{
  "formatVersion": "1.0",
  "exportDate": "2025-12-04T22:00:30.889Z",
  "appVersion": "1.0.0",
  "curriculumData": {
    "metadata": {
      "baseOn": "Catálogo dos Cursos de Graduação 2025 - SI-22",
      "lastUpdated": "2025-12-04",
      "totalAtomicSkills": 382
    },
    "areas": [
      {
        "id": "10",
        "name": "Computação",
        "description": "Área de Computação do curso SI-22, abrangendo fundamentos de programação e desenvolvimento de software.",
        "disciplines": [
          {
            "id": "10.1",
            "name": "Programação Orientada a Objetos",
            "description": "instâncias e métodos. Abstração, herança, encapsulamento e polimorfismo. Características de linguagens de tipagem estática e dinâmica. Tipos de dados e operadores. Métodos e variáveis estáticas. Estruturas de dados orientadas a objetos e tipos genéricos. Tratamento de exceção. Linguagem Unificada de Modelagem (UML). Padrões Básicos de Projeto. Programação de interfaces GUI.",
            "mainTopics": [
              {
                "id": "10.1.1",
                "name": "Instâncias e Métodos",
                "description": "Introdução às instâncias de classes e definição de métodos em programação orientada a objetos.",
                "totalSkills": 44,
                "atomicTopics": [
                  {
                    "id": "10.1.1.1",
                    "name": "Definição de Instância de Classe",
                    "description": "Conceito de instância como um objeto criado a partir de uma classe, representando uma entidade concreta em memória.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.1.1",
                        "name": "Classe como Molde Abstrato",
                        "description": "A classe é uma estrutura que define as propriedades e comportamentos comuns para objetos, atuando como um blueprint ou template para a criação de instâncias.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.1.1",
                            "name": "Definir o conceito de classe",
                            "description": "Explicar que uma classe é uma abstração que encapsula atributos e métodos, servindo como modelo para instâncias em linguagens como Python ou C++.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Abstração em Programação",
                                  "subSteps": [
                                    "Leia definições de abstração em programação de fontes confiáveis como documentação oficial do Python.",
                                    "Compare abstração com exemplos cotidianos, como um blueprint de uma casa que não é a casa em si.",
                                    "Anote as características principais: simplificação de complexidade e foco no essencial.",
                                    "Discuta com um colega ou em fórum por que abstração é fundamental na OOP.",
                                    "Crie um diagrama mental ligando abstração a conceitos reais."
                                  ],
                                  "verification": "Você pode explicar abstração sem usar termos técnicos excessivos e dar um exemplo não-programático.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Python OOP",
                                    "Papel e caneta para diagrama",
                                    "Vídeo introdutório sobre OOP (5 min)"
                                  ],
                                  "tips": "Use analogias simples como 'receita de bolo' para fixar o conceito.",
                                  "learningObjective": "Definir abstração como mecanismo para representar entidades complexas de forma simplificada.",
                                  "commonMistakes": [
                                    "Confundir abstração com ocultação de detalhes (é mais ampla)",
                                    "Ignorar o aspecto de modelo genérico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Atributos e Métodos",
                                  "subSteps": [
                                    "Estude a diferença: atributos (dados/estado) vs. métodos (comportamentos/ações).",
                                    "Liste 3 exemplos de atributos e métodos para uma entidade real, como 'Carro'.",
                                    "Analise código simples em Python: class Exemplo: def __init__(self): self.atributo = valor.",
                                    "Escreva pseudocódigo separando atributos e métodos explicitamente.",
                                    "Teste mentalmente: 'O que armazena dados? O que executa ações?'."
                                  ],
                                  "verification": "Crie uma tabela comparando atributos e métodos com exemplos corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto como VS Code",
                                    "Documentação Python classes",
                                    "Exemplos de código OOP básicos"
                                  ],
                                  "tips": "Lembre: atributos são como 'propriedades' de um objeto; métodos são 'ações' que ele pode fazer.",
                                  "learningObjective": "Distinguir atributos (variáveis de instância) de métodos (funções de instância).",
                                  "commonMistakes": [
                                    "Chamar métodos de 'atributos funcionais'",
                                    "Esquecer que métodos podem acessar/modificar atributos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Encapsulamento e Classe como Molde",
                                  "subSteps": [
                                    "Aprenda encapsulamento: agrupar atributos e métodos relacionados em uma unidade.",
                                    "Desenhe um diagrama UML simples de uma classe com atributos e métodos.",
                                    "Entenda 'molde': classe define estrutura, instâncias são cópias concretas.",
                                    "Compare com fábrica: classe é máquina, instâncias são produtos fabricados.",
                                    "Escreva uma definição pessoal: 'Classe é [sua frase].'."
                                  ],
                                  "verification": "Desenhe e explique um diagrama de classe que mostre encapsulamento.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama online como draw.io",
                                    "Tutoriais UML básicos",
                                    "Livro ou PDF sobre OOP"
                                  ],
                                  "tips": "Pense na classe como um 'cookie cutter': define forma, mas não é o cookie.",
                                  "learningObjective": "Reconhecer classe como estrutura encapsulada que serve de molde para múltiplas instâncias.",
                                  "commonMistakes": [
                                    "Confundir classe com instância única",
                                    "Subestimar o papel do encapsulamento na organização"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Conceito com Exemplos em Linguagens",
                                  "subSteps": [
                                    "Escreva uma classe simples em Python: class Pessoa: com atributos nome e idade, método saudar().",
                                    "Compare sintaxe Python vs. C++: class em C++ requer ; e public/private.",
                                    "Crie 2 instâncias da classe e chame métodos para verificar.",
                                    "Explique verbalmente ou por escrito como a classe abstrai e gera instâncias.",
                                    "Refatore um código procedural para orientado a objetos usando classes."
                                  ],
                                  "verification": "Execute código com classe e instâncias sem erros, explicando cada parte.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python instalado ou Replit online",
                                    "Compilador C++ opcional",
                                    "Exemplos de código prontos para referência"
                                  ],
                                  "tips": "Comece com Python por ser mais simples; foque no conceito, não na sintaxe avançada.",
                                  "learningObjective": "Implementar e explicar uma classe em pelo menos uma linguagem, ligando à definição conceitual.",
                                  "commonMistakes": [
                                    "Esquecer __init__ em Python",
                                    "Criar instância sem classe definida"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe 'Carro' em Python: class Carro: def __init__(self, cor, modelo): self.cor = cor; self.modelo = modelo; def acelerar(self): print('Acelerando!'). Instâncias: meu_carro = Carro('azul', 'Fusca'); meu_carro.acelerar(). Aqui, Carro encapsula atributos (cor, modelo) e método (acelerar), servindo de molde para múltiplos carros.",
                              "finalVerifications": [
                                "Explique verbalmente o que é uma classe em 1 minuto sem hesitação.",
                                "Diferencie classe de instância com exemplos concretos.",
                                "Identifique atributos e métodos em um código OOP fornecido.",
                                "Desenhe um diagrama de classe UML básico.",
                                "Crie uma classe simples funcional em Python.",
                                "Compare classes em Python e C++."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição: inclui abstração, encapsulamento, atributos/métodos e molde para instâncias (peso 30%).",
                                "Uso de exemplos relevantes e corretos em linguagens (peso 25%).",
                                "Capacidade de diferenciar classe de objeto/instância (peso 20%).",
                                "Clareza em analogias cotidianas (peso 15%).",
                                "Implementação prática sem erros sintáticos (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos abstratos como funções e conjuntos.",
                                "Biologia: Classificação taxonômica (gênero como classe, espécies como instâncias).",
                                "Física: Modelos teóricos (equações como classes para simulações).",
                                "Design: Blueprints arquitetônicos como moldes para construções."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, classes modelam entidades como 'Conta Bancária' (atributos: saldo; métodos: depositar()), permitindo criar múltiplas contas seguras e reutilizáveis, essencial em apps bancários, jogos (classes Jogador) e sistemas empresariais."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.2",
                            "name": "Identificar elementos de uma classe",
                            "description": "Reconhecer atributos (variáveis de instância) e métodos (funções) declarados dentro de uma classe, diferenciando-os de elementos estáticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a estrutura básica de uma classe",
                                  "subSteps": [
                                    "Analise a sintaxe geral de uma classe em uma linguagem OOP como Python ou Java.",
                                    "Identifique as palavras-chave como 'class' e o corpo delimitado por chaves ou indentação.",
                                    "Observe a posição dos elementos dentro do corpo da classe.",
                                    "Diferencie o cabeçalho da classe do seu conteúdo interno.",
                                    "Anote exemplos de classes vazias para fixar a estrutura."
                                  ],
                                  "verification": "Desenhe ou escreva a estrutura esquelética de uma classe corretamente sem erros de sintaxe.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou IDLE)",
                                    "Documentação oficial de Python/Java sobre classes"
                                  ],
                                  "tips": "Sempre leia a classe de cima para baixo para captar a hierarquia.",
                                  "learningObjective": "Compreender a anatomia fundamental de uma classe OOP.",
                                  "commonMistakes": [
                                    "Confundir declaração de classe com funções standalone",
                                    "Ignorar indentação ou chaves no corpo da classe"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar atributos (variáveis de instância)",
                                  "subSteps": [
                                    "Procure por declarações de variáveis dentro do corpo da classe, sem modificador 'static'.",
                                    "Note que atributos de instância são acessados via objeto (ex: obj.atributo).",
                                    "Classifique variáveis por seu escopo: públicas, privadas (com _ ou private).",
                                    "Compare com variáveis locais de métodos para diferenciar.",
                                    "Liste todos os atributos em um exemplo de código fornecido."
                                  ],
                                  "verification": "Extraia e liste corretamente todos os atributos de instância de um código de classe exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de código de classes com atributos",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Atributos de instância definem o 'estado' único de cada objeto.",
                                  "learningObjective": "Reconhecer e classificar variáveis de instância em uma classe.",
                                  "commonMistakes": [
                                    "Confundir atributos com parâmetros de métodos",
                                    "Considerar variáveis estáticas como de instância"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar métodos (funções de instância)",
                                  "subSteps": [
                                    "Localize definições de funções dentro da classe, sem 'static'.",
                                    "Identifique o 'self' (Python) ou 'this' implícito (Java) como indicador de método de instância.",
                                    "Distinga métodos do construtor (ex: __init__ ou constructor).",
                                    "Verifique se o método acessa atributos de instância.",
                                    "Marque todos os métodos em um diagrama da classe."
                                  ],
                                  "verification": "Identifique e descreva o propósito de cada método de instância em um código exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código fonte com classes complexas",
                                    "Ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Métodos de instância definem o 'comportamento' dos objetos.",
                                  "learningObjective": "Reconhecer métodos de instância e seu papel na classe.",
                                  "commonMistakes": [
                                    "Confundir métodos com funções globais",
                                    "Ignorar o primeiro parâmetro 'self'"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar elementos de instância de elementos estáticos",
                                  "subSteps": [
                                    "Compare atributos/métodos com e sem 'static'.",
                                    "Teste conceitualmente: elementos estáticos pertencem à classe, não ao objeto.",
                                    "Analise exemplos onde static é usado (contadores, utilitários).",
                                    "Crie uma tabela comparativa: instância vs estático.",
                                    "Aplique em código real, removendo static para observar mudanças."
                                  ],
                                  "verification": "Classifique todos os elementos de uma classe como instância ou estático com 100% de acerto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código com mistura de static e não-static",
                                    "Tabela comparativa em planilha"
                                  ],
                                  "tips": "Elementos estáticos não precisam de instância para acesso.",
                                  "learningObjective": "Diferenciar precisamente elementos dinâmicos de estáticos em classes.",
                                  "commonMistakes": [
                                    "Achar que todos os elementos dentro da classe são de instância",
                                    "Confundir static com global"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a classe em Python:\nclass Carro:\n    rodas = 4  # atributo estático\n    def __init__(self, cor):  # construtor\n        self.cor = cor  # atributo de instância\n    def acelerar(self):  # método de instância\n        print('Acelerando...')\n    @staticmethod\n    def info_fabricante():\n        return 'Toyota'\nAqui, 'cor' é atributo de instância, 'acelerar' é método de instância, 'rodas' e 'info_fabricante' são estáticos.",
                              "finalVerifications": [
                                "Liste corretamente atributos e métodos de instância de uma classe exemplo.",
                                "Explique a diferença entre self.cor e rodas em um objeto Carro().",
                                "Identifique erros em classificações de elementos estáticos vs instância.",
                                "Crie um diagrama UML simples destacando elementos de instância.",
                                "Responda quiz com 90% de acerto sobre identificação em código.",
                                "Diferencie acesso: Carro.rodas vs carro.cor"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de atributos de instância (sem incluir estáticos).",
                                "Correta distinção de métodos de instância vs estáticos.",
                                "Explicação clara do papel de cada elemento identificado.",
                                "Uso correto de terminologia OOP (atributo, método, instância, estático).",
                                "Capacidade de aplicar em código novo sem orientação.",
                                "Ausência de confusão com elementos locais ou globais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Analogia com funções e variáveis em equações parametrizadas.",
                                "Biologia: Classes como 'molde genético' para organismos (instâncias).",
                                "Língua Portuguesa: Estrutura sintática similar a parágrafos com sujeito (atributos) e verbo (métodos).",
                                "Design: Modelagem de objetos como blueprints arquitetônicos.",
                                "Física: Propriedades (atributos) e ações (métodos) de partículas."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, como apps de e-commerce, identificar elementos de classe permite criar objetos personalizados (ex: carrinho de compras com atributos únicos como itens do usuário e métodos como adicionarItem()), otimizando código reutilizável em equipes de programação."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.3",
                            "name": "Exemplificar classes simples",
                            "description": "Criar ou analisar um exemplo de classe básica, como uma classe 'Carro' com atributos como 'cor' e método 'acelerar', sem instanciá-la.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de classe como molde abstrato",
                                  "subSteps": [
                                    "Ler a definição de classe em Programação Orientada a Objetos (OOP).",
                                    "Identificar que uma classe é um blueprint ou molde para criar objetos, sem instanciá-la.",
                                    "Diferenciar classe (abstrata) de instância (objeto concreto).",
                                    "Estudar a sintaxe básica de declaração de classe em Python: 'class NomeClasse:'",
                                    "Analisar um diagrama UML simples de uma classe."
                                  ],
                                  "verification": "Explicar em 3 frases o que é uma classe e sua diferença para um objeto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial Python OOP",
                                    "Vídeo tutorial sobre classes (5-10 min)",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Visualize a classe como uma forma de bolo: define o formato, mas não cria o bolo.",
                                  "learningObjective": "Dominar o conceito fundamental de classe como estrutura abstrata.",
                                  "commonMistakes": [
                                    "Confundir classe com objeto instanciado",
                                    "Acreditar que a classe executa código sozinha",
                                    "Ignorar indentação na sintaxe"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Planejar atributos e métodos da classe Carro",
                                  "subSteps": [
                                    "Listar atributos relevantes para um carro: cor, modelo, ano.",
                                    "Definir métodos úteis: acelerar(), frear(), buzinar().",
                                    "Esboçar a estrutura em pseudocódigo ou diagrama.",
                                    "Decidir quais atributos serão iniciais (via __init__).",
                                    "Garantir que não haja instância no planejamento."
                                  ],
                                  "verification": "Criar um esboço escrito ou diagrama com pelo menos 3 atributos e 2 métodos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para esboço",
                                    "Editor de texto simples",
                                    "Exemplos de classes online"
                                  ],
                                  "tips": "Comece com o mundo real: o que um carro tem e faz?",
                                  "learningObjective": "Planejar componentes de uma classe de forma lógica e organizada.",
                                  "commonMistakes": [
                                    "Incluir código de instância no planejamento",
                                    "Escolher atributos irrelevantes",
                                    "Métodos sem lógica clara"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a classe Carro em código",
                                  "subSteps": [
                                    "Escrever a declaração: class Carro:",
                                    "Adicionar o método __init__ com atributos como cor.",
                                    "Definir métodos como acelerar() que imprima uma mensagem.",
                                    "Garantir indentação correta e sem criação de objetos.",
                                    "Salvar e validar sintaxe no interpretador Python."
                                  ],
                                  "verification": "Executar o código sem erros e ler a definição da classe.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou IDLE)",
                                    "Interpretador Python",
                                    "Notebook Jupyter opcional"
                                  ],
                                  "tips": "Use print() nos métodos para testar sem instanciar.",
                                  "learningObjective": "Codificar uma classe funcional com atributos e métodos básicos.",
                                  "commonMistakes": [
                                    "Erro de indentação",
                                    "Esquecer self nos atributos",
                                    "Instanciar acidentalmente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e refinar o exemplo de classe",
                                  "subSteps": [
                                    "Explicar cada linha do código criado.",
                                    "Identificar como a classe serve de molde.",
                                    "Testar modificações: adicionar um atributo ou método.",
                                    "Comparar com outro exemplo simples, como 'Pessoa'.",
                                    "Documentar o que foi aprendido."
                                  ],
                                  "verification": "Reescrever a classe com uma pequena modificação e explicar mudanças.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código salvo do step 3",
                                    "Bloco de notas para análise"
                                  ],
                                  "tips": "Pergunte: 'Essa classe pode gerar múltiplos carros idênticos?'",
                                  "learningObjective": "Analisar criticamente uma classe para compreensão profunda.",
                                  "commonMistakes": [
                                    "Não entender o papel do self",
                                    "Ignorar herança futura",
                                    "Focar só no código, não no conceito"
                                  ]
                                }
                              ],
                              "practicalExample": "class Carro:\n    def __init__(self, cor, modelo):\n        self.cor = cor\n        self.modelo = modelo\n    \n    def acelerar(self):\n        print(f'O {self.modelo} está acelerando!')\n    \n    def frear(self):\n        print(f'O {self.modelo} está freando.')",
                              "finalVerifications": [
                                "Definir corretamente uma classe com __init__ e pelo menos um método.",
                                "Explicar o papel de 'self' em atributos e métodos.",
                                "Identificar que a classe é um molde sem instância.",
                                "Modificar a classe adicionando um atributo sem erros.",
                                "Comparar com exemplo similar sem copiar código.",
                                "Executar definição da classe sem syntax error."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe Python 100% correta e indentada.",
                                "Atributos e métodos relevantes ao tema 'Carro'.",
                                "Ausência total de instâncias ou chamadas de métodos.",
                                "Explicação clara do conceito em análise.",
                                "Estrutura lógica e comentada no código.",
                                "Capacidade de refatorar com adições simples."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem abstrata e funções como métodos.",
                                "Física: Simulação de comportamentos de veículos reais.",
                                "Língua Portuguesa: Estruturação de textos descritivos em documentação.",
                                "Artes: Design de blueprints e diagramas UML."
                              ],
                              "realWorldApplication": "Classes como 'Carro' são usadas em simuladores de jogos (ex: Unity), sistemas de gerenciamento de frotas (ex: apps de delivery) e softwares de engenharia automotiva para modelar entidades reais sem criar instâncias desnecessárias, otimizando memória e lógica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.2",
                        "name": "Instância como Objeto Concreto",
                        "description": "Uma instância é um objeto específico criado a partir da classe, alocado em memória, com seu próprio estado único representando uma entidade real.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.2.1",
                            "name": "Definir o conceito de instância",
                            "description": "Descrever uma instância como uma entidade concreta em memória, derivada de uma classe, com valores específicos para seus atributos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito base de classe como molde",
                                  "subSteps": [
                                    "Revise a definição de uma classe: um blueprint ou molde que define atributos e métodos.",
                                    "Identifique exemplos cotidianos de classes, como 'Carro' definindo cor, modelo e marca.",
                                    "Escreva pseudocódigo de uma classe simples sem criar instâncias.",
                                    "Explique verbalmente ou por escrito o papel da classe como estrutura abstrata.",
                                    "Compare classe a um projeto arquitetônico versus a casa construída."
                                  ],
                                  "verification": "Escreva uma definição de classe em suas próprias palavras e crie um exemplo pseudocódigo simples.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Caderno ou editor de texto simples (ex: Notepad++), documentação de POO básica.",
                                  "tips": "Use analogias reais como 'receita de bolo' para classe para fixar o conceito abstrato.",
                                  "learningObjective": "Compreender que uma classe é uma definição abstrata, não um objeto utilizável.",
                                  "commonMistakes": "Confundir classe com instância desde o início; assumir que classe já tem dados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar classe de instância conceitualmente",
                                  "subSteps": [
                                    "Defina instância como uma concretização da classe em memória com valores específicos.",
                                    "Desenhe um diagrama: classe no topo, múltiplas instâncias abaixo com atributos preenchidos.",
                                    "Liste diferenças chave: classe é única e abstrata; instâncias são múltiplas e concretas.",
                                    "Explique alocação em memória: cada instância ocupa espaço separado.",
                                    "Crie uma tabela comparativa: Classe vs Instância (ex: molde vs objeto moldado)."
                                  ],
                                  "verification": "Crie um diagrama ou tabela que destaque pelo menos 4 diferenças claras entre classe e instância.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou ferramenta de diagrama como Draw.io, acesso a internet para imagens de analogias.",
                                  "tips": "Pense em 'classe Cachorro' vs instâncias 'Rex' (preto, 5 anos) e 'Fido' (branco, 2 anos).",
                                  "learningObjective": "Distinguir instância como entidade concreta derivada da classe com identidade única.",
                                  "commonMistakes": "Achar que instância é só um nome diferente para classe; ignorar valores específicos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar e observar uma instância em código",
                                  "subSteps": [
                                    "Escolha uma linguagem POO como Python e defina uma classe simples com atributos.",
                                    "Crie uma instância usando o construtor (ex: obj = MinhaClasse(valor1, valor2)).",
                                    "Acesse e imprima atributos da instância para ver valores específicos.",
                                    "Crie uma segunda instância com valores diferentes e compare saídas.",
                                    "Use print(id(obj)) para verificar endereços de memória únicos."
                                  ],
                                  "verification": "Execute código que cria duas instâncias diferentes da mesma classe e exibe seus atributos e IDs de memória.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código (VS Code ou PyCharm), Python instalado, terminal para execução.",
                                  "tips": "Sempre inicialize atributos no __init__ para evitar valores None inesperados.",
                                  "learningObjective": "Aplicar o conceito criando instâncias reais e observando suas propriedades únicas.",
                                  "commonMistakes": "Esquecer de passar argumentos no construtor; confundir atributos de classe com de instância."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reforçar com múltiplas instâncias e reflexão",
                                  "subSteps": [
                                    "Crie um programa com lista de instâncias da mesma classe.",
                                    "Modifique atributos de uma instância e verifique que outras não mudam.",
                                    "Explique por que cada instância mantém seus valores independentes.",
                                    "Reflita: como isso resolve problemas no mundo real (ex: múltiplos usuários).",
                                    "Documente o ciclo: classe define -> instância aloca -> valores personalizados."
                                  ],
                                  "verification": "Desenvolva um script com 3+ instâncias, modifique uma e confirme independência das outras.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Mesmo ambiente de codificação do step anterior, caderno para anotações reflexivas.",
                                  "tips": "Teste mutabilidade: instâncias compartilham métodos, mas não estado mutável por padrão.",
                                  "learningObjective": "Internalizar instâncias como entidades independentes em memória com estados únicos.",
                                  "commonMistakes": "Usar variáveis de classe em vez de instância, causando compartilhamento indesejado."
                                }
                              ],
                              "practicalExample": "Em Python: class Carro: def __init__(self, marca, cor): self.marca = marca; self.cor = cor. Então, carro1 = Carro('Toyota', 'vermelho'); carro2 = Carro('Ford', 'azul'). Aqui, carro1 e carro2 são instâncias concretas com valores específicos, ocupando memórias separadas.",
                              "finalVerifications": [
                                "Explicar verbalmente a diferença entre classe e instância sem hesitação.",
                                "Criar código funcional com pelo menos duas instâncias independentes.",
                                "Identificar IDs de memória únicos para múltiplas instâncias.",
                                "Desenhar diagrama correto de classe e suas instâncias.",
                                "Listar 3 exemplos reais de classes e instâncias do dia a dia.",
                                "Responder quiz: 'O que acontece se modificar atributo de uma instância?'"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição: instância como entidade concreta com valores específicos (peso 25%).",
                                "Demonstração prática: código executável com instâncias independentes (peso 30%).",
                                "Compreensão conceitual: diagramas e comparações claras (peso 20%).",
                                "Reflexão: explicação de independência em memória (peso 15%).",
                                "Criatividade: exemplos relevantes e variados (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: instância como valor específico de uma função genérica.",
                                "Biologia: classe como espécie, instância como indivíduo com traços únicos.",
                                "Física: classe como lei geral, instância como partícula com propriedades medidas.",
                                "Língua Portuguesa: classe como substantivo abstrato, instância como concreto nomeado."
                              ],
                              "realWorldApplication": "Em apps como bancos online, cada 'ContaCorrente' é uma classe, e contas de usuários reais (ex: João com saldo 1000, Maria com 500) são instâncias independentes, permitindo transações personalizadas sem afetar outras."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.1.2.2",
                            "name": "Diferenciar classe de instância",
                            "description": "Comparar classe (abstração única) versus instância (múltiplas cópias concretas em memória), usando exemplos como 'Classe Cachorro' vs. instâncias 'Rex' e 'Fido'.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Classe",
                                  "subSteps": [
                                    "Leia a definição: Uma classe é um blueprint ou molde abstrato que define atributos (dados) e métodos (comportamentos) para objetos.",
                                    "Identifique características principais: Existe apenas uma cópia única na memória, não ocupa espaço para dados específicos.",
                                    "Estude exemplos simples: 'Classe Cachorro' define atributos como 'raca', 'cor' e método 'latir()'.",
                                    "Use analogias: Compare com uma 'receita de bolo' que descreve ingredientes e passos, mas não é o bolo pronto.",
                                    "Anote diferenças iniciais de objetos concretos."
                                  ],
                                  "verification": "Escreva uma definição da classe em suas palavras e crie um exemplo fictício não relacionado a animais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook para anotações",
                                    "Artigo ou vídeo introdutório sobre OOP (ex: documentação Python classes)"
                                  ],
                                  "tips": "Sempre pense na classe como um 'template' genérico, não algo específico.",
                                  "learningObjective": "Definir classe como abstração única e identificar suas componentes principais.",
                                  "commonMistakes": [
                                    "Confundir classe com um objeto executável",
                                    "Achar que classes armazenam dados de múltiplos objetos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o Conceito de Instância",
                                  "subSteps": [
                                    "Defina instância: Uma instância (objeto) é uma cópia concreta criada a partir da classe, com seus próprios valores de atributos.",
                                    "Entenda criação: Usa-se um construtor (ex: new em Java ou () em Python) para alocar memória separada.",
                                    "Examine múltiplas instâncias: Da mesma classe, podem existir várias, cada uma independente (ex: 'Rex' e 'Fido' da classe Cachorro).",
                                    "Analogie: Instâncias são 'bolos assados' a partir da receita, cada um com variações.",
                                    "Observe memória: Cada instância tem endereço único na memória."
                                  ],
                                  "verification": "Desenhe um diagrama simples mostrando uma classe e duas instâncias com atributos diferentes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Editor de código simples para visualizar sintaxe"
                                  ],
                                  "tips": "Lembre-se: instâncias são 'vivas' na memória durante execução do programa.",
                                  "learningObjective": "Explicar instância como objeto concreto múltiplo e processo de instanciação.",
                                  "commonMistakes": [
                                    "Pensar que instância é a classe em si",
                                    "Confundir atributos da classe com atributos da instância"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Classe versus Instância",
                                  "subSteps": [
                                    "Liste diferenças chave: Classe = 1 abstração única (sem dados próprios); Instância = múltiplas cópias concretas (com dados próprios).",
                                    "Use tabela comparativa: Colunas para 'Classe' (única, blueprint) vs 'Instância' (múltiplas, concreta).",
                                    "Aplique exemplo dado: 'Classe Cachorro' (abstração) vs 'Rex' e 'Fido' (instâncias com raças específicas).",
                                    "Questione cenários: O que acontece se modificar atributo de uma instância? (Só afeta ela).",
                                    "Reforce com pseudocódigo: class Cachorro {} rex = new Cachorro(); fido = new Cachorro();"
                                  ],
                                  "verification": "Preencha uma tabela comparativa com pelo menos 5 diferenças e explique verbalmente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Pseudocódigo ou snippet de código OOP"
                                  ],
                                  "tips": "Foque em 'única vs múltiplas' e 'abstração vs concreto' como diferenciais principais.",
                                  "learningObjective": "Diferenciar precisamente classe de instância usando critérios claros.",
                                  "commonMistakes": [
                                    "Achar que classes são instâncias especiais",
                                    "Ignorar alocação de memória separada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Diferenciação com Exemplos",
                                  "subSteps": [
                                    "Crie código simples: Defina classe 'Carro' e crie 3 instâncias com atributos diferentes.",
                                    "Execute e observe: Verifique memória/ID das instâncias (ex: print(id(obj)) em Python).",
                                    "Analise erros comuns: Tente modificar classe como instância e veja falha.",
                                    "Compare em diagramas UML: Desenhe classe e suas instâncias.",
                                    "Teste quiz autoavaliação: Identifique classe/instância em snippets de código."
                                  ],
                                  "verification": "Produza código funcional com classe e instâncias, explicando cada elemento.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code, Replit)",
                                    "Referência UML básica para classes"
                                  ],
                                  "tips": "Use console para inspecionar objetos e confirmar independência.",
                                  "learningObjective": "Aplicar diferenciação em prática de programação real.",
                                  "commonMistakes": [
                                    "Criar instância sem classe definida",
                                    "Confundir métodos de classe com métodos de instância"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python:\nclass Cachorro:\n    def __init__(self, nome, raca):\n        self.nome = nome\n        self.raca = raca\n    def latir(self):\n        print(f'{self.nome} late!')\n\nrex = Cachorro('Rex', 'Pastor Alemão')  # Instância 1\nfido = Cachorro('Fido', 'Labrador')     # Instância 2\n\nrex.latir()  # Saída: Rex late!\n# rex e fido são instâncias independentes; Cachorro é a classe única.",
                              "finalVerifications": [
                                "Explique a diferença entre classe e instância sem olhar notas.",
                                "Identifique corretamente classe e instâncias em um snippet de código fornecido.",
                                "Crie um diagrama mostrando uma classe com 2 instâncias e seus atributos únicos.",
                                "Descreva o que acontece na memória ao criar múltiplas instâncias.",
                                "Diferencie usando analogia não-OOP (ex: molde vs produtos moldados).",
                                "Responda quiz: 'Qual é único na memória? Classe ou instância?'",
                                "Compare com exemplo real: classe 'ContaBancaria' vs instâncias de clientes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição: Distingue abstração única vs concretas múltiplas (peso 25%).",
                                "Uso correto de exemplos: Aplica 'Cachorro/Rex/Fido' ou similar (20%).",
                                "Compreensão de memória: Explica alocação separada (20%).",
                                "Capacidade de diagramação/código: Produz representações claras (20%).",
                                "Aplicação em cenários novos: Generaliza para outros domínios (15%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Classe como conjunto abstrato, instância como elemento concreto do conjunto.",
                                "Biologia: Classe como espécie (abstração), instância como indivíduo específico.",
                                "Linguística: Classe como substantivo comum genérico, instância como nome próprio particular.",
                                "Filosofia: Classe como forma platônica (ideal), instância como manifestação concreta.",
                                "Engenharia: Classe como projeto técnico, instância como protótipo fabricado."
                              ],
                              "realWorldApplication": "Em desenvolvimento de jogos, a classe 'Personagem' define atributos como vida e movimento; instâncias são heróis e inimigos específicos na tela, cada um com vida independente, permitindo simulações realistas de batalhas."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.1.2.3",
                            "name": "Reconhecer estado da instância",
                            "description": "Identificar que cada instância mantém seu próprio estado (valores de atributos) independentemente de outras instâncias da mesma classe.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de estado em instâncias",
                                  "subSteps": [
                                    "Defina o que é 'estado' em programação orientada a objetos: valores dos atributos de um objeto.",
                                    "Explique que o estado é único para cada instância de uma classe.",
                                    "Diferencie estado (atributos) de comportamento (métodos).",
                                    "Leia exemplos simples em documentação de linguagens OOP como Python ou Java.",
                                    "Anote diferenças entre classe (molde) e instância (objeto concreto)."
                                  ],
                                  "verification": "Escreva uma definição curta do estado de instância e dê um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de Python/Java OOP",
                                    "Caderno para anotações"
                                  ],
                                  "tips": "Use analogias como 'classe é receita, instância é bolo pronto com ingredientes específicos'.",
                                  "learningObjective": "Identificar o estado como valores independentes de atributos em cada instância.",
                                  "commonMistakes": [
                                    "Confundir estado com métodos da classe",
                                    "Pensar que todas as instâncias compartilham o mesmo estado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar uma classe simples com atributos e instanciar múltiplos objetos",
                                  "subSteps": [
                                    "Defina uma classe simples, ex: 'Carro' com atributos 'cor' e 'velocidade'.",
                                    "Crie duas instâncias da classe: carro1 e carro2.",
                                    "Inicialize atributos diferentes para cada instância.",
                                    "Imprima os atributos iniciais de ambas as instâncias.",
                                    "Confirme que os valores são independentes no código."
                                  ],
                                  "verification": "Execute o código e verifique que os atributos impressos são únicos para cada instância.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, PyCharm)",
                                    "Interpretador Python ou compilador Java"
                                  ],
                                  "tips": "Use print() para visualizar estados imediatamente após instanciação.",
                                  "learningObjective": "Demonstrar criação de instâncias com estados iniciais independentes.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar atributos no construtor",
                                    "Usar variáveis globais em vez de atributos de instância"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modificar o estado de uma instância e observar independência",
                                  "subSteps": [
                                    "Altere o atributo de uma instância apenas (ex: carro1.velocidade = 100).",
                                    "Imprima o estado de carro1 e carro2 após a alteração.",
                                    "Confirme que apenas carro1 mudou.",
                                    "Repita com outra instância para reforçar.",
                                    "Adicione um método getter para acessar estados de forma controlada."
                                  ],
                                  "verification": "Compare saídas de print antes e depois: apenas a instância modificada deve mudar.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código do step anterior",
                                    "Editor de código"
                                  ],
                                  "tips": "Evite modificar atributos estáticos da classe, foque em de instância.",
                                  "learningObjective": "Verificar que alterações em uma instância não afetam outras.",
                                  "commonMistakes": [
                                    "Declarar atributos como static/class-level",
                                    "Confundir self/this com variáveis locais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e comparar estados de múltiplas instâncias",
                                  "subSteps": [
                                    "Crie um método na classe para exibir o estado completo.",
                                    "Chame o método em todas as instâncias após várias modificações.",
                                    "Crie uma lista de instâncias e itere imprimindo estados.",
                                    "Discuta por que cada instância mantém seu estado único.",
                                    "Refatore o código para incluir validações de estado."
                                  ],
                                  "verification": "Gere relatório comparativo dos estados e confirme independência.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código expandido",
                                    "Editor de código"
                                  ],
                                  "tips": "Use loops para simular cenários com muitas instâncias.",
                                  "learningObjective": "Analisar e comprovar independência de estados em escala.",
                                  "commonMistakes": [
                                    "Compartilhar referências entre instâncias acidentalmente",
                                    "Ignorar mutabilidade de objetos mutáveis como listas"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe 'ContaBancaria' com atributo 'saldo'. Instancie conta1 (saldo=1000) e conta2 (saldo=500). Deposite 200 em conta1. Imprima saldos: conta1 deve ter 1200, conta2 permanece 500, provando estados independentes.",
                              "finalVerifications": [
                                "Explicar em palavras próprias por que instâncias têm estados independentes.",
                                "Executar código com 3+ instâncias, modificar uma e confirmar isolamento.",
                                "Identificar em código fornecido quais atributos são de instância vs. classe.",
                                "Criar diagrama UML simples mostrando estados únicos.",
                                "Responder quiz: 'O que acontece com instância B se alterar A?'",
                                "Debugar código onde estado parece compartilhado e corrigir."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e exemplos de estado independente (80%+ acerto).",
                                "Código funcional sem erros de compartilhamento de estado.",
                                "Explicações claras e uso correto de terminologia OOP.",
                                "Criatividade em exemplos práticos e analogias.",
                                "Capacidade de debug e correção de erros comuns.",
                                "Tempo de execução dentro dos estimados com maestria demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Variáveis independentes em equações e funções.",
                                "Biologia: Características genéticas individuais em uma população.",
                                "Física: Propriedades únicas de partículas em um sistema.",
                                "Língua Portuguesa: Substantivos próprios vs. comuns em contextos.",
                                "História: Estados individuais de nações em alianças internacionais."
                              ],
                              "realWorldApplication": "Em aplicativos bancários, cada conta de usuário mantém saldo independente; alterar uma não afeta outras, garantindo privacidade e integridade financeira."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.3",
                        "name": "Processo de Criação de Instância",
                        "description": "O processo de instanciar uma classe envolve a alocação de memória para um novo objeto e a inicialização de seus atributos, tipicamente via construtor.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.3.1",
                            "name": "Explicar o processo de instanciamento",
                            "description": "Descrever as etapas: chamada do construtor, alocação de memória e retorno da referência ao objeto, em contextos de Python (ex: obj = MinhaClasse()) ou C++ (ex: MinhaClasse* obj = new MinhaClasse()).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais do Instanciamento",
                                  "subSteps": [
                                    "Defina instanciamento como o processo de criar um objeto a partir de uma classe.",
                                    "Explique alocação de memória: reserva de espaço na heap ou stack para os atributos do objeto.",
                                    "Descreva o papel do construtor: método especial chamado automaticamente para inicializar o objeto.",
                                    "Discuta o retorno da referência: um ponteiro ou handle que permite acessar o objeto criado.",
                                    "Identifique que o processo é similar em linguagens OO, mas com sintaxes diferentes."
                                  ],
                                  "verification": "Resuma os quatro conceitos principais em suas próprias palavras sem consultar notas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação oficial de Python (docs.python.org) e C++ (cppreference.com), quadro branco ou papel para diagramas.",
                                  "tips": "Use diagramas de memória (setas para referências) para visualizar o processo.",
                                  "learningObjective": "Identificar e explicar os componentes essenciais do instanciamento em OOP.",
                                  "commonMistakes": [
                                    "Confundir construtor com método comum.",
                                    "Ignorar diferenças entre stack e heap.",
                                    "Achar que instanciamento só aloca memória sem inicialização."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Processo de Instanciamento em Python",
                                  "subSteps": [
                                    "Escreva o código: obj = MinhaClasse() e execute em um interpretador.",
                                    "Observe a alocação: Python gerencia automaticamente na heap.",
                                    "Verifique a chamada do __init__: construtor que inicializa atributos.",
                                    "Trace o retorno: obj recebe uma referência ao novo objeto.",
                                    "Use id(obj) e sys.getsizeof() para inspecionar memória e identidade."
                                  ],
                                  "verification": "Execute o código e explique o output de print(id(obj)) antes/depois da criação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor Python (IDLE ou VS Code), módulo sys.",
                                  "tips": "Adicione print statements no __init__ para ver a execução em tempo real.",
                                  "learningObjective": "Descrever sequencialmente o instanciamento em Python com evidências empíricas.",
                                  "commonMistakes": [
                                    "Esquecer que Python é garbage-collected, sem necessidade de delete.",
                                    "Confundir self com a referência retornada.",
                                    "Não distinguir __new__ de __init__."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Processo de Instanciamento em C++",
                                  "subSteps": [
                                    "Escreva o código: MinhaClasse* obj = new MinhaClasse(); e compile/executar.",
                                    "Explique alocação manual: new reserva na heap e chama construtor.",
                                    "Detalhe o construtor padrão ou customizado para inicialização.",
                                    "Trace o retorno: new retorna ponteiro para o objeto alocado.",
                                    "Inclua delete obj; para liberar memória e evitar leaks."
                                  ],
                                  "verification": "Compile e rode o código; use debugger (GDB) para pausar no new e inspecionar ponteiro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Compilador C++ (g++), debugger GDB, editor como CLion ou VS Code.",
                                  "tips": "Use -g flag no g++ para debug; visualize heap com ferramentas como Valgrind.",
                                  "learningObjective": "Mapear o instanciamento em C++ incluindo gerenciamento manual de memória.",
                                  "commonMistakes": [
                                    "Esquecer delete, causando memory leaks.",
                                    "Confundir new com malloc (new chama construtor).",
                                    "Ignorar inicialização de ponteiro nullptr."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Instanciamento em Python e C++ e Sintetizar",
                                  "subSteps": [
                                    "Liste semelhanças: alocação, construtor, referência/ponteiro.",
                                    "Destaque diferenças: Python automático vs C++ manual; sintaxe e GC.",
                                    "Crie uma tabela comparativa com colunas para cada linguagem.",
                                    "Discuta implicações: portabilidade, performance, segurança de memória.",
                                    "Teste cenários híbridos ou erros comuns em ambos."
                                  ],
                                  "verification": "Crie e explique uma tabela comparativa para um colega ou em voz alta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilha ou Markdown para tabela, exemplos de código de steps anteriores.",
                                  "tips": "Foque em fluxogramas paralelos para visualização rápida de diferenças.",
                                  "learningObjective": "Diferenciar e relacionar processos de instanciamento entre linguagens.",
                                  "commonMistakes": [
                                    "Superestimar similaridades, ignorando gerenciamento de memória.",
                                    "Não considerar exceções em construtores."
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: class Carro: def __init__(self, cor): self.cor = cor; print('Construtor chamado'); meuCarro = Carro('vermelho'); print(id(meuCarro)). Em C++: class Carro { public: Carro(string cor) : cor(cor) { cout << 'Construtor chamado'; } string cor; }; Carro* meuCarro = new Carro('vermelho'); cout << meuCarro; delete meuCarro; // Saída mostra alocação, init e ponteiro.",
                              "finalVerifications": [
                                "Explicar verbalmente o fluxo completo para Python e C++ sem hesitação.",
                                "Executar exemplos de código sem erros de sintaxe ou runtime.",
                                "Identificar memory leak em código C++ mal gerenciado.",
                                "Comparar tempos de execução ou uso de memória entre linguagens.",
                                "Desenhar diagrama de memória correto para ambos os exemplos.",
                                "Responder perguntas sobre o que acontece se o construtor falhar."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de alocação de memória e construtor (90%+ correto).",
                                "Uso correto de terminologia OOP (referência, ponteiro, heap).",
                                "Demonstração prática com código executável e análise de output.",
                                "Comparação clara e equilibrada entre Python e C++.",
                                "Identificação proativa de erros comuns e soluções.",
                                "Clareza na comunicação via diagramas ou tabelas."
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Gerenciamento de memória liga a Estruturas de Dados e Algoritmos.",
                                "Matemática: Ponteiros em C++ conectam a Álgebra Linear (endereços como vetores).",
                                "Engenharia de Software: Práticas de RAII em C++ relacionam a Design Patterns.",
                                "Física/Engenharia: Analogia de 'construtor' como montagem de componentes físicos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, entender instanciamento é crucial para criar objetos em apps como jogos (instanciar inimigos dinamicamente em Unity/C# similar a C++), web services (objetos de requisição em Django/Python) ou sistemas embarcados (gerenciamento preciso de memória em C++ para IoT), evitando crashes por leaks ou referências inválidas."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1",
                              "10.1.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.1.3.2",
                            "name": "Implementar criação de instância",
                            "description": "Escrever código para criar uma instância de uma classe simples e atribuir valores iniciais aos atributos via construtor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir uma classe simples com construtor",
                                  "subSteps": [
                                    "Escolha um tema simples para a classe, como 'Pessoa', e defina atributos básicos (ex: nome e idade).",
                                    "Escreva a sintaxe da classe: class NomeClasse:",
                                    "Implemente o método __init__(self, param1, param2): com atribuições self.param1 = param1.",
                                    "Salve o arquivo como script.py e execute para testar sintaxe.",
                                    "Adicione um print simples dentro do __init__ para confirmar execução (opcional para depuração)."
                                  ],
                                  "verification": "Execute o script e confirme ausência de erros de sintaxe; o construtor é definido sem falhas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Python 3.x instalado"
                                  ],
                                  "tips": "Sempre inclua 'self' como primeiro parâmetro no __init__ e use nomes descritivos para clareza.",
                                  "learningObjective": "Compreender a estrutura básica de uma classe com construtor para inicialização de atributos.",
                                  "commonMistakes": [
                                    "Esquecer 'self' nas atribuições (ex: nome = nome em vez de self.nome = nome)",
                                    "Omitir os dois underscores em __init__",
                                    "Definir parâmetros sem tipos ou valores padrão desnecessários"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever código para criar uma instância única via construtor",
                                  "subSteps": [
                                    "Após a definição da classe, escreva: minha_instancia = NomeClasse(valor1, valor2).",
                                    "Garanta que o número e tipo de argumentos combinem exatamente com os parâmetros do construtor.",
                                    "Coloque esta linha fora da classe, no corpo principal do script.",
                                    "Execute o script para testar a criação.",
                                    "Use uma variável descritiva para a instância (ex: pessoa1)."
                                  ],
                                  "verification": "O script executa sem erros de TypeError ou NameError, confirmando criação da instância.",
                                  "estimatedTime": "8 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Python 3.x instalado"
                                  ],
                                  "tips": "Lembre-se: parênteses são obrigatórios após o nome da classe para chamar o construtor.",
                                  "learningObjective": "Dominar a sintaxe precisa para instanciar uma classe e passar argumentos ao construtor.",
                                  "commonMistakes": [
                                    "Esquecer parênteses: NomeClasse em vez de NomeClasse()",
                                    "Argumentos em ordem ou tipo incorretos",
                                    "Tentar criar instância dentro da própria classe"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar atributos da instância após criação",
                                  "subSteps": [
                                    "Adicione linhas print(minha_instancia.atributo1) e print(minha_instancia.atributo2).",
                                    "Execute o script e observe se os valores impressos correspondem aos passados no construtor.",
                                    "Experimente alterar um atributo pós-criação: minha_instancia.atributo1 = novo_valor e print novamente.",
                                    "Confirme que o acesso via ponto (.) funciona.",
                                    "Adicione comentários explicando cada print."
                                  ],
                                  "verification": "Os prints exibem exatamente os valores iniciais do construtor, validando a inicialização.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Python 3.x instalado"
                                  ],
                                  "tips": "Use print para depuração rápida; acesse atributos sempre com notação de ponto.",
                                  "learningObjective": "Validar que o construtor atribuiu corretamente os valores iniciais aos atributos da instância.",
                                  "commonMistakes": [
                                    "Acessar atributo antes de criar a instância",
                                    "Esquecer o ponto: minha_instancia atributo1",
                                    "Confundir atributos de classe com de instância"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Criar múltiplas instâncias independentes",
                                  "subSteps": [
                                    "Crie uma segunda instância: instancia2 = NomeClasse(valor3, valor4) com valores diferentes.",
                                    "Adicione prints para atributos de ambas as instâncias.",
                                    "Altere um atributo em uma instância e verifique a outra.",
                                    "Execute e confirme independência.",
                                    "Documente com comentários sobre estado único por instância."
                                  ],
                                  "verification": "Prints mostram valores distintos e independentes; alteração em uma não afeta a outra.",
                                  "estimatedTime": "12 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Python 3.x instalado"
                                  ],
                                  "tips": "Cada chamada ao construtor gera um novo objeto com estado próprio.",
                                  "learningObjective": "Demonstrar que múltiplas instâncias compartilham a classe mas mantêm dados separados.",
                                  "commonMistakes": [
                                    "Achar que atributos são globais",
                                    "Reatribuir a mesma variável: instancia = nova_instancia (perde referência anterior)",
                                    "Ignorar diferenças nos valores passados"
                                  ]
                                },
                                {
                                  "practicalExample": "```python\nclass Pessoa:\n    def __init__(self, nome, idade):\n        self.nome = nome\n        self.idade = idade\n\npessoa1 = Pessoa('Alice', 30)\nprint(f'{pessoa1.nome}: {pessoa1.idade}')  # Alice: 30\n\npessoa2 = Pessoa('Bob', 25)\nprint(f'{pessoa2.nome}: {pessoa2.idade}')  # Bob: 25\npessoa1.idade = 31\nprint(f'{pessoa1.idade}')  # 31 (independente)\nprint(f'{pessoa2.idade}')  # 25\n``` Este exemplo cria duas pessoas independentes com valores iniciais via construtor."
                                },
                                {
                                  "finalVerifications": [
                                    "Código executa sem erros de sintaxe ou runtime.",
                                    "Atributos da instância refletem valores passados ao construtor.",
                                    "Acesso a atributos via notação de ponto funciona corretamente.",
                                    "Múltiplas instâncias mantêm estados independentes.",
                                    "Não há vazamento de variáveis ou referências compartilhadas indevidas."
                                  ],
                                  "assessmentCriteria": [
                                    "Construtor usa 'self' corretamente em todas as atribuições.",
                                    "Sintaxe de instanciação inclui parênteses e argumentos exatos.",
                                    "Verificações via print confirmam inicialização bem-sucedida.",
                                    "Código demonstra criação de pelo menos duas instâncias independentes.",
                                    "Comentários explicam passos chave; código é legível e sem redundâncias.",
                                    "Ausência de erros comuns como esquecer 'self' ou argumentos errados."
                                  ],
                                  "crossCurricularConnections": [
                                    "Matemática: Modelagem de entidades com propriedades variáveis (análoga a funções e variáveis).",
                                    "Língua Portuguesa: Uso de nomenclatura clara e descritiva em identificadores.",
                                    "Ciências: Analogia com criação de organismos individuais a partir de um blueprint genético.",
                                    "Artes: Design de templates (classes) para objetos únicos e personalizados."
                                  ],
                                  "realWorldApplication": "Em aplicativos reais, como sistemas de gerenciamento de estoque, criar instâncias de 'Produto' permite representar itens únicos com preços e quantidades iniciais; em jogos, instâncias de 'Inimigo' com posições e vidas específicas; ou em redes sociais, perfis de usuários com dados pessoais inicializados."
                                }
                              ]
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1",
                              "10.1.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.1.3.3",
                            "name": "Visualizar instância em UML",
                            "description": "Representar uma instância de classe em diagrama de objetos UML, mostrando nome do objeto, classe e valores de atributos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender componentes de um diagrama de objetos UML",
                                  "subSteps": [
                                    "Estude a sintaxe básica: objeto nomeado como 'objeto:Classe'",
                                    "Identifique que atributos são listados como 'atributo=valor' dentro de chaves {}",
                                    "Revise exemplos de diagramas de classes para diferenciar de objetos",
                                    "Anote diferenças entre diagrama de classes (tipos) e objetos (instâncias específicas)",
                                    "Pratique identificando elementos em um diagrama de exemplo fornecido"
                                  ],
                                  "verification": "Liste corretamente os 3 componentes principais (nome objeto, classe, atributos com valores) sem erros",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplos de diagramas UML online (UMLet ou PlantUML)"
                                  ],
                                  "tips": "Use cores diferentes para nome, classe e atributos para visualizar melhor",
                                  "learningObjective": "Dominar a sintaxe fundamental de diagramas de objetos UML",
                                  "commonMistakes": [
                                    "Confundir com diagrama de classes",
                                    "Esquecer os dois pontos após o nome do objeto",
                                    "Usar tipos em vez de valores concretos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a classe e selecionar atributos relevantes",
                                  "subSteps": [
                                    "Examine a definição da classe: identifique nome e lista de atributos",
                                    "Escolha valores concretos para cada atributo (ex: strings, números, booleanos)",
                                    "Decida um nome descritivo e único para a instância do objeto",
                                    "Verifique se todos os atributos obrigatórios têm valores atribuídos",
                                    "Documente escolhas em uma tabela simples: atributo | tipo | valor proposto"
                                  ],
                                  "verification": "Crie uma tabela com pelo menos 3 atributos, tipos e valores corretos",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Definição da classe em texto ou diagrama",
                                    "Planilha ou papel quadriculado"
                                  ],
                                  "tips": "Priorize atributos principais; valores devem ser realistas para o contexto",
                                  "learningObjective": "Mapear estrutura de classe para dados de instância específica",
                                  "commonMistakes": [
                                    "Omitir atributos",
                                    "Usar valores genéricos como 'null' sem justificativa",
                                    "Nomear objeto com nome da classe"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o diagrama de objeto",
                                  "subSteps": [
                                    "Desenhe o retângulo principal para o objeto",
                                    "Escreva 'nomeObjeto : NomeClasse' na primeira linha",
                                    "Liste atributos no formato 'atributo1=valor1, atributo2=valor2' dentro de {}",
                                    "Adicione linhas de separação se houver mais compartimentos (opcional para métodos)",
                                    "Ajuste layout para clareza: centralize texto e use fonte legível"
                                  ],
                                  "verification": "Diagrama desenhado segue sintaxe exata UML para objeto único",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de desenho UML (Draw.io, Lucidchart ou papel)",
                                    "Referência UML oficial"
                                  ],
                                  "tips": "Mantenha o diagrama simples; foque em um objeto por vez",
                                  "learningObjective": "Aplicar sintaxe UML para representar instância visualmente",
                                  "commonMistakes": [
                                    "Chaves {} ausentes",
                                    "Virgulas faltando entre atributos",
                                    "Classe em minúscula"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e refinar o diagrama",
                                  "subSteps": [
                                    "Compare com referência UML: verifique nome, classe e atributos",
                                    "Teste legibilidade: mostre a um par para feedback",
                                    "Adicione rótulo ou legenda se necessário",
                                    "Exporte ou fotografe para portfólio digital",
                                    "Registre lições aprendidas para próximas instâncias"
                                  ],
                                  "verification": "Checklist de 5 itens UML completado com 100% de acertos",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Checklist impresso",
                                    "Ferramenta de compartilhamento (Google Drive)"
                                  ],
                                  "tips": "Use zoom out para verificar proporções gerais",
                                  "learningObjective": "Garantir precisão e usabilidade do diagrama",
                                  "commonMistakes": [
                                    "Ignorar feedback externo",
                                    "Sobrecarregar com detalhes desnecessários",
                                    "Erros tipográficos em valores"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a classe 'Carro' com atributos cor: String, modelo: String, ano: int. Crie 'meuFusca : Carro {cor=\"vermelho\", modelo=\"Fusca\", ano=1970}' em um retângulo UML.",
                              "finalVerifications": [
                                "Nome do objeto precede os dois pontos (:)",
                                "Nome da classe em maiúscula após os dois pontos",
                                "Atributos listados como pares nome=valor dentro de chaves {}",
                                "Valores são concretos e tipados corretamente",
                                "Diagrama é legível e bem formatado",
                                "Nenhum método ou comportamento incluído indevidamente"
                              ],
                              "assessmentCriteria": [
                                "Precisão da sintaxe UML (100% conformidade)",
                                "Clareza visual e legibilidade (espaçamento, alinhamento)",
                                "Correção dos valores de atributos (realistas e consistentes)",
                                "Completude: todos atributos da classe representados",
                                "Originalidade no nome do objeto (descritivo)",
                                "Eficiência: diagrama minimalista sem excessos"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de conjuntos e funções (atributos como mapeamentos)",
                                "Artes: Design gráfico e composição visual",
                                "Linguagens: Semântica e notação formal em programação",
                                "Ciências da Computação: Abstração de dados em bancos relacionais"
                              ],
                              "realWorldApplication": "Em equipes de desenvolvimento de software, diagramas de objetos UML documentam estados reais de sistemas (ex: instância de usuário logado em app bancário), facilitando depuração, refatoração e comunicação com stakeholders não-técnicos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1",
                              "10.1.1.1.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.2",
                    "name": "Criação de Instâncias",
                    "description": "Processo de instanciação de uma classe utilizando o construtor para criar objetos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.2.1",
                        "name": "Conceito de Instância",
                        "description": "Uma instância, ou objeto, é uma entidade concreta criada a partir de uma classe, que atua como um molde ou blueprint, permitindo múltiplas realizações independentes com estados próprios.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.1",
                            "name": "Definir instância de classe",
                            "description": "Explicar verbalmente ou por escrito que uma instância é um objeto específico gerado a partir de uma classe, contendo valores únicos para atributos e capaz de invocar métodos definidos na classe.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de classe como molde",
                                  "subSteps": [
                                    "Defina classe como um blueprint ou molde que descreve atributos e métodos comuns.",
                                    "Identifique atributos como variáveis (ex: nome, idade) e métodos como funções (ex: falar()).",
                                    "Compare com analogias reais: classe é como um projeto de casa, definindo estrutura geral.",
                                    "Discuta que classes não têm valores específicos, apenas definem o que objetos terão.",
                                    "Anote exemplos de classes do dia a dia, como 'Carro' ou 'Pessoa'."
                                  ],
                                  "verification": "Aluno explica verbalmente o que é uma classe usando uma analogia correta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Quadro ou papel para desenhar diagramas",
                                    "Exemplos impressos de classes simples"
                                  ],
                                  "tips": "Use desenhos visuais para representar a classe como um molde vazio.",
                                  "learningObjective": "Entender classe como estrutura abstrata para objetos.",
                                  "commonMistakes": "Confundir classe com um objeto específico já criado."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender instância como objeto concreto da classe",
                                  "subSteps": [
                                    "Defina instância como um objeto específico criado a partir da classe, com valores únicos.",
                                    "Explique que cada instância herda atributos e métodos da classe.",
                                    "Destaque que instâncias podem invocar métodos definidos na classe.",
                                    "Diferencie: múltiplas instâncias da mesma classe têm estados diferentes (ex: carros com cores variadas).",
                                    "Escreva definição formal: 'Instância é objeto gerado da classe com valores únicos para atributos'."
                                  ],
                                  "verification": "Aluno escreve ou verbaliza definição precisa de instância, citando atributos únicos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto simples",
                                    "Documentação de Python OOP básica"
                                  ],
                                  "tips": "Pense em instâncias como cópias personalizadas do molde.",
                                  "learningObjective": "Diferenciar instância de classe reconhecendo valores únicos e invocação de métodos.",
                                  "commonMistakes": [
                                    "Achar que instância é a classe em si",
                                    "Ignorar que métodos são compartilhados."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar criação e uso de instância",
                                  "subSteps": [
                                    "Revise sintaxe básica: em Python, 'obj = Classe(args)' cria instância.",
                                    "Discuta passagem de argumentos para inicializar atributos únicos no construtor (__init__).",
                                    "Demonstre invocação de método: 'obj.metodo()' usando a instância.",
                                    "Crie mentalmente duas instâncias da mesma classe com valores diferentes.",
                                    "Explique estado mutável: atributos da instância podem mudar após criação."
                                  ],
                                  "verification": "Aluno descreve processo de criação de instância passo a passo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ambiente Python online (Replit ou Jupyter)",
                                    "Código exemplo de classe simples"
                                  ],
                                  "tips": "Sempre chame o construtor com valores para ver atributos únicos em ação.",
                                  "learningObjective": "Compreender processo de geração e uso de instâncias.",
                                  "commonMistakes": [
                                    "Esquecer de passar argumentos no construtor",
                                    "Confundir nome da classe com nome da instância."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar definição e verificação do conceito",
                                  "subSteps": [
                                    "Escreva explicação completa: verbal ou escrita sobre instância de classe.",
                                    "Crie diagrama: classe no topo, setas para instâncias com atributos preenchidos.",
                                    "Compare duas instâncias: destaque valores únicos e métodos comuns.",
                                    "Teste invocação: simule chamada de método em instância específica.",
                                    "Autoavalie: responda 'O que acontece se eu criar 3 instâncias?'"
                                  ],
                                  "verification": "Aluno produz explicação escrita clara e diagrama correto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para diagrama",
                                    "Editor de código para teste rápido"
                                  ],
                                  "tips": "Inclua exemplos reais para reforçar a explicação.",
                                  "learningObjective": "Sintetizar conceito de instância de forma acionável e verificável.",
                                  "commonMistakes": [
                                    "Descrever apenas classe sem mencionar instâncias específicas",
                                    "Omitir capacidade de invocar métodos."
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python:\nclass Pessoa:\n    def __init__(self, nome, idade):\n        self.nome = nome\n        self.idade = idade\n    def saudar(self):\n        return f'Olá, sou {self.nome} e tenho {self.idade} anos.'\n\npessoa1 = Pessoa('João', 25)  # Instância 1 com valores únicos\npessoa2 = Pessoa('Maria', 30) # Instância 2 com valores únicos\nprint(pessoa1.saudar())  # Invoca método da instância",
                              "finalVerifications": [
                                "Explica corretamente que instância tem valores únicos para atributos.",
                                "Demonstra invocação de método em instância específica.",
                                "Diferencia classe (molde) de instância (objeto concreto).",
                                "Cria exemplo simples de múltiplas instâncias da mesma classe.",
                                "Identifica erros comuns em definições de instância."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição: inclui atributos únicos e métodos (peso 30%).",
                                "Uso de exemplos concretos e analogias claras (peso 25%).",
                                "Capacidade de diferenciar classe e instância (peso 20%).",
                                "Explicação verbal/escrita fluida e sem erros conceituais (peso 15%).",
                                "Inclusão de aplicação prática como invocação de métodos (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Classes como funções genéricas, instâncias como chamadas com parâmetros específicos.",
                                "Biologia: Espécie como classe, indivíduo como instância com características únicas.",
                                "Língua Portuguesa: Substantivo genérico (classe) vs. substantivo próprio (instância personalizada).",
                                "Física: Modelo teórico (classe) vs. experimento real (instância com medidas únicas)."
                              ],
                              "realWorldApplication": "Assim como uma fábrica usa um molde (classe) para produzir carros únicos (instâncias) com cores e motores diferentes, mas todos capazes de acelerar (método), em software criamos instâncias de classes para modelar entidades reais como usuários em apps ou produtos em e-commerces."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2",
                            "name": "Diferenciar classe de instância",
                            "description": "Comparar classe (modelo abstrato com atributos e métodos) versus instância (objeto concreto com memória alocada e estado inicializado), usando exemplos como 'Carro' (classe) e 'meuCarro' (instância).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de Classe",
                                  "subSteps": [
                                    "Leia a definição: classe é um modelo abstrato que define atributos (propriedades) e métodos (comportamentos).",
                                    "Analise exemplos cotidianos: 'Carro' como classe representa o blueprint genérico de veículos.",
                                    "Estude a estrutura básica: declaração da classe, atributos e métodos em pseudocódigo.",
                                    "Discuta características: abstrata, sem alocação de memória, reutilizável.",
                                    "Crie um diagrama simples mostrando a classe como molde."
                                  ],
                                  "verification": "Escreva um resumo de 3 frases definindo classe e liste 2 exemplos não-computacionais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigo de classe exemplo",
                                    "Papel e caneta para diagrama",
                                    "Vídeo introdutório sobre POO (5 min)"
                                  ],
                                  "tips": [
                                    "Pense na classe como uma receita de bolo: define ingredientes e passos, mas não é o bolo pronto."
                                  ],
                                  "learningObjective": "Definir classe como modelo abstrato e identificar suas componentes principais.",
                                  "commonMistakes": [
                                    "Confundir classe com um objeto específico",
                                    "Acreditar que classe ocupa memória em disco",
                                    "Ignorar que classes definem métodos além de dados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o conceito de Instância",
                                  "subSteps": [
                                    "Leia a definição: instância é um objeto concreto criado a partir da classe, com memória alocada e estado inicializado.",
                                    "Analise exemplos: 'meuCarro' como instância de 'Carro', com cor e placa específicas.",
                                    "Estude o processo de criação: uso do operador 'new' ou equivalente para instanciar.",
                                    "Observe propriedades: cada instância tem seu próprio estado (atributos únicos).",
                                    "Compare múltiplas instâncias da mesma classe."
                                  ],
                                  "verification": "Descreva como criar uma instância e explique por que ela tem memória alocada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigo de instanciação",
                                    "Ambiente de programação online (ex: Replit)",
                                    "Diagrama de memória"
                                  ],
                                  "tips": [
                                    "Instância é como assar o bolo da receita: cada bolo tem seu sabor e tamanho únicos."
                                  ],
                                  "learningObjective": "Definir instância como objeto concreto e entender seu ciclo de vida.",
                                  "commonMistakes": [
                                    "Pensar que instância é sinônimo de classe",
                                    "Confundir estado inicial com atributos da classe",
                                    "Criar instâncias sem inicializar"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Classe e Instância",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: colunas para classe (abstrato, sem memória) vs instância (concreto, com memória).",
                                    "Use analogias: classe como espécie (gato), instância como indivíduo (meu gato Tom).",
                                    "Analise diferenças chave: abstração vs concretude, template vs dados reais.",
                                    "Desenhe diagramas UML: classe no topo, setas para instâncias abaixo.",
                                    "Discuta múltiplas instâncias compartilhando métodos da classe."
                                  ],
                                  "verification": "Preencha uma tabela comparativa com pelo menos 5 diferenças e valide com um colega.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela modelo em Excel/Google Sheets",
                                    "Ferramenta de diagrama online (ex: Draw.io)",
                                    "Exemplos impressos"
                                  ],
                                  "tips": [
                                    "Sempre pergunte: 'Isso tem estado único?' para identificar instância."
                                  ],
                                  "learningObjective": "Diferenciar precisamente classe de instância usando comparações visuais e conceituais.",
                                  "commonMistakes": [
                                    "Tratar classe como única instância",
                                    "Ignorar que métodos são compartilhados",
                                    "Confundir herança com instanciação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar com Código e Exemplos",
                                  "subSteps": [
                                    "Escreva código: defina classe Carro com atributos (cor, modelo) e método (acelerar).",
                                    "Crie 2 instâncias: meuCarro e carroAmigo, altere estados individuais.",
                                    "Execute e observe: memória alocada para cada objeto via print(id(objeto)).",
                                    "Teste chamadas de métodos: verifique que ambos usam o mesmo método da classe.",
                                    "Depure erros comuns de instanciação."
                                  ],
                                  "verification": "Execute o código e capture screenshot mostrando IDs diferentes das instâncias.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor Python (VS Code ou online)",
                                    "Código template fornecido",
                                    "Console para depuração"
                                  ],
                                  "tips": [
                                    "Use print() para visualizar estados e confirmar diferenças."
                                  ],
                                  "learningObjective": "Aplicar conceitos criando e manipulando classes e instâncias em código.",
                                  "commonMistakes": [
                                    "Esquecer parênteses na instanciação",
                                    "Modificar atributo da classe achando que afeta só instância",
                                    "Não inicializar construtor"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: class Carro: def __init__(self, cor): self.cor = cor; def acelerar(self): print('Vrum!'); meuCarro = Carro('azul'); carroAmigo = Carro('vermelho'). Aqui, Carro é a classe (molde), meuCarro e carroAmigo são instâncias (objetos reais com estados únicos).",
                              "finalVerifications": [
                                "Explique verbalmente a diferença entre classe e instância usando o exemplo Carro/meuCarro.",
                                "Crie um diagrama UML com 1 classe e 3 instâncias.",
                                "Escreva e execute código criando instâncias com estados diferentes.",
                                "Identifique em código fornecido: quais linhas definem classe vs criam instâncias.",
                                "Responda quiz: 5 perguntas sobre memória e estado.",
                                "Discuta com parceiro: dê exemplos reais fora de programação."
                              ],
                              "assessmentCriteria": [
                                "Definição precisa de classe como abstrata (sem erros conceituais).",
                                "Descrição correta de instância com alocação de memória e estado.",
                                "Tabela/diagrama comparativo completo e visualmente claro.",
                                "Código funcional com pelo menos 2 instâncias e uso de métodos.",
                                "Explicação fluida sem confusão entre termos.",
                                "Identificação de 3+ diferenças chave."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Classes como conjuntos abstratos, instâncias como elementos concretos.",
                                "Biologia: Espécie (classe) vs indivíduo (instância) com variações genéticas.",
                                "Língua Portuguesa: Substantivo comum (classe) vs nome próprio (instância específica).",
                                "Física: Lei geral (classe) vs experimento realizado (instância com medidas reais)."
                              ],
                              "realWorldApplication": "Em apps como bancos online, 'Conta' é classe (define saldo, métodos de depósito); 'contaDoJoão' é instância (saldo real de R$1000). Permite criar milhões de contas únicas a partir de um molde, escalando software como e-commerces e jogos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.3",
                            "name": "Identificar instâncias em código fonte",
                            "description": "Analisar trechos de código em linguagens como Python ou C++ e identificar expressões que criam instâncias, como 'obj = MinhaClasse()' em Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Classes e Instâncias",
                                  "subSteps": [
                                    "Leia a definição de classe como blueprint para objetos.",
                                    "Entenda instância como um objeto criado a partir da classe.",
                                    "Diferencie classe de instância com diagramas simples.",
                                    "Identifique exemplos cotidianos, como 'Carro' (classe) e 'meuCarro' (instância).",
                                    "Anote diferenças chave em um caderno."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre classe e instância com um exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação OOP básica (Python/C++), caderno e caneta"
                                  ],
                                  "tips": "Use analogias como moldes de bolo (classe) e bolos assados (instâncias) para fixar o conceito.",
                                  "learningObjective": "Compreender o papel conceitual de instâncias na OOP.",
                                  "commonMistakes": [
                                    "Confundir classe com instância",
                                    "Ignorar que instâncias têm estado único"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer Sintaxe de Criação de Instâncias em Python",
                                  "subSteps": [
                                    "Estude a sintaxe: 'objeto = NomeClasse(argumentos)'.",
                                    "Analise exemplos simples como 'pessoa = Pessoa(\"João\")'.",
                                    "Identifique o operador '=' e o nome da classe.",
                                    "Destaque construtores (__init__) em códigos de exemplo.",
                                    "Pratique com 3 trechos de código Python fornecidos."
                                  ],
                                  "verification": "Marque corretamente instâncias em 5 linhas de código Python aleatórias.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code), exemplos de código Python OOP"
                                  ],
                                  "tips": "Procure sempre por 'nome_da_classe(' seguido de ')' para sinalizar criação.",
                                  "learningObjective": "Identificar precisamente expressões de instanciação em Python.",
                                  "commonMistakes": [
                                    "Confundir chamadas de função com criação de instâncias",
                                    "Ignorar instâncias em linhas longas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconhecer Sintaxe de Criação de Instâncias em C++",
                                  "subSteps": [
                                    "Aprenda sintaxe: 'NomeClasse objeto(argumentos);' ou 'NomeClasse* ptr = new NomeClasse();'.",
                                    "Diferencie instanciação em stack e heap.",
                                    "Analise exemplos como 'Carro meuCarro;'.",
                                    "Identifique uso de 'new' para alocação dinâmica.",
                                    "Compare com Python em uma tabela."
                                  ],
                                  "verification": "Liste todas as instâncias em um trecho de código C++ de 20 linhas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador online (Replit), exemplos de código C++ OOP"
                                  ],
                                  "tips": "Foque em declarações de variáveis cujo tipo é uma classe, não primitivos.",
                                  "learningObjective": "Dominar identificação de instâncias na sintaxe C++.",
                                  "commonMistakes": [
                                    "Não notar 'new' em ponteiros",
                                    "Confundir structs com classes sem métodos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação em Códigos Complexos e Mistos",
                                  "subSteps": [
                                    "Analise códigos mistos Python/C++ com múltiplas instâncias.",
                                    "Ignore distratores como funções e variáveis primitivas.",
                                    "Use highlighter para marcar instâncias em editores.",
                                    "Resolva 5 exercícios com códigos reais de repositórios GitHub.",
                                    "Discuta ambiguidades com um par ou fórum."
                                  ],
                                  "verification": "Identifique 100% das instâncias em um código de teste de 50 linhas sem erros.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Códigos de exemplo de GitHub, highlighter digital (Notion ou VS Code)"
                                  ],
                                  "tips": "Leia o código linha por linha, focando em atribuições e declarações de tipos classe.",
                                  "learningObjective": "Aplicar identificação em cenários reais e complexos.",
                                  "commonMistakes": [
                                    "Marcar métodos estáticos como instâncias",
                                    "Perder instâncias em condicionais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: class Cachorro: pass; meuCachorro = Cachorro()  # 'meuCachorro' é uma instância. Em C++: class Cachorro { }; Cachorro fido;  # 'fido' é uma instância. Identifique: pet1 = Cachorro('Rex');",
                              "finalVerifications": [
                                "Pode listar todas as instâncias em um código Python de 30 linhas.",
                                "Identifica corretamente heap vs stack em C++.",
                                "Explica por que uma linha NÃO cria instância.",
                                "Aplica em código com herança ou múltiplas classes.",
                                "Resolve quiz com 90% de acerto em <5 minutos.",
                                "Diferencia instâncias de objetos literais (ex: listas)."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 100% das instâncias corretamente identificadas.",
                                "Velocidade: Análise de 50 linhas em <10 minutos.",
                                "Explicação: Justifica cada identificação com sintaxe.",
                                "Generalização: Aplica a novas linguagens OOP semelhantes.",
                                "Robustez: Ignora distratores como funções ou primitivos.",
                                "Profundidade: Nota construtores e argumentos opcionais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de objetos como variáveis em equações.",
                                "Língua Portuguesa/Inglês: Leitura analítica de documentação técnica.",
                                "Lógica: Raciocínio dedutivo para parsing de sintaxe.",
                                "Artes: Visualização de diagramas UML para classes/instâncias."
                              ],
                              "realWorldApplication": "Durante debugging de software, refatoração de código legado ou code review em equipes de desenvolvimento, permitindo identificar objetos para otimizar memória e performance em aplicações como jogos ou sistemas empresariais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.2",
                        "name": "Construtor de Classe",
                        "description": "O construtor é um método especial automaticamente invocado durante a instanciação para inicializar os atributos do novo objeto, podendo ser padrão (sem parâmetros) ou customizado.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.2.1",
                            "name": "Explicar função do construtor",
                            "description": "Descrever que o construtor (__init__ em Python ou construtor em C++) é executado automaticamente ao criar uma instância, configurando valores iniciais para atributos e garantindo estado válido.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico do Construtor",
                                  "subSteps": [
                                    "Defina um construtor como um método especial executado automaticamente ao criar uma instância de classe.",
                                    "Identifique os nomes: __init__ em Python e construtores nomeados como a classe em C++.",
                                    "Explique os propósitos principais: inicializar atributos com valores iniciais e garantir um estado válido do objeto.",
                                    "Diferencie de métodos comuns: construtores não têm tipo de retorno explícito e são chamados implicitamente.",
                                    "Discuta sobrecarga de construtores para flexibilidade em inicializações variadas."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo o que é um construtor, quando é chamado e seu propósito principal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial Python OOP",
                                    "Documentação C++ constructors (cppreference.com)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Visualize o construtor como o 'setup inicial' de um objeto, similar a preparar ingredientes antes de cozinhar.",
                                  "learningObjective": "Dominar a definição, timing e funções essenciais do construtor em OOP.",
                                  "commonMistakes": [
                                    "Confundir construtor com método estático",
                                    "Acreditar que construtor é opcional em todas as classes",
                                    "Ignorar validação de estado inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Construtor em Python (__init__)",
                                  "subSteps": [
                                    "Crie uma classe simples, como 'Carro', com método __init__ que recebe parâmetros para atributos (marca, modelo).",
                                    "Adicione um print dentro de __init__ para observar a execução automática ao instanciar.",
                                    "Teste instanciação sem parâmetros (use valores default) e com parâmetros para ver flexibilidade.",
                                    "Implemente validação básica no __init__, como verificar se marca não é vazia.",
                                    "Analise o self como referência ao novo objeto sendo inicializado."
                                  ],
                                  "verification": "Execute o código e capture a saída mostrando a chamada automática do __init__; explique o output.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor Python (VS Code ou Jupyter)",
                                    "REPL Python para testes interativos"
                                  ],
                                  "tips": "Sempre use self.atributo = parametro para atribuir valores aos atributos de instância.",
                                  "learningObjective": "Implementar e depurar construtores em Python, entendendo self e inicialização.",
                                  "commonMistakes": [
                                    "Esquecer self nos parâmetros",
                                    "Retornar valor de __init__",
                                    "Não tratar parâmetros opcionais com defaults"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Construtor em C++",
                                  "subSteps": [
                                    "Defina uma classe 'Ponto' com construtor que inicializa coordenadas x e y.",
                                    "Implemente construtor default, parametrizado e de cópia.",
                                    "Use cout no construtor para visualizar a chamada automática na instanciação.",
                                    "Adicione lista de inicialização (initializer list) para eficiência em inicialização.",
                                    "Compile e execute para observar ordem de chamada e validação de estado."
                                  ],
                                  "verification": "Compile o código C++ sem erros e demonstre outputs confirmando execução automática do construtor.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador C++ (g++ ou online como Replit)",
                                    "Referência cppreference para constructors"
                                  ],
                                  "tips": "Prefira initializer lists para membros const ou referências, evitando chamadas desnecessárias.",
                                  "learningObjective": "Implementar construtores variados em C++, incluindo boas práticas de inicialização.",
                                  "commonMistakes": [
                                    "Nomear construtor diferente da classe",
                                    "Esquecer ; após lista de inicialização",
                                    "Não definir construtor default quando necessário"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Aplicar o Conceito em Contextos Práticos",
                                  "subSteps": [
                                    "Compare __init__ Python vs construtores C++: semelhanças (automático, inicialização) e diferenças (retorno, sobrecarga).",
                                    "Crie uma classe que use construtor para garantir invariantes (ex: saldo >=0 em ContaBancaria).",
                                    "Refatore uma classe sem construtor para adicionar um, testando antes/depois.",
                                    "Discuta cenários onde construtor falha (ex: exceções na inicialização).",
                                    "Planeje uso em projeto maior, como inicializar objetos em um sistema de gerenciamento."
                                  ],
                                  "verification": "Crie um diagrama ou tabela comparando Python e C++, e refatore um exemplo com sucesso.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel ou ferramenta de diagrama (Draw.io)",
                                    "Códigos dos steps anteriores"
                                  ],
                                  "tips": "Sempre valide entradas no construtor para prevenir objetos inválidos ('fail-fast').",
                                  "learningObjective": "Integrar conhecimento de construtores cross-language e aplicá-los para robustez.",
                                  "commonMistakes": [
                                    "Ignorar exceções em construtores",
                                    "Sobrepor construtores sem necessidade",
                                    "Não considerar herança em construtores"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: class Ponto: def __init__(self, x=0, y=0): self.x = x; self.y = y; print('Construtor chamado!') p = Ponto(3,4)  # Output: Construtor chamado!, p.x=3. Em C++: class Ponto { int x,y; public: Ponto(int a=0, int b=0): x(a), y(b) { cout << 'Construtor chamado!'; } }; Ponto p(3,4);  // Output confirma inicialização automática.",
                              "finalVerifications": [
                                "Explicar verbalmente quando e por que o construtor é chamado automaticamente.",
                                "Identificar corretamente o construtor em códigos Python e C++ fornecidos.",
                                "Criar uma classe simples com construtor que inicializa e valida atributos.",
                                "Diferenciar construtor de outros métodos e explicar ausência de retorno.",
                                "Demonstrar uso de defaults e sobrecarga em exemplos funcionais.",
                                "Discutir impacto de construtor mal implementado em estado inválido."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definição e timing 100% corretos (30%).",
                                "Implementação prática: códigos compilam/executam sem erros (25%).",
                                "Explicação comparativa: Python vs C++ clara e precisa (20%).",
                                "Validação e boas práticas: inclui checks e initializer lists (15%).",
                                "Criatividade em exemplos: aplica a cenários reais (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Inicialização de vetores/matrizes como construtores em simulações numéricas.",
                                "Física: Modelagem de partículas/objetos com estado inicial (posição, velocidade).",
                                "Design de Software: Princípios SOLID, especialmente Single Responsibility no setup.",
                                "Lógica: Validação de pré-condições similar a provas matemáticas.",
                                "Banco de Dados: Construtores análogos a INSERT com defaults e constraints."
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps, construtores inicializam usuários com dados padrão (ex: app bancário valida saldo inicial >=0), prevenindo erros; em jogos, configuram inimigos com vida/posição; em sistemas embarcados C++, garantem sensores em estado calibrado ao boot."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.2.2",
                            "name": "Definir construtor padrão",
                            "description": "Identificar e explicar o construtor padrão gerado automaticamente pela linguagem quando nenhum é definido, que inicializa atributos com valores default.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição de construtor padrão",
                                  "subSteps": [
                                    "Leia a definição oficial de construtor em programação OO: método especial chamado na criação de instância.",
                                    "Identifique que o construtor padrão é gerado automaticamente se nenhum construtor for definido explicitamente.",
                                    "Anote que ele inicializa atributos com valores default da linguagem (ex: null para objetos, 0 para números inteiros em Java).",
                                    "Compare com linguagens específicas: Java (no-args constructor), Python (__init__ com defaults).",
                                    "Registre exemplos de valores default por tipo de dado."
                                  ],
                                  "verification": "Escreva um parágrafo explicando o construtor padrão e cite 3 valores default corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação da linguagem (ex: Java Oracle Docs)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Consulte sempre a especificação oficial da linguagem para evitar confusões entre dialects.",
                                  "learningObjective": "Definir precisamente o que é um construtor padrão e seu propósito na inicialização de objetos.",
                                  "commonMistakes": [
                                    "Confundir construtor padrão com inicializadores de classe estática.",
                                    "Acreditar que construtor padrão aceita parâmetros por default."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar condições de geração do construtor padrão",
                                  "subSteps": [
                                    "Crie uma classe simples sem nenhum construtor definido.",
                                    "Tente instanciar um objeto usando new Classe() sem argumentos.",
                                    "Observe se a compilação/execução succeeds e atributos estão com defaults.",
                                    "Adicione um construtor customizado e verifique que o padrão desaparece.",
                                    "Teste em pelo menos duas linguagens OO para generalizar (ex: Java e C++)."
                                  ],
                                  "verification": "Compile e execute código demonstrando instanciação sem construtor customizado, confirmando valores default.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE como IntelliJ ou VS Code",
                                    "Compilador Java/JDK ou Python interpreter"
                                  ],
                                  "tips": "Use System.out.println ou print para inspecionar valores de atributos após instanciação.",
                                  "learningObjective": "Reconhecer quando o compilador gera o construtor padrão e suas implicações.",
                                  "commonMistakes": [
                                    "Esquecer de declarar atributos não-inicializados.",
                                    "Ignorar que herança pode afetar chamadas de super() implícito."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar inicialização com valores default",
                                  "subSteps": [
                                    "Liste valores default para tipos primitivos e referências em sua linguagem alvo (ex: int=0, boolean=false, String=null).",
                                    "Crie classe com mix de tipos e instancie sem construtor, imprimindo todos atributos.",
                                    "Modifique atributos pós-instanciação e compare com estado inicial.",
                                    "Analise código descompilado (ex: javap em Java) para ver o construtor gerado.",
                                    "Documente diferenças entre defaults e valores explícitos."
                                  ],
                                  "verification": "Gere relatório com tabela de tipos vs. defaults observados no código executado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE com debugger",
                                    "Ferramenta de descompilação como javap"
                                  ],
                                  "tips": "Use debugger para pausar logo após new e inspecionar memória do objeto.",
                                  "learningObjective": "Mapear e validar valores default inicializados pelo construtor padrão.",
                                  "commonMistakes": [
                                    "Confundir defaults de primitivos com wrappers.",
                                    "Achar que String default é \"\" em vez de null."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar construtor padrão com customizado e praticar",
                                  "subSteps": [
                                    "Refatore classe anterior adicionando construtor com parâmetros.",
                                    "Teste instanciação: new Classe(args) vs new Classe() (deve falhar agora).",
                                    "Discuta trade-offs: simplicidade do padrão vs. controle customizado.",
                                    "Crie exercício: classe BankAccount sem construtor, deposite/retire simulando uso real.",
                                    "Avalie cenários onde padrão é preferível (ex: POJOs em frameworks)."
                                  ],
                                  "verification": "Execute testes unitários comprovando falha sem construtor custom e sucesso com ele.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Framework de testes como JUnit",
                                    "Exemplos de código em repositório Git"
                                  ],
                                  "tips": "Sempre inclua construtor no-arg se biblioteca externa exigir.",
                                  "learningObjective": "Diferenciar e escolher entre construtor padrão e customizados baseados em necessidades.",
                                  "commonMistakes": [
                                    "Não chamar super() em subclasses, quebrando chain.",
                                    "Sobrecarregar construtores sem no-arg quando necessário."
                                  ]
                                }
                              ],
                              "practicalExample": "Em Java: public class Pessoa { String nome; int idade; } Pessoa p = new Pessoa(); // nome=null, idade=0. Imprima: System.out.println(p.nome + \", \" + p.idade); Saída: null, 0. Agora adicione public Pessoa(String n, int i) { nome=n; idade=i; } – new Pessoa() falha!",
                              "finalVerifications": [
                                "Explicar verbalmente o construtor padrão e citar 5 valores default corretos.",
                                "Criar e instanciar classe sem construtor, confirmando defaults via print/debug.",
                                "Descompilar classe e apontar código do construtor gerado.",
                                "Refatorar para custom e demonstrar perda do padrão.",
                                "Listar 3 cenários onde usar padrão é vantajoso."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e exemplos de defaults (90% correto).",
                                "Código executável sem erros demonstrando comportamento.",
                                "Análise clara de quando padrão é gerado/inválido.",
                                "Comparação lógica com construtores customizados.",
                                "Uso correto de ferramentas de debug/descompilação.",
                                "Criatividade em exemplos práticos e conexões reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de estados iniciais e valores neutros (zero elemento).",
                                "Lógica Computacional: Compreensão de geração automática de código pelo compilador.",
                                "Design de Software: Princípios de encapsulation e inicialização segura.",
                                "Inglês Técnico: Terminologia OO padrão (constructor, default values)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de APIs REST com Spring Boot ou Hibernate, POJOs usam construtor padrão para mapeamento automático de JSON/XML para entidades, permitindo inicialização mínima sem código boilerplate desnecessário."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.2.2.3",
                            "name": "Implementar construtor customizado",
                            "description": "Escrever um construtor com parâmetros para inicializar atributos, como def __init__(self, nome): self.nome = nome em Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de construtor em Python",
                                  "subSteps": [
                                    "Estude a definição de construtor: método especial __init__ chamado automaticamente na criação de instâncias",
                                    "Identifique os parâmetros obrigatórios: self como primeiro argumento",
                                    "Compare com o comportamento padrão de classes sem construtor customizado",
                                    "Analise exemplos simples da documentação oficial do Python",
                                    "Anote as diferenças entre __init__ e métodos de instância comuns"
                                  ],
                                  "verification": "Escreva uma frase resumindo o propósito do __init__ e recite sem consultar notas",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código Python (ex: VS Code, IDLE)",
                                    "Documentação Python: https://docs.python.org/pt-br/3/tutorial/classes.html"
                                  ],
                                  "tips": "Sempre inclua 'self' como primeiro parâmetro para acessar atributos da instância",
                                  "learningObjective": "Entender o papel e a execução automática do construtor na inicialização de objetos",
                                  "commonMistakes": [
                                    "Esquecer o 'self' no início da assinatura",
                                    "Confundir __init__ com um método estático",
                                    "Achar que __init__ retorna algo além de None"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a estrutura básica da classe com construtor",
                                  "subSteps": [
                                    "Crie uma classe vazia com 'class NomeClasse:'",
                                    "Adicione a linha 'def __init__(self, parametro1):' dentro da classe",
                                    "Identifique os parâmetros necessários baseados nos atributos desejados",
                                    "Teste sintaxe básica executando o código sem corpo do método",
                                    "Adicione um print simples no __init__ para confirmar chamada automática"
                                  ],
                                  "verification": "Execute 'obj = NomeClasse()' e confirme que o print aparece sem erros",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ambiente Python interativo (REPL ou Jupyter)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use indentação consistente (4 espaços) para evitar erros de sintaxe",
                                  "learningObjective": "Estruturar corretamente a assinatura do construtor com parâmetros iniciais",
                                  "commonMistakes": [
                                    "Indentação incorreta do método dentro da classe",
                                    "Falta de dois underscores antes e depois de 'init'",
                                    "Parâmetros sem vírgula entre self e outros"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inicializar atributos da instância no construtor",
                                  "subSteps": [
                                    "Dentro do __init__, escreva 'self.atributo = parametro' para cada parâmetro",
                                    "Escolha nomes descritivos para atributos e parâmetros (ex: nome, idade)",
                                    "Adicione múltiplos parâmetros se necessário (ex: __init__(self, nome, idade))",
                                    "Teste acessando atributos após instanciação (print(obj.atributo))",
                                    "Refatore para incluir um atributo padrão se aplicável (ex: self.idade = 0)"
                                  ],
                                  "verification": "Crie uma instância e acesse todos os atributos; valores devem corresponder aos passados",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código com linting Python (ex: PyCharm Community)",
                                    "Exemplos de classes OOP"
                                  ],
                                  "tips": "Use 'self.' para tornar atributos acessíveis fora do construtor",
                                  "learningObjective": "Implementar atribuições de parâmetros para atributos de instância",
                                  "commonMistakes": [
                                    "Esquecer 'self.' antes do atributo",
                                    "Atribuir parametro diretamente sem self",
                                    "Usar nomes de variáveis conflitantes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar o construtor customizado",
                                  "subSteps": [
                                    "Crie múltiplas instâncias com diferentes valores de parâmetros",
                                    "Adicione um método simples (ex: def exibir(self):) para imprimir atributos",
                                    "Verifique se atributos persistem após criação",
                                    "Teste casos edge: parâmetros vazios ou None se permitido",
                                    "Corrija erros e refatore o código para clareza"
                                  ],
                                  "verification": "Todas as instâncias exibem atributos corretos sem exceções",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Unittests básicos com assert (módulo unittest)",
                                    "Console Python para depuração"
                                  ],
                                  "tips": "Use print statements temporários para debug durante testes",
                                  "learningObjective": "Validar funcionalidade do construtor através de instanciações e acessos",
                                  "commonMistakes": [
                                    "Não testar com valores variados",
                                    "Ignorar TypeError em parâmetros obrigatórios",
                                    "Acessar atributo antes da instanciação"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie a classe Pessoa: class Pessoa: def __init__(self, nome, idade): self.nome = nome; self.idade = idade. Instancie: p1 = Pessoa('Ana', 25); print(p1.nome)  # Saída: Ana; print(p1.idade)  # Saída: 25",
                              "finalVerifications": [
                                "O construtor é invocado automaticamente ao criar instâncias",
                                "Todos os atributos são inicializados com valores dos parâmetros",
                                "Instâncias múltiplas mantêm valores independentes",
                                "Acesso a atributos fora da classe funciona corretamente",
                                "Não há erros de sintaxe ou NameError ao executar",
                                "Métodos adicionais acessam atributos inicializados"
                              ],
                              "assessmentCriteria": [
                                "Código sintaticamente correto e executável",
                                "Presença de 'self' em todos os parâmetros e atribuições",
                                "Atributos inicializados corretamente via parâmetros",
                                "Testes demonstram funcionalidade em pelo menos 2 instâncias",
                                "Nomenclatura clara e consistente (PEP 8)",
                                "Ausência de erros comuns como atribuições diretas sem self"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica sequencial e funções parametrizadas",
                                "Língua Portuguesa: Nomeação descritiva de variáveis e classes",
                                "Física: Modelagem de entidades reais como objetos com propriedades",
                                "Artes: Design de interfaces intuitivas em programação"
                              ],
                              "realWorldApplication": "Em sistemas de gerenciamento, construtores customizados inicializam objetos como 'Usuário' com login e perfil, facilitando apps web, jogos (personagens com posição e vida) e simulações científicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.3",
                        "name": "Sintaxe de Instanciação",
                        "description": "Processo prático de criar instâncias utilizando a sintaxe da linguagem, invocando o construtor com ou sem argumentos para alocar memória e inicializar o objeto.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.3.1",
                            "name": "Criar instância sem parâmetros",
                            "description": "Escrever e executar código para instanciar um objeto usando construtor padrão, ex: carro = Carro() em Python, verificando a criação bem-sucedida.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Classe e Construtor Padrão",
                                  "subSteps": [
                                    "Leia a documentação oficial do Python sobre classes (docs.python.org/pt-br/3/tutorial/classes.html).",
                                    "Identifique o que é um construtor padrão (__init__ sem parâmetros obrigatórios).",
                                    "Anote exemplos de classes built-in como list() ou dict().",
                                    "Compare instanciação com funções simples para diferenciar objetos.",
                                    "Desenhe um diagrama simples de uma classe e sua instância."
                                  ],
                                  "verification": "Resuma em 3 frases o que aprendeu e compartilhe com um colega ou anote em um caderno.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Navegador web para documentação Python, caderno para anotações.",
                                  "tips": "Foquem em classes como 'molde' para objetos, facilitando reutilização.",
                                  "learningObjective": "Entender classes como blueprints e construtores como inicializadores automáticos.",
                                  "commonMistakes": "Confundir classe com instância; achar que todo __init__ precisa de parâmetros."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir uma Classe Simples com Construtor Padrão",
                                  "subSteps": [
                                    "Abra um editor de código (ex: VS Code, IDLE).",
                                    "Escreva 'class MinhaClasse:' e defina def __init__(self): pass'.",
                                    "Adicione um atributo simples como self.nome = 'Exemplo'.",
                                    "Salve o arquivo como 'classe_simples.py'.",
                                    "Comente o código explicando cada linha."
                                  ],
                                  "verification": "Execute o código sem criar instância; deve rodar sem erros (python classe_simples.py).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de texto/IDE com Python instalado (versão 3.8+).",
                                  "tips": "Use indentação consistente (4 espaços); teste salvando e recarregando.",
                                  "learningObjective": "Criar uma classe funcional com construtor vazio ou básico.",
                                  "commonMistakes": "Esquecer dois underscores em __init__; indentação errada causando SyntaxError."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escrever e Executar a Instanciação",
                                  "subSteps": [
                                    "Adicione linha após a classe: obj = MinhaClasse()",
                                    "Adicione print(obj.nome) para testar atributo.",
                                    "Execute o script completo.",
                                    "Experimente criar múltiplas instâncias: obj2 = MinhaClasse(); print(obj2.nome)",
                                    "Registre o output esperado vs. obtido."
                                  ],
                                  "verification": "O print mostra o valor do atributo sem erros de runtime.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Mesmo arquivo 'classe_simples.py' e terminal/IDE.",
                                  "tips": "Use print() imediatamente após instanciação para debug rápido.",
                                  "learningObjective": "Sintaxe correta para carro = Carro() e verificação imediata.",
                                  "commonMistakes": "Esquecer parênteses (); usar = em vez de nome_da_classe()."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Expandir a Instância",
                                  "subSteps": [
                                    "Adicione um método simples na classe: def saudar(self): return 'Olá!'",
                                    "Chame print(obj.saudar()) após instanciação.",
                                    "Teste se instâncias independentes mantêm estado separado.",
                                    "Corrija qualquer erro e reexecute.",
                                    "Documente o código final com comentários."
                                  ],
                                  "verification": "Método executa corretamente em todas instâncias sem alterar estados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Arquivo atualizado e terminal.",
                                  "tips": "Sempre verifique type(obj) == <class '__main__.MinhaClasse'>.",
                                  "learningObjective": "Confirmar criação bem-sucedida via atributos e métodos.",
                                  "commonMistakes": "Acessar atributo antes de setar; confundir self com instância."
                                }
                              ],
                              "practicalExample": "class Carro:\n    def __init__(self):\n        self.modelo = 'Fusca 1970'\n\ncarro = Carro()\nprint(carro.modelo)  # Saída: Fusca 1970\ncarro2 = Carro()\nprint(carro2.modelo)  # Independente",
                              "finalVerifications": [
                                "Código executa sem SyntaxError ou NameError.",
                                "type(carro) retorna <class '__main__.Carro'>.",
                                "Atributos da instância são acessíveis e corretos.",
                                "Múltiplas instâncias criadas independentemente.",
                                "Nenhum erro de parâmetro no construtor.",
                                "Output de prints/verificação bate com esperado."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe precisa: class Nome: e obj = Nome()",
                                "Construtor __init__(self) sem args obrigatórios.",
                                "Verificação explícita de criação (print/type).",
                                "Código comentado e legível.",
                                "Testes com múltiplas instâncias.",
                                "Tratamento de erros comuns demonstrado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de objetos como funções parametrizadas.",
                                "Física: Simulação de partículas/partes com propriedades iniciais.",
                                "Biologia: Criação de 'indivíduos' em simulações populacionais.",
                                "Artes: Geração procedural de elementos gráficos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de jogos (criar inimigos/jogadores), simulações científicas (objetos físicos), apps web (sessões de usuário) ou automação (instâncias de configurações padrão reutilizáveis)."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.2",
                              "10.1.1.2.2.2"
                            ]
                          },
                          {
                            "id": "10.1.1.2.3.2",
                            "name": "Criar instância com parâmetros",
                            "description": "Implementar e instanciar objeto passando argumentos ao construtor, ex: carro = Carro('Fusca', 1970), acessando atributos pós-criação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a classe com construtor parametrizado",
                                  "subSteps": [
                                    "Abra um editor de código Python (ex: VS Code ou IDLE).",
                                    "Escreva a declaração da classe: class NomeClasse:.",
                                    "Defina o método __init__(self, parametro1, parametro2): dentro da classe.",
                                    "Atribua os parâmetros aos atributos da instância: self.parametro1 = parametro1.",
                                    "Salve o arquivo com extensão .py."
                                  ],
                                  "verification": "Execute o código da classe isoladamente; não deve haver erros de sintaxe.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Editor de código Python, interpretador Python instalado",
                                  "tips": "Use nomes descritivos para parâmetros para facilitar a compreensão.",
                                  "learningObjective": "Compreender a estrutura do construtor __init__ para inicializar objetos com dados personalizados.",
                                  "commonMistakes": "Esquecer 'self.' nos atributos; confundir parâmetros com atributos globais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar a instância passando argumentos ao construtor",
                                  "subSteps": [
                                    "Escreva a linha de instanciação: instancia = NomeClasse('valor1', valor2).",
                                    "Use aspas para strings e números diretamente para inteiros ou floats.",
                                    "Posicione os argumentos na ordem definida no __init__.",
                                    "Adicione uma print(instancia) para visualização inicial.",
                                    "Execute o código completo."
                                  ],
                                  "verification": "A instância é criada sem erro TypeError ou SyntaxError; print mostra o objeto.",
                                  "estimatedTime": "8 minutos",
                                  "materials": "Mesmo editor e Python do passo anterior",
                                  "tips": "Argumentos posicionais devem seguir a ordem exata dos parâmetros no __init__.",
                                  "learningObjective": "Dominar a sintaxe de instanciação com passagem de argumentos.",
                                  "commonMistakes": "Inverter ordem dos argumentos; esquecer parênteses ou vírgulas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Acessar e manipular atributos da instância",
                                  "subSteps": [
                                    "Acesse um atributo: print(instancia.parametro1).",
                                    "Acesse múltiplos atributos em sequência.",
                                    "Modifique um atributo: instancia.parametro1 = 'novo_valor'.",
                                    "Verifique a alteração com novo print.",
                                    "Use o objeto em uma expressão simples, ex: if instancia.ano > 2000."
                                  ],
                                  "verification": "Atributos são acessados e exibidos corretamente; modificações persistem.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Editor Python",
                                  "tips": "Sempre use notação ponto (.) para acessar atributos de instâncias.",
                                  "learningObjective": "Aprender a interagir com atributos pós-instanciação.",
                                  "commonMistakes": "Usar colchetes [] em vez de ponto .; tentar acessar antes da instanciação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e debugar a instância completa",
                                  "subSteps": [
                                    "Crie uma segunda instância com parâmetros diferentes.",
                                    "Compare atributos das duas instâncias.",
                                    "Adicione um método simples à classe e chame na instância.",
                                    "Execute todo o script e revise saídas.",
                                    "Corrija erros identificados."
                                  ],
                                  "verification": "Múltiplas instâncias funcionam independentemente; saídas esperadas.",
                                  "estimatedTime": "12 minutos",
                                  "materials": "Editor Python, terminal para execução",
                                  "tips": "Use repr() ou str() no __init__ para prints mais informativos.",
                                  "learningObjective": "Garantir robustez na criação e uso de instâncias parametrizadas.",
                                  "commonMistakes": "Instâncias compartilhando atributos (erro de self); TypeErrors em argumentos errados."
                                }
                              ],
                              "practicalExample": "class Carro:\n    def __init__(self, modelo, ano):\n        self.modelo = modelo\n        self.ano = ano\n\ncarro_fusca = Carro('Fusca', 1970)\nprint(carro_fusca.modelo)  # Saída: Fusca\nprint(carro_fusca.ano)     # Saída: 1970\ncarro_fusca.modelo = 'Fusca Restaurado'\nprint(carro_fusca.modelo)  # Saída: Fusca Restaurado",
                              "finalVerifications": [
                                "Instância criada sem erros de TypeError ou SyntaxError.",
                                "Atributos acessados corretamente via notação ponto.",
                                "Valores dos parâmetros refletidos nos atributos.",
                                "Modificações em atributos persistem na instância.",
                                "Múltiplas instâncias independentes funcionam.",
                                "Saídas de print confirmam valores esperados."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe de instanciação 100% correta (parênteses, vírgulas, ordem).",
                                "Atributos inicializados com valores passados (verificação por print).",
                                "Acesso e modificação de atributos sem erros.",
                                "Uso independente de múltiplas instâncias.",
                                "Código limpo, sem warnings ou erros no execution.",
                                "Exemplo prático funcional e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Parâmetros como argumentos de funções matemáticas.",
                                "Física: Modelagem de entidades reais (ex: veículos com propriedades).",
                                "Língua Portuguesa: Nomeação clara e descritiva de classes e atributos.",
                                "Artes: Design de objetos visuais em simulações."
                              ],
                              "realWorldApplication": "Em desenvolvimento de jogos (criar personagens com stats personalizadas), apps de e-commerce (produtos com preço e estoque), sistemas de gerenciamento (usuários com nome e ID), ou simulações científicas (partículas com massa e velocidade)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.2.3",
                              "10.1.1.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.1.2.3.3",
                            "name": "Comparar instanciação em Python e C++",
                            "description": "Analisar diferenças na sintaxe: Python (obj = Classe(args)) vs C++ (Classe* obj = new Classe(args);), executando exemplos simples em ambas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Instanciação em Python",
                                  "subSteps": [
                                    "Defina uma classe simples, como 'Pessoa', com atributos nome e idade no método __init__.",
                                    "Instancie o objeto usando a sintaxe obj = Pessoa('João', 30).",
                                    "Acesse atributos e chame métodos no objeto instanciado.",
                                    "Use print para verificar o estado do objeto.",
                                    "Experimente passar argumentos variáveis ou usar valores padrão."
                                  ],
                                  "verification": "Código executa sem erros, objeto é criado e atributos são acessíveis corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor Python (IDLE ou VSCode)",
                                    "Documentação oficial Python sobre classes"
                                  ],
                                  "tips": "Sempre use self nos métodos para referenciar atributos da instância.",
                                  "learningObjective": "Dominar a sintaxe simples e direta de criação de objetos em Python.",
                                  "commonMistakes": "Esquecer de chamar __init__ implicitamente ou passar argumentos incorretos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a Instanciação em C++",
                                  "subSteps": [
                                    "Inclua headers necessários (#include <iostream>, #include <string>) e defina uma classe 'Pessoa'.",
                                    "Implemente o construtor na classe para inicializar nome e idade.",
                                    "Instancie usando ponteiro: Pessoa* obj = new Pessoa('João', 30);",
                                    "Acesse membros via ponteiro (->) e imprima valores.",
                                    "Libere memória com delete obj; para evitar vazamentos."
                                  ],
                                  "verification": "Programa compila e executa, objeto é criado, usado e memória liberada sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador C++ (g++ ou IDE como Code::Blocks)",
                                    "Referência C++ sobre new/delete"
                                  ],
                                  "tips": "Sempre pareie new com delete para gerenciar memória manualmente.",
                                  "learningObjective": "Entender o uso de ponteiros e alocação dinâmica em C++.",
                                  "commonMistakes": "Esquecer delete, causando memory leak, ou usar . em vez de -> em ponteiros."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diferenças Sintáticas e Conceituais",
                                  "subSteps": [
                                    "Liste diferenças: Python (obj = Classe(args)) vs C++ (Classe* obj = new Classe(args);).",
                                    "Analise gerenciamento de memória: automático em Python (GC) vs manual em C++.",
                                    "Compare acesso a membros: . em Python vs -> em C++ para ponteiros.",
                                    "Discuta vantagens: simplicidade Python vs controle fino C++.",
                                    "Registre em tabela ou notas as similaridades e diferenças chave."
                                  ],
                                  "verification": "Tabela ou lista comparativa completa e precisa é criada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel/notas ou editor de texto",
                                    "Exemplos de código das etapas anteriores"
                                  ],
                                  "tips": "Use uma tabela com colunas Python, C++, Diferença e Implicação.",
                                  "learningObjective": "Identificar e explicar diferenças fundamentais na sintaxe de instanciação.",
                                  "commonMistakes": "Ignorar gerenciamento de memória ou confundir sintaxe de acesso."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar Exemplos Comparativos em Ambas as Linguagens",
                                  "subSteps": [
                                    "Crie códigos idênticos funcionalmente: classe Pessoa com getNome() e getIdade().",
                                    "Execute em Python: instancie múltiplos objetos e teste métodos.",
                                    "Execute em C++: instancie múltiplos objetos com new, teste e delete todos.",
                                    "Compare outputs e performance básica (tempo de execução aproximado).",
                                    "Documente qualquer erro encontrado e correções aplicadas."
                                  ],
                                  "verification": "Ambos códigos rodam perfeitamente, produzindo saídas idênticas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ambientes de Python e C++ configurados",
                                    "Timer para performance básica"
                                  ],
                                  "tips": "Compile C++ com -Wall para detectar warnings de memória.",
                                  "learningObjective": "Aplicar conhecimento prático comparando execuções reais.",
                                  "commonMistakes": "Não liberar memória em C++ ou erros de compilação por sintaxe."
                                }
                              ],
                              "practicalExample": "Crie uma classe 'Carro' com atributos marca e ano. Em Python: carro = Carro('Toyota', 2020); print(carro.marca). Em C++: Carro* carro = new Carro('Toyota', 2020); cout << carro->marca; delete carro; Observe a criação simples em Python vs alocação manual em C++.",
                              "finalVerifications": [
                                "Explicar corretamente a sintaxe de instanciação em ambas linguagens.",
                                "Identificar necessidade de new/delete em C++ e ausência em Python.",
                                "Executar exemplos sem erros de compilação ou runtime.",
                                "Listar pelo menos 3 diferenças chave em gerenciamento de memória.",
                                "Comparar acesso a membros (. vs ->) com exemplos.",
                                "Demonstrar criação de múltiplas instâncias em ambas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição sintática (100% correto).",
                                "Compreensão de conceitos de memória (GC vs manual).",
                                "Execução bem-sucedida de códigos comparativos.",
                                "Análise clara de prós/contras de cada abordagem.",
                                "Documentação completa de comparações.",
                                "Identificação correta de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de alocação de recursos e ponteiros como endereços.",
                                "Inglês: Leitura de documentação oficial de Python e C++.",
                                "Física: Analogia com alocação de espaço em sistemas físicos.",
                                "Lógica: Raciocínio sobre fluxo de controle e gerenciamento de recursos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software embarcado (C++ para performance) com scripts Python para prototipagem rápida, ou em engines de jogos como Unreal (C++) com Python para automação, garantindo migração suave de objetos entre linguagens."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.3",
                    "name": "Definição de Métodos de Instância",
                    "description": "Como declarar e implementar métodos associados a instâncias, utilizando referências como 'self' em Python.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.3.1",
                        "name": "Método de Instância",
                        "description": "Um método de instância é uma função definida dentro de uma classe que atua sobre os atributos e comportamentos específicos de uma instância da classe, permitindo a manipulação de dados particulares de cada objeto criado.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.1.1",
                            "name": "Identificar um método de instância",
                            "description": "Diferenciar métodos de instância de métodos estáticos ou de classe, reconhecendo sua associação exclusiva a objetos individuais por meio de exemplos de código Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos de Métodos em Classes Python",
                                  "subSteps": [
                                    "Revise a definição de uma classe em Python usando 'class NomeClasse:'",
                                    "Identifique o parâmetro 'self' como referência à instância atual",
                                    "Observe que métodos normais requerem 'self' como primeiro parâmetro",
                                    "Execute um código simples criando uma classe com um método básico",
                                    "Note que métodos sem decoradores são métodos de instância por padrão"
                                  ],
                                  "verification": "Crie uma classe simples com um método que usa 'self' e chame-o em uma instância; confirme que funciona sem erros",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de código Python (ex: VS Code, IDLE), documentação oficial Python sobre classes",
                                  "tips": "Sempre leia a assinatura do método primeiro: presença de 'self' é o indicador chave",
                                  "learningObjective": "Compreender que métodos de instância são definidos dentro de classes e usam 'self' para acessar atributos da instância",
                                  "commonMistakes": "Confundir 'self' com uma variável global; esquecer que 'self' deve ser o primeiro parâmetro"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar Métodos de Instância de Outros Tipos de Métodos",
                                  "subSteps": [
                                    "Analise um método estático decorado com '@staticmethod' (sem 'self' ou 'cls')",
                                    "Examine um método de classe decorado com '@classmethod' (usa 'cls' em vez de 'self')",
                                    "Compare chamadas: métodos de instância via objeto, estáticos/classe via classe",
                                    "Crie exemplos paralelos de cada tipo em uma mesma classe",
                                    "Teste chamadas incorretas para observar erros (ex: chamar método de instância sem objeto)"
                                  ],
                                  "verification": "Escreva uma classe com os três tipos de métodos e chame cada um corretamente, registrando os resultados",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor Python, console interativo (REPL) para testes rápidos",
                                  "tips": "Lembre-se: decoradores definem o tipo; sem decorador e com 'self', é de instância",
                                  "learningObjective": "Distinguir métodos de instância (self, por objeto) de estáticos (sem self/cls) e de classe (cls)",
                                  "commonMistakes": "Ignorar decoradores e focar só em parâmetros; chamar método de instância via classe"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar Identificação em Exemplos de Código",
                                  "subSteps": [
                                    "Analise códigos fornecidos ou gerados com métodos misturados",
                                    "Marque cada método como instância, estático ou classe baseado em assinatura e decoradores",
                                    "Explique por quê cada método é do tipo identificado (cite 'self', '@staticmethod', etc.)",
                                    "Modifique um método de instância para estático e observe mudanças no comportamento",
                                    "Resolva 5-10 exercícios de identificação em códigos variados"
                                  ],
                                  "verification": "Liste corretamente o tipo de 10 métodos em códigos de teste, com justificativa para cada",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Exercícios impressos ou online (ex: LeetCode, HackerRank OOP), Jupyter Notebook",
                                  "tips": "Procure primeiro por decoradores, depois por parâmetros: self > cls > nenhum",
                                  "learningObjective": "Aplicar critérios de identificação para classificar métodos em códigos reais",
                                  "commonMistakes": "Confundir métodos com funções fora da classe; não testar chamadas"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Reforçar a Compreensão com Testes",
                                  "subSteps": [
                                    "Crie seu próprio código com métodos de instância e outros tipos",
                                    "Peça a um par para revisar sua identificação ou use ferramentas de linting",
                                    "Resolva quizzes online sobre OOP Python focados em métodos",
                                    "Documente 3 exemplos pessoais onde identificação correta evitaria erros",
                                    "Reflita sobre cenários onde confundir tipos causa bugs"
                                  ],
                                  "verification": "Aceda 90% em um quiz de 20 questões sobre identificação de métodos",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Plataformas de quiz (ex: Codecademy, Python.org exercises), parceiro de estudo",
                                  "tips": "Use print statements dentro de métodos para rastrear 'self' durante execução",
                                  "learningObjective": "Consolidar habilidade de identificação através de prática autônoma e autoavaliação",
                                  "commonMistakes": "Não testar código; assumir sem verificar decoradores"
                                }
                              ],
                              "practicalExample": "Considere a classe Carro:\nclass Carro:\n    def __init__(self, cor): self.cor = cor  # Método de instância\n    @staticmethod\n    def info_geral(): return 'Carro genérico'  # Estático\n    @classmethod\n    def de_fabrica(cls): return cls('preto')  # De classe\nIdentifique: __init__ é de instância (usa self); info_geral é estático (decorator, sem self); de_fabrica é de classe (cls).",
                              "finalVerifications": [
                                "Pode listar características únicas de métodos de instância (self, chamado via objeto)",
                                "Identifica corretamente em código sem decoradores e com 'self'",
                                "Explica diferença em chamadas: obj.metodo() vs Classe.metodo()",
                                "Detecta erros comuns como chamar método de instância via classe",
                                "Cria exemplo funcional com método de instância acessando atributo",
                                "Diferencia de métodos especiais como __init__ ou __str__"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação: 90%+ correto em testes",
                                "Justificativa clara: cita self/decorator em todas as respostas",
                                "Compreensão conceitual: explica associações a objetos individuais",
                                "Aplicação prática: modifica código corretamente sem quebrar funcionalidade",
                                "Profundidade: menciona contextos de uso (estado mutável via self)",
                                "Auto-correção: identifica e corrige erros próprios"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Analogia com funções de instância em álgebra (ex: métodos em vetores)",
                                "Lógica/Algoritmos: Fluxo de decisão para classificação de métodos como árvore binária",
                                "Design de Software: Modelagem de entidades reais (UML classes com métodos)",
                                "Biologia: Modelagem de objetos biológicos (instâncias de espécies com métodos individuais)"
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps como jogos (método mover() em Player instance) ou sistemas bancários (método sacar() em Conta instance), identificar métodos de instância garante que ações afetem apenas o objeto específico, evitando bugs globais em equipes de programação."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.2",
                            "name": "Explicar o propósito de métodos de instância",
                            "description": "Descrever como métodos de instância promovem encapsulamento e abstração, permitindo que cada instância mantenha seu estado independente e execute ações personalizadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir métodos de instância e sua distinção de métodos estáticos",
                                  "subSteps": [
                                    "Revise a definição básica de classe e instância em OOP.",
                                    "Identifique a sintaxe para definir um método de instância (ex: def method(self) em Python).",
                                    "Compare com métodos de classe ou estáticos, que não acessam self.",
                                    "Crie um exemplo simples de classe com um método de instância.",
                                    "Explique por que 'self' (ou 'this') é crucial para acesso a atributos de instância."
                                  ],
                                  "verification": "Escreva uma definição clara e um snippet de código distinguindo métodos de instância de estáticos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código (VS Code ou Jupyter), documentação OOP (Python/Java).",
                                  "tips": "Sempre inclua 'self' como primeiro parâmetro para reforçar o foco na instância.",
                                  "learningObjective": "Compreender a estrutura fundamental de métodos de instância.",
                                  "commonMistakes": "Confundir com funções globais ou esquecer o parâmetro 'self/this'."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar como métodos de instância promovem encapsulamento",
                                  "subSteps": [
                                    "Defina encapsulamento como esconder detalhes internos e expor apenas interfaces.",
                                    "Mostre como atributos privados são acessados/modificados apenas via métodos de instância.",
                                    "Implemente getters e setters como métodos de instância.",
                                    "Demonstre validação de dados dentro do método (ex: checar se idade > 0).",
                                    "Discuta benefícios: proteção de estado e interface controlada."
                                  ],
                                  "verification": "Refatore um atributo público para privado e crie métodos de acesso, testando validação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código, exemplos de classes com atributos privados.",
                                  "tips": "Use convenções como _atributo para protected ou __atributo para private em Python.",
                                  "learningObjective": "Aplicar encapsulamento através de métodos de instância para proteger dados.",
                                  "commonMistakes": "Acessar atributos diretamente em vez de via métodos, quebrando encapsulamento."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar abstração fornecida por métodos de instância",
                                  "subSteps": [
                                    "Defina abstração como esconder complexidade e mostrar apenas o essencial.",
                                    "Crie um método de instância que abstrai lógica complexa (ex: calcular salário líquido).",
                                    "Explique como o usuário da classe chama o método sem conhecer implementação interna.",
                                    "Refatore um método para simplificar sua interface pública.",
                                    "Compare chamadas de métodos vs. código inline para destacar abstração."
                                  ],
                                  "verification": "Escreva um método que abstrai uma operação complexa e explique sua interface simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código, diagramas UML opcionais.",
                                  "tips": "Mantenha métodos com responsabilidades únicas (Single Responsibility Principle).",
                                  "learningObjective": "Usar métodos de instância para abstrair complexidade e melhorar usabilidade.",
                                  "commonMistakes": "Expor implementação interna no nome ou parâmetros do método."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar estado independente e ações personalizadas por instância",
                                  "subSteps": [
                                    "Crie múltiplas instâncias da mesma classe com estados diferentes.",
                                    "Chame o mesmo método em cada instância e observe resultados personalizados.",
                                    "Altere o estado de uma instância e verifique independência das outras.",
                                    "Adicione lógica no método que depende do estado atual da instância.",
                                    "Sintetize como isso permite modelagem de objetos reais com comportamentos únicos."
                                  ],
                                  "verification": "Crie 3 instâncias, execute métodos e confirme independência de estados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código, console para testes interativos.",
                                  "tips": "Use print statements para visualizar estados durante execuções.",
                                  "learningObjective": "Ilustrar como métodos de instância habilitam comportamentos instância-específicos.",
                                  "commonMistakes": "Usar variáveis globais em vez de atributos de instância, violando independência."
                                }
                              ],
                              "practicalExample": "Considere uma classe Carro: def __init__(self, tanque): self._tanque = tanque. Método drive(self, distancia): if self._tanque >= distancia / 10: self._tanque -= distancia / 10; return 'Dirigindo!'. Cada carro mantém seu tanque independente, e drive() personaliza a ação baseada no estado.",
                              "finalVerifications": [
                                "Explicar verbalmente o propósito de métodos de instância em 1 minuto.",
                                "Identificar corretamente métodos de instância em código fornecido.",
                                "Refatorar código sem encapsulamento para usar métodos de instância.",
                                "Criar exemplo próprio com estado independente.",
                                "Diferenciar impactos de métodos de instância vs. estáticos em múltiplas instâncias.",
                                "Discutir trade-offs de encapsulamento/abstração em cenários reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de métodos de instância e distinção de outros tipos (30%).",
                                "Demonstração clara de encapsulamento com exemplos de proteção de dados (25%).",
                                "Explicação efetiva de abstração e interface simplificada (20%).",
                                "Evidência de compreensão de estado independente via testes com múltiplas instâncias (15%).",
                                "Uso correto de conceitos OOP em exemplos práticos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções como métodos que operam em variáveis independentes.",
                                "Biologia: Comportamentos de organismos (instâncias) com estados genéticos únicos.",
                                "Física: Simulações de partículas com propriedades e interações personalizadas.",
                                "Língua: Abstração em narrativas onde ações dependem de contexto individual."
                              ],
                              "realWorldApplication": "Em desenvolvimento de jogos, métodos de instância em classes Player permitem que cada jogador tenha vida, score e ações únicas (ex: atirar() usa munição pessoal). Em apps bancários, Account.drive() (saque) valida saldo individual, promovendo segurança e modularidade."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.3",
                            "name": "Comparar com métodos estáticos",
                            "description": "Comparar métodos de instância (que requerem uma instância para serem chamados) com métodos estáticos (chamados diretamente na classe), usando exemplos simples em Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos de Métodos de Instância",
                                  "subSteps": [
                                    "Defina um método de instância em uma classe Python, incluindo o parâmetro 'self' como primeiro argumento.",
                                    "Crie uma instância da classe e acesse atributos de instância dentro do método.",
                                    "Chame o método usando a sintaxe objeto.metodo(), observando que requer uma instância.",
                                    "Teste alterando um atributo de instância e veja como afeta chamadas subsequentes.",
                                    "Registre o comportamento: o método acessa estado específico da instância."
                                  ],
                                  "verification": "Execute o código e confirme que o método só funciona após criar uma instância e que reflete mudanças no estado da instância.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código Python (ex: VS Code, PyCharm)",
                                    "Console Python REPL"
                                  ],
                                  "tips": "Use print statements para visualizar o valor de 'self' e atributos durante a execução.",
                                  "learningObjective": "Compreender que métodos de instância dependem de uma instância específica e acessam seu estado.",
                                  "commonMistakes": [
                                    "Esquecer o parâmetro 'self' causando TypeError",
                                    "Tentar chamar o método diretamente na classe sem instância"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender Definição e Uso de Métodos Estáticos",
                                  "subSteps": [
                                    "Adicione o decorador @staticmethod acima de um método na classe, sem parâmetro 'self'.",
                                    "Implemente lógica que não dependa de atributos de instância, como uma função utilitária.",
                                    "Chame o método diretamente na classe: Classe.metodo_estatico(), e também via instância para comparar.",
                                    "Teste múltiplas instâncias e confirme que o método retorna o mesmo resultado independentemente do estado.",
                                    "Documente que não há acesso a 'self' ou estado de instância."
                                  ],
                                  "verification": "Execute chamadas via classe e instância, verificando resultados idênticos sem erros de estado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código Python",
                                    "Console Python REPL"
                                  ],
                                  "tips": "Mantenha métodos estáticos simples e independentes para evitar confusão com lógica de instância.",
                                  "learningObjective": "Identificar que métodos estáticos são funções de classe, independentes de instâncias.",
                                  "commonMistakes": [
                                    "Incluir 'self' em método estático causando erros de argumentos",
                                    "Confundir com métodos de classe que usam 'cls'"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Exemplos Comparativos em uma Classe Única",
                                  "subSteps": [
                                    "Crie uma classe exemplo (ex: Calculadora) com um método de instância que usa um atributo (ex: modo de cálculo) e um método estático para operação fixa (ex: fatorial).",
                                    "Instancie a classe duas vezes com estados diferentes e chame ambos os métodos em cada.",
                                    "Compare saídas: método de instância varia por instância, estático é consistente.",
                                    "Adicione prints para mostrar chamadas: uma via classe, outra via objeto.",
                                    "Salve o código em um arquivo .py para reutilização."
                                  ],
                                  "verification": "Rode o script e capture saídas mostrando diferenças claras entre os métodos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código Python",
                                    "Console Python REPL"
                                  ],
                                  "tips": "Use nomes descritivos como instance_method e static_method para clareza.",
                                  "learningObjective": "Aplicar ambos os tipos de métodos em código prático para observar comportamentos.",
                                  "commonMistakes": [
                                    "Acessar atributos de instância em método estático causando AttributeError",
                                    "Esquecer @staticmethod"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Comparar Diferenças Chave",
                                  "subSteps": [
                                    "Crie uma tabela ou lista comparando: sintaxe de chamada, parâmetros, dependência de estado, casos de uso.",
                                    "Discuta quando usar cada: instância para estado mutável, estático para utilitários puros.",
                                    "Refatore um método de instância desnecessariamente dependente para estático e teste.",
                                    "Resuma prós/contras: estáticos são mais eficientes para funções globais, instância para encapsulamento.",
                                    "Explique verbalmente ou em comentários as implicações em OOP."
                                  ],
                                  "verification": "Escreva um resumo de 5-10 linhas comparando os dois e valide com um colega ou auto-teste.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código Python",
                                    "Papel ou documento Markdown para tabela"
                                  ],
                                  "tips": "Pense em cenários reais: utilitários como math.sqrt() são estáticos.",
                                  "learningObjective": "Sintetizar comparações para decidir uso apropriado em design de classes.",
                                  "commonMistakes": [
                                    "Ignorar overhead de instância em métodos simples",
                                    "Usar estáticos quando estado é necessário"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe Calculadora:\nclass Calculadora:\n    def __init__(self, modo):\n        self.modo = modo\n    def somar_instancia(self, a, b):\n        return a + b if self.modo == 'int' else float(a + b)\n    @staticmethod\n    def fatorial(n):\n        return 1 if n <= 1 else n * Calculadora.fatorial(n-1)\n\nc1 = Calculadora('int')\nprint(c1.somar_instancia(2,3))  # 5\nprint(Calculadora.fatorial(5))  # 120",
                              "finalVerifications": [
                                "Explique corretamente a diferença na sintaxe de chamada (objeto vs classe).",
                                "Demonstre código com ambos os métodos funcionando sem erros.",
                                "Identifique que métodos estáticos não acessam 'self' ou estado de instância.",
                                "Dê um exemplo de quando preferir um sobre o outro.",
                                "Compare saídas de chamadas via instância e classe para método estático.",
                                "Refatore um método incorretamente implementado."
                              ],
                              "assessmentCriteria": [
                                "Código executa sem erros e demonstra diferenças claras (40%)",
                                "Explicação precisa de conceitos e comparações (30%)",
                                "Uso correto de @staticmethod e 'self' (15%)",
                                "Identificação de casos de uso apropriados (10%)",
                                "Clareza em exemplos e verificações (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções puras vs dependentes de variáveis (métodos estáticos como funções matemáticas).",
                                "Lógica e Filosofia: Abstração e independência conceitual em raciocínio.",
                                "Design de Software: Princípios de modularidade e reutilização em engenharia.",
                                "Inglês Técnico: Terminologia OOP como 'instance' vs 'static'."
                              ],
                              "realWorldApplication": "Em bibliotecas como math (métodos estáticos para funções puras como sqrt()), ou classes utilitárias em frameworks web (ex: validators estáticos em Django), permitindo chamadas eficientes sem instâncias desnecessárias, otimizando performance em apps escaláveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.2",
                        "name": "Parâmetro 'self'",
                        "description": "'self' é a referência convencional ao primeiro parâmetro em métodos de instância em Python, representando a instância atual da classe e permitindo acesso a seus atributos e outros métodos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.2.1",
                            "name": "Declarar 'self' na assinatura do método",
                            "description": "Escrever corretamente a assinatura de um método de instância incluindo 'self' como primeiro parâmetro, sem passá-lo explicitamente ao chamar o método na instância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de 'self' em métodos de instância",
                                  "subSteps": [
                                    "Leia a documentação oficial do Python sobre classes e instâncias (docs.python.org/3/tutorial/classes.html).",
                                    "Identifique que 'self' refere-se à instância atual da classe.",
                                    "Compare com linguagens como Java, onde 'this' é usado similarmente.",
                                    "Anote exemplos de por que 'self' é obrigatório na definição, mas não na chamada.",
                                    "Discuta em um fórum ou com um par o papel de 'self' na passagem implícita."
                                  ],
                                  "verification": "Escreva uma definição escrita de 'self' em suas próprias palavras e compare com a documentação oficial.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação Python oficial, caderno para anotações, navegador web",
                                  "tips": "Pense em 'self' como 'eu mesmo' – a instância falando sobre si mesma.",
                                  "learningObjective": "Compreender o propósito e a mecânica de 'self' como primeiro parâmetro em métodos de instância.",
                                  "commonMistakes": "Confundir 'self' com um parâmetro global ou achar que é opcional em Python."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever a assinatura básica de um método com 'self'",
                                  "subSteps": [
                                    "Crie uma classe vazia chamada 'MeuExemplo'.",
                                    "Defina um método chamado 'meu_metodo' com assinatura 'def meu_metodo(self):'.",
                                    "Adicione um print simples no corpo: print('Método chamado!').",
                                    "Salve o código em um arquivo .py.",
                                    "Execute o arquivo para verificar sintaxe sem erros."
                                  ],
                                  "verification": "O código compila sem erros de sintaxe ao executar python arquivo.py.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de código (VS Code ou IDLE), interpretador Python instalado",
                                  "tips": "Sempre coloque 'self' como o primeiro parâmetro, seguido de uma vírgula se houver outros.",
                                  "learningObjective": "Declarar corretamente a assinatura de um método de instância incluindo 'self'.",
                                  "commonMistakes": "Esquecer os dois pontos após a assinatura ou omitir parênteses."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e acessar atributos via 'self' no método",
                                  "subSteps": [
                                    "Adicione um atributo na __init__: self.nome = nome.",
                                    "No método, use self.nome para acessar e imprimir o atributo.",
                                    "Crie o __init__ com def __init__(self, nome):.",
                                    "Teste a sintaxe executando o script.",
                                    "Corrija qualquer IndentationError comum."
                                  ],
                                  "verification": "Execute o código e confirme que não há erros ao definir a classe.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Mesmo editor e Python do step anterior",
                                  "tips": "Use Tab ou 4 espaços consistentes para indentação.",
                                  "learningObjective": "Utilizar 'self' para acessar atributos de instância dentro do método.",
                                  "commonMistakes": "Esquecer 'self.' antes do atributo, causando NameError."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Instanciar a classe e chamar o método sem passar 'self'",
                                  "subSteps": [
                                    "Crie uma instância: obj = MeuExemplo('Teste').",
                                    "Chame o método: obj.meu_metodo().",
                                    "Observe que 'self' não é passado explicitamente.",
                                    "Adicione mais uma chamada para confirmar.",
                                    "Execute e verifique a saída no console."
                                  ],
                                  "verification": "O método executa corretamente, imprimindo o esperado, sem erros como TypeError.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de código e terminal Python",
                                  "tips": "Lembre-se: Python passa 'self' automaticamente na chamada de instância.",
                                  "learningObjective": "Chamar métodos de instância corretamente sem explicitar 'self'.",
                                  "commonMistakes": "Tentar chamar como MinhaClasse.meu_metodo() sem instância, ou passar 'self' manualmente."
                                }
                              ],
                              "practicalExample": "```python\nclass Pessoa:\n    def __init__(self, nome):\n        self.nome = nome\n    \n    def saudar(self):\n        print(f'Olá, eu sou {self.nome}!')\n\np = Pessoa('Alice')\np.saudar()  # Saída: Olá, eu sou Alice! (sem passar self)\n```",
                              "finalVerifications": [
                                "Código roda sem SyntaxError ou TypeError relacionado a 'self'.",
                                "Método acessa corretamente atributos via self sem NameError.",
                                "Chamada de método em instância funciona sem argumentos extras.",
                                "Múltiplas instâncias compartilham a mesma definição de método.",
                                "Comentários no código explicam o uso de 'self'.",
                                "Teste unitário simples passa (usando assert)."
                              ],
                              "assessmentCriteria": [
                                "'self' presente como primeiro parâmetro em TODOS os métodos de instância.",
                                "Corretas referências a self.atributo dentro dos métodos.",
                                "Chamadas de métodos sem 'self' explícito.",
                                "Código limpo, indentado corretamente e sem erros de sintaxe.",
                                "Exemplo prático demonstra uso real com atributos.",
                                "Explicação escrita correta sobre por que 'self' é implícito na chamada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de objetos como entidades com atributos (álgebra).",
                                "Língua Portuguesa: Nomenclatura clara em variáveis e métodos.",
                                "Física: Conceito de instâncias como partículas individuais em um sistema.",
                                "Inglês: Convenções PEP8 para nomes como 'self'."
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps Python como Django ou Flask, 'self' é essencial para modelos de dados em OOP, permitindo que instâncias de classes (ex: User) acessem seus próprios dados em métodos como save() ou validate(), escalando para sistemas empresariais reais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.2.2",
                            "name": "Acessar atributos via 'self'",
                            "description": "Utilizar 'self.nome_atributo' dentro do método para ler ou modificar atributos de instância, demonstrando em código como isso mantém o estado específico do objeto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de 'self' e atributos de instância",
                                  "subSteps": [
                                    "Leia a definição de classe em Python e identifique onde 'self' é usado no __init__.",
                                    "Explique em suas palavras: 'self' refere-se à instância atual do objeto.",
                                    "Diferencie atributos de classe (compartilhados) de atributos de instância (via self).",
                                    "Crie um diagrama simples mostrando uma instância acessando seu próprio atributo via self.",
                                    "Teste conceitualmente: por que sem 'self', o atributo não seria acessível no método?"
                                  ],
                                  "verification": "Resuma o conceito em 3 frases e desenhe um fluxograma simples do acesso via self.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE (VS Code, PyCharm)",
                                    "Documentação Python sobre classes (docs.python.org)"
                                  ],
                                  "tips": "Pense em 'self' como 'eu mesmo' no contexto do objeto, similar a 'this' em outras linguagens.",
                                  "learningObjective": "Entender que 'self' permite acesso ao estado específico da instância dentro de métodos.",
                                  "commonMistakes": [
                                    "Confundir 'self' com parâmetro global; esquecer que é obrigatório em métodos de instância."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir uma classe com atributos de instância no __init__",
                                  "subSteps": [
                                    "Crie uma classe simples chamada 'Carro' com atributos 'cor' e 'modelo' inicializados via self no __init__.",
                                    "Adicione parâmetros ao __init__ para receber valores iniciais e atribuí-los via self.cor = cor.",
                                    "Instancie um objeto Carro e imprima seus atributos diretamente (carro.cor).",
                                    "Verifique se cada instância tem seus próprios valores (crie duas instâncias diferentes).",
                                    "Adicione um print no __init__ para confirmar que self está vinculado à instância certa."
                                  ],
                                  "verification": "Execute o código e confirme que duas instâncias têm atributos independentes via print(car1.cor) e print(car2.cor).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python 3.x instalado",
                                    "REPL ou Jupyter Notebook para testes rápidos"
                                  ],
                                  "tips": "Sempre use self. no __init__ para evitar shadowing de variáveis locais.",
                                  "learningObjective": "Criar atributos de instância que persistem no objeto via self.",
                                  "commonMistakes": [
                                    "Esquecer self. nos atributos no __init__; atribuir sem self, tornando local."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar método de instância que lê atributos via 'self'",
                                  "subSteps": [
                                    "Adicione um método 'obter_info' à classe Carro que retorna f\"O carro é {self.cor} e modelo {self.modelo}\".",
                                    "Chame o método em uma instância e verifique se acessa os atributos corretos.",
                                    "Crie múltiplas instâncias e chame o método em cada uma para confirmar estado específico.",
                                    "Modifique um atributo diretamente (carro.cor = 'azul') e chame o método novamente.",
                                    "Adicione um print(self) dentro do método para visualizar a instância referenciada."
                                  ],
                                  "verification": "O método retorna informações corretas e específicas para cada instância, sem erros de atributo não encontrado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Mesmo ambiente do step anterior",
                                    "Exemplos de código de classes OOP"
                                  ],
                                  "tips": "self é passado automaticamente ao chamar métodos; não o passe manualmente como carro.obter_info(car).",
                                  "learningObjective": "Usar self para ler atributos dentro de métodos, mantendo encapsulamento.",
                                  "commonMistakes": [
                                    "Omitir self. no método, causando NameError; chamar método com self explícito."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar método que modifica atributos via 'self' e testar completamente",
                                  "subSteps": [
                                    "Adicione um método 'pintar' que recebe uma nova_cor e faz self.cor = nova_cor.",
                                    "Chame pintar em uma instância, depois verifique com obter_info se mudou.",
                                    "Teste em múltiplas instâncias para garantir que uma não afeta a outra.",
                                    "Adicione validação no método: se nova_cor vazia, não modifique e retorne mensagem.",
                                    "Execute cenários: modificar, ler, criar nova instância e comparar."
                                  ],
                                  "verification": "Após chamar pintar('vermelho'), obter_info reflete a mudança apenas na instância modificada.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Script Python completo",
                                    "Debugger para inspecionar self"
                                  ],
                                  "tips": "Modificações via self alteram o estado persistente do objeto para chamadas futuras.",
                                  "learningObjective": "Modificar estado da instância via self em métodos, demonstrando mutabilidade.",
                                  "commonMistakes": [
                                    "Retornar valor sem alterar self; esquecer de atualizar self no método."
                                  ]
                                }
                              ],
                              "practicalExample": "```python\nclass Carro:\n    def __init__(self, cor, modelo):\n        self.cor = cor\n        self.modelo = modelo\n    \n    def obter_info(self):\n        return f\"Carro: {self.modelo}, cor {self.cor}\"\n    \n    def pintar(self, nova_cor):\n        self.cor = nova_cor\n\ncar1 = Carro('azul', 'Fusca')\nprint(car1.obter_info())  # Carro: Fusca, cor azul\ncar1.pintar('vermelho')\nprint(car1.obter_info())  # Carro: Fusca, cor vermelha\n```",
                              "finalVerifications": [
                                "Código executa sem erros de sintaxe ou NameError.",
                                "Múltiplas instâncias mantêm estados independentes ao acessar/modificar via self.",
                                "Métodos leem e modificam atributos corretamente, refletindo mudanças.",
                                "Print de self dentro de métodos mostra instância correta.",
                                "Validação em métodos previne erros (ex: cor vazia).",
                                "Diagrama ou resumo conceitual explica o fluxo de self."
                              ],
                              "assessmentCriteria": [
                                "Precisão no uso de self. em todos os acessos (100% correto).",
                                "Independência de estados entre instâncias demonstrada em testes.",
                                "Métodos funcionais com leitura e modificação via self.",
                                "Código limpo, indentado e comentado explicando self.",
                                "Compreensão conceitual via explicação ou diagrama.",
                                "Testes cobrem cenários edge (ex: atributos não inicializados)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de objetos como vetores com coordenadas acessadas via self.",
                                "Física: Simulações de partículas onde posição e velocidade são atributos mutáveis via self.",
                                "Língua Portuguesa: Documentação de métodos explicando o uso de self.",
                                "Artes: Criação de classes para elementos gráficos com propriedades visuais via self."
                              ],
                              "realWorldApplication": "Em jogos como RPGs, personagens usam self.vida para ler/modificar saúde durante batalhas; em apps bancários, contas acessam self.saldo via métodos para depósitos/retiradas, garantindo estado único por usuário."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.2.3",
                            "name": "Chamar outros métodos via 'self'",
                            "description": "Invocar métodos de instância adicionais usando 'self.nome_metodo()' dentro de um método, ilustrando a chain de chamadas dentro da mesma instância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definição de classe com múltiplos métodos de instância",
                                  "subSteps": [
                                    "Crie uma classe simples com pelo menos dois métodos de instância que usam 'self'.",
                                    "Defina atributos de instância nos métodos usando 'self.atributo'.",
                                    "Garanta que cada método acesse ou modifique atributos compartilhados via 'self'.",
                                    "Salve o código em um arquivo Python e execute para verificar sintaxe.",
                                    "Adicione prints nos métodos para observar a execução sequencial."
                                  ],
                                  "verification": "Execute o código e confirme que ambos os métodos acessam os mesmos atributos sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Python 3.x instalado",
                                    "Terminal para execução"
                                  ],
                                  "tips": "Sempre idente corretamente os métodos dentro da classe para evitar erros de indentação.",
                                  "learningObjective": "Compreender como múltiplos métodos compartilham estado via 'self' na mesma classe.",
                                  "commonMistakes": [
                                    "Esquecer parênteses em def método(self):",
                                    "Não usar 'self' em atributos dentro de métodos",
                                    "Confundir métodos de classe com métodos de instância"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar chamada de método simples via 'self'",
                                  "subSteps": [
                                    "No primeiro método, adicione uma linha: self.segundo_metodo() no final.",
                                    "Certifique-se de que o segundo método retorne um valor ou modifique um atributo.",
                                    "Atualize o primeiro método para usar o retorno do segundo método se aplicável.",
                                    "Teste chamando apenas o primeiro método na instância para acionar a chain.",
                                    "Use print statements para rastrear a ordem de execução."
                                  ],
                                  "verification": "Ao instanciar e chamar o primeiro método, o segundo é executado automaticamente sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmo arquivo Python do step anterior",
                                    "Console para debugar prints"
                                  ],
                                  "tips": "Chame self.metodo() exatamente como chamaria em uma instância externa, mas sem o objeto.",
                                  "learningObjective": "Dominar a sintaxe e fluxo de chamar um método de outro via 'self'.",
                                  "commonMistakes": [
                                    "Chamar como metodo() sem 'self.'",
                                    "Passar argumentos extras desnecessários",
                                    "Erro de recursão infinita se chamar a si mesmo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir chain de chamadas de métodos via 'self'",
                                  "subSteps": [
                                    "Adicione um terceiro método e faça o segundo chamá-lo via self.terceiro_metodo().",
                                    "Crie uma sequência: método1 -> método2 -> método3, cada um modificando um atributo.",
                                    "Implemente validações condicionais nos métodos para chain condicional.",
                                    "Instancie a classe e chame método1 para testar a chain completa.",
                                    "Registre saídas com logs ou prints para visualizar o fluxo."
                                  ],
                                  "verification": "Execução de método1 aciona método2 e método3 em sequência, com atributos atualizados corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Python interpreter"
                                  ],
                                  "tips": "Mantenha chains curtas inicialmente para facilitar debug; expanda gradualmente.",
                                  "learningObjective": "Aplicar chamadas encadeadas via 'self' para modularizar lógica complexa.",
                                  "commonMistakes": [
                                    "Quebrar a chain com return prematuro",
                                    "Não propagar valores entre métodos",
                                    "Indentação incorreta em chains aninhadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, debugar e refatorar a chain de métodos",
                                  "subSteps": [
                                    "Escreva testes unitários usando unittest para cada método individual e a chain.",
                                    "Introduza erros propositalis (ex: esquecer self) e corrija-os.",
                                    "Refatore para adicionar docstrings e type hints em todos os métodos.",
                                    "Execute cenários edge cases, como atributos vazios.",
                                    "Otimize a chain removendo redundâncias."
                                  ],
                                  "verification": "Todos os testes passam e a chain funciona em múltiplas instâncias.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Biblioteca unittest (import unittest)",
                                    "Arquivo de testes separado"
                                  ],
                                  "tips": "Use assert para verificações em testes; rode com python -m unittest.",
                                  "learningObjective": "Garantir robustez e manutenibilidade em designs OOP com self chains.",
                                  "commonMistakes": [
                                    "Testar apenas happy path",
                                    "Ignorar exceções em chains",
                                    "Sobrecarregar um método com muita lógica"
                                  ]
                                }
                              ],
                              "practicalExample": "Classe Carro:\nclass Carro:\n    def __init__(self):\n        self.velocidade = 0\n    \n    def acelerar(self):\n        self.atualizar_velocidade(10)\n        print(f'Nova velocidade: {self.velocidade}')\n    \n    def atualizar_velocidade(self, incremento):\n        self.verificar_combustivel()\n        self.velocidade += incremento\n    \n    def verificar_combustivel(self):\n        print('Combustível OK')\n\ncarro = Carro()\ncarro.acelerar()  # Output: Combustível OK, Nova velocidade: 10",
                              "finalVerifications": [
                                "Código executa sem erros de sintaxe ou NameError ao chamar self.metodo().",
                                "Chain de chamadas propaga mudanças de estado corretamente entre métodos.",
                                "Múltiplas instâncias mantêm estados isolados apesar de chamadas via self.",
                                "Prints ou logs confirmam ordem exata de execução da chain.",
                                "Testes unitários cobrem 100% das chamadas via self.",
                                "Refatoração não quebra funcionalidade existente."
                              ],
                              "assessmentCriteria": [
                                "Correta sintaxe em todas as chamadas self.nome_metodo() (100%).",
                                "Fluxo lógico da chain sem loops infinitos ou quebras (90-100%).",
                                "Modularidade: cada método tem responsabilidade única (80-90%).",
                                "Tratamento de erros e validações em chains (70-80%).",
                                "Documentação e testes completos (60-70%).",
                                "Eficiência e legibilidade do código (bônus)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Propagação de cálculos sequenciais em modelos numéricos.",
                                "Design de Software: Princípios de composição e reutilização de componentes.",
                                "Lógica Computacional: Fluxogramas e chamadas de funções encadeadas.",
                                "Física: Simulações de sistemas com estados dependentes (ex: movimento).",
                                "Inglês Técnico: Leitura e escrita de docstrings em OOP."
                              ],
                              "realWorldApplication": "Em frameworks como Django, modelos chamam métodos via self para validações encadeadas (ex: save() chama clean(), que chama validate_unique()); em jogos com Pygame, entidades atualizam posição chamando self.move() que chama self.check_collision()."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.3",
                        "name": "Declaração e Implementação de Métodos",
                        "description": "Processo completo de definir a assinatura com 'self' e parâmetros adicionais, implementar o corpo lógico do método e integrá-lo à classe para uso em instâncias.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.3.1",
                            "name": "Implementar método simples com 'self'",
                            "description": "Criar um método de instância que retorne ou modifique um atributo via 'self', testando-o ao instanciar um objeto e chamá-lo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a classe base com atributos de instância",
                                  "subSteps": [
                                    "Abra um editor de código Python e crie um novo arquivo.",
                                    "Declare uma classe simples, por exemplo: class Pessoa:",
                                    "Defina o método __init__(self, nome):",
                                    "Dentro de __init__, atribua self.nome = nome",
                                    "Adicione um print('Pessoa criada') para confirmação inicial."
                                  ],
                                  "verification": "Execute o script com python arquivo.py; deve imprimir 'Pessoa criada' sem erros ao definir a classe.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, PyCharm)",
                                    "Python 3.x instalado"
                                  ],
                                  "tips": "Use nomes descritivos para classes e atributos para facilitar a leitura.",
                                  "learningObjective": "Entender como criar uma classe com construtor que inicializa atributos via self.",
                                  "commonMistakes": [
                                    "Esquecer os dois underscores em __init__",
                                    "Não usar self ao atribuir atributos",
                                    "Indentação incorreta no método"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar método de instância simples com 'self'",
                                  "subSteps": [
                                    "Dentro da classe Pessoa, adicione def apresentar(self):",
                                    "No corpo do método, use self.nome para retornar uma string, ex: return f'Meu nome é {self.nome}'",
                                    "Salve o arquivo e teste a sintaxe executando o script.",
                                    "Adicione uma linha para modificar: self.idade = 25 (se não existir) e return self.idade no método.",
                                    "Ajuste __init__ para incluir idade se necessário: def __init__(self, nome, idade)."
                                  ],
                                  "verification": "O código roda sem SyntaxError e o método é reconhecido (use help(Pessoa) no interpretador).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Mesmo editor e Python",
                                    "Console Python interativo para testes"
                                  ],
                                  "tips": "Sempre inclua 'self' como primeiro parâmetro em métodos de instância.",
                                  "learningObjective": "Dominar a declaração de métodos que acessam ou modificam atributos via self.",
                                  "commonMistakes": [
                                    "Omitir 'self' na definição do método",
                                    "Esquecer self ao acessar atributos dentro do método",
                                    "Confundir self com parâmetro local"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Instanciar objeto e chamar o método",
                                  "subSteps": [
                                    "Fora da classe, crie uma instância: pessoa = Pessoa('João', 30)",
                                    "Chame o método: print(pessoa.apresentar())",
                                    "Teste modificação: print(pessoa.apresentar()) novamente se modificar idade.",
                                    "Adicione print(pessoa.nome) para verificar acesso direto.",
                                    "Execute o script completo e observe saídas."
                                  ],
                                  "verification": "A saída mostra 'Meu nome é João' e idade correta; atributo acessível via instância.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor e Python console"
                                  ],
                                  "tips": "Chame métodos em instâncias específicas, não na classe.",
                                  "learningObjective": "Aplicar instanciação e invocação de métodos de instância corretamente.",
                                  "commonMistakes": [
                                    "Chamar método na classe em vez da instância (Pessoa.apresentar())",
                                    "Passar self explicitamente",
                                    "Erro de parênteses na chamada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e debugar o método com cenários variados",
                                  "subSteps": [
                                    "Crie múltiplas instâncias: p2 = Pessoa('Maria', 25)",
                                    "Chame apresentar() em ambas e compare saídas.",
                                    "Modifique um atributo via método e verifique: def envelhecer(self): self.idade += 1; return self.idade",
                                    "Teste chamadas sucessivas: print(pessoa.envelhecer()) duas vezes.",
                                    "Use assert para automação: assert pessoa.nome == 'João'"
                                  ],
                                  "verification": "Todas as instâncias comportam-se independentemente; modificações persistem na instância.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python com módulo unittest opcional"
                                  ],
                                  "tips": "Use prints ou debugger para rastrear valores de self.",
                                  "learningObjective": "Validar isolamento de instâncias e persistência de estado via self.",
                                  "commonMistakes": [
                                    "Modificações afetarem todas instâncias (variáveis globais)",
                                    "Não atualizar self corretamente",
                                    "Erros em asserts por valores inesperados"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie class Carro: def __init__(self, cor): self.cor = cor\ndef pintar(self, nova_cor): self.cor = nova_cor; return f'Carro agora é {self.cor}'\ncarro = Carro('azul')\nprint(carro.pintar('vermelho'))  # Saída: 'Carro agora é vermelho'\nprint(carro.cor)  # 'vermelho'",
                              "finalVerifications": [
                                "Código executa sem erros de sintaxe ou runtime.",
                                "Método acessa e/ou modifica atributo via self corretamente.",
                                "Instâncias mantêm estados independentes.",
                                "Chamada de método em instância retorna valor esperado.",
                                "Atributos persistem após chamadas de métodos.",
                                "Múltiplas instâncias funcionam isoladamente."
                              ],
                              "assessmentCriteria": [
                                "Clareza e correção na definição da classe e __init__.",
                                "Uso preciso de 'self' em todos os lugares necessários.",
                                "Funcionalidade completa: instanciação, chamada e verificação.",
                                "Código limpo, indentado e comentado minimamente.",
                                "Testes cobrem retorno e modificação de atributos.",
                                "Ausência de variáveis globais ou side-effects indesejados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica sequencial e funções como em algoritmos.",
                                "Língua Portuguesa: Nomenclatura precisa e legível no código.",
                                "Física: Modelagem de entidades reais (objetos) com propriedades mutáveis.",
                                "Artes: Design de interfaces intuitivas via métodos.",
                                "Ética: Encapsulamento promove código responsável e modular."
                              ],
                              "realWorldApplication": "Em apps como jogos (personagens com métodos move() que alteram posição via self.x), e-commerces (carrinho com add_item() modificando self.itens) ou simulações (robôs com update_sensor() acessando self.dados), permitindo que objetos gerenciem seu estado autonomamente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.2.2"
                            ]
                          },
                          {
                            "id": "10.1.1.3.3.2",
                            "name": "Implementar método com parâmetros adicionais",
                            "description": "Definir e implementar um método de instância que receba parâmetros além de 'self', utilizando-os junto com atributos de instância para realizar operações como cálculos ou atualizações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar os requisitos do método",
                                  "subSteps": [
                                    "Identificar os parâmetros adicionais necessários com base no contexto da classe.",
                                    "Determinar como os parâmetros interagem com os atributos de instância (self).",
                                    "Planejar a lógica da operação, como cálculos, atualizações ou validações.",
                                    "Definir o tipo de retorno do método (None ou valor específico).",
                                    "Esboçar o esqueleto do método em comentários ou papel."
                                  ],
                                  "verification": "Existe um esboço escrito ou comentado descrevendo parâmetros, lógica e interações com self.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE",
                                    "Documentação ou especificação da classe"
                                  ],
                                  "tips": "Use exemplos reais da classe para visualizar a interação entre parâmetros e atributos.",
                                  "learningObjective": "Compreender a interação entre parâmetros adicionais e atributos de instância.",
                                  "commonMistakes": [
                                    "Ignorar tipos de dados dos parâmetros.",
                                    "Não considerar casos de uso edge ou validações."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar a assinatura do método",
                                  "subSteps": [
                                    "Escrever 'def nome_metodo(self, param1: tipo1, param2: tipo2):'.",
                                    "Garantir que 'self' seja o primeiro parâmetro.",
                                    "Adicionar type hints opcionais para parâmetros e retorno.",
                                    "Finalizar com dois pontos e respeitar a indentação da classe.",
                                    "Verificar sintaxe básica no editor."
                                  ],
                                  "verification": "A assinatura é reconhecida pelo IDE sem erros de sintaxe e inclui todos os parâmetros.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "IDE com suporte a Python (ex: VS Code, PyCharm)"
                                  ],
                                  "tips": "Sempre use type hints para melhorar a legibilidade: def metodo(self, valor: float) -> None:.",
                                  "learningObjective": "Definir corretamente a assinatura de um método de instância com parâmetros adicionais.",
                                  "commonMistakes": [
                                    "Esquecer 'self' como primeiro parâmetro.",
                                    "Erro de indentação dentro da classe."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o corpo do método",
                                  "subSteps": [
                                    "Acessar atributos de instância com 'self.atributo'.",
                                    "Incorporar parâmetros na lógica (ex: self.saldo += valor).",
                                    "Realizar operações como cálculos, atualizações ou condicionais.",
                                    "Adicionar validações básicas (ex: if valor > 0).",
                                    "Retornar valor se necessário ou imprimir confirmação."
                                  ],
                                  "verification": "Executar o método em uma instância altera os atributos corretamente sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código da classe",
                                    "Console ou debugger da IDE"
                                  ],
                                  "tips": "Use print() ou debugger para inspecionar valores de self e parâmetros durante o desenvolvimento.",
                                  "learningObjective": "Manipular atributos de instância utilizando parâmetros adicionais de forma correta.",
                                  "commonMistakes": [
                                    "Modificar apenas parâmetros locais sem atualizar self.",
                                    "Não tratar tipos incompatíveis."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar o método",
                                  "subSteps": [
                                    "Criar uma instância da classe.",
                                    "Chamar o método com diferentes valores de parâmetros.",
                                    "Verificar alterações em atributos com print ou asserts.",
                                    "Testar casos edge (valores inválidos, zero, negativos).",
                                    "Refatorar código se testes falharem."
                                  ],
                                  "verification": "Todos os testes passam e produzem resultados esperados em múltiplos cenários.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Script de teste simples",
                                    "Biblioteca unittest (opcional)"
                                  ],
                                  "tips": "Escreva testes unitários: assert instancia.metodo(param) altera self corretamente.",
                                  "learningObjective": "Validar a funcionalidade do método através de testes práticos.",
                                  "commonMistakes": [
                                    "Chamar método sem instância (esquecer obj.metodo()).",
                                    "Não testar variações de parâmetros."
                                  ]
                                }
                              ],
                              "practicalExample": "Na classe ContaBancaria (com atributo self.saldo = 0), implemente def depositar(self, valor: float) -> None: que valida valor > 0, adiciona ao self.saldo e imprime 'Depósito realizado'. Teste com conta = ContaBancaria(); conta.depositar(100.0); print(conta.saldo) == 100.0.",
                              "finalVerifications": [
                                "Método possui assinatura com 'self' e parâmetros adicionais corretos.",
                                "Parâmetros são usados em conjunto com atributos de self.",
                                "Lógica realiza operações (cálculo/atualização) sem erros.",
                                "Método é chamado corretamente em instâncias.",
                                "Testes com valores variados passam.",
                                "Código é indentado e legível."
                              ],
                              "assessmentCriteria": [
                                "Assinatura sintaticamente correta com self e parâmetros (30%).",
                                "Uso correto de self e integração de parâmetros (30%).",
                                "Lógica funcional e sem bugs (20%).",
                                "Validações e tratamento de erros básicos (10%).",
                                "Testes abrangentes executados (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aplicação de operações aritméticas e validações numéricas.",
                                "Lógica e Raciocínio: Sequenciamento de instruções e condicionais.",
                                "Inglês Técnico: Interpretação de documentação oficial do Python."
                              ],
                              "realWorldApplication": "Desenvolvimento de sistemas bancários (depósitos/saques), jogos (movimentar personagem com velocidade/direção), e-commerce (adicionar itens ao carrinho com quantidade/preço) e simulações científicas (atualizar modelos com parâmetros variáveis)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.2.1",
                              "10.1.1.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.3.3",
                            "name": "Testar métodos em múltiplas instâncias",
                            "description": "Criar várias instâncias de uma classe, chamar o mesmo método de instância em cada uma e verificar como o comportamento varia conforme o estado individual de cada objeto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir uma classe com método de instância que depende do estado do objeto",
                                  "subSteps": [
                                    "Escolha um conceito simples para a classe, como 'Carro' com atributos como 'combustivel' e 'velocidade'.",
                                    "Defina o construtor (__init__) para inicializar atributos com valores diferentes por instância.",
                                    "Implemente um método de instância, como 'dirigir()', que modifica ou usa o estado atual (ex: reduz combustível baseado na velocidade).",
                                    "Teste o método em uma instância única para validar o comportamento básico.",
                                    "Adicione prints ou returns para observar o estado antes e depois da chamada."
                                  ],
                                  "verification": "O método altera o estado da instância corretamente quando chamado em um objeto único, sem erros de sintaxe.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code, PyCharm)",
                                    "Documentação de Python OOP"
                                  ],
                                  "tips": "Sempre use 'self' para acessar atributos de instância; evite variáveis globais.",
                                  "learningObjective": "Compreender como métodos de instância acessam e modificam o estado único de um objeto.",
                                  "commonMistakes": [
                                    "Usar variáveis estáticas em vez de de instância",
                                    "Esquecer 'self' nos parâmetros do método"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar múltiplas instâncias da classe com estados iniciais diferentes",
                                  "subSteps": [
                                    "Instancie pelo menos 3 objetos da classe usando o construtor com parâmetros variados (ex: carro1 com 100L combustível, carro2 com 50L).",
                                    "Atribua cada instância a variáveis distintas (ex: carro1, carro2, carro3).",
                                    "Imprima ou acesse os atributos iniciais de cada instância para confirmar diferenças no estado.",
                                    "Verifique que os objetos são independentes alterando um atributo em um sem afetar os outros.",
                                    "Registre os estados iniciais em uma lista ou dicionário para comparação futura."
                                  ],
                                  "verification": "Impressão dos atributos mostra estados únicos e independentes para cada instância.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Console ou notebook Jupyter para testes interativos"
                                  ],
                                  "tips": "Use loops para criar instâncias se quiser escalar, mas comece manualmente para clareza.",
                                  "learningObjective": "Dominar a criação de objetos independentes, cada um com seu próprio estado encapsulado.",
                                  "commonMistakes": [
                                    "Reatribuir a mesma variável, sobrescrevendo instâncias",
                                    "Inicializar todos com os mesmos valores por engano"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Chamar o mesmo método de instância em cada objeto",
                                  "subSteps": [
                                    "Chame o método 'dirigir()' em cada instância sequencialmente.",
                                    "Passe parâmetros diferentes se aplicável (ex: distância para dirigir).",
                                    "Capture saídas ou retornos do método para cada chamada.",
                                    "Imprima o estado de cada objeto imediatamente após a chamada do método.",
                                    "Repita chamadas múltiplas em alguns objetos para observar acumulação de mudanças."
                                  ],
                                  "verification": "Cada chamada modifica apenas o estado da instância correspondente, com saídas variadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Terminal para execução stepwise"
                                  ],
                                  "tips": "Use um loop for com lista de instâncias para automatizar chamadas e comparações.",
                                  "learningObjective": "Observar como o mesmo código de método produz comportamentos distintos baseado no estado individual.",
                                  "commonMistakes": [
                                    "Chamar método estático por engano",
                                    "Ignorar saídas de prints durante as chamadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e verificar as variações de comportamento",
                                  "subSteps": [
                                    "Compare os estados finais de todas as instâncias lado a lado (ex: tabela ou prints alinhados).",
                                    "Identifique padrões: como estados iniciais afetam resultados do método.",
                                    "Teste cenários edge, como instância com combustível zero.",
                                    "Documente observações em comentários ou relatório simples.",
                                    "Refatore o código para incluir asserts ou testes unitários para validação automática."
                                  ],
                                  "verification": "Relatório ou asserts confirmam que comportamentos variam conforme estados individuais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Biblioteca unittest ou pytest para asserts opcionais"
                                  ],
                                  "tips": "Crie uma função auxiliar para imprimir estados formatados e facilitar comparações.",
                                  "learningObjective": "Analisar empiricamente o encapsulamento e independência de instâncias em OOP.",
                                  "commonMistakes": [
                                    "Assumir comportamento uniforme sem verificação",
                                    "Não testar casos limites como estados inválidos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Refinar e generalizar o teste para reutilização",
                                  "subSteps": [
                                    "Abstraia o teste em uma função que recebe lista de instâncias e método a chamar.",
                                    "Adicione logs detalhados para rastrear mudanças em cada chamada.",
                                    "Teste com uma classe diferente para validar generalidade.",
                                    "Compartilhe o código em um repositório ou notebook.",
                                    "Planeje extensões, como herança ou polimorfismo."
                                  ],
                                  "verification": "Função de teste executa corretamente em novas classes/instâncias sem modificações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "GitHub para versionamento"
                                  ],
                                  "tips": "Priorize legibilidade: use docstrings em métodos e funções de teste.",
                                  "learningObjective": "Transformar testes isolados em padrões reutilizáveis para desenvolvimento OOP robusto.",
                                  "commonMistakes": [
                                    "Hardcodear valores específicos, perdendo generalidade",
                                    "Pular documentação de resultados"
                                  ]
                                }
                              ],
                              "practicalExample": "Classe Carro: def __init__(self, combustivel): self.combustivel = combustivel. Método dirigir(distancia): self.combustivel -= distancia * 0.1; print(f'Combustível restante: {self.combustivel}L'). Crie carro1=Carro(100), carro2=Carro(50), carro3=Carro(20). Chame carro1.dirigir(50), carro2.dirigir(30), carro3.dirigir(10). Observe: carro1~95L, carro2~47L, carro3~19L – variações baseadas em estado inicial.",
                              "finalVerifications": [
                                "Pelo menos 3 instâncias criadas com estados distintos confirmados por prints.",
                                "Método chamado em todas as instâncias com saídas/efeitos diferenciados.",
                                "Estados pós-chamada independentes (alteração em uma não afeta outras).",
                                "Análise escrita comparando comportamentos observados.",
                                "Asserts ou testes unitários passam validando independência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação do método dependente de estado (100% funcional).",
                                "Número e diversidade de instâncias criadas (mín. 3 com variações claras).",
                                "Correta observação e documentação de diferenças comportamentais.",
                                "Ausência de acoplamento entre instâncias (independência total).",
                                "Clareza e organização do código com comentários explicativos.",
                                "Eficiência temporal: conclusão dentro de 2h totais.",
                                "Criatividade em cenários de teste (edge cases incluídos)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de funções dependentes de variáveis independentes (estado inicial).",
                                "Ciência: Simulação de sistemas físicos com estados variáveis (ex: física de veículos).",
                                "Lógica e Raciocínio: Análise comparativa e identificação de padrões em experimentos.",
                                "Design de Software: Princípios de modularidade e reutilização de código.",
                                "Estatística: Coleta e interpretação de dados de múltiplas 'execuções' experimentais."
                              ],
                              "realWorldApplication": "Em desenvolvimento de jogos (ex: personagens com stats únicas chamando 'atacar()' com danos variados); simulações empresariais (contas bancárias com saldos diferentes processando transações); apps de fitness (usuários com perfis únicos executando 'treinar()' com progressos personalizados); sistemas IoT (sensores com calibrações distintas reportando dados via métodos comuns)."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.4",
                    "name": "Invocação de Métodos em Instâncias",
                    "description": "Chamada de métodos em objetos instanciados e passagem implícita da referência da instância.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.4.1",
                        "name": "Método de Instância",
                        "description": "Um método de instância é uma função associada a uma classe que opera sobre os dados específicos de uma instância (objeto) dessa classe, recebendo implicitamente uma referência para si mesma como primeiro parâmetro.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.1.1",
                            "name": "Identificar métodos de instância em código fonte",
                            "description": "Reconhecer a declaração de métodos de instância em linguagens como Python (com parâmetro self) ou C++ (com this implícito), diferenciando-os de métodos estáticos ou de classe.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entenda os Conceitos Fundamentais de Métodos de Instância",
                                  "subSteps": [
                                    "Leia a definição: Métodos de instância são funções definidas dentro de uma classe que operam em uma instância específica do objeto, acessando seus atributos.",
                                    "Compare com métodos estáticos: Estes não recebem referência à instância (sem self/this) e são chamados na classe.",
                                    "Compare com métodos de classe: Recebem a classe como primeiro argumento (cls em Python).",
                                    "Estude o papel de 'self' em Python e 'this' implícito em C++ como referências à instância atual.",
                                    "Anote diferenças chave em um quadro comparativo."
                                  ],
                                  "verification": "Crie um quadro comparativo com pelo menos 3 diferenças entre métodos de instância, estáticos e de classe, e explique verbalmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial Python (docs.python.org), Documentação C++ (cppreference.com)",
                                    "Bloco de notas ou editor de texto"
                                  ],
                                  "tips": "Sempre priorize a assinatura da função: presença de 'self' ou acesso a membros de instância indica método de instância.",
                                  "learningObjective": "Diferenciar conceitualmente métodos de instância de outros tipos de métodos em OOP.",
                                  "commonMistakes": [
                                    "Confundir métodos de instância com funções globais fora da classe",
                                    "Ignorar que métodos estáticos podem acessar métodos de instância indiretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identifique Métodos de Instância em Código Python",
                                  "subSteps": [
                                    "Abra um editor de código e cole um snippet de classe Python simples.",
                                    "Localize definições de métodos dentro da classe (indentados após 'def').",
                                    "Verifique o primeiro parâmetro: deve ser 'self' seguido de outros argumentos opcionais.",
                                    "Confirme acesso a atributos de instância (ex: self.attribute).",
                                    "Marque todos os métodos de instância com comentários."
                                  ],
                                  "verification": "Analise um código Python fornecido e liste corretamente todos os métodos de instância, justificando cada um.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código como VS Code ou PyCharm",
                                    "Snippets de exemplo de classes Python"
                                  ],
                                  "tips": "Use Ctrl+F para buscar 'def ' dentro da classe e cheque imediatamente o parâmetro self.",
                                  "learningObjective": "Reconhecer sintaxe específica de métodos de instância em Python pelo parâmetro 'self'.",
                                  "commonMistakes": [
                                    "Marcar construtores __init__ como não-métodos de instância (eles são!)",
                                    "Confundir 'self' com variáveis locais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identifique Métodos de Instância em Código C++",
                                  "subSteps": [
                                    "Abra um editor e cole um snippet de classe C++.",
                                    "Localize declarações de métodos dentro da classe (públicos/privados).",
                                    "Note ausência explícita de 'this': é implícito no primeiro parâmetro.",
                                    "Verifique acesso a membros de instância (ex: this->member ou member direto).",
                                    "Distinga de métodos estáticos declarados com 'static'."
                                  ],
                                  "verification": "Em um código C++ dado, circule métodos de instância e explique por que não são estáticos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código com suporte C++ como CLion ou VS Code com extensão C++",
                                    "Snippets de exemplo de classes C++"
                                  ],
                                  "tips": "Procure por 'static' na declaração; se ausente e acessa dados de instância, é método de instância.",
                                  "learningObjective": "Reconhecer métodos de instância em C++ pela ausência de 'static' e uso de membros de instância.",
                                  "commonMistakes": [
                                    "Assumir que todos os métodos sem 'this' explícito são estáticos",
                                    "Ignorar métodos inline em headers"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Pratique Diferenciação e Análise de Códigos Mistos",
                                  "subSteps": [
                                    "Pegue códigos mistos Python/C++ com métodos variados.",
                                    "Classifique cada método: instância, estático ou classe.",
                                    "Explique diferenças em acessos (self vs cls, static).",
                                    "Debugue um erro comum: chamada de método de instância sem instância.",
                                    "Crie seu próprio exemplo simples e analise."
                                  ],
                                  "verification": "Analise 5 trechos de código mistos e classifique 100% corretamente com justificativas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exercícios online como LeetCode ou HackerRank OOP sections",
                                    "Seu editor de código"
                                  ],
                                  "tips": "Sempre pergunte: 'Esse método precisa de uma instância para funcionar?' Se sim, é de instância.",
                                  "learningObjective": "Aplicar identificação em cenários reais mistos, diferenciando com precisão.",
                                  "commonMistakes": [
                                    "Chamar métodos estáticos como instância (funciona mas incorreto conceitualmente)",
                                    "Confundir sobrecarga de métodos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: class Carro: def __init__(self): self.velocidade = 0; def acelerar(self, incremento): self.velocidade += incremento;  Aqui, 'acelerar' é método de instância por 'self'. Em C++: class Car { public: void acelerar(int inc) { velocidade += inc; } static int totalCarros; };  'acelerar' é de instância (sem static, acessa velocidade).",
                              "finalVerifications": [
                                "Identifica corretamente 'self' em 10 métodos Python consecutivos.",
                                "Distingue métodos estáticos em C++ sem hesitação.",
                                "Explica o papel de 'this' implícito em C++.",
                                "Classifica métodos em código misto com 95% acurácia.",
                                "Cria um exemplo próprio de método de instância.",
                                "Debuga erros de invocação de métodos de instância."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação (sem falsos positivos/negativos).",
                                "Justificativa clara baseada em sintaxe (self/this/static).",
                                "Velocidade de análise em códigos reais (<2 min por trecho).",
                                "Capacidade de explicar diferenças para pares.",
                                "Criação de exemplos corretos e variados.",
                                "Detecção de erros comuns em códigos fornecidos."
                              ],
                              "crossCurricularConnections": [
                                "Lógica Matemática: Análise sintática similar a parsing de expressões algébricas.",
                                "Língua Portuguesa/Inglês: Leitura crítica de 'texto código' como prosa técnica.",
                                "Física: Modelagem de objetos (instâncias) com propriedades mutáveis como corpos em movimento.",
                                "Análise de Dados: Identificação de funções em scripts de dados orientados a objetos."
                              ],
                              "realWorldApplication": "No desenvolvimento de software, identificar métodos de instância é essencial para debugging, refatoração e manutenção de código OOP em projetos como apps web (Django/Flask em Python) ou jogos (Unreal Engine em C++), evitando erros de estado de instância e otimizando performance."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.2",
                            "name": "Explicar o propósito de métodos de instância",
                            "description": "Descrever como métodos de instância encapsulam comportamentos específicos de objetos, promovendo abstração e reutilização de código orientado a objetos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos de classes e objetos em OOP",
                                  "subSteps": [
                                    "Estude a definição de uma classe como blueprint para objetos.",
                                    "Crie uma classe simples em Python, como 'Carro', com atributos básicos (cor, modelo).",
                                    "Instancie pelo menos dois objetos da classe e acesse seus atributos.",
                                    "Observe como cada instância mantém seu próprio estado.",
                                    "Registre diferenças entre classe e instâncias em um diagrama."
                                  ],
                                  "verification": "Crie e instancie uma classe com atributos únicos por objeto, demonstrando independência de estado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código (VS Code), Python instalado, caderno para diagramas.",
                                  "tips": "Use print() para visualizar estados dos objetos e confirme independência.",
                                  "learningObjective": "Compreender classes como moldes e objetos como entidades independentes.",
                                  "commonMistakes": "Confundir atributos da classe (compartilhados) com atributos de instância (próprios)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e definir métodos de instância",
                                  "subSteps": [
                                    "Defina método de instância como função definida dentro de uma classe que opera em uma instância específica.",
                                    "Adicione um método simples 'acelerar()' à classe Carro que modifica um atributo de velocidade.",
                                    "Chame o método em diferentes instâncias e observe efeitos isolados.",
                                    "Compare com funções globais fora da classe para destacar associação com instância.",
                                    "Teste invocação com 'self' em Python para acessar atributos da instância."
                                  ],
                                  "verification": "Implemente e execute um método de instância que altere apenas o estado da instância chamada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código, Python, console para testes.",
                                  "tips": "Sempre use 'self' como primeiro parâmetro em Python para referenciar a instância.",
                                  "learningObjective": "Reconhecer métodos de instância como comportamentos ligados a objetos específicos.",
                                  "commonMistakes": "Esquecer 'self' ou chamar método sem instância, causando erros de sintaxe."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar encapsulamento e abstração promovidos por métodos de instância",
                                  "subSteps": [
                                    "Descreva encapsulamento como agrupar dados e comportamentos em um objeto.",
                                    "Modifique a classe Carro para incluir validações no método 'acelerar()' (ex: limite de velocidade).",
                                    "Discuta abstração: usuário interage via método sem conhecer implementação interna.",
                                    "Escreva um parágrafo explicando como isso esconde complexidade.",
                                    "Refatore um código procedural para OOP usando métodos de instância."
                                  ],
                                  "verification": "Refatore um script simples procedural para usar métodos de instância com validações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código, exemplos de código OOP online (documentação Python).",
                                  "tips": "Pense em métodos como 'caixas pretas' que recebem inputs e produzem outputs sem expor internals.",
                                  "learningObjective": "Entender como métodos encapsulam lógica, promovendo abstração.",
                                  "commonMistakes": "Expor lógica interna diretamente via atributos, violando encapsulamento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar reutilização de código e sintetizar propósito",
                                  "subSteps": [
                                    "Crie múltiplas instâncias de Carro e reutilize o método 'acelerar()' sem duplicar código.",
                                    "Compare com código duplicado sem OOP para quantificar reutilização.",
                                    "Escreva uma explicação completa do propósito: encapsular comportamentos para abstração e reutilização.",
                                    "Discuta escalabilidade em projetos maiores.",
                                    "Registre benefícios em uma tabela comparativa."
                                  ],
                                  "verification": "Demonstre reutilização criando 3 instâncias e chamando o mesmo método com resultados distintos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código, planilha ou caderno para tabela.",
                                  "tips": "Meça linhas de código salvas para visualizar ganhos de reutilização.",
                                  "learningObjective": "Sintetizar o propósito integral de métodos de instância em OOP.",
                                  "commonMistakes": "Subestimar reutilização, confundindo com herança ou polimorfismo."
                                }
                              ],
                              "practicalExample": "Na classe 'ContaBancaria', o método de instância 'depositar(valor)' encapsula a lógica de atualizar saldo + valor, valida se valor > 0, e registra a transação. Cada conta (instância) usa o mesmo método, mas mantém seu saldo independente, promovendo reutilização sem duplicação de código.",
                              "finalVerifications": [
                                "Explicar verbalmente o que é um método de instância e sua sintaxe básica.",
                                "Implementar um método de instância que modifique atributos de uma instância específica.",
                                "Identificar benefícios de encapsulamento em um código dado.",
                                "Refatorar código procedural para usar métodos de instância.",
                                "Comparar métodos de instância vs estáticos em um exemplo.",
                                "Demonstrar abstração escondendo detalhes de implementação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de método de instância (100% corretude).",
                                "Capacidade de implementar código funcional com métodos de instância (sem erros).",
                                "Explicação clara de encapsulamento, abstração e reutilização (com exemplos).",
                                "Identificação correta de erros comuns em códigos OOP.",
                                "Criatividade em refatoração e extensão de exemplos.",
                                "Compreensão de independência de estado entre instâncias."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstração em funções e modelagem de objetos geométricos.",
                                "Física: Simulação de comportamentos de partículas ou veículos via métodos.",
                                "Biologia: Modelagem de organismos com métodos para funções vitais (ex: reproduzir()).",
                                "Design Gráfico: Encapsulamento de animações em objetos gráficos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps como Uber, métodos de instância em classes 'Veiculo' gerenciam aceleração, freio e rotas específicas por carro, permitindo reutilização de código para milhões de veículos reais modelados, com abstração para motoristas sem expor algoritmos de navegação."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.3",
                            "name": "Diferenciar métodos de instância de métodos estáticos",
                            "description": "Comparar métodos de instância, que requerem uma instância para serem chamados, com métodos estáticos, acessíveis diretamente pela classe sem necessidade de objeto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Métodos de Instância",
                                  "subSteps": [
                                    "Defina método de instância como uma função associada a uma instância específica de uma classe.",
                                    "Identifique que eles acessam e modificam atributos da instância usando 'self' (Python) ou 'this' (Java).",
                                    "Analise exemplos simples de invocação: obj.metodo_instancia().",
                                    "Discuta o uso do 'self' como primeiro parâmetro implícito.",
                                    "Crie uma classe de teste com um atributo de instância e um método que o utiliza."
                                  ],
                                  "verification": "Escreva e execute um código com uma classe que tenha um método de instância acessando um atributo da instância.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código (VS Code ou PyCharm), documentação de Python/Java sobre classes.",
                                  "tips": "Sempre inclua 'self' como primeiro parâmetro em Python para métodos de instância.",
                                  "learningObjective": "Reconhecer a dependência de métodos de instância em uma instância específica.",
                                  "commonMistakes": "Esquecer de passar 'self' ou chamar sem instância, gerando erro de sintaxe."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender Métodos Estáticos",
                                  "subSteps": [
                                    "Defina método estático como uma função pertencente à classe, não requerendo instância.",
                                    "Identifique o decorador '@staticmethod' em Python ou 'static' em Java.",
                                    "Analise exemplos de invocação: Classe.metodo_estatico().",
                                    "Discuta que eles não acessam atributos de instância ou 'self'.",
                                    "Crie uma classe de teste com um método estático que realiza uma operação independente."
                                  ],
                                  "verification": "Escreva e execute um código chamando um método estático diretamente pela classe sem criar objeto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código, exemplos de código de bibliotecas como math em Python.",
                                  "tips": "Use métodos estáticos para funções utilitárias que não dependem de estado da instância.",
                                  "learningObjective": "Identificar a independência de métodos estáticos de instâncias.",
                                  "commonMistakes": "Tentar acessar 'self' dentro de um método estático, causando erro."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diferenças Chave",
                                  "subSteps": [
                                    "Liste diferenças: dependência de instância vs. acesso direto à classe.",
                                    "Compare acesso a atributos: instância pode, estático não.",
                                    "Discuta herança: métodos estáticos são herdados, mas chamados na subclasse.",
                                    "Analise performance: estáticos são ligeiramente mais rápidos por não acessarem instância.",
                                    "Crie uma tabela comparativa com exemplos de código lado a lado."
                                  ],
                                  "verification": "Preencha uma tabela comparativa e explique verbalmente ou por escrito as diferenças.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel ou ferramenta de diagramação (Draw.io), exemplos de código comparativos.",
                                  "tips": "Lembre-se: se precisa de estado da instância, use método de instância; caso contrário, estático.",
                                  "learningObjective": "Diferenciar precisamente quando e por que usar cada tipo.",
                                  "commonMistakes": "Confundir e usar método de instância como estático, perdendo modularidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar com Exemplos e Testes",
                                  "subSteps": [
                                    "Implemente uma classe com ambos os tipos de métodos.",
                                    "Teste chamadas corretas e incorretas para observar erros.",
                                    "Refatore um método de instância para estático onde apropriado.",
                                    "Analise código existente e identifique tipos de métodos.",
                                    "Crie testes unitários para verificar comportamentos."
                                  ],
                                  "verification": "Execute testes que chamem ambos métodos corretamente e corrijam erros intencionais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código com suporte a testes (pytest para Python), exemplos de código.",
                                  "tips": "Use print statements ou asserts para visualizar diferenças em execução.",
                                  "learningObjective": "Aplicar o conhecimento na identificação e uso prático dos métodos.",
                                  "commonMistakes": "Chamar método estático via instância (funciona, mas é confuso)."
                                }
                              ],
                              "practicalExample": "Em Python, crie a classe Calculadora:\nclass Calculadora:\n    def __init__(self, nome):\n        self.nome = nome\n    def somar_instancia(self, a, b):  # Método de instância\n        return f'{self.nome} soma: {a + b}'\n    @staticmethod\n    def somar_estatico(a, b):  # Método estático\n        return a + b\n\n# Uso:\ncalc = Calculadora('MinhaCalc')\nprint(calc.somar_instancia(2, 3))  # Requer instância\nprint(Calculadora.somar_estatico(2, 3))  # Direto na classe",
                              "finalVerifications": [
                                "Explicar verbalmente a diferença entre métodos de instância e estáticos com exemplos.",
                                "Identificar corretamente o tipo de método em um código fornecido.",
                                "Implementar uma classe com ambos os métodos sem erros.",
                                "Demonstrar chamadas corretas e explicar erros comuns.",
                                "Refatorar um método inadequado para o tipo correto.",
                                "Criar testes que validem o comportamento de cada tipo."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições e exemplos fornecidos (80% acerto).",
                                "Capacidade de codificar sem erros de sintaxe ou lógica.",
                                "Correta identificação de tipos em códigos mistos.",
                                "Explicação clara das diferenças e cenários de uso.",
                                "Criatividade em exemplos práticos e testes.",
                                "Uso adequado de verificações e correção de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Métodos estáticos semelhantes a funções puras independentes de variáveis de estado.",
                                "Design de Software: Padrões como Utility Classes para métodos estáticos.",
                                "Lógica Computacional: Entender encapsulamento e abstração em OOP.",
                                "Física/Engenharia: Modelagem de comportamentos dependentes de instância (ex: propriedades de objetos físicos)."
                              ],
                              "realWorldApplication": "Em bibliotecas como math.sqrt() (estático para cálculos independentes) vs. métodos em objetos como listas.append() (de instância para modificar estado específico), otimizando código em aplicações web, jogos e sistemas empresariais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.2",
                        "name": "Sintaxe de Invocação de Métodos",
                        "description": "A invocação de métodos em instâncias utiliza a notação ponto (objeto.método()), onde o interpretador ou compilador resolve a chamada dinamicamente com base no tipo da instância.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.2.1",
                            "name": "Escrever código para invocar métodos em instâncias",
                            "description": "Criar e executar código que instancie um objeto e chame seus métodos, como em Python: instancia.metodo(arg1, arg2), verificando o retorno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição da classe e identificar métodos disponíveis",
                                  "subSteps": [
                                    "Leia a documentação ou código fonte da classe para entender seus atributos e métodos.",
                                    "Identifique os métodos públicos (não privados, que começam com __ ou _).",
                                    "Anote a assinatura de cada método: parâmetros necessários, tipo de retorno e propósito.",
                                    "Verifique se o método requer argumentos específicos ou se é sem parâmetros.",
                                    "Confirme o contexto de uso do método dentro da classe."
                                  ],
                                  "verification": "Lista de métodos anotada com assinaturas corretas, sem erros de interpretação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Código fonte da classe, editor de texto ou IDE como VS Code, documentação Python oficial.",
                                  "tips": "Use o comando help(classe) no interpretador Python para inspecionar métodos rapidamente.",
                                  "learningObjective": "Compreender a estrutura de uma classe e seus métodos para uso correto.",
                                  "commonMistakes": "Confundir métodos de instância com métodos de classe (staticmethod); ignorar parâmetros obrigatórios."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar uma instância da classe",
                                  "subSteps": [
                                    "Escreva o código para importar a classe se necessário.",
                                    "Declare uma variável para a instância: instancia = Classe(args_init).",
                                    "Execute o código para confirmar que a instância é criada sem erros.",
                                    "Imprima a instância ou use type(instancia) para verificar o tipo.",
                                    "Inicialize atributos se o construtor (__init__) permitir."
                                  ],
                                  "verification": "Instância criada com sucesso e print(type(instancia)) mostra o tipo correto da classe.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Interpretador Python ou Jupyter Notebook, módulo com a classe definida.",
                                  "tips": "Sempre passe argumentos corretos para __init__ para evitar TypeError.",
                                  "learningObjective": "Dominar a instanciação de objetos a partir de classes.",
                                  "commonMistakes": "Esquecer parênteses na chamada do construtor; usar nome errado da classe."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Invocar o método na instância com argumentos corretos",
                                  "subSteps": [
                                    "Escreva a sintaxe: resultado = instancia.metodo(arg1, arg2).",
                                    "Passe argumentos do tipo e quantidade exatos esperados pelo método.",
                                    "Execute o código e capture qualquer exceção (ex: AttributeError).",
                                    "Use print para exibir o estado da instância antes e depois da chamada.",
                                    "Teste variações de argumentos se o método suportar sobrecarga implícita."
                                  ],
                                  "verification": "Método executado sem erros e atributos da instância alterados conforme esperado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "IDE com depurador (PyCharm ou VS Code), console Python para testes interativos.",
                                  "tips": "Use autocomplete da IDE para evitar erros de digitação no nome do método.",
                                  "learningObjective": "Aplicar sintaxe precisa para chamadas de métodos em objetos.",
                                  "commonMistakes": "Usar parênteses incorretos ou esquecer vírgulas em argumentos múltiplos; chamar método estático como de instância."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e utilizar o retorno do método",
                                  "subSteps": [
                                    "Atribua o retorno a uma variável: retorno = instancia.metodo().",
                                    "Imprima ou valide o retorno (ex: assert isinstance(retorno, tipo_esperado)).",
                                    "Teste cenários de erro, como argumentos inválidos, e trate com try-except.",
                                    "Integre o retorno em lógica maior, como condicionais ou loops.",
                                    "Documente o código com comentários explicando o retorno esperado."
                                  ],
                                  "verification": "Retorno capturado, validado e usado corretamente em um script funcional.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Unittest ou pytest para testes automatizados, script de teste pronto.",
                                  "tips": "Sempre verifique o tipo de retorno com isinstance() para robustez.",
                                  "learningObjective": "Gerenciar retornos de métodos para fluxos de programação compostos.",
                                  "commonMistakes": "Ignorar retornos de métodos que os produzem; não tratar exceções como ValueError."
                                }
                              ],
                              "practicalExample": "Considere uma classe Carro: class Carro: def __init__(self, marca): self.marca = marca; def acelerar(self, velocidade): self.velocidade_atual = velocidade; return f'{self.marca} acelerou para {velocidade} km/h'. Código: meu_carros = Carro('Fusca'); resultado = meu_carros.acelerar(60); print(resultado)  # Saída: Fusca acelerou para 60 km/h",
                              "finalVerifications": [
                                "Código executa sem erros de sintaxe ou runtime.",
                                "Instância criada e método invocado altera estado corretamente.",
                                "Retorno do método é capturado e exibido/validado.",
                                "Testes com argumentos variados passam sem exceções inesperadas.",
                                "Código comentado explica cada invocação de método.",
                                "Uso de try-except para cenários de erro."
                              ],
                              "assessmentCriteria": [
                                "Correção da sintaxe de instanciação e invocação (100% peso).",
                                "Manuseio preciso de argumentos e tipos (20%).",
                                "Verificação e uso do retorno (20%).",
                                "Tratamento de erros comuns (15%).",
                                "Clareza e documentação do código (15%).",
                                "Eficiência e boas práticas (10%).",
                                "Testes unitários incluídos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de funções e parâmetros como variáveis algébricas.",
                                "Lógica: Sequenciamento de passos como fluxogramas.",
                                "Física: Simulação de objetos reais (ex: aceleração em veículos).",
                                "Língua Portuguesa: Documentação clara de código como redação técnica.",
                                "Inglês: Leitura de documentação oficial Python em inglês."
                              ],
                              "realWorldApplication": "Em desenvolvimento de jogos (invocar métodos de movimento em sprites no Pygame), apps web (chamar métodos de usuário em frameworks como Django), automação de dados (métodos de processamento em pandas DataFrames) ou simulações científicas (atualizar estados em modelos físicos)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.2",
                            "name": "Passar argumentos para métodos de instância",
                            "description": "Utilizar parâmetros adicionais na invocação de métodos, entendendo como eles são mapeados para os parâmetros formais após a referência implícita da instância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar métodos de instância sem parâmetros e introduzir self",
                                  "subSteps": [
                                    "Defina uma classe simples, como 'Carro', com um atributo 'velocidade' inicializado no __init__.",
                                    "Crie um método de instância sem parâmetros, como 'mostrar_velocidade', que imprime a velocidade atual usando self.velocidade.",
                                    "Instancie um objeto e chame o método para entender a invocação implícita de self.",
                                    "Explique verbalmente ou em comentário como self é passado automaticamente como primeiro argumento.",
                                    "Execute o código e observe o output."
                                  ],
                                  "verification": "O método é chamado sem erros e imprime a velocidade corretamente.",
                                  "estimatedTime": "15 minutes",
                                  "materials": [
                                    "Editor de código Python (ex: VS Code, PyCharm)",
                                    "Interpretador Python 3+"
                                  ],
                                  "tips": "Sempre inclua self como primeiro parâmetro formal em métodos de instância.",
                                  "learningObjective": "Compreender o papel implícito de self na invocação de métodos.",
                                  "commonMistakes": [
                                    "Esquecer 'self' na definição do método",
                                    "Tentar chamar método sem instância"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Adicionar parâmetros formais ao método de instância",
                                  "subSteps": [
                                    "Modifique o método 'mostrar_velocidade' para aceitar um parâmetro formal, como 'unidade' (ex: 'km/h').",
                                    "Atualize o método para usar self.velocidade e o novo parâmetro: print(f'Velocidade: {self.velocidade} {unidade}').",
                                    "Adicione um segundo parâmetro opcional, como 'formato', com valor padrão.",
                                    "Salve e execute um teste rápido chamando o método sem argumentos extras para verificar defaults.",
                                    "Documente os parâmetros no docstring do método."
                                  ],
                                  "verification": "O método compila sem erros de sintaxe e usa os parâmetros corretamente em prints.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Editor de código Python",
                                    "Documentação oficial Python sobre funções"
                                  ],
                                  "tips": "Parâmetros após self são mapeados diretamente dos argumentos passados.",
                                  "learningObjective": "Definir métodos que recebem parâmetros adicionais além de self.",
                                  "commonMistakes": [
                                    "Colocar self após outros parâmetros",
                                    "Não usar self para acessar atributos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Invocar o método passando argumentos reais",
                                  "subSteps": [
                                    "Crie uma instância de 'Carro' e chame o método passando argumentos: carro.mostrar_velocidade('km/h', 'decimal').",
                                    "Teste com diferentes valores para múltiplos argumentos.",
                                    "Adicione um método 'acelerar(aumento)' que modifica self.velocidade += aumento e chame-o.",
                                    "Combine chamadas: acelere e depois mostre velocidade com argumentos.",
                                    "Use print ou debugger para inspecionar o mapeamento durante a execução."
                                  ],
                                  "verification": "O output reflete os argumentos passados e altera o estado da instância corretamente.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Editor de código Python",
                                    "Console interativo REPL para testes rápidos"
                                  ],
                                  "tips": "Argumentos na chamada são mapeados sequencialmente após self.",
                                  "learningObjective": "Invocar métodos de instância com parâmetros posicionais ou nomeados.",
                                  "commonMistakes": [
                                    "Passar self explicitamente na chamada",
                                    "Número incorreto de argumentos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, debugar e explorar variações avançadas",
                                  "subSteps": [
                                    "Crie cenários de erro: chame com argumentos errados e corrija TypeErrors ou ValueErrors.",
                                    "Implemente argumentos nomeados: carro.mostrar_velocidade(unidade='mph').",
                                    "Adicione validação nos métodos (ex: if aumento < 0: raise ValueError).",
                                    "Compare com funções livres para reforçar diferenças OOP.",
                                    "Escreva 3 testes unitários simples usando assert."
                                  ],
                                  "verification": "Todos os testes passam e erros são tratados graciosamente.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Biblioteca unittest do Python",
                                    "Debugger integrado no IDE"
                                  ],
                                  "tips": "Use *args e **kwargs para flexibilidade em métodos avançados.",
                                  "learningObjective": "Debugar e validar passagem de argumentos em métodos OOP.",
                                  "commonMistakes": [
                                    "Confundir parâmetros posicionais com nomeados",
                                    "Ignorar ordem de mapeamento"
                                  ]
                                }
                              ],
                              "practicalExample": "```python\nclass Carro:\n    def __init__(self, velocidade=0):\n        self.velocidade = velocidade\n\n    def acelerar(self, aumento):\n        self.velocidade += aumento\n        print(f'Nova velocidade: {self.velocidade} km/h')\n\n    def mostrar_velocidade(self, unidade='km/h', formato='decimal'):\n        print(f'Velocidade atual: {self.velocidade} {unidade} ({formato})')\n\ncarro = Carro(50)\ncarro.acelerar(30)  # Passa '30' para 'aumento'\ncarro.mostrar_velocidade('mph', 'cientifico')  # Argumentos nomeados\n``` Output esperado: acelera para 80, mostra corretamente.",
                              "finalVerifications": [
                                "Código executa sem erros de sintaxe ou runtime para 5 chamadas variadas.",
                                "Estado da instância (ex: velocidade) é alterado corretamente pelos métodos.",
                                "Output reflete exatamente os argumentos passados em ordem ou nomeados.",
                                "Testes unitários cobrem casos normais e edge cases (ex: argumentos inválidos).",
                                "Explicação oral correta sobre mapeamento self -> args.",
                                "Método funciona com múltiplas instâncias independentemente."
                              ],
                              "assessmentCriteria": [
                                "Correta definição de parâmetros após self (100% sintaxe OOP).",
                                "Invocações produzem outputs esperados (funcionalidade).",
                                "Uso correto de self para acessar/modificar atributos (conceitual).",
                                "Tratamento de erros em argumentos inválidos (robustez).",
                                "Eficiência: código limpo, sem código desnecessário (qualidade).",
                                "Criatividade: extensão natural do exemplo básico."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções e mapeamento de parâmetros como funções matemáticas.",
                                "Lógica/Algoritmos: Sequência de argumentos como fluxos de dados.",
                                "Inglês: Leitura de docstrings e documentação oficial Python.",
                                "Física: Modelagem de objetos reais (ex: carro com velocidade)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de jogos (ex: mover personagem com método player.move(dx, dy)), apps web (user.update_profile(name, email)) ou simulações científicas (particle.accelerate(force, time)), onde métodos de instância recebem dados dinâmicos para atualizar estados reais de objetos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.3",
                            "name": "Interpretar erros comuns em invocações",
                            "description": "Diagnosticar e corrigir erros como 'AttributeError' em Python ao tentar invocar método inexistente ou em instância nula.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de AttributeError em invocações de métodos",
                                  "subSteps": [
                                    "Ler a definição oficial do AttributeError na documentação Python.",
                                    "Analisar exemplos básicos de código que geram esse erro.",
                                    "Diferenciar AttributeError de erros semelhantes como NameError ou TypeError.",
                                    "Estudar a estrutura de um traceback completo, identificando linha e mensagem.",
                                    "Reproduzir um AttributeError simples em um editor de código."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito as causas principais do AttributeError e mostrar um traceback exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial Python (docs.python.org)",
                                    "Editor de código como VS Code ou PyCharm",
                                    "Console Python interativo (REPL)"
                                  ],
                                  "tips": [
                                    "Sempre foque na mensagem exata após 'AttributeError:'",
                                    "Use print() para inspecionar objetos antes da invocação",
                                    "Copie tracebacks para análise posterior"
                                  ],
                                  "learningObjective": "Dominar as definições e estruturas básicas do AttributeError em contextos de OOP.",
                                  "commonMistakes": [
                                    "Confundir com erros de sintaxe",
                                    "Ignorar o nome do atributo mencionado no erro",
                                    "Não examinar o tipo do objeto (ex: NoneType)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar causas comuns de AttributeError em invocações",
                                  "subSteps": [
                                    "Listar causas: método inexistente na classe, instância nula (None), atributo com nome errado.",
                                    "Criar código exemplo para cada causa e executar para observar o erro.",
                                    "Comparar tracebacks de diferentes causas para padrões.",
                                    "Usar dir(obj) e type(obj) para inspecionar objetos.",
                                    "Categorizar 5 exemplos reais de repositórios open-source."
                                  ],
                                  "verification": "Classificar corretamente 3 tracebacks diferentes por causa raiz.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código com Python instalado",
                                    "Exemplos de código em GitHub",
                                    "Ferramenta dir() e help() no Python"
                                  ],
                                  "tips": [
                                    "Verifique se a instância foi inicializada corretamente",
                                    "Use isinstance() para checar tipos esperados",
                                    "Mantenha classes pequenas para facilitar inspeção"
                                  ],
                                  "learningObjective": "Reconhecer padrões de erros em invocações de métodos em instâncias.",
                                  "commonMistakes": [
                                    "Assumir que o erro é sempre método inexistente",
                                    "Não checar se a variável foi atribuída",
                                    "Confundir herança com atributos locais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diagnosticar AttributeError em cenários práticos",
                                  "subSteps": [
                                    "Receber um código com erro oculto e executar para gerar traceback.",
                                    "Mapear a linha do erro no traceback à invocação problemática.",
                                    "Usar debugger (pdb ou IDE) para pausar e inspecionar variáveis.",
                                    "Documentar diagnóstico: causa, linha e solução proposta.",
                                    "Testar hipóteses com prints ou asserts temporários."
                                  ],
                                  "verification": "Produzir um relatório de diagnóstico para um código fornecido, identificando causa exata.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "IDE com debugger (PyCharm, VS Code)",
                                    "Códigos de teste com erros intencionais",
                                    "Ferramenta pdb (import pdb; pdb.set_trace())"
                                  ],
                                  "tips": [
                                    "Siga o traceback de baixo para cima",
                                    "Inspecione o objeto com vars(obj) ou getattr()",
                                    "Anote padrões para referência futura"
                                  ],
                                  "learningObjective": "Aplicar técnicas de diagnóstico sistemático em erros reais.",
                                  "commonMistakes": [
                                    "Pular linhas do traceback",
                                    "Não reproduzir o erro isoladamente",
                                    "Ignorar contexto de chamadas aninhadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Corrigir AttributeError e validar a solução",
                                  "subSteps": [
                                    "Aplicar correção baseada no diagnóstico (ex: checar None, corrigir nome).",
                                    "Adicionar guards como if obj is not None.",
                                    "Executar testes unitários para validar invocação.",
                                    "Refatorar código para prevenir recorrência (ex: propriedades).",
                                    "Comparar performance antes/depois com timeit."
                                  ],
                                  "verification": "Executar código corrigido sem erros e passar em 3 testes unitários.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Biblioteca unittest ou pytest",
                                    "Editor com suporte a testes",
                                    "Códigos corrigidos de steps anteriores"
                                  ],
                                  "tips": [
                                    "Prefira early returns para checagens de None",
                                    "Use Optional types com mypy para prevenção estática",
                                    "Sempre teste edge cases como None"
                                  ],
                                  "learningObjective": "Implementar correções robustas e verificações preventivas.",
                                  "commonMistakes": [
                                    "Corrigir sintoma sem causa raiz",
                                    "Não testar com dados reais",
                                    "Remover código sem substituição segura"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma classe Carro: class Carro: def acelerar(self): print('Acelerando'). Uso: meu_carro = None; meu_carro.acelerar() → AttributeError: 'NoneType' object has no attribute 'acelerar'. Diagnóstico: meu_carro é None. Correção: if meu_carro is not None: meu_carro.acelerar() else: print('Carro não inicializado').",
                              "finalVerifications": [
                                "Identificar AttributeError em qualquer traceback fornecido.",
                                "Listar 3 causas comuns sem hesitação.",
                                "Diagnosticar e corrigir um erro em código desconhecido em <5 min.",
                                "Explicar diferença entre AttributeError e KeyError.",
                                "Criar código que reproduz e corrige o erro intencionalmente.",
                                "Usar dir() para listar métodos disponíveis em instância."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação da causa raiz (90% acerto).",
                                "Qualidade do diagnóstico com mapeamento exato de traceback.",
                                "Efetividade da correção (código roda sem erros).",
                                "Uso de boas práticas preventivas (checagens, testes).",
                                "Documentação clara do processo de debug.",
                                "Tempo de resolução eficiente (<10 min por erro simples)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica dedutiva em diagnóstico de problemas.",
                                "Língua Portuguesa: Leitura e interpretação de textos técnicos (tracebacks).",
                                "Engenharia de Software: Práticas de debugging e testes.",
                                "Física/Química: Modelagem de sistemas com estados inválidos (análogos a None)."
                              ],
                              "realWorldApplication": "No desenvolvimento de software profissional, interpretar AttributeError previne crashes em apps como e-commerces ou jogos, economizando horas de debug em equipes; essencial em CI/CD para deploy confiável."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.3",
                        "name": "Passagem Implícita da Referência da Instância",
                        "description": "Durante a invocação de um método de instância, a linguagem passa automaticamente a referência do objeto chamador como primeiro argumento (ex: self em Python, this em C++/Java), permitindo acesso aos atributos da instância.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.3.1",
                            "name": "Explicar o mecanismo de self/this implícito",
                            "description": "Descrever como, em uma chamada instancia.metodo(arg), o interpretador transforma internamente em Classe.metodo(instancia, arg), passando a referência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender chamadas de métodos em instâncias",
                                  "subSteps": [
                                    "Revise o conceito de instância: crie uma classe simples com um método de instância.",
                                    "Escreva código para instanciar um objeto e chamar um método sem argumentos.",
                                    "Observe a sintaxe: obj.metodo() vs obj.metodo(arg).",
                                    "Explique verbalmente por que o método 'sabe' sobre a instância específica.",
                                    "Compare com funções livres para destacar a diferença."
                                  ],
                                  "verification": "Execute o código e confirme que o método acessa atributos da instância correta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código (VS Code ou PyCharm), documentação Python sobre classes.",
                                  "tips": "Use print statements para rastrear o 'this' implícito.",
                                  "learningObjective": "Compreender que métodos de instância recebem a instância como primeiro argumento.",
                                  "commonMistakes": "Confundir métodos de instância com métodos de classe ou estáticos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o desugaring interno da chamada",
                                  "subSteps": [
                                    "Analise a sintaxe instancia.metodo(arg) e identifique o que o interpretador faz.",
                                    "Reescreva manualmente como Classe.metodo(instancia, arg).",
                                    "Teste chamando o método diretamente via classe com a instância como self.",
                                    "Use o disassembler Python (dis module) para ver bytecode da chamada.",
                                    "Discuta por que isso é 'implícito' e não requer self explícito na chamada."
                                  ],
                                  "verification": "Confirme que Classe.metodo(instancia, arg) produz o mesmo resultado que instancia.metodo(arg).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python REPL ou Jupyter Notebook, módulo dis do Python.",
                                  "tips": "Ative debug com import dis; dis.show_code(obj.metodo).",
                                  "learningObjective": "Mapear a transformação sintática para o mecanismo de lookup de atributo.",
                                  "commonMistakes": "Esquecer que o lookup é em __dict__ da classe primeiro."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar self/this em linguagens OOP",
                                  "subSteps": [
                                    "Compare Python (self explícito no def) com JavaScript (this implícito).",
                                    "Crie exemplos em Python e JS mostrando a passagem implícita.",
                                    "Explique o papel do interpretador/runtime em cada linguagem.",
                                    "Teste cenários de perda de contexto (ex: callbacks em JS).",
                                    "Registre diferenças em uma tabela comparativa."
                                  ],
                                  "verification": "Explique corretamente as similaridades e diferenças em uma nota ou gravação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Node.js para JS, navegador console, tabela Markdown.",
                                  "tips": "Use arrow functions em JS para contrastar com this normal.",
                                  "learningObjective": "Reconhecer o self/this como referência à instância atual.",
                                  "commonMistakes": "Achar que self é global ou não precisa ser passado."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e debugar o mecanismo",
                                  "subSteps": [
                                    "Crie uma classe com método que modifica atributos da instância.",
                                    "Chame via instância e via classe, debugando com breakpoints.",
                                    "Intencionalmente passe self errado para ver erros.",
                                    "Explique o fluxo: descriptor protocol (__get__ para bound method).",
                                    "Refatore código legado para usar métodos de instância corretos."
                                  ],
                                  "verification": "Corrija um código com erro de self e execute testes unitários.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Pytest para testes, debugger (pdb ou IDE).",
                                  "tips": "Use @classmethod vs def para contrastar.",
                                  "learningObjective": "Diagnosticar problemas relacionados a self implícito.",
                                  "commonMistakes": "Passar self como None ou instância errada."
                                }
                              ],
                              "practicalExample": "Em Python: class Carro: def acelerar(self, velocidade): self.velocidade += velocidade. carro = Carro(); carro.acelerar(10) → Internamente: Carro.acelerar(carro, 10). Isso permite que self acesse carro.velocidade.",
                              "finalVerifications": [
                                "Pode reescrever qualquer chamada de método de instância na forma explícita Classe.metodo(instancia, args).",
                                "Explica o papel do descriptor protocol em métodos bound.",
                                "Identifica e corrige erros de contexto perdido em callbacks.",
                                "Usa dis module para confirmar o bytecode de uma chamada.",
                                "Compara corretamente self em Python com this em JS.",
                                "Cria um exemplo funcional em <5 minutos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do desugaring (100% correto).",
                                "Uso de exemplos concretos com código executável.",
                                "Explicação clara de verificações e erros comuns.",
                                "Profundidade em substeps (mínimo 4 por step).",
                                "Conexões com conceitos OOP mais amplos.",
                                "Capacidade de debugar cenários reais."
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Bytecode e interpretadores (compiladores).",
                                "Matemática: Funções de primeira classe e currying implícito.",
                                "Design de Software: Padrões como Observer que dependem de this/self.",
                                "Linguagens Formais: Parsing e resolução de nomes."
                              ],
                              "realWorldApplication": "Em frameworks como Django/Flask, métodos de view usam self para acessar request/user; entender isso previne bugs em herança e evita recriar instâncias desnecessariamente em apps escaláveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.3.2",
                            "name": "Acessar atributos da instância dentro de métodos",
                            "description": "Implementar métodos que utilizem self.atributo para ler ou modificar dados da instância específica, demonstrando encapsulamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o papel de 'self' em métodos de instância",
                                  "subSteps": [
                                    "Leia a documentação oficial do Python sobre métodos de instância e o parâmetro 'self'.",
                                    "Identifique que 'self' refere-se à instância atual durante a execução do método.",
                                    "Compare com funções comuns para destacar a diferença na passagem implícita da referência.",
                                    "Anote exemplos onde 'self' é omitido na chamada, mas passado automaticamente.",
                                    "Explique em suas palavras como 'self' permite acesso específico à instância."
                                  ],
                                  "verification": "Escreva um parágrafo explicando 'self' e forneça um exemplo simples de código comentado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação Python (docs.python.org)",
                                    "Editor de texto como VS Code"
                                  ],
                                  "tips": "Lembre-se: 'self' é como 'this' em outras linguagens; sempre o primeiro parâmetro.",
                                  "learningObjective": "Compreender que 'self' representa a instância específica e é passado implicitamente.",
                                  "commonMistakes": [
                                    "Confundir 'self' com a classe em si.",
                                    "Esquecer de incluir 'self' na definição do método.",
                                    "Usar 'self' em funções estáticas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar uma classe com atributos de instância e método de leitura",
                                  "subSteps": [
                                    "Defina uma classe simples, como 'ContaBancaria', com atributos como 'saldo' e 'titular'.",
                                    "Crie o método '__init__' para inicializar atributos via 'self'.",
                                    "Implemente um método 'get_saldo()' que retorne self.saldo.",
                                    "Crie uma instância e teste a chamada do método.",
                                    "Verifique se o valor retornado é específico da instância."
                                  ],
                                  "verification": "Execute o código e imprima o saldo de duas instâncias diferentes para confirmar valores únicos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python IDLE ou Jupyter Notebook",
                                    "Ambiente Python 3.x"
                                  ],
                                  "tips": "Use print() para depuração durante o teste.",
                                  "learningObjective": "Implementar métodos que leem atributos via 'self' para demonstrar acesso encapsulado.",
                                  "commonMistakes": [
                                    "Acessar atributo diretamente sem 'self'.",
                                    "Não inicializar atributos no '__init__'.",
                                    "Confundir atributos de classe com de instância."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar métodos para modificar atributos da instância",
                                  "subSteps": [
                                    "Adicione um método 'depositar(valor)' que faça self.saldo += valor.",
                                    "Adicione um método 'sacar(valor)' que verifique saldo e faça self.saldo -= valor se possível.",
                                    "Inclua validações usando 'self' para acessar o saldo atual.",
                                    "Teste com múltiplas operações em uma instância.",
                                    "Crie uma segunda instância e confirme que modificações são independentes."
                                  ],
                                  "verification": "Registre o saldo antes e depois das operações e afirme que as mudanças são locais à instância.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código com depurador",
                                    "Console Python"
                                  ],
                                  "tips": "Sempre valide entradas nos métodos para robustez.",
                                  "learningObjective": "Desenvolver métodos que modificam atributos via 'self', promovendo encapsulamento.",
                                  "commonMistakes": [
                                    "Modificar atributos globalmente.",
                                    "Esquecer validações como saldo insuficiente.",
                                    "Não usar 'self' nas modificações."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar encapsulamento e refatorar para boas práticas",
                                  "subSteps": [
                                    "Tente acessar 'saldo' diretamente de fora da classe e observe erro (se privado).",
                                    "Refatore métodos para usar convenções como '_' para atributos 'protegidos'.",
                                    "Crie testes unitários simples para métodos de leitura e escrita.",
                                    "Documente o código com comentários explicando uso de 'self'.",
                                    "Compare com versão sem 'self' para destacar benefícios."
                                  ],
                                  "verification": "Execute testes e confirme que acesso direto falha ou é desencorajado, enquanto métodos funcionam.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Biblioteca unittest do Python",
                                    "Exemplos de código anteriores"
                                  ],
                                  "tips": "Use 'assert' para verificações rápidas nos testes.",
                                  "learningObjective": "Demonstrar encapsulamento acessando/modificando apenas via métodos com 'self'.",
                                  "commonMistakes": [
                                    "Expor atributos publicamente.",
                                    "Não testar cenários de erro.",
                                    "Ignorar convenções de nomenclatura."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie a classe:\nclass ContaBancaria:\n    def __init__(self, titular, saldo=0):\n        self.titular = titular\n        self._saldo = saldo\n    \n    def get_saldo(self):\n        return self._saldo\n    \n    def depositar(self, valor):\n        if valor > 0:\n            self._saldo += valor\n            return True\n        return False\n\nconta1 = ContaBancaria('João', 100)\nprint(conta1.get_saldo())  # 100\nconta1.depositar(50)\nprint(conta1.get_saldo())  # 150",
                              "finalVerifications": [
                                "Criar duas instâncias e confirmar atributos independentes.",
                                "Chamar métodos de leitura e verificar valores corretos.",
                                "Executar modificações e afirmar persistência na instância.",
                                "Tentar acesso direto a atributos e notar encapsulamento.",
                                "Rodar testes unitários sem falhas.",
                                "Explicar verbalmente o fluxo de 'self' em um método."
                              ],
                              "assessmentCriteria": [
                                "Todos os métodos usam 'self' corretamente para acessar/modificar atributos.",
                                "Atributos são encapsulados (não acessíveis diretamente).",
                                "Código inclui validações e tratamentos de erro.",
                                "Testes demonstram independência de instâncias.",
                                "Comentários explicam uso de 'self'.",
                                "Estrutura segue boas práticas de OOP."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações aritméticas em atributos (soma/subtração de saldo).",
                                "Língua Portuguesa: Nomenclatura clara e documentação de métodos.",
                                "Ciências: Modelagem de sistemas reais como contas bancárias.",
                                "Lógica: Sequenciamento de passos em métodos com validações."
                              ],
                              "realWorldApplication": "Em aplicativos bancários, métodos como 'depositar()' e 'sacar()' usam 'self.saldo' para gerenciar o saldo específico de cada cliente, garantindo segurança e encapsulamento de dados sensíveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.3.3",
                            "name": "Visualizar em diagramas UML",
                            "description": "Representar a invocação de métodos e passagem implícita em diagramas de classes UML, mostrando mensagens entre objetos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Diagramas de Classes UML",
                                  "subSteps": [
                                    "Estude os elementos básicos: classes, atributos, métodos e relacionamentos.",
                                    "Identifique notações para objetos (retângulos com underline no nome).",
                                    "Aprenda sobre mensagens síncronas (setas abertas com linha sólida).",
                                    "Revise a passagem implícita de 'self' ou 'this' em chamadas de métodos.",
                                    "Pratique desenhando uma classe simples com um objeto instanciado."
                                  ],
                                  "verification": "Desenhe um diagrama simples de uma classe com objeto e confirme com um tutorial UML.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramenta de diagramação como draw.io ou Lucidchart; tutorial UML online.",
                                  "tips": "Use cores para diferenciar classes de objetos.",
                                  "learningObjective": "Compreender notações UML essenciais para classes e objetos.",
                                  "commonMistakes": "Confundir classes (sem underline) com objetos (com underline no nome)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Invocação de Métodos e Passagem Implícita",
                                  "subSteps": [
                                    "Examine código fonte de um método sendo chamado em uma instância, notando 'self'.",
                                    "Identifique a referência implícita da instância passada como primeiro argumento.",
                                    "Trace o fluxo: objeto A chama método em B, passando referência de A implicitamente.",
                                    "Anote parâmetros explícitos vs. implícitos em diagramas de sequência preliminares.",
                                    "Compare com chamadas estáticas para contrastar."
                                  ],
                                  "verification": "Escreva um resumo de 3 linhas explicando a passagem implícita e valide com código exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de código com exemplo OOP (Python/Java); papel para anotações.",
                                  "tips": "Pense em 'self' como um ponteiro invisível para o chamador.",
                                  "learningObjective": "Reconhecer como referências de instância são passadas implicitamente.",
                                  "commonMistakes": "Ignorar que 'self' é a instância receptora, não o chamador."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir Diagrama de Classes com Objetos e Mensagens",
                                  "subSteps": [
                                    "Desenhe as classes envolvidas com atributos e métodos relevantes.",
                                    "Crie instâncias (objetos) nomeados abaixo das classes.",
                                    "Adicione setas de mensagem do objeto chamador para o receptor, rotulando com nome do método.",
                                    "Inclua parâmetros explícitos na mensagem; destaque 'self' implicitamente.",
                                    "Ajuste layout para mostrar sequência temporal de cima para baixo."
                                  ],
                                  "verification": "Compartilhe o diagrama com um par para feedback inicial.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software UML (PlantUML, draw.io); código fonte exemplo.",
                                  "tips": "Use linha tracejada para retorno de métodos se aplicável.",
                                  "learningObjective": "Representar visualmente invocações de métodos em UML.",
                                  "commonMistakes": "Usar seta errada (ex: seta de herança em vez de mensagem)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Refinar e Validar o Diagrama",
                                  "subSteps": [
                                    "Verifique consistência entre código e diagrama (métodos, parâmetros).",
                                    "Adicione notas para passagem implícita de referência.",
                                    "Teste 'executando' o diagrama mentalmente para simular fluxo.",
                                    "Compare com exemplos profissionais de diagramas UML.",
                                    "Exporte e documente o diagrama com legenda."
                                  ],
                                  "verification": "Gere código a partir do diagrama e compile sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Exemplos UML profissionais; compilador/interpretador.",
                                  "tips": "Zoom out para verificar legibilidade geral.",
                                  "learningObjective": "Garantir precisão e clareza no diagrama final.",
                                  "commonMistakes": "Sobrecarregar o diagrama com detalhes desnecessários."
                                }
                              ],
                              "practicalExample": "Em uma classe Carro com método acelerar(velocidade), um objeto carro1.chamaMotor() passa implicitamente carro1 para motor.acelerar(). No UML: objeto 'carro1:Carro' -> seta mensagem 'chamaMotor()' -> 'motor:Motor', com nota 'self=carro1 implícito'.",
                              "finalVerifications": [
                                "Diagrama mostra objetos com underline nos nomes.",
                                "Mensagens rotuladas corretamente com nomes de métodos e parâmetros.",
                                "Passagem implícita de 'self/this' indicada via nota ou convenção.",
                                "Fluxo de mensagens segue ordem temporal.",
                                "Nenhuma seta de relacionamento confundida com mensagem.",
                                "Diagrama é legível e profissional."
                              ],
                              "assessmentCriteria": [
                                "Precisão na representação de classes vs. objetos (20%).",
                                "Correta notação de mensagens síncronas (30%).",
                                "Evidência clara de passagem implícita (20%).",
                                "Clareza e organização visual (15%).",
                                "Consistência com código fonte (10%).",
                                "Inclusão de verificações e notas (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de grafos direcionados.",
                                "Design Gráfico: Princípios de visualização de informações.",
                                "Linguagens: Análise sintática de código OOP.",
                                "Engenharia de Software: Documentação de sistemas."
                              ],
                              "realWorldApplication": "Desenvolvedores usam diagramas UML para documentar interações em sistemas como apps bancários, onde objetos 'Conta' invocam métodos em 'Transacao' passando referências implícitas, facilitando revisão de código e colaboração em equipes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.5",
                    "name": "Métodos Estáticos",
                    "description": "Definição e uso de métodos estáticos, que pertencem à classe e não requerem instância para serem chamados.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.5.1",
                        "name": "Definição de Métodos Estáticos",
                        "description": "Métodos estáticos são funções associadas à classe em vez de a uma instância específica do objeto. Eles não requerem a criação de um objeto para serem executados e não têm acesso direto aos atributos de instância (self ou this). São úteis para operações que pertencem logicamente à classe como um todo.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.1.1",
                            "name": "Identificar características de métodos estáticos",
                            "description": "Diferenciar métodos estáticos de métodos de instância, reconhecendo que métodos estáticos pertencem à classe, não acessam 'self' ou 'this' diretamente e são chamados via nome da classe.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Métodos de Instância",
                                  "subSteps": [
                                    "Leia a definição de método de instância: funções definidas dentro de uma classe que recebem 'self' como primeiro parâmetro.",
                                    "Examine um exemplo de código Python com um método de instância, como def calcular_idade(self):.",
                                    "Observe como métodos de instância são chamados via objeto: instancia.calcular_idade().",
                                    "Identifique que eles acessam atributos de instância via self.",
                                    "Anote as dependências em estado da instância."
                                  ],
                                  "verification": "Escreva um resumo de 3 frases explicando métodos de instância e teste chamando um em um objeto criado.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Editor de código (VS Code ou IDLE), documentação Python OOP básica.",
                                  "tips": "Sempre verifique se o método usa 'self' para acessar dados da instância.",
                                  "learningObjective": "Diferenciar métodos de instância por sua dependência em 'self' e estado do objeto.",
                                  "commonMistakes": "Confundir com funções globais; esquecer que precisam de uma instância para chamada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Conceito de Métodos Estáticos",
                                  "subSteps": [
                                    "Decore o decorador @staticmethod em Python ou palavra-chave static em Java.",
                                    "Leia que métodos estáticos não recebem 'self' ou 'this' e pertencem à classe.",
                                    "Veja sintaxe: def metodo_statico(): sem self.",
                                    "Teste chamando via classe: Classe.metodo_statico(), sem criar instância.",
                                    "Confirme que não acessam atributos de instância diretamente."
                                  ],
                                  "verification": "Crie uma classe simples com um método estático e chame-o via nome da classe sem instância.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de código, console Python interativo (REPL).",
                                  "tips": "Use @staticmethod para sinalizar claramente; teste chamadas inválidas para ver erros.",
                                  "learningObjective": "Reconhecer sintaxe e chamada de métodos estáticos sem dependência de instância.",
                                  "commonMistakes": "Incluir 'self' acidentalmente; tentar chamar via instância (funciona mas confunde)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diferenças Chave",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: colunas para instância vs estático (parâmetros, chamada, acesso a dados).",
                                    "Analise: estáticos pertencem à classe, não herdam estado de instância.",
                                    "Identifique usos: utilitários independentes como validações ou conversores.",
                                    "Simule cenários: tente acessar self em estático (deve dar erro).",
                                    "Discuta quando usar cada: estáticos para lógica pura da classe."
                                  ],
                                  "verification": "Preencha a tabela e corrija um código com erro comum de confusão entre os dois.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel ou planilha Google Sheets para tabela, exemplos de código.",
                                  "tips": "Pense em 'estático = sem estado'; memorize 'chamado por Classe.nometodo()'.",
                                  "learningObjective": "Diferenciar precisamente métodos estáticos de instância por pertencência, acesso e chamada.",
                                  "commonMistakes": "Achar que estáticos precisam de instância; ignorar que podem acessar métodos/classe static."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação em Código",
                                  "subSteps": [
                                    "Analise snippets de código mistos e rotule cada método como estático ou instância.",
                                    "Modifique um método instância para estático e vice-versa, observando mudanças.",
                                    "Resolva exercícios: 'Identifique por que este método é estático?'.",
                                    "Crie seu próprio exemplo com ambos e explique características.",
                                    "Debugue erros comuns como NameError ao usar self em estático."
                                  ],
                                  "verification": "Identifique corretamente 5 métodos em um código fornecido e justifique cada um.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Exercícios online (LeetCode, HackerRank OOP), seu editor.",
                                  "tips": "Procure ausência de 'self' e chamadas via classe como pistas rápidas.",
                                  "learningObjective": "Aplicar conhecimento para identificar características em código real.",
                                  "commonMistakes": "Confundir com métodos de classe (@classmethod, que usa cls)."
                                }
                              ],
                              "practicalExample": "Em uma classe Calculadora: def somar(a, b): return a + b  (@staticmethod) - chamado como Calculadora.somar(2,3). Vs def somar_meus_numeros(self): return self.x + self.y  - chamado como calc.somar_meus_numeros(). Identifique: somar é estático (sem self, chamado por classe).",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças chave sem hesitação.",
                                "Identificar corretamente métodos estáticos em um snippet de 20 linhas.",
                                "Converter um método instância para estático sem erros.",
                                "Chamar método estático via classe e instância, notando diferenças.",
                                "Listar 2 cenários reais onde métodos estáticos são preferíveis.",
                                "Debugar erro 'self não definido' em método estático."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção de sintaxe (ausência de self/this): 25%.",
                                "Correta compreensão de chamadas (classe vs instância): 25%.",
                                "Identificação de pertencência à classe: 20%.",
                                "Explicação de não acesso direto a estado de instância: 15%.",
                                "Aplicação em exemplos práticos sem erros: 15%."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções puras como métodos estáticos (sem efeitos colaterais).",
                                "Lógica e Raciocínio: Abstração de conceitos de estado vs stateless.",
                                "Inglês Técnico: Vocabulário OOP (static, instance, class method).",
                                "Design de Software: Princípios SOLID (SRP para utilitários)."
                              ],
                              "realWorldApplication": "Em bibliotecas como math (math.sqrt() é estático), validações em formulários web (UserValidator.is_valid_email(email) sem instância), ou factories em frameworks como Django para criar objetos sem estado prévio."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.2",
                            "name": "Comparar métodos estáticos com métodos de instância",
                            "description": "Analisar cenários onde métodos estáticos são preferíveis, como utilitários de classe (ex: contadores de instâncias), versus métodos que manipulam estado de objetos individuais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Métodos de Instância",
                                  "subSteps": [
                                    "Leia a definição de método de instância: funções definidas dentro de uma classe que operam no estado de uma instância específica.",
                                    "Analise um exemplo simples em Python ou Java: def get_name(self) em uma classe Pessoa.",
                                    "Crie uma instância da classe e chame o método para observar o acesso a atributos individuais.",
                                    "Registre como o método requer uma instância para ser chamado (obj.metodo()).",
                                    "Compare com funções comuns fora da classe."
                                  ],
                                  "verification": "Implemente e execute um método de instância que retorne um atributo único da instância, confirmando que funciona apenas com objeto criado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Documentação OOP da linguagem escolhida (Python/Java)"
                                  ],
                                  "tips": "Sempre prefixe com 'self' (Python) ou 'this' (Java) para acessar atributos da instância.",
                                  "learningObjective": "Identificar que métodos de instância dependem do estado mutável de objetos individuais.",
                                  "commonMistakes": [
                                    "Chamar método de instância sem criar uma instância",
                                    "Confundir com atributos de classe"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender Métodos Estáticos",
                                  "subSteps": [
                                    "Leia a definição: métodos que pertencem à classe, não a instâncias, decorados com @staticmethod (Python) ou static (Java).",
                                    "Analise exemplo: um método utilitário como contador de instâncias criado (self.count +=1 em __init__, get_count() estático).",
                                    "Crie e chame o método diretamente na classe (Classe.metodo()) sem instância.",
                                    "Observe que não acessa 'self' ou atributos de instância.",
                                    "Teste chamadas em múltiplas instâncias para ver comportamento global."
                                  ],
                                  "verification": "Implemente um método estático que retorne um valor global da classe, chamando-o sem instâncias.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Referência de @staticmethod ou 'static'"
                                  ],
                                  "tips": "Use para lógica que não depende de dados de instância, como validações ou fábricas.",
                                  "learningObjective": "Reconhecer que métodos estáticos gerenciam estado da classe ou são utilitários puros.",
                                  "commonMistakes": [
                                    "Tentar acessar 'self' em método estático",
                                    "Usar para lógica específica de instância"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Diferenças Chave",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: acesso a estado (instância vs classe), chamada (obj vs Classe), herança.",
                                    "Teste código: altere estado de uma instância e veja impacto em método estático (nenhum).",
                                    "Analise performance: estáticos não precisam de objeto, mais eficientes para utilitários.",
                                    "Discuta encapsulamento: instância protege dados privados por objeto; estático é global.",
                                    "Refatore um método de instância para estático onde possível e observe mudanças."
                                  ],
                                  "verification": "Preencha uma tabela de comparação com pelo menos 5 diferenças e valide com código executável.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou documento para tabela",
                                    "Ambiente de execução de código"
                                  ],
                                  "tips": "Lembre: estáticos são como funções da classe; instância são comportamentos personalizados.",
                                  "learningObjective": "Diferenciar acesso a estado, invocação e propósitos entre os dois tipos.",
                                  "commonMistakes": [
                                    "Achar que estáticos herdam como instância",
                                    "Ignorar overhead de criação de objeto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Cenários de Uso Preferencial",
                                  "subSteps": [
                                    "Identifique cenários para estáticos: contadores, utilitários (Math.random()), factories.",
                                    "Para instância: manipulação de dados pessoais (getSalary(), setName()).",
                                    "Crie exemplos híbridos: classe com ambos, simulando app real.",
                                    "Debata prós/contras: estáticos facilitam acesso global, mas dificultam testes unitários.",
                                    "Refatore código dado: decida e justifique qual método usar em cada caso."
                                  ],
                                  "verification": "Desenvolva um exemplo com classe usando ambos métodos e explique escolhas em comentários.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exemplos de código de bibliotecas (Math em Java/Python)",
                                    "Ferramenta de refatoração no IDE"
                                  ],
                                  "tips": "Prefira estáticos para 'não depende de mim, mas da classe toda'.",
                                  "learningObjective": "Avaliar quando um tipo é preferível baseado em contexto e necessidades.",
                                  "commonMistakes": [
                                    "Usar estático para estado mutável por instância",
                                    "Sobrecarregar instância com lógica global"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma classe ContaBancaria: método get_saldo(self) é de instância (varia por conta); método total_contas() é estático (conta quantas contas criadas globalmente). Teste criando 3 contas: total_contas() retorna 3, independentemente de qual instância.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças chave entre os métodos.",
                                "Identificar corretamente tipo de método em código fornecido.",
                                "Refatorar código simples trocando tipos sem quebrar funcionalidade.",
                                "Criar exemplo próprio com justificativa de escolha.",
                                "Discutir impacto em herança e polimorfismo.",
                                "Executar testes unitários para ambos tipos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção de estado acessado (instância vs classe).",
                                "Correta invocação em código (objeto vs classe).",
                                "Justificativa contextual para preferência em cenários.",
                                "Ausência de erros comuns como acesso inválido a 'self'.",
                                "Criatividade e relevância nos exemplos práticos.",
                                "Compreensão de implicações em design (testabilidade, performance)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções puras (estáticas) vs funções com parâmetros variáveis (instância).",
                                "Design de Software: Padrões Singleton ou Factory usando estáticos.",
                                "Banco de Dados: Procedimentos armazenados globais vs consultas parametrizadas por registro.",
                                "Física: Propriedades globais (constantes universais) vs propriedades locais de partículas."
                              ],
                              "realWorldApplication": "Bibliotecas como Math.sqrt() (estático, utilitário global) vs objeto Carro.acelerar() (instância, altera estado específico do carro); em apps web, User.count() para métricas globais vs user.get_profile()."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.3",
                            "name": "Reconhecer vantagens e limitações",
                            "description": "Explicar benefícios como eficiência (sem instância) e limitações como falta de acesso a dados de instância, com exemplos em Python ou C++.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição e Sintaxe de Métodos Estáticos",
                                  "subSteps": [
                                    "Leia a documentação oficial de métodos estáticos em Python (usando @staticmethod) ou C++ (usando static keyword em classes).",
                                    "Escreva um exemplo simples de classe com método estático que não acessa atributos de instância.",
                                    "Compile e execute o código para observar que o método é chamado via classe, não instância.",
                                    "Compare sintaxe com métodos de instância (self/this).",
                                    "Anote diferenças chave em um documento."
                                  ],
                                  "verification": "Código executa sem erros e método é acessível via nome da classe.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Documentação Python/C++ oficial",
                                    "Terminal para execução"
                                  ],
                                  "tips": "Sempre use @staticmethod em Python para evitar confusão com classmethods.",
                                  "learningObjective": "Compreender a sintaxe e chamada de métodos estáticos versus métodos de instância.",
                                  "commonMistakes": [
                                    "Esquecer o decorador @staticmethod",
                                    "Tentar acessar self dentro do método estático",
                                    "Confundir com métodos de classe"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Explicar Vantagens dos Métodos Estáticos",
                                  "subSteps": [
                                    "Liste vantagens como independência de instâncias (eficiência em memória e tempo).",
                                    "Crie exemplo: método estático para validação de email em uma classe Utils, chamado sem criar objeto.",
                                    "Meça tempo de execução comparando chamadas com e sem instância (use timeit em Python).",
                                    "Discuta cenários onde utilidade é alta, como funções utilitárias globais.",
                                    "Registre pelo menos 3 vantagens com justificativas."
                                  ],
                                  "verification": "Lista de vantagens com exemplos de código funcional e medições de performance.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Biblioteca timeit (Python)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Pense em funções puras: entrada determinística sem estado.",
                                  "learningObjective": "Reconhecer eficiência e utilidade de métodos estáticos em contextos sem estado.",
                                  "commonMistakes": [
                                    "Ignorar overhead de criação de instância desnecessária",
                                    "Confundir eficiência com métodos de classe",
                                    "Não quantificar ganhos de performance"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Limitações dos Métodos Estáticos",
                                  "subSteps": [
                                    "Tente acessar atributo de instância dentro de método estático e observe erro.",
                                    "Exemplo: Em classe BankAccount, método estático não pode acessar saldo sem instância.",
                                    "Compare com método de instância que usa self para dados específicos.",
                                    "Liste 3 limitações, como falta de acesso a estado da instância e herança restrita.",
                                    "Refatore um método de instância para estático onde possível e note perdas."
                                  ],
                                  "verification": "Código demonstra erros ao tentar acessar self/this e lista clara de limitações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Documentação de erros Python/C++"
                                  ],
                                  "tips": "Métodos estáticos são para lógica stateless; use instância para estado.",
                                  "learningObjective": "Identificar quando métodos estáticos falham devido à ausência de contexto de instância.",
                                  "commonMistakes": [
                                    "Forçar acesso a self violando regras",
                                    "Subestimar necessidade de estado em OOP",
                                    "Confundir com funções globais fora de classes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Sintetizar Vantagens e Limitações com Exemplos Práticos",
                                  "subSteps": [
                                    "Crie tabela comparativa: colunas para Estático vs Instância, linhas para acesso dados, performance, uso.",
                                    "Implemente classe MathUtils com estático sqrt() e instância calculate() com estado.",
                                    "Teste em cenários: utilitário puro vs cálculo por objeto.",
                                    "Escreva parágrafo resumindo quando usar cada um.",
                                    "Debata com colega ou simule Q&A sobre trade-offs."
                                  ],
                                  "verification": "Tabela completa, código testado e resumo escrito.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Planilha ou Markdown para tabela",
                                    "Exemplos de código prontos"
                                  ],
                                  "tips": "Use profiling tools como cProfile para evidências reais.",
                                  "learningObjective": "Sintetizar trade-offs para decisões informadas em design de classes.",
                                  "commonMistakes": [
                                    "Viés para um tipo sem considerar contexto",
                                    "Exemplos irrelevantes",
                                    "Não testar cenários reais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: class Utils: @staticmethod def is_valid_email(email): return '@' in email. Uso: Utils.is_valid_email('test@example.com') – eficiente sem instância. Limitação: Não acessa user_data de instância específica.",
                              "finalVerifications": [
                                "Lista corretamente 3+ vantagens (ex: eficiência, utilidade global).",
                                "Explica limitações com exemplo de erro de acesso a self.",
                                "Compara performance em código executável.",
                                "Identifica cenários ideais para métodos estáticos.",
                                "Fornece exemplo real-world sem erros.",
                                "Responde Q&A sobre trade-offs com precisão."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de vantagens (eficiência sem instância).",
                                "Correta identificação de limitações (sem dados de instância).",
                                "Exemplos de código funcionais em Python/C++.",
                                "Análise comparativa clara e equilibrada.",
                                "Uso de evidências (testes, medições).",
                                "Clareza na comunicação de trade-offs."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções puras e stateless semelhantes a funções matemáticas.",
                                "Design de Software: Padrões como Utility Classes e Factory Methods.",
                                "Ciência da Computação: Otimização de performance e alocação de memória.",
                                "Lógica: Análise de trade-offs em decisões binárias."
                              ],
                              "realWorldApplication": "Bibliotecas como math ou datetime em Python usam métodos estáticos para funções utilitárias (ex: math.sqrt()), evitando overhead de instâncias em apps de dados, jogos ou ferramentas de engenharia onde eficiência é crítica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.2",
                        "name": "Declaração de Métodos Estáticos",
                        "description": "A declaração de métodos estáticos varia por linguagem: em Python usa-se o decorador @staticmethod; em C++, a palavra-chave 'static' dentro da classe. Não recebem o parâmetro de instância.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.2.1",
                            "name": "Declarar método estático em Python",
                            "description": "Escrever a sintaxe correta usando @staticmethod, sem parâmetro 'self', e integrá-lo em uma classe, conforme exemplos de bibliografia como Lott & Phillips.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de métodos estáticos em Python",
                                  "subSteps": [
                                    "Leia a definição: métodos estáticos pertencem à classe, não à instância, e não acessam 'self' ou 'cls'.",
                                    "Compare com métodos de instância (usam 'self') e métodos de classe (usam @classmethod e 'cls').",
                                    "Estude exemplos da bibliografia (Lott & Phillips): métodos para utilidades que não dependem do estado da instância.",
                                    "Anote diferenças chave: invocados via classe ou instância, sem acesso a atributos de instância.",
                                    "Resuma em suas palavras: quando usar @staticmethod vs outros métodos."
                                  ],
                                  "verification": "Escreva um resumo de 3-5 frases explicando métodos estáticos e envie para revisão.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Documentação Python oficial: https://docs.python.org/3/library/functions.html#staticmethod",
                                    "Livro Lott & Phillips (capítulo sobre OOP)"
                                  ],
                                  "tips": "Visualize métodos estáticos como funções 'presas' à classe para organização, não para estado.",
                                  "learningObjective": "Compreender o propósito e diferenças de métodos estáticos em relação a outros tipos de métodos.",
                                  "commonMistakes": [
                                    "Confundir com métodos de classe (que usam 'cls')",
                                    "Pensar que precisam de 'self'"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a sintaxe básica do decorador @staticmethod",
                                  "subSteps": [
                                    "Abra um editor Python (ex: VS Code ou IDLE).",
                                    "Escreva uma classe vazia: class MinhaClasse: pass",
                                    "Adicione o decorador: def meu_metodo(): print('Estático!') logo após @staticmethod",
                                    "Teste a sintaxe: rode o código sem erros de indentação.",
                                    "Verifique com help(): print(help(meu_metodo)) para confirmar <staticmethod>."
                                  ],
                                  "verification": "Código roda sem SyntaxError e help() mostra <staticmethod MinhaClasse.meu_metodo>.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor Python",
                                    "Console interativo Python"
                                  ],
                                  "tips": "O decorador deve estar diretamente acima da def, sem linhas em branco entre eles.",
                                  "learningObjective": "Dominar a colocação exata do @staticmethod na definição do método.",
                                  "commonMistakes": [
                                    "Esquecer o @ ou colocá-lo errado",
                                    "Adicionar parênteses desnecessários: @staticmethod()"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Declarar um método estático integrado a uma classe funcional",
                                  "subSteps": [
                                    "Crie uma classe exemplo: class Calculadora:",
                                    "Defina um método estático: @staticmethod def somar(a, b): return a + b",
                                    "Note ausência de 'self': parâmetros são explícitos, sem estado de instância.",
                                    "Adicione corpo útil: inclua docstring '''Soma dois números.'''",
                                    "Salve em arquivo .py e importe para teste."
                                  ],
                                  "verification": "Método definido sem 'self' e decorador correto; dir(Calculadora) lista o método.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Arquivo Python novo: calculator.py"
                                  ],
                                  "tips": "Use parâmetros genéricos para flexibilidade; evite lógica que precise de 'self'.",
                                  "learningObjective": "Escrever sintaxe completa de método estático sem 'self' dentro de uma classe.",
                                  "commonMistakes": [
                                    "Incluir 'self' por hábito",
                                    "Indentação errada no decorador"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e verificar o método estático",
                                  "subSteps": [
                                    "Crie instância: calc = Calculadora()",
                                    "Chame via classe: print(Calculadora.somar(2, 3)) == 5",
                                    "Chame via instância: print(calc.somar(2, 3)) == 5",
                                    "Teste erro intencional: adicione 'self' e veja TypeError ao chamar.",
                                    "Corrija e confirme: método acessível sem instância."
                                  ],
                                  "verification": "Ambas chamadas retornam 5 sem erros; tentativa com 'self' falha corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Console Python",
                                    "Arquivo calculator.py"
                                  ],
                                  "tips": "Métodos estáticos são ideais para funções puras; teste acessibilidade dupla.",
                                  "learningObjective": "Validar funcionamento correto do método estático em contextos classe e instância.",
                                  "commonMistakes": [
                                    "Aguardar 'self' em chamada",
                                    "Confundir saída com métodos de instância"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma classe Calculadora:\nclass Calculadora:\n    @staticmethod\n    def somar(a, b):\n        '''Retorna a soma de a e b.'''\n        return a + b\n\n# Uso:\nresultado = Calculadora.somar(5, 7)  # 12\nou\ncalc = Calculadora()\nresultado = calc.somar(5, 7)  # 12",
                              "finalVerifications": [
                                "Código roda sem SyntaxError ou TypeError.",
                                "Método é listado em dir(Classe) como função.",
                                "Chamada via Classe.metodo() e instancia.metodo() funcionam igualmente.",
                                "Ausência total de 'self' na definição.",
                                "Decorador @staticmethod está corretamente posicionado.",
                                "Docstring ou comentário explica propósito."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe precisa: @staticmethod acima de def sem 'self'.",
                                "Integração correta na classe com indentação adequada.",
                                "Método funcional e testável com entrada/saída esperada.",
                                "Sem dependência de estado de instância.",
                                "Explicação clara do código em comentários.",
                                "Testes cobrem chamadas via classe e instância."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Implementação de funções utilitárias como soma ou validações numéricas.",
                                "Design de Software: Padrões como Utility Classes e Factory Methods.",
                                "Lógica Computacional: Abstração de funções independentes de objetos.",
                                "Inglês Técnico: Leitura de docs Python e bibliografia (Lott & Phillips)."
                              ],
                              "realWorldApplication": "Métodos estáticos são usados em bibliotecas como math (math.gcd()), para utilitários globais sem instância, em validadores de formulários web (ex: validar_email()), ou em classes de conversão de unidades sem estado, promovendo código modular e reutilizável em projetos Django/Flask."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.2",
                            "name": "Declarar método estático em C++",
                            "description": "Utilizar 'static' na assinatura do método dentro da classe e implementar fora se necessário, sem parâmetro 'this' implícito, baseado em Saraiva.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a estrutura da classe e entender o papel do 'static'",
                                  "subSteps": [
                                    "Abra seu ambiente de desenvolvimento (IDE ou editor com compilador C++).",
                                    "Crie um novo arquivo .cpp e inclua as headers necessárias (#include <iostream>).",
                                    "Defina uma classe simples usando 'class NomeClasse { };'.",
                                    "Identifique onde métodos estáticos se encaixam: funções que operam em dados da classe sem instância.",
                                    "Anote que 'static' remove o 'this' implícito."
                                  ],
                                  "verification": "Classe vazia criada e compilada com sucesso em um programa main simples.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, Code::Blocks)",
                                    "Compilador g++",
                                    "Arquivo .cpp novo"
                                  ],
                                  "tips": "Sempre use namespace std; para simplificar. Teste compilação precoce.",
                                  "learningObjective": "Compreender o conceito de método estático e preparar o esqueleto da classe.",
                                  "commonMistakes": [
                                    "Esquecer #include <iostream>",
                                    "Não usar ponto e vírgula após a classe",
                                    "Confundir static com funções membro normais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar o método estático dentro da classe",
                                  "subSteps": [
                                    "Dentro da definição da classe, adicione a assinatura: static tipoRetorno nomeMetodo(parametros);",
                                    "Escolha um exemplo simples, como static int contarInstancias();",
                                    "Garanta que a declaração esteja na seção public: se for pública.",
                                    "Salve o arquivo e tente compilar para verificar erros de sintaxe.",
                                    "Comente o código explicando por que 'static' é usado aqui."
                                  ],
                                  "verification": "Compilação sem erros de declaração; método visível na classe.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Mesmo arquivo .cpp",
                                    "Documentação C++ sobre classes (cppreference.com)"
                                  ],
                                  "tips": "Use 'public:' explicitamente para clareza. Evite sobrecarga inicial.",
                                  "learningObjective": "Dominar a sintaxe exata de declaração de método estático na classe.",
                                  "commonMistakes": [
                                    "Esquecer 'static' na declaração",
                                    "Adicionar corpo na declaração (use ;)",
                                    "Colocar em private sem intenção"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o método estático fora da classe",
                                  "subSteps": [
                                    "Fora da classe, use EscopoClasse::nomeMetodo { corpo da função };",
                                    "Implemente lógica simples, ex: return ++contador; com static int contador = 0; dentro da função.",
                                    "Note ausência de 'this' – acesse membros estáticos via EscopoClasse::.",
                                    "Compile novamente para validar a ligação.",
                                    "Adicione um main() para chamar o método via NomeClasse::nomeMetodo();"
                                  ],
                                  "verification": "Função implementada compila e linka corretamente sem instância da classe.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador g++",
                                    "Referência de implementação de métodos (cppreference.com)"
                                  ],
                                  "tips": "Use Qualificador de escopo (::) sempre na implementação. Teste com cout para debug.",
                                  "learningObjective": "Aprender a implementar métodos estáticos com escopo correto e sem 'this'.",
                                  "commonMistakes": [
                                    "Esquecer :: no escopo",
                                    "Usar 'this' na implementação estática",
                                    "Definir corpo inline se planeja separar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e verificar o comportamento estático",
                                  "subSteps": [
                                    "No main(), chame o método sem criar objeto: Classe::metodo();",
                                    "Execute o programa e observe saída (ex: contador compartilhado).",
                                    "Crie instâncias da classe e chame via objeto – deve funcionar igual.",
                                    "Modifique para provar independência de instância (chame múltiplas vezes).",
                                    "Compile com g++ -o teste arquivo.cpp && ./teste"
                                  ],
                                  "verification": "Programa executa corretamente, método acessível via classe e instância, sem erros de runtime.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Terminal para compilar e executar",
                                    "g++ instalado"
                                  ],
                                  "tips": "Use gdb para debug se erros. Compare com métodos não-estáticos.",
                                  "learningObjective": "Validar que o método estático funciona sem instância e compartilha estado.",
                                  "commonMistakes": [
                                    "Tentar chamar como obj.metodo() e esperar falha (não falha, mas confunde)",
                                    "Variáveis locais não-estáticas",
                                    "Erros de linkage por falta de implementação"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe 'MathUtils' com static double pi() { return 3.14159; }. Declare na classe: static double pi(); Implemente fora: double MathUtils::pi() { return 3.14159; }. No main: cout << MathUtils::pi(); // Saída: 3.14159 sem instância.",
                              "finalVerifications": [
                                "Código compila sem warnings sobre 'static' ou linkage.",
                                "Método é chamado via NomeClasse::metodo() sem objeto.",
                                "Estado estático (ex: contador) é compartilhado entre chamadas.",
                                "Não há referência a 'this' na implementação.",
                                "Compilação separada (header + cpp) funciona.",
                                "Teste unitário simples passa."
                              ],
                              "assessmentCriteria": [
                                "Declaração usa 'static' corretamente na assinatura da classe.",
                                "Implementação usa escopo :: e não acessa membros não-estáticos.",
                                "Código compila e executa sem erros ou warnings.",
                                "Exemplo demonstra independência de instância.",
                                "Comentários explicam ausência de 'this'.",
                                "Tempo de execução coerente com eficiência estática."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções puras e constantes universais (ex: pi).",
                                "Design de Software: Princípios de utilitários e factory methods.",
                                "Física: Constantes físicas acessíveis globalmente (ex: velocidade da luz).",
                                "Banco de Dados: Contadores globais como sequence generators.",
                                "Administração: Métricas de classe compartilhadas em relatórios."
                              ],
                              "realWorldApplication": "Métodos estáticos são usados em bibliotecas como std::numeric_limits::max() para valores máximos de tipos, em singletons para acesso global, ou em classes utilitárias como String::toUpper() em frameworks, evitando overhead de instâncias desnecessárias em apps de alto desempenho como jogos ou servidores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.3",
                        "name": "Uso e Invocação de Métodos Estáticos",
                        "description": "Métodos estáticos são invocados diretamente pelo nome da classe (Classe.metodo()), sem necessidade de instância, e podem ser usados para factory methods ou validações.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.3.1",
                            "name": "Invocar métodos estáticos corretamente",
                            "description": "Chamar métodos estáticos via nome da classe em Python (Classe.metodo()) ou C++ (Classe::metodo()), demonstrando com código funcional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos de Métodos Estáticos",
                                  "subSteps": [
                                    "Leia a definição de método estático: funções pertencentes à classe, não a instâncias, acessíveis via nome da classe.",
                                    "Compare com métodos de instância: estáticos não precisam de 'self' em Python ou objeto em C++.",
                                    "Estude quando usar: utilitários como conversões ou cálculos independentes de estado.",
                                    "Revise sintaxe básica: @staticmethod em Python; static no C++.",
                                    "Anote diferenças entre Python (decorator) e C++ (keyword static)."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos chave e diferenças entre linguagens.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação Python: staticmethod",
                                    "Documentação C++: static member functions",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use analogia: método estático é como uma ferramenta da classe, não do objeto.",
                                  "learningObjective": "Diferenciar métodos estáticos de instância e entender acessibilidade.",
                                  "commonMistakes": [
                                    "Confundir com métodos de classe (@classmethod), esquecer decorator em Python."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Método Estático em Python",
                                  "subSteps": [
                                    "Crie uma classe simples, ex: class MathUtils.",
                                    "Defina um método com @staticmethod, ex: def add(a, b): return a + b.",
                                    "Evite usar 'self' no método.",
                                    "Salve em arquivo .py e execute para testar definição.",
                                    "Adicione docstring explicando uso."
                                  ],
                                  "verification": "Código define classe sem erros de sintaxe; método é reconhecido como estático via help().",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code/IDLE)",
                                    "Python 3.x instalado"
                                  ],
                                  "tips": "Teste com dir(Classe) para ver o método listado.",
                                  "learningObjective": "Implementar corretamente um método estático em Python.",
                                  "commonMistakes": [
                                    "Omitir @staticmethod, causando TypeError ao chamar sem instância."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Invocar Método Estático em Python",
                                  "subSteps": [
                                    "Chame via Classe.metodo(arg1, arg2), ex: MathUtils.add(2, 3).",
                                    "Compare com chamada em instância: obj = MathUtils(); obj.add(2,3) – deve funcionar igual.",
                                    "Teste cenários: argumentos variados, edge cases (zero, negativos).",
                                    "Registre output em console.",
                                    "Refatore para múltiplos métodos estáticos."
                                  ],
                                  "verification": "Output correto sem erros; funciona tanto via classe quanto instância.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Terminal/REPL Python",
                                    "Arquivo .py do Step 2"
                                  ],
                                  "tips": "Use print para depurar retornos.",
                                  "learningObjective": "Invocar método estático corretamente via nome da classe.",
                                  "commonMistakes": [
                                    "Chamar como instância primeiro: obj.metodo(), esquecendo Classe.metodo()."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir e Invocar Método Estático em C++",
                                  "subSteps": [
                                    "Crie classe: class MathUtils { public: static int add(int a, int b) { return a + b; } };",
                                    "Compile com g++: g++ -o test file.cpp.",
                                    "No main(): cout << MathUtils::add(2, 3);",
                                    "Teste sem instância e com instância (deve funcionar).",
                                    "Adicione header guards se em .h."
                                  ],
                                  "verification": "Programa compila e executa com output 5, sem linker errors.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador g++",
                                    "Editor como Code::Blocks ou VS Code com C++ extension"
                                  ],
                                  "tips": "Declare static na classe e defina fora se necessário.",
                                  "learningObjective": "Implementar e invocar método estático em C++ usando ::.",
                                  "commonMistakes": [
                                    "Esquecer 'static' na declaração, causar erro de linkage."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar e Comparar Ambas Linguagens",
                                  "subSteps": [
                                    "Crie classe utilitária comum (ex: conversor de unidades) em ambas linguagens.",
                                    "Invocar em scripts/programas completos.",
                                    "Compare performance/tempo de execução (simples benchmark).",
                                    "Documente diferenças chave em um relatório curto.",
                                    "Teste em projeto mini: calculadora estática."
                                  ],
                                  "verification": "Ambos códigos funcionam; relatório lista 3 similaridades/diferenças.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Arquivos de steps anteriores",
                                    "Timer para benchmark"
                                  ],
                                  "tips": "Use funções como sqrt em <cmath> para inspiração real.",
                                  "learningObjective": "Aplicar invocação em contextos reais, comparando linguagens.",
                                  "commonMistakes": [
                                    "Misturar sintaxes entre linguagens."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie class Utils com @staticmethod def is_even(n): return n % 2 == 0 em Python. Chame Utils.is_even(4) → True. Em C++: static bool is_even(int n) { return n % 2 == 0; } → Utils::is_even(4). Use em loop para filtrar pares.",
                              "finalVerifications": [
                                "Código Python roda sem AttributeError ao chamar Classe.metodo().",
                                "Código C++ compila sem undefined reference a static methods.",
                                "Output corresponde a inputs esperados em 5 testes variados.",
                                "Método acessível sem criar instância da classe.",
                                "Docstrings/comentários explicam uso estático.",
                                "Benchmark mostra eficiência similar entre linguagens."
                              ],
                              "assessmentCriteria": [
                                "Correção sintática: 100% sem erros de compilação/execução.",
                                "Uso preciso: Sempre via Classe.metodo() ou ::, não instância obrigatória.",
                                "Cobertura de edge cases: Testes com 0, negativos, grandes números.",
                                "Clareza: Código legível com comentários.",
                                "Eficiência: Sem loops desnecessários em métodos simples.",
                                "Documentação: Explica por que estático foi escolhido."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções utilitárias como constantes π ou conversões.",
                                "Design de Software: Padrões Singleton/Fábrica usando estáticos.",
                                "Lógica Computacional: Abstrações independentes de estado.",
                                "Física/Engenharia: Constantes globais (ex: g = 9.8)."
                              ],
                              "realWorldApplication": "Em bibliotecas como math (Python: math.pi acessível diretamente) ou std::numeric_limits (C++), para validações de input em apps web/mobile, logging utils em frameworks (ex: Logger::info()), otimizando performance ao evitar instâncias desnecessárias."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.3.2",
                            "name": "Aplicar em casos práticos",
                            "description": "Implementar exemplos como contador de instâncias ou métodos utilitários (ex: conversão de unidades), integrando com UML para modelagem de classes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejar e Modelar a Classe com UML",
                                  "subSteps": [
                                    "Identifique o caso prático: contador de instâncias e método utilitário de conversão de unidades (ex: km para milhas).",
                                    "Desenhe o diagrama de classes UML mostrando atributos estáticos (ex: contador), métodos estáticos e relacionamentos.",
                                    "Defina a assinatura dos métodos estáticos: public static int getContadorInstancias() e public static double kmParaMilhas(double km).",
                                    "Adicione construtor que incrementa o contador estático.",
                                    "Valide o diagrama garantindo que métodos estáticos não dependam de instâncias."
                                  ],
                                  "verification": "Diagrama UML completo e legível, com métodos estáticos claramente marcados e sem dependências de instância.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel ou ferramenta UML online (ex: Lucidchart, Draw.io), documentação de UML básica.",
                                  "tips": "Use notação UML padrão: sublinhe nomes de métodos estáticos.",
                                  "learningObjective": "Compreender como métodos estáticos se integram à estrutura de classes via modelagem UML.",
                                  "commonMistakes": "Esquecer de marcar métodos como estáticos no UML; incluir parâmetros de instância em métodos estáticos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Contador de Instâncias com Método Estático",
                                  "subSteps": [
                                    "Crie a classe base (ex: Carro) com atributo estático privado int contador = 0.",
                                    "Adicione construtor que faz contador++.",
                                    "Implemente método estático public static int getNumeroDeInstancias() { return contador; }.",
                                    "Crie main para testar: instancie 3 objetos e chame o método estático.",
                                    "Compile e execute para verificar contagem correta."
                                  ],
                                  "verification": "Ao criar múltiplas instâncias, getNumeroDeInstancias() retorna o número exato de instâncias criadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "IDE (ex: IntelliJ, VS Code com Java), compilador Java.",
                                  "tips": "Acesse o método sem instância: Classe.metodo().",
                                  "learningObjective": "Implementar contador compartilhado via variáveis e métodos estáticos.",
                                  "commonMistakes": "Incrementar contador no método estático em vez do construtor; esquecer static no atributo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Método Utilitário Estático e Integrar",
                                  "subSteps": [
                                    "Adicione método estático public static double kmParaMilhas(double km) { return km * 0.621371; }.",
                                    "Integre chamadas no main: exiba contagem e resultado de conversão sem instâncias.",
                                    "Adicione validação de entrada (ex: if km < 0 throw exception).",
                                    "Compare implementação com diagrama UML para consistência.",
                                    "Refatore se necessário para seguir o modelo UML."
                                  ],
                                  "verification": "Método kmParaMilhas() retorna valores precisos (ex: 100km -> 62.1371 milhas) chamado diretamente na classe.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Mesma IDE e compilador do step anterior.",
                                  "tips": "Métodos utilitários devem ser puros: sem side-effects ou estado mutável.",
                                  "learningObjective": "Criar métodos estáticos independentes para utilitários reutilizáveis.",
                                  "commonMistakes": "Usar 'this' ou atributos de instância em método estático; fator de conversão incorreto."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Documentar e Verificar Integração",
                                  "subSteps": [
                                    "Escreva testes unitários para ambos métodos estáticos (ex: JUnit).",
                                    "Documente código com Javadoc destacando uso estático.",
                                    "Execute cenários: múltiplas instâncias, chamadas sem instância, edge cases (km=0, negativo).",
                                    "Compare saída com expectativas do UML.",
                                    "Otimize e commite em repositório Git."
                                  ],
                                  "verification": "Todos testes passam; documentação explica uso sem instâncias; UML reflete código final.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "JUnit ou testes manuais, Git para versionamento.",
                                  "tips": "Teste chamadas estáticas primeiro para isolar problemas.",
                                  "learningObjective": "Garantir robustez e documentação em aplicações práticas de métodos estáticos.",
                                  "commonMistakes": "Não testar chamadas sem instância; documentação genérica sem menção a static."
                                }
                              ],
                              "practicalExample": "Crie uma classe 'Veiculo' com contador estático de instâncias via getTotalVeiculos() e método utilitário static double metrosParaPes(double metros) { return metros * 3.28084; }. No main: crie 5 Veiculo, imprima total e converta 100m para pés sem instanciar.",
                              "finalVerifications": [
                                "Contador reflete exatamente o número de instâncias criadas.",
                                "Métodos utilitários funcionam sem criar objetos da classe.",
                                "Código compila e executa sem erros em múltiplos cenários.",
                                "UML inicial corresponde à implementação final.",
                                "Testes cobrem casos normais e edge cases.",
                                "Documentação explica acessos estáticos corretamente."
                              ],
                              "assessmentCriteria": [
                                "Métodos e atributos estáticos declarados corretamente (static keyword).",
                                "UML preciso, com notação correta para estáticos.",
                                "Implementação funcional e eficiente, sem dependências de instância.",
                                "Testes abrangentes e documentação clara.",
                                "Integração lógica entre contador e utilitário.",
                                "Código limpo, com tratamento de erros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculos de conversão de unidades e precisão numérica.",
                                "Design e Engenharia: Modelagem UML para sistemas colaborativos.",
                                "Gestão de Projetos: Versionamento com Git e testes unitários.",
                                "Física: Aplicações em medidas reais (distâncias, contagens)."
                              ],
                              "realWorldApplication": "Bibliotecas utilitárias como Math.PI (estático em Java), contadores de usuários em apps web (ex: User.getTotalUsers()), conversores em ferramentas de engenharia ou GPS apps."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.3.3",
                            "name": "Debugar erros comuns em métodos estáticos",
                            "description": "Identificar e corrigir erros como tentativa de acesso a 'self' em método estático ou chamada incorreta sem instância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de métodos estáticos",
                                  "subSteps": [
                                    "Estude a definição de método estático: função de classe decorada com @staticmethod que não acessa instância ou classe.",
                                    "Revise diferenças entre métodos de instância (usa self), de classe (@classmethod, usa cls) e estáticos.",
                                    "Analise sintaxe básica em Python: def metodo_statico(): sem self ou cls.",
                                    "Examine exemplos válidos de uso: utilitários como math.sqrt em classes.",
                                    "Identifique restrições: não pode acessar self ou cls diretamente."
                                  ],
                                  "verification": "Explique em suas palavras as diferenças entre os três tipos de métodos e forneça um exemplo simples de @staticmethod.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação Python oficial (staticmethod), editor de código como VS Code ou PyCharm.",
                                  "tips": "Use print statements para visualizar o que self representa em diferentes contextos.",
                                  "learningObjective": "Dominar a teoria por trás de métodos estáticos para identificar violações conceituais.",
                                  "commonMistakes": "Confundir método estático com método de instância, achando que self é opcional."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar erros comuns em código de métodos estáticos",
                                  "subSteps": [
                                    "Procure por uso de 'self' dentro de @staticmethod: erro comum de TypeError.",
                                    "Verifique chamadas incorretas: tentando chamar como método de instância sem criar objeto.",
                                    "Detecte referências a variáveis de instância ou cls sem decorator apropriado.",
                                    "Use linter (ex: pylint) ou IDE para destacar warnings sobre acesso inválido.",
                                    "Anote o tipo de erro: NameError para self indefinido ou AttributeError em chamadas."
                                  ],
                                  "verification": "Em um código com erro plantado, liste todos os erros sem tentar corrigi-los ainda.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor com linter ativado (VS Code com Python extension), exemplos de código buggy salvos.",
                                  "tips": "Comente linhas suspeitas uma a uma para isolar o erro.",
                                  "learningObjective": "Desenvolver habilidade de detecção precisa de padrões de erro em métodos estáticos.",
                                  "commonMistakes": "Ignorar warnings do linter, assumindo que são falsos positivos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Corrigir erros identificados em métodos estáticos",
                                  "subSteps": [
                                    "Remova ou substitua 'self' por parâmetro explícito se necessário, ou mude para método de instância.",
                                    "Ajuste invocações: chame via Classe.metodo() ou instância.metodo(), dependendo do tipo.",
                                    "Refatore para @classmethod se acesso a cls for preciso.",
                                    "Teste correções parciais com execuções incrementais.",
                                    "Documente mudanças com comentários explicando o porquê da correção."
                                  ],
                                  "verification": "Execute o código corrigido e confirme ausência de erros sem mudanças de comportamento esperado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Terminal Python interativo (REPL), debugger como pdb ou IDE debugger.",
                                  "tips": "Use breakpoints no debugger para pausar em linhas com self e inspecionar variáveis.",
                                  "learningObjective": "Aplicar correções precisas mantendo a intenção original do código.",
                                  "commonMistakes": "Corrigir o sintaxe mas quebrar a lógica, como alterar comportamento ao remover self."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar correções de forma abrangente",
                                  "subSteps": [
                                    "Crie testes unitários com unittest ou pytest para cenários com e sem instância.",
                                    "Simule chamadas erradas e valide exceções esperadas no código original.",
                                    "Meça performance se aplicável, garantindo que staticmethod não crie overhead desnecessário.",
                                    "Revise código com peer review simulado ou linter final.",
                                    "Registre lições aprendidas em um log pessoal."
                                  ],
                                  "verification": "Todos os testes passam e código roda em múltiplos cenários (instância e classe).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Biblioteca pytest instalada, framework de testes simples.",
                                  "tips": "Escreva testes primeiro (TDD) para guiar as correções.",
                                  "learningObjective": "Garantir robustez das correções através de validação automatizada.",
                                  "commonMistakes": "Testar só o caso feliz, ignorando edge cases como None ou chamadas inválidas."
                                }
                              ],
                              "practicalExample": "Em uma classe Calculadora: @staticmethod def somar(a, b): return self.a + b  # Erro: self indefinido. Correção: return a + b. Chame como Calculadora.somar(1,2) sem instância.",
                              "finalVerifications": [
                                "Método executa sem instância usando NomeClasse.metodo() sem erros.",
                                "Não há referências a self ou cls dentro do @staticmethod.",
                                "Testes unitários cobrem chamadas via classe e instância (se aplicável).",
                                "Linter não reporta warnings relacionados a métodos estáticos.",
                                "Comportamento permanece idêntico antes/depois da correção.",
                                "Documentação no código explica uso correto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de todos os erros comuns (self, chamadas incorretas).",
                                "Correções minimalistas que preservam lógica original.",
                                "Cobertura de testes >= 80% para cenários de debug.",
                                "Tempo de resolução eficiente sem hacks temporários.",
                                "Explicação clara das causas e soluções.",
                                "Aplicação consistente em múltiplos exemplos."
                              ],
                              "crossCurricularConnections": [
                                "Lógica e resolução de problemas (Matemática: algoritmos).",
                                "Pensamento computacional (abstração e decomposição).",
                                "Literacia digital (uso de ferramentas de debug como IDEs).",
                                "Inglês técnico (leitura de stack traces e docs)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de bibliotecas utilitárias (ex: funções matemáticas em Django utils), APIs REST onde métodos estáticos servem endpoints sem estado, ou scripts de automação onde classes encapsulam ferramentas sem necessidade de instâncias."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.2",
                "name": "Pilares da Programação Orientada a Objetos",
                "description": "Abstração, herança, encapsulamento e polimorfismo como fundamentos essenciais da POO.",
                "totalSkills": 38,
                "atomicTopics": [
                  {
                    "id": "10.1.2.1",
                    "name": "Abstração em POO",
                    "description": "Processo de modelar entidades do mundo real simplificando características essenciais e ocultando detalhes irrelevantes.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.1.1",
                        "name": "Definição e Propósito da Abstração",
                        "description": "Compreensão fundamental do conceito de abstração como processo de modelar entidades do mundo real, destacando características essenciais e ocultando detalhes desnecessários para simplificar o design de software.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.1.1",
                            "name": "Identificar o conceito de abstração",
                            "description": "Reconhecer a abstração como um pilar da POO que permite representar entidades reais de forma simplificada, focando em atributos e comportamentos relevantes, com exemplos como modelar um 'Carro' apenas com cor, modelo e acelerar, ignorando detalhes mecânicos internos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender abstração no cotidiano",
                                  "subSteps": [
                                    "Observe objetos reais ao seu redor, como um carro ou smartphone.",
                                    "Liste atributos essenciais visíveis e comportamentos úteis (ex.: cor, acelerar).",
                                    "Ignore detalhes internos complexos (ex.: motor do carro).",
                                    "Explique por que simplificamos para interagir com o objeto.",
                                    "Registre 3 exemplos pessoais de abstração diária."
                                  ],
                                  "verification": "Lista de 3 exemplos pessoais criados e explicados verbalmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou editor de texto simples.",
                                  "tips": "Pense em como você usa um controle remoto sem saber eletrônica interna.",
                                  "learningObjective": "Reconhecer abstração como simplificação natural de entidades complexas.",
                                  "commonMistakes": "Confundir abstração com simplificação excessiva que remove funcionalidades essenciais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir abstração no contexto de POO",
                                  "subSteps": [
                                    "Leia definição de POO e seus pilares (abstração, encapsulamento, herança, polimorfismo).",
                                    "Destaque que abstração foca em 'o quê' (atributos/comportamentos) vs. 'como' (implementação interna).",
                                    "Compare com abstração cotidiana: carro real vs. modelo conceitual.",
                                    "Anote diferenças entre abstração em POO e nos outros pilares.",
                                    "Crie um diagrama simples de uma entidade abstrata."
                                  ],
                                  "verification": "Diagrama criado e definição reescrita em palavras próprias.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Acesso a documentação básica de POO (ex.: MDN ou tutorial online), papel para diagrama.",
                                  "tips": "Use setas para mostrar 'externo relevante' vs. 'interno oculto'.",
                                  "learningObjective": "Diferenciar abstração em POO de conceitos cotidianos e outros pilares.",
                                  "commonMistakes": "Misturar abstração com encapsulamento (foco em esconder dados vs. simplificar modelo)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar exemplo clássico: Modelar um 'Carro'",
                                  "subSteps": [
                                    "Defina classe Carro com atributos: cor, modelo.",
                                    "Adicione métodos: acelerar(), frear().",
                                    "Discuta o que foi abstraído (ex.: ignora pistões, combustível).",
                                    "Simule uso: carro.acelerar() sem conhecer mecânica.",
                                    "Identifique benefícios: código mais legível e reutilizável."
                                  ],
                                  "verification": "Código pseudocódigo ou esboço de classe Carro com explicação escrita.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código ou papel para pseudocódigo.",
                                  "tips": "Escreva em pseudocódigo para focar no conceito, não sintaxe.",
                                  "learningObjective": "Aplicar conceito de abstração a um exemplo concreto em POO.",
                                  "commonMistakes": "Incluir detalhes internos desnecessários, como simular motor."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar abstração em novos cenários",
                                  "subSteps": [
                                    "Escolha 2 entidades reais (ex.: Conta Bancária, Animal).",
                                    "Liste atributos e comportamentos relevantes.",
                                    "Crie modelos abstratos ignorando complexidades internas.",
                                    "Compare modelos e discuta propósitos semelhantes.",
                                    "Avalie se o modelo captura essência sem sobrecarga."
                                  ],
                                  "verification": "Dois modelos criados com listas de abstrações justificadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel, caneta ou ferramenta de diagramação simples (ex.: Draw.io).",
                                  "tips": "Pergunte: 'O que o usuário precisa saber/usar?'",
                                  "learningObjective": "Generalizar identificação de abstração para entidades diversas.",
                                  "commonMistakes": "Abstrair demais, perdendo funcionalidades chave."
                                }
                              ],
                              "practicalExample": "Modelar uma 'Conta Bancária': atributos (saldo, titular); métodos (depositar(valor), sacar(valor)). Abstrai transações bancárias reais (verificação de fundos, logs, regulamentações), focando apenas no essencial para o usuário.",
                              "finalVerifications": [
                                "Explicar abstração em POO em 1 minuto sem consultar notas.",
                                "Identificar abstração vs. outros pilares em um exemplo dado.",
                                "Criar modelo abstrato para nova entidade em <5 minutos.",
                                "Listar 3 benefícios da abstração em projetos de software.",
                                "Diferenciar modelo abstrato de implementação real em diagrama."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de abstração (foco em relevante vs. irrelevante).",
                                "Qualidade dos exemplos: concretos e relevantes a POO.",
                                "Profundidade dos modelos: equilíbrio entre simplificação e utilidade.",
                                "Capacidade de generalização para novos cenários.",
                                "Clareza na explicação oral/escrita de conceitos.",
                                "Identificação correta de erros comuns em abstrações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos abstratos em funções e equações (ex.: f(x) ignora derivação).",
                                "Biologia: Classificação taxonômica abstrai características essenciais de espécies.",
                                "Física: Modelos newtonianos simplificam forças reais para cálculos.",
                                "Língua Portuguesa: Metáforas e analogias abstraem ideias complexas."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, abstração permite criar APIs como Google Maps (use rota() sem codificar GPS), facilitando apps escaláveis e manutenção em equipes grandes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.2",
                            "name": "Diferenciar abstração de outros pilares da POO",
                            "description": "Comparar abstração com encapsulamento (ocultação de dados), herança (reutilização) e polimorfismo (comportamentos variados), explicando que a abstração foca na simplificação conceitual sem expor implementação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições básicas dos pilares da POO",
                                  "subSteps": [
                                    "Leia e anote a definição de abstração: simplificação conceitual, escondendo detalhes desnecessários.",
                                    "Defina encapsulamento: ocultação de dados e métodos internos, expondo apenas interfaces necessárias.",
                                    "Defina herança: mecanismo de reutilização de código, onde uma classe herda de outra.",
                                    "Defina polimorfismo: capacidade de objetos de diferentes classes responderem ao mesmo método de formas variadas.",
                                    "Compare brevemente em uma tabela: foco principal de cada pilar."
                                  ],
                                  "verification": "Crie uma tabela com definições e confirme com uma fonte confiável como documentação oficial de Java ou Python.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de POO (ex: Oracle Java Tutorials)",
                                    "Bloco de notas ou editor de texto"
                                  ],
                                  "tips": "Use analogias cotidianas, como carro para fixar conceitos.",
                                  "learningObjective": "Compreender os significados fundamentais de cada pilar sem confusões iniciais.",
                                  "commonMistakes": [
                                    "Confundir abstração com implementação completa",
                                    "Achar que encapsulamento é só 'private'"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Comparar abstração versus encapsulamento",
                                  "subSteps": [
                                    "Identifique similaridades: ambos escondem detalhes.",
                                    "Destaque diferenças: abstração foca no 'o quê' (interface conceitual), encapsulamento no 'como proteger dados' (acesso controlado).",
                                    "Crie um diagrama UML simples mostrando uma classe com métodos abstratos vs atributos privados.",
                                    "Escreva um exemplo de código: interface abstrata vs classe com getters/setters privados.",
                                    "Explique verbalmente a diferença para si mesmo."
                                  ],
                                  "verification": "Gere código exemplo e teste se compila, confirmando distinções.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE como IntelliJ ou VS Code",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Pense em abstração como 'menu de restaurante' (o quê pedir), encapsulamento como 'cozinha fechada'.",
                                  "learningObjective": "Diferenciar claramente o foco conceitual da abstração do controle de acesso do encapsulamento.",
                                  "commonMistakes": [
                                    "Equiparar abstração só a classes abstratas",
                                    "Ignorar que encapsulamento não simplifica conceitos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar abstração versus herança",
                                  "subSteps": [
                                    "Note similaridades: ambos lidam com reutilização conceitual.",
                                    "Diferenças chave: abstração simplifica sem hierarquia, herança cria árvore de classes para reutilizar código.",
                                    "Desenhe hierarquia: Animal abstrato vs Mamifero herda de Animal.",
                                    "Escreva código: classe abstrata Animal com método abstract comer() vs subclasse Cachorro extends Animal.",
                                    "Discuta desvantagens: herança pode levar a acoplamento rígido, abstração via interfaces é mais flexível."
                                  ],
                                  "verification": "Implemente e execute código mostrando herança sem abstração forçada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE com suporte a POO",
                                    "Referências online como MDN ou GeeksforGeeks"
                                  ],
                                  "tips": "Abstração é 'modelo genérico', herança é 'família de modelos'.",
                                  "learningObjective": "Entender que abstração não depende de hierarquia, ao contrário da herança.",
                                  "commonMistakes": [
                                    "Pensar abstração como sempre envolvendo herança",
                                    "Confundir polimorfismo com herança"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar abstração versus polimorfismo e sintetizar",
                                  "subSteps": [
                                    "Similaridades: ambos permitem comportamentos flexíveis.",
                                    "Diferenças: polimorfismo é execução variada de métodos (via herança/interfaces), abstração é a definição conceitual simplificada.",
                                    "Exemplo: método dirigir() polimórfico em Carro e Moto, mas abstração no conceito 'Veículo'.",
                                    "Crie um mapa mental conectando todos os pilares.",
                                    "Resuma em 3 frases as diferenças únicas da abstração."
                                  ],
                                  "verification": "Apresente o mapa mental e explique para um colega ou grave áudio.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de mindmap como Draw.io",
                                    "Gravador de voz"
                                  ],
                                  "tips": "Polimorfismo é 'ação diferente', abstração é 'visão simplificada'.",
                                  "learningObjective": "Sintetizar como abstração é o pilar da simplificação conceitual, distinto dos outros.",
                                  "commonMistakes": [
                                    "Achar polimorfismo parte da abstração",
                                    "Misturar todos em 'esconder detalhes'"
                                  ]
                                }
                              ],
                              "practicalExample": "Modelagem de um 'Veículo': Abstração define interface Veiculo com dirigir() sem detalhes do motor; Encapsulamento torna motor private com getter; Herança: Carro extends Veiculo; Polimorfismo: dirigir() em Carro acelera devagar, em Moto rápido. Código Java: public interface Veiculo { void dirigir(); } vs class Carro implements Veiculo { private int motor; public void dirigir() { /* impl */ } }.",
                              "finalVerifications": [
                                "Explicar verbalmente as 3 diferenças principais da abstração sem pausas.",
                                "Criar tabela comparativa precisa com exemplos de código.",
                                "Identificar em código real qual pilar está sendo usado.",
                                "Discutir cenários onde confundir pilares causa erros.",
                                "Aplicar conceitos em um mini-projeto simples sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (sem confusões entre pilares).",
                                "Uso de exemplos concretos e código funcional.",
                                "Clareza nas comparações (foco conceitual vs técnico).",
                                "Capacidade de sintetizar diferenças únicas da abstração.",
                                "Ausência de common mistakes identificados.",
                                "Profundidade nos substeps (mínimo 4 por step)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstrações em funções e modelos algébricos.",
                                "Design Gráfico: Conceitos abstratos em wireframes vs detalhes de UI.",
                                "Física: Modelos teóricos abstratos vs propriedades específicas.",
                                "Língua Portuguesa: Abstrações em metáforas literárias."
                              ],
                              "realWorldApplication": "Em desenvolvimento de APIs como RESTful services (ex: Stripe API), abstração oferece endpoints simples ('pagar()') sem expor lógica interna, enquanto encapsulamento protege dados de pagamento, herança modela tipos de transação e polimorfismo lida com pagamentos variados (cartão/PIX), simplificando integração para apps."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.3",
                            "name": "Reconhecer benefícios da abstração",
                            "description": "Listar vantagens como redução de complexidade, facilidade de manutenção, reutilização de código e foco em alto nível, ilustrando com cenários reais como modelagem de sistemas bancários ou jogos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definição de abstração e listar benefícios teóricos",
                                  "subSteps": [
                                    "Leia a definição de abstração em POO: esconder detalhes complexos e expor apenas o essencial.",
                                    "Liste os principais benefícios: redução de complexidade, facilidade de manutenção, reutilização de código e foco em alto nível.",
                                    "Escreva uma explicação curta para cada benefício em suas próprias palavras.",
                                    "Crie um mapa mental conectando abstração aos benefícios.",
                                    "Pesquise uma fonte confiável (ex: documentação oficial de linguagens POO) para validar a lista."
                                  ],
                                  "verification": "Capacidade de recitar pelo menos 4 benefícios com explicações corretas sem consultar notas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo sobre POO Abstração (ex: MDN ou DevMedia)",
                                    "Papel e caneta ou ferramenta de mindmap como Draw.io",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Use analogias cotidianas, como um controle remoto que abstrai a complexidade interna da TV.",
                                  "learningObjective": "Compreender e memorizar os benefícios fundamentais da abstração.",
                                  "commonMistakes": [
                                    "Confundir abstração com encapsulamento",
                                    "Listar benefícios genéricos sem relação com POO",
                                    "Ignorar o foco em alto nível"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar redução de complexidade e reutilização com exemplos simples",
                                  "subSteps": [
                                    "Escreva um pseudocódigo sem abstração para um sistema de veículos (carro e moto com métodos duplicados).",
                                    "Refatore o código usando uma classe abstrata Veiculo, implementando métodos comuns.",
                                    "Compare os códigos: conte linhas de código e identifique redução de complexidade.",
                                    "Teste reutilização criando novas subclasses sem alterar código existente.",
                                    "Registre métricas: tempo de desenvolvimento e linhas salvas."
                                  ],
                                  "verification": "Código refatorado roda sem erros e demonstra reutilização com pelo menos 2 subclasses.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de código online (ex: Replit ou CodePen)",
                                    "Pseudocódigo de exemplo de veículos"
                                  ],
                                  "tips": "Comece pequeno: foque em 2-3 métodos comuns para evitar sobrecarga.",
                                  "learningObjective": "Aplicar abstração para demonstrar redução de complexidade e reutilização.",
                                  "commonMistakes": [
                                    "Duplicar código nas subclasses",
                                    "Expor detalhes internos desnecessários",
                                    "Não testar novas implementações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar manutenção e foco em alto nível em cenários reais",
                                  "subSteps": [
                                    "Escolha um cenário real: modelagem de sistema bancário (Conta abstrata para Corrente e Poupança).",
                                    "Desenhe diagrama de classes mostrando herança e métodos abstratos.",
                                    "Simule uma mudança: adicione taxa de juros e veja facilidade de manutenção.",
                                    "Discuta foco em alto nível: desenvolvedor trabalha com 'conta.depositar()' sem saber implementação.",
                                    "Compare com código procedural: destaque problemas de manutenção."
                                  ],
                                  "verification": "Diagrama completo e explicação verbal de como abstração facilita mudanças.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama (ex: Lucidchart ou papel)",
                                    "Exemplo de código bancário em pseudocódigo"
                                  ],
                                  "tips": "Pense em escalabilidade: como adicionar ContaInvestimento sem quebrar o sistema.",
                                  "learningObjective": "Reconhecer impactos em manutenção e abstração de alto nível via cenários práticos.",
                                  "commonMistakes": [
                                    "Focar só em código, ignorar diagramas",
                                    "Não simular mudanças reais",
                                    "Subestimar benefícios em grandes sistemas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar benefícios e criar resumo pessoal",
                                  "subSteps": [
                                    "Revise todos os benefícios com exemplos do passo anterior.",
                                    "Crie uma tabela comparativa: com vs. sem abstração (complexidade, manutenção, etc.).",
                                    "Escreva um parágrafo resumindo por que abstração é essencial em POO.",
                                    "Autoavalie: responda 5 perguntas sobre benefícios em cenários variados.",
                                    "Compartilhe resumo em fórum ou com par (opcional) para feedback."
                                  ],
                                  "verification": "Tabela e resumo completos, respondendo corretamente a perguntas de autoavaliação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha (Google Sheets ou papel)",
                                    "Lista de perguntas de verificação"
                                  ],
                                  "tips": "Use bullet points para clareza no resumo; revise com olhos frescos após pausa.",
                                  "learningObjective": "Integrar e internalizar todos os benefícios da abstração.",
                                  "commonMistakes": [
                                    "Resumo superficial sem exemplos",
                                    "Esquecer um benefício chave",
                                    "Não comparar quantitativamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um jogo de corrida, crie uma classe abstrata Veiculo com métodos abstratos como acelerar() e frear(). Subclasses Carro e Moto implementam detalhes específicos, reduzindo código duplicado de 200 para 80 linhas, facilitando adição de Avião sem reescrever lógica comum.",
                              "finalVerifications": [
                                "Lista e explica corretamente pelo menos 4 benefícios da abstração.",
                                "Fornece exemplo real ilustrando redução de complexidade.",
                                "Demonstra reutilização criando subclass sem alterar código base.",
                                "Compara cenários com e sem abstração em termos de manutenção.",
                                "Explica foco em alto nível com analogia prática.",
                                "Cria diagrama ou código funcional de exemplo bancário."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na lista de benefícios (peso 25%).",
                                "Qualidade e relevância dos exemplos práticos (peso 25%).",
                                "Demonstração clara de comparações com/sem abstração (peso 20%).",
                                "Profundidade nas explicações de manutenção e reutilização (peso 15%).",
                                "Criatividade em analogias e cenários reais (peso 10%).",
                                "Clareza e organização do resumo final (peso 5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstração em funções e modelos algébricos.",
                                "Design/Arte: Conceitos de abstração em design gráfico e UI/UX.",
                                "Negócios: Modelagem de processos empresariais em BPMN.",
                                "Física: Modelos abstratos de sistemas (ex: partículas como classes).",
                                "Linguagem: Abstração em metáforas e figuras de linguagem."
                              ],
                              "realWorldApplication": "Em sistemas bancários como o do Banco do Brasil, abstração permite modelar Conta como classe base para tipos variados, facilitando atualizações regulatórias (ex: novas taxas) em um codebase de milhões de linhas sem downtime, economizando milhões em manutenção anual."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.2",
                        "name": "Abstração através de Classes e Objetos",
                        "description": "Mecanismo prático de implementar abstração utilizando classes para encapsular dados e métodos, criando instâncias que representam entidades abstratas do mundo real.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.2.1",
                            "name": "Criar uma classe que modele uma entidade real",
                            "description": "Desenvolver uma classe em Python ou C++ que abstraia uma entidade como 'ContaBancaria', definindo atributos essenciais (saldo, titular) e métodos (depositar, sacar), ocultando lógica interna de validação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejar a entidade e identificar atributos e métodos essenciais",
                                  "subSteps": [
                                    "Escolha uma entidade real simples, como 'ContaBancaria', e liste 2-4 atributos principais (ex: titular, saldo).",
                                    "Defina 3-5 métodos necessários (ex: depositar, sacar, consultar_saldo), considerando ações reais da entidade.",
                                    "Esboce um diagrama simples (UML-like) no papel ou editor de texto para visualizar a estrutura da classe.",
                                    "Identifique regras de negócio ocultas, como saldo não negativo ou saques limitados ao saldo disponível.",
                                    "Documente o propósito da classe em uma frase clara."
                                  ],
                                  "verification": "Verifique se há um esboço escrito ou diagrama com atributos, métodos e regras listados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel/caneta ou editor de texto simples (Notepad, VS Code)",
                                  "tips": "Comece com entidades familiares do dia a dia para facilitar a abstração.",
                                  "learningObjective": "Compreender como mapear uma entidade real para componentes de uma classe POO.",
                                  "commonMistakes": "Listar atributos irrelevantes ou esquecer métodos de consulta/acesso."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a estrutura básica da classe e o construtor",
                                  "subSteps": [
                                    "Crie o esqueleto da classe em Python: 'class NomeClasse:' com indentação correta.",
                                    "Adicione o método __init__ com parâmetros para inicializar atributos (ex: self.titular = titular, self.__saldo = 0).",
                                    "Use convenções de nomenclatura: snake_case para Python, atributos privados com __prefixo.",
                                    "Adicione um atributo privado para saldo para simular encapsulamento.",
                                    "Teste a criação de uma instância básica sem erros."
                                  ],
                                  "verification": "Execute código para criar uma instância e imprimir atributos via print(obj.__dict__ ou getters).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código (VS Code, PyCharm), interpretador Python",
                                  "tips": "Sempre use 'self' para referenciar atributos de instância.",
                                  "learningObjective": "Implementar o construtor para inicializar objetos com estado inicial correto.",
                                  "commonMistakes": "Esquecer 'self' nos parâmetros ou atributos, ou não inicializar atributos privados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar métodos de manipulação com lógica interna oculta",
                                  "subSteps": [
                                    "Crie método depositar(valor): valide se valor > 0, adicione ao saldo privado, retorne confirmação.",
                                    "Crie método sacar(valor): verifique saldo suficiente e valor > 0, subtraia saldo, retorne sucesso/falha.",
                                    "Adicione método get_saldo() para acessar saldo sem expor o atributo diretamente.",
                                    "Oculte toda validação dentro dos métodos, expondo apenas interface simples.",
                                    "Adicione docstrings aos métodos explicando parâmetros e retornos."
                                  ],
                                  "verification": "Chame métodos em uma instância e confirme saldos atualizados corretamente via get_saldo().",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código, Python REPL para testes rápidos",
                                  "tips": "Use if/else para validações e raise ValueError para entradas inválidas.",
                                  "learningObjective": "Aplicar abstração ocultando detalhes de implementação nos métodos.",
                                  "commonMistakes": "Permitir saldo negativo sem validação ou expor atributos diretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar a classe completa",
                                  "subSteps": [
                                    "Crie 3-5 cenários de teste: depósito válido, saque inválido, múltiplas operações.",
                                    "Execute testes em um script separado, imprimindo estados antes/depois.",
                                    "Verifique exceções para entradas inválidas (ex: saque > saldo).",
                                    "Refatore código para melhor legibilidade se necessário (ex: constantes para limites).",
                                    "Compare com diagrama inicial para garantir fidelidade à modelagem."
                                  ],
                                  "verification": "Todos testes passam sem erros e comportamentos esperados são observados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código, script de teste Python",
                                  "tips": "Use assert statements para automação básica de testes.",
                                  "learningObjective": "Garantir robustez da classe através de testes abrangentes.",
                                  "commonMistakes": "Testar apenas casos felizes, ignorando bordas como valores zero ou negativos."
                                }
                              ],
                              "practicalExample": "```python\nclass ContaBancaria:\n    def __init__(self, titular, saldo_inicial=0):\n        self.titular = titular\n        self.__saldo = saldo_inicial\n\n    def depositar(self, valor):\n        if valor > 0:\n            self.__saldo += valor\n            return f'Depositado R${valor}. Novo saldo: R${self.__saldo}'\n        raise ValueError('Valor deve ser positivo')\n\n    def sacar(self, valor):\n        if valor > 0 and valor <= self.__saldo:\n            self.__saldo -= valor\n            return f'Sacado R${valor}. Novo saldo: R${self.__saldo}'\n        raise ValueError('Saque inválido')\n\n    def get_saldo(self):\n        return self.__saldo\n\n# Teste\nconta = ContaBancaria('João')\nprint(conta.depositar(100))\nprint(conta.sacar(50))\nprint(conta.get_saldo())\n``` Saída esperada: Depositado R$100..., Sacado R$50..., 50",
                              "finalVerifications": [
                                "Instância da classe é criada sem erros com atributos inicializados corretamente.",
                                "Métodos depositar e sacar alteram saldo apenas com validações passando.",
                                "Tentativas inválidas levantam exceções apropriadas.",
                                "Atributos privados não são acessíveis diretamente de fora da classe.",
                                "Múltiplas operações sequenciais mantêm estado consistente.",
                                "Docstrings e comentários explicam o código claramente."
                              ],
                              "assessmentCriteria": [
                                "Planejamento completo com atributos e métodos mapeados (20%)",
                                "Construtor e atributos implementados corretamente com encapsulamento (25%)",
                                "Métodos com lógica de validação oculta e interface limpa (30%)",
                                "Testes abrangentes cobrindo casos normais e de erro (15%)",
                                "Código limpo, legível com docstrings (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações aritméticas seguras e validações numéricas.",
                                "Lógica e Algoritmos: Estruturas condicionais para regras de negócio.",
                                "Design de Sistemas: Modelagem UML básica para software.",
                                "Ética em TI: Validações para prevenir fraudes em modelagens financeiras."
                              ],
                              "realWorldApplication": "Modelar entidades como ContaBancaria é fundamental em sistemas bancários (ex: apps como Nubank), ERPs empresariais ou jogos (ex: inventário de personagem), permitindo abstrair complexidades reais em código reutilizável e seguro."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.1.2.2",
                            "name": "Instanciar objetos a partir de classes abstratas",
                            "description": "Criar instâncias de classes para representar múltiplas entidades concretas, demonstrando como objetos herdam a abstração da classe, com exemplos de múltiplas contas bancárias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de classes abstratas e herança",
                                  "subSteps": [
                                    "Leia a definição de classe abstrata: uma classe que não pode ser instanciada diretamente e serve como blueprint para subclasses concretas.",
                                    "Estude exemplos de herança em POO, focando em como subclasses herdam métodos e atributos abstratos.",
                                    "Identifique métodos abstratos que devem ser implementados nas subclasses.",
                                    "Revise sintaxe básica de declaração de classe abstrata em Java (ex: 'abstract class').",
                                    "Anote diferenças entre classes abstratas e interfaces."
                                  ],
                                  "verification": "Explique em suas palavras o que é uma classe abstrata e dê um exemplo simples sem código.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Java sobre classes abstratas",
                                    "Editor de texto ou IDE como IntelliJ ou VS Code"
                                  ],
                                  "tips": "Use diagramas UML para visualizar a hierarquia de classes antes de codificar.",
                                  "learningObjective": "Entender o papel das classes abstratas na abstração e herança.",
                                  "commonMistakes": [
                                    "Confundir classes abstratas com classes concretas instanciáveis",
                                    "Esquecer o modificador 'abstract'"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir uma classe abstrata para representar entidades comuns",
                                  "subSteps": [
                                    "Crie uma classe abstrata chamada 'ContaBancaria' com atributos como numeroConta, saldo e titular.",
                                    "Adicione um método abstrato 'calcularTaxa()' que será implementado nas subclasses.",
                                    "Inclua métodos concretos como 'depositar(double valor)' e 'getSaldo()'.",
                                    "Declare a classe como 'abstract' e torne o construtor protegido.",
                                    "Teste compilação para garantir que não é instanciável."
                                  ],
                                  "verification": "Tente instanciar ContaBancaria diretamente; deve dar erro de compilação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE Java (Eclipse ou IntelliJ)",
                                    "Compilador Java instalado"
                                  ],
                                  "tips": "Comece com atributos privados e getters/setters para encapsulamento.",
                                  "learningObjective": "Criar uma classe abstrata que defina comportamento comum para subclasses.",
                                  "commonMistakes": [
                                    "Tentar instanciar a classe abstrata",
                                    "Esquecer de declarar métodos abstratos como 'abstract'"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar subclasses concretas que estendem a classe abstrata",
                                  "subSteps": [
                                    "Crie classe 'ContaCorrente' que extends ContaBancaria e implemente calcularTaxa() retornando 0.10 * saldo.",
                                    "Crie classe 'ContaPoupanca' que extends ContaBancaria e implemente calcularTaxa() retornando 0.05 * saldo.",
                                    "Adicione construtores em cada subclasse chamando super() com numeroConta, saldo e titular.",
                                    "Implemente método 'sacar(double valor)' em cada, considerando a taxa.",
                                    "Compile e verifique herança de métodos da superclasse."
                                  ],
                                  "verification": "Chame métodos herdados nas subclasses sem erros.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "IDE Java",
                                    "Exemplos de código de herança"
                                  ],
                                  "tips": "Use '@Override' para métodos sobrescritos para evitar erros de digitação.",
                                  "learningObjective": "Implementar lógica específica em subclasses concretas.",
                                  "commonMistakes": [
                                    "Não chamar super() no construtor",
                                    "Implementar calcularTaxa() incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Instanciar múltiplos objetos e demonstrar herança",
                                  "subSteps": [
                                    "No método main, crie pelo menos duas instâncias: ContaCorrente cc1 = new ContaCorrente('123', 1000, 'João');",
                                    "Crie ContaPoupanca cp1 = new ContaPoupanca('456', 2000, 'Maria');",
                                    "Demonstre herança: chame depositar(), getSaldo() e calcularTaxa() em cada objeto.",
                                    "Crie uma lista ou array de ContaBancaria e adicione as instâncias (polimorfismo).",
                                    "Imprima saldos e taxas para verificar comportamento diferente."
                                  ],
                                  "verification": "Execute o programa e confirme que objetos herdam abstração e exibem comportamentos corretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE Java com main class",
                                    "Terminal para execução"
                                  ],
                                  "tips": "Use System.out.println para depuração rápida.",
                                  "learningObjective": "Instanciar objetos de subclasses e usar polimorfismo.",
                                  "commonMistakes": [
                                    "Instanciar a classe abstrata diretamente",
                                    "Erros de tipo em arrays polimórficos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema bancário Java: abstract class ContaBancaria { ... abstract double calcularTaxa(); } class ContaCorrente extends ContaBancaria { ... } No main: ContaCorrente cc = new ContaCorrente('001', 1000, 'Ana'); cc.depositar(500); System.out.println('Taxa: ' + cc.calcularTaxa()); // 0.10 * 1500 = 150",
                              "finalVerifications": [
                                "Código compila sem erros de instância de classe abstrata.",
                                "Objetos instanciados herdam e executam métodos da superclasse.",
                                "Métodos abstratos são implementados corretamente nas subclasses.",
                                "Polimorfismo funciona: objetos em array de tipo superclasse.",
                                "Comportamentos específicos (taxas diferentes) são demonstrados.",
                                "Múltiplas instâncias representam entidades concretas distintas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e uso de classe abstrata (sem instâncias diretas).",
                                "Implementação completa de métodos abstratos com lógica correta.",
                                "Demonstração de herança via chamadas de métodos herdados.",
                                "Criação de pelo menos duas instâncias com dados variados.",
                                "Uso efetivo de polimorfismo em coleções.",
                                "Código limpo, com encapsulamento e comentários."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculos de taxas e saldos (aritmética financeira).",
                                "Administração: Modelagem de entidades de negócios como contas.",
                                "Lógica Computacional: Estruturas condicionais em métodos de saque.",
                                "Design de Sistemas: Princípios de modelagem UML e abstração."
                              ],
                              "realWorldApplication": "Em aplicativos bancários como apps de mobile banking, classes abstratas modelam 'Conta' genérica, permitindo instanciar Corrente, Poupança ou Investimento, facilitando manutenção e escalabilidade em sistemas que gerenciam milhões de contas reais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.1.2.3",
                            "name": "Aplicar abstração em estruturas de dados orientadas a objetos",
                            "description": "Utilizar classes para abstrair coleções como listas ou árvores, simplificando operações complexas em métodos de alto nível, compatível com tipos genéricos em linguagens como Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de abstração em estruturas de dados",
                                  "subSteps": [
                                    "Estudar a definição de abstração em POO e seu papel em esconder complexidades",
                                    "Revisar estruturas de dados básicas como listas, pilhas e árvores",
                                    "Identificar operações complexas (ex: busca em árvore binária)",
                                    "Analisar exemplos nativos em Python (list, dict)",
                                    "Mapear como classes podem simplificar essas operações"
                                  ],
                                  "verification": "Escrever um resumo de 200 palavras explicando abstração com exemplos de listas e árvores",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação oficial Python (collections module)",
                                    "Tutorial sobre POO em Python (Real Python)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use diagramas UML simples para visualizar abstrações",
                                  "learningObjective": "Dominar o conceito de abstração e sua aplicação em estruturas de dados",
                                  "commonMistakes": [
                                    "Confundir abstração com herança",
                                    "Ignorar o foco em interfaces de alto nível"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar a classe abstrata para uma estrutura de dados",
                                  "subSteps": [
                                    "Escolher uma estrutura (ex: Lista Genérica ou Árvore Binária)",
                                    "Definir atributos privados para encapsular dados",
                                    "Especificar métodos de alto nível (add, remove, search)",
                                    "Desenhar diagrama de classe com genéricos em mente",
                                    "Validar design com casos de uso simples"
                                  ],
                                  "verification": "Criar um diagrama UML da classe e revisar com um colega ou ferramenta online",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramenta UML como draw.io",
                                    "Editor de código (VS Code com Python extension)",
                                    "Exemplos de código de bibliotecas como typing"
                                  ],
                                  "tips": "Priorize métodos intuitivos que o usuário final usaria sem conhecer implementação interna",
                                  "learningObjective": "Capacitar o design de classes que abstraem complexidades de estruturas",
                                  "commonMistakes": [
                                    "Expor atributos internos",
                                    "Definir métodos muito granulares"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a classe com métodos de alto nível e genéricos",
                                  "subSteps": [
                                    "Criar a classe base com type hints (from typing import Generic, TypeVar)",
                                    "Implementar métodos principais (ex: append, pop para lista)",
                                    "Adicionar suporte a genéricos (T = TypeVar('T'))",
                                    "Testar implementação com dados de diferentes tipos",
                                    "Refatorar para otimizar performance básica"
                                  ],
                                  "verification": "Executar testes unitários com pytest para 5 operações chave",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python 3.9+",
                                    "Biblioteca typing e dataclasses",
                                    "pytest para testes"
                                  ],
                                  "tips": "Use list interna para lista, recursão controlada para árvores",
                                  "learningObjective": "Implementar abstração funcional com suporte a tipos genéricos",
                                  "commonMistakes": [
                                    "Esquecer type hints",
                                    "Implementações ineficientes sem lazy loading"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, verificar e refinar a abstração",
                                  "subSteps": [
                                    "Criar cenários de teste edge-case (lista vazia, overflow)",
                                    "Usar mypy para checar tipos genéricos",
                                    "Comparar com implementações nativas (tempo e legibilidade)",
                                    "Refinar métodos baseados em feedback",
                                    "Documentar a classe com docstrings"
                                  ],
                                  "verification": "Relatório de testes mostrando 100% coverage e aprovação no type checker",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "mypy tool",
                                    "pytest-cov para coverage",
                                    "Jupyter Notebook para demos"
                                  ],
                                  "tips": "Meça legibilidade: código cliente deve ser <10 linhas para operações complexas",
                                  "learningObjective": "Garantir robustez e usabilidade da abstração implementada",
                                  "commonMistakes": [
                                    "Testes insuficientes para genéricos",
                                    "Ignorar exceções"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe GenericStack[T] em Python: class GenericStack(Generic[T]): def __init__(self): self._items: list[T] = [] def push(self, item: T) -> None: self._items.append(item) def pop(self) -> T: return self._items.pop() ... Use como stack = GenericStack[int](); stack.push(42) para abstrair pilha de inteiros sem expor lista interna.",
                              "finalVerifications": [
                                "Código passa mypy sem erros de tipo",
                                "Testes unitários cobrem 90%+ com cenários genéricos",
                                "Operações de alto nível funcionam intuitivamente para tipos diferentes",
                                "Desempenho comparável a nativo (benchmark simples)",
                                "Documentação clara permite uso sem ler código interno",
                                "Refatoração remove dependências de implementação baixa-nível"
                              ],
                              "assessmentCriteria": [
                                "Precisão na abstração: métodos escondem detalhes internos (90%)",
                                "Suporte a genéricos: type-safe em múltiplos tipos (100%)",
                                "Legibilidade: API simples e intuitiva",
                                "Robustez: gerencia erros e edge-cases",
                                "Eficiência: O(1) para operações chave onde aplicável",
                                "Documentação: docstrings completas e exemplos"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstrações em grafos e árvores (teoria dos conjuntos)",
                                "Design de Software: Padrões como Abstract Data Type (ADT)",
                                "Banco de Dados: Abstrações em ORMs como SQLAlchemy models",
                                "Algoritmos: Simplificação de complexidade Big-O via métodos de alto nível"
                              ],
                              "realWorldApplication": "Em bibliotecas como pandas (DataFrame abstrai arrays multidim), Django ORM (QuerySet abstrai SQL queries) ou NumPy (arrays genéricos), permitindo desenvolvedores focarem em lógica de negócio sem gerenciar memória ou traversals manuais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.3",
                        "name": "Abstração Avançada com Interfaces e UML",
                        "description": "Técnicas avançadas de abstração usando interfaces, classes abstratas e modelagem UML para definir contratos de comportamento sem implementação específica.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.3.1",
                            "name": "Definir interfaces para abstração de comportamento",
                            "description": "Criar interfaces em Python (usando ABC) ou C++ que especifiquem métodos essenciais sem implementação, como uma interface 'Veiculo' com 'acelerar()', permitindo polimorfismo futuro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Interfaces e Abstração",
                                  "subSteps": [
                                    "Estude a definição de interface como um contrato que especifica métodos sem implementação, promovendo abstração e polimorfismo.",
                                    "Compare interfaces com classes abstratas: interfaces não têm estado ou implementação, apenas assinaturas.",
                                    "Analise exemplos reais, como interfaces em bibliotecas padrão Python (ex: Iterable).",
                                    "Identifique pilares da POO relacionados: abstração oculta detalhes, interfaces forçam conformidade.",
                                    "Desenhe um diagrama UML simples de uma interface Veiculo com método acelerar()."
                                  ],
                                  "verification": "Escreva um parágrafo explicando em suas palavras o que é uma interface e sua diferença de uma classe concreta; compartilhe com um par para feedback.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial Python abc module",
                                    "Ferramenta de desenho UML online (ex: draw.io)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Pense em interfaces como 'promessas' que classes concretas devem cumprir para serem usadas polimorficamente.",
                                  "learningObjective": "Dominar o conceito teórico de interfaces como ferramenta de abstração comportamental em POO.",
                                  "commonMistakes": "Confundir interfaces com herança de implementação; interfaces nunca implementam lógica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar uma Interface em Python Usando o Módulo ABC",
                                  "subSteps": [
                                    "Importe o módulo abc: from abc import ABC, abstractmethod.",
                                    "Defina uma classe base herdando de ABC: class Veiculo(ABC):",
                                    "Adicione decorador @abstractmethod a métodos essenciais: @abstractmethod def acelerar(self): pass",
                                    "Adicione múltiplos métodos abstratos, como frear() e parar(), sem corpo.",
                                    "Teste tentativa de instanciação para confirmar erro (TypeError)."
                                  ],
                                  "verification": "Execute o código da interface; confirme que não pode ser instanciada e que subclasses sem implementação falham.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE Python (ex: PyCharm ou VS Code)",
                                    "Console Python interativo",
                                    "Documentação abc: https://docs.python.org/3/library/abc.html"
                                  ],
                                  "tips": "Sempre use ABC como superclasse e @abstractmethod para forçar implementação nas subclasses.",
                                  "learningObjective": "Implementar sintaxe correta de interfaces em Python para abstrair comportamentos.",
                                  "commonMistakes": "Esquecer de herdar de ABC ou usar @abstractmethod, resultando em classe instanciável."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Interface Equivalente em C++ e Comparar Abordagens",
                                  "subSteps": [
                                    "Declare uma classe abstrata em C++: class Veiculo { public: virtual void acelerar() = 0; virtual ~Veiculo() {} };",
                                    "Use virtual puro (=0) para métodos abstratos e inclua destructor virtual.",
                                    "Compile e teste: tentativa de instanciar Veiculo deve falhar.",
                                    "Compare com Python: discuta pure virtual vs ABC, e gerenciamento de memória.",
                                    "Crie um arquivo header (.h) e teste em main.cpp com subclasses."
                                  ],
                                  "verification": "Compile código C++ sem erros; confirme que objeto Veiculo não pode ser criado (erro de linker).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Compilador C++ (g++ ou IDE como Code::Blocks)",
                                    "Documentação C++ virtual functions",
                                    "Editor de texto"
                                  ],
                                  "tips": "Destructor virtual é crucial em C++ para polimorfismo correto; Python gerencia isso automaticamente.",
                                  "learningObjective": "Entender implementação de interfaces em C++ e contrastar com Python para flexibilidade multiplataforma.",
                                  "commonMistakes": "Esquecer destructor virtual em C++, levando a comportamento indefinido em deleções polimórficas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Interface em Exemplo Prático com Polimorfismo",
                                  "subSteps": [
                                    "Crie subclasses concretas: class Carro(Veiculo): def acelerar(self): print('Carro acelerando')",
                                    "Implemente todas as abstrações nas subclasses (Carro e Moto).",
                                    "Use lista polimórfica: veiculos = [Carro(), Moto()]; for v in veiculos: v.acelerar()",
                                    "Teste exceções: tente usar subclass incompleta para ver TypeError.",
                                    "Refatore para adicionar novo método na interface e atualize subclasses."
                                  ],
                                  "verification": "Execute código polimórfico; observe saídas corretas sem erros de implementação faltante.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE com suporte Python/C++",
                                    "Terminal para execução",
                                    "Exemplo código base fornecido"
                                  ],
                                  "tips": "Mantenha interfaces 'pequenas e focadas' (3-5 métodos) para facilitar manutenção.",
                                  "learningObjective": "Demonstrar uso prático de interfaces para habilitar polimorfismo e extensibilidade.",
                                  "commonMistakes": "Implementar lógica na interface em vez de pass; quebrar o contrato de abstração."
                                }
                              ],
                              "practicalExample": "Em Python:\nfrom abc import ABC, abstractmethod\n\nclass Veiculo(ABC):\n    @abstractmethod\n    def acelerar(self):\n        pass\n\nclass Carro(Veiculo):\n    def acelerar(self):\n        print('Carro: Vrum vrum!')\n\nclass Moto(Veiculo):\n    def acelerar(self):\n        print('Moto: Zuum!')\n\n# Uso polimórfico\nveiculos = [Carro(), Moto()]\nfor v in veiculos:\n    v.acelerar()  # Saída: Carro: Vrum vrum! Moto: Zuum!",
                              "finalVerifications": [
                                "Interface não pode ser instanciada diretamente (TypeError em Python; erro de compilação em C++).",
                                "Subclasses sem implementação completa de métodos abstratos falham na instanciação.",
                                "Código polimórfico executa corretamente com diferentes subclasses.",
                                "Adição de novo método abstrato força atualização em todas as subclasses.",
                                "Diagrama UML reflete corretamente a hierarquia interface-subclasses.",
                                "Código em C++ compila e executa polimorfismo via ponteiros.",
                                "Nenhuma implementação de lógica nos métodos da interface."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe precisa de ABC e @abstractmethod em Python (sem erros).",
                                "Uso correto de virtual puro em C++ com destructor virtual.",
                                "Exemplo prático demonstra polimorfismo funcional.",
                                "Substeps detalhados e verificações por step implementados.",
                                "Identificação precisa de erros comuns evitados.",
                                "Conexão clara com abstração comportamental no contexto POO."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstração similar a funções/interfaces em álgebra abstrata.",
                                "Design de Software: Modelagem UML para interfaces em diagramas de classe.",
                                "Engenharia de Software: Contratos em Design by Contract (DbC).",
                                "Lógica: Proposições como contratos booleanos (deve implementar ou falhar)."
                              ],
                              "realWorldApplication": "Frameworks como Django usam interfaces semelhantes para models personalizados; em games (Unity/Unreal), entidades como 'Personagem' com interface 'Mover()' permitem polimorfismo entre heróis e inimigos; APIs REST definem contratos de endpoints sem implementação específica."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.1.3.2",
                            "name": "Modelar abstração utilizando diagramas UML",
                            "description": "Desenhar diagramas de classes UML para representar abstrações, incluindo classes abstratas, interfaces e relacionamentos, conforme Larman (2006), para visualizar entidades simplificadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de abstração em diagramas UML",
                                  "subSteps": [
                                    "Estude a notação UML para classes abstratas (nome em itálico), interfaces (<<interface>>) e relacionamentos (herança com seta triangular, realização com seta tracejada).",
                                    "Leia trechos relevantes de Larman (2006) sobre abstração em modelagem de objetos.",
                                    "Identifique diferenças entre classes concretas, abstratas e interfaces.",
                                    "Pratique esboçando símbolos UML básicos em papel.",
                                    "Anote exemplos de abstração em contextos reais, como 'Animal' abstrato."
                                  ],
                                  "verification": "Crie um glossário pessoal com 5 termos chave (classe abstrata, interface, herança, realização, composição) e suas notações UML corretas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Applying UML and Patterns' de Larman (2006)",
                                    "Papel e caneta",
                                    "Recursos online UML (ex: uml-diagrams.org)"
                                  ],
                                  "tips": "Use diagramas de referência UML para copiar notações com precisão; foque em abstração como simplificação de entidades complexas.",
                                  "learningObjective": "Compreender notações UML específicas para modelar abstrações conforme Larman.",
                                  "commonMistakes": [
                                    "Confundir herança com composição",
                                    "Esquecer itálico em classes abstratas",
                                    "Ignorar multiplicidades em relacionamentos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar domínio do problema para identificar entidades abstratas",
                                  "subSteps": [
                                    "Descreva o problema em linguagem natural e extraia substantivos como potenciais classes.",
                                    "Classifique entidades: concretas (ex: Carro), abstratas (ex: Veículo) ou interfaces (ex: Movimentável).",
                                    "Defina responsabilidades de cada entidade usando CRC cards (Class-Responsibility-Collaboration).",
                                    "Priorize abstrações que simplifiquem o modelo, evitando detalhes de implementação.",
                                    "Valide com perguntas: 'Essa classe pode ser instanciada?' ou 'É um contrato comum?'"
                                  ],
                                  "verification": "Produza uma lista de 5-8 entidades com classificação (concreta/abstrata/interface) e justificativa breve.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel para CRC cards",
                                    "Descrição do problema exemplo",
                                    "Ferramenta digital como Miro ou papel"
                                  ],
                                  "tips": "Pense em hierarquias: gerais no topo (abstratas), específicas no fundo (concretas).",
                                  "learningObjective": "Identificar e classificar entidades abstratas no domínio problemático.",
                                  "commonMistakes": [
                                    "Sobrecarregar classes com muitas responsabilidades",
                                    "Criar classes concretas para conceitos gerais",
                                    "Ignorar interfaces para comportamentos compartilhados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenhar classes, interfaces e classes abstratas no diagrama",
                                  "subSteps": [
                                    "Desenhe caixas para cada classe: nome, atributos (visibilidade + tipo), métodos (visibilidade + assinatura).",
                                    "Marque classes abstratas em itálico e métodos abstratos sublinhados.",
                                    "Crie interfaces com <<interface>> e operações puras virtuais.",
                                    "Posicione classes logicamente: abstratas no topo.",
                                    "Adicione estereótipos se aplicável (ex: <<entity>>)."
                                  ],
                                  "verification": "Gere um diagrama parcial com pelo menos 3 classes (1 abstrata, 1 interface, 1 concreta) sem erros de notação.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Software UML: PlantUML, Lucidchart ou Draw.io",
                                    "Papel para rascunho"
                                  ],
                                  "tips": "Mantenha diagramas limpos: use linhas retas e espaçamento uniforme.",
                                  "learningObjective": "Construir representação visual precisa de abstrações UML.",
                                  "commonMistakes": [
                                    "Incluir implementação em interfaces",
                                    "Esquecer visibilidade em atributos/métodos",
                                    "Misturar atributos de estado com comportamento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir e adicionar relacionamentos entre entidades",
                                  "subSteps": [
                                    "Identifique herança: seta triangular de subclasse para superclasse abstrata.",
                                    "Adicione realização: seta tracejada para interfaces.",
                                    "Inclua associações (linhas simples), agregação (diamante vazio), composição (diamante cheio).",
                                    "Especifique multiplicidades (ex: 1..*, 0..1) e nomes de papéis.",
                                    "Verifique ciclos ou relacionamentos desnecessários."
                                  ],
                                  "verification": "Complete o diagrama com 4+ relacionamentos corretos e multiplicidades.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Mesma ferramenta UML do step 3",
                                    "Referência de relacionamentos UML"
                                  ],
                                  "tips": "Pergunte: 'Essa relação é essencial para a abstração?' para evitar poluição.",
                                  "learningObjective": "Modelar interações entre abstrações usando notações UML padrão.",
                                  "commonMistakes": [
                                    "Usar seta errada (cheia vs tracejada)",
                                    "Esquecer multiplicidades",
                                    "Criar herança quando associação basta"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Refinar, validar e documentar o diagrama",
                                  "subSteps": [
                                    "Revise o diagrama contra regras de Larman: coesão alta, acoplamento baixo.",
                                    "Teste cenários: 'Pode instanciar classes abstratas?' ou 'Interfaces são implementadas?'.",
                                    "Adicione notas explicativas e legendas.",
                                    "Compare com exemplos de Larman (2006).",
                                    "Exporte ou imprima para revisão."
                                  ],
                                  "verification": "Produza relatório de 1 página validando o diagrama com 3+ cenários de teste.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramenta UML",
                                    "Checklist de validação UML"
                                  ],
                                  "tips": "Use ferramentas de validação automática se disponíveis (ex: PlantUML checks).",
                                  "learningObjective": "Garantir qualidade e usabilidade do modelo UML de abstração.",
                                  "commonMistakes": [
                                    "Ignorar validação de consistência",
                                    "Sobrecarregar diagrama com detalhes excessivos",
                                    "Não documentar decisões de modelagem"
                                  ]
                                }
                              ],
                              "practicalExample": "Modelar um sistema de gerenciamento de veículos: Crie classe abstrata 'Veículo' (atributos: placa, ano; métodos abstratos: mover()), interface 'Motorizável' (método: abastecer()), classes concretas 'Carro' e 'Moto' que herdam de Veículo e realizam Motorizável. Adicione relacionamento de composição: Veículo tem Motor (1:1).",
                              "finalVerifications": [
                                "Desenhar diagrama UML completo para um problema dado sem erros de notação.",
                                "Diferenciar corretamente classes abstratas, interfaces e concretas em exemplos.",
                                "Explicar verbalmente relacionamentos e justificativas de abstração.",
                                "Aplicar modelo a variações do problema (ex: adicionar 'Bicicleta' não-motorizável).",
                                "Validar diagrama contra princípios de Larman (2006).",
                                "Gerar código esqueleto Java a partir do diagrama."
                              ],
                              "assessmentCriteria": [
                                "Precisão da notação UML (100% correta).",
                                "Adequação das abstrações ao domínio (simplificação efetiva).",
                                "Correção e completude dos relacionamentos (multiplicidades inclusas).",
                                "Coesão e baixo acoplamento nas classes.",
                                "Documentação clara com notas e legendas.",
                                "Criatividade na identificação de interfaces compartilhadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos para modelar relacionamentos como nós e arestas.",
                                "Análise de Sistemas: Elicitação de requisitos para identificar entidades.",
                                "Design Gráfico: Princípios de visualização clara em diagramas.",
                                "Lógica: Abstração como raciocínio dedutivo de geral para específico.",
                                "Negócios: Modelagem de processos empresariais em BPMN vs UML."
                              ],
                              "realWorldApplication": "Em engenharia de software, diagramas UML de classes são usados por arquitetos para planejar sistemas escaláveis, como em desenvolvimento de apps bancários (abstrações de Conta e interface Transacionável), facilitando comunicação em equipes e geração automática de código em ferramentas como Enterprise Architect."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.1.3.3",
                            "name": "Implementar classes abstratas e herança para abstração",
                            "description": "Desenvolver classes abstratas que forcem subclasses a implementarem métodos essenciais, exemplificando com hierarquia 'Animal' -> 'Cachorro', ocultando detalhes irrelevantes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a classe abstrata base 'Animal'",
                                  "subSteps": [
                                    "Pesquise a sintaxe de classes abstratas na documentação da linguagem (ex: Java 'abstract class').",
                                    "Crie uma nova classe chamada 'Animal' e declare-a como abstrata usando a palavra-chave 'abstract'.",
                                    "Adicione campos comuns a todos os animais, como 'nome' (String) e 'idade' (int), com construtor.",
                                    "Inclua um método concreto não-abstrato, como 'respirar()', que imprima uma mensagem genérica.",
                                    "Salve e compile a classe para verificar erros de sintaxe."
                                  ],
                                  "verification": "A classe compila sem erros e não pode ser instanciada diretamente (teste com new Animal()).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE com suporte a Java (IntelliJ, Eclipse ou VSCode)",
                                    "Documentação oficial de classes abstratas"
                                  ],
                                  "tips": "Lembre-se: classes abstratas servem como blueprint e não podem ser instanciadas.",
                                  "learningObjective": "Compreender a declaração e propósito básico de uma classe abstrata.",
                                  "commonMistakes": [
                                    "Esquecer a palavra-chave 'abstract' na declaração da classe",
                                    "Tentar instanciar a classe abstrata diretamente",
                                    "Declarar construtores privados sem necessidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Adicionar métodos abstratos à classe 'Animal'",
                                  "subSteps": [
                                    "Defina um método abstrato 'fazerSom()' sem corpo (apenas assinatura com 'abstract').",
                                    "Adicione outro método abstrato 'mover()' para forçar implementação em subclasses.",
                                    "Inclua um método concreto 'dormir()' que todas as subclasses herdarão.",
                                    "Compile novamente e verifique se a classe ainda é válida como abstrata.",
                                    "Anote em comentários o motivo de cada método ser abstrato ou concreto."
                                  ],
                                  "verification": "Compilação bem-sucedida e IDE indica que métodos abstratos precisam de implementação em subclasses.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE com realce de sintaxe",
                                    "Referência de POO sobre métodos abstratos"
                                  ],
                                  "tips": "Métodos abstratos forçam especialização, ocultando detalhes de implementação.",
                                  "learningObjective": "Diferenciar métodos abstratos de concretos e seu papel na abstração.",
                                  "commonMistakes": [
                                    "Adicionar corpo a métodos abstratos",
                                    "Esquecer '; ' no final da assinatura abstrata",
                                    "Tornar métodos concretos abstratos por engano"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a subclasse concreta 'Cachorro'",
                                  "subSteps": [
                                    "Crie uma nova classe 'Cachorro' que estenda 'Animal' usando 'extends'.",
                                    "Implemente o construtor de 'Cachorro' chamando super() para inicializar nome e idade.",
                                    "Forneça implementações concretas para 'fazerSom()' (ex: System.out.println('Au au!')) e 'mover()' (ex: 'Corre com 4 patas').",
                                    "Adicione um método específico de Cachorro, como 'abanaRabo()', para demonstrar extensão.",
                                    "Compile e teste instanciação de Cachorro."
                                  ],
                                  "verification": "Instância de Cachorro pode ser criada e seus métodos chamados sem erros de compilação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE",
                                    "Exemplos de herança em tutoriais POO"
                                  ],
                                  "tips": "Use '@Override' para métodos sobrescritos para clareza e detecção de erros.",
                                  "learningObjective": "Aplicar herança para especializar uma classe abstrata em uma concreta.",
                                  "commonMistakes": [
                                    "Esquecer 'extends Animal'",
                                    "Não chamar super() no construtor",
                                    "Não implementar todos os métodos abstratos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar a hierarquia com polimorfismo",
                                  "subSteps": [
                                    "Crie uma classe principal 'Main' com método main().",
                                    "Declare uma referência do tipo 'Animal' e instancie um 'Cachorro'.",
                                    "Chame métodos polimórficos como animal.fazerSom() e animal.mover().",
                                    "Crie um array de Animal com múltiplas instâncias e itere chamando métodos.",
                                    "Execute o programa e verifique saídas específicas de cada subclasse."
                                  ],
                                  "verification": "Programa executa corretamente, exibindo comportamentos específicos via referência base.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador Java",
                                    "Terminal para execução"
                                  ],
                                  "tips": "Polimorfismo permite tratar subclasses uniformemente via tipo base.",
                                  "learningObjective": "Demonstrar abstração e herança em uso real com polimorfismo.",
                                  "commonMistakes": [
                                    "Instanciar Animal diretamente",
                                    "Não usar referência polimórfica",
                                    "Erros em loops de array"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma hierarquia: abstract class Animal { String nome; abstract void fazerSom(); void dormir() { System.out.println(nome + \" dorme\"); } } class Cachorro extends Animal { void fazerSom() { System.out.println(\"Au au!\"); } } Em Main: Animal a = new Cachorro(); a.fazerSom(); // Au au!",
                              "finalVerifications": [
                                "Código compila e executa sem erros.",
                                "Subclasses implementam todos os métodos abstratos obrigatoriamente.",
                                "Referências do tipo base invocam implementações corretas das subclasses.",
                                "Detalhes de implementação de subclasses estão ocultos na classe base.",
                                "Hierarquia suporta adição de novas subclasses sem alterar código existente.",
                                "Comentários explicam o propósito de abstração em cada classe."
                              ],
                              "assessmentCriteria": [
                                "Uso correto de 'abstract' em classes e métodos.",
                                "Implementação completa de métodos abstratos em subclasses.",
                                "Demonstração de polimorfismo com referências base.",
                                "Ocultação efetiva de detalhes irrelevantes (abstração bem-sucedida).",
                                "Código limpo, comentado e extensível.",
                                "Tratamento de erros comuns evitado (ex: compilação limpa)."
                              ],
                              "crossCurricularConnections": [
                                "Biologia: Hierarquias de classificação taxonômica (Reino > Filo > Espécie).",
                                "Design de Software: Padrões como Template Method e Strategy.",
                                "Matemática: Relações de subconjuntos e hierarquias em teoria de conjuntos.",
                                "Engenharia de Software: Abstração em modelagem UML de classes."
                              ],
                              "realWorldApplication": "Em jogos, classes abstratas como 'Veiculo' forçam 'Carro' e 'Moto' a implementarem 'acelerar()', permitindo código genérico para frotas; em apps bancários, 'Conta' abstrata oculta detalhes de 'ContaCorrente' para transações uniformes."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.2.2",
                              "10.1.2.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.2",
                    "name": "Encapsulamento em POO",
                    "description": "Mecanismo de bundling de dados e métodos em uma classe, controlando o acesso via modificadores como privado e público.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.2.1",
                        "name": "Bundling de Dados e Métodos",
                        "description": "Mecanismo fundamental do encapsulamento que agrupa dados (atributos) e métodos (comportamentos) dentro de uma única classe, promovendo a coesão e modularidade no código.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.1",
                            "name": "Definir uma classe com atributos e métodos",
                            "description": "Criar uma classe que contenha atributos para representar o estado do objeto e métodos para manipular esses atributos, ilustrando o bundling básico em linguagens como Python ou C++.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejar a estrutura da classe",
                                  "subSteps": [
                                    "Escolha um objeto do mundo real para modelar, como uma 'Conta Bancária'.",
                                    "Liste 3-5 atributos que representam o estado (ex: saldo, titular, numero_conta).",
                                    "Identifique 3-4 métodos para manipular o estado (ex: depositar, sacar, consultar_saldo).",
                                    "Defina os tipos de dados para cada atributo (ex: float para saldo, str para titular).",
                                    "Esboce um diagrama simples no papel mostrando classe, atributos e métodos."
                                  ],
                                  "verification": "Você possui um esboço escrito ou diagrama com atributos e métodos listados claramente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": [
                                    "Comece com objetos simples e concretos para evitar complexidade desnecessária.",
                                    "Use nomes descritivos em português ou inglês consistente."
                                  ],
                                  "learningObjective": "Identificar e planejar atributos (estado) e métodos (comportamentos) de uma classe.",
                                  "commonMistakes": [
                                    "Confundir atributos (dados) com métodos (ações).",
                                    "Escolher atributos irrelevantes ou excessivos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar a classe e inicializar atributos no construtor",
                                  "subSteps": [
                                    "Abra um editor de código e escreva 'class NomeClasse:' (ex: class ContaBancaria:).",
                                    "Defina o método construtor: def __init__(self, ...):",
                                    "Dentro do __init__, atribua valores aos atributos usando self: self.saldo = 0.0",
                                    "Adicione parâmetros ao __init__ para atributos variáveis (ex: self.titular = titular).",
                                    "Salve o arquivo como conta_bancaria.py e execute para verificar sintaxe."
                                  ],
                                  "verification": "Código executa sem erros de sintaxe e você pode imprimir self.titular após instanciação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou IDLE)",
                                    "Python instalado (versão 3.x)"
                                  ],
                                  "tips": [
                                    "Sempre use 'self' como primeiro parâmetro em métodos de instância.",
                                    "Inicialize atributos numéricos com 0 ou None para evitar erros."
                                  ],
                                  "learningObjective": "Implementar a sintaxe básica de classe e bundling de atributos via construtor.",
                                  "commonMistakes": [
                                    "Esquecer 'self' nos atributos.",
                                    "Não passar parâmetros ao instanciar a classe."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar métodos para manipular atributos",
                                  "subSteps": [
                                    "Adicione um método simples: def depositar(self, valor): self.saldo += valor",
                                    "Crie um método condicional: def sacar(self, valor): if self.saldo >= valor: self.saldo -= valor",
                                    "Adicione um método de consulta: def consultar_saldo(self): return self.saldo",
                                    "Inclua validações básicas (ex: if valor < 0: raise ValueError('Valor inválido')).",
                                    "Teste os métodos chamando-os em uma instância criada."
                                  ],
                                  "verification": "Métodos alteram ou retornam atributos corretamente sem quebrar o código.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Terminal para executar python conta_bancaria.py"
                                  ],
                                  "tips": [
                                    "Mantenha métodos curtos e focados em uma ação.",
                                    "Use return para métodos de consulta em vez de print."
                                  ],
                                  "learningObjective": "Criar métodos que encapsulem a manipulação de atributos, demonstrando bundling.",
                                  "commonMistakes": [
                                    "Modificar atributos diretamente fora da classe.",
                                    "Esquecer validações em métodos que alteram estado."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Instanciar, testar e refatorar a classe",
                                  "subSteps": [
                                    "Crie uma instância: conta = ContaBancaria('João', 1234)",
                                    "Teste métodos: conta.depositar(100); print(conta.consultar_saldo())",
                                    "Execute cenários de erro: tente sacar mais que o saldo e capture exceções.",
                                    "Refatore se necessário: adicione um atributo privado como __numero_conta.",
                                    "Documente a classe com docstring explicando atributos e métodos."
                                  ],
                                  "verification": "Todas as instâncias e chamadas de métodos funcionam como esperado em testes manuais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Terminal Python interativo (REPL)"
                                  ],
                                  "tips": [
                                    "Use print() temporariamente para depuração, mas remova depois.",
                                    "Teste edge cases como valores zero ou negativos."
                                  ],
                                  "learningObjective": "Validar o bundling criando e usando objetos completos.",
                                  "commonMistakes": [
                                    "Acessar atributos privados sem getters/setters.",
                                    "Não testar interações entre métodos."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe ContaBancaria com atributos: titular (str), numero_conta (int), saldo (float inicial 0.0). Métodos: depositar(valor), sacar(valor) com verificação de saldo suficiente, e consultar_saldo(). Exemplo de uso: conta = ContaBancaria('Maria', 5678); conta.depositar(500); print(conta.consultar_saldo())  # Saída: 500.0",
                              "finalVerifications": [
                                "A classe é declarada corretamente com construtor que inicializa todos os atributos.",
                                "Métodos manipulam atributos via 'self' e respeitam encapsulamento.",
                                "Instanciação cria objeto com estado correto.",
                                "Testes cobrem ações bem-sucedidas e falhas (ex: saque insuficiente).",
                                "Código executa sem erros de sintaxe ou runtime.",
                                "Docstring ou comentários explicam o propósito."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe correta de classe, __init__ e métodos de instância.",
                                "Uso consistente de 'self' em todos os atributos e métodos.",
                                "Atributos representam estado persistente; métodos alteram ou consultam.",
                                "Validações básicas em métodos para entradas inválidas.",
                                "Testes demonstram bundling funcional.",
                                "Nomenclatura clara e consistente (ex: snake_case em Python)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica condicional e operações aritméticas em métodos.",
                                "Língua Portuguesa/Inglês: Nomenclatura precisa de atributos e métodos.",
                                "Design de Sistemas: Modelagem UML básica para planejamento.",
                                "Ética: Validações para prevenir erros como saques negativos (segurança)."
                              ],
                              "realWorldApplication": "Em sistemas bancários digitais (apps como Nubank), modela contas de usuários com bundling de dados sensíveis (saldo) e operações seguras (transferências), garantindo privacidade e integridade via encapsulamento."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.2",
                            "name": "Instanciar objetos a partir da classe",
                            "description": "Criar instâncias de uma classe encapsulada, demonstrando como cada objeto mantém seu próprio estado bundlado com métodos associados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura da classe para instanciação",
                                  "subSteps": [
                                    "Analise os atributos privados ou encapsulados da classe.",
                                    "Identifique os métodos associados, incluindo o construtor.",
                                    "Revise a documentação ou comentários da classe para entender parâmetros do construtor.",
                                    "Desenhe um diagrama simples da classe mostrando dados e métodos bundados.",
                                    "Explique verbalmente como um objeto manterá seu estado independente."
                                  ],
                                  "verification": "Crie um resumo escrito listando atributos, métodos e propósito do construtor.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código fonte da classe exemplo (ex: Python ou Java)",
                                    "Papel e caneta para diagrama",
                                    "Editor de código como VS Code"
                                  ],
                                  "tips": "Lembre-se: a classe é o molde; o objeto é a cópia com estado próprio.",
                                  "learningObjective": "Reconhecer como encapsulamento bundles dados e métodos para instanciação.",
                                  "commonMistakes": [
                                    "Confundir atributos da classe com instância",
                                    "Ignorar visibilidade (private/public)",
                                    "Esquecer o papel do construtor"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar instanciação básica sem parâmetros",
                                  "subSteps": [
                                    "Escreva a sintaxe de instanciação: obj = NomeClasse().",
                                    "Execute o código para criar o objeto.",
                                    "Acesse um atributo padrão via getter ou diretamente (se público).",
                                    "Chame um método simples no objeto criado.",
                                    "Imprima o estado inicial do objeto para confirmação."
                                  ],
                                  "verification": "O objeto é criado sem erros e um método é executado com saída esperada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ambiente de execução (ex: Python IDLE, Jupyter Notebook)",
                                    "Classe exemplo simples sem construtor parametrizado"
                                  ],
                                  "tips": "Use print() para debugar o estado imediatamente após instanciação.",
                                  "learningObjective": "Dominar a sintaxe fundamental de criação de instâncias.",
                                  "commonMistakes": [
                                    "Esquecer parênteses após o nome da classe",
                                    "Tentar acessar atributos antes da instanciação",
                                    "Confundir nome da variável com nome da classe"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Instanciar objetos com construtor parametrizado",
                                  "subSteps": [
                                    "Modifique ou use uma classe com construtor que aceita argumentos.",
                                    "Passe argumentos corretos na instanciação: obj = NomeClasse(arg1, arg2).",
                                    "Verifique o estado do objeto acessando getters.",
                                    "Crie duas instâncias com argumentos diferentes.",
                                    "Compare os estados para demonstrar independência."
                                  ],
                                  "verification": "Duas instâncias têm estados distintos e métodos funcionam corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Classe com construtor parametrizado",
                                    "Editor de código e terminal para execução"
                                  ],
                                  "tips": "Ordene argumentos conforme assinatura do construtor; use IDE para autocompletar.",
                                  "learningObjective": "Aplicar encapsulamento ao inicializar estados personalizados em objetos.",
                                  "commonMistakes": [
                                    "Argumentos errados no tipo ou ordem",
                                    "Esquecer de chamar super() em herança",
                                    "Mutar estado de uma instância afetando outra"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Manipular e verificar múltiplas instâncias",
                                  "subSteps": [
                                    "Crie um array ou lista de 3 objetos instanciados.",
                                    "Aplique métodos em cada um, alterando seus estados individuais.",
                                    "Use loops para iterar e imprimir estados de todos os objetos.",
                                    "Teste cenários de erro, como argumentos inválidos.",
                                    "Refatore código para uma função que instancia e gerencia objetos."
                                  ],
                                  "verification": "Todos os objetos mantêm estados independentes após manipulações.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ambiente de programação completo",
                                    "Classe exemplo com métodos mutadores/getters"
                                  ],
                                  "tips": "Sempre valide entradas no construtor para robustez.",
                                  "learningObjective": "Demonstrar como múltiplos objetos compartilham classe mas não estado.",
                                  "commonMistakes": [
                                    "Usar variáveis estáticas confundindo estados",
                                    "Não inicializar corretamente em loops",
                                    "Sobrecarregar construtor sem necessidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Defina uma classe 'Carro' com atributos privados 'marca' e 'ano', construtor parametrizado e métodos getMarca(), acelerar() que aumenta 'velocidade'. Instancie: carro1 = Carro('Toyota', 2020); carro2 = Carro('Ford', 2018). Chame carro1.acelerar() 3x e carro2.acelerar() 2x. Imprima velocidades: carro1 tem 3, carro2 tem 2, provando estados independentes.",
                              "finalVerifications": [
                                "Código instancia objetos sem erros de sintaxe ou runtime.",
                                "Cada objeto acessa seus próprios atributos e métodos corretamente.",
                                "Múltiplas instâncias mantêm estados independentes após alterações.",
                                "Getters retornam valores inicializados via construtor.",
                                "Métodos mutadores afetam apenas a instância chamada.",
                                "Uso em loops ou listas preserva independência de estado."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe de instanciação 100% correta (classe(), argumentos).",
                                "Estados bundados corretamente via encapsulamento (private + getters/setters).",
                                "Demonstração clara de independência entre instâncias.",
                                "Tratamento de erros em construtores (validações básicas).",
                                "Código limpo, comentado e executável.",
                                "Eficiência: tempo de execução e uso de recursos mínimos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de funções e vetores como classes.",
                                "Física: Simulação de partículas ou corpos com propriedades bundadas.",
                                "Biologia: Representação de organismos com DNA (atributos) e funções vitais (métodos).",
                                "Química: Moléculas com estrutura e reações encapsuladas.",
                                "Economia: Modelos de agentes econômicos com estados individuais."
                              ],
                              "realWorldApplication": "Em desenvolvimento de aplicativos, como criar contas de usuário em um banco (cada conta com saldo e métodos de depósito/saque independentes) ou simulações de jogos onde cada inimigo é uma instância com vida e ataques próprios."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.3",
                            "name": "Explicar a coesão promovida pelo bundling",
                            "description": "Descrever verbalmente ou por escrito como o bundling reduz a complexidade ao manter dados e operações relacionados juntos em uma unidade lógica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de coesão em programação",
                                  "subSteps": [
                                    "Defina coesão como a medida de quão bem os elementos de um módulo (funções, dados) trabalham juntos para uma tarefa específica.",
                                    "Discuta tipos de coesão: alta (funcional) vs. baixa (coincidental).",
                                    "Explique por que alta coesão facilita manutenção e reduz erros.",
                                    "Identifique exemplos de baixa coesão em código procedural.",
                                    "Anote a importância da coesão para escalabilidade."
                                  ],
                                  "verification": "Escreva uma definição clara de coesão e dê um exemplo de código com baixa coesão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Use analogias cotidianas, como uma equipe coesa vs. dispersa.",
                                  "learningObjective": "Entender o que é coesão e sua relevância em programação.",
                                  "commonMistakes": [
                                    "Confundir coesão com acoplamento",
                                    "Ignorar o impacto na manutenção"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o bundling em Programação Orientada a Objetos",
                                  "subSteps": [
                                    "Defina bundling como o agrupamento de dados (atributos) e operações (métodos) relacionados em uma classe.",
                                    "Compare com programação procedural, onde dados e funções estão separados.",
                                    "Desenhe um diagrama simples de uma classe com atributos e métodos.",
                                    "Explique que bundling é parte do encapsulamento.",
                                    "Liste benefícios iniciais: proteção de dados e organização lógica."
                                  ],
                                  "verification": "Crie um esboço de uma classe que demonstre bundling.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code)",
                                    "Papel para diagramas"
                                  ],
                                  "tips": "Pense em objetos reais: um carro tem rodas (dados) e dirigir (método).",
                                  "learningObjective": "Dominar a definição e representação visual de bundling.",
                                  "commonMistakes": [
                                    "Separar dados e métodos em diagramas",
                                    "Confundir com herança"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar como o bundling promove coesão",
                                  "subSteps": [
                                    "Descreva verbalmente: bundling mantém dados e operações juntos, focando a classe em uma responsabilidade única.",
                                    "Mostre como isso reduz complexidade: menos buscas por funções dispersas.",
                                    "Compare código sem bundling (procedural) vs. com bundling (classe).",
                                    "Explique coesão alta: todas operações manipulam os mesmos dados internamente.",
                                    "Escreva uma explicação curta sobre redução de complexidade."
                                  ],
                                  "verification": "Escreva um parágrafo explicando a promoção de coesão pelo bundling.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplos de código procedural e OOP"
                                  ],
                                  "tips": "Use setas em diagramas para mostrar relações entre dados e métodos.",
                                  "learningObjective": "Conectar bundling diretamente à promoção de coesão.",
                                  "commonMistakes": [
                                    "Focar só em proteção de dados, ignorar coesão",
                                    "Exemplos irreais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e refinar a explicação com exemplos práticos",
                                  "subSteps": [
                                    "Crie um exemplo de classe com bundling e analise sua coesão.",
                                    "Refatore um código procedural para OOP e compare coesão.",
                                    "Discuta cenários onde baixa coesão causa problemas.",
                                    "Pratique explicação oral para um 'parceiro' imaginário.",
                                    "Revise e melhore a explicação escrita."
                                  ],
                                  "verification": "Grave ou escreva uma explicação completa de 1 minuto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Gravador de áudio (opcional)"
                                  ],
                                  "tips": "Teste a explicação em voz alta para clareza.",
                                  "learningObjective": "Aplicar e validar o conhecimento de forma independente.",
                                  "commonMistakes": [
                                    "Exemplos muito complexos",
                                    "Não comparar antes/depois"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma classe ContaBancaria: atributos (saldo, titular) bundados com métodos (depositar(), sacar()). Isso promove coesão pois todas operações relacionadas à conta ficam juntas, reduzindo complexidade em vez de funções espalhadas como em código procedural: funcaoDepositar(saldoGlobal), funcaoSacar(saldoGlobal).",
                              "finalVerifications": [
                                "Pode definir coesão e bundling corretamente?",
                                "Explica verbalmente como bundling reduz complexidade?",
                                "Identifica coesão alta em um exemplo de classe?",
                                "Compara código procedural vs. OOP em termos de coesão?",
                                "Cria um diagrama mostrando bundling?",
                                "Evita confusão com acoplamento?"
                              ],
                              "assessmentCriteria": [
                                "Clareza e precisão na definição de conceitos",
                                "Uso de exemplos relevantes e concretos",
                                "Demonstração da relação bundling-coesão",
                                "Capacidade de comparação procedural vs. OOP",
                                "Profundidade na explicação de redução de complexidade",
                                "Estrutura lógica da explicação verbal/escrita"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Agrupamento de variáveis e funções em módulos modulares",
                                "Língua Portuguesa: Coesão textual, mantendo ideias relacionadas unidas",
                                "Biologia: Organelas celulares bundlando funções e estruturas",
                                "Física: Sistemas fechados onde componentes interagem internamente"
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps bancários, bundling em classes como Conta garante coesão, facilitando manutenção em equipes grandes e reduzindo bugs em sistemas como apps do Nubank ou jogos Unity onde objetos bundlam física e lógica."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.2",
                        "name": "Modificadores de Acesso",
                        "description": "Uso de modificadores como privado (private), público (public) e protegido (protected) para controlar a visibilidade e acesso aos membros da classe, garantindo a restrição externa.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.2.1",
                            "name": "Implementar atributos privados",
                            "description": "Declarar atributos com modificador privado em uma classe (ex: _atributo em Python ou private em C++) e tentar acessá-los externamente para observar o controle de acesso.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de atributos privados e encapsulamento",
                                  "subSteps": [
                                    "Leia a definição de encapsulamento em POO: esconder detalhes internos da classe.",
                                    "Estude modificadores de acesso: private (_ em Python, private em C++).",
                                    "Compare com public: acesso irrestrito vs. controlado.",
                                    "Assista a um vídeo curto (5 min) sobre name mangling em Python.",
                                    "Anote diferenças entre Python (convenção) e C++ (compilação)."
                                  ],
                                  "verification": "Resuma em 3 frases o que são atributos privados e por que usá-los.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Python oficial (classes), Tutorial C++ private",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Lembre-se: Python usa '_' como convenção, não enforcement estrito.",
                                  "learningObjective": "Compreender o propósito de atributos privados no encapsulamento.",
                                  "commonMistakes": [
                                    "Confundir com métodos privados",
                                    "Achar que Python private é como Java",
                                    "Ignorar name mangling (__double_underscore)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar uma classe com atributos privados",
                                  "subSteps": [
                                    "Crie uma classe simples, ex: Pessoa, com atributos _nome e _idade como privados.",
                                    "Use '__init__' para inicializar os atributos privados.",
                                    "Adicione um atributo público para comparação, ex: public_id.",
                                    "Salve o código em um arquivo .py.",
                                    "Execute a classe instanciando um objeto."
                                  ],
                                  "verification": "Instancie a classe e imprima atributos públicos sem erro.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, PyCharm)",
                                    "Python 3.x instalado"
                                  ],
                                  "tips": "Use _atributo para single underscore (protected-like), __atributo para name mangled.",
                                  "learningObjective": "Declarar corretamente atributos privados em uma classe Python.",
                                  "commonMistakes": [
                                    "Esquecer self. em init",
                                    "Usar public por engano",
                                    "Não inicializar atributos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Testar acesso externo aos atributos privados",
                                  "subSteps": [
                                    "Instancie um objeto da classe.",
                                    "Tente acessar _nome diretamente: obj._nome = 'teste'.",
                                    "Observe o comportamento: warning ou name mangling em __nome.",
                                    "Tente imprimir obj._idade e veja se acessa.",
                                    "Compare com acesso ao atributo público."
                                  ],
                                  "verification": "Confirme que acesso direto gera warning ou requer mangling para funcionar.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Terminal ou Jupyter Notebook",
                                    "Código da classe anterior"
                                  ],
                                  "tips": "Rode pylint ou flake8 para ver warnings de acesso privado.",
                                  "learningObjective": "Observar o controle de acesso em ação.",
                                  "commonMistakes": [
                                    "Achar que é erro fatal (Python permite)",
                                    "Não notar name mangling",
                                    "Confundir com exceções"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar métodos de acesso controlado (getters/setters)",
                                  "subSteps": [
                                    "Adicione método get_nome(self) que retorna self._nome.",
                                    "Crie setter set_nome(self, nome) com validação (ex: len(nome)>0).",
                                    "Teste: use obj.get_nome() e obj.set_nome('Novo').",
                                    "Acesse via métodos e confirme que atributos privados permanecem protegidos.",
                                    "Refatore para usar @property se avançado."
                                  ],
                                  "verification": "Acesso via métodos funciona; direto ainda restrito.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Código atualizado"
                                  ],
                                  "tips": "Valide inputs no setter para encapsulamento real.",
                                  "learningObjective": "Controlar acesso a privados via métodos públicos.",
                                  "commonMistakes": [
                                    "Esquecer return no getter",
                                    "Não validar no setter",
                                    "Expor privados acidentalmente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e refatorar o encapsulamento completo",
                                  "subSteps": [
                                    "Crie testes unitários: acesso direto falha, métodos OK.",
                                    "Use assert para verificar validações (ex: set_idade negativa rejeitada).",
                                    "Refatore classe para C++ equivalente se tempo permitir.",
                                    "Documente a classe com docstrings explicando privados.",
                                    "Execute e debugue qualquer issue."
                                  ],
                                  "verification": "Todos testes passam; código limpo sem warnings.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "unittest ou pytest",
                                    "Compilador C++ opcional"
                                  ],
                                  "tips": "Use pytest para automação: pytest teste.py.",
                                  "learningObjective": "Validar implementação de encapsulamento.",
                                  "commonMistakes": [
                                    "Testes incompletos",
                                    "Ignorar warnings",
                                    "Não refatorar"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe ContaBancaria com __saldo (privado). Inicialize com 1000. Tente: conta.__saldo = 5000 (name mangled). Crie def get_saldo(self): return self.__saldo. def depositar(self, valor): if valor>0: self.__saldo += valor. Teste: print(conta.get_saldo()) após depositar(500).",
                              "finalVerifications": [
                                "Atributos declarados com _ ou __ prefixo.",
                                "Acesso direto externo gera warning ou requer mangling.",
                                "Getters/setters funcionam com validação.",
                                "Instância mantém estado encapsulado após múltiplas operações.",
                                "Código executa sem erros de sintaxe.",
                                "Testes confirmam controle de acesso."
                              ],
                              "assessmentCriteria": [
                                "Correta declaração de atributos privados (100%).",
                                "Demonstração de falha no acesso direto (80%).",
                                "Getters/setters com validação implementados (90%).",
                                "Código limpo, comentado e testado (70%).",
                                "Compreensão conceitual via resumo (60%).",
                                "Aplicação em exemplo prático sem bugs (85%)."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Proteção de dados sensíveis.",
                                "Matemática: Modelagem de estados com restrições.",
                                "Design de Sistemas: Princípios de software engineering.",
                                "Lógica Computacional: Controle de fluxo e validação."
                              ],
                              "realWorldApplication": "Em apps bancários, atributos privados como _saldo protegem saldos de acessos indevidos, permitindo apenas transações validadas via métodos, prevenindo fraudes e erros."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.2",
                            "name": "Diferenciar public, private e protected",
                            "description": "Comparar os níveis de acesso em diagramas ou tabelas, exemplificando cenários onde cada um é apropriado em contextos de POO.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as definições básicas dos modificadores de acesso",
                                  "subSteps": [
                                    "Leia a definição de 'public': permite acesso de qualquer classe ou objeto externo.",
                                    "Estude 'private': restringe acesso apenas ao interior da própria classe.",
                                    "Analise 'protected': permite acesso dentro da classe, subclasses e pacotes (em linguagens como Java).",
                                    "Compare com exemplos simples de código pseudocódigo para fixar.",
                                    "Anote as diferenças principais em um caderno."
                                  ],
                                  "verification": "Resuma verbalmente ou por escrito as três definições sem consultar materiais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial de POO (ex: Java Docs)",
                                    "Caderno e caneta",
                                    "Editor de texto para pseudocódigo"
                                  ],
                                  "tips": "Use analogias: public como porta aberta, private como cofre, protected como quarto familiar.",
                                  "learningObjective": "Identificar corretamente o escopo de acesso de cada modificador.",
                                  "commonMistakes": [
                                    "Confundir protected com private em herança",
                                    "Achar que public é sempre inseguro",
                                    "Ignorar diferenças de pacote em linguagens específicas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar uma tabela comparativa dos níveis de acesso",
                                  "subSteps": [
                                    "Desenhe uma tabela com colunas: Modificador, Acesso externo, Acesso subclasses, Acesso pacote, Exemplo.",
                                    "Preencha para public: Sim, Sim, Sim, método getter.",
                                    "Preencha para private: Não, Não, Não, saldo bancário.",
                                    "Preencha para protected: Não, Sim, Sim (Java), método herdado.",
                                    "Adicione uma linha de comparação visual com símbolos (✓/✗)."
                                  ],
                                  "verification": "Mostre a tabela a um colega ou mentor para validação das entradas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Planilha (Google Sheets ou papel)",
                                    "Referência de tabela de modificadores de acesso"
                                  ],
                                  "tips": "Use cores para destacar: verde para permitido, vermelho para negado.",
                                  "learningObjective": "Visualizar e comparar os escopos de acesso de forma tabular.",
                                  "commonMistakes": [
                                    "Esquecer acesso de pacote para protected",
                                    "Marcar protected como acessível externamente",
                                    "Tabela incompleta sem exemplos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar cenários apropriados para cada modificador",
                                  "subSteps": [
                                    "Liste cenários para public: interfaces de API, métodos de uso geral como toString().",
                                    "Defina para private: dados sensíveis como senhas, saldos internos.",
                                    "Exemplifique protected: variáveis que subclasses precisam acessar, como em frameworks de herança.",
                                    "Crie 3 cenários hipotéticos por modificador e justifique a escolha.",
                                    "Discuta por que violar (ex: tornar private em public) causa problemas de encapsulamento."
                                  ],
                                  "verification": "Escreva 9 cenários (3 por tipo) e explique a adequação em frases curtas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de código de classes reais (GitHub)",
                                    "Fórum de dúvidas POO"
                                  ],
                                  "tips": "Pense em segurança: private protege implementação interna.",
                                  "learningObjective": "Aplicar modificadores a contextos reais de encapsulamento.",
                                  "commonMistakes": [
                                    "Usar public para tudo por 'facilidade'",
                                    "Confundir protected com herança obrigatória",
                                    "Ignorar cenários de pacote"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e testar em um exemplo de código",
                                  "subSteps": [
                                    "Crie uma classe Animal com atributo private 'idade', protected 'especie', public 'nome'.",
                                    "Adicione subclasses como Cachorro herdando e acessando protected.",
                                    "Tente acessar membros de fora da classe e observe erros de compilação.",
                                    "Crie getters/setters para public/private e teste chamadas.",
                                    "Compile e execute para verificar acessos permitidos."
                                  ],
                                  "verification": "Execute o código sem erros e demonstre acessos bem-sucedidos/falhos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE como IntelliJ ou VS Code",
                                    "Compilador Java ou equivalente"
                                  ],
                                  "tips": "Comece com pseudocódigo antes de codificar para evitar erros.",
                                  "learningObjective": "Praticar diferenciação prática via implementação.",
                                  "commonMistakes": [
                                    "Esquecer importações ou pacotes",
                                    "Acessar private externamente sem getter",
                                    "Não testar herança com protected"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma classe ContaBancaria: 'private double saldo' (só alterado internamente), 'protected String tipoConta' (subclasses como ContaPoupanca acessam), 'public void depositar(double valor)' (qualquer cliente usa). Tente acessar saldo diretamente fora da classe: erro! Subclasse acessa tipoConta: ok!",
                              "finalVerifications": [
                                "Consegue explicar os três modificadores sem hesitação?",
                                "Tabela comparativa está 100% correta?",
                                "Identifica corretamente 80% dos cenários apropriados?",
                                "Código exemplo compila e demonstra acessos corretos?",
                                "Diferencia protected de private em herança?",
                                "Cria diagrama UML simples com visibilidades (+ public, - private, # protected)?"
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (90% correto)",
                                "Tabela/diagrama claro e completo",
                                "Exemplos relevantes e justificados",
                                "Código funcional sem violações de acesso",
                                "Compreensão de encapsulamento via escolhas",
                                "Ausência de confusões comuns (ex: protected != public)"
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: analogia com permissões de arquivos (read/write/execute)",
                                "Design de Software: princípios SOLID e encapsulamento",
                                "Lógica Matemática: conjuntos de acesso (união/interseção de escopos)",
                                "Banco de Dados: visibilidade de colunas (public/private views)"
                              ],
                              "realWorldApplication": "Em apps bancários, private protege saldos contra acessos indevidos; protected permite que subclasses como ContaCorrente estendam funcionalidades sem expor dados; public oferece APIs seguras para transações, garantindo encapsulamento e manutenção de código em equipes grandes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.3",
                            "name": "Aplicar convenções de nomenclatura para encapsulamento",
                            "description": "Usar convenções como prefixo _ para protected/private em Python, garantindo legibilidade e intenção de encapsulamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as Convenções de Nomenclatura para Encapsulamento em Python",
                                  "subSteps": [
                                    "Estude a documentação oficial do Python sobre convenções PEP 8, focando em underscores para atributos.",
                                    "Identifique a diferença: _single_underscore para 'protected' (convenção, acessível mas não deve ser acessado diretamente).",
                                    "__double_underscore para 'private' (name mangling, dificulta acesso externo).",
                                    "Leia exemplos de código em repositórios open-source como Django para ver uso real.",
                                    "Anote as regras principais em um documento pessoal."
                                  ],
                                  "verification": "Crie um resumo de 1 página explicando quando usar _ e __, com exemplos simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação PEP 8 (pep8.org), editor de texto como VS Code"
                                  ],
                                  "tips": "Use o interpretador Python interativo (REPL) para testar acessos rápidos.",
                                  "learningObjective": "Explicar verbalmente ou por escrito as convenções de nomenclatura para encapsulamento.",
                                  "commonMistakes": "Confundir _ com __; achar que Python enforce privacidade como em Java."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Atributos que Precisam de Encapsulamento em uma Classe",
                                  "subSteps": [
                                    "Crie uma classe simples sem encapsulamento, como uma ContaBancaria com balance público.",
                                    "Analise quais atributos devem ser privados (ex: balance, pin) para evitar manipulação externa.",
                                    "Marque no código comentários onde aplicar _ ou __.",
                                    "Discuta com um par ou em fórum por que certos atributos precisam de proteção.",
                                    "Refatore manualmente adicionando underscores nos atributos identificados."
                                  ],
                                  "verification": "Execute o código e tente acessar atributos de fora da classe; confirme que ainda funciona mas com intenção clara.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python instalado, IDE como PyCharm ou VS Code"
                                  ],
                                  "tips": "Comece com atributos sensíveis como senhas ou saldos financeiros.",
                                  "learningObjective": "Selecionar corretamente atributos para encapsulamento baseado em boas práticas.",
                                  "commonMistakes": "Aplicar underscore em tudo; ignorar que convenções são sugestões, não enforcements."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Convenções em uma Classe Completa e Adicionar Getters/Setters",
                                  "subSteps": [
                                    "Defina métodos getter (ex: get_balance()) e setter (ex: set_balance(novo_valor)) para atributos _encapsulados.",
                                    "Teste acesso direto vs. via métodos: demonstre que _balance falha intencionalmente se acessado direto.",
                                    "Use __ para atributos verdadeiramente privados como _internal_id.",
                                    "Adicione validações nos setters (ex: balance não negativo).",
                                    "Escreva testes unitários com unittest para verificar encapsulamento."
                                  ],
                                  "verification": "Rode testes: acesso direto deve ser possível mas desencorajado; métodos funcionam corretamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Biblioteca unittest do Python, arquivo .py para a classe"
                                  ],
                                  "tips": "Siga o padrão 'ask forgiveness' em setters para validações.",
                                  "learningObjective": "Implementar encapsulamento com nomenclatura e métodos de acesso seguros.",
                                  "commonMistakes": "Esquecer validações em setters; usar __ em excesso, complicando depuração."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Refatorar Código Existente e Avaliar Legibilidade",
                                  "subSteps": [
                                    "Pegue um código legado sem convenções e aplique _/__ sistematicamente.",
                                    "Use linters como pylint ou black para checar conformidade com PEP 8.",
                                    "Compare antes/depois: meça legibilidade com métricas simples (linhas de código, clareza).",
                                    "Peça feedback de um revisor de código sobre intenção clara de encapsulamento.",
                                    "Documente mudanças em um commit Git com mensagem explicativa."
                                  ],
                                  "verification": "Código passa em pylint sem warnings de nomenclatura; legibilidade melhorada em review.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Git para versionamento, pylint instalado via pip"
                                  ],
                                  "tips": "Use git diff para visualizar mudanças atômicas.",
                                  "learningObjective": "Refatorar código para aderir a convenções, melhorando manutenção.",
                                  "commonMistakes": "Refatorar sem testes, quebrando funcionalidade; ignorar legibilidade em nomes longos."
                                }
                              ],
                              "practicalExample": "Crie uma classe ContaBancaria: def __init__(self): self._balance = 0; self.__pin = 1234. Adicione def get_balance(self): return self._balance; def deposit(self, amount): if amount > 0: self._balance += amount. Teste: conta = ContaBancaria(); print(conta._balance)  # Funciona, mas evite; print(conta.get_balance())  # Correto.",
                              "finalVerifications": [
                                "Todos atributos privados usam _ ou __ conforme intenção.",
                                "Getters/setters expõem apenas o necessário com validações.",
                                "Código passa em linters PEP 8 sem erros de nomenclatura.",
                                "Testes unitários cobrem acessos encapsulados.",
                                "Legibilidade: intenções claras para outros desenvolvedores.",
                                "Name mangling funciona para __ (ex: _Classe__atributo)."
                              ],
                              "assessmentCriteria": [
                                "Consistência na aplicação de convenções (_ para protected, __ para private).",
                                "Presença de métodos de acesso adequados e validados.",
                                "Melhoria mensurável em legibilidade (reviews ou métricas).",
                                "Ausência de acessos diretos desnecessários em testes.",
                                "Adesão total à PEP 8 em nomenclatura.",
                                "Tratamento de erros comuns como validações em setters."
                              ],
                              "crossCurricularConnections": [
                                "Lógica Matemática: Validações em setters usam condicionais e aritmética.",
                                "Linguagem Portuguesa: Convenções semelhantes a regras gramaticais para clareza.",
                                "Ética e Segurança: Encapsulamento protege dados sensíveis como em cibersegurança.",
                                "Design de Sistemas: Padrões de nomenclatura em engenharia de software."
                              ],
                              "realWorldApplication": "Em aplicações bancárias como apps de fintech (ex: Nubank), usa-se _balance para impedir alterações diretas por usuários maliciosos, garantindo integridade de dados e facilitando manutenção em equipes grandes."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.3",
                        "name": "Getters e Setters",
                        "description": "Métodos públicos para acesso controlado (leitura e escrita) a atributos privados, validando dados e mantendo a integridade do encapsulamento.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.3.1",
                            "name": "Criar métodos getter",
                            "description": "Implementar um método getter para ler um atributo privado, retornando seu valor de forma controlada sem expor o atributo diretamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a classe com atributo privado",
                                  "subSteps": [
                                    "Crie uma nova classe Java, por exemplo, 'Pessoa'.",
                                    "Declare um atributo privado, como 'private String nome;'.",
                                    "Adicione um construtor público para inicializar o atributo, ex: public Pessoa(String nome) { this.nome = nome; }.",
                                    "Compile a classe para verificar ausência de erros.",
                                    "Tente acessar o atributo diretamente de fora da classe para confirmar erro de compilação."
                                  ],
                                  "verification": "Atributo privado gera erro de compilação ao ser acessado externamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "IDE como IntelliJ ou Eclipse",
                                    "JDK 8 ou superior"
                                  ],
                                  "tips": "Use nomes descritivos para atributos e siga convenções Java (camelCase).",
                                  "learningObjective": "Entender o conceito de encapsulamento e atributos privados.",
                                  "commonMistakes": [
                                    "Declarar atributo como public",
                                    "Esquecer ponto e vírgula no final da declaração",
                                    "Não inicializar no construtor"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a assinatura do método getter",
                                  "subSteps": [
                                    "Nomeie o método seguindo a convenção: 'get' + nome do atributo capitalizado, ex: 'getNome()'.",
                                    "Defina o modificador de acesso como 'public'.",
                                    "Especifique o tipo de retorno igual ao atributo, ex: 'String'.",
                                    "Não inclua parâmetros na assinatura.",
                                    "Adicione o método dentro da classe, acima ou abaixo do construtor."
                                  ],
                                  "verification": "Compilação bem-sucedida sem erros de sintaxe na assinatura do método.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "IDE com autocompletar",
                                    "Documentação Java sobre métodos"
                                  ],
                                  "tips": "Sempre comece getters com 'get' em maiúscula para padronização.",
                                  "learningObjective": "Dominar a nomenclatura e assinatura padrão de getters em POO.",
                                  "commonMistakes": [
                                    "Usar 'private' no getter",
                                    "Adicionar parâmetros desnecessários",
                                    "Tipo de retorno incorreto",
                                    "Nome sem 'get'"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o corpo do método getter",
                                  "subSteps": [
                                    "Abra chaves do método e insira apenas 'return nome;' (substitua pelo nome do atributo).",
                                    "Evite qualquer lógica adicional como cálculos ou validações neste passo básico.",
                                    "Salve e compile a classe.",
                                    "Verifique se o método tem apenas uma linha de retorno.",
                                    "Teste compilação após implementação."
                                  ],
                                  "verification": "Método compila e está pronto para retornar o valor do atributo.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Compilador Java"
                                  ],
                                  "tips": "Mantenha o getter simples: apenas leitura, sem modificações.",
                                  "learningObjective": "Implementar lógica mínima para acesso controlado a dados privados.",
                                  "commonMistakes": [
                                    "Retornar valor hardcoded",
                                    "Modificar o atributo no getter",
                                    "Esquecer 'return'",
                                    "Fechar chaves prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar o método getter",
                                  "subSteps": [
                                    "Crie uma classe principal (Main) com método main().",
                                    "Instancie a classe, ex: Pessoa p = new Pessoa('João');.",
                                    "Chame o getter e imprima: System.out.println(p.getNome());.",
                                    "Tente acessar o atributo diretamente (deve falhar).",
                                    "Execute e confirme saída correta."
                                  ],
                                  "verification": "Programa executa, getter retorna valor correto e acesso direto falha.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "IDE com console",
                                    "JDK para execução"
                                  ],
                                  "tips": "Use System.out.println para depuração rápida.",
                                  "learningObjective": "Verificar o encapsulamento na prática através de testes.",
                                  "commonMistakes": [
                                    "Não instanciar objeto corretamente",
                                    "Esquecer importações",
                                    "Não testar acesso direto ao atributo"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe ContaBancaria com atributo privado double saldo. Adicione construtor: public ContaBancaria(double saldoInicial) { this.saldo = saldoInicial; }. Implemente public double getSaldo() { return saldo; }. Em uma classe Main, crie ContaBancaria c = new ContaBancaria(1000.0); imprima c.getSaldo() (deve mostrar 1000.0) e tente c.saldo (erro de compilação).",
                              "finalVerifications": [
                                "Método getter é public e retorna tipo correto do atributo.",
                                "Corpo do getter contém apenas instrução de return simples.",
                                "Atributo privado não é acessível diretamente fora da classe.",
                                "Teste em main demonstra retorno correto do valor.",
                                "Sem parâmetros no método getter.",
                                "Compilação e execução sem erros."
                              ],
                              "assessmentCriteria": [
                                "Correta declaração de atributo private.",
                                "Assinatura do getter segue convenção Java (public getNome()).",
                                "Implementação minimalista sem lógica extra.",
                                "Teste comprova encapsulamento (acesso direto falha).",
                                "Código limpo, compilável e executável.",
                                "Uso apropriado de construtor para inicialização."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Manipulação de tipos primitivos e precisão numérica em double.",
                                "Língua Portuguesa/Inglês: Convenções de nomenclatura camelCase e padrões Java.",
                                "Segurança da Informação: Princípios de controle de acesso e proteção de dados.",
                                "Design de Software: Boas práticas de abstração e modularidade."
                              ],
                              "realWorldApplication": "Em aplicativos bancários ou e-commerce, getters permitem que usuários consultem saldos ou preços sem expor ou modificar diretamente os dados sensíveis, garantindo segurança e integridade em sistemas como apps de fintech ou plataformas de pagamento."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.2.3.2",
                            "name": "Criar métodos setter com validação",
                            "description": "Desenvolver um setter que valide entradas antes de modificar um atributo privado, como checar ranges ou tipos, ilustrando proteção de dados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a classe com atributo privado",
                                  "subSteps": [
                                    "Declare uma classe simples, como 'ContaBancaria'.",
                                    "Crie um atributo privado, por exemplo, 'private double saldo;'.",
                                    "Inicialize o atributo no construtor com um valor padrão válido.",
                                    "Adicione um getter básico para acessar o valor."
                                  ],
                                  "verification": "Compilar a classe sem erros e instanciar um objeto para verificar o getter retorna o valor inicial.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (IDE como IntelliJ ou VS Code)",
                                    "Compilador Java ou ambiente online como Replit"
                                  ],
                                  "tips": "Use convenções de nomenclatura camelCase para atributos e métodos.",
                                  "learningObjective": "Compreender o encapsulamento básico com atributos privados e getters.",
                                  "commonMistakes": [
                                    "Esquecer o modificador 'private'",
                                    "Não inicializar no construtor",
                                    "Getter sem 'return'"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir regras de validação para o atributo",
                                  "subSteps": [
                                    "Identifique tipos de validação necessários, como range (saldo >= 0) e tipo (double positivo).",
                                    "Escreva pseudocódigo para as condições de validação, ex: if (valor < 0) { erro }.",
                                    "Decida o mecanismo de erro: lançar IllegalArgumentException ou retornar boolean.",
                                    "Documente as regras em comentários na classe."
                                  ],
                                  "verification": "Revisar o pseudocódigo e confirmar que cobre cenários inválidos como negativos ou nulos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta ou bloco de notas para pseudocódigo",
                                    "Documentação Java sobre exceções"
                                  ],
                                  "tips": "Priorize validações simples primeiro; expanda para regex se necessário.",
                                  "learningObjective": "Planejar validações específicas para proteger a integridade dos dados.",
                                  "commonMistakes": [
                                    "Ignorar validação de null",
                                    "Regras muito restritivas",
                                    "Não considerar exceções"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o método setter com validação",
                                  "subSteps": [
                                    "Crie o método setter: public void setSaldo(double valor).",
                                    "Adicione as verificações if no início do método.",
                                    "Se inválido, lance IllegalArgumentException com mensagem clara.",
                                    "Se válido, atribua ao atributo privado: this.saldo = valor;."
                                  ],
                                  "verification": "Compilar e testar chamadas: uma válida (atualiza) e inválida (lança exceção).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE com debugger",
                                    "Main class para testes unitários"
                                  ],
                                  "tips": "Use 'this.' para diferenciar parâmetro local do atributo.",
                                  "learningObjective": "Codificar um setter que enforce regras de negócio via validação.",
                                  "commonMistakes": [
                                    "Atribuir antes de validar",
                                    "Mensagens de erro vagas",
                                    "Esquecer 'this.saldo'"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e refinar o setter",
                                  "subSteps": [
                                    "Crie uma classe Main com instância da classe.",
                                    "Teste casos: valor válido, negativo, zero, muito grande.",
                                    "Use try-catch para capturar e imprimir exceções.",
                                    "Refatore se necessário com base nos testes."
                                  ],
                                  "verification": "Todos testes passam: válidos atualizam, inválidos excepcionam sem alterar atributo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "JUnit ou testes manuais em main",
                                    "Console para output"
                                  ],
                                  "tips": "Automatize testes com asserts para robustez.",
                                  "learningObjective": "Validar a implementação através de testes abrangentes.",
                                  "commonMistakes": [
                                    "Não testar bordas como 0 ou MAX_DOUBLE",
                                    "Ignorar try-catch",
                                    "Alterar atributo em erro"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma classe ContaBancaria: private double saldo = 0.0;\npublic void setSaldo(double valor) {\n  if (valor < 0) throw new IllegalArgumentException(\"Saldo não pode ser negativo\");\n  this.saldo = valor;\n}\nTeste: conta.setSaldo(100.0); // OK\nconta.setSaldo(-50); // Exceção",
                              "finalVerifications": [
                                "O setter rejeita valores inválidos lançando exceção sem alterar o atributo.",
                                "Valores válidos atualizam corretamente o atributo privado.",
                                "Getter reflete mudanças apenas de sets válidos.",
                                "Mensagens de erro são claras e informativas.",
                                "Testes cobrem ranges, tipos e bordas.",
                                "Código compila e executa sem warnings."
                              ],
                              "assessmentCriteria": [
                                "Validação implementada corretamente (100%)",
                                "Tratamento de exceções apropriado (25%)",
                                "Cobertura de testes abrangente (20%)",
                                "Código limpo e comentado (15%)",
                                "Uso correto de 'this' e encapsulamento (20%)",
                                "Eficiência e legibilidade (20%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica condicional e operadores de comparação.",
                                "Segurança da Informação: Proteção contra injeções de dados inválidos.",
                                "Ética em Computação: Garantia de integridade de dados sensíveis.",
                                "Design de Software: Princípios SOLID (Encapsulamento).",
                                "Testes e Qualidade: Práticas de TDD (Test-Driven Development)."
                              ],
                              "realWorldApplication": "Em aplicativos bancários ou e-commerce, setters com validação previnem erros como saldos negativos ou idades inválidas, garantindo conformidade regulatória e evitando falhas em produção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.2.3.3",
                            "name": "Refatorar classe para usar getters/setters",
                            "description": "Pegar uma classe sem encapsulamento e refatorá-la adicionando atributos privados e métodos de acesso, comparando antes/depois.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a classe original sem encapsulamento",
                                  "subSteps": [
                                    "Examine o código da classe existente e identifique todos os atributos declarados como públicos.",
                                    "Liste os atributos que acessam dados sensíveis ou que precisam de controle de acesso.",
                                    "Registre os usos atuais dos atributos públicos no código cliente (main ou outras classes).",
                                    "Crie uma cópia do código original para comparação posterior.",
                                    "Documente o estado inicial, incluindo possíveis problemas como acesso direto indevido."
                                  ],
                                  "verification": "Lista completa de atributos públicos identificados e usos documentados em um arquivo de notas ou comentário no código.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (IDE como IntelliJ ou VS Code)",
                                    "Classe de exemplo sem encapsulamento (ex: classe Pessoa com atributos públicos)"
                                  ],
                                  "tips": "Use o recurso de busca no IDE para encontrar todos os acessos aos atributos públicos.",
                                  "learningObjective": "Compreender o estado atual da classe e identificar oportunidades de encapsulamento.",
                                  "commonMistakes": [
                                    "Ignorar atributos que parecem inofensivos",
                                    "Não documentar usos existentes do cliente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Tornar atributos privados",
                                  "subSteps": [
                                    "Altere a visibilidade de cada atributo público para 'private'.",
                                    "Verifique se há dependências diretas no código cliente que quebrarão com essa mudança.",
                                    "Compile o código para identificar erros imediatos de acesso negado.",
                                    "Ajuste temporariamente o código cliente para acessar via novos métodos (preparação).",
                                    "Salve uma versão intermediária do código."
                                  ],
                                  "verification": "Código compila sem erros de acesso a atributos e todos os atributos relevantes são private.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE com suporte a Java",
                                    "Código da classe do Step 1"
                                  ],
                                  "tips": "Use refactoring tools do IDE como 'Encapsulate Field' se disponível, mas faça manualmente para aprendizado.",
                                  "learningObjective": "Aplicar o princípio de encapsulamento tornando dados inacessíveis diretamente.",
                                  "commonMistakes": [
                                    "Esquecer de alterar todos os atributos",
                                    "Não compilar após mudanças"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar métodos getters",
                                  "subSteps": [
                                    "Crie um método getter para cada atributo private (ex: public String getNome() { return nome; }).",
                                    "Siga convenções de nomenclatura: get + nome do atributo, camelCase.",
                                    "Atualize o código cliente para usar getters em vez de acesso direto.",
                                    "Teste cada getter individualmente com prints ou asserts simples.",
                                    "Otimize getters se necessário (ex: lazy loading, mas mantenha simples)."
                                  ],
                                  "verification": "Todos os getters funcionam corretamente e código cliente usa-os sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE",
                                    "Código atualizado do Step 2",
                                    "JUnit para testes opcionais"
                                  ],
                                  "tips": "Getters devem ser simples e sem side-effects; retorne cópias imutáveis para objetos se aplicável.",
                                  "learningObjective": "Fornecer leitura controlada de dados encapsulados via getters.",
                                  "commonMistakes": [
                                    "Retornar referência mutável em vez de valor",
                                    "Nomenclatura incorreta (ex: getnome())"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar métodos setters e validar",
                                  "subSteps": [
                                    "Crie setters para atributos mutáveis (ex: public void setIdade(int idade) { if(idade > 0) this.idade = idade; }).",
                                    "Adicione validações básicas nos setters (ex: ranges, null checks).",
                                    "Atualize código cliente para usar setters.",
                                    "Teste setters com valores válidos e inválidos para verificar validações.",
                                    "Compare performance e funcionalidade antes/depois."
                                  ],
                                  "verification": "Setters aplicam validações corretamente e classe mantém integridade de dados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE",
                                    "Código com getters",
                                    "Casos de teste para validação"
                                  ],
                                  "tips": "Nem todos os atributos precisam de setters; use apenas quando modificação controlada é necessária.",
                                  "learningObjective": "Controlar escrita de dados com validação via setters.",
                                  "commonMistakes": [
                                    "Setters sem validação permitindo dados inválidos",
                                    "Expor this diretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar integralmente e comparar antes/depois",
                                  "subSteps": [
                                    "Execute testes completos na classe refatorada comparando com original.",
                                    "Verifique se comportamentos são idênticos ou melhorados (ex: rejeita dados inválidos).",
                                    "Gere relatórios ou diffs destacando mudanças (private, getters/setters).",
                                    "Refatore código cliente se necessário para melhor uso dos métodos.",
                                    "Documente lições aprendidas em comentários."
                                  ],
                                  "verification": "Classe refatorada passa todos os testes e demonstra encapsulamento efetivo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Testes unitários (JUnit)",
                                    "Ferramenta de diff (ex: Git diff)"
                                  ],
                                  "tips": "Use version control para comparar versões facilmente.",
                                  "learningObjective": "Validar refatoração e medir benefícios do encapsulamento.",
                                  "commonMistakes": [
                                    "Não testar cenários de borda",
                                    "Ignorar breaking changes no cliente"
                                  ]
                                }
                              ],
                              "practicalExample": "Classe original (sem encapsulamento):\npublic class Pessoa {\n  public String nome;\n  public int idade;\n}\n// Uso: Pessoa p = new Pessoa(); p.nome = 'João'; p.idade = -5;\nClasse refatorada:\npublic class Pessoa {\n  private String nome;\n  private int idade;\n  public String getNome() { return nome; }\n  public void setNome(String nome) { if(nome != null) this.nome = nome; }\n  public int getIdade() { return idade; }\n  public void setIdade(int idade) { if(idade > 0) this.idade = idade; }\n}\n// Uso: p.setNome('João'); p.setIdade(25); // Rejeita idade negativa.",
                              "finalVerifications": [
                                "Todos os atributos são private e acessíveis apenas via métodos.",
                                "Getters retornam valores corretos sem side-effects.",
                                "Setters validam entradas e mantêm integridade dos dados.",
                                "Código cliente foi atualizado e funciona sem erros.",
                                "Comparação antes/depois mostra redução de acoplamento.",
                                "Testes unitários passam para cenários válidos e inválidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de atributos a encapsular (100% cobertos).",
                                "Qualidade dos getters/setters: convenções seguidas e validações implementadas.",
                                "Funcionalidade preservada ou melhorada pós-refatoração.",
                                "Documentação clara de mudanças e testes.",
                                "Eficiência: tempo gasto alinhado com estimativas.",
                                "Criatividade em validações e otimizações."
                              ],
                              "crossCurricularConnections": [
                                "Design de Software: Princípios SOLID (Encapsulamento como base para Single Responsibility).",
                                "Segurança da Informação: Proteção de dados sensíveis contra acessos indevidos.",
                                "Matemática: Lógica de validação em setters (condicionais, ranges).",
                                "Gestão de Projetos: Refatoração como prática de manutenção de código legado.",
                                "Ética Profissional: Responsabilidade em manter código robusto e seguro."
                              ],
                              "realWorldApplication": "Em sistemas empresariais como bancos ou e-commerces, refatorar classes para getters/setters previne erros como saldos negativos ou nomes nulos, facilitando manutenção em equipes grandes e integrando com frameworks como Spring que exigem encapsulamento para injeção de dependências e serialização JSON segura."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.2.3.4",
                            "name": "Representar encapsulamento em UML",
                            "description": "Desenhar um diagrama de classe UML mostrando atributos privados (+ para públicos em getters/setters), conforme padrões UML.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos de encapsulamento e notação UML básica",
                                  "subSteps": [
                                    "Estude o encapsulamento: atributos privados acessíveis apenas via métodos públicos.",
                                    "Aprenda notação UML: retângulo dividido em nome da classe (topo), atributos (meio), métodos (base).",
                                    "Memorize visibilidade: - (privado), + (público), # (protegido).",
                                    "Identifique getters (getAtributo(): +tipo) e setters (setAtributo(tipo valor): +void).",
                                    "Anote exemplos simples de classes com encapsulamento."
                                  ],
                                  "verification": "Liste 3 exemplos de atributos privados e seus getters/setters com notação UML correta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Referência UML oficial (PDF ou site OMG)",
                                    "Bloco de notas",
                                    "Ferramenta online como draw.io"
                                  ],
                                  "tips": "Use cores para diferenciar seções da classe para melhor visualização.",
                                  "learningObjective": "Compreender como encapsulamento se reflete na notação UML.",
                                  "commonMistakes": [
                                    "Confundir visibilidade privada (-) com pública (+)",
                                    "Esquecer separadores de seção (---)",
                                    "Omitir tipo de retorno nos métodos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenhar a estrutura da classe com atributos privados",
                                  "subSteps": [
                                    "Desenhe o retângulo da classe com nome no topo (ex: Pessoa).",
                                    "Adicione atributos privados no meio: -nome: String, -idade: int.",
                                    "Use notação completa: visibilidade + nome + : + tipo.",
                                    "Verifique alinhamento e legibilidade.",
                                    "Adicione uma linha separadora entre atributos e métodos."
                                  ],
                                  "verification": "Desenhe uma classe com 2 atributos privados corretos e confirme com referência UML.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel milimetrado ou software UML (PlantUML, Lucidchart)",
                                    "Exemplos de diagramas UML"
                                  ],
                                  "tips": "Mantenha o diagrama simples; foque em precisão antes de complexidade.",
                                  "learningObjective": "Criar a seção de atributos privados com notação precisa.",
                                  "commonMistakes": [
                                    "Escrever atributos sem visibilidade",
                                    "Usar parênteses em atributos (só para métodos)",
                                    "Ignorar tipos de dados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar getters e setters públicos",
                                  "subSteps": [
                                    "Crie getter para cada atributo privado: +getNome(): String.",
                                    "Crie setter: +setNome(String nome): void.",
                                    "Posicione métodos na seção inferior com visibilidade +.",
                                    "Inclua parâmetros nos setters corretamente.",
                                    "Teste desenhando para múltiplos atributos."
                                  ],
                                  "verification": "O diagrama mostra getters/setters públicos acessando atributos privados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Mesma ferramenta UML do passo anterior",
                                    "Modelo de classe de exemplo"
                                  ],
                                  "tips": "Getters sem parâmetros; setters com parâmetro nomeado igual ao atributo.",
                                  "learningObjective": "Representar métodos públicos que encapsulam acesso privado.",
                                  "commonMistakes": [
                                    "Tornar getters/setters privados",
                                    "Esquecer :void nos setters",
                                    "Nomear parâmetros incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e refinar o diagrama completo",
                                  "subSteps": [
                                    "Revise todo o diagrama contra padrões UML 2.0.",
                                    "Adicione estereótipos se aplicável (<<class>>).",
                                    "Compare com exemplos reais de software.",
                                    "Exporte ou fotografe para portfólio.",
                                    "Identifique melhorias para clareza."
                                  ],
                                  "verification": "Uma pessoa externa confirma que o diagrama representa encapsulamento corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Checklist UML",
                                    "Ferramenta de validação UML online"
                                  ],
                                  "tips": "Use seta de dependência se houver relações, mas foque em classe isolada.",
                                  "learningObjective": "Garantir conformidade e profissionalismo no diagrama.",
                                  "commonMistakes": [
                                    "Sobrecarregar com detalhes desnecessários",
                                    "Ignorar convenções de nomenclatura (camelCase)",
                                    "Faltar itálico em abstratos (não aplicável aqui)"
                                  ]
                                }
                              ],
                              "practicalExample": "Classe BankAccount: Atributos -balance: double, -accountNumber: String. Métodos: +getBalance(): double, +setBalance(double amount): void, +getAccountNumber(): String, +deposit(double value): void. Diagrama mostra balance privado acessível só via métodos públicos.",
                              "finalVerifications": [
                                "Atributos usam - corretamente; métodos públicos usam +.",
                                "Getters retornam tipo correto sem parâmetros; setters têm parâmetro.",
                                "Estrutura de classe: 3 seções claras com separadores.",
                                "Nomes seguem convenções Java-like (camelCase).",
                                "Diagrama é legível e profissional.",
                                "Encapsulamento é evidente: nenhum acesso direto a privados."
                              ],
                              "assessmentCriteria": [
                                "Precisão da notação UML (visibilidade, seções): 30%",
                                "Correta representação de getters/setters: 25%",
                                "Clareza e legibilidade do diagrama: 20%",
                                "Ausência de erros comuns: 15%",
                                "Completude (todos elementos presentes): 10%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Uso de símbolos lógicos e notação formal.",
                                "Design Gráfico: Princípios de diagramação e hierarquia visual.",
                                "Linguagens: Modelagem conceitual similar a diagramas de Venn ou fluxogramas.",
                                "Negócios: Análise de requisitos para modelagem de sistemas empresariais."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, diagramas UML de classes com encapsulamento são usados em documentação de projetos (ex: apps bancários), revisões de código em equipes ágeis e ferramentas como Enterprise Architect para gerar código boilerplate automaticamente."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.3",
                    "name": "Herança em POO",
                    "description": "Capacidade de uma classe derivada herdar atributos e métodos de uma classe base, promovendo reutilização de código.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.3.1",
                        "name": "Classe Base e Classe Derivada",
                        "description": "Compreender os conceitos fundamentais de classe base (superclasse ou classe pai) e classe derivada (subclasse ou classe filha), que formam a base da herança, permitindo que a subclasse receba atributos e métodos da superclasse para reutilização de código.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.1.1",
                            "name": "Identificar classe base em um diagrama UML",
                            "description": "Analisar um diagrama de classes UML para identificar a seta de herança e distinguir a classe base da classe derivada, reconhecendo a relação 'é-um' (is-a).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar notação básica de diagramas de classes UML",
                                  "subSteps": [
                                    "Estude a estrutura de uma classe UML: nome da classe no topo, atributos no meio e métodos na base.",
                                    "Identifique os retângulos com divisões horizontais que representam classes.",
                                    "Observe exemplos simples de diagramas com múltiplas classes sem relações.",
                                    "Anote as convenções visuais: classes são caixas retangulares com linhas separadoras.",
                                    "Pratique desenhando uma classe simples como 'Veiculo' com atributos e métodos."
                                  ],
                                  "verification": "Desenhe ou identifique corretamente 3 classes UML básicas em um diagrama fornecido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta UML online como draw.io",
                                    "Exemplos de diagramas UML básicos"
                                  ],
                                  "tips": "Comece com diagramas simples para evitar sobrecarga visual.",
                                  "learningObjective": "Compreender a representação visual padrão de classes em UML.",
                                  "commonMistakes": [
                                    "Confundir atributos com métodos",
                                    "Ignorar as linhas separadoras nas caixas de classe"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a notação de herança em diagramas UML",
                                  "subSteps": [
                                    "Identifique a seta de herança: linha com seta triangular vazia apontando para a classe base.",
                                    "Memorize que a classe base (superclasse) está no destino da seta, e a derivada (subclasse) na origem.",
                                    "Estude a relação 'is-a': uma classe derivada 'é-um' tipo da classe base.",
                                    "Compare com seta de associação (linha simples) e composição (losango preenchido).",
                                    "Anote exemplos: 'Cachorro' herda de 'Animal' (Cachorro é-um Animal)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a direção da seta de herança em um diagrama exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagramas UML com herança destacada",
                                    "Vídeo tutorial curto sobre notação UML herança"
                                  ],
                                  "tips": "Visualize a seta como uma 'flecha de generalização' apontando para o 'pai' (classe base).",
                                  "learningObjective": "Reconhecer e interpretar a notação específica de herança UML.",
                                  "commonMistakes": [
                                    "Confundir direção da seta (base no início em vez do fim)",
                                    "Misturar com seta de dependência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar diagramas UML para identificar classes base e derivadas",
                                  "subSteps": [
                                    "Selecione um diagrama de classes UML com herança.",
                                    "Localize todas as setas triangulares vazias.",
                                    "Para cada seta, identifique: origem = classe derivada, destino = classe base.",
                                    "Valide a relação 'is-a' verbalizando: 'ClasseDerivada é-um ClasseBase'.",
                                    "Marque ou rotule as classes base em pelo menos 3 diagramas de prática."
                                  ],
                                  "verification": "Corretamente label as classes base em um diagrama teste com 80% de acerto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "5 diagramas UML de prática com soluções",
                                    "Ferramenta de edição UML"
                                  ],
                                  "tips": "Ignore outras relações inicialmente; foque apenas em setas de herança.",
                                  "learningObjective": "Aplicar conhecimento para distinguir classes base de derivadas em diagramas reais.",
                                  "commonMistakes": [
                                    "Rotular classe derivada como base",
                                    "Omitir múltiplas heranças em hierarquias"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e reforçar com exemplos variados",
                                  "subSteps": [
                                    "Analise diagramas com herança múltipla ou profunda.",
                                    "Crie seu próprio diagrama simples com 2-3 classes herdando de uma base.",
                                    "Explique para um par ou grave um vídeo identificando classes base.",
                                    "Resolva exercícios com diagramas embaralhados ou incompletos.",
                                    "Compare sua análise com soluções modelo."
                                  ],
                                  "verification": "Crie e analise um diagrama original, identificando corretamente todas as classes base.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Diagramas avançados UML",
                                    "Templates vazios para desenho"
                                  ],
                                  "tips": "Use cores para destacar: azul para base, verde para derivadas.",
                                  "learningObjective": "Consolidar habilidade através de prática ativa e autoavaliação.",
                                  "commonMistakes": [
                                    "Assumir herança sem seta explícita",
                                    "Confundir interfaces com classes base"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um diagrama UML com classes 'Animal' (atributos: nome, idade; métodos: comer()), 'Mamifero' herdando de 'Animal' (método adicional: amamentar()) e 'Cachorro' herdando de 'Mamifero' (método: latir()). A seta triangular aponta de 'Mamifero' para 'Animal' e de 'Cachorro' para 'Mamifero', identificando 'Animal' como classe base raiz.",
                              "finalVerifications": [
                                "Identifica corretamente a direção da seta de herança em qualquer diagrama UML.",
                                "Distinguir classe base (destino da seta) da derivada (origem).",
                                "Explica a relação 'is-a' para pelo menos 3 pares de classes.",
                                "Localiza classes base em hierarquias com múltiplas heranças.",
                                "Diferencia herança de outras relações UML como associação ou agregação.",
                                "Aplica em diagramas reais sem hesitação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação da seta de herança (100% correto).",
                                "Correta distinção entre classe base e derivada em todos os exemplos.",
                                "Explicação clara da relação 'is-a' com exemplos próprios.",
                                "Velocidade e confiança na análise de novos diagramas.",
                                "Ausência de confusão com outras notações UML.",
                                "Capacidade de criar diagramas válidos com herança."
                              ],
                              "crossCurricularConnections": [
                                "Biologia: Classificação taxonômica (espécies derivadas de gêneros base).",
                                "Matemática: Hierarquias e relações de subconjuntos (conjunto base e subconjuntos).",
                                "Linguística: Hierarquias semânticas (hiperônimos como classes base).",
                                "Design: Modelagem de sistemas com generalizações."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, identificar classes base em diagramas UML permite reutilizar código em projetos como sistemas de e-commerce (Produto base para Eletronico e Roupa derivadas), reduzindo redundâncias e facilitando manutenção em equipes de programação."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.2",
                            "name": "Definir atributos e métodos em classe base",
                            "description": "Criar uma classe base com atributos privados/públicos e métodos, utilizando encapsulamento, para servir como fundação para herança em linguagens como Python ou C++.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejar a estrutura da classe base",
                                  "subSteps": [
                                    "Identifique a entidade base para herança (ex: Animal para Mamifero).",
                                    "Liste 3-5 atributos necessários, classificando como públicos ou privados.",
                                    "Defina 3-4 métodos essenciais, incluindo getters/setters para encapsulamento.",
                                    "Esboce o diagrama UML simples da classe.",
                                    "Decida a linguagem (Python ou C++) e convenções (ex: _prefixo para private em Python)."
                                  ],
                                  "verification": "Verifique se o esboço inclui atributos, métodos e tipos de acesso corretos em um documento ou papel.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Referência de sintaxe Python/C++"
                                  ],
                                  "tips": "Comece com entidades reais do mundo para facilitar a modelagem hierárquica.",
                                  "learningObjective": "Compreender os componentes fundamentais de uma classe base para herança.",
                                  "commonMistakes": [
                                    "Confundir atributos de classe com instância",
                                    "Ignorar encapsulamento desde o planejamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a classe e seus atributos",
                                  "subSteps": [
                                    "Crie a declaração da classe (class NomeClasse: em Python).",
                                    "Adicione atributos públicos no __init__ (self.nome = nome).",
                                    "Adicione atributos privados (self._privado = valor ou private em C++).",
                                    "Inicialize todos os atributos no construtor.",
                                    "Teste instanciação básica da classe."
                                  ],
                                  "verification": "Instancie a classe e imprima atributos públicos; privados não devem ser acessíveis diretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE como VS Code ou PyCharm",
                                    "Python 3+ instalado"
                                  ],
                                  "tips": "Use self em Python para atributos de instância; sempre inicialize no __init__.",
                                  "learningObjective": "Implementar atributos com controle de acesso em uma classe base.",
                                  "commonMistakes": [
                                    "Esquecer 'self' em Python",
                                    "Tornar tudo público desnecessariamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar métodos com encapsulamento",
                                  "subSteps": [
                                    "Crie métodos públicos para lógica geral (ex: mover()).",
                                    "Adicione getters (get_privado()) e setters (set_privado(valor)) para privados.",
                                    "Inclua validação nos setters (ex: if valor > 0).",
                                    "Adicione um método para demonstrar uso (ex: info()).",
                                    "Garanta que métodos usem apenas APIs públicas."
                                  ],
                                  "verification": "Chame getters/setters e verifique se alteram privados corretamente sem acesso direto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Mesma IDE",
                                    "Documentação oficial Python/C++ sobre classes"
                                  ],
                                  "tips": "Encapsulamento protege dados; use propriedades @property em Python para simplicidade.",
                                  "learningObjective": "Aplicar encapsulamento via métodos para manter integridade da classe base.",
                                  "commonMistakes": [
                                    "Expor privados diretamente",
                                    "Falta de validação em setters"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar a classe base",
                                  "subSteps": [
                                    "Crie instâncias múltiplas e teste todos os métodos.",
                                    "Verifique encapsulamento tentando acessar privados diretamente (deve falhar ou alertar).",
                                    "Adicione asserts ou testes unitários simples.",
                                    "Documente a classe com docstrings.",
                                    "Prepare para herança testando super() em um stub derivado."
                                  ],
                                  "verification": "Todos os testes passam; classe é instanciável e métodos funcionam sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Unittest ou pytest para Python",
                                    "Console/terminal para execução"
                                  ],
                                  "tips": "Escreva testes primeiro (TDD) para garantir robustez.",
                                  "learningObjective": "Validar que a classe base está pronta para extensão via herança.",
                                  "commonMistakes": [
                                    "Não testar casos de borda em setters",
                                    "Esquecer docstrings"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python, crie class Veiculo: com atributos publico 'modelo' e privado '_velocidade_max'. Métodos: acelerar(delta), get_velocidade_max(), set_velocidade_max(nova_vel). Teste: v = Veiculo('Fusca', 120); v.acelerar(10); print(v.get_velocidade_max()) == 130.",
                              "finalVerifications": [
                                "Classe instancia sem erros e atributos são inicializados.",
                                "Atributos privados não acessíveis diretamente (AttributeError ou warning).",
                                "Getters/setters funcionam com validação.",
                                "Métodos públicos executam corretamente.",
                                "Classe preparada para herança (chamada super() possível).",
                                "Código documentado com docstrings."
                              ],
                              "assessmentCriteria": [
                                "Correta declaração de atributos públicos/privados (100%).",
                                "Encapsulamento completo via métodos (sem acesso direto a privados).",
                                "Validação em setters e lógica em métodos (80% cobertura).",
                                "Testes unitários passam para todos métodos (100%).",
                                "Código limpo, legível e comentado.",
                                "Preparação explícita para herança."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstração e modelagem hierárquica (árvores de herança como grafos).",
                                "Biologia: Classificação taxonômica (classes base como gêneros).",
                                "Design/Engenharia: Modelagem de sistemas modulares (blueprints).",
                                "Lógica: Princípios de encapsulamento como black-box.",
                                "Física: Simulações com classes base (ex: Particula para Colisao)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, classes base como 'Usuario' em apps web (Django/Flask) servem de fundação para 'AdminUsuario' ou 'ClienteUsuario', garantindo código reutilizável, manutenção fácil e segurança de dados em sistemas bancários ou e-commerce."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.3",
                            "name": "Criar instância de classe derivada",
                            "description": "Instanciar uma classe derivada e verificar que ela herda e acessa atributos e métodos da classe base sem redefinição.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a classe base com atributos e métodos essenciais",
                                  "subSteps": [
                                    "Escolha uma linguagem de POO como Python.",
                                    "Crie uma classe base, por exemplo, 'Animal', com um atributo privado ou público (ex: nome) e um método (ex: fazer_som()).",
                                    "Implemente o construtor (__init__) para inicializar atributos.",
                                    "Adicione um método simples que retorne ou modifique o atributo.",
                                    "Salve o código em um arquivo .py."
                                  ],
                                  "verification": "Execute o código da classe base isoladamente e confirme que instâncias dela funcionam corretamente, acessando atributos e métodos sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, PyCharm)",
                                    "Interpretador Python instalado"
                                  ],
                                  "tips": "Mantenha a classe base simples para focar na herança; use print() para depuração rápida.",
                                  "learningObjective": "Compreender a estrutura básica de uma classe para servir como base para herança.",
                                  "commonMistakes": [
                                    "Esquecer o construtor __init__",
                                    "Definir atributos como privados sem getter/setter acessível"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar a classe derivada herdando da classe base",
                                  "subSteps": [
                                    "Declare a classe derivada (ex: 'Cao') usando sintaxe de herança (class Cao(Animal):).",
                                    "Chame o construtor da superclasse no __init__ da derivada usando super().__init__().",
                                    "Adicione um atributo específico da derivada (ex: raca) sem redefinir atributos da base.",
                                    "Opcionalmente, adicione um método sobrescrito, mas evite redefinições desnecessárias.",
                                    "Certifique-se de não duplicar código da base."
                                  ],
                                  "verification": "Analise o código-fonte: confirme a palavra-chave de herança e chamada super() sem redefinições de membros da base.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Mesmo arquivo .py da classe base",
                                    "Documentação de POO da linguagem escolhida"
                                  ],
                                  "tips": "Sempre use super() para evitar problemas em hierarquias múltiplas; teste sintaxe com pylint ou linter.",
                                  "learningObjective": "Implementar herança corretamente, garantindo acesso aos membros da superclasse.",
                                  "commonMistakes": [
                                    "Esquecer super().__init__() levando a atributos não inicializados",
                                    "Redefinir métodos da base desnecessariamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Instanciar a classe derivada e inicializar",
                                  "subSteps": [
                                    "Crie uma instância da classe derivada (ex: meu_cachorro = Cao('Rex', 'Labrador')).",
                                    "Passe argumentos corretos para o construtor, incluindo os da superclasse.",
                                    "Use print() para exibir atributos herdados e específicos.",
                                    "Execute o código e observe a saída.",
                                    "Salve e rode o script completo."
                                  ],
                                  "verification": "A instância é criada sem erros de sintaxe ou TypeError, e atributos da base são acessíveis via objeto derivado.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Terminal ou IDE com execução Python"
                                  ],
                                  "tips": "Use variáveis descritivas para instâncias; rode em modo interativo (REPL) para testes rápidos.",
                                  "learningObjective": "Criar objetos de classes derivadas que herdam comportamento da base.",
                                  "commonMistakes": [
                                    "Argumentos errados no construtor",
                                    "Tentativa de acessar atributos privados diretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar herança acessando atributos e métodos da base",
                                  "subSteps": [
                                    "Acesse atributos herdados (ex: print(meu_cachorro.nome)).",
                                    "Chame métodos da superclasse (ex: meu_cachorro.fazer_som()).",
                                    "Compare com instância da base para confirmar comportamento idêntico onde não sobrescrito.",
                                    "Adicione asserts ou testes unitários simples para validação.",
                                    "Registre saídas em log ou console."
                                  ],
                                  "verification": "Todos acessos a membros herdados funcionam sem AttributeError, e outputs confirmam herança.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Biblioteca unittest do Python (opcional)"
                                  ],
                                  "tips": "Use isinstance(obj, Animal) para verificar hierarquia; documente testes em comentários.",
                                  "learningObjective": "Validar empiricamente que a derivada herda sem redefinição desnecessária.",
                                  "commonMistakes": [
                                    "Sobrescrever métodos acidentalmente",
                                    "Confundir nomes de atributos entre classes"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e depurar a herança completa",
                                  "subSteps": [
                                    "Crie múltiplas instâncias de derivada com variações.",
                                    "Execute cenários de borda (ex: atributos vazios).",
                                    "Use debugger ou print statements para rastrear chamadas.",
                                    "Confirme ausência de redefinições comparando códigos.",
                                    "Refatore se necessário e reteste."
                                  ],
                                  "verification": "Testes passam 100%, sem warnings de herança quebrada; código limpo e documentado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramentas de debug (pdb, IDE debugger)"
                                  ],
                                  "tips": "Escreva testes primeiro (TDD mindset); versione com Git para rastrear mudanças.",
                                  "learningObjective": "Garantir robustez da herança através de testes abrangentes.",
                                  "commonMistakes": [
                                    "Ignorar erros de runtime em herança",
                                    "Não testar múltiplas instâncias"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python:\nclass Animal:\n    def __init__(self, nome):\n        self.nome = nome\n    def fazer_som(self):\n        return 'Som genérico'\n\nclass Cao(Animal):\n    def __init__(self, nome, raca):\n        super().__init__(nome)\n        self.raca = raca\n    def fazer_som(self):\n        return 'Au au!'\n\nmeu_cao = Cao('Rex', 'Labrador')\nprint(meu_cao.nome)  # Herda: Rex\nprint(meu_cao.fazer_som())  # Sobrescrito: Au au!",
                              "finalVerifications": [
                                "Instância da derivada criada sem erros.",
                                "Atributos da base acessíveis via objeto derivado.",
                                "Métodos da base executam corretamente se não sobrescritos.",
                                "Uso de super() confirmado no código.",
                                "Nenhuma redefinição desnecessária de membros da base.",
                                "Testes com múltiplas instâncias passam.",
                                "isinstance(derivada, base) retorna True."
                              ],
                              "assessmentCriteria": [
                                "Código sintaticamente correto e executável.",
                                "Herança implementada com super() ou equivalente.",
                                "Acesso correto a membros herdados sem erros.",
                                "Sem duplicação de código da base.",
                                "Testes/verificação demonstram herança funcional.",
                                "Código limpo, comentado e eficiente."
                              ],
                              "crossCurricularConnections": [
                                "Biologia: Hierarquias taxonômicas (espécie herda gênero).",
                                "Matemática: Relações hierárquicas em conjuntos e subconjuntos.",
                                "Design: Princípios de reutilização em modelagem UML.",
                                "Física: Modelos de partículas elementares e compostas."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, como em jogos (Personagem herda de Entidade para reutilizar física básica) ou sistemas bancários (ContaPoupanca herda de Conta para compartilhar saldo e transações sem duplicação)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.2",
                        "name": "Declaração e Sintaxe de Herança",
                        "description": "Dominar a sintaxe para declarar herança em linguagens orientadas a objetos, promovendo a extensão de classes base por classes derivadas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.2.1",
                            "name": "Escrever sintaxe de herança em Python",
                            "description": "Utilizar a sintaxe 'class Filho(Pai):' para declarar uma classe derivada que herda todos os atributos e métodos públicos da classe base em Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Criar uma Classe Base Simples",
                                  "subSteps": [
                                    "Defina uma classe pai básica com o nome 'Animal'.",
                                    "Adicione um atributo simples, como 'nome', no método __init__.",
                                    "Inclua um método público 'falar' que imprima uma mensagem genérica.",
                                    "Salve o código em um arquivo .py e execute para verificar sem erros.",
                                    "Teste instanciando um objeto Animal e chamando o método falar."
                                  ],
                                  "verification": "Execute o código e confirme que uma instância de Animal imprime 'Som genérico' sem erros de sintaxe.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Python 3.x instalado",
                                    "Terminal ou IDE com interpretador"
                                  ],
                                  "tips": "Mantenha a classe pai simples para focar na herança, evitando complexidades desnecessárias.",
                                  "learningObjective": "Compreender e implementar uma classe base funcional para servir de fundação à herança.",
                                  "commonMistakes": [
                                    "Esquecer o 'self' nos métodos",
                                    "Erro de indentação no __init__",
                                    "Não chamar super() se necessário, mas aqui é opcional"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever a Sintaxe de Herança para a Classe Derivada",
                                  "subSteps": [
                                    "Declare uma nova classe chamada 'Cachorro' imediatamente após a classe Animal.",
                                    "Use a sintaxe exata: class Cachorro(Animal): garantindo parênteses após Animal.",
                                    "Adicione dois pontos (:) ao final da declaração da classe.",
                                    "No corpo da classe, chame super().__init__(self, nome) no __init__ da filha.",
                                    "Copie o método __init__ da pai adaptado para a filha."
                                  ],
                                  "verification": "Analise o código: confirme presença de 'class Cachorro(Animal):' com parênteses e dois pontos, sem erros de parser.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Mesmo editor e Python do step anterior",
                                    "Documentação Python OOP (opcional)"
                                  ],
                                  "tips": "Sempre coloque o nome da classe pai entre parênteses logo após o nome da classe filha para ativar a herança.",
                                  "learningObjective": "Dominar a sintaxe precisa 'class Filho(Pai):' para declarar herança corretamente.",
                                  "commonMistakes": [
                                    "Esquecer os parênteses após o nome da pai",
                                    "Usar vírgula em vez de parênteses",
                                    "Colocar o nome da pai sem aspas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Método na Classe Filha e Testar Herança",
                                  "subSteps": [
                                    "Adicione um método 'falar' na classe Cachorro que override o da pai, imprimindo 'Au au!'.",
                                    "Fora das classes, crie uma instância de Cachorro com nome 'Rex'.",
                                    "Chame o método falar() na instância e verifique a saída 'Au au!'.",
                                    "Teste herança chamando um atributo ou método da pai se disponível.",
                                    "Execute o script completo e capture a saída no terminal."
                                  ],
                                  "verification": "Instância de Cachorro() executa sem erros e chama corretamente métodos herdados ou override.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Python REPL ou terminal para testes interativos"
                                  ],
                                  "tips": "Use print statements para debugar e confirmar qual método está sendo chamado.",
                                  "learningObjective": "Verificar que a classe filha herda atributos e pode override métodos da base.",
                                  "commonMistakes": [
                                    "Não usar super() no __init__ da filha, causando perda de herança",
                                    "Erro de indentação no override",
                                    "Chamar método errado na instância"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Refinar e Validar a Herança Completa",
                                  "subSteps": [
                                    "Adicione um atributo único na classe Cachorro, como 'raca'.",
                                    "Crie uma lista de objetos mistos [Animal(), Cachorro()] e itere chamando falar().",
                                    "Use isinstance() para verificar se Cachorro é instância de Animal (deve retornar True).",
                                    "Corrija qualquer erro de sintaxe ou runtime identificado.",
                                    "Documente o código com comentários explicando a herança."
                                  ],
                                  "verification": "isinstance(cachorro, Animal) retorna True e polimorfismo funciona na lista.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor com suporte a linting (Pylint)",
                                    "Python docs para isinstance"
                                  ],
                                  "tips": "Teste com isinstance() para provar herança conceitualmente além da execução.",
                                  "learningObjective": "Consolidar o entendimento de herança através de testes avançados e polimorfismo básico.",
                                  "commonMistakes": [
                                    "Confundir herança com composição",
                                    "Não testar herança com isinstance",
                                    "Expor atributos privados acidentalmente"
                                  ]
                                }
                              ],
                              "practicalExample": "```python\nclass Animal:\n    def __init__(self, nome):\n        self.nome = nome\n    def falar(self):\n        print('Som genérico')\n\nclass Cachorro(Animal):\n    def __init__(self, nome, raca):\n        super().__init__(nome)\n        self.raca = raca\n    def falar(self):\n        print(f'{self.nome} diz: Au au!')\n\nrex = Cachorro('Rex', 'Labrador')\nrex.falar()  # Saída: Rex diz: Au au!\nprint(isinstance(rex, Animal))  # True\n```",
                              "finalVerifications": [
                                "Código executa sem erros de sintaxe ou runtime.",
                                "Instância da classe filha acessa atributos/métodos da pai.",
                                "Método override na filha funciona corretamente.",
                                "isinstance(filha, pai) retorna True.",
                                "Polimorfismo básico: lista de objetos pai e filha chama métodos corretamente.",
                                "Atributos únicos da filha são acessíveis."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe exata: 'class Filho(Pai):' com parênteses e dois pontos.",
                                "Uso correto de super() no __init__ da filha.",
                                "Indentação consistente em todo o código.",
                                "Herança comprovada via acesso a membros da pai.",
                                "Ausência de erros comuns como esquecer self ou parênteses.",
                                "Comentários explicando a herança."
                              ],
                              "crossCurricularConnections": [
                                "Biologia: Hierarquia de classificação taxonômica (Reino > Filo > Classe).",
                                "Matemática: Relações hierárquicas e conjuntos (subconjuntos herdando propriedades).",
                                "Design Gráfico: Sistemas de camadas e herança em ferramentas como Adobe (shapes base > derivados).",
                                "Linguagens Naturais: Analogia com sinônimos e hipônimos em linguística."
                              ],
                              "realWorldApplication": "Na indústria de software, herança é usada em frameworks como Django (Model herda de models.Model) para reutilizar funcionalidades comuns, em jogos (classe Personagem herda para Heroi/Vilao) e em bibliotecas como scikit-learn (estimadores base para modelos específicos), reduzindo código duplicado e promovendo manutenção escalável."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.2.2",
                            "name": "Implementar herança simples em C++",
                            "description": "Declarar herança pública com 'class Derivada : public Base {};' em C++, garantindo acesso aos membros herdados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Criar a classe base com membros acessíveis",
                                  "subSteps": [
                                    "Defina uma classe base simples, como 'Animal', com um membro público (ex: função greet()).",
                                    "Adicione um membro protegido (protected) para demonstração de acesso na derivada.",
                                    "Inclua um construtor simples na classe base.",
                                    "Salve o código em um arquivo .h ou diretamente no .cpp para teste.",
                                    "Compile para verificar que a classe base funciona isoladamente."
                                  ],
                                  "verification": "Compilar o código da classe base sem erros e instanciar um objeto que chama greet().",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador C++ (g++ ou IDE como Visual Studio Code com C++ extension)",
                                    "Editor de texto ou IDE"
                                  ],
                                  "tips": "Use #include <iostream> e namespace std; para simplicidade inicial.",
                                  "learningObjective": "Entender como definir uma classe base com visibilidades pública e protegida.",
                                  "commonMistakes": [
                                    "Esquecer ponto e vírgula após a declaração da classe.",
                                    "Confundir public com private ao definir membros.",
                                    "Não incluir construtor padrão."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar a classe derivada com herança pública",
                                  "subSteps": [
                                    "Escreva 'class Derivada : public Base { };' logo após a classe base.",
                                    "Adicione um construtor na derivada que chama o construtor da base com : Base().",
                                    "Declare um membro público na derivada, como uma função que acessa o membro da base.",
                                    "Feche a classe corretamente com chaves e ponto e vírgula.",
                                    "Verifique a sintaxe no editor para highlights de erro."
                                  ],
                                  "verification": "O código compila sem erros de sintaxe na declaração de herança.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Mesmo compilador e IDE do step anterior",
                                    "Referência de sintaxe C++ (cppreference.com)"
                                  ],
                                  "tips": "Sempre use 'public' para herança pública se quiser acessar membros públicos da base como públicos na derivada.",
                                  "learningObjective": "Dominar a sintaxe exata de declaração de herança pública em C++.",
                                  "commonMistakes": [
                                    "Omitir ': public Base'.",
                                    "Usar private ou protected em vez de public na herança.",
                                    "Esquecer o ponto e vírgula após a classe derivada."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar acesso a membros herdados na derivada",
                                  "subSteps": [
                                    "Na função membro da derivada, chame uma função pública da base diretamente (ex: base_greet()).",
                                    "Acesse um membro protegido da base dentro da derivada.",
                                    "Adicione uma função main() para instanciar a derivada e chamar seus métodos.",
                                    "Use cout para imprimir resultados e demonstrar herança.",
                                    "Teste chamadas que confirmem herança (ex: derivada chama base)."
                                  ],
                                  "verification": "Executar o programa e ver saídas que mostram acesso correto aos membros da base.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador g++",
                                    "Terminal para execução (g++ main.cpp -o main && ./main)"
                                  ],
                                  "tips": "Membros públicos da base são acessíveis diretamente; protected só dentro da hierarquia.",
                                  "learningObjective": "Garantir que a herança permita acesso correto aos membros da base.",
                                  "commonMistakes": [
                                    "Tentar acessar membros private da base.",
                                    "Não chamar construtor da base no da derivada.",
                                    "Erro de escopo ao referenciar base."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compilar, testar e depurar o código completo",
                                  "subSteps": [
                                    "Compile o arquivo completo com g++ ou IDE.",
                                    "Execute e verifique saídas esperadas.",
                                    "Introduza um erro intencional (ex: herança private) e corrija.",
                                    "Adicione comentários explicando cada parte da herança.",
                                    "Salve uma versão funcional para portfolio."
                                  ],
                                  "verification": "Programa roda sem erros, demonstra herança e acesso a membros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Terminal ou IDE debugger",
                                    "Exemplo de código comentado"
                                  ],
                                  "tips": "Use -Wall no g++ para warnings extras.",
                                  "learningObjective": "Validar a implementação de herança através de testes práticos.",
                                  "commonMistakes": [
                                    "Erros de linking se classes em arquivos separados.",
                                    "Não flush cout com endl.",
                                    "Ignorar warnings do compilador."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie classe Animal { public: void greet() { cout << 'Sou um animal'; } protected: string name; }; então class Dog : public Animal { public: Dog() : Animal() { name = 'Rex'; } void bark() { cout << name << ' late!'; greet(); } }; No main: Dog d; d.bark(); // Saída: Rex late! Sou um animal",
                              "finalVerifications": [
                                "Código compila sem erros ou warnings relacionados a herança.",
                                "Objeto derivado acessa e executa membros públicos da base.",
                                "Membros protegidos da base são acessíveis apenas na derivada.",
                                "Construtor da derivada inicializa corretamente a base.",
                                "Programa produz saída esperada demonstrando herança.",
                                "Nenhum acesso indevido a membros private da base."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe de herança pública correta (: public Base).",
                                "Acesso apropriado a membros herdados (públicos e protegidos).",
                                "Uso correto de construtores em cadeia.",
                                "Código limpo, compilável e executável.",
                                "Demonstração prática de polimorfismo básico via herança.",
                                "Comentários explicando o mecanismo de herança."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Hierarquias e relações de subconjuntos (conjuntos de Venn).",
                                "Biologia: Classificação taxonômica (espécie herda gênero).",
                                "Design: Princípios de modelagem hierárquica em UML.",
                                "Lógica: Conceitos de extensão e especialização de entidades."
                              ],
                              "realWorldApplication": "Em desenvolvimento de jogos, classe Enemy herda de Character para reutilizar movimento e vida, adicionando ataques específicos; economiza código e promove reutilização em grandes sistemas como engines de software ou frameworks empresariais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.2.3",
                            "name": "Verificar herança via isinstance em Python",
                            "description": "Usar a função isinstance(objeto, ClasseBase) para confirmar que uma instância de classe derivada é considerada uma instância da classe base.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de herança em POO",
                                  "subSteps": [
                                    "Estude a definição de herança: uma classe derivada (subclasse) herda atributos e métodos da classe base (superclasse).",
                                    "Analise exemplos simples de declaração de herança em Python usando 'class Subclasse(Base):'.",
                                    "Entenda a relação 'é-um' (is-a): um objeto de subclasse 'é-um' objeto da superclasse.",
                                    "Diferencie herança de composição e agregação.",
                                    "Leia a documentação oficial do Python sobre classes e herança."
                                  ],
                                  "verification": "Resuma em suas palavras o que significa herança e forneça um exemplo de código simples com uma superclasse e subclasse.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código Python (ex: VS Code, PyCharm)",
                                    "Documentação Python: https://docs.python.org/3/tutorial/classes.html#inheritance"
                                  ],
                                  "tips": "Use diagramas de classes (UML) para visualizar a hierarquia de herança.",
                                  "learningObjective": "Compreender a base conceitual da herança para contextualizar o uso de isinstance.",
                                  "commonMistakes": [
                                    "Confundir herança com instanciamento de objetos.",
                                    "Ignorar que herança permite polimorfismo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a sintaxe e funcionamento de isinstance()",
                                  "subSteps": [
                                    "Memorize a sintaxe: isinstance(objeto, classe) retorna True se objeto é instância de classe ou subclasse.",
                                    "Compare com type(objeto) == Classe, destacando que isinstance aceita herança.",
                                    "Teste em REPL Python: isinstance(5, int) deve ser True.",
                                    "Explore isinstance com tuplas: isinstance(objeto, (Classe1, Classe2)).",
                                    "Estude casos onde retorna False: instância de classe não relacionada."
                                  ],
                                  "verification": "Execute isinstance em um objeto simples e explique o resultado em um comentário no código.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Interpretador Python interativo (REPL)",
                                    "Notebook Jupyter para testes rápidos"
                                  ],
                                  "tips": "Sempre passe a classe como segundo argumento, não uma instância.",
                                  "learningObjective": "Dominar a sintaxe e comportamento de isinstance para verificação de tipos hierárquicos.",
                                  "commonMistakes": [
                                    "Usar type() em vez de isinstance para herança.",
                                    "Passar string em vez de referência de classe."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar exemplo prático com classes hierárquicas",
                                  "subSteps": [
                                    "Crie uma classe base 'Animal' com método 'falar()'.",
                                    "Defina uma subclasse 'Cachorro' que herda de Animal e sobrescreve 'falar()'.",
                                    "Instancie um objeto 'cachorro = Cachorro()'.",
                                    "Use print(isinstance(cachorro, Animal)) e confirme True.",
                                    "Teste isinstance(cachorro, Cachorro) == True e isinstance(cachorro, str) == False."
                                  ],
                                  "verification": "Execute o código e capture saídas mostrando True para superclasse e subclasse.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor Python com terminal integrado",
                                    "Arquivo .py para salvar o exemplo"
                                  ],
                                  "tips": "Adicione prints nos métodos para depurar e visualizar chamadas polimórficas.",
                                  "learningObjective": "Aplicar isinstance em um cenário real de herança simples.",
                                  "commonMistakes": [
                                    "Esquecer dois pontos após class Subclasse(Base).",
                                    "Não instanciar corretamente o objeto."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar cenários avançados e depuração",
                                  "subSteps": [
                                    "Crie herança múltipla: class AveReptil(Passaro, Reptil):",
                                    "Teste isinstance com superclasses múltiplas.",
                                    "Verifique casos negativos: isinstance(cachorro, Gato) == False.",
                                    "Use isinstance em funções genéricas para type checking seguro.",
                                    "Adicione try-except para erros comuns e logs de depuração."
                                  ],
                                  "verification": "Escreva uma função que aceite 'Animal' e use isinstance para validar entrada, testando com sucessos e falhas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Mesmo editor e REPL do passo anterior",
                                    "Pytest para testes unitários opcionais"
                                  ],
                                  "tips": "Prefira isinstance sobre duck typing em código legível e robusto.",
                                  "learningObjective": "Lidar com edge cases e integrar isinstance em código prático.",
                                  "commonMistakes": [
                                    "Assumir que isinstance ignora herança múltipla (não ignora).",
                                    "Não testar classes não relacionadas."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie class Veiculo com metodo mover(). Subclasse Carro(Veiculo): def mover(self): print('Carro se move'). carro = Carro(). assert isinstance(carro, Veiculo) == True. Isso confirma herança sem quebrar polimorfismo.",
                              "finalVerifications": [
                                "isinstance(instancia_sub, ClasseBase) retorna True.",
                                "isinstance(instancia_base, ClasseSub) retorna False.",
                                "isinstance com herança múltipla reconhece todas as bases.",
                                "Função genérica usa isinstance para validar argumentos.",
                                "Código roda sem erros em REPL ou script.",
                                "Explicação escrita diferencia isinstance de type()."
                              ],
                              "assessmentCriteria": [
                                "Código sintaticamente correto e executável.",
                                "Uso preciso de isinstance com herança demonstrado.",
                                "Testes cobrem casos positivos e negativos.",
                                "Explicações claras nos comentários.",
                                "Eficiência: sem loops ou condicionais desnecessários.",
                                "Boas práticas: nomes descritivos e indentação correta."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Verificação de subconjuntos em teoria de conjuntos.",
                                "Biologia: Hierarquias de classificação taxonômica (gênero > espécie).",
                                "Design de Software: Princípios SOLID, especialmente Liskov Substitution.",
                                "Lógica: Provas de 'é-um' em raciocínio dedutivo."
                              ],
                              "realWorldApplication": "Em frameworks como Django ou Flask, verificar se um modelo é instância de uma base abstrata antes de processar queries; em bibliotecas de ML como scikit-learn, validar tipos de dados hierárquicos para pipelines robustos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.3",
                        "name": "Sobrescrita de Métodos e Chamada à Superclasse",
                        "description": "Aplicar sobrescrita (override) de métodos herdados e invocar métodos da superclasse para estender comportamentos, mantendo a reutilização de código.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.3.1",
                            "name": "Sobrescrever método na classe derivada",
                            "description": "Redefinir um método herdado na classe derivada com a mesma assinatura, alterando seu comportamento específico sem quebrar a herança.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o método na superclasse",
                                  "subSteps": [
                                    "Identifique a superclasse e localize o método a ser sobrescrito.",
                                    "Verifique a assinatura do método: nome, parâmetros, tipo de retorno e modificadores de acesso.",
                                    "Entenda o comportamento atual do método na superclasse.",
                                    "Anote se o método é protegido ou público para permitir sobrescrita.",
                                    "Compile e teste a superclasse isoladamente para confirmar funcionamento."
                                  ],
                                  "verification": "O método na superclasse compila e executa corretamente sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de código (VS Code, IntelliJ), compilador Java/Python (JDK, Python 3+)",
                                  "tips": "Use @Override annotation em Java para evitar erros de digitação na assinatura.",
                                  "learningObjective": "Compreender a estrutura exata do método herdado para replicá-la corretamente.",
                                  "commonMistakes": "Ignorar modificadores de acesso ou tipos de parâmetros, causando erros de compilação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar a classe derivada e declarar a sobrescrita",
                                  "subSteps": [
                                    "Defina a classe derivada estendendo a superclasse com 'extends'.",
                                    "Declare o método com a mesma assinatura exata da superclasse.",
                                    "Adicione a anotação @Override (em Java) ou equivalente para documentar a intenção.",
                                    "Ajuste o modificador de acesso se necessário (não pode ser mais restritivo).",
                                    "Compile a classe derivada para verificar herança e assinatura."
                                  ],
                                  "verification": "A classe derivada compila sem erros de sobrescrita inválida.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código, compilador, documentação da linguagem (Java Docs ou Python PEP)",
                                  "tips": "Sempre use a mesma assinatura para polimorfismo funcionar corretamente.",
                                  "learningObjective": "Estabelecer a herança e preparar o método sobrescrito com assinatura idêntica.",
                                  "commonMistakes": "Alterar acidentalmente parâmetros ou tipo de retorno, quebrando a sobrescrita."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar comportamento específico e chamar superclasse se necessário",
                                  "subSteps": [
                                    "Escreva o novo corpo do método com lógica específica da subclasse.",
                                    "Use 'super.nomeDoMetodo()' para chamar a implementação da superclasse quando útil.",
                                    "Adicione lógica condicional ou personalizada para diferenciar o comportamento.",
                                    "Teste unitariamente o método isolado na subclasse.",
                                    "Refatore para otimizar performance ou legibilidade."
                                  ],
                                  "verification": "O método executa o novo comportamento e opcionalmente integra o da superclasse.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código, framework de testes (JUnit para Java, pytest para Python)",
                                  "tips": "Chame super() no início ou fim para estender, não substituir completamente.",
                                  "learningObjective": "Personalizar o comportamento herdado mantendo compatibilidade.",
                                  "commonMistakes": "Esquecer de chamar super() quando necessário, perdendo funcionalidade base."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar polimorfismo e integração",
                                  "subSteps": [
                                    "Crie instâncias de superclasse e subclasse.",
                                    "Use referência da superclasse para chamar o método em objetos da subclasse.",
                                    "Verifique se o comportamento polimórfico ocorre corretamente.",
                                    "Execute testes com cenários variados (bordas, erros).",
                                    "Documente o código com comentários sobre a sobrescrita."
                                  ],
                                  "verification": "Chamadas polimórficas executam o método da subclasse corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código, ferramentas de teste, debugger",
                                  "tips": "Use debugger para inspecionar qual método é chamado em runtime.",
                                  "learningObjective": "Validar que a sobrescrita funciona em contextos polimórficos.",
                                  "commonMistakes": "Testar apenas instâncias diretas, ignorando polimorfismo."
                                }
                              ],
                              "practicalExample": "Em Java: classe Animal { public void makeSound() { System.out.println('Som genérico'); } } classe Cachorro extends Animal { @Override public void makeSound() { super.makeSound(); System.out.println('Au au!'); } } Ao chamar animal.makeSound() com Cachorro, imprime 'Som genérico Au au!'.",
                              "finalVerifications": [
                                "Compilação sem erros de assinatura ou acesso.",
                                "Comportamento específico executa corretamente na subclasse.",
                                "Chamada a super() integra funcionalidades quando aplicável.",
                                "Polimorfismo funciona via referência da superclasse.",
                                "Testes unitários passam em todos os cenários.",
                                "Código documentado com @Override e comentários."
                              ],
                              "assessmentCriteria": [
                                "Assinatura do método idêntica à superclasse (100% match).",
                                "Comportamento alterado corretamente sem quebrar herança.",
                                "Uso apropriado de super() para extensão.",
                                "Demonstração de polimorfismo em testes.",
                                "Código limpo, testado e documentado.",
                                "Tempo de execução otimizado e sem erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Biologia: Herança genética, onde traços são 'sobrescritos' em subespécies.",
                                "Design de Software: Padrões como Template Method.",
                                "Matemática: Funções polimórficas em álgebra abstrata.",
                                "Lógica: Raciocínio dedutivo em hierarquias."
                              ],
                              "realWorldApplication": "Em jogos, classe Veiculo com mover(); Carro extends Veiculo sobrescreve mover() para simular tração 4x4, permitindo que um motor de jogo trate todos veículos polimorficamente sem código duplicado."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.3.2",
                            "name": "Usar super() para chamar método da base",
                            "description": "Em Python, invocar super().__init__() ou super().metodo() no construtor ou método sobrescrito para executar o código da superclasse antes ou após customizações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito e necessidade de super() em herança",
                                  "subSteps": [
                                    "Revise classes base e derivadas: crie uma classe base simples (ex: Animal) com __init__ que define atributos como nome e idade.",
                                    "Crie uma subclasse (ex: Cachorro) sem super(): observe que atributos da base não são inicializados.",
                                    "Execute o código e identifique erros ou comportamentos inesperados, como atributos None.",
                                    "Leia documentação oficial do Python sobre super() para entender que ele chama métodos da superclasse dinamicamente.",
                                    "Anote em um caderno: 'super() garante execução do código da superclasse em herança.'"
                                  ],
                                  "verification": "Resuma em 2 frases o que acontece sem super() e por que usá-lo; confira se menciona inicialização correta de atributos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Python 3.8+ instalado",
                                    "Documentação Python: super()"
                                  ],
                                  "tips": "Sempre pense na 'cadeia de herança': super() segue a ordem MRO (Method Resolution Order).",
                                  "learningObjective": "Explicar o papel de super() na preservação do comportamento da superclasse durante sobrescrita.",
                                  "commonMistakes": [
                                    "Confundir super() com chamada direta como ClasseBase().__init__(self)",
                                    "Ignorar que sem super() a inicialização da base é perdida"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar super() no construtor __init__",
                                  "subSteps": [
                                    "Na subclasse Cachorro, adicione super().__init__(nome, idade) no início do __init__.",
                                    "Adicione atributos específicos da subclasse após a chamada super(), como raca.",
                                    "Teste instanciando Cachorro('Rex', 5, 'Labrador') e imprima atributos para verificar inicialização completa.",
                                    "Adicione print statements em ambos __init__ para ver ordem de execução.",
                                    "Refatore para usar *args, **kwargs em super() para flexibilidade futura."
                                  ],
                                  "verification": "Instancie objeto e acesse atributos da base e derivada; todos devem ter valores corretos sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Terminal para rodar python script.py"
                                  ],
                                  "tips": "Chame super() ANTES de código customizado no __init__ para evitar dependências.",
                                  "learningObjective": "Aplicar super().__init__() corretamente para inicializar superclasse no construtor.",
                                  "commonMistakes": [
                                    "Esquecer self como primeiro argumento",
                                    "Passar argumentos errados para super()",
                                    "Chamar super() após código que depende de atributos da base"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Usar super() em métodos sobrescritos além de __init__",
                                  "subSteps": [
                                    "Adicione um método na base, ex: Animal.falar() que imprime 'Som genérico'.",
                                    "Sobrescreva em Cachorro.falar(): chame super().falar() e adicione 'Au au!'.",
                                    "Teste chamando obj.falar() e verifique saída combinada.",
                                    "Crie outra subclasse Gato e repita para validar polimorfismo.",
                                    "Explore super() com herança múltipla: crie classe Mamifero e teste ordem de chamada."
                                  ],
                                  "verification": "Execute métodos sobrescritos; saída deve incluir código de todas classes na hierarquia.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Python REPL para testes rápidos"
                                  ],
                                  "tips": "super().metodo(args) funciona para qualquer método, não só __init__.",
                                  "learningObjective": "Estender comportamento de métodos da superclasse usando super() em sobrescritas.",
                                  "commonMistakes": [
                                    "Não passar argumentos corretos para super().metodo()",
                                    "Usar super sem parênteses: super.meth() em vez de super().meth()"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar, depurar e otimizar uso de super()",
                                  "subSteps": [
                                    "Crie um exemplo realista: classe Veiculo com __init__ e mover(); subclasse Carro com motor e acelerar().",
                                    "Use super() em ambos métodos e teste cenários de falha (ex: argumentos faltantes).",
                                    "Depure erros comuns com pdb ou print; corrija e documente soluções.",
                                    "Refatore para herança múltipla (ex: Veiculo + Elétrico) e verifique MRO com type.__mro__.",
                                    "Escreva testes unitários com unittest para validar chamadas super()."
                                  ],
                                  "verification": "Todos testes passam; MRO impresso mostra ordem correta; sem warnings de unbound method.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor com debugger",
                                    "Biblioteca unittest",
                                    "Exemplo código base salvo"
                                  ],
                                  "tips": "Use super() com *args, **kwargs para herança profunda e múltipla.",
                                  "learningObjective": "Integrar super() em hierarquias complexas com depuração e testes.",
                                  "commonMistakes": [
                                    "Problemas em herança múltipla sem entender MRO",
                                    "super() em contextos estáticos/classe (use super(Subclasse, self) explicitamente)"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie classe Animal:\nclass Animal:\n    def __init__(self, nome, idade):\n        self.nome = nome\n        self.idade = idade\n    def falar(self):\n        print('Som animal')\n\nclass Cachorro(Animal):\n    def __init__(self, nome, idade, raca):\n        super().__init__(nome, idade)\n        self.raca = raca\n    def falar(self):\n        super().falar()\n        print(f'{self.nome} late: Au au!')\n\nrex = Cachorro('Rex', 5, 'Labrador')\nrex.falar()  # Saída: 'Som animal' + 'Rex late: Au au!'",
                              "finalVerifications": [
                                "Atributos da superclasse são inicializados corretamente em instâncias da subclasse.",
                                "Métodos sobrescritos executam código da superclasse via super() sem erros.",
                                "Código roda sem TypeError ou AttributeError relacionados a chamadas super().",
                                "Ordem de execução reflete hierarquia (ver prints ou logs).",
                                "Testes unitários para __init__ e métodos passam 100%.",
                                "MRO (Method Resolution Order) é correta para herança múltipla."
                              ],
                              "assessmentCriteria": [
                                "Uso correto de super().__init__(self, *args) ou super().metodo() com argumentos.",
                                "Chamada super() posicionada logicamente (antes/depois customizações conforme necessidade).",
                                "Tratamento de herança múltipla sem ambiguidades ou loops infinitos.",
                                "Código limpo, legível com comentários explicando super().",
                                "Verificações empíricas: prints, asserts ou testes confirmam funcionamento.",
                                "Evita chamadas diretas à superclasse (ClasseBase() em vez de super())."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Hierarquias e relações de dependência semelhantes a grafos direcionados.",
                                "Biologia: Classificação taxonômica (classes base como reinos, subclasses como espécies).",
                                "Engenharia de Software: Padrões de design como Template Method.",
                                "Lógica e Filosofia: Conceitos de extensão e especialização em categorias."
                              ],
                              "realWorldApplication": "Em frameworks como Django (Model.objects.create() chama super()), bibliotecas GUI como Tkinter (widgets herdam e estendem init), ou engines de jogos (Unity-like em Python com Pygame: entidades herdam comportamentos base como update() via super()). Garante extensibilidade sem quebrar código legado."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.3.3",
                            "name": "Demonstrar polimorfismo via herança",
                            "description": "Criar uma lista de objetos de classes derivadas diferentes e chamar um método sobrescrito, ilustrando polimorfismo em tempo de execução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a classe base com um método virtual",
                                  "subSteps": [
                                    "Crie uma classe abstrata ou concreta chamada 'Animal' com um atributo nome.",
                                    "Adicione um método público 'makeSound()' que retorne uma string genérica como 'Som genérico'.",
                                    "Inclua um construtor que inicialize o nome.",
                                    "Garanta que o método seja virtual ou possa ser sobrescrito (use @Override em Java).",
                                    "Compile e teste a classe base isoladamente."
                                  ],
                                  "verification": "Instancie um objeto Animal e chame makeSound(); deve retornar 'Som genérico' sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE como IntelliJ ou Eclipse",
                                    "JDK 8 ou superior"
                                  ],
                                  "tips": "Use modificador 'public' para o método e torne-o não-final para permitir sobrescrita.",
                                  "learningObjective": "Entender a base da hierarquia para polimorfismo.",
                                  "commonMistakes": [
                                    "Esquecer o construtor",
                                    "Tornar o método final ou private",
                                    "Não compilar antes de prosseguir"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar subclasses com sobrescrita do método",
                                  "subSteps": [
                                    "Crie classe 'Dog' que herda de Animal e sobrescreva makeSound() para retornar 'Au au!'.",
                                    "Crie classe 'Cat' que herda de Animal e sobrescreva makeSound() para retornar 'Miau!'.",
                                    "Adicione construtores em cada subclasse chamando super(nome).",
                                    "Teste cada subclasse individualmente chamando makeSound().",
                                    "Verifique se a sobrescrita funciona com anotações como @Override."
                                  ],
                                  "verification": "Instancie Dog e Cat; makeSound() deve retornar os sons específicos de cada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesma IDE e JDK",
                                    "Documentação Java sobre herança"
                                  ],
                                  "tips": "Sempre chame super() no construtor para reutilizar código da superclasse.",
                                  "learningObjective": "Dominar sobrescrita de métodos para comportamentos específicos.",
                                  "commonMistakes": [
                                    "Não usar @Override",
                                    "Esquecer de chamar super() causando NullPointer",
                                    "Assinaturas de método diferentes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir uma lista polimórfica de objetos",
                                  "subSteps": [
                                    "Importe java.util.List e ArrayList.",
                                    "Crie uma List<Animal> chamada animals.",
                                    "Adicione instâncias de Dog, Cat e outro Animal à lista.",
                                    "Imprima a lista para confirmar que contém referências polimórficas.",
                                    "Use toString() sobrescrito se necessário para depuração."
                                  ],
                                  "verification": "animals.size() == 3+ e getClass() em cada item mostra classes diferentes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código das classes anteriores"
                                  ],
                                  "tips": "A lista é tipada como Animal, permitindo adicionar subclasses.",
                                  "learningObjective": "Criar coleções que tratam objetos de forma uniforme.",
                                  "commonMistakes": [
                                    "Usar List<Dog> em vez de List<Animal>",
                                    "Adicionar objetos incompatíveis",
                                    "Esquecer importações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar polimorfismo iterando e chamando o método",
                                  "subSteps": [
                                    "Use um loop for-each sobre a lista animals.",
                                    "Chame makeSound() em cada item dentro do loop.",
                                    "Imprima o nome do animal seguido do som.",
                                    "Execute o programa e observe os outputs diferentes.",
                                    "Adicione logs ou prints para mostrar o tipo real de cada objeto (getClass())."
                                  ],
                                  "verification": "Output mostra sons corretos de cada subclasse apesar da referência Animal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código completo anterior"
                                  ],
                                  "tips": "Use System.out.println(animal.getClass().getSimpleName()) para visualizar polimorfismo.",
                                  "learningObjective": "Ilustrar resolução em runtime do método correto.",
                                  "commonMistakes": [
                                    "Chamar método da superclasse",
                                    "Loop incorreto",
                                    "Não observar getClass()"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Refatorar e otimizar para clareza",
                                  "subSteps": [
                                    "Adicione um método toString() sobrescrito em Animal e subclasses.",
                                    "Crie mais subclasses (ex: Bird) para enriquecer a demo.",
                                    "Teste com diferentes tamanhos de lista.",
                                    "Documente o código com comentários explicando polimorfismo.",
                                    "Execute múltiplas vezes confirmando consistência."
                                  ],
                                  "verification": "Código roda sem erros, outputs variam por instância, fully documentado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Todo o código"
                                  ],
                                  "tips": "Mantenha código limpo para facilitar compreensão.",
                                  "learningObjective": "Aplicar polimorfismo de forma escalável.",
                                  "commonMistakes": [
                                    "Sobrecomplicar com casts desnecessários",
                                    "Ignorar documentação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um zoológico virtual: List<Animal> zoo = new ArrayList<>(); zoo.add(new Dog('Rex')); zoo.add(new Cat('Mimi')); for(Animal a : zoo) { System.out.println(a.getName() + ': ' + a.makeSound()); } Output: Rex: Au au! Mimi: Miau! Demonstra que o método correto é chamado em runtime.",
                              "finalVerifications": [
                                "Lista contém referências polimórficas (diferentes classes via instanceof ou getClass()).",
                                "Método makeSound() executa versão sobrescrita da subclasse correta.",
                                "Nenhum cast é necessário para chamar o método.",
                                "Output varia baseado no tipo real do objeto, não na referência.",
                                "Código compila e roda sem erros ou warnings de sobrescrita.",
                                "Adicionar nova subclasse requer só herança e sobrescrita, sem mudar o loop."
                              ],
                              "assessmentCriteria": [
                                "Hierarquia de classes correta com sobrescrita válida.",
                                "Lista tipada corretamente como superclasse.",
                                "Loop chama método polimórfico produzindo outputs esperados.",
                                "Código limpo, compilável e bem comentado.",
                                "Explicação clara do porquê polimorfismo ocorre em runtime.",
                                "Extensibilidade demonstrada (fácil adicionar nova classe)."
                              ],
                              "crossCurricularConnections": [
                                "Biologia: Hierarquias de classificação (reino, filo, classe como herança).",
                                "Matemática: Abstração e conjuntos (superclasse como conjunto pai).",
                                "Design: Princípios de herança em modelagem UML.",
                                "Física: Comportamentos emergentes em sistemas complexos."
                              ],
                              "realWorldApplication": "Frameworks como Java Swing (Componentes tratados uniformemente via polimorfismo), jogos (entidades inimigas com comportamentos diferentes via herança), bancos (contas correntes/poupança com métodos sobrescritos para cálculo de juros)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.3.4",
                            "name": "Evitar problemas comuns em herança",
                            "description": "Identificar e corrigir erros como diamante em herança múltipla ou shadowing de variáveis, promovendo hierarquias limpas e reutilizáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar Problemas Comuns em Herança",
                                  "subSteps": [
                                    "Estude o problema de herança múltipla diamante: quando uma classe herda de duas classes que compartilham uma superclasse comum, causando ambiguidade.",
                                    "Aprenda sobre shadowing de variáveis: quando uma subclasse declara uma variável com o mesmo nome da superclasse, ocultando-a.",
                                    "Explore fragilidade da classe base: mudanças na superclasse quebram subclasses inesperadamente.",
                                    "Revise problemas de profundidade em hierarquias profundas, como aumento de acoplamento.",
                                    "Liste exemplos em linguagens como Python (MRO) ou C++ (virtual inheritance)."
                                  ],
                                  "verification": "Crie uma tabela resumindo 5 problemas comuns com descrições e impactos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de POO da linguagem escolhida (ex: Python docs on MRO)",
                                    "Artigos sobre 'diamond problem in inheritance'",
                                    "IDE para testar snippets"
                                  ],
                                  "tips": "Use diagramas UML para visualizar hierarquias problemáticas.",
                                  "learningObjective": "Compreender os principais pitfalls da herança e seus efeitos no código.",
                                  "commonMistakes": [
                                    "Confundir shadowing com sobrescrita de métodos.",
                                    "Ignorar ordem de resolução de métodos (MRO)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detectar Problemas em Código Existente",
                                  "subSteps": [
                                    "Analise código fornecido: identifique herança múltipla e verifique ambiguidade em chamadas de métodos.",
                                    "Use ferramentas de depuração: inspecione ordem de resolução (ex: mro() em Python) e rastreie shadowing.",
                                    "Teste cenários: compile e execute código com herança profunda para observar comportamentos inesperados.",
                                    "Documente achados: anote linhas problemáticas e sintomas observados.",
                                    "Compare com hierarquias ideais usando princípios Liskov Substitution Principle (LSP)."
                                  ],
                                  "verification": "Refatore um snippet de código com pelo menos 2 problemas identificados e prove com testes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código de exemplo com erros (ex: GitHub repos de POO pitfalls)",
                                    "IDE com debugger (VS Code, PyCharm)",
                                    "Test framework como unittest"
                                  ],
                                  "tips": "Sempre execute testes unitários para revelar ambiguidades em runtime.",
                                  "learningObjective": "Desenvolver habilidade para diagnosticar issues de herança em código real.",
                                  "commonMistakes": [
                                    "Não testar com dados edge-case.",
                                    "Assumir que compilação sem erros significa correção."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Corrigir Problemas Específicos",
                                  "subSteps": [
                                    "Resolva diamante: use herança virtual (C++) ou prefira composição/interfaces (Java/Python).",
                                    "Corrija shadowing: renomeie variáveis ou use super() explicitamente.",
                                    "Mitigue fragilidade: aplique LSP e evite herança para implementação, prefira para interfaces.",
                                    "Refatore hierarquia: extraia classes intermediárias ou use mixins controlados.",
                                    "Valide correções: rode testes antes/depois e meça melhorias em legibilidade."
                                  ],
                                  "verification": "Forneça código corrigido lado a lado com original, incluindo testes que falham no original e passam no novo.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Snippets de código problemáticos",
                                    "Referências: Effective Java ou Clean Code capítulos sobre herança",
                                    "Ferramentas de refatoração no IDE"
                                  ],
                                  "tips": "Prefira composição sobre herança sempre que possível (favor composition over inheritance).",
                                  "learningObjective": "Aplicar técnicas específicas para remediar erros de herança.",
                                  "commonMistakes": [
                                    "Sobre-refatorar e quebrar funcionalidade existente.",
                                    "Ignorar performance em correções de diamante."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Projetar Hierarquias Limpos e Reutilizáveis",
                                  "subSteps": [
                                    "Planeje hierarquias: use LSP e verifique se subclasses são substituíveis.",
                                    "Aplique design patterns: Strategy para evitar herança desnecessária, Template Method para reutilização.",
                                    "Promova reutilização: crie interfaces abstratas e evite profundidade >3 níveis.",
                                    "Revise com pares: peça feedback em diagramas UML propostos.",
                                    "Documente decisões: justifique escolhas de herança vs composição."
                                  ],
                                  "verification": "Desenvolva uma hierarquia nova para um problema simples (ex: sistema de veículos) sem pitfalls.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ferramenta UML (draw.io, Lucidchart)",
                                    "Livros: Head First Design Patterns",
                                    "Exemplos de código open-source bem estruturados"
                                  ],
                                  "tips": "Pergunte: 'Essa herança modela IS-A ou precisa de HAS-A?'",
                                  "learningObjective": "Criar estruturas de herança robustas e manuteníveis.",
                                  "commonMistakes": [
                                    "Herança excessiva por conveniência.",
                                    "Não considerar evolução futura do código."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de formas geométricas: Classe Point herda de 2DShape e 3DShape, ambos herdando de Shape (diamante). Chamada a draw() ambígua. Correção: Use composição - 2DShape tem Point como atributo, ou interface ShapeBehavior.",
                              "finalVerifications": [
                                "Explicar o problema diamante com diagrama e solução.",
                                "Identificar shadowing em código fornecido em <2 min.",
                                "Refatorar herança múltipla para composição sem quebrar testes.",
                                "Aplicar LSP em uma hierarquia proposta.",
                                "Listar 3 alternativas à herança para um caso dado.",
                                "Debugar fragilidade base-class em snippet real."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de pelo menos 4 problemas comuns (90% acerto).",
                                "Qualidade das correções: código limpo, testado e documentado.",
                                "Profundidade dos substeps: todos executados com evidências.",
                                "Criatividade em conexões com boas práticas (LSP, composição).",
                                "Tempo respeitado e eficiência demonstrada.",
                                "Hierarquia final reutilizável e livre de pitfalls."
                              ],
                              "crossCurricularConnections": [
                                "Design de Software: Integra com SOLID principles e design patterns.",
                                "Engenharia de Software: Relaciona a refatoração e code smells.",
                                "Matemática: Hierarquias como árvores e grafos acíclicos.",
                                "Lógica Computacional: Resolução de ambiguidades como em grafos DAG."
                              ],
                              "realWorldApplication": "Em frameworks como Android (Activity herda de Context, evitando diamante via interfaces) ou jogos Unity (evitar herança profunda em GameObjects para performance e manutenção)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.4",
                    "name": "Polimorfismo em POO",
                    "description": "Habilidade de objetos de diferentes classes responderem à mesma mensagem de forma específica, via sobrescrita ou sobrecarga.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.4.1",
                        "name": "Polimorfismo por Sobrescrita de Métodos (Override)",
                        "description": "Mecanismo que permite a uma subclasse redefinir a implementação de um método herdado da superclasse, permitindo que objetos de diferentes classes respondam de forma específica à mesma chamada de método, promovendo flexibilidade em hierarquias de herança.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.1.1",
                            "name": "Identificar cenários para sobrescrita de métodos",
                            "description": "Analisar uma hierarquia de classes e determinar quando um método da superclasse deve ser sobrescrito em subclasses para comportamentos específicos, considerando princípios como Liskov Substitution Principle.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Herança e Polimorfismo",
                                  "subSteps": [
                                    "Estude a definição de superclasse e subclasse em uma hierarquia de classes.",
                                    "Revise o que é polimorfismo por sobrescrita (override) versus sobrecarga (overload).",
                                    "Analise exemplos simples de métodos herdados sem modificação.",
                                    "Identifique o papel do método virtual ou @Override em linguagens como Java ou C#.",
                                    "Entenda o contrato de interface de um método na superclasse."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre herança e polimorfismo, com um diagrama de classes simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial de POO (Java/Python)",
                                    "Editor de código como IntelliJ ou VS Code",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Comece com diagramas UML para visualizar a hierarquia antes de codificar.",
                                  "learningObjective": "Compreender os pré-requisitos para identificar cenários de sobrescrita.",
                                  "commonMistakes": [
                                    "Confundir override com overload",
                                    "Ignorar a assinatura do método da superclasse",
                                    "Assumir que toda herança requer sobrescrita"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Hierarquia de Classes e Comportamentos Específicos",
                                  "subSteps": [
                                    "Mapeie a hierarquia de classes: identifique superclasse e subclasses relevantes.",
                                    "Liste todos os métodos da superclasse que são candidatos a polimorfismo.",
                                    "Para cada método, compare o comportamento genérico da superclasse com necessidades específicas das subclasses.",
                                    "Registre cenários onde o comportamento diverge: ex., método genérico não atende especialização.",
                                    "Documente requisitos funcionais das subclasses via análise de casos de uso."
                                  ],
                                  "verification": "Crie um mapa mental ou tabela listando métodos e justificativas para sobrescrita em pelo menos 3 subclasses.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação como Lucidchart ou Draw.io",
                                    "Exemplos de código de hierarquias (GitHub repos de POO)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Pergunte: 'O comportamento da subclasse é um refinamento comportamental ou totalmente diferente?'",
                                  "learningObjective": "Desenvolver habilidade para mapear hierarquias e detectar divergências comportamentais.",
                                  "commonMistakes": [
                                    "Sobrescrever métodos desnecessariamente",
                                    "Ignorar comportamentos compartilhados",
                                    "Focar apenas em uma subclasse"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Conformidade com o Princípio de Substituição de Liskov (LSP)",
                                  "subSteps": [
                                    "Revise o LSP: subclasses devem ser substituíveis por superclasses sem alterar propriedades esperadas.",
                                    "Para cada candidato a sobrescrita, teste se a subclasse preserva o contrato pré-condições/pós-condições.",
                                    "Verifique se a sobrescrita fortalece pré-condições ou enfraquece pós-condições adequadamente.",
                                    "Simule substituição: compile e execute código polimórfico para validar.",
                                    "Identifique violações LSP que invalidam a sobrescrita."
                                  ],
                                  "verification": "Escreva um teste unitário polimórfico que passe com superclasse e subclasses sobrescritas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Framework de testes como JUnit ou pytest",
                                    "Compilador/IDE com suporte a debugging",
                                    "Referência ao LSP (artigo de Robert C. Martin)"
                                  ],
                                  "tips": "Use 'is-a' test: 'Um objeto da subclasse É-A superclasse em todos os contextos?'",
                                  "learningObjective": "Aplicar LSP para validar cenários de sobrescrita.",
                                  "commonMistakes": [
                                    "Violar LSP ao adicionar lógica que falha em contextos genéricos",
                                    "Ignorar exceções lançadas apenas em subclasses",
                                    "Alterar tipo de retorno incompatível"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação em Cenários Reais e Sintetizar",
                                  "subSteps": [
                                    "Analise um código legado com hierarquia complexa e marque pontos de sobrescrita.",
                                    "Crie 3 cenários hipotéticos e decida se requerem sobrescrita, justificando.",
                                    "Refatore um método genérico para polimórfico, implementando overrides.",
                                    "Revise com pares ou auto-revisão para feedback.",
                                    "Documente regras pessoais para decidir sobrescrita futura."
                                  ],
                                  "verification": "Apresente um relatório com 5 cenários identificados, 3 com sobrescrita recomendada e código de exemplo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Repositórios open-source com POO (ex: Spring Framework exemplos)",
                                    "Ferramenta de versionamento como Git",
                                    "Checklist de LSP"
                                  ],
                                  "tips": "Priorize métodos que afetam comportamento observável externamente.",
                                  "learningObjective": "Consolidar a identificação de cenários através de prática iterativa.",
                                  "commonMistakes": [
                                    "Sobrescrever por micro-otimizações",
                                    "Não considerar performance em polimorfismo",
                                    "Esquecer documentação nos overrides"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma hierarquia Shape -> Rectangle -> Square, o método setDimensions(width, height) na Shape é genérico. No Square, deve sobrescrever para setSide(length), garantindo width == height, mas preservando LSP: um Square pode ser usado onde Shape é esperado, ajustando internamente sem quebrar clientes.",
                              "finalVerifications": [
                                "Lista corretamente 4 cenários onde sobrescrita é necessária em uma hierarquia dada.",
                                "Explica LSP em relação a um override específico.",
                                "Implementa código polimórfico que passa em testes de substituição.",
                                "Identifica 2 violações potenciais de LSP em exemplos propostos.",
                                "Documenta justificativas claras para decisões de sobrescrita/não sobrescrita."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de cenários (90% acurácia).",
                                "Aplicação correta do LSP em análises (sem violações).",
                                "Qualidade dos subSteps e verificações em steps criados.",
                                "Profundidade de justificativas e exemplos práticos.",
                                "Capacidade de refatorar código existente com overrides apropriados.",
                                "Clareza na documentação e diagramas utilizados."
                              ],
                              "crossCurricularConnections": [
                                "Design de Software: Aplicação em padrões como Template Method.",
                                "Matemática: Abstração e modelagem hierárquica semelhante a conjuntos e subconjuntos.",
                                "Engenharia de Software: Refatoração e manutenção de código legível.",
                                "Lógica Computacional: Contratos e pré/pós-condições formais."
                              ],
                              "realWorldApplication": "Em frameworks como Android (sobrescrita de onCreate() em Activities especializadas) ou jogos (método update() em entidades com comportamentos únicos), garantindo extensibilidade sem quebrar código cliente existente."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.2",
                            "name": "Implementar sobrescrita de métodos em código",
                            "description": "Escrever código em linguagens como Python ou C++ onde uma subclasse sobrescreve um método da superclasse, utilizando anotações como @override em C++ ou simplesmente redefinindo em Python, e testando com chamadas polimórficas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a superclasse com um método virtual",
                                  "subSteps": [
                                    "Crie uma classe base (superclasse) representando um conceito genérico, como 'Animal'.",
                                    "Adicione um método não privado, como 'make_sound()', que imprima uma mensagem genérica, ex: 'Some generic sound'.",
                                    "Garanta que o método seja acessível para sobrescrita, sem modificadores restritivos em Python.",
                                    "Salve o código em um arquivo .py e execute para verificar que o método funciona na superclasse.",
                                    "Documente o método com uma docstring explicando seu propósito genérico."
                                  ],
                                  "verification": "Instancie a superclasse e chame o método; deve imprimir a mensagem genérica sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Python 3.x instalado"
                                  ],
                                  "tips": "Use nomes descritivos para classes e métodos para facilitar o entendimento da hierarquia.",
                                  "learningObjective": "Compreender como definir um método na superclasse que servirá de base para polimorfismo.",
                                  "commonMistakes": [
                                    "Tornar o método privado com '__' em Python, impedindo sobrescrita",
                                    "Esquecer de definir o corpo do método",
                                    "Não testar a superclasse isoladamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar a subclasse e preparar para sobrescrita",
                                  "subSteps": [
                                    "Defina uma subclasse que herde da superclasse, ex: class Dog(Animal).",
                                    "No construtor da subclasse (__init__), chame o construtor da superclasse com super().__init__() se necessário.",
                                    "Adicione atributos específicos da subclasse, como self.name = name.",
                                    "Instancie a subclasse e chame o método herdado; deve executar a versão da superclasse.",
                                    "Verifique a herança com isinstance(obj, Animal) retornando True."
                                  ],
                                  "verification": "Criar instância da subclasse e chamar make_sound() deve usar a versão da superclasse.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Mesmo editor e Python do step anterior",
                                    "Console para testes interativos"
                                  ],
                                  "tips": "Sempre use super() para evitar problemas em hierarquias múltiplas.",
                                  "learningObjective": "Estabelecer herança correta para preparar sobrescrita de métodos.",
                                  "commonMistakes": [
                                    "Esquecer parênteses na herança: class Dog(Animal) ao invés de class Dog(Animal):",
                                    "Não chamar super().__init__() levando a atributos ausentes",
                                    "Não testar herança antes de sobrescrever"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a sobrescrita do método na subclasse",
                                  "subSteps": [
                                    "Na subclasse, defina o método com o mesmo nome e assinatura da superclasse, ex: def make_sound(self):.",
                                    "Altere o corpo do método para comportamento específico, ex: print(f'{self.name} says Woof!').",
                                    "Adicione uma anotação opcional como uma docstring indicando override.",
                                    "Para C++, use 'virtual' na superclasse e '@override' na subclasse (mas foque em Python aqui).",
                                    "Salve e execute chamadas na subclasse para confirmar sobrescrita."
                                  ],
                                  "verification": "Chamar make_sound() na instância da subclasse deve imprimir o som específico, não o genérico.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Python interpreter"
                                  ],
                                  "tips": "Mantenha a mesma assinatura (parâmetros) para polimorfismo verdadeiro.",
                                  "learningObjective": "Sobrescrever métodos para customizar comportamento em subclasses.",
                                  "commonMistakes": [
                                    "Mudar a assinatura do método (ex: adicionar parâmetros extras)",
                                    "Esquecer 'self' em Python",
                                    "Não alterar o corpo, resultando em comportamento idêntico"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar polimorfismo com chamadas dinâmicas",
                                  "subSteps": [
                                    "Crie uma lista de objetos polimórficos: animals = [Animal(), Dog('Rex'), Cat('Whiskers')].",
                                    "Use um loop for animal in animals: animal.make_sound() para demonstrar polimorfismo.",
                                    "Verifique que cada chamada resolve para o método correto da classe real do objeto.",
                                    "Adicione uma função genérica que receba Animal e chame make_sound() para testar binding dinâmico.",
                                    "Execute testes unitários simples com assert para validar saídas esperadas."
                                  ],
                                  "verification": "O loop polimórfico deve imprimir sons diferentes para cada tipo sem if/else por classe.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Biblioteca unittest do Python para testes",
                                    "Editor com suporte a debugging"
                                  ],
                                  "tips": "Use type(obj) ou obj.__class__.__name__ para debugar qual método foi chamado.",
                                  "learningObjective": "Demonstrar polimorfismo em runtime através de sobrescrita de métodos.",
                                  "commonMistakes": [
                                    "Usar chamadas diretas como dog.make_sound() ao invés de polimórficas",
                                    "Não lidar com múltiplas subclasses",
                                    "Erros de indentação em loops ou funções"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma hierarquia Animal -> Dog e Cat. Dog.make_sound() imprime 'Woof!', Cat 'Meow!'. Em uma lista [Dog('Rex'), Cat('Mittens')], um loop for animal.make_sound() produz saídas polimórficas corretas.",
                              "finalVerifications": [
                                "Código executa sem erros e demonstra sobrescrita com saídas diferentes.",
                                "Testes polimórficos em lista de objetos herdam e sobrescrevem corretamente.",
                                "isinstance() confirma herança em subclasses.",
                                "Método genérico aceita qualquer subclasse e chama versão correta.",
                                "Adaptação para C++ com virtual/override funciona similarmente.",
                                "Nenhum vazamento de implementação da superclasse nas subclasses."
                              ],
                              "assessmentCriteria": [
                                "Correta definição de herança e sobrescrita sem erros sintáticos (40%).",
                                "Demonstração efetiva de polimorfismo em testes (30%).",
                                "Código limpo, documentado e com verificações (15%).",
                                "Uso apropriado de super() e binding dinâmico (10%).",
                                "Extensibilidade para novas subclasses (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Biologia: Modelagem de hierarquias de classes como taxonomia de espécies.",
                                "Matemática: Abstração similar a funções genéricas em álgebra abstrata.",
                                "Design: Padrões de herança como em design gráfico de componentes reutilizáveis.",
                                "Lógica: Raciocínio dedutivo em resolução de métodos dinâmicos."
                              ],
                              "realWorldApplication": "Em frameworks como Django (modelos herdam e sobrescrevem save()), jogos Unity (comportamentos de entidades polimórficas), ou bibliotecas GUI onde botões subclasses sobrescrevem eventos de clique para ações customizadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.3",
                            "name": "Representar sobrescrita em diagramas UML",
                            "description": "Criar diagramas de classes UML mostrando herança e sobrescrita de métodos, utilizando notações como {abstract} para métodos abstratos e setas de generalização para ilustrar polimorfismo de subtipo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Herança e Sobrescrita em UML",
                                  "subSteps": [
                                    "Estude a notação UML para classes: retângulos com nome da classe no topo, atributos no meio e métodos na base.",
                                    "Revise setas de generalização: seta triangular vazia apontando da subclasse para a superclasse.",
                                    "Identifique notações para métodos: {abstract} para métodos abstratos, itálico para nomes abstratos.",
                                    "Entenda sobrescrita: método na subclasse com mesma assinatura da superclasse.",
                                    "Pratique esboçando uma hierarquia simples de classes pai e filha."
                                  ],
                                  "verification": "Crie um esboço rápido de uma superclasse e subclasse com seta de generalização e confirme com uma referência UML.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de desenho como Draw.io ou papel e lápis",
                                    "Referência UML oficial (PDF ou site como uml-diagrams.org)"
                                  ],
                                  "tips": "Use cores diferentes para superclasse e subclasses para visualizar melhor a hierarquia.",
                                  "learningObjective": "Compreender as notações fundamentais de herança em diagramas de classes UML.",
                                  "commonMistakes": [
                                    "Confundir seta de generalização com seta de associação (use seta triangular para herança)",
                                    "Esquecer de alinhar métodos para sobrescrita visual."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Mapear Elementos de Sobrescrita",
                                  "subSteps": [
                                    "Escolha um exemplo: superclasse Animal com método abstrato makeSound().",
                                    "Liste subclasses: Dog e Cat, cada uma sobrescrevendo makeSound() com implementações específicas.",
                                    "Marque métodos abstratos na superclasse com {abstract} ou itálico.",
                                    "Anote assinaturas idênticas para overrides nas subclasses.",
                                    "Verifique polimorfismo: subclasses podem ser tratadas como superclasse."
                                  ],
                                  "verification": "Lista escrita com classes, métodos e anotações; compare com definição de polimorfismo por sobrescrita.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Bloco de notas ou editor de texto",
                                    "Exemplo de código OOP em Java/Python para referência"
                                  ],
                                  "tips": "Pense em polimorfismo de subtipo: 'um Dog É-UM Animal'.",
                                  "learningObjective": "Mapear corretamente métodos abstratos e overrides em uma hierarquia de classes.",
                                  "commonMistakes": [
                                    "Marcar métodos concretos como abstratos",
                                    "Usar nomes diferentes para métodos sobrescritos (assinaturas devem ser iguais)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o Diagrama de Classes UML Completo",
                                  "subSteps": [
                                    "Desenhe a superclasse Animal com atributos e makeSound() {abstract}.",
                                    "Adicione subclasses Dog e Cat com seus atributos e overrides de makeSound().",
                                    "Conecte com setas de generalização da subclasse para superclasse.",
                                    "Adicione visibilidade (+ público, - privado) aos métodos.",
                                    "Inclua multiplicidade se aplicável (ex: 1 para herança)."
                                  ],
                                  "verification": "Diagrama visualmente completo; exporte ou fotografe para revisão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta UML como Lucidchart, PlantUML ou Draw.io"
                                  ],
                                  "tips": "Mantenha o diagrama limpo: evite cruzamentos de setas, use layout hierárquico.",
                                  "learningObjective": "Criar um diagrama UML preciso representando herança e sobrescrita.",
                                  "commonMistakes": [
                                    "Seta invertida (deve apontar para superclasse)",
                                    "Esquecer {abstract} em métodos da superclasse."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Refinar o Diagrama",
                                  "subSteps": [
                                    "Verifique setas: generalização correta para polimorfismo.",
                                    "Confira notações: {abstract}, overrides com mesma assinatura.",
                                    "Teste legibilidade: alguém sem contexto entende a sobrescrita?",
                                    "Adicione notas ou estereótipos se necessário (ex: <<abstract>>).",
                                    "Compare com exemplos profissionais de diagramas UML."
                                  ],
                                  "verification": "Checklist preenchido confirmando todos os elementos; revisão por pares ou autoavaliação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Checklist impresso ou digital",
                                    "Exemplos de diagramas UML online"
                                  ],
                                  "tips": "Use ferramentas com validação automática como PlantUML para erros de sintaxe.",
                                  "learningObjective": "Garantir precisão e conformidade do diagrama com padrões UML.",
                                  "commonMistakes": [
                                    "Ignorar visibilidade de métodos",
                                    "Sobrecarregar o diagrama com detalhes desnecessários."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um diagrama UML para Animal (método abstrato makeSound()), com subclasses Dog (makeSound(): 'Woof!') e Cat (makeSound(): 'Meow!'). Use seta de generalização e {abstract} no método da superclasse.",
                              "finalVerifications": [
                                "Setas de generalização conectam corretamente subclasses à superclasse.",
                                "Métodos abstratos marcados com {abstract} ou itálico.",
                                "Assinaturas de métodos sobrescritos são idênticas.",
                                "Diagrama é legível e sem erros de notação.",
                                "Polimorfismo de subtipo é ilustrado via herança.",
                                "Visibilidades (+/-) estão presentes nos métodos."
                              ],
                              "assessmentCriteria": [
                                "Precisão das notações UML (generalização, {abstract}).",
                                "Correta representação de sobrescrita (assinaturas iguais).",
                                "Clareza e organização visual do diagrama.",
                                "Uso apropriado de atributos e métodos.",
                                "Ausência de erros comuns como setas invertidas.",
                                "Demonstração de polimorfismo via hierarquia."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Hierarquias e relações de subconjuntos (conjuntos e herança).",
                                "Design Gráfico: Princípios de modelagem visual e legibilidade.",
                                "Lógica: Abstração e refinamento de conceitos.",
                                "Engenharia de Software: Modelagem de sistemas complexos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, como no projeto de um sistema de gerenciamento de zoológico, onde classes base como Veiculo definem métodos abstratos como acelerar(), sobrescritos por Carro e Moto para simulações polimórficas em jogos ou apps de logística."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.2",
                        "name": "Polimorfismo por Sobrecarga de Métodos (Overload)",
                        "description": "Capacidade de definir múltiplos métodos na mesma classe ou hierarquia com o mesmo nome, mas parâmetros diferentes (tipo, número ou ordem), resolvido em tempo de compilação em linguagens de tipagem estática.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.2.1",
                            "name": "Diferenciar sobrecarga de sobrescrita",
                            "description": "Comparar os conceitos de sobrecarga (mesma classe, assinaturas diferentes) e sobrescrita (herança, mesma assinatura), identificando exemplos em contextos de tipagem estática como C++ versus dinâmica como Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Sobrecarga (Overload)",
                                  "subSteps": [
                                    "Defina sobrecarga como a capacidade de definir múltiplos métodos na mesma classe com o mesmo nome, mas assinaturas diferentes (parâmetros variados em número, tipo ou ordem).",
                                    "Estude exemplos básicos: um método soma(int a, int b) e outro soma(double a, double b).",
                                    "Analise como o compilador resolve a chamada baseada na tipagem estática em C++.",
                                    "Compare com Python, onde a sobrecarga é simulada via argumentos variáveis (*args, **kwargs) devido à tipagem dinâmica.",
                                    "Crie um pseudocódigo simples para ilustrar."
                                  ],
                                  "verification": "Escreva um exemplo de código com dois métodos sobrecarregados e explique como o compilador/interpretador escolhe qual chamar.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de C++ sobre overload",
                                    "Tutoriais Python args/kwargs",
                                    "Editor de código como VS Code"
                                  ],
                                  "tips": [
                                    "Lembre-se: overload é intra-classe e resolvido em tempo de compilação em linguagens estáticas."
                                  ],
                                  "learningObjective": "Identificar e exemplificar sobrecarga em contextos de tipagem estática e dinâmica.",
                                  "commonMistakes": [
                                    "Confundir overload com override achando que é herança",
                                    "Ignorar diferenças de tipagem entre linguagens"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o Conceito de Sobrescrita (Override)",
                                  "subSteps": [
                                    "Defina sobrescrita como redefinir um método da classe base na subclasse com a mesma assinatura exata.",
                                    "Estude requisitos: herança, mesma assinatura (nome, parâmetros, retorno), anotação virtual em C++ (@override em Python).",
                                    "Examine polimorfismo em runtime: chamada via ponteiro/base resolve na subclasse.",
                                    "Compare C++ (tipagem estática, virtual functions) vs Python (tipagem dinâmica, duck typing).",
                                    "Implemente um exemplo hierárquico simples."
                                  ],
                                  "verification": "Crie uma hierarquia de classes com override e demonstre polimorfismo via chamada de base.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplos de herança em C++",
                                    "Documentação Python classes",
                                    "Compilador g++ ou Python REPL"
                                  ],
                                  "tips": [
                                    "Sempre use anotações como 'virtual' em C++ para evitar slicing.",
                                    "Em Python, teste com isinstance() para verificação."
                                  ],
                                  "learningObjective": "Diferenciar sobrescrita de overload pelo contexto de herança e resolução em runtime.",
                                  "commonMistakes": [
                                    "Alterar assinatura achando que ainda é override",
                                    "Esquecer herança na definição"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Sobrecarga e Sobrescrita em Linguagens de Tipagem Estática (C++)",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: overload (compile-time, mesma classe) vs override (runtime, herança).",
                                    "Implemente código C++ com ambos: classe com métodos overload e subclasses com override.",
                                    "Compile e execute, analisando erros se assinaturas mudarem.",
                                    "Discuta limitações: C++ requer tipos exatos para overload.",
                                    "Refatore código para destacar diferenças."
                                  ],
                                  "verification": "Compile um programa C++ que use ambos conceitos e explique o output.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Compilador C++ (g++)",
                                    "IDE como CLion",
                                    "Referência C++ virtual functions"
                                  ],
                                  "tips": [
                                    "Use 'using' para herdar overload em subclasses.",
                                    "Teste com ponteiros para polimorfismo."
                                  ],
                                  "learningObjective": "Aplicar e contrastar conceitos em C++ para solidificar diferenças.",
                                  "commonMistakes": [
                                    "Chamar override como overload por erro de ponteiro",
                                    "Não declarar virtual"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar em Linguagens de Tipagem Dinâmica (Python) e Sintetizar Diferenças",
                                  "subSteps": [
                                    "Implemente overload simulado em Python com *args e ifs baseados em len(args).",
                                    "Crie hierarquia com override direto (mesmo nome e params).",
                                    "Execute exemplos polimórficos e compare resolução (runtime sempre).",
                                    "Liste diferenças chave: C++ estrita vs Python flexível; overload não nativo em Python.",
                                    "Resuma em mindmap ou tabela final."
                                  ],
                                  "verification": "Escreva scripts Python para ambos e identifique qual é overload vs override em trechos mistos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python 3 interpreter",
                                    "Jupyter Notebook",
                                    "Documentação Python métodos especiais"
                                  ],
                                  "tips": [
                                    "Use typing hints em Python para simular estaticidade.",
                                    "Evite globals para isolar testes."
                                  ],
                                  "learningObjective": "Sintetizar diferenças cross-linguagem e identificar em código real.",
                                  "commonMistakes": [
                                    "Achar que *args é overload real como C++",
                                    "Ignorar duck typing em override Python"
                                  ]
                                }
                              ],
                              "practicalExample": "Em C++: class Calculadora { int soma(int a, int b); double soma(double a, double b); }; class Avancada : public Calculadora { double soma(double a, double b) override; }; Em Python: class Calculadora: def soma(self, *args): if len(args)==2 and isinstance(args[0], int): ... class Avancada(Calculadora): def soma(self, a, b): ... # override",
                              "finalVerifications": [
                                "Explique verbalmente a diferença entre overload e override sem hesitação.",
                                "Identifique corretamente overload/override em um código C++ fornecido.",
                                "Faça o mesmo para código Python.",
                                "Crie um exemplo híbrido e classifique cada método.",
                                "Discuta impactos em performance (compile vs runtime).",
                                "Resolva um quiz com 5 cenários mistos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição: 100% correta distinção conceitual.",
                                "Exemplos funcionais: Código compila/executa sem erros.",
                                "Comparação cross-linguagem: Menciona tipagem estática/dinâmica.",
                                "Identificação em código: Acerta 90% em testes mistos.",
                                "Explicação clara: Usa termos como 'assinatura', 'herança', 'resolução'.",
                                "Aplicação prática: Relaciona a polimorfismo."
                              ],
                              "crossCurricularConnections": [
                                "Design de Software: Padrões como Strategy usam override.",
                                "Teoria da Computação: Tipagem e resolução de símbolos.",
                                "Lógica e Matemática: Assinaturas como funções sobrecarregadas.",
                                "Inglês Técnico: Termos overload/override em docs.",
                                "Ética em Programação: Sobrecarga clara evita confusão."
                              ],
                              "realWorldApplication": "Em frameworks como Qt (C++ overload para signals/slots) ou Django (Python override em models/views), desenvolvedores estendem funcionalidades sem quebrar APIs existentes, facilitando bibliotecas extensíveis como NumPy (simula overload)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.2",
                            "name": "Implementar sobrecarga de métodos",
                            "description": "Definir múltiplas versões de um método com assinaturas variadas em uma classe, demonstrando chamadas que selecionam a versão apropriada com base nos argumentos, em linguagens que suportam overload explícito como C++.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente de desenvolvimento e revisar conceitos básicos",
                                  "subSteps": [
                                    "Instale um compilador C++ como g++ (via MinGW no Windows ou nativo no Linux/Mac).",
                                    "Crie um novo arquivo .cpp em um editor como VS Code ou Code::Blocks.",
                                    "Escreva um programa simples 'Hello World' com uma classe básica para testar compilação.",
                                    "Compile com 'g++ arquivo.cpp -o executavel' e execute para verificar.",
                                    "Revise sintaxe de classes e métodos em C++ consultando documentação oficial."
                                  ],
                                  "verification": "Programa 'Hello World' com classe compila e executa sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador g++",
                                    "Editor de texto/IDE (VS Code)",
                                    "Documentação C++ (cppreference.com)"
                                  ],
                                  "tips": "Use flags como -Wall para detectar warnings precocemente.",
                                  "learningObjective": "Configurar ambiente funcional para experimentação com POO e sobrecarga.",
                                  "commonMistakes": [
                                    "Esquecer de incluir <iostream>",
                                    "Não usar namespace std;",
                                    "Erros de digitação no comando de compilação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a classe base com o método inicial",
                                  "subSteps": [
                                    "Declare uma classe simples, ex: 'Calculadora', com um método público 'somar'.",
                                    "Implemente a primeira versão: somar(int a, int b) que retorna int(a + b).",
                                    "Adicione construtor padrão e inclua headers necessários (#include <iostream>).",
                                    "Teste compilação isolada da classe.",
                                    "Adicione um main() básico para chamar somar(2, 3) e imprimir resultado."
                                  ],
                                  "verification": "Código compila e imprime soma correta de dois inteiros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Compilador C++"
                                  ],
                                  "tips": "Mantenha métodos inline para simplicidade inicial.",
                                  "learningObjective": "Criar estrutura de classe com método funcional básico.",
                                  "commonMistakes": [
                                    "Esquecer ponto e vírgula após declaração de classe",
                                    "Retorno incorreto do tipo",
                                    "Falta de #include"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar múltiplas sobrecargas de métodos",
                                  "subSteps": [
                                    "Adicione sobrecarga: somar(double a, double b) retornando double(a + b).",
                                    "Adicione outra: somar(int a, double b) retornando double(a + b).",
                                    "Garanta assinaturas distintas (tipos e/ou número de parâmetros variados).",
                                    "Compile e verifique ausência de erros de redefinição.",
                                    "Evite ambiguidades testando chamadas como somar(2, 3.5)."
                                  ],
                                  "verification": "Compilação bem-sucedida sem ambiguidades ou erros de overload.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Compilador C++"
                                  ],
                                  "tips": "Use tipos exatos para evitar promoção implícita que cause ambiguidades.",
                                  "learningObjective": "Dominar definição de overloads com assinaturas variadas.",
                                  "commonMistakes": [
                                    "Assinaturas idênticas causando erro de redefinição",
                                    "Ignorar ordem de parâmetros",
                                    "Ambiguidade por promoção de tipos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar chamadas e depurar seleção de overloads",
                                  "subSteps": [
                                    "No main(), faça chamadas: somar(2,3), somar(2.5,3.7), somar(2,3.5).",
                                    "Imprima qual versão foi chamada (use cout dentro de cada método).",
                                    "Compile, execute e valide saídas e seleções corretas.",
                                    "Introduza depuração: adicione prints para rastrear argumentos.",
                                    "Refatore se necessário e teste casos edge (ex: valores zero ou negativos)."
                                  ],
                                  "verification": "Todas chamadas selecionam overload correto e produzem saídas precisas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador C++",
                                    "Terminal para execução"
                                  ],
                                  "tips": "Use debugger do IDE para step-through e inspecionar chamadas.",
                                  "learningObjective": "Verificar comportamento runtime de resolução de overload.",
                                  "commonMistakes": [
                                    "Não testar todos overloads",
                                    "Ignorar precisão de double vs int",
                                    "Falta de prints para debug"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar, documentar e expandir",
                                  "subSteps": [
                                    "Adicione comentários explicando cada overload.",
                                    "Teste compilação final e execute suíte de testes.",
                                    "Experimente adicionar mais um overload (ex: somar três parâmetros).",
                                    "Analise erros comuns e corrija.",
                                    "Salve código e reflita sobre melhorias."
                                  ],
                                  "verification": "Código documentado compila, executa perfeitamente e está salvo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código"
                                  ],
                                  "tips": "Use Doxygen-style comments para documentação futura.",
                                  "learningObjective": "Consolidar aprendizado com documentação e extensão.",
                                  "commonMistakes": [
                                    "Sobrecarga excessiva desnecessária",
                                    "Falta de testes edge",
                                    "Código sem comentários"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie classe Calculadora com: int somar(int a, int b) { cout << 'Int overload'; return a+b; }, double somar(double a, double b) { cout << 'Double overload'; return a+b; }, double somar(int a, double b) { cout << 'Mixed overload'; return a+b; }. No main: Calculadora c; c.somar(2,3); c.somar(2.5,3.7); c.somar(2,3.5);. Saída deve mostrar overloads corretos.",
                              "finalVerifications": [
                                "Código compila sem erros ou warnings de overload.",
                                "Chamadas com argumentos int selecionam int overload.",
                                "Chamadas com double selecionam double ou mixed conforme assinatura.",
                                "Nenhuma ambiguidade em tempo de compilação.",
                                "Saídas refletem cálculos precisos e identificam overload usado.",
                                "Código executa em menos de 1 segundo para testes."
                              ],
                              "assessmentCriteria": [
                                "Assinaturas de métodos distintas e válidas para overload.",
                                "Resolução correta de overload pelo compilador em todas chamadas.",
                                "Implementação sem vazamentos de memória ou erros runtime.",
                                "Código limpo, indentado e comentado.",
                                "Testes cobrem todos overloads definidos.",
                                "Uso apropriado de tipos para evitar promoção implícita indesejada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Manipulação de tipos numéricos e precisão em cálculos.",
                                "Lógica e Algoritmos: Resolução de ambiguidades e matching de padrões.",
                                "Design de Software: Princípios de flexibilidade e usabilidade em APIs.",
                                "Inglês Técnico: Leitura de documentação C++ e comentários em código.",
                                "Ética em Computação: Evitar overloads confusos que degradam legibilidade."
                              ],
                              "realWorldApplication": "Sobrecarga é usada extensivamente na STL C++ (ex: operator<< para diferentes tipos) e bibliotecas como Boost, permitindo funções flexíveis em jogos (renderização de diferentes formatos), simulações científicas (cálculos com int/double) e desenvolvimento de GUIs (conversões de dados variados), promovendo código reutilizável e intuitivo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.3",
                            "name": "Aplicar sobrecarga em estruturas de dados",
                            "description": "Utilizar sobrecarga para criar métodos flexíveis em classes de estruturas de dados orientadas a objetos, como adicionar elementos de tipos diferentes a uma lista genérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos de sobrecarga de métodos em POO",
                                  "subSteps": [
                                    "Estude a definição de sobrecarga: múltiplos métodos com o mesmo nome, mas parâmetros diferentes em tipo, número ou ordem.",
                                    "Compare com sobrescrita (override) para evitar confusões.",
                                    "Analise exemplos simples em sua linguagem preferida (ex: Java, C# ou Python com @overload).",
                                    "Identifique como sobrecarga promove flexibilidade em estruturas de dados.",
                                    "Anote 3 benefícios da sobrecarga em classes como listas ou pilhas."
                                  ],
                                  "verification": "Escreva um resumo de 5 linhas explicando sobrecarga e dê um exemplo simples.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Documentação oficial da linguagem (ex: Oracle Java Docs)",
                                    "Editor de código como VS Code ou IntelliJ"
                                  ],
                                  "tips": "Use diagramas UML para visualizar assinaturas de métodos sobrecarregados.",
                                  "learningObjective": "Compreender os fundamentos teóricos da sobrecarga para aplicação prática em estruturas de dados.",
                                  "commonMistakes": [
                                    "Confundir sobrecarga com sobrescrita; ignorar que o tipo de retorno não define sobrecarga."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar a classe de estrutura de dados com sobrecarga",
                                  "subSteps": [
                                    "Defina a estrutura base: crie uma classe genérica ou simples como 'ListaFlexivel<T>' com atributos como array dinâmico.",
                                    "Planeje métodos sobrecarregados: ex. add(int), add(String), add(double), add(Object).",
                                    "Desenhe o diagrama de classe mostrando assinaturas dos métodos.",
                                    "Considere gerenciamento de capacidade e redimensionamento automático.",
                                    "Documente cada método com Javadoc ou comentários sobre parâmetros suportados."
                                  ],
                                  "verification": "Crie um esboço em papel ou ferramenta UML da classe com métodos sobrecarregados.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Ferramenta UML como Lucidchart ou papel e caneta",
                                    "Referências de design de coleções (ex: ArrayList em Java)"
                                  ],
                                  "tips": "Priorize tipos comuns (int, String, double) para demonstrar flexibilidade sem generics excessivos.",
                                  "learningObjective": "Projetar uma estrutura de dados que utilize sobrecarga para adicionar elementos heterogêneos.",
                                  "commonMistakes": [
                                    "Definir métodos com apenas número de parâmetros diferente, ignorando tipos; não planejar conversões implícitas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar os métodos sobrecarregados na classe",
                                  "subSteps": [
                                    "Implemente o construtor da classe e o armazenamento base (ex: ArrayList<Object>).",
                                    "Code os métodos add: cada um converte o tipo para Object e chama um método privado addInternal(Object).",
                                    "Adicione métodos auxiliares como size(), get(int index) e toString() para depuração.",
                                    "Trate exceções como IndexOutOfBoundsException em acessos.",
                                    "Teste compilação após cada método adicionado."
                                  ],
                                  "verification": "O código compila sem erros e exibe a estrutura via toString() com dados mistos.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "IDE com suporte a POO (ex: Eclipse, PyCharm)",
                                    "Compilador da linguagem escolhida"
                                  ],
                                  "tips": "Use um método privado comum para evitar duplicação de código nos adds sobrecarregados.",
                                  "learningObjective": "Implementar código funcional que demonstre polimorfismo por sobrecarga em estruturas de dados.",
                                  "commonMistakes": [
                                    "Não converter tipos adequadamente para o armazenamento genérico; duplicar lógica em vez de fatorar."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e refinar a implementação",
                                  "subSteps": [
                                    "Crie uma classe de teste com instâncias da ListaFlexivel.",
                                    "Teste adição de int, String e double; verifique size() e get().",
                                    "Adicione casos de borda: lista vazia, overflow de capacidade.",
                                    "Meça performance com 1000 elementos mistos.",
                                    "Refatore com base em bugs encontrados e otimize."
                                  ],
                                  "verification": "Todos os testes passam e a lista armazena/retrai elementos de tipos diferentes corretamente.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Framework de testes como JUnit ou pytest",
                                    "Exemplos de código de teste unitário"
                                  ],
                                  "tips": "Use assertions para verificar tipos exatos com instanceof.",
                                  "learningObjective": "Validar a robustez da sobrecarga através de testes abrangentes.",
                                  "commonMistakes": [
                                    "Testar apenas casos felizes; ignorar perda de type-safety em generics mistos."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe ListaFlexivel que suporte add(10), add(\"texto\"), add(3.14). No main: ListaFlexivel lista = new ListaFlexivel(); lista.add(1); lista.add(\"Olá\"); lista.add(2.5); System.out.println(lista); // Saída: [1, Olá, 2.5]",
                              "finalVerifications": [
                                "Código compila e executa sem erros de compilação ou runtime.",
                                "Métodos sobrecarregados aceitam tipos diferentes e armazenam corretamente.",
                                "Métodos auxiliares (size, get, toString) funcionam com dados heterogêneos.",
                                "Testes de borda (vazia, cheia) passam sem exceções inesperadas.",
                                "Não há duplicação de código desnecessária nos métodos add.",
                                "Type-safety é mantida onde possível via conversões explícitas."
                              ],
                              "assessmentCriteria": [
                                "Correção da implementação: todos os métodos sobrecarregados funcionam (40%).",
                                "Design limpo: uso de métodos privados para evitar duplicação (20%).",
                                "Cobertura de testes: pelo menos 80% dos cenários cobertos (20%).",
                                "Documentação e comentários claros em cada método (10%).",
                                "Eficiência: redimensionamento automático implementado (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstração de conjuntos heterogêneos e teoria de tipos.",
                                "Design de Software: Princípios SOLID, especialmente Interface Segregation.",
                                "Banco de Dados: Modelagem de tabelas com colunas de tipos variados via UNION.",
                                "Engenharia de Software: APIs flexíveis em bibliotecas como STL (C++) ou Collections (Java)."
                              ],
                              "realWorldApplication": "Em bibliotecas de coleções como Java's ArrayList (métodos add overload), permitindo desenvolvedores adicionarem primitivos ou objetos sem casting manual, facilitando desenvolvimento de apps como processadores de logs mistos (IDs numéricos + mensagens textuais)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.3",
                        "name": "Aplicações Práticas do Polimorfismo",
                        "description": "Uso do polimorfismo em cenários reais, como coleções de objetos heterogêneos, interfaces e padrões de projeto, permitindo código mais genérico e extensível.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.3.1",
                            "name": "Criar coleções polimórficas",
                            "description": "Implementar uma lista ou array que armazena objetos de subclasses diferentes, invocando métodos polimórficos para comportamentos variados, como em Python com duck typing ou C++ com ponteiros virtuais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a hierarquia de classes base e subclasses",
                                  "subSteps": [
                                    "Crie uma classe base abstrata chamada Shape usando module abc em Python.",
                                    "Defina métodos abstratos area() e draw() na classe Shape.",
                                    "Crie subclasses concretas: Circle, Rectangle e Triangle, herdando de Shape.",
                                    "Implemente os métodos area() e draw() em cada subclasse com lógica específica (ex: pi*r^2 para Circle)."
                                  ],
                                  "verification": "Execute o código das classes isoladamente; deve levantar TypeError se tentar instanciar Shape diretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Documentação Python ABC: https://docs.python.org/3/library/abc.html"
                                  ],
                                  "tips": "Use @abstractmethod para forçar implementação nas subclasses; teste instanciando subclasses.",
                                  "learningObjective": "Compreender o papel da superclasse abstrata em fornecer interface comum para polimorfismo.",
                                  "commonMistakes": [
                                    "Esquecer de importar abc e ABC",
                                    "Não usar @abstractmethod",
                                    "Implementar lógica na superclasse em vez de subclasses"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar métodos polimórficos nas subclasses",
                                  "subSteps": [
                                    "No Circle, implemente area() como math.pi * radius**2 e draw() imprimindo 'Desenhando círculo'.",
                                    "No Rectangle, area() como width * height e draw() como 'Desenhando retângulo'.",
                                    "No Triangle, area() como 0.5 * base * height e draw() como 'Desenhando triângulo'.",
                                    "Teste cada método individualmente com instâncias das subclasses.",
                                    "Importe math para cálculos precisos."
                                  ],
                                  "verification": "Chame area() e draw() em instâncias de cada subclasse; resultados devem variar por tipo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Biblioteca math do Python",
                                    "Calculadora para validar fórmulas geométricas"
                                  ],
                                  "tips": "Mantenha draw() simples para foco em polimorfismo; use print() para output visível.",
                                  "learningObjective": "Garantir que subclasses forneçam implementações específicas, permitindo comportamento runtime variado.",
                                  "commonMistakes": [
                                    "Cálculos incorretos de área",
                                    "Chamar super() desnecessariamente em métodos sobrescritos",
                                    "Não importar math"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar e popular a coleção polimórfica",
                                  "subSteps": [
                                    "Crie uma lista vazia chamada shapes: shapes = [].",
                                    "Instancie objetos de diferentes subclasses: Circle(5), Rectangle(4,6), Triangle(3,4).",
                                    "Adicione esses objetos à lista shapes usando append().",
                                    "Imprima len(shapes) para confirmar 3 itens.",
                                    "Verifique tipos com isinstance() para diferentes classes."
                                  ],
                                  "verification": "A lista shapes deve conter 3 objetos de tipos diferentes subclasses de Shape.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código com debugger",
                                    "Console Python interativo (REPL)"
                                  ],
                                  "tips": "Use lista heterogênea; Python permite via duck typing sem casts explícitos.",
                                  "learningObjective": "Armazenar referências polimórficas em uma única coleção sem perda de tipo específico.",
                                  "commonMistakes": [
                                    "Tentar adicionar strings ou ints à lista",
                                    "Esquecer de instanciar com parâmetros corretos",
                                    "Usar lista de strings em vez de objetos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Iterar pela coleção e invocar métodos polimórficos",
                                  "subSteps": [
                                    "Use um loop for para iterar sobre shapes: for shape in shapes:.",
                                    "Dentro do loop, chame shape.area() e shape.draw().",
                                    "Colete resultados em uma lista ou imprima diretamente para observar variação.",
                                    "Execute o loop e valide que cada objeto executa sua própria implementação.",
                                    "Adicione tratamento de erro opcional para robustez."
                                  ],
                                  "verification": "Output do loop mostra áreas e draws corretos e diferentes para cada shape.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Console Python para execução stepwise"
                                  ],
                                  "tips": "O polimorfismo resolve o método correto em runtime baseado no tipo real do objeto.",
                                  "learningObjective": "Demonstrar execução de comportamentos variados via uma interface comum.",
                                  "commonMistakes": [
                                    "Usar type checking no loop (quebra polimorfismo)",
                                    "Chamar métodos com argumentos errados",
                                    "Loop infinito ou range incorreto"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e refatorar para extensibilidade",
                                  "subSteps": [
                                    "Adicione uma nova subclasse Square herdando Rectangle.",
                                    "Adicione instância de Square à coleção e reexecute o loop.",
                                    "Verifique se o polimorfismo funciona sem modificar o código de iteração.",
                                    "Escreva testes unitários simples com assert para areas.",
                                    "Refatore para usar uma função genérica que aceita qualquer coleção de Shapes."
                                  ],
                                  "verification": "Nova classe adicionada sem quebrar iteração existente; testes passam.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pytest ou unittest para testes",
                                    "Git para versionamento"
                                  ],
                                  "tips": "Princípio Open-Closed: aberto para extensão, fechado para modificação.",
                                  "learningObjective": "Validar extensibilidade inerente ao polimorfismo em coleções.",
                                  "commonMistakes": [
                                    "Modificar loop para acomodar nova classe",
                                    "Erros em testes unitários",
                                    "Não herdar corretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma lista shapes = [Circle(5), Rectangle(4,6), Triangle(3,4)]. Itere com for shape in shapes: print(shape.area(), shape.draw()). Saída: 78.54 Desenhando círculo; 24.0 Desenhando retângulo; 6.0 Desenhando triângulo. Adicione Square(5) e reexecute sem alterar o loop.",
                              "finalVerifications": [
                                "A coleção contém pelo menos 3 objetos de subclasses diferentes de Shape.",
                                "Iteração chama area() e draw() corretamente para cada tipo sem erros.",
                                "Cálculos de área correspondem às fórmulas matemáticas exatas.",
                                "Adicionar nova subclasse não requer mudanças no código de iteração.",
                                "Testes unitários confirmam comportamentos individuais.",
                                "Nenhum type checking explícito é usado no loop polimórfico."
                              ],
                              "assessmentCriteria": [
                                "Código usa herança e sobrescrita correta para polimorfismo.",
                                "Coleção heterogênea armazena e acessa objetos via interface comum.",
                                "Comportamentos variam corretamente em runtime durante iteração.",
                                "Código é extensível: novas subclasses funcionam sem refatoração.",
                                "Implementação segue duck typing Python sem casts desnecessários.",
                                "Testes e verificações demonstram robustez e correção."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Fórmulas geométricas de área para validação real.",
                                "Design de Software: Padrão Strategy para comportamentos intercambiáveis.",
                                "Ciência da Computação: Conceitos de herança e binding dinâmico.",
                                "Engenharia de Software: Princípios SOLID (Open-Closed).",
                                "Análise de Algoritmos: Complexidade O(n) para iteração em coleções."
                              ],
                              "realWorldApplication": "Em editores gráficos como Photoshop (coleções de layers com draw() polimórfico), jogos (entidades como inimigos e itens com update() comum mas lógica variada), frameworks web (handlers de requests com process() específico por tipo), e sistemas de inventário (itens com calculateValue() diferente por categoria)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.2",
                            "name": "Utilizar polimorfismo com interfaces",
                            "description": "Definir interfaces ou classes abstratas e implementar polimorfismo via sobrescrita em classes concretas, aplicando em exemplos de GUI ou tratamento de exceções.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a Interface para Polimorfismo",
                                  "subSteps": [
                                    "Analise o problema para identificar comportamentos comuns que serão polimórficos, como 'desenhar' para formas em uma GUI.",
                                    "Crie uma nova interface usando a palavra-chave 'interface', definindo métodos abstratos sem implementação.",
                                    "Adicione métodos relevantes, como 'draw(Graphics g)' para um contexto de GUI em Java.",
                                    "Inclua Javadoc para documentar cada método, explicando parâmetros e retornos esperados.",
                                    "Compile a interface para verificar erros de sintaxe."
                                  ],
                                  "verification": "A interface compila sem erros e possui pelo menos um método abstrato relevante.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE como IntelliJ ou Eclipse",
                                    "JDK 8 ou superior"
                                  ],
                                  "tips": "Mantenha métodos da interface simples e focados em um único responsabilidade para facilitar implementações.",
                                  "learningObjective": "Compreender como interfaces definem contratos para polimorfismo.",
                                  "commonMistakes": [
                                    "Adicionar corpo de método na interface (use default methods apenas se necessário)",
                                    "Esquecer modificador public para métodos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar Classes Concretas que Implementam a Interface",
                                  "subSteps": [
                                    "Crie uma classe concreta, como Circle, que implemente a interface Drawable usando 'implements Drawable'.",
                                    "Sobrescreva todos os métodos da interface com implementações específicas, ex: calcular raio e desenhar círculo.",
                                    "Repita para outra classe, como Rectangle, com lógica própria para retângulo.",
                                    "Adicione construtores e campos necessários para cada classe.",
                                    "Teste compilação de cada classe individualmente."
                                  ],
                                  "verification": "Classes compilam e implementam corretamente todos os métodos da interface sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE",
                                    "JDK"
                                  ],
                                  "tips": "Use sobreposição de métodos (@Override) para evitar erros de digitação nos nomes.",
                                  "learningObjective": "Implementar comportamentos polimórficos em classes concretas.",
                                  "commonMistakes": [
                                    "Esquecer 'implements' na declaração da classe",
                                    "Não sobrescrever todos os métodos obrigatórios"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar Polimorfismo Usando Referências da Interface",
                                  "subSteps": [
                                    "Crie uma lista ou array de referências do tipo da interface (ex: List<Drawable>).",
                                    "Instancie objetos das classes concretas e adicione à lista.",
                                    "Itere pela lista chamando o método polimórfico (ex: forEach(shape -> shape.draw(g)).",
                                    "Execute o código em um contexto simples, como main() ou JPanel paintComponent.",
                                    "Observe o comportamento runtime: diferentes implementações executadas via mesma referência."
                                  ],
                                  "verification": "Programa executa sem erros e chama métodos corretos baseados no tipo runtime dos objetos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE",
                                    "JDK"
                                  ],
                                  "tips": "Use System.out.println para debugar qual classe está sendo chamada em cada iteração.",
                                  "learningObjective": "Aplicar polimorfismo em runtime com referências de interface.",
                                  "commonMistakes": [
                                    "Tentar chamar métodos específicos da classe concreta via referência da interface",
                                    "Não inicializar objetos corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Exemplo Prático de GUI ou Tratamento de Exceções",
                                  "subSteps": [
                                    "Integre em uma aplicação GUI: crie um JFrame com JPanel que desenha shapes polimórficas.",
                                    "Alternativa para exceções: defina interface Handler com handle(Exception), implemente por LoggerHandler e EmailHandler.",
                                    "Adicione código para tratar exceções ou desenhar via polimorfismo.",
                                    "Teste interativamente: clique para adicionar shapes ou simule exceções.",
                                    "Refatore para usar factory method criando objetos via interface."
                                  ],
                                  "verification": "Aplicação GUI roda e desenha shapes diferentes, ou exceções são tratadas polimorficamente sem crashes.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "IDE com suporte a Swing (Java)",
                                    "JDK"
                                  ],
                                  "tips": "Para GUI, override paintComponent(Graphics g) no JPanel para chamar draw().",
                                  "learningObjective": "Integrar polimorfismo com interfaces em cenários reais como GUI.",
                                  "commonMistakes": [
                                    "Não repintar painel após adicionar shapes (use repaint())",
                                    "Capturar exceções erradas no handler"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um app Java Swing onde uma interface Drawable é implementada por Circle e Rectangle. Uma lista de Drawable é populada com instâncias mistas. No paintComponent de um JPanel, itere a lista chamando draw(g), resultando em desenho polimórfico de formas diferentes sem if-else por tipo.",
                              "finalVerifications": [
                                "Código compila e executa sem erros de compilação ou runtime.",
                                "Métodos da interface são chamados corretamente via referências polimórficas.",
                                "Diferentes classes produzem comportamentos distintos no mesmo loop.",
                                "Aplicação GUI exibe formas desenhadas ou exceções tratadas adequadamente.",
                                "Refatoração para nova classe mantém funcionalidade intacta.",
                                "Javadoc cobre todos os métodos principais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e implementação da interface (sem métodos concretos indevidos).",
                                "Correto uso de polimorfismo (referências de interface chamando métodos sobrescritos).",
                                "Qualidade do exemplo prático (GUI funcional ou handlers de exceção eficazes).",
                                "Cobertura de verificações e testes em cada step.",
                                "Clareza no código com comentários e estrutura modular.",
                                "Eficiência: evita duplicação de código via polimorfismo."
                              ],
                              "crossCurricularConnections": [
                                "Design Patterns: Relaciona com Strategy ou Factory para extensibilidade.",
                                "Matemática: Cálculos geométricos em métodos draw() (ex: seno/cosseno para círculos).",
                                "Engenharia de Software: Abstração e acoplamento frouxo em sistemas modulares.",
                                "Banco de Dados: Polimorfismo em ORMs para diferentes tipos de entidades."
                              ],
                              "realWorldApplication": "Em frameworks como Java Swing/AWT para componentes GUI customizáveis (ex: plugins de botões com ações polimórficas), ou em Spring Boot para handlers de exceções globais onde diferentes exceções são tratadas por implementações intercambiáveis, permitindo escalabilidade sem alterar código cliente."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.3",
                            "name": "Analisar polimorfismo em padrões de projeto",
                            "description": "Examinar padrões básicos como Strategy ou Template Method, identificando como o polimorfismo permite variação de algoritmos sem alterar código cliente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Polimorfismo e Padrões de Projeto",
                                  "subSteps": [
                                    "Leia definições de polimorfismo em POO, focando em herança e interfaces.",
                                    "Estude introdução aos padrões de projeto GoF, destacando Strategy e Template Method.",
                                    "Identifique exemplos simples de polimorfismo em código básico (ex: shapes desenhando).",
                                    "Anote como polimorfismo abstrai implementações variáveis.",
                                    "Compare polimorfismo com composição estática."
                                  ],
                                  "verification": "Resuma em um diagrama UML mostrando polimorfismo básico e cite 3 benefícios.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Design Patterns' (capítulos iniciais)",
                                    "Documentação Java/ C# sobre interfaces",
                                    "Ferramenta de desenho UML como Lucidchart"
                                  ],
                                  "tips": "Use exemplos visuais para fixar conceitos abstratos.",
                                  "learningObjective": "Compreender como polimorfismo suporta flexibilidade em padrões de projeto.",
                                  "commonMistakes": [
                                    "Confundir polimorfismo com sobrecarga de métodos",
                                    "Ignorar o papel das interfaces abstratas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Padrão Strategy com Ênfase em Polimorfismo",
                                  "subSteps": [
                                    "Descreva a estrutura do Strategy: Context, Strategy interface e concretas.",
                                    "Examine código exemplo de Strategy para ordenação (QuickSort, MergeSort).",
                                    "Identifique onde polimorfismo ocorre: chamadas via interface sem conhecer implementação.",
                                    "Trace o fluxo: como o cliente varia algoritmos em runtime.",
                                    "Modifique o exemplo trocando estratégias e observe impacto zero no cliente.",
                                    "Crie um diagrama de classes mostrando polimorfismo."
                                  ],
                                  "verification": "Implemente um Strategy simples e execute com 2 estratégias diferentes, sem alterar o Context.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Refactor Guru - Strategy Pattern",
                                    "IDE como IntelliJ ou VS Code",
                                    "Exemplos GitHub de Strategy"
                                  ],
                                  "tips": "Sempre pergunte: 'O cliente sabe a implementação concreta?' Deve ser não.",
                                  "learningObjective": "Reconhecer polimorfismo como chave para intercâmbio de algoritmos em Strategy.",
                                  "commonMistakes": [
                                    "Usar herança em vez de composição",
                                    "Expor estratégias diretamente no Context"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Padrão Template Method com Ênfase em Polimorfismo",
                                  "subSteps": [
                                    "Descreva Template Method: classe abstrata com skeleton e métodos primitivos.",
                                    "Estude exemplo de framework de jogo (inicializar, jogar, finalizar).",
                                    "Identifique polimorfismo: subclasses sobrescrevem primitivos via herança.",
                                    "Trace como o template garante ordem sem alterar skeleton.",
                                    "Compare com Strategy: herança vs composição.",
                                    "Implemente uma variação, como relatório de dados."
                                  ],
                                  "verification": "Crie uma subclasse que altere apenas passos específicos e execute o template.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Refactor Guru - Template Method",
                                    "IDE com suporte a refatoração",
                                    "Exemplos em Java ou C++"
                                  ],
                                  "tips": "Foco no 'Hollywood Principle': não chame nós, nós chamamos você.",
                                  "learningObjective": "Identificar como polimorfismo via herança define hooks em Template Method.",
                                  "commonMistakes": [
                                    "Tornar o skeleton overridable",
                                    "Não usar métodos final para skeleton"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Aplicar Análise em um Caso Integrado",
                                  "subSteps": [
                                    "Compare Strategy e Template: quando usar cada um com polimorfismo.",
                                    "Escolha um problema real (ex: processador de pagamentos) e aplique ambos.",
                                    "Analise prós/contras: flexibilidade vs estrutura rígida.",
                                    "Refatore um código monolítico usando um deles, destacando polimorfismo.",
                                    "Documente ganhos: manutenção, extensibilidade.",
                                    "Teste cenários de variação de algoritmos."
                                  ],
                                  "verification": "Produza um relatório com diagramas, código e análise de 300 palavras.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "IDE para codificação",
                                    "Ferramentas de teste unitário (JUnit)",
                                    "Papel ou ferramenta para mindmaps"
                                  ],
                                  "tips": "Use métricas como cyclomatic complexity para quantificar benefícios.",
                                  "learningObjective": "Aplicar análise crítica de polimorfismo em padrões para cenários práticos.",
                                  "commonMistakes": [
                                    "Escolher padrão errado por viés",
                                    "Ignorar performance de chamadas virtuais"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar e Refinar a Análise",
                                  "subSteps": [
                                    "Revise seu código e diagramas com critérios de polimorfismo puro.",
                                    "Simule extensões futuras: adicionar nova estratégia/template.",
                                    "Colete feedback simulando code review.",
                                    "Otimize código removendo violações OCP.",
                                    "Registre lições aprendidas em um journal."
                                  ],
                                  "verification": "O código passa em testes e suporta nova implementação sem mudanças no cliente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Checklists de design patterns",
                                    "Ferramentas de linting/ análise estática"
                                  ],
                                  "tips": "Pergunte: 'Isso escala para 10 estratégias?'",
                                  "learningObjective": "Refinar habilidades de análise para robustez.",
                                  "commonMistakes": [
                                    "Sobre-engenharia desnecessária",
                                    "Não testar edge cases"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um e-commerce, use Strategy para pagamentos: Context=Checkout delega para PayPalStrategy ou CreditCardStrategy via interface PaymentStrategy. Polimorfismo permite adicionar CryptoStrategy sem alterar Checkout. Para Template Method, um GameProcessor abstrato define play() com hooks como render() sobrescritos por subclasses MobileGame ou WebGame.",
                              "finalVerifications": [
                                "Explicar verbalmente como polimorfismo isola o cliente em Strategy.",
                                "Implementar Template Method com 3 subclasses funcionais.",
                                "Identificar polimorfismo em código legado fornecido.",
                                "Comparar Strategy vs Template em um quadro.",
                                "Refatorar código sem polimorfismo para usar um padrão.",
                                "Discutir trade-offs em um par de programação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de pontos de polimorfismo (90%+).",
                                "Código limpo, compilável e testado.",
                                "Análise escrita clara com diagramas UML corretos.",
                                "Demonstração de OCP: extensões sem modificações.",
                                "Compreensão de diferenças entre padrões.",
                                "Criatividade em exemplos reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstração algorítmica similar a funções genéricas.",
                                "Engenharia de Software: Princípios SOLID (Liskov Substitution).",
                                "Análise de Sistemas: Modelagem de requisitos variáveis.",
                                "Lógica Computacional: Provas de corretude em algoritmos polimórficos."
                              ],
                              "realWorldApplication": "Frameworks como Spring usam Strategy para Beans configuráveis; jogos Unity aplicam Template Method em game loops; apps bancários variam regras de negócio via polimorfismo sem recompilar o core."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.3",
                "name": "Tipagem Estática e Dinâmica",
                "description": "Características e diferenças entre linguagens com tipagem estática e dinâmica.",
                "totalSkills": 46,
                "atomicTopics": [
                  {
                    "id": "10.1.3.1",
                    "name": "Definição de Tipagem Estática",
                    "description": "Tipagem onde os tipos de variáveis são verificados em tempo de compilação, exigindo declaração explícita.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.1.1",
                        "name": "Verificação de Tipos em Tempo de Compilação",
                        "description": "Na tipagem estática, o compilador analisa e verifica os tipos de todas as variáveis, expressões e operações antes da execução do programa, detectando erros de tipo durante a fase de compilação.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.1",
                            "name": "Definir verificação de tipos em tempo de compilação",
                            "description": "Explicar que a tipagem estática realiza a checagem de compatibilidade de tipos (como atribuição de int para string) exclusivamente na compilação, impedindo execução de código com erros de tipo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de verificação de tipos em tempo de compilação",
                                  "subSteps": [
                                    "Defina tipagem estática como um mecanismo onde tipos de variáveis são declarados explicitamente.",
                                    "Explique que a verificação ocorre antes da execução, durante a fase de compilação.",
                                    "Descreva como o compilador checa compatibilidade de tipos em atribuições, operações e chamadas de função.",
                                    "Liste tipos comuns: int, String, boolean, etc., e suas incompatibilidades.",
                                    "Discuta o objetivo: prevenir erros de tipo antes da runtime."
                                  ],
                                  "verification": "Escreva uma definição em suas palavras e identifique 3 exemplos de incompatibilidades de tipos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação de linguagens estáticas (Java/C++), notebook para anotações.",
                                  "tips": "Use analogia: compilador como um 'porteiro' que checa documentos antes de entrar na festa (execução).",
                                  "learningObjective": "Entender o que é e quando ocorre a verificação de tipos na compilação.",
                                  "commonMistakes": "Confundir com verificação em runtime; achar que todos os erros são detectados na compilação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar erros de tipo comuns detectados na compilação",
                                  "subSteps": [
                                    "Analise atribuições inválidas: int x = 'a';",
                                    "Examine operações incompatíveis: String + int sem concatenação explícita.",
                                    "Revise chamadas de método com parâmetros errados: método esperando double recebe String.",
                                    "Estude herança e polimorfismo: subclasses incompatíveis.",
                                    "Pratique listando 5 cenários de erro de tipo."
                                  ],
                                  "verification": "Liste 5 pares de tipos incompatíveis e explique por quê falham na compilação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Lista de tipos primitivos e referências de Java/C++.",
                                  "tips": "Pense em tipos como 'caixas' de tamanhos fixos; não cabe um na outra sem conversão.",
                                  "learningObjective": "Reconhecer padrões de incompatibilidade de tipos.",
                                  "commonMistakes": "Ignorar casting implícito; confundir widening/narrowing conversions."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar com código prático em linguagem estática",
                                  "subSteps": [
                                    "Escreva código Java inválido: public class Test { public static void main(String[] args) { int num = \"abc\"; } }",
                                    "Tente compilar com javac e observe o erro: incompatible types.",
                                    "Corrija adicionando casting ou mudança de tipo e recompile.",
                                    "Compare com código válido que compila e executa.",
                                    "Documente o output do compilador."
                                  ],
                                  "verification": "Compile um código com erro de tipo e capture a mensagem de erro exata.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "JDK instalado, editor como IntelliJ/VS Code, terminal para javac.",
                                  "tips": "Sempre declare tipos explicitamente para visualizar erros cedo.",
                                  "learningObjective": "Verificar na prática como o compilador bloqueia código com erros de tipo.",
                                  "commonMistakes": "Esquecer de salvar arquivo antes de compilar; usar linguagem dinâmica por engano."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Contrastar com verificação em tempo de execução e resumir benefícios",
                                  "subSteps": [
                                    "Compare com Python (dinâmica): int x = 'a' só falha em runtime.",
                                    "Explique vantagens: detecção precoce, performance melhor, código mais seguro.",
                                    "Discuta desvantagens: rigidez, necessidade de casts.",
                                    "Crie tabela comparativa: Compilação vs Runtime.",
                                    "Resuma em 3 pontos chave por quê tipagem estática é preferida em projetos grandes."
                                  ],
                                  "verification": "Crie uma tabela comparativa e explique 2 benefícios em um parágrafo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de texto, exemplos de código Python e Java lado a lado.",
                                  "tips": "Lembre: 'Fail fast' – melhor falhar na compilação que em produção.",
                                  "learningObjective": "Diferenciar estático vs dinâmico e valorizar a verificação em compilação.",
                                  "commonMistakes": "Achar que estática elimina todos os bugs; ignorar exceções em runtime."
                                }
                              ],
                              "practicalExample": "Em Java: int idade = \"vinte\"; // Erro de compilação: incompatible types: String cannot be converted to int. O compilador impede execução, evitando NullPointerException ou crashes em runtime.",
                              "finalVerifications": [
                                "Explica corretamente que verificação ocorre só na compilação, não em runtime.",
                                "Identifica e corrige erros de tipo em código fornecido.",
                                "Distingue tipagem estática de dinâmica com exemplos.",
                                "Lista pelo menos 3 benefícios da detecção precoce de erros.",
                                "Demonstra com código compilando com sucesso após correção.",
                                "Resume o conceito em 1-2 frases precisas."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: 30% (definição correta sem confusões).",
                                "Exemplos práticos: 25% (códigos válidos/inválidos com erros reais).",
                                "Compreensão comparativa: 20% (estática vs dinâmica).",
                                "Aplicação: 15% (correções e verificações independentes).",
                                "Clareza de comunicação: 10% (explicações concisas e sem jargões desnecessários)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Tipos como conjuntos com regras de inclusão (subtipos).",
                                "Lógica: Verificação como prova formal de consistência antes de execução.",
                                "Física/Engenharia: Analogia com testes de segurança antes de lançamento de produto.",
                                "Inglês: Leitura de mensagens de erro do compilador para debugging."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software enterprise (bancos, sistemas críticos), tipagem estática previne bilhões em custos com bugs; ex: erro no Twitter (2014) por atribuição errada poderia ser evitado na compilação."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.2",
                            "name": "Identificar erros detectados em compilação",
                            "description": "Reconhecer exemplos de erros como atribuição incompatível de tipos (ex: int x = 'a'; em C++) que são rejeitados pelo compilador em linguagens de tipagem estática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de erros de compilação em linguagens de tipagem estática",
                                  "subSteps": [
                                    "Defina erro de compilação como falha detectada pelo compilador antes da execução.",
                                    "Diferencie erros de compilação de erros de runtime e lógicos.",
                                    "Explique o papel da tipagem estática na detecção precoce de incompatibilidades.",
                                    "Estude exemplos básicos em C++, como sintaxe inválida.",
                                    "Revise o ciclo de compilação: pré-processamento, compilação, linkage."
                                  ],
                                  "verification": "Resuma em 3 frases a diferença entre erro de compilação e runtime, com exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação do compilador GCC/Clang",
                                    "Editor de texto como VS Code",
                                    "Tutorial online sobre ciclo de compilação em C++"
                                  ],
                                  "tips": [
                                    "Sempre leia a mensagem de erro completa; ela indica linha e tipo de problema.",
                                    "Use diagramas para visualizar o ciclo de compilação."
                                  ],
                                  "learningObjective": "Entender o que são erros de compilação e sua detecção em tempo de compilação.",
                                  "commonMistakes": [
                                    "Confundir com erros de runtime",
                                    "Ignorar a fase de linkage",
                                    "Não diferenciar tipagem estática de dinâmica"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar verificação de tipos em tempo de compilação",
                                  "subSteps": [
                                    "Aprenda como o compilador verifica compatibilidade de tipos durante a compilação.",
                                    "Identifique regras de tipos primitivos em C++: int, char, float, etc.",
                                    "Analise atribuições inválidas: ex. int x = 'a'; (char para int sem cast).",
                                    "Estude promoção e conversão implícita de tipos.",
                                    "Pratique lendo especificações de tipos na referência C++."
                                  ],
                                  "verification": "Classifique 3 pares de tipos como compatíveis ou incompatíveis e justifique.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Referência C++ (cppreference.com)",
                                    "Compilador online como Godbolt.org",
                                    "Lista de tipos primitivos C++"
                                  ],
                                  "tips": [
                                    "Use 'static_cast' para conversões explícitas e evite implícitas arriscadas.",
                                    "Teste no compilador para validar hipóteses."
                                  ],
                                  "learningObjective": "Dominar como a verificação de tipos previne erros em tempo de compilação.",
                                  "commonMistakes": [
                                    "Assumir conversão automática sempre funciona",
                                    "Confundir char com string",
                                    "Ignorar qualificadores como const"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar erros comuns de atribuição incompatível de tipos",
                                  "subSteps": [
                                    "Liste erros típicos: int = char, float = string, void* = int.",
                                    "Analise mensagens de erro do compilador: 'cannot convert char to int'.",
                                    "Corrija exemplos errados adicionando casts ou alterando tipos.",
                                    "Compare com linguagens dinâmicas como Python, onde passa na compilação.",
                                    "Crie 3 exemplos próprios de atribuições inválidas."
                                  ],
                                  "verification": "Forneça 3 códigos C++ com erros de tipo e aponte o problema exato.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor IDE com suporte a C++ (Code::Blocks ou CLion)",
                                    "Exemplos de código com erros preparados",
                                    "Compilador g++ instalado"
                                  ],
                                  "tips": [
                                    "Copie a mensagem de erro e pesquise-a diretamente.",
                                    "Use -Wall flag no g++ para warnings extras."
                                  ],
                                  "learningObjective": "Reconhecer e nomear erros de atribuição incompatível em códigos fonte.",
                                  "commonMistakes": [
                                    "Não notar sutilezas como signed/unsigned",
                                    "Confundir literais numéricos",
                                    "Esquecer de incluir headers necessários"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar detecção e correção de erros em códigos reais",
                                  "subSteps": [
                                    "Compile 5 códigos com erros plantados e identifique todos os erros de tipo.",
                                    "Explique por que cada erro é detectado em compilação, não runtime.",
                                    "Refatore os códigos para compilar sem erros.",
                                    "Discuta cenários onde casts são necessários vs. mudança de design.",
                                    "Registre lições aprendidas em um log pessoal."
                                  ],
                                  "verification": "Compile e corrija um código complexo com múltiplos erros de tipo com 100% de sucesso.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "5 arquivos .cpp com erros (criados ou baixados)",
                                    "Terminal com g++",
                                    "Debugger como gdb (opcional)"
                                  ],
                                  "tips": [
                                    "Comece pelos erros mais óbvios listados primeiro.",
                                    "Teste incrementalmente após cada correção."
                                  ],
                                  "learningObjective": "Aplicar identificação de erros em cenários práticos de programação.",
                                  "commonMistakes": [
                                    "Corrigir sintaxe em vez de tipo",
                                    "Ignorar warnings como erros",
                                    "Não testar após correção"
                                  ]
                                }
                              ],
                              "practicalExample": "Em C++, o código 'int main() { int numero = 'A'; std::cout << numero; return 0; }' falha na compilação com erro 'cannot convert ‘char’ to ‘int’ in initialization'. Isso ocorre porque 'A' é um literal char (ASCII 65), incompatível com int sem cast explícito como static_cast<int>('A'). Correção: int numero = static_cast<int>('A');.",
                              "finalVerifications": [
                                "Identifica corretamente 90% dos erros de tipo em 10 exemplos aleatórios.",
                                "Explica a mensagem de erro do compilador em termos de tipos envolvidos.",
                                "Corrige atribuições incompatíveis usando casts apropriados.",
                                "Distingue erros de compilação de outros tipos em logs de build.",
                                "Cria exemplos próprios de erros detectáveis em compilação.",
                                "Compila código sem erros após identificar e corrigir problemas de tipo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do erro específico (tipo incompatível).",
                                "Qualidade da explicação causal (por que o compilador rejeita).",
                                "Eficiência na correção proposta (mínimas alterações).",
                                "Compreensão de implicações em tipagem estática vs. dinâmica.",
                                "Criatividade em exemplos práticos fornecidos.",
                                "Velocidade e confiança na análise de novos códigos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Raciocínio lógico e conjuntos (compatibilidade de tipos como interseções).",
                                "Língua Portuguesa/Inglês: Interpretação de mensagens de erro técnicas.",
                                "Física/Engenharia: Modelagem precisa de sistemas (tipos como unidades físicas).",
                                "Desenvolvimento Ágil: Integração em pipelines CI/CD para detecção automática.",
                                "Ética em Computação: Evitar hacks como casts forçados que mascaram problemas."
                              ],
                              "realWorldApplication": "No desenvolvimento de software profissional, como em sistemas bancários ou embarcados (ex: Arduino), identificar erros de compilação acelera o debugging, reduz tempo de release e previne falhas críticas, como atribuições erradas que poderiam corromper dados financeiros ou sensores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.3",
                            "name": "Comparar com verificação em tempo de execução",
                            "description": "Diferenciar a detecção precoce de erros na compilação (tipagem estática) da detecção tardia em runtime (tipagem dinâmica, como em Python).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Verificação de Tipos em Tempo de Compilação (Tipagem Estática)",
                                  "subSteps": [
                                    "Defina tipagem estática e verifique como o compilador inspeciona tipos antes da execução.",
                                    "Estude linguagens como Java ou TypeScript: compile um código simples com erro de tipo.",
                                    "Analise mensagens de erro do compilador e identifique detecção precoce.",
                                    "Compare com fluxograma de processo de compilação.",
                                    "Pesquise vantagens como redução de bugs em runtime."
                                  ],
                                  "verification": "Compilação bem-sucedida de código correto e falha com erro de tipo, com captura de screenshot das mensagens.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de código (VS Code)",
                                    "Compilador TypeScript ou Java (Node.js + tsc, ou JDK)",
                                    "Documentação oficial de TypeScript/Java"
                                  ],
                                  "tips": "Sempre leia as mensagens de erro do compilador com atenção; elas indicam exatamente o problema de tipo.",
                                  "learningObjective": "Compreender como a tipagem estática detecta erros antes da execução, promovendo código mais robusto.",
                                  "commonMistakes": "Confundir erros de sintaxe com erros de tipo; ignorar warnings do compilador."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Verificação de Tipos em Tempo de Execução (Tipagem Dinâmica)",
                                  "subSteps": [
                                    "Defina tipagem dinâmica e como tipos são verificados apenas durante a execução.",
                                    "Escreva e execute código Python com erro de tipo (ex: somar int e str).",
                                    "Observe o traceback de erro em runtime e identifique o momento da falha.",
                                    "Compare com fluxograma de interpretação/execução em Python.",
                                    "Liste desvantagens como bugs descobertos tarde."
                                  ],
                                  "verification": "Execução de código Python que gera TypeError em runtime, com log do erro salvo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python 3.x instalado",
                                    "Editor/IDLE ou Jupyter Notebook",
                                    "Documentação Python sobre exceções"
                                  ],
                                  "tips": "Use print() ou debugger para inspecionar tipos em runtime com type() ou isinstance().",
                                  "learningObjective": "Reconhecer como a tipagem dinâmica adia verificações, permitindo flexibilidade mas riscos maiores.",
                                  "commonMistakes": "Assumir que código sem erros de sintaxe roda perfeitamente; não tratar exceções adequadamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar e Contrastar os Dois Mecanismos",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: compile-time vs runtime (timing, detecção, prós/contras).",
                                    "Discuta cenários: quando static é melhor (projetos grandes) vs dynamic (prototipagem rápida).",
                                    "Analise impacto em produtividade e manutenção de código.",
                                    "Debata com exemplos reais de projetos open-source.",
                                    "Sintetize em um resumo de 1 parágrafo."
                                  ],
                                  "verification": "Tabela comparativa completa e resumo escrito, revisado por pares ou autoavaliação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou papel para tabela",
                                    "Exemplos de código dos steps anteriores"
                                  ],
                                  "tips": "Use bullet points para prós/contras; foque em evidências práticas não opiniões.",
                                  "learningObjective": "Diferenciar claramente detecção precoce (estática) de tardia (dinâmica), com exemplos contextualizados.",
                                  "commonMistakes": "Generalizar demais sem exemplos; ignorar trade-offs como performance vs flexibilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Comparação em Exemplos Práticos Mistos",
                                  "subSteps": [
                                    "Refatore um código Python com erros potenciais para TypeScript, observando mudanças.",
                                    "Teste cenários híbridos (ex: Node.js com TypeScript vs puro JS).",
                                    "Simule debugging: tempo gasto em cada abordagem.",
                                    "Documente lições aprendidas em um relatório curto.",
                                    "Crie um checklist para escolher tipagem em projetos."
                                  ],
                                  "verification": "Relatório com códigos refatorados, tempos medidos e checklist finalizado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ambiente misto: Node.js, TypeScript, Python",
                                    "Git para versionamento"
                                  ],
                                  "tips": "Meça tempo real de debug para dados concretos na comparação.",
                                  "learningObjective": "Aplicar o conhecimento comparativo para tomar decisões informadas sobre tipagem.",
                                  "commonMistakes": "Não versionar código; pular medições quantitativas de tempo/eficiência."
                                }
                              ],
                              "practicalExample": "Em TypeScript: function soma(a: number, b: number): number { return a + b; } soma(1, '2'); // Erro de compile: Argument of type 'string' is not assignable to parameter of type 'number'. Em Python: def soma(a, b): return a + b; soma(1, '2') # TypeError em runtime: unsupported operand type(s) for +: 'int' and 'str'.",
                              "finalVerifications": [
                                "Explicar verbalmente ou por escrito a diferença de timing de detecção.",
                                "Identificar corretamente erros estáticos vs dinâmicos em códigos fornecidos.",
                                "Criar tabela comparativa precisa com pelo menos 5 diferenças chave.",
                                "Demonstrar refatoração de código dinâmico para estático sem perda de funcionalidade.",
                                "Aplicar checklist em um cenário hipotético de projeto."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de static vs dynamic (80%).",
                                "Uso de exemplos concretos e código funcional (90%).",
                                "Análise equilibrada de prós/contras com evidências (85%).",
                                "Clareza na tabela/comparação e verificações práticas (75%).",
                                "Checklist prático e aplicável (80%).",
                                "Profundidade: menção a performance, manutenção e cenários reais (90%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica formal e prova de propriedades (tipos como teoremas).",
                                "Língua Portuguesa/Inglês: Redação técnica de relatórios e documentação de código.",
                                "Física/Engenharia: Modelagem de sistemas robustos e prevenção de falhas catastróficas.",
                                "Estatística: Análise de dados de bugs e métricas de qualidade de software."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software empresarial (ex: bancos), tipagem estática previne erros caros em produção, como transferências financeiras erradas detectadas só em runtime; acelera debugging em equipes grandes e melhora CI/CD pipelines."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.2",
                        "name": "Declaração Explícita de Tipos de Variáveis",
                        "description": "Exigência em linguagens de tipagem estática de que o programador declare o tipo exato de cada variável no momento de sua criação, como 'int x;' ou 'String nome;' em Java.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.2.1",
                            "name": "Realizar declaração explícita de variáveis",
                            "description": "Escrever declarações de variáveis com tipos explícitos em linguagens OO como C++ (ex: class Pessoa { int idade; };) ou Java, garantindo conformidade com a tipagem estática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de declaração explícita de variáveis em tipagem estática",
                                  "subSteps": [
                                    "Estude a definição de tipagem estática: tipos de variáveis são conhecidos em tempo de compilação.",
                                    "Diferencie declaração explícita (especificar tipo manualmente) de implícita (inferido pelo compilador).",
                                    "Analise exemplos: int x = 5; vs auto x = 5; (em C++ moderno).",
                                    "Revise benefícios: detecção de erros precoces, otimização de performance.",
                                    "Compare com linguagens dinâmicas como Python (x = 5)."
                                  ],
                                  "verification": "Resuma em suas palavras os benefícios da declaração explícita e liste 3 diferenças com tipagem dinâmica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação oficial de C++ (cppreference.com) e Java (docs.oracle.com), notebook para anotações.",
                                  "tips": "Use diagramas para visualizar fluxo de compilação com tipagem estática.",
                                  "learningObjective": "Explicar o papel da declaração explícita na tipagem estática e seus impactos na programação OO.",
                                  "commonMistakes": "Confundir com alocação de memória; ignorar que declaração não inicializa valores."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar a sintaxe de declaração explícita em C++",
                                  "subSteps": [
                                    "Declare variáveis locais: int idade = 25; double salario = 3000.50;",
                                    "Declare membros de classe: class Pessoa { private: int idade; public: Pessoa(int i) : idade(i) {} };",
                                    "Use qualificadores: const int MAX = 100; static int contador;",
                                    "Pratique com tipos compostos: std::string nome = \"João\"; std::vector<int> lista;",
                                    "Compile um snippet simples com g++."
                                  ],
                                  "verification": "Compile um programa C++ com 5 declarações variadas sem erros de sintaxe.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Compilador GCC, IDE como Code::Blocks ou VS Code com extensão C++.",
                                  "tips": "Sempre inicialize variáveis para evitar valores indefinidos (garbage).",
                                  "learningObjective": "Escrever declarações explícitas corretas para diferentes escopos em C++.",
                                  "commonMistakes": "Esquecer ponto e vírgula (;); usar = em construtores em vez de : para inicialização."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar a sintaxe de declaração explícita em Java",
                                  "subSteps": [
                                    "Declare variáveis locais: int idade = 25; double salario = 3000.50;",
                                    "Declare campos de classe: public class Pessoa { private int idade; private String nome; }",
                                    "Use tipos primitivos vs wrappers: int vs Integer; String nome = \"João\";",
                                    "Pratique arrays e coleções: int[] idades = new int[10]; List<String> nomes = new ArrayList<>();",
                                    "Compile com javac e execute."
                                  ],
                                  "verification": "Compile e execute uma classe Java com declarações de campos e métodos acessando-as.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "JDK 17+, IDE como IntelliJ IDEA Community ou Eclipse.",
                                  "tips": "Prefira tipos primitivos para performance em loops intensos.",
                                  "learningObjective": "Escrever declarações explícitas corretas para classes e métodos em Java.",
                                  "commonMistakes": "Confundir tipos primitivos com objetos (int vs Integer); esquecer modificadores de acesso."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar declarações em uma classe OO completa e verificar conformidade",
                                  "subSteps": [
                                    "Crie uma classe Pessoa com campos explícitos: idade (int), nome (String), salario (double).",
                                    "Adicione construtor e getters/setters com declarações explícitas.",
                                    "Instancie objetos e acesse variáveis em main().",
                                    "Teste atribuições inválidas para ver erros de compilação (ex: String para int).",
                                    "Refatore para usar const/ final onde aplicável."
                                  ],
                                  "verification": "Programa compila e executa corretamente, com variáveis tipadas acessadas sem runtime errors.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "IDE integrada para C++/Java, exemplos de código-fonte online (GeeksforGeeks).",
                                  "tips": "Use debugger para inspecionar tipos em runtime após compilação.",
                                  "learningObjective": "Integrar declarações explícitas em estruturas OO funcionais.",
                                  "commonMistakes": "Declarar campos públicos desnecessariamente; não tratar exceções de tipo em setters."
                                }
                              ],
                              "practicalExample": "Em Java: public class Pessoa { private int idade; private String nome; public Pessoa(int i, String n) { idade = i; nome = n; } public int getIdade() { return idade; } } Em C++: class Pessoa { private: int idade; std::string nome; public: Pessoa(int i, std::string n) : idade(i), nome(n) {} int getIdade() { return idade; } }; Compile e teste instanciação: Pessoa p(25, \"João\");",
                              "finalVerifications": [
                                "Todas as declarações usam tipos explícitos sem inferência (auto/var).",
                                "Compilação sem warnings de tipo ou inicialização pendente.",
                                "Variáveis mantêm tipos corretos em acessos e atribuições.",
                                "Getters/setters respeitam tipagem estática sem casts desnecessários.",
                                "Teste unitário passa verificando valores tipados.",
                                "Nenhum erro de runtime relacionado a tipos incompatíveis."
                              ],
                              "assessmentCriteria": [
                                "Correção sintática: 100% das declarações válidas para C++/Java.",
                                "Uso apropriado de escopos (private/public/local).",
                                "Inicialização explícita em construtores.",
                                "Tratamento de tipos primitivos vs referência.",
                                "Detecção e correção de 3 erros comuns de tipagem.",
                                "Eficiência: sem overhead desnecessário por tipagem errada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Seleção de tipos numéricos (int/double) baseada em precisão e range.",
                                "Lógica e Algoritmos: Planejamento prévio de tipos para otimizar fluxos de dados.",
                                "Física/Engenharia: Modelagem de entidades reais com atributos tipados (ex: velocidade como double).",
                                "Inglês Técnico: Leitura de docs oficiais para sintaxe precisa.",
                                "Ética em Computação: Tipagem estática previne bugs caros em produção."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software empresarial, declarações explícitas em C++/Java garantem robustez em sistemas bancários (ex: contas com saldos double precisos) ou jogos (posições int/float), detectando erros de tipo na compilação e evitando falhas custosas em produção, como conversões implícitas erradas em transações financeiras."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.2.2",
                            "name": "Exemplificar declaração em contextos OO",
                            "description": "Demonstrar declaração de tipos em classes OO, como atributos tipados em métodos (ex: void setIdade(int idade) em Java), destacando benefícios para compilação segura.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos básicos de declaração de tipos em classes OO",
                                  "subSteps": [
                                    "Estudar a sintaxe básica de classes em Java (declaração com 'class').",
                                    "Identificar locais para declaração de atributos tipados (private int, String etc.).",
                                    "Analisar exemplos de métodos com parâmetros e retornos tipados.",
                                    "Diferenciar tipagem estática (compile-time) de dinâmica (runtime).",
                                    "Listar benefícios como detecção precoce de erros."
                                  ],
                                  "verification": "Escrever um resumo de 5 linhas explicando declaração tipada em OO.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação oficial Java (Oracle Docs)",
                                    "Editor de texto como VS Code"
                                  ],
                                  "tips": "Use exemplos simples como 'int idade' para fixar a ideia.",
                                  "learningObjective": "Dominar os fundamentos de declaração explícita de tipos em estruturas OO.",
                                  "commonMistakes": [
                                    "Confundir atributos de classe com variáveis locais.",
                                    "Ignorar modificadores como 'private'."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar uma classe simples com atributos tipados",
                                  "subSteps": [
                                    "Definir uma classe 'Pessoa' com atributos: private int id, private String nome, private int idade.",
                                    "Implementar um construtor que receba e inicialize esses atributos tipados.",
                                    "Declarar métodos de acesso básico, como toString() tipado para String.",
                                    "Compilar o código para verificar erros de tipo.",
                                    "Adicionar validações simples nos atributos (ex: idade > 0)."
                                  ],
                                  "verification": "Compilar a classe sem erros e exibir o código fonte.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "JDK instalado",
                                    "IDE como IntelliJ ou Eclipse"
                                  ],
                                  "tips": "Sempre use 'this.' para evitar shadowing de variáveis.",
                                  "learningObjective": "Praticar declaração e inicialização de atributos tipados em uma classe.",
                                  "commonMistakes": [
                                    "Declarar sem tipo (ex: var idade; em Java antigo).",
                                    "Usar tipos errados como String para id numérico."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar métodos getters e setters tipados",
                                  "subSteps": [
                                    "Criar setter para idade: public void setIdade(int idade).",
                                    "Criar getter correspondente: public int getIdade().",
                                    "Adicionar setter e getter para nome: public void setNome(String nome), public String getNome().",
                                    "Testar chamadas em um método main() com instância da classe.",
                                    "Comparar com código sem tipos para observar erros de compilação."
                                  ],
                                  "verification": "Executar main() e confirmar que setters/getters funcionam sem erros runtime.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE com debugger",
                                    "Compilador Java"
                                  ],
                                  "tips": "Siga convenções de nomenclatura: get/set + nome da propriedade.",
                                  "learningObjective": "Aplicar declaração de tipos em métodos de encapsulamento OO.",
                                  "commonMistakes": [
                                    "Retornar tipo errado no getter.",
                                    "Passar parâmetro sem tipo no setter."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar benefícios e refatorar código não-tipado",
                                  "subSteps": [
                                    "Criar versão sem tipos (comentada ou em outra linguagem simulada).",
                                    "Introduzir erro intencional (ex: passar String para int) e observar falha em compile-time.",
                                    "Executar testes unitários simples na classe tipada.",
                                    "Documentar 3 benefícios observados (segurança, performance, legibilidade).",
                                    "Refatorar uma classe existente para incluir tipagem explícita."
                                  ],
                                  "verification": "Relatório com prints de compilação bem-sucedida e erro detectado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "JUnit para testes (opcional)",
                                    "IDE com console"
                                  ],
                                  "tips": "Use System.out.println para logs rápidos de verificação.",
                                  "learningObjective": "Demonstrar vantagens práticas da tipagem estática em OO.",
                                  "commonMistakes": [
                                    "Testar apenas runtime, ignorando compile-time.",
                                    "Não validar entradas nos setters."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie a classe Pessoa:\npublic class Pessoa {\n  private int id;\n  private String nome;\n  private int idade;\n\n  public Pessoa(int id, String nome, int idade) {\n    this.id = id;\n    this.nome = nome;\n    this.idade = idade;\n  }\n\n  public void setIdade(int idade) {\n    if (idade > 0) this.idade = idade;\n  }\n\n  public int getIdade() { return idade; }\n\n  public String toString() { return \"Pessoa[id=\" + id + \", nome=\" + nome + \", idade=\" + idade + \"]\"; }\n}\n\nNo main: Pessoa p = new Pessoa(1, \"João\", 30); p.setIdade(31); System.out.println(p); // Compila e executa seguro.",
                              "finalVerifications": [
                                "Classe compila sem warnings de tipo.",
                                "Métodos getters/setters funcionam com dados corretos sem erros runtime.",
                                "Erros de tipo (ex: String em int) são rejeitados em compile-time.",
                                "Instância é criada e manipulada corretamente em teste main().",
                                "Benefícios como segurança e legibilidade são explicitados em comentários.",
                                "Código segue padrões OO (encapsulamento)."
                              ],
                              "assessmentCriteria": [
                                "Correção sintática em todas as declarações de tipos (100%).",
                                "Uso apropriado de tipos primitivos (int) e referência (String).",
                                "Implementação completa de pelo menos 3 métodos tipados.",
                                "Demonstração clara de benefícios via testes e comparação.",
                                "Validações básicas nos setters para robustez.",
                                "Código limpo, comentado e legível."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Uso de tipos numéricos (int, double) e operações aritméticas em validações.",
                                "Língua Portuguesa: Nomenclatura clara e camelCase para variáveis e métodos.",
                                "Lógica e Algoritmos: Estruturas condicionais em setters para checagem de tipos.",
                                "Inglês Técnico: Convenções de naming de Java (getters/setters)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps empresariais como sistemas de RH, declaração tipada em classes (ex: Employee com int salary) previne erros caros como depósitos errados em bancos ou idades inválidas em cadastros, garantindo compilação segura e redução de bugs em produção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.2.3",
                            "name": "Diferenciar de inferência de tipos",
                            "description": "Contrastar declaração explícita (obrigatória em tipagem estática pura) com type inference (parcial em linguagens como C# com 'var'), explicando impactos na verificação estática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Declaração Explícita de Tipos",
                                  "subSteps": [
                                    "Defina declaração explícita como a especificação manual do tipo de uma variável na declaração, ex: int x = 5; em C# ou Java.",
                                    "Identifique cenários onde é obrigatória em tipagem estática pura, como funções sem inferência.",
                                    "Analise vantagens: clareza imediata para o leitor do código.",
                                    "Examine desvantagens: verbosidade e necessidade de atualização em refatorações.",
                                    "Pratique declarando variáveis com tipos explícitos em um editor."
                                  ],
                                  "verification": "Escreva 5 declarações explícitas de variáveis diferentes e compile sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código (VS Code com C# extension), documentação oficial do C#.",
                                  "tips": "Sempre leia o código em voz alta para verificar se o tipo faz sentido no contexto.",
                                  "learningObjective": "Explicar e aplicar declaração explícita de tipos em código estático.",
                                  "commonMistakes": "Confundir com inferência ao usar tipos genéricos sem especificar."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Inferência de Tipos",
                                  "subSteps": [
                                    "Defina inferência de tipos como o processo onde o compilador deduce o tipo automaticamente, ex: var x = 5; em C#, inferido como int.",
                                    "Estude limitações: funciona apenas em inicializações e não em declarações sem valor.",
                                    "Compare com linguagens como TypeScript, onde inferência é parcial.",
                                    "Teste inferência com diferentes literais (string, array, objetos anônimos).",
                                    "Verifique o tipo inferido usando ferramentas de IDE."
                                  ],
                                  "verification": "Converta 5 declarações explícitas para 'var' e confirme tipos via IntelliSense ou hover.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "IDE com suporte a C# (Visual Studio ou Rider), exemplos de código online.",
                                  "tips": "Use 'var' apenas quando o tipo é óbvio do lado direito da atribuição.",
                                  "learningObjective": "Identificar e utilizar inferência de tipos corretamente em contextos suportados.",
                                  "commonMistakes": "Assumir inferência em loops ou condições sem inicialização."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Contrastar Declaração Explícita e Inferência",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: obrigatoriedade, legibilidade, manutenção.",
                                    "Escreva código lado a lado: int x = 5; vs var x = 5; e discuta diferenças.",
                                    "Debata cenários ideais para cada: explícita para APIs públicas, inferência para código interno.",
                                    "Analise refatoração: como mudar tipos afeta cada abordagem.",
                                    "Discuta suporte em linguagens: C# (parcial), Rust (limitada), Haskell (forte)."
                                  ],
                                  "verification": "Produza uma tabela Markdown com 5 diferenças chave e 3 exemplos de código.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramenta de Markdown (Obsidian ou GitHub), compilador C#.",
                                  "tips": "Pense em 'quem lê o código': explícita beneficia iniciantes.",
                                  "learningObjective": "Diferenciar precisamente as duas abordagens com exemplos.",
                                  "commonMistakes": "Ignorar que inferência falha em casos ambíguos como var x = null;"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Impactos na Verificação Estática",
                                  "subSteps": [
                                    "Explique verificação estática: detecção de erros em tempo de compilação via tipos.",
                                    "Compare: explícita permite verificação imediata; inferência adia para análise do compilador.",
                                    "Teste erros: atribuição incompatível em var vs explícito.",
                                    "Discuta performance: inferência pode adicionar overhead mínimo no compilador.",
                                    "Avalie em grandes projetos: legibilidade vs confiança no compilador."
                                  ],
                                  "verification": "Crie código com erros de tipo usando ambas abordagens e compare mensagens de erro do compilador.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Compilador C# (dotnet CLI), exemplos de código com erros intencionais.",
                                  "tips": "Use 'option strict on' em VB.NET ou warnings em C# para rigor.",
                                  "learningObjective": "Avaliar como cada método afeta detecção estática de erros.",
                                  "commonMistakes": "Subestimar ambiguidades em inferência com genéricos."
                                }
                              ],
                              "practicalExample": "Em C#, declare explicitamente: string nome = \"Alice\"; int idade = 30; vs inferência: var nome = \"Alice\"; var idade = 30; Compile e tente atribuir idade = \"30\"; – explícita falha imediatamente, inferência também após dedução.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças chave sem consultar notas.",
                                "Converter código misto (explícito/inferido) e identificar tipos corretamente.",
                                "Criar snippet com erro de tipo detectado apenas por verificação estática.",
                                "Comparar legibilidade de 10 linhas de código em ambas formas.",
                                "Discutir prós/contras em um parágrafo coeso."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção: 100% correto em definições.",
                                "Exemplos práticos: Pelo menos 3 códigos funcionais.",
                                "Análise de impactos: Cobertura completa de verificação estática.",
                                "Profundidade comparativa: Tabela ou lista com 5+ pontos.",
                                "Clareza e originalidade: Explicações sem cópias literais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Tipos como conjuntos fechados vs inferência como funções de mapeamento.",
                                "Lógica: Dedução (inferência) vs axiomas explícitos.",
                                "Linguística: Semântica explícita vs implícita em linguagem natural.",
                                "Design de Software: Trade-offs em UX de código (legibilidade vs concisão)."
                              ],
                              "realWorldApplication": "Em equipes de desenvolvimento, declaração explícita melhora onboarding de novos devs em APIs legadas, enquanto inferência acelera prototipagem em C# ou Kotlin, reduzindo boilerplate sem sacrificar verificação estática em IDEs como Visual Studio."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.3",
                        "name": "Características Gerais da Tipagem Estática",
                        "description": "Propriedades fundamentais como detecção precoce de erros, performance otimizada pelo compilador e rigidez de tipos, comuns em linguagens OO como C++ e Java.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.3.1",
                            "name": "Listar vantagens da tipagem estática",
                            "description": "Descrever benefícios como redução de bugs em runtime, otimização de código pelo compilador e suporte a refatoração segura em projetos OO grandes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Tipagem Estática",
                                  "subSteps": [
                                    "Defina tipagem estática como verificação de tipos em tempo de compilação.",
                                    "Compare brevemente com tipagem dinâmica (verificação em runtime).",
                                    "Identifique linguagens exemplares: Java, C#, TypeScript.",
                                    "Liste componentes chave: declaração de variáveis com tipos explícitos.",
                                    "Analise um exemplo simples de declaração tipada vs não tipada."
                                  ],
                                  "verification": "Escreva uma definição precisa e cite 3 linguagens com tipagem estática.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial de Java ou TypeScript",
                                    "Editor de código como VS Code"
                                  ],
                                  "tips": "Use diagramas para visualizar o fluxo de compilação vs execução.",
                                  "learningObjective": "Compreender a base da tipagem estática para contextualizar vantagens.",
                                  "commonMistakes": "Confundir tipagem estática com compilação total; lembre que scripts podem ser interpretados com types."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Redução de Bugs em Runtime",
                                  "subSteps": [
                                    "Explique como erros de tipo são detectados antes da execução.",
                                    "Simule um erro comum: atribuição de string a variável inteira.",
                                    "Compare cenários: código Java (falha em compile) vs JavaScript (falha em runtime).",
                                    "Calcule impacto: estime redução de 15-50% em bugs de tipo.",
                                    "Discuta testes unitários complementares."
                                  ],
                                  "verification": "Crie um snippet de código que demonstre erro pego em compile time.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Playground online como TypeScript Playground ou Replit",
                                    "Exemplos de código Java/JS"
                                  ],
                                  "tips": "Execute o código dinâmico até falhar para sentir a diferença.",
                                  "learningObjective": "Identificar como tipagem estática previne falhas em produção.",
                                  "commonMistakes": "Subestimar bugs sutis; foque em casos como null/undefined."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Otimização de Código pelo Compilador",
                                  "subSteps": [
                                    "Descreva otimizações: inlining, dead code elimination baseadas em tipos conhecidos.",
                                    "Examine bytecode gerado em linguagens como Java (javap).",
                                    "Compare performance: benchmark simples de loop tipado vs genérico.",
                                    "Discuta AOT (Ahead-of-Time) compilation em contextos OO.",
                                    "Relacione com tree-shaking em TypeScript."
                                  ],
                                  "verification": "Gere e compare bytecode ou performance metrics de dois códigos similares.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta javap para Java",
                                    "Node.js com --inspect para JS",
                                    "Benchmark.js"
                                  ],
                                  "tips": "Use flags de otimização no compilador para ver diferenças.",
                                  "learningObjective": "Entender ganhos de performance via análise estática.",
                                  "commonMistakes": "Ignorar overhead inicial de compilação; equilibre com ganhos em runtime."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Investigar Suporte a Refatoração Segura em Projetos OO Grandes",
                                  "subSteps": [
                                    "Defina refatoração: renomear método/classe sem quebrar código.",
                                    "Demonstre IDEs: refactor em IntelliJ para Java vs manual em JS.",
                                    "Analise hierarquias OO: polimorfismo tipado vs duck typing.",
                                    "Discuta escalabilidade: equipes grandes em monorepos.",
                                    "Liste ferramentas: TypeScript LSP, Java Lombok."
                                  ],
                                  "verification": "Realize uma refatoração em um mini-projeto OO e verifique erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE como IntelliJ ou VS Code com extensões",
                                    "Projeto sample GitHub com classes OO"
                                  ],
                                  "tips": "Comece com projeto pequeno para ver confiança do IDE.",
                                  "learningObjective": "Aplicar vantagens em cenários de desenvolvimento colaborativo.",
                                  "commonMistakes": "Confundir refatoração com reescrita; foque em segurança automatizada."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Listar Todas as Vantagens",
                                  "subSteps": [
                                    "Compile lista: redução bugs, otimização, refatoração, IDE support, documentação implícita.",
                                    "Priorize por impacto em projetos OO grandes.",
                                    "Crie tabela comparativa estática vs dinâmica.",
                                    "Debata limitações: verbosidade inicial.",
                                    "Formule statement: 'Tipagem estática acelera desenvolvimento seguro em escala.'"
                                  ],
                                  "verification": "Escreva uma lista numerada de 5+ vantagens com exemplos breves.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou Markdown para tabela"
                                  ],
                                  "tips": "Use bullet points para clareza em apresentações futuras.",
                                  "learningObjective": "Consolidar conhecimento em uma lista acionável e memorizável.",
                                  "commonMistakes": "Listar vantagens genéricas; ancorar em exemplos concretos."
                                }
                              ],
                              "practicalExample": "Em um sistema de e-commerce OO em Java, declarar 'List<Product> inventory' permite compilador detectar erro ao adicionar 'User' ao invés de 'Product', evitando crash em runtime durante pico de vendas. Refatorar 'getPrice()' para 'calculatePrice()' atualiza todos usos automaticamente via IDE.",
                              "finalVerifications": [
                                "Pode listar pelo menos 5 vantagens específicas sem consultar notas?",
                                "Explica redução de bugs com exemplo código?",
                                "Demonstra otimização comparando performance?",
                                "Realiza refatoração segura em projeto sample?",
                                "Cria tabela comparativa estática vs dinâmica?",
                                "Discute aplicação em projetos OO grandes?"
                              ],
                              "assessmentCriteria": [
                                "Precisão: Vantagens listadas corretas e relevantes (80%)",
                                "Profundidade: Cada vantagem exemplificada com código ou cenário (15%)",
                                "Clareza: Lista organizada, concisa e acionável (5%)",
                                "Completude: Inclui pelo menos redução bugs, otimização e refatoração (obrigatório)",
                                "Originalidade: Exemplos práticos além de definições básicas",
                                "Aplicação: Relaciona a contextos OO reais"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de tipos como álgebra abstrata (tipos como conjuntos).",
                                "Design de Software: Princípios SOLID beneficiados por types seguros.",
                                "Gestão de Projetos: Redução tempo debug em equipes ágeis.",
                                "Lógica e Raciocínio: Verificação estática como prova formal."
                              ],
                              "realWorldApplication": "Em empresas como Google (usando Java/C++), tipagem estática reduz custos de manutenção em bilhões de linhas de código, permitindo refatorações rápidas em microsserviços OO e otimizações que suportam escala global sem downtimes por bugs de tipo."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.3.2",
                            "name": "Identificar linguagens com tipagem estática",
                            "description": "Reconhecer linguagens OO como C++, Java e C# como exemplos de tipagem estática, contrastando com Python (dinâmica), conforme bibliografia citada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de tipagem estática e dinâmica",
                                  "subSteps": [
                                    "Defina tipagem estática: declaração explícita de tipos de variáveis antes do uso, verificada em tempo de compilação.",
                                    "Defina tipagem dinâmica: tipos inferidos em tempo de execução, sem declaração explícita.",
                                    "Compare vantagens: estática previne erros cedo; dinâmica permite flexibilidade.",
                                    "Leia trechos da bibliografia citada sobre OO e tipagem.",
                                    "Anote diferenças em um quadro comparativo."
                                  ],
                                  "verification": "Criar um quadro comparativo com pelo menos 4 diferenças chave entre estática e dinâmica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Bibliografia do currículo, papel ou editor de texto para quadro.",
                                  "tips": "Use tabelas para visualização clara das diferenças.",
                                  "learningObjective": "Diferenciar conceitualmente tipagem estática de dinâmica.",
                                  "commonMistakes": "Confundir tipagem com paradigmas de programação (ex: achar que OO é sempre estática)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar linguagens com tipagem estática",
                                  "subSteps": [
                                    "Liste linguagens OO com tipagem estática: C++, Java, C#.",
                                    "Pesquise sintaxe básica: em Java, 'int x = 5;' declara tipo explicitamente.",
                                    "Examine código de exemplo em C++ e C# mostrando declaração de tipos.",
                                    "Note características comuns: compilação verifica tipos.",
                                    "Crie flashcards com exemplos de cada linguagem."
                                  ],
                                  "verification": "Produzir 3 exemplos de código simples, um para cada linguagem, destacando declaração de tipos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação oficial de Java/C++/C#, editor de código online como Replit.",
                                  "tips": "Foque em declarações de variáveis para ver o tipo explícito.",
                                  "learningObjective": "Reconhecer e exemplificar linguagens estáticas OO.",
                                  "commonMistakes": "Incluir linguagens não-OO como Pascal, focando apenas em OO."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Contrastar com linguagens de tipagem dinâmica como Python",
                                  "subSteps": [
                                    "Analise sintaxe Python: 'x = 5' sem tipo explícito.",
                                    "Compare erros: em Python, tipo errado só em runtime; em Java, em compile-time.",
                                    "Execute códigos paralelos: um em Java (estático) e Python (dinâmico) com mesmo erro de tipo.",
                                    "Registre diferenças observadas em um log.",
                                    "Discuta trade-offs em um resumo escrito."
                                  ],
                                  "verification": "Executar e documentar 2 pares de códigos (estático vs dinâmico) mostrando detecção de erros.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python online (Replit), Java online, terminal para execução.",
                                  "tips": "Force um erro de tipo int para string em ambos para comparar.",
                                  "learningObjective": "Contrastar comportamentos práticos entre estático e dinâmico.",
                                  "commonMistakes": "Achar Python 'melhor' sem entender contexto; foque em identificação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação em cenários variados",
                                  "subSteps": [
                                    "Receba lista de 10 linguagens mistas e classifique como estática/dinâmica.",
                                    "Crie quiz autoavaliativo com exemplos de código anônimos.",
                                    "Pesquise uma linguagem extra (ex: TypeScript) e classifique.",
                                    "Explique escolhas em parágrafos curtos.",
                                    "Revise com bibliografia para validação."
                                  ],
                                  "verification": "Acertar 90% em quiz de 10 itens e justificar classificações.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Lista de linguagens impressa ou digital, quiz online (Quizlet).",
                                  "tips": "Pergunte: 'Tipo declarado explicitamente antes de usar?'",
                                  "learningObjective": "Aplicar conhecimento para identificar tipagem em novas linguagens.",
                                  "commonMistakes": "Confundir tipagem fraca (JS) com dinâmica pura."
                                }
                              ],
                              "practicalExample": "Dado código: 'String nome = \"João\";' (Java, estática) vs 'nome = \"João\"' (Python, dinâmica). Identifique e explique por que Java é estática: tipo 'String' declarado explicitamente, verificado na compilação.",
                              "finalVerifications": [
                                "Listar corretamente C++, Java, C# como estáticas OO.",
                                "Contrastar com Python como dinâmica.",
                                "Explicar detecção de erros em compile-time vs runtime.",
                                "Classificar 5 linguagens adicionais com 100% acerto.",
                                "Criar quadro comparativo completo.",
                                "Justificar escolhas com exemplos de sintaxe."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de linguagens estáticas (90%+).",
                                "Qualidade do contraste com exemplos dinâmicos.",
                                "Profundidade conceitual nos conceitos (definições claras).",
                                "Uso correto de exemplos de código.",
                                "Capacidade de aplicação em cenários novos.",
                                "Clareza em justificativas e quadros."
                              ],
                              "crossCurricularConnections": [
                                "Lógica e Matemática: Verificação de tipos como prova formal de correção.",
                                "Linguística: Sintaxe de programação similar a gramática declarativa.",
                                "Engenharia de Software: Impacto na depuração e manutenção de código.",
                                "História da Computação: Evolução de linguagens (Fortran estática para Python dinâmica)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software enterprise, escolher Java/C# (estática) previne erros em larga escala; em scripts rápidos, Python (dinâmica) acelera prototipagem, ajudando devs a selecionar ferramentas adequadas por projeto."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.2",
                    "name": "Definição de Tipagem Dinâmica",
                    "description": "Tipagem onde os tipos de variáveis são verificados em tempo de execução, sem declaração explícita prévia.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.2.1",
                        "name": "Definição Fundamental de Tipagem Dinâmica",
                        "description": "Sistema de tipagem em que os tipos das variáveis não precisam ser declarados explicitamente antes da compilação e são determinados e verificados apenas durante a execução do programa, permitindo maior flexibilidade no código.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.1.1",
                            "name": "Definir tipagem dinâmica",
                            "description": "Explicar em palavras próprias que a tipagem dinâmica verifica os tipos de variáveis em tempo de execução, sem declaração prévia, contrastando com a tipagem estática que faz isso em tempo de compilação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito básico de tipagem de variáveis",
                                  "subSteps": [
                                    "Leia a definição de tipagem: o processo pelo qual uma linguagem de programação associa tipos de dados a variáveis.",
                                    "Identifique que tipos comuns incluem inteiros, strings, booleanos e floats.",
                                    "Discuta por que tipagem é importante para alocação de memória e operações seguras.",
                                    "Anote exemplos de variáveis sem tipo explícito em linguagens como Python.",
                                    "Compare brevemente com linguagens que exigem declaração de tipo como C++."
                                  ],
                                  "verification": "Escreva uma definição própria de tipagem em 2-3 frases e liste 4 tipos de dados comuns.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook ou editor de texto",
                                    "Documentação de Python ou JavaScript sobre tipos"
                                  ],
                                  "tips": "Use analogias como 'caixas' para tipos de dados para fixar o conceito.",
                                  "learningObjective": "Compreender o papel fundamental da tipagem nas linguagens de programação.",
                                  "commonMistakes": [
                                    "Confundir tipagem com declaração de variáveis",
                                    "Ignorar que tipagem afeta performance"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Contrastar tipagem estática e dinâmica",
                                  "subSteps": [
                                    "Defina tipagem estática: tipos verificados em tempo de compilação, exigindo declaração prévia.",
                                    "Defina tipagem dinâmica: tipos verificados em tempo de execução, sem declaração obrigatória.",
                                    "Crie uma tabela comparativa com colunas: Verificação, Declaração, Exemplos de linguagens.",
                                    "Explique o trade-off: estática previne erros cedo, dinâmica oferece flexibilidade.",
                                    "Pesquise exemplos: Java (estática) vs Python (dinâmica)."
                                  ],
                                  "verification": "Preencha uma tabela comparativa com pelo menos 5 diferenças chave.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Referências online sobre linguagens (MDN, Python docs)"
                                  ],
                                  "tips": "Lembre-se: compilação é 'antes de rodar', execução é 'durante a rodagem'.",
                                  "learningObjective": "Diferenciar claramente tipagem estática de dinâmica com exemplos.",
                                  "commonMistakes": [
                                    "Achar que dinâmica não tem tipos",
                                    "Confundir com tipagem forte/fraca"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o funcionamento da tipagem dinâmica em runtime",
                                  "subSteps": [
                                    "Entenda 'runtime': momento em que o código é executado pela máquina.",
                                    "Simule verificação: o interpretador infere o tipo baseado no valor atribuído.",
                                    "Discuta reatribuição: variáveis podem mudar de tipo dinamicamente.",
                                    "Analise erros comuns: TypeError em Python quando operações incompatíveis ocorrem.",
                                    "Trace o ciclo: atribuição → inferência → verificação → execução."
                                  ],
                                  "verification": "Descreva o processo de verificação em runtime com um fluxograma simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código online como Replit",
                                    "Vídeo curto sobre interpretadores Python"
                                  ],
                                  "tips": "Execute código passo a passo no debugger para visualizar inferência.",
                                  "learningObjective": "Explicar mecanicamente como a tipagem dinâmica opera durante execução.",
                                  "commonMistakes": [
                                    "Pensar que dinâmica ignora tipos completamente",
                                    "Confundir inferência com ausência de tipos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e sintetizar a definição de tipagem dinâmica",
                                  "subSteps": [
                                    "Escreva sua definição em palavras próprias, incluindo contraste com estática.",
                                    "Crie um exemplo de código dinâmico que reatribui tipos.",
                                    "Identifique vantagens (flexibilidade, rapidez em protótipos) e desvantagens (erros em runtime).",
                                    "Explique em voz alta para um colega ou grave um vídeo de 1 minuto.",
                                    "Revise e refine a definição para clareza e precisão."
                                  ],
                                  "verification": "Produza uma definição escrita de 100-150 palavras com exemplo de código.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código Python/JS",
                                    "Gravador de áudio ou vídeo opcional"
                                  ],
                                  "tips": "Use linguagem simples: 'O Python descobre o tipo quando o código roda, não antes'.",
                                  "learningObjective": "Formular uma definição completa e acionável de tipagem dinâmica.",
                                  "commonMistakes": [
                                    "Omitir o contraste com estática",
                                    "Dar exemplos errados de linguagens"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: x = 5  # x é int; x = 'Olá'  # agora x é str. Nenhum erro em compilação (não há), mas TypeError só se usar x em operação incompatível como x + 10 após virar string.",
                              "finalVerifications": [
                                "Pode explicar tipagem dinâmica sem consultar notas?",
                                "Identifica corretamente linguagens dinâmicas (Python, JS) vs estáticas (Java, C#)?",
                                "Descreve o momento da verificação (runtime vs compile-time)?",
                                "Cita pelo menos uma vantagem e uma desvantagem?",
                                "Executa um exemplo de reatribuição de tipo sem erros?",
                                "Diferencia de tipagem forte/fraca?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (verificação em runtime, sem declaração prévia)",
                                "Clareza no contraste com tipagem estática",
                                "Uso de exemplos concretos e corretos",
                                "Compreensão de implicações (flexibilidade vs erros tardios)",
                                "Capacidade de explicar verbalmente ou por escrito",
                                "Identificação de trade-offs"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Inferência de tipos similar a resolução de equações implícitas",
                                "Lógica: Análise de fluxos condicionais em runtime",
                                "Física/Engenharia: Analogia com medições dinâmicas vs estáticas",
                                "Linguística: Semântica dinâmica em interpretação de linguagem natural"
                              ],
                              "realWorldApplication": "Desenvolvimento rápido de scripts de automação em Python (ex: análise de dados onde colunas variam), protótipos web em JavaScript, ou jogos onde entidades mudam comportamentos dinamicamente, permitindo iterações ágeis sem recompilações."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.2",
                            "name": "Identificar ausência de declaração explícita",
                            "description": "Reconhecer em exemplos de código que variáveis podem ser atribuídas sem especificar o tipo, como em Python onde 'x = 5' ou 'x = \"texto\"' é válido sem declaração de int ou str.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Declaração Explícita de Tipos",
                                  "subSteps": [
                                    "Defina declaração explícita: Especificar o tipo da variável antes ou durante a atribuição, ex: int x; em C++.",
                                    "Defina ausência de declaração explícita: Atribuição direta sem menção ao tipo, ex: x = 5 em Python.",
                                    "Explique inferência de tipo: A linguagem determina o tipo pelo valor atribuído.",
                                    "Diferencie de tipagem dinâmica: O tipo é resolvido em tempo de execução.",
                                    "Registre a definição em suas próprias palavras."
                                  ],
                                  "verification": "Escreva uma definição clara da ausência de declaração explícita e forneça 1 exemplo de cada tipo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Notebook, documentação Python oficial (docs.python.org), editor de texto simples.",
                                  "tips": "Use analogias como 'não precisar rotular uma caixa para saber o que tem dentro pelo conteúdo'.",
                                  "learningObjective": "Diferenciar declaração explícita de ausência dela em contextos de tipagem.",
                                  "commonMistakes": "Confundir com tipagem forte vs fraca; focar apenas em sintaxe sem contexto semântico."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Exemplos de Código Python com Tipagem Dinâmica",
                                  "subSteps": [
                                    "Execute o código: x = 5; print(type(x)) e observe o output <class 'int'>.",
                                    "Teste: x = 'texto'; print(type(x)) e note mudança para <class 'str'> sem redeclaração.",
                                    "Identifique linhas sem 'int', 'str' ou similares antes da atribuição.",
                                    "Marque ausências em 3-5 snippets de código fornecidos.",
                                    "Explique por que isso é válido em Python."
                                  ],
                                  "verification": "Anote 3 exemplos onde identificou ausência e execute-os sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python instalado (versão 3.x), IDLE ou VS Code, snippets de código de exemplo.",
                                  "tips": "Use print(type(var)) após cada atribuição para visualizar inferência.",
                                  "learningObjective": "Reconhecer padrões de atribuição sem declaração em código real.",
                                  "commonMistakes": "Assumir que funções como len() declaram tipos; ignorar atribuições múltiplas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar com Linguagens de Tipagem Estática",
                                  "subSteps": [
                                    "Escreva equivalente em Java: int x = 5; e tente x = 'texto' (erro de compilação).",
                                    "Em C++: int x = 5; x = 'texto'; (erro).",
                                    "Compare sintaxe lado a lado em uma tabela: Python vs Java/C++.",
                                    "Identifique onde Java/C++ exigem 'int x;' explicitamente.",
                                    "Discuta vantagens da ausência em Python (flexibilidade)."
                                  ],
                                  "verification": "Crie uma tabela comparativa com 4 exemplos e explique diferenças.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Compiladores online (repl.it para Java/C++), Python REPL.",
                                  "tips": "Copie-cole código entre linguagens para testes rápidos.",
                                  "learningObjective": "Contrastar ausência de declaração em dinâmica vs obrigatoriedade em estática.",
                                  "commonMistakes": "Confundir erros de runtime com compile-time; ignorar casting implícito."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação em Exercícios Diversos",
                                  "subSteps": [
                                    "Analise 5 trechos de código mistos (Python, JS, Java) e marque ausências.",
                                    "Crie seu próprio código Python com 10 variáveis sem declaração.",
                                    "Debugue código com erros intencionais de suposição de tipo estático.",
                                    "Avalie um código de colega ou online (ex: GitHub snippet).",
                                    "Registre acertos/erros em um log."
                                  ],
                                  "verification": "Complete 80% dos exercícios corretamente e autoavalie.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Exercícios impressos ou Google Docs, repositórios GitHub de iniciantes em Python.",
                                  "tips": "Procure por '=' sem tipo prefixado; ignore type hints opcionais (ex: x: int).",
                                  "learningObjective": "Aplicar identificação de forma independente em cenários variados.",
                                  "commonMistakes": "Marcar type hints como declaração explícita; confundir com imports."
                                }
                              ],
                              "practicalExample": "Em um script de análise de dados: dados = [1, 2, 3]; nome_arquivo = 'vendas.csv'; total = sum(dados). Aqui, 'dados' infere list, 'nome_arquivo' str, 'total' int sem declarações explícitas.",
                              "finalVerifications": [
                                "Identifica corretamente ausência em 10/10 exemplos Python fornecidos.",
                                "Explica inferência de tipo para valores numéricos, strings e listas.",
                                "Distingue de linguagens estáticas em comparação paralela.",
                                "Cria código funcional sem declarações explícitas sem erros.",
                                "Registra log de prática com pelo menos 5 identificações independentes.",
                                "Discute uma vantagem prática da tipagem dinâmica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação: 90%+ acertos em testes.",
                                "Profundidade de explicação: Inclui inferência e runtime resolution.",
                                "Comparação interdisciplinar: Tabela clara com 3+ linguagens.",
                                "Criatividade em exemplos: Fornece 3+ originais práticos.",
                                "Autoavaliação: Log reflete erros comuns evitados.",
                                "Tempo de execução: Completa dentro de 90 minutos totais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Inferência semelhante a resolução de equações sem variáveis declaradas.",
                                "Lógica: Padrões de reconhecimento como em puzzles de programação.",
                                "Linguística: Semântica implícita vs sintaxe explícita em linguagem natural.",
                                "Física/Engenharia: Modelagem dinâmica de sistemas sem rigidez inicial."
                              ],
                              "realWorldApplication": "Em desenvolvimento ágil de scripts de automação (ex: web scraping com Python), data science (pandas sem declarações), prototipagem rápida onde flexibilidade acelera iterações sem overhead de tipagem estática."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.3",
                            "name": "Diferenciar de tipagem estática",
                            "description": "Comparar tipagem dinâmica (ex: Python) com estática (ex: C++), destacando que na dinâmica os erros de tipo só são detectados em runtime, não em compile-time.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Tipagem Estática",
                                  "subSteps": [
                                    "Leia a definição de tipagem estática: tipos de variáveis são declarados explicitamente e verificados durante a compilação.",
                                    "Instale e configure um compilador C++ (ex: g++ via MinGW ou online como Replit).",
                                    "Escreva um código simples em C++ declarando variáveis com tipos (int, string).",
                                    "Tente compilar um código com erro de tipo (ex: somar int e string) e observe o erro de compilação.",
                                    "Analise a mensagem de erro do compilador para entender a detecção em compile-time."
                                  ],
                                  "verification": "Compilação falha com erro de tipo antes da execução, confirmando detecção em compile-time.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou Replit)",
                                    "Compilador C++ (g++)"
                                  ],
                                  "tips": [
                                    "Use flags como -Wall -Wextra para mais avisos.",
                                    "Comece com programas mínimos para isolar erros."
                                  ],
                                  "learningObjective": "Dominar como a tipagem estática previne erros de tipo antes da execução.",
                                  "commonMistakes": [
                                    "Ignorar warnings do compilador.",
                                    "Confundir erros de sintaxe com erros de tipo.",
                                    "Achar que todas as linguagens estática detectam 100% dos erros."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender os Fundamentos da Tipagem Dinâmica",
                                  "subSteps": [
                                    "Leia a definição de tipagem dinâmica: tipos são inferidos em runtime, sem declaração explícita.",
                                    "Instale Python (ou use online como Replit).",
                                    "Escreva um código Python com variáveis sem tipos declarados (ex: x = 5; y = 'texto').",
                                    "Execute um código com erro de tipo (ex: print(x + y)) e observe o erro em runtime.",
                                    "Compare o fluxo: código 'compila' (interpreta) mas falha na execução."
                                  ],
                                  "verification": "Código executa parcialmente até o erro de tipo em runtime ser lançado (TypeError).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3.x instalado",
                                    "Editor de código (IDLE ou VS Code)"
                                  ],
                                  "tips": [
                                    "Use print() para debugar tipos com type() durante execução.",
                                    "Teste incrementalmente para isolar runtime errors."
                                  ],
                                  "learningObjective": "Reconhecer que tipagem dinâmica adia verificações de tipo para runtime.",
                                  "commonMistakes": [
                                    "Achar que Python não tem tipos (são duck-typed).",
                                    "Confundir interpretação com ausência de verificação.",
                                    "Ignorar TypeError como 'bug do Python'."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Tipagem Estática e Dinâmica",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: compile-time vs runtime, declaração explícita vs inferência, exemplos C++ vs Python.",
                                    "Liste vantagens: estática (detecção precoce, performance); dinâmica (flexibilidade, rapidez de codificação).",
                                    "Liste desvantagens: estática (verbosa); dinâmica (erros tardios).",
                                    "Discuta cenários: estática para sistemas críticos, dinâmica para scripts.",
                                    "Resuma em 3 frases chave as diferenças fundamentais."
                                  ],
                                  "verification": "Tabela completa com pelo menos 5 diferenças chave, explicada oralmente ou por escrito.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha (Google Sheets ou papel)",
                                    "Documentação de C++ e Python sobre tipos"
                                  ],
                                  "tips": [
                                    "Use markdown para tabela legível.",
                                    "Pense em trade-offs reais de projetos."
                                  ],
                                  "learningObjective": "Diferenciar precisamente os mecanismos e impactos de cada tipagem.",
                                  "commonMistakes": [
                                    "Generalizar 'estática é sempre melhor'.",
                                    "Omitir performance em estática.",
                                    "Confundir com tipagem forte/fraca."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Diferenciação com Exemplos Híbridos",
                                  "subSteps": [
                                    "Escreva o mesmo programa em C++ e Python: função que processa lista de números e strings.",
                                    "Introduza erro de tipo intencionado em ambos e compare detecção.",
                                    "Refatore o código Python usando type hints (opcional, para modernizar).",
                                    "Registre tempos: compilação C++ vs execução Python até erro.",
                                    "Explique por que um falha cedo e o outro tarde."
                                  ],
                                  "verification": "Dois códigos funcionais + versions com erros, com logs de erros comparados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ambiente dual C++/Python (Replit multi-linguagem)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": [
                                    "Copie estruturas semelhantes para comparação justa.",
                                    "Meça com timer real."
                                  ],
                                  "learningObjective": "Aplicar diferenciação prática para internalizar conceitos.",
                                  "commonMistakes": [
                                    "Usar linguagens erradas (ex: JavaScript como estática).",
                                    "Não isolar o erro de tipo.",
                                    "Esquecer de testar execução completa."
                                  ]
                                }
                              ],
                              "practicalExample": "Em C++ (estática): int main() { int a = 5; string b = 'texto'; cout << a + b; } → Erro de compilação: 'no match for operator+'. Em Python (dinâmica): a = 5; b = 'texto'; print(a + b) → TypeError em runtime: 'unsupported operand type(s)'. Demonstra detecção precoce vs tardia.",
                              "finalVerifications": [
                                "Explicar em 1 minuto a diferença principal sem hesitação.",
                                "Classificar C++, Python, JavaScript corretamente como estática/dinâmica.",
                                "Prever detecção de erro para código híbrido fornecido.",
                                "Listar 2 prós e 2 contras de cada sem consulta.",
                                "Criar exemplo próprio de erro runtime em dinâmica."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (compile-time vs runtime: 30%)",
                                "Uso correto de exemplos linguagens (25%)",
                                "Identificação de trade-offs e cenários (20%)",
                                "Clareza na comparação tabular ou verbal (15%)",
                                "Aplicação prática sem erros lógicos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de tipos como conjuntos e funções tipadas.",
                                "Lógica: Raciocínio dedutivo em verificações formais vs empíricas.",
                                "Engenharia de Software: Análise de riscos e debugging sistemático.",
                                "Filosofia: Paradigma declarativo (estática) vs imperativo (dinâmica)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps bancários (C++ estática previne erros de transação em compile-time, evitando perdas financeiras); em data science (Python dinâmica acelera protótipos, mas exige testes rigorosos para runtime safety)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.2",
                        "name": "Verificação de Tipos em Tempo de Execução",
                        "description": "Processo pelo qual o interpretador ou runtime environment checa a compatibilidade de tipos durante a execução, podendo gerar exceções se houver incompatibilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.2.1",
                            "name": "Explicar verificação em runtime",
                            "description": "Descrever como o runtime verifica tipos dinamicamente, por exemplo, em Python ao tentar somar int e str, gerando TypeError apenas na execução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Básicos de Tipagem Dinâmica e Runtime",
                                  "subSteps": [
                                    "Defina tipagem dinâmica: tipos são associados a valores em tempo de execução, não em compilação.",
                                    "Explique 'runtime': fase de execução do programa após compilação ou interpretação.",
                                    "Diferencie de tipagem estática: verificações em tempo de compilação vs. execução.",
                                    "Discuta vantagens: flexibilidade em linguagens como Python.",
                                    "Identifique linguagens exemplos: Python, JavaScript (dinâmicas) vs. Java, C++ (estáticas)."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos e forneça 2 exemplos de linguagens.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Notebook com Python instalado, documentação oficial do Python (docs.python.org).",
                                  "tips": "Use analogias como 'runtime é como um juiz que decide na hora do jogo'.",
                                  "learningObjective": "Compreender a distinção fundamental entre tipagem dinâmica e runtime verification.",
                                  "commonMistakes": "Confundir runtime com compile-time; achar que Python compila antes de executar."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Demonstrar Verificação de Tipos com Exemplo Prático em Python",
                                  "subSteps": [
                                    "Escreva código: result = 5 + 'abc' e execute.",
                                    "Observe o TypeError: 'unsupported operand type(s) for +: 'int' and 'str''. ",
                                    "Explique: Python verifica tipos durante execução da operação +.",
                                    "Teste variações: int + int (funciona), str + str (funciona), mistos (falha).",
                                    "Use print(type()) antes da operação para visualizar tipos dinâmicos."
                                  ],
                                  "verification": "Execute o código e capture screenshot do erro com explicação escrita.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código (VS Code ou IDLE), terminal Python.",
                                  "tips": "Execute linha por linha com debugger para ver o momento exato do erro.",
                                  "learningObjective": "Visualizar e reproduzir erro de verificação em runtime.",
                                  "commonMistakes": "Esquecer de executar o código; confundir TypeError com NameError."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Mecanismo Interno e Cenários Avançados",
                                  "subSteps": [
                                    "Descreva como Python usa CPython: interpretador verifica operadores em bytecode.",
                                    "Analise função isinstance() e type(): verificações manuais em runtime.",
                                    "Teste com funções: def soma(a, b): return a + b; chame com tipos mistos.",
                                    "Discuta duck typing: 'se parece com um pato, anda como um pato'.",
                                    "Exemplo avançado: listas heterogêneas e erros em iterações."
                                  ],
                                  "verification": "Crie função customizada que falhe em runtime e explique o porquê.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python REPL, debugger pdb.",
                                  "tips": "Use dis.dis() para disassemblar bytecode e ver verificações.",
                                  "learningObjective": "Entender o 'como' técnico da verificação dinâmica.",
                                  "commonMistakes": "Achar que Python não tem tipagem; ignorar exceções capturáveis."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Implicações, Boas Práticas e Comparações",
                                  "subSteps": [
                                    "Compare com tipagem estática: erros precoces vs. flexibilidade.",
                                    "Liste boas práticas: use type hints (Python 3.5+), mypy para verificação estática opcional.",
                                    "Discuta debugging: tracebacks revelam runtime errors.",
                                    "Exemplo real: script de automação que falha com input inesperado.",
                                    "Resuma trade-offs: velocidade vs. segurança de tipos."
                                  ],
                                  "verification": "Escreva parágrafo comparando prós/contras com exemplo de type hint.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação PEP 484 (type hints), mypy instalado.",
                                  "tips": "Instale mypy: pip install mypy e teste código com --strict.",
                                  "learningObjective": "Aplicar conhecimento para práticas profissionais.",
                                  "commonMistakes": "Subestimar riscos de runtime errors em produção."
                                }
                              ],
                              "practicalExample": "Em um script Python para processar dados: preco = 10.5; nome = 'Produto'; total = preco + nome resulta em TypeError durante execução ao tentar concatenar float e str, demonstrando verificação dinâmica apenas no runtime.",
                              "finalVerifications": [
                                "Explicar corretamente por que TypeError ocorre apenas em execução, não antes.",
                                "Reproduzir exemplo com soma de tipos incompatíveis e capturar traceback.",
                                "Diferenciar runtime de compile-time com 2 exemplos de cada.",
                                "Identificar 3 linguagens com tipagem dinâmica.",
                                "Descrever como type hints mitigam problemas sem alterar runtime.",
                                "Explicar duck typing com exemplo funcional."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de runtime e tipagem dinâmica (30%)",
                                "Exemplos práticos: códigos executáveis com erros reproduzíveis (25%)",
                                "Clareza explicativa: uso de analogias e passos lógicos (20%)",
                                "Profundidade técnica: menção a mecanismos como CPython ou isinstance (15%)",
                                "Aplicação prática: discussão de boas práticas e trade-offs (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: conceitos de tipos de dados como conjuntos (int, str).",
                                "Lógica: raciocínio dedutivo em debugging de erros runtime.",
                                "Física/Engenharia: analogia com testes em protótipos (falhas só em uso).",
                                "Linguística: tipagem como gramática dinâmica em linguagens naturais."
                              ],
                              "realWorldApplication": "Em desenvolvimento de scripts de automação (ex: web scraping com inputs variáveis), onde tipos dinâmicos permitem flexibilidade, mas runtime checks evitam crashes silenciosos; essencial para data science em Python, debugging apps web em Django/Flask."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.2.2",
                            "name": "Reconhecer erros de tipo em runtime",
                            "description": "Identificar e prever cenários onde erros de tipo ocorrem em execução, como atribuir função a variável e chamá-la incorretamente sem checagem prévia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Tipagem Dinâmica e Erros em Runtime",
                                  "subSteps": [
                                    "Estude a definição de tipagem dinâmica: tipos são determinados em tempo de execução, não em compilação.",
                                    "Diferencie erros de tipo em runtime de erros de sintaxe ou compile-time.",
                                    "Analise exemplos iniciais em JavaScript: variáveis que mudam de tipo dinamicamente.",
                                    "Identifique quando a verificação de tipo ocorre: apenas durante a execução.",
                                    "Revise documentação oficial do MDN sobre TypeError."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre tipagem estática e dinâmica, com um exemplo de erro em runtime.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação MDN Web Docs (JavaScript Errors), editor de texto simples.",
                                  "tips": "Use o console do navegador para testar snippets rápidos de código.",
                                  "learningObjective": "Diferenciar tipagem dinâmica de estática e reconhecer o momento da verificação de tipos.",
                                  "commonMistakes": "Confundir erros de runtime com erros de compilação; assumir que linguagens como JS verificam tipos antecipadamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Cenários Comuns de Erros de Tipo em Runtime",
                                  "subSteps": [
                                    "Liste cenários comuns: atribuição incorreta de função a variável (ex: string em vez de função).",
                                    "Examine casos como chamar método em objeto undefined ou null.",
                                    "Estude operações aritméticas com tipos incompatíveis (string + number sem coerção esperada).",
                                    "Analise atribuição de função e chamada sem checagem: let fn = getFunction(); fn() onde fn vira string.",
                                    "Registre 5 exemplos pessoais de potenciais erros."
                                  ],
                                  "verification": "Crie uma tabela com 3 cenários comuns e descreva o erro esperado em runtime.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código (VS Code ou Replit), console do navegador.",
                                  "tips": "Sempre pergunte: 'O que acontece se o tipo mudar inesperadamente?'",
                                  "learningObjective": "Listar e descrever pelo menos 4 cenários típicos de erros de tipo em runtime.",
                                  "commonMistakes": "Ignorar coerções implícitas do JavaScript, como '2' + 2 virando string."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar e Simular Execução de Código com Erros Potenciais",
                                  "subSteps": [
                                    "Escreva código simples com erro intencional: let callback = prompt('Digite uma função'); callback();",
                                    "Execute passo a passo no console, observando o TypeError.",
                                    "Preveja o erro antes de rodar: identifique linha e tipo incompatível.",
                                    "Use debugger ou console.log para rastrear mudanças de tipo.",
                                    "Repita com 2 variações: função sobrescrita por array ou número."
                                  ],
                                  "verification": "Execute o código e capture screenshot do erro no console, anotando a previsão vs. realidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Navegador Chrome/Firefox com DevTools, playground online como JSFiddle.",
                                  "tips": "Use typeof() para inspecionar tipos antes da operação crítica.",
                                  "learningObjective": "Simular execução mental e prática para prever erros de tipo.",
                                  "commonMistakes": "Não testar entradas do usuário, assumindo tipos fixos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Prever, Debugar e Verificar Prevenção de Erros",
                                  "subSteps": [
                                    "Adicione checagens: if (typeof callback === 'function') callback();",
                                    "Debugue código alheio com erros escondidos, identificando 3 pontos de falha.",
                                    "Crie teste unitário simples com Jest para validar ausência de erros.",
                                    "Documente padrões de prevenção: type guards em TypeScript como inspiração.",
                                    "Avalie impacto: tempo de debug vs. prevenção."
                                  ],
                                  "verification": "Modifique código com erro para incluir checagem e confirme execução sem crash com input inválido.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Node.js ou browser console, Jest (opcional via CDN).",
                                  "tips": "Adote 'fail-fast': cheque tipos cedo no fluxo.",
                                  "learningObjective": "Implementar verificações básicas para prevenir erros de tipo em runtime.",
                                  "commonMistakes": "Adicionar checagens excessivas, impactando performance desnecessariamente."
                                }
                              ],
                              "practicalExample": "Em JavaScript: let userInput = 'não sou uma função'; userInput(); // TypeError: userInput is not a function. Isso ocorre ao atribuir string de input a variável esperada como callback, sem typeof check.",
                              "finalVerifications": [
                                "Pode prever corretamente o erro em 3 códigos dados sem executá-los.",
                                "Identifica o tipo incompatível e linha exata do erro em stack trace.",
                                "Implementa checagem typeof em código funcional.",
                                "Explica verbalmente um cenário real de erro evitado.",
                                "Cria teste que falha sem checagem e passa com ela.",
                                "Lista 4 cenários comuns sem consultar notas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na previsão de erros (90% acerto em simulações).",
                                "Detalhe na descrição de causas (tipo, linha, contexto).",
                                "Qualidade das checagens preventivas (simples e eficazes).",
                                "Capacidade de debug: tempo para identificar < 2 min por caso.",
                                "Criatividade em exemplos pessoais relevantes.",
                                "Compreensão conceitual: diferencia runtime de outros erros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional para prever condições de falha.",
                                "Física/Engenharia: Modelagem de sistemas com falhas em tempo real (debugging).",
                                "Língua Portuguesa: Análise de textos técnicos (stack traces).",
                                "Estatística: Probabilidade de erros em inputs dinâmicos."
                              ],
                              "realWorldApplication": "Em desenvolvimento web/fullstack (ex: React apps), previne crashes ao lidar com APIs que retornam dados inesperados, como um endpoint que falha e atribui string a handler de evento, evitando downtime em produção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.3",
                        "name": "Características e Exemplos em Linguagens OO",
                        "description": "Linguagens como Python suportam tipagem dinâmica em contextos orientados a objetos, promovendo duck typing onde o tipo é definido pelo comportamento dos métodos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.3.1",
                            "name": "Analisar código Python com tipagem dinâmica",
                            "description": "Ler e interpretar código Python OO onde objetos de classes diferentes são usados polimorficamente sem declaração de tipo, verificando compatibilidade em runtime.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Tipagem Dinâmica e Duck Typing em Python",
                                  "subSteps": [
                                    "Defina tipagem dinâmica: tipos de variáveis são determinados durante a execução, não na compilação.",
                                    "Explique duck typing: 'Se anda como pato e grasna como pato, é um pato' – foco em comportamento, não em tipo declarado.",
                                    "Compare com tipagem estática: em Python, sem 'int x;', tipos inferidos em runtime.",
                                    "Identifique herança e polimorfismo: subclasses compartilham interfaces sem declarações explícitas.",
                                    "Examine exemplo básico: lista com objetos de classes diferentes processados uniformemente."
                                  ],
                                  "verification": "Escreva uma explicação de 100 palavras sobre duck typing e dê um exemplo simples de código.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial Python: https://docs.python.org/3/tutorial/classes.html",
                                    "Artigo 'Duck Typing': https://en.wikipedia.org/wiki/Duck_typing"
                                  ],
                                  "tips": "Sempre pergunte: 'O objeto tem o método esperado?' em vez de checar tipo com isinstance().",
                                  "learningObjective": "Compreender como Python resolve compatibilidade de tipos em runtime via duck typing.",
                                  "commonMistakes": [
                                    "Assumir necessidade de declarações de tipo como em TypeScript ou Java.",
                                    "Ignorar que AttributeError surge em runtime se método ausente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear Estrutura de Classes e Herança no Código",
                                  "subSteps": [
                                    "Identifique todas as definições de class: superclasse e subclasses.",
                                    "Trace herança: use issubclass() mentalmente para entender relações.",
                                    "Liste métodos comuns: métodos que subclasses devem implementar para polimorfismo.",
                                    "Anote atributos dinâmicos: __init__ pode setar diferentes tipos.",
                                    "Desenhe diagrama UML simples: classes, setas de herança e métodos compartilhados."
                                  ],
                                  "verification": "Crie um diagrama de classes resumindo o código analisado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código como VS Code com Python extension",
                                    "Ferramenta UML online: draw.io"
                                  ],
                                  "tips": "Comece pelo topo: encontre a classe base primeiro.",
                                  "learningObjective": "Mapear hierarquia OO para prever comportamentos polimórficos.",
                                  "commonMistakes": [
                                    "Perder herança múltipla em Python.",
                                    "Confundir atributos de instância com de classe."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Pontos de Uso Polimórfico e Verificações Runtime",
                                  "subSteps": [
                                    "Localize chamadas de métodos em funções genéricas: ex. func(obj) onde obj é polimórfico.",
                                    "Marque linhas sem type hints: foco em código puro Python 3 sem typing module.",
                                    "Simule dispatch dinâmico: trace qual método é chamado baseado no objeto real.",
                                    "Identifique potenciais AttributeError ou TypeError: se método/operador ausente.",
                                    "Verifique loops/list comprehensions: objetos mistos em coleções."
                                  ],
                                  "verification": "Anote 3-5 pontos polimórficos no código com explicação de runtime check.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código Python fornecido",
                                    "Python REPL ou Jupyter Notebook para testes isolados"
                                  ],
                                  "tips": "Use print(type(obj)) mentalmente para rastrear tipos em runtime.",
                                  "learningObjective": "Detectar onde tipagem dinâmica permite flexibilidade mas introduz riscos runtime.",
                                  "commonMistakes": [
                                    "Assumir TypeError só em operações aritméticas, não em métodos.",
                                    "Ignorar que None pode ser passado, causando AttributeError."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular Execução e Validar Compatibilidade",
                                  "subSteps": [
                                    "Execute código mentalmente passo a passo: trace fluxo com objetos específicos.",
                                    "Teste com inputs variados: instâncias de diferentes subclasses.",
                                    "Registre exceções potenciais: colete cenários de falha runtime.",
                                    "Confirme polimorfismo: verifique se comportamento varia corretamente por classe.",
                                    "Sugira melhorias: adicione type hints opcionais para análise estática."
                                  ],
                                  "verification": "Execute o código com 2 cenários diferentes e documente saídas/erros.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python interpreter",
                                    "Código anotado do passo anterior"
                                  ],
                                  "tips": "Use debugger como pdb para pausar em pontos polimórficos.",
                                  "learningObjective": "Validar código dinâmico simulando runtime sem execução completa.",
                                  "commonMistakes": [
                                    "Não considerar ordem de inicialização afetando atributos.",
                                    "Subestimar sobrescrita de métodos em subclasses."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere este código:\n\nclass Animal:\n    def sound(self):\n        pass\n\nclass Dog(Animal):\n    def sound(self):\n        return 'Woof!'\n\nclass Cat(Animal):\n    def sound(self):\n        return 'Meow!'\n\ndef make_noise(animal):  # Polimórfico, sem type hint\n    return animal.sound()  # Runtime check\n\npets = [Dog(), Cat(), Animal()]  # Mistos\nfor pet in pets:\n    print(make_noise(pet))  # Funciona para Dog/Cat, AttributeError para Animal puro se não implementado.",
                              "finalVerifications": [
                                "Explicar duck typing aplicado ao código exemplo.",
                                "Identificar todos os pontos polimórficos sem type hints.",
                                "Prever exceções runtime para objetos incompatíveis.",
                                "Mapear hierarquia de classes corretamente.",
                                "Simular execução com 3 inputs diferentes.",
                                "Sugerir 2 melhorias para robustez."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de verificações runtime (90%+).",
                                "Profundidade na análise de polimorfismo (cobre herança e métodos).",
                                "Correção na previsão de erros (todos AttributeError/TypeError capturados).",
                                "Clareza no mapeamento de estrutura OO.",
                                "Criatividade em simulações e sugestões práticas.",
                                "Completude dos substeps em cada análise."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstração de conjuntos e funções polimórficas como morfismos.",
                                "Lógica: Raciocínio dedutivo para prever runtime behaviors.",
                                "Design de Software: Princípios SOLID (Liskov Substitution).",
                                "Ciência da Computação: Teoria de Tipos e Lambda Calculus.",
                                "Inglês Técnico: Leitura de documentação Python."
                              ],
                              "realWorldApplication": "Em frameworks como Django ou Flask, views processam requests de diferentes middlewares polimorficamente sem type checks explícitos; bibliotecas como Pandas lidam com DataFrames de dtypes mistos resolvidos em runtime, essencial para data science ágil."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.2",
                            "name": "Entender duck typing",
                            "description": "Explicar o conceito de 'duck typing' em tipagem dinâmica: 'se parece um pato e grasna como um pato, é um pato', focando em métodos disponíveis em runtime.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e analogia do Duck Typing",
                                  "subSteps": [
                                    "Leia a definição: Duck typing é um estilo de tipagem dinâmica onde a adequação de um objeto a um interface é determinada pela presença de métodos e propriedades em tempo de execução, não por herança ou declaração explícita.",
                                    "Estude a analogia clássica: 'Se anda como pato, grasna como pato, então é um pato' – aplicada a objetos que se comportam como esperados.",
                                    "Compare brevemente com tipagem estática: Em tipagem estática (ex: Java), tipos são verificados em compile-time; em dinâmica (ex: Python), em runtime.",
                                    "Anote em suas palavras: O que significa 'tipagem baseada em comportamento' vs 'tipagem baseada em declaração'.",
                                    "Pesquise origens: Conceito popularizado por Python, mas usado em Ruby, JavaScript."
                                  ],
                                  "verification": "Escreva um parágrafo explicando duck typing com a analogia do pato e dê um exemplo simples sem código.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Python sobre tipagem dinâmica",
                                    "Artigo 'Duck Typing' na Wikipedia"
                                  ],
                                  "tips": "Use analogias cotidianas para fixar: pense em plugues USB que funcionam se encaixam, independentemente da marca.",
                                  "learningObjective": "Definir duck typing e sua analogia fundamental.",
                                  "commonMistakes": [
                                    "Confundir com herança (duck typing não requer superclasse)",
                                    "Achar que é só para Python (é conceito geral)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o mecanismo em runtime",
                                  "subSteps": [
                                    "Entenda o papel do runtime: Verificações ocorrem quando métodos são chamados; AttributeError surge se método ausente.",
                                    "Analise pseudocódigo: função faz(obj): obj.quack() – aceita qualquer obj com quack().",
                                    "Diferencie de interfaces explícitas: Sem necessidade de 'implements Duck'.",
                                    "Discuta vantagens: Flexibilidade, código mais conciso; desvantagens: Erros em runtime.",
                                    "Visualize fluxograma: Chamada método → Verifica existência → Executa ou erro."
                                  ],
                                  "verification": "Desenhe um fluxograma simples mostrando como duck typing verifica um método em runtime.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto para diagramas (Draw.io ou papel)",
                                    "Vídeo curto sobre tipagem dinâmica no YouTube"
                                  ],
                                  "tips": "Pense em 'não pergunte, apenas tente': código assume que o objeto tem o método.",
                                  "learningObjective": "Explicar como duck typing opera em tempo de execução.",
                                  "commonMistakes": [
                                    "Acreditar que tipos são checados em compile-time",
                                    "Ignorar exceções runtime como AttributeError"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar exemplos em linguagens com tipagem dinâmica",
                                  "subSteps": [
                                    "Exemplo Python: def make_it_quack(thing): thing.quack(); class Duck: def quack(self): print('Quack!'); class Person: def quack(self): print('Quack imitation!'); make_it_quack(Duck()); make_it_quack(Person()).",
                                    "Teste no interpretador Python: Crie classes não relacionadas e passe para função comum.",
                                    "Exemplo JavaScript: function quack(thing) { thing.quack(); } – objetos literais com método quack funcionam.",
                                    "Compare falha: Objeto sem quack() gera erro em runtime.",
                                    "Liste linguagens: Python, Ruby, JavaScript, Go (parcialmente)."
                                  ],
                                  "verification": "Execute o exemplo Python e capture screenshot de saída com Duck e Person quackando.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python instalado ou Replit/Online IDE",
                                    "Documentação oficial Python 'Dynamic Typing'"
                                  ],
                                  "tips": "Use print(type(obj)) para ver que tipos diferentes passam.",
                                  "learningObjective": "Identificar e codificar exemplos funcionais de duck typing.",
                                  "commonMistakes": [
                                    "Usar isinstance() (isso quebra duck typing)",
                                    "Esquecer def quack(self) em classes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e refletir sobre duck typing",
                                  "subSteps": [
                                    "Crie seu exemplo: Função que 'voa' objetos com fly() – teste com Bird, Airplane, Superhero.",
                                    "Adicione erro intencional: Classe sem fly() e observe AttributeError.",
                                    "Reflita: Quando usar? Em APIs flexíveis, protocolos informais.",
                                    "Compare com tipagem estática: Reescreva exemplo em pseudocódigo Java com interface.",
                                    "Documente aprendizados: Vantagens/desvantagens em tabela."
                                  ],
                                  "verification": "Compartilhe código funcional com 3 classes diferentes usando sua função duck-typed.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "IDE Python (VS Code, PyCharm)",
                                    "Notebook para reflexões"
                                  ],
                                  "tips": "Comece simples; expanda para métodos com args (ex: fly(distance)).",
                                  "learningObjective": "Aplicar duck typing em código original e analisar trade-offs.",
                                  "commonMistakes": [
                                    "Forçar herança desnecessária",
                                    "Não tratar exceções em produção"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python, uma função de auditoria de notas: def print_grades(student): for grade in student.grades: print(grade). Aceita qualquer objeto com atributo 'grades' (lista), seja Student, Employee ou dict customizado – sem checar tipo.",
                              "finalVerifications": [
                                "Explicar analogia do pato sem hesitação.",
                                "Executar código Python com duck typing sem erros.",
                                "Identificar AttributeError como sinal de falha duck typing.",
                                "Diferenciar duck typing de herança ou interfaces explícitas.",
                                "Listar 2 linguagens que usam duck typing.",
                                "Criar exemplo original com 3 objetos heterogêneos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e analogia (80%+ correto).",
                                "Código funcional demonstrando duck typing (sem isinstance).",
                                "Análise correta de erros runtime vs compile-time.",
                                "Reflexão sobre prós/contras com exemplos.",
                                "Exemplo prático criativo e testado.",
                                "Conexões com linguagens reais."
                              ],
                              "crossCurricularConnections": [
                                "Lógica e Filosofia: Conceito de identidade baseado em comportamento observável (Aristóteles).",
                                "Matemática: Abstração de interfaces funcionais (funções como objetos first-class).",
                                "Design de Software: Princípios SOLID (Interface Segregation via comportamento).",
                                "Psicologia: Analogias para aprendizado cognitivo."
                              ],
                              "realWorldApplication": "Frameworks como Django (Python) usam duck typing para views e models flexíveis; JavaScript no frontend aceita qualquer objeto com métodos render() em bibliotecas como React; economiza boilerplate em APIs dinâmicas."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.3",
                            "name": "Relacionar com POO",
                            "description": "Associar tipagem dinâmica a pilares da POO como polimorfismo em Python, onde métodos são resolvidos dinamicamente sem tipos fixos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os pilares fundamentais da Programação Orientada a Objetos (POO)",
                                  "subSteps": [
                                    "Estude os quatro pilares principais: encapsulamento, herança, polimorfismo e abstração.",
                                    "Leia definições oficiais e exemplos genéricos em linguagens OO.",
                                    "Anote como cada pilar contribui para o design de software modular.",
                                    "Compare brevemente com programação procedural.",
                                    "Identifique onde a resolução de tipos pode influenciar esses pilares."
                                  ],
                                  "verification": "Criar um mapa mental ou tabela resumindo os pilares com uma frase chave para cada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de POO (ex: livros como 'Head First Design Patterns' ou sites como GeeksforGeeks), papel/caneta ou ferramenta como Draw.io.",
                                  "tips": "Use analogias do mundo real, como carros para herança, para fixar conceitos.",
                                  "learningObjective": "Compreender os pilares da POO como base para relacionar com tipagem dinâmica.",
                                  "commonMistakes": "Confundir polimorfismo com sobrecarga de métodos (mais comum em tipagem estática)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender tipagem dinâmica em Python",
                                  "subSteps": [
                                    "Execute exemplos simples de variáveis sem declaração de tipo em Python.",
                                    "Observe como o interpretador resolve tipos em tempo de execução.",
                                    "Teste reatribuição de tipos a uma mesma variável (ex: x = 5; x = 'texto').",
                                    "Compare com linguagens de tipagem estática como Java usando snippets de código.",
                                    "Analise o conceito de 'duck typing': se quack como pato, é pato."
                                  ],
                                  "verification": "Rodar um script Python que demonstre mudança de tipos e imprimir confirmações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python 3 instalado, IDLE ou VS Code, console interativo (REPL).",
                                  "tips": "Use print(type(obj)) após cada operação para visualizar a tipagem dinâmica.",
                                  "learningObjective": "Dominar como Python resolve tipos dinamicamente durante a execução.",
                                  "commonMistakes": "Achar que tipagem dinâmica significa 'sem tipos', ignorando type hints opcionais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar polimorfismo em Python e sua relação com tipagem dinâmica",
                                  "subSteps": [
                                    "Crie classes com métodos de mesmo nome (ex: Animal com speak()).",
                                    "Implemente herança e chame métodos polimórficos em uma lista de objetos.",
                                    "Demonstre duck typing com classes não relacionadas que compartilham interface.",
                                    "Analise o bytecode ou use dis.dis() para ver resolução dinâmica de métodos.",
                                    "Teste falhas em runtime devido a métodos ausentes para entender limites."
                                  ],
                                  "verification": "Executar um programa com polimorfismo dinâmico e verificar saída correta sem erros de tipo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de código (PyCharm ou VS Code), Python REPL, documentação oficial de classes.",
                                  "tips": "Comece com exemplos simples como Cão e Gato para ilustrar polimorfismo.",
                                  "learningObjective": "Associar polimorfismo à resolução dinâmica de métodos via tipagem dinâmica.",
                                  "commonMistakes": "Confundir polimorfismo de subtipo (herança) com ad-hoc (duck typing)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar relações entre tipagem dinâmica e outros pilares da POO",
                                  "subSteps": [
                                    "Discuta como tipagem dinâmica facilita encapsulamento (sem getters/setters rígidos).",
                                    "Explore herança múltipla e resolução dinâmica em Python.",
                                    "Crie um exemplo integrando todos os pilares com tipagem dinâmica.",
                                    "Compare vantagens/desvantagens com tipagem estática em cenários POO.",
                                    "Documente conclusões em um relatório curto."
                                  ],
                                  "verification": "Produzir um código exemplo completo e um parágrafo explicando as relações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notebook para anotações, GitHub para versionar código, referências comparativas (Java vs Python).",
                                  "tips": "Use diagramas UML simples para visualizar relações entre pilares e tipagem.",
                                  "learningObjective": "Relacionar tipagem dinâmica integralmente aos pilares da POO, com foco em Python.",
                                  "commonMistakes": "Ignorar que abstração beneficia de duck typing para flexibilidade."
                                }
                              ],
                              "practicalExample": "Crie classes Forma com método area(): class Circulo: def area(self): return 3.14 * self.r ** 2; class Quadrado: def area(self): return self.lado ** 2. Em uma lista [Circulo(5), Quadrado(4)], use for forma in formas: print(forma.area()) – Python resolve dinamicamente sem declarar tipos comuns.",
                              "finalVerifications": [
                                "Explicar verbalmente como tipagem dinâmica habilita polimorfismo em Python.",
                                "Implementar e executar código polimórfico com duck typing sem erros.",
                                "Identificar 3 vantagens da tipagem dinâmica nos pilares POO.",
                                "Comparar com exemplo em linguagem estática (ex: Java).",
                                "Criar um diagrama ligando tipagem dinâmica aos 4 pilares.",
                                "Responder quiz com 5 perguntas sobre conceitos chave."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Correta associação de tipagem dinâmica ao polimorfismo (30%).",
                                "Profundidade de exemplos: Código prático e funcional demonstrando conceitos (25%).",
                                "Clareza na explicação: Linguagem acessível e sem jargões desnecessários (20%).",
                                "Completude: Cobertura de todos os pilares da POO (15%).",
                                "Criatividade: Exemplos originais ou extensões além do básico (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstração e modelagem de funções polimórficas como em geometria.",
                                "Lógica e Filosofia: Conceitos de identidade e 'duck typing' como essência sobre forma.",
                                "Design e Artes: Encapsulamento como modularidade em projetos gráficos.",
                                "Ciências da Computação: Evolução de linguagens e trade-offs de performance."
                              ],
                              "realWorldApplication": "Em frameworks como Django ou Flask, tipagem dinâmica permite polimorfismo em views e models, facilitando desenvolvimento rápido de APIs flexíveis que lidam com dados heterogêneos sem boilerplate de tipos, comum em apps web escaláveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.3",
                    "name": "Características da Tipagem Estática",
                    "description": "Detecção precoce de erros, melhor performance em execução e suporte a otimizações do compilador.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.3.1",
                        "name": "Detecção Precoce de Erros",
                        "description": "A tipagem estática verifica a compatibilidade de tipos durante a fase de compilação, permitindo identificar erros de tipo antes da execução do programa, o que reduz falhas em runtime e facilita a depuração.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.1.1",
                            "name": "Identificar erros de tipo em código estático",
                            "description": "Analisar código-fonte em linguagens como Java ou C++ para detectar incompatibilidades de tipos, como atribuição de string a variável inteira, e entender mensagens de erro do compilador.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Tipos de Dados Primitivos e Referência em Linguagens Estáticas",
                                  "subSteps": [
                                    "Estude os tipos primitivos em Java (int, double, boolean, char, String como referência).",
                                    "Liste exemplos de declaração: int x = 5; String s = \"hello\";.",
                                    "Compare tipos compatíveis (int para double) e incompatíveis (String para int).",
                                    "Revise hierarquia de tipos e promoção implícita.",
                                    "Anote incompatibilidades comuns, como atribuir float a boolean."
                                  ],
                                  "verification": "Crie uma tabela com 5 tipos primitivos, exemplos válidos e inválidos de atribuição.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial do Java (Oracle Docs)",
                                    "Editor de texto como VS Code",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use diagramas visuais para mapear hierarquias de tipos; memorize primitivos vs. wrappers.",
                                  "learningObjective": "Dominar os tipos básicos e regras de compatibilidade em tipagem estática.",
                                  "commonMistakes": [
                                    "Confundir String (referência) com char (primitivo)",
                                    "Ignorar promoção automática de int para double",
                                    "Esquecer que boolean não é numérico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Padrões de Erros de Tipo em Código Estático",
                                  "subSteps": [
                                    "Examine declarações de variáveis e atribuições em snippets de código.",
                                    "Marque erros como: int num = \"123\"; ou double d = true;.",
                                    "Classifique erros: atribuição direta, passagem de parâmetros, retorno de funções.",
                                    "Pratique com 3 códigos curtos, destacando linhas problemáticas.",
                                    "Explique por que o compilador rejeita: mismatch de tipos esperados vs. fornecidos."
                                  ],
                                  "verification": "Analise um código de 10 linhas e liste todos os erros de tipo sem compilar.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Snippets de código Java com erros (prepare 5 exemplos)",
                                    "Marcador digital ou papel para destacar"
                                  ],
                                  "tips": "Leia o código de cima para baixo, focando em =, parâmetros e retornos; ignore lógica por enquanto.",
                                  "learningObjective": "Reconhecer visualmente incompatibilidades de tipos sem compilação.",
                                  "commonMistakes": [
                                    "Confundir casting explícito com atribuição inválida",
                                    "Ignorar erros em inicializações de arrays",
                                    "Não notar sobrecarga de métodos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compilar Código e Interpretar Mensagens de Erro do Compilador",
                                  "subSteps": [
                                    "Instale e configure JDK e um editor/IDE simples.",
                                    "Escreva um código com 2-3 erros de tipo e compile com javac.",
                                    "Leia mensagens: identifique 'incompatible types: String cannot be converted to int'.",
                                    "Mapeie o erro à linha exata e tipo mismatch.",
                                    "Corrija um erro por vez e recompile para validar."
                                  ],
                                  "verification": "Compile 3 códigos com erros, interprete corretamente 100% das mensagens e corrija.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "JDK 17+ instalado",
                                    "Terminal/Command Prompt",
                                    "Arquivos .java de teste"
                                  ],
                                  "tips": "Copie a mensagem de erro exata e busque no Google para padrões comuns; use -Xlint para mais detalhes.",
                                  "learningObjective": "Decodificar mensagens de erro do compilador para localizar erros de tipo precisamente.",
                                  "commonMistakes": [
                                    "Ignorar o número da linha na mensagem",
                                    "Confundir warnings com erros fatais",
                                    "Não diferenciar tipo vs. null pointer"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Análise e Correção de Erros em Códigos Complexos",
                                  "subSteps": [
                                    "Pegue um código de 20-30 linhas com múltiplos erros de tipo misturados.",
                                    "Identifique todos os erros sem compilar primeiro.",
                                    "Compile, compare sua análise com mensagens reais.",
                                    "Corrija sequencialmente e teste compilação final.",
                                    "Registre lições aprendidas em um log pessoal."
                                  ],
                                  "verification": "Resolva um exercício completo: zero erros na compilação final em <10 minutos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Códigos de prática complexos (GitHub ou crie próprios)",
                                    "IDE como IntelliJ Community (opcional)"
                                  ],
                                  "tips": "Priorize erros em ordem de compilação; use refatoração para tipos consistentes.",
                                  "learningObjective": "Aplicar detecção de erros de tipo em cenários realistas e iterativos.",
                                  "commonMistakes": [
                                    "Corrigir sintaxe em vez de tipo",
                                    "Introduzir novos erros ao corrigir",
                                    "Pular verificação pós-correção"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Java: public class TipoErro { public static void main(String[] args) { int numero = \"cem\"; // Erro: incompatible types: String cannot be converted to int double pi = 3.14; boolean ehValido = pi; // Erro: incompatible types: double cannot be converted to boolean } } Compilador diz: TipoErro.java:3: error: incompatible types: String cannot be converted to int. Ao compilar com javac, identifique linha 3 (String para int) e linha 5 (double para boolean), corrigindo para int numero = 100; e boolean ehValido = true;.",
                              "finalVerifications": [
                                "Identificar 95% dos erros de tipo em um código de 50 linhas sem dicas.",
                                "Interpretar corretamente mensagens de erro do compilador em 5 exemplos variados.",
                                "Corrigir um código com 10 erros de tipo em menos de 15 minutos.",
                                "Explicar a diferença entre erro de tipo estático e runtime.",
                                "Criar um snippet próprio com 3 erros de tipo e resolvê-lo.",
                                "Listar 8 tipos primitivos Java e suas incompatibilidades comuns."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de mismatches de tipos (90%+).",
                                "Velocidade de interpretação de mensagens de compilador (<2 min por erro).",
                                "Correções sem introduzir novos erros.",
                                "Explicação clara do porquê do erro (tipo esperado vs. fornecido).",
                                "Uso correto de casting quando aplicável.",
                                "Aplicação em múltiplas funções/classes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Analogia com conjuntos e funções de tipo (domínio vs. imagem).",
                                "Lógica: Verificação de premissas em silogismos formais.",
                                "Física/Engenharia: Detecção precoce de falhas em modelos (tipos como unidades de medida).",
                                "Linguística: Análise sintática e semântica em frases/código.",
                                "Design de Sistemas: Validação de interfaces e contratos."
                              ],
                              "realWorldApplication": "Desenvolvedores usam detecção de erros de tipo estático para evitar bugs caros em produção, como crashes em apps bancários (ex: app tentando somar strings como valores monetários), economizando tempo em debugging e garantindo robustez em software crítico como sistemas de saúde ou autônomos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.2",
                            "name": "Explicar o processo de verificação em compile-time",
                            "description": "Descrever como o compilador realiza type checking estático, incluindo inferência de tipos e resolução de sobrecarga de métodos, com exemplos de código corrigido.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de verificação em compile-time",
                                  "subSteps": [
                                    "Defina o que é compile-time e contrastar com runtime.",
                                    "Explique o papel do compilador na análise estática do código.",
                                    "Identifique fases principais da compilação: lexical, sintática e semântica.",
                                    "Descreva como erros são detectados antes da execução.",
                                    "Liste vantagens da detecção precoce de erros."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo o processo e identifique pelo menos 3 vantagens.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação oficial de compiladores (ex: Java Compiler API), editor de texto.",
                                  "tips": "Use analogias como 'revisão ortográfica antes de imprimir um livro'.",
                                  "learningObjective": "Entender o timing e propósito da verificação estática.",
                                  "commonMistakes": "Confundir compile-time com runtime ou ignorar fases semânticas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o type checking estático",
                                  "subSteps": [
                                    "Defina type checking e sua execução durante a análise semântica.",
                                    "Analise como o compilador verifica compatibilidade de tipos em declarações e atribuições.",
                                    "Examine exemplos de erros de tipo: incompatibilidade entre int e String.",
                                    "Descreva o fluxo: declaração → uso → verificação cruzada.",
                                    "Pratique corrigindo um código com erro de type mismatch."
                                  ],
                                  "verification": "Corrija um snippet de código com erro de tipo e compile sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "IDE como IntelliJ ou VS Code com Java, exemplos de código simples.",
                                  "tips": "Sempre declare tipos explicitamente primeiro para visualizar mismatches.",
                                  "learningObjective": "Dominar como o compilador valida tipos estaticamente.",
                                  "commonMistakes": "Assumir que casting resolve todos os erros sem verificação prévia."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar inferência de tipos",
                                  "subSteps": [
                                    "Explique inferência de tipos: como o compilador deduz tipos de contexto.",
                                    "Compare inferência implícita (var em Java 10+) vs explícita.",
                                    "Analise exemplos: inferência em lambdas ou generics.",
                                    "Teste limites: casos onde inferência falha e requer anotação.",
                                    "Discuta impacto na legibilidade e segurança de tipos."
                                  ],
                                  "verification": "Escreva 3 exemplos onde inferência ocorre e comprove com depuração.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código-fonte Java 10+, ferramenta de decompilação ou debugger.",
                                  "tips": "Use 'javap -c' para inspecionar bytecode e ver tipos inferidos.",
                                  "learningObjective": "Compreender mecanismos automáticos de dedução de tipos.",
                                  "commonMistakes": "Confundir inferência com tipagem dinâmica ou polimorfismo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar resolução de sobrecarga de métodos",
                                  "subSteps": [
                                    "Defina sobrecarga: múltiplas assinaturas com mesmos nomes mas parâmetros diferentes.",
                                    "Descreva o algoritmo: matching exato → promoção → varargs.",
                                    "Examine exemplos: chamada ambígua e como o compilador resolve ou falha.",
                                    "Corrija códigos com erros de resolução de sobrecarga.",
                                    "Compare com linguagens sem sobrecarga como Python."
                                  ],
                                  "verification": "Compile 2 exemplos de sobrecarga, um com sucesso e um corrigido de ambiguidade.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Compilador Java (javac), snippets de código com overloads.",
                                  "tips": "Priorize parâmetros mais específicos no design para evitar ambiguidades.",
                                  "learningObjective": "Explicar como o compilador seleciona o método correto.",
                                  "commonMistakes": "Ignorar ordem de resolução ou confundir com overriding."
                                }
                              ],
                              "practicalExample": "Em Java: classe com métodos sobrecarregados print(int i) e print(double d). Código errado: print('a'); // Erro compile-time. Correção: print((int)'a'); ou use String overload. Demonstra type checking, inferência falhando e resolução escolhendo baseado em promoção de char para int.",
                              "finalVerifications": [
                                "Explicar verbalmente o fluxo completo de verificação em compile-time.",
                                "Identificar e corrigir 3 erros de type checking em código fornecido.",
                                "Descrever inferência em um lambda expression.",
                                "Resolver ambiguidade em sobrecarga com parâmetros mistos.",
                                "Comparar compile-time vs runtime em um diagrama.",
                                "Listar 4 vantagens da tipagem estática."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do processo semântico (type checking).",
                                "Correção de exemplos de código com inferência e sobrecarga.",
                                "Uso de terminologia técnica adequada (ex: promoção de tipos).",
                                "Profundidade nos sub-passos e verificações práticas.",
                                "Clareza em analogias e aplicações reais.",
                                "Completude: todos os componentes da expansão cobertos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica formal e dedução de tipos como teoremas.",
                                "Design de Sistemas: Modelagem de fluxos de compilação em diagramas UML.",
                                "Lógica Computacional: Provas de tipos como verificação formal.",
                                "Engenharia de Software: Boas práticas em testes unitários preventivos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software enterprise (ex: bancos), detecta erros de tipo cedo, reduzindo custos de debug em runtime em até 90%, acelerando deploy em CI/CD pipelines como Jenkins."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.3",
                            "name": "Comparar detecção estática vs. dinâmica",
                            "description": "Contrastar a detecção de erros em tipagem estática (pré-execução) com tipagem dinâmica (runtime), destacando cenários onde a estática previne crashes inesperados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Detecção Estática de Erros",
                                  "subSteps": [
                                    "Estude o conceito de análise estática: verificação de código sem execução.",
                                    "Identifique o momento de detecção: durante a compilação ou linting (pré-execução).",
                                    "Liste erros comuns detectados: incompatibilidade de tipos, variáveis não declaradas, violações de sintaxe.",
                                    "Analise vantagens: prevenção de erros antes do runtime, feedback imediato.",
                                    "Explore ferramentas: TypeScript checker, Java compiler."
                                  ],
                                  "verification": "Liste pelo menos 3 erros detectados estaticamente e explique por que são pegos pré-execução.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor com suporte a TypeScript (VS Code)",
                                    "Documentação TypeScript Handbook",
                                    "Exemplos de código Java"
                                  ],
                                  "tips": [
                                    "Comece com exemplos simples de type mismatch para fixar o conceito.",
                                    "Use o compilador para testar em tempo real."
                                  ],
                                  "learningObjective": "Dominar os fundamentos da detecção estática e seu timing no ciclo de desenvolvimento.",
                                  "commonMistakes": [
                                    "Confundir análise estática com testes unitários (que são dinâmicos).",
                                    "Ignorar que nem todos os erros são detectáveis estaticamente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a Detecção Dinâmica de Erros",
                                  "subSteps": [
                                    "Defina detecção dinâmica: verificação durante a execução do programa (runtime).",
                                    "Descreva o momento: só ocorre quando o código problemático é executado.",
                                    "Exemplos de erros: TypeError em JavaScript ao atribuir número a string, AttributeError em Python.",
                                    "Discuta desvantagens: crashes inesperados em produção, dependência de caminhos de execução.",
                                    "Ferramentas: console.log, try-catch blocks."
                                  ],
                                  "verification": "Escreva um snippet de código JavaScript que cause erro dinâmico e execute para observar o crash.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Node.js ou browser console",
                                    "Documentação MDN JavaScript Errors",
                                    "Editor como CodePen"
                                  ],
                                  "tips": [
                                    "Execute códigos variados para ver quando erros surgem.",
                                    "Compare com linguagens como Python para padrões comuns."
                                  ],
                                  "learningObjective": "Entender o comportamento e limitações da detecção em runtime.",
                                  "commonMistakes": [
                                    "Achar que detecção dinâmica é sempre mais lenta; ela é 'invisível' até o erro.",
                                    "Subestimar impactos em apps de larga escala."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diretamente Detecção Estática vs. Dinâmica",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: timing (pré vs. runtime), tipos de erros, performance de desenvolvimento.",
                                    "Analise precisão: estática pega erros garantidos em todos os fluxos; dinâmica depende de testes.",
                                    "Discuta trade-offs: estática mais rígida (boilerplate), dinâmica mais flexível.",
                                    "Compare linguagens: TypeScript (estática) vs. vanilla JS (dinâmica).",
                                    "Sintetize: estática previne crashes previsíveis."
                                  ],
                                  "verification": "Preencha uma tabela com 5 diferenças chave e 2 vantagens de cada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou papel para tabela",
                                    "Exemplos paralelos TS/JS",
                                    "Artigo 'Static vs Dynamic Typing'"
                                  ],
                                  "tips": [
                                    "Use exemplos idênticos em linguagens diferentes para comparação justa.",
                                    "Foque em métricas como 'tempo até detecção'."
                                  ],
                                  "learningObjective": "Capacitar a contrastar as abordagens de forma estruturada.",
                                  "commonMistakes": [
                                    "Generalizar que estática é 'sempre melhor'; depende do contexto.",
                                    "Omitir flexibilidade da dinâmica em protótipos rápidos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Cenários Onde Estática Prevê Crashes Inesperados",
                                  "subSteps": [
                                    "Identifique cenários: APIs com dados variáveis, funções com parâmetros opcionais.",
                                    "Simule erro: código que funciona em testes mas crasha em produção (dados reais).",
                                    "Demonstre prevenção: refatorar para estática e verificar ausência de warnings.",
                                    "Quantifique benefícios: redução de bugs em 40-70% em equipes grandes.",
                                    "Debata exceções: quando dinâmica é preferível (scripts rápidos)."
                                  ],
                                  "verification": "Crie e corrija um exemplo onde estática evita crash dinâmico.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Repositório GitHub com exemplos TS/JS",
                                    "Ferramenta de linting como ESLint"
                                  ],
                                  "tips": [
                                    "Teste com dados mock variados para simular produção.",
                                    "Meça tempo de debug antes/depois."
                                  ],
                                  "learningObjective": "Aplicar comparação em contextos reais para valorizar estática.",
                                  "commonMistakes": [
                                    "Ignorar overhead de setup na estática.",
                                    "Não considerar cobertura de testes na dinâmica."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma função soma(a: number, b: number): number em TypeScript que rejeita string no compile-time, evitando TypeError em runtime como em JS: soma('2', 3) // crasha só ao chamar.",
                              "finalVerifications": [
                                "Explique em 1 parágrafo a diferença principal entre estática e dinâmica.",
                                "Forneça 2 exemplos de erros exclusivos de cada tipo.",
                                "Descreva um cenário onde estática previne crash em produção.",
                                "Compare trade-offs em uma frase por lado.",
                                "Liste 3 linguagens para cada abordagem.",
                                "Simule correção de um erro dinâmico via estática."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: distinção clara de timing e escopo.",
                                "Uso de exemplos relevantes e corretos.",
                                "Profundidade na comparação: trade-offs e cenários.",
                                "Clareza na comunicação: tabelas ou listas bem estruturadas.",
                                "Aplicação prática: demonstração funcional.",
                                "Análise crítica: reconhecimento de contextos ideais para cada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica formal (provas estáticas) vs. testes empíricos (dinâmicos).",
                                "Engenharia de Software: Controle de qualidade e debugging sistemático.",
                                "Ciência da Computação: Teoria de linguagens e semântica.",
                                "Gestão de Projetos: Impacto no tempo de ciclo de desenvolvimento."
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps bancários ou e-commerce, tipagem estática (ex: Kotlin em Android) previne crashes por dados inválidos de usuários, reduzindo downtime e custos de suporte em até 50%, como visto em equipes da Google e Microsoft."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.2",
                        "name": "Melhor Performance em Execução",
                        "description": "Com tipos definidos em compile-time, o bytecode ou código máquina gerado dispensa verificações dinâmicas de tipo durante a execução, resultando em tempos de execução mais rápidos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.2.1",
                            "name": "Analisar impacto de verificações ausentes em runtime",
                            "description": "Examinar assembly ou bytecode de programas em linguagens estáticas para observar ausência de type checks dinâmicos, comparando velocidades de execução com linguagens dinâmicas como Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar programas equivalentes em linguagens estática e dinâmica",
                                  "subSteps": [
                                    "Escreva uma função simples idêntica em C++ (estática) e Python (dinâmica), como soma de uma lista de números inteiros.",
                                    "Garanta que ambas as funções realizem a mesma operação lógica, variando apenas a linguagem.",
                                    "Inclua loops ou operações repetitivas para amplificar diferenças de performance.",
                                    "Salve os códigos em arquivos separados: soma.cpp e soma.py.",
                                    "Teste compilação/execução básica em ambas."
                                  ],
                                  "verification": "Ambos os programas compilam/executam sem erros e produzem o mesmo resultado para uma entrada de teste (ex: lista [1,2,3,4,5] soma 15).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto (VS Code), compilador GCC para C++, Python 3 instalado.",
                                  "tips": "Use listas grandes (10^6 elementos) para evidenciar diferenças; evite otimizações compiler-specific.",
                                  "learningObjective": "Entender como estruturar experimentos controlados para comparação de linguagens.",
                                  "commonMistakes": "Códigos não equivalentes logicamente; esquecer de usar tipos explícitos em C++."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inspecionar assembly ou bytecode para ausência de type checks",
                                  "subSteps": [
                                    "Compile o código C++ com flags de debug: g++ -S -O0 soma.cpp para gerar soma.s (assembly).",
                                    "Abra o arquivo assembly e procure por instruções de type checking (ex: ausência de casts dinâmicos ou verificações em runtime).",
                                    "Para Python, use dis.dis() ou pydisasm para disassemblar o bytecode e identificar LOAD_ATTR/CHECK dinâmicos.",
                                    "Anote diferenças: C++ tem instruções diretas (add/mov), Python tem verificações implícitas.",
                                    "Compare visualmente seções críticas como loop de soma."
                                  ],
                                  "verification": "Relatório anotado destacando pelo menos 3 diferenças em type checks ausentes no assembly C++ vs. bytecode Python.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "GCC compiler, Python com dis module, visualizador de texto (nano/vim).",
                                  "tips": "Use -O0 para desabilitar otimizações e ver código 'cru'; foque em funções de soma.",
                                  "learningObjective": "Identificar evidências de type checking em baixo nível e sua ausência em tipagem estática.",
                                  "commonMistakes": "Confundir otimizações com type checks; não desabilitar otimizações."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar benchmarks de performance",
                                  "subSteps": [
                                    "Implemente medição de tempo em ambos: use clock() em C++, timeit em Python.",
                                    "Execute 1000 iterações com listas de 10^6 elementos e registre tempos médios.",
                                    "Repita 5 vezes para média e calcule desvio padrão.",
                                    "Registre uso de CPU/memória com tools como time ou psutil.",
                                    "Gere gráficos simples com matplotlib (Python) comparando tempos."
                                  ],
                                  "verification": "Tabela ou gráfico mostrando C++ ~10-100x mais rápido que Python no teste.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Bibliotecas timeit/psutil (Python), <chrono> ou clock() (C++), matplotlib opcional.",
                                  "tips": "Execute em máquina idle; aqueça cache com runs iniciais descartados.",
                                  "learningObjective": "Medir quantitativamente o impacto de verificações ausentes em velocidade.",
                                  "commonMistakes": "Listas pequenas (não evidenciam diferença); não usar repetições suficientes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e correlacionar resultados com type system",
                                  "subSteps": [
                                    "Compare tempos: relacione lentidão Python a type checks no bytecode.",
                                    "Explique como tipagem estática resolve tipos em compile-time, eliminando runtime checks.",
                                    "Discuta trade-offs: performance vs. flexibilidade.",
                                    "Teste variação: adicione type hints em Python e recompile com mypy para simular estática.",
                                    "Escreva relatório de 1 página resumindo achados."
                                  ],
                                  "verification": "Relatório explicando causalidade entre ausência de checks e performance, com evidências.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "mypy para Python type hints, editor para relatório.",
                                  "tips": "Use termos como 'static dispatch' vs. 'dynamic dispatch'; cite referências como LLVM docs.",
                                  "learningObjective": "Sintetizar análise para concluir sobre vantagens da tipagem estática.",
                                  "commonMistakes": "Ignorar fatores externos (GC Python); generalizar sem evidências."
                                }
                              ],
                              "practicalExample": "Implemente soma de lista de 1 milhão inteiros: C++ leva ~0.01s, Python ~1s. Assembly C++ mostra add direto; Python bytecode tem BINARY_OP com checks.",
                              "finalVerifications": [
                                "Identifica ausência de type checks no assembly/bytecode de linguagens estáticas.",
                                "Benchmark demonstra speedup >10x para estática vs. dinâmica.",
                                "Relatório correlaciona corretamente performance a verificações runtime.",
                                "Teste com type hints em Python reduz gap, confirmando hipótese.",
                                "Gráficos/tabulares suportam conclusões quantitativamente.",
                                "Discute limitações do experimento (ex: GC)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na inspeção de assembly/bytecode (70% peso).",
                                "Qualidade e repetibilidade dos benchmarks (20% peso).",
                                "Profundidade da análise causal (10% peso).",
                                "Clareza do relatório e visualizações.",
                                "Correção conceitual sobre tipagem.",
                                "Tratamento de edge cases e trade-offs."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise estatística de benchmarks (média, desvio).",
                                "Física: Analogia com eficiência energética em sistemas.",
                                "Engenharia de Software: Otimização e profiling.",
                                "Ciência da Computação Geral: Compiladores e VMs."
                              ],
                              "realWorldApplication": "Em desenvolvimento de jogos (Unity/C# estática para performance crítica) ou apps mobile (Swift estática vs. JS dinâmico), onde runtime type checks causam lags; otimiza engines como game loops."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.2",
                            "name": "Medir performance em benchmarks simples",
                            "description": "Criar e executar benchmarks comparativos entre funções tipadas estaticamente e dinamicamente, medindo tempo de CPU e uso de memória em cenários de loops intensivos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de desenvolvimento para benchmarks",
                                  "subSteps": [
                                    "Instalar Node.js e npm no sistema.",
                                    "Criar um novo projeto Node.js com 'npm init -y'.",
                                    "Instalar TypeScript e ts-node: 'npm install -D typescript ts-node @types/node'.",
                                    "Configurar tsconfig.json básico para compilação estrita.",
                                    "Criar pastas para scripts JS e TS."
                                  ],
                                  "verification": "Verificar instalação executando 'node --version', 'tsc --version' e 'ts-node --version' sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Node.js (v18+), npm, editor de código (VS Code recomendado)",
                                  "tips": "Use nvm para gerenciar versões do Node.js e evitar conflitos.",
                                  "learningObjective": "Preparar um ambiente híbrido JS/TS para comparações de performance.",
                                  "commonMistakes": "Esquecer de instalar @types/node, causando erros de tipagem em TS."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o cenário de benchmark com loop intensivo",
                                  "subSteps": [
                                    "Criar uma função comum de workload: soma acumulada em array de 1 milhão de elementos em 1000 iterações.",
                                    "Implementar funções auxiliares para medir tempo de CPU com process.hrtime() e memória com process.memoryUsage().",
                                    "Escrever um runner de benchmark que execute o loop N vezes e registre médias.",
                                    "Adicionar warm-up runs para estabilizar o JIT.",
                                    "Salvar como template.js e template.ts."
                                  ],
                                  "verification": "Executar o template uma vez e confirmar que retorna métricas sem erros (tempo >0, memória heapUsed >0).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código, terminal com Node.js",
                                  "tips": "Use console.time() para testes rápidos iniciais antes de hrtime.",
                                  "learningObjective": "Entender como estruturar workloads realistas para benchmarks justos.",
                                  "commonMistakes": "Não incluir warm-up, levando a resultados inconsistentes devido ao JIT."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e executar benchmark para tipagem dinâmica (JavaScript)",
                                  "subSteps": [
                                    "Copiar template para dynamic-benchmark.js.",
                                    "Implementar a função de soma sem tipos: function sumArray(arr) { let sum = 0; for(let i=0; i<arr.length; i++) sum += arr[i]; return sum; }.",
                                    "Executar 10 runs completos com node dynamic-benchmark.js e registrar tempos e memórias médios.",
                                    "Calcular desvios padrão básicos para validar consistência.",
                                    "Salvar resultados em arquivo JSON ou log."
                                  ],
                                  "verification": "Script executa sem erros e produz output com tempo médio < 500ms e memória heap ~50MB para o workload.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Arquivos JS criados, terminal",
                                  "tips": "Execute em modo release (sem --inspect) para performance máxima.",
                                  "learningObjective": "Medir baseline de performance em linguagem dinamicamente tipada.",
                                  "commonMistakes": "Usar var ao invés de let/const, alterando escopo e performance."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e executar benchmark para tipagem estática (TypeScript)",
                                  "subSteps": [
                                    "Copiar template para static-benchmark.ts.",
                                    "Tipar a função: function sumArray(arr: number[]): number { let sum: number = 0; for(let i: number=0; i<arr.length; i++) sum += arr[i]; return sum; }.",
                                    "Executar com ts-node static-benchmark.ts, 10 runs, registrar métricas.",
                                    "Comparar compilação tsc vs execução direta para notar overhead inicial.",
                                    "Salvar resultados."
                                  ],
                                  "verification": "Tempo médio em TS menor ou igual ao JS (esperado ganho de 5-20%), sem erros de compilação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "ts-node instalado, arquivos TS",
                                  "tips": "Use 'ts-node --transpile-only' para pular type-checking em execuções repetidas.",
                                  "learningObjective": "Observar ganhos de performance da tipagem estática em runtime.",
                                  "commonMistakes": "Tipagem incorreta causando erros de compilação desnecessários."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e comparar resultados dos benchmarks",
                                  "subSteps": [
                                    "Criar tabela comparativa: tempo JS vs TS, memória JS vs TS, % de melhoria.",
                                    "Executar múltiplos benchmarks variando tamanho do array (10k, 1M, 10M) para tendências.",
                                    "Plotar gráficos simples com console.table() ou exportar para CSV.",
                                    "Documentar conclusões sobre impacto da tipagem estática.",
                                    "Repetir benchmarks em máquina limpa para validar."
                                  ],
                                  "verification": "Relatório mostra TS consistentemente mais rápido em loops intensivos, com evidências numéricas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Resultados salvos, planilha ou script de análise",
                                  "tips": "Use médias de 50+ runs para estatística robusta.",
                                  "learningObjective": "Interpretar dados de benchmark para validar vantagens da tipagem estática.",
                                  "commonMistakes": "Ignorar garbage collection, medindo apenas um run."
                                }
                              ],
                              "practicalExample": "Benchmark de soma em array de 1e6 números, 1000 iterações: JS leva 250ms (heap 45MB), TS leva 210ms (heap 42MB), ganho de 16% em tempo e 7% em memória devido a otimizações de tipo no V8 JIT.",
                              "finalVerifications": [
                                "Benchmarks executados pelo menos 10x para cada versão sem crashes.",
                                "Resultados mostram diferença mensurável (>5%) favorecendo tipagem estática.",
                                "Métricas de tempo e memória registradas com desvios <10%.",
                                "Código fonte comentado e reproduzível.",
                                "Gráficos ou tabelas comparativas geradas.",
                                "Conclusões alinhadas com teoria de performance estática."
                              ],
                              "assessmentCriteria": [
                                "Precisão e consistência das medições (desvios baixos).",
                                "Fairness no design do benchmark (mesmo workload).",
                                "Uso correto de APIs de performance do Node.js.",
                                "Análise quantitativa com % de melhoria calculados.",
                                "Documentação clara de setup e resultados.",
                                "Identificação de fatores como JIT impactando resultados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística descritiva (médias, desvios) para análise de dados.",
                                "Física/Engenharia: Medição experimental de performance como em testes de carga.",
                                "Algoritmos: Otimização de loops e complexidade temporal O(n).",
                                "Banco de Dados: Benchmarks semelhantes para queries SQL vs NoSQL."
                              ],
                              "realWorldApplication": "Em desenvolvimento de APIs de alto tráfego (ex: Netflix usa TS para performance), onde loops intensivos em processamento de dados economizam custos de CPU em cloud, reduzindo bills em 10-20%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.3",
                            "name": "Explicar benefícios em aplicações de grande escala",
                            "description": "Discutir como a performance aprimorada beneficia sistemas OO de alto desempenho, como servidores web em Java, evitando overhead de boxing/unboxing.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Overhead de Boxing e Unboxing em Tipagem Dinâmica",
                                  "subSteps": [
                                    "Defina boxing como a conversão de tipos primitivos para objetos wrapper (ex: int para Integer em Java).",
                                    "Defina unboxing como a conversão reversa de objetos wrapper para primitivos.",
                                    "Explique o custo: alocação de memória heap, garbage collection e verificações em runtime.",
                                    "Compare com operações diretas em primitivos: sem alocação extra.",
                                    "Discuta impacto cumulativo em loops ou coleções grandes."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo boxing/unboxing com um exemplo de código simples que demonstre o overhead.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação Java (Oracle Docs sobre autoboxing), IDE como IntelliJ para testes rápidos.",
                                  "tips": "Use ferramentas como VisualVM para medir alocações de memória em exemplos reais.",
                                  "learningObjective": "Compreender mecanicamente como boxing/unboxing consome recursos em runtime.",
                                  "commonMistakes": "Confundir boxing com casting de tipos; ignorar que em linguagens dinâmicas como Python, isso é inerente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Vantagens da Tipagem Estática na Evitação de Overhead",
                                  "subSteps": [
                                    "Descreva como compiladores de tipagem estática (ex: Java) otimizam primitivos sem wrappers automáticos.",
                                    "Compare código: use genéricos com tipos primitivos vs. wrappers (ArrayList<Integer> vs. primitivas especializadas).",
                                    "Explique otimizações JIT: inlining direto sem verificações runtime para tipos conhecidos.",
                                    "Calcule overhead aproximado: 2-10x mais lento em benchmarks para operações intensivas.",
                                    "Teste um micro-benchmark simples somando 1 milhão de elementos."
                                  ],
                                  "verification": "Execute e compare tempos de execução de dois snippets de código: um com boxing, outro sem.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "JDK instalado, JMH (Java Microbenchmark Harness) ou código simples em main method.",
                                  "tips": "Force boxing explícito no código para isolar o impacto; rode em modo -server para JIT.",
                                  "learningObjective": "Identificar otimizações específicas da tipagem estática que eliminam overhead desnecessário.",
                                  "commonMistakes": "Atribuir toda performance a tipagem estática, ignorando fatores como caching ou hardware."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Conceitos a Sistemas OO de Alto Desempenho",
                                  "subSteps": [
                                    "Descreva arquitetura de servidores web Java (ex: Tomcat/Spring Boot): threads, handlers, request processing.",
                                    "Identifique hotspots: parsing JSON, manipulação de coleções em memória, loops em responses.",
                                    "Explique escalabilidade: milhões de requests/minuto demandam CPU eficiente sem GC spikes.",
                                    "Compare com linguagens dinâmicas: Node.js/Python sofrem mais com boxing implícito em loops.",
                                    "Cite métricas reais: redução de 20-50% em latência por evitar autoboxing em frameworks."
                                  ],
                                  "verification": "Crie um diagrama simples mostrando fluxo de request em servidor Java destacando pontos de performance.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Diagrama tools como Draw.io, docs de Spring Boot performance tuning.",
                                  "tips": "Pesquise 'Java autoboxing performance pitfalls' para cases reais de produção.",
                                  "learningObjective": "Conectar teoria de tipagem a componentes reais de aplicações enterprise.",
                                  "commonMistakes": "Focar só em teoria sem ligar a cenários concretos como throughput de servidores."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Quantificar e Comunicar Benefícios em Escala",
                                  "subSteps": [
                                    "Defina métricas chave: throughput (req/s), latência média, uso de CPU/GC pauses.",
                                    "Apresente dados: benchmarks mostrando 30% ganho em apps com tipagem estática vs. dinâmica.",
                                    "Discuta trade-offs: tipagem estática adiciona compile-time mas salva runtime em escala.",
                                    "Prepare argumentos persuasivos: ROI em cloud costs (menos instâncias necessárias).",
                                    "Simule escala: multiplique overhead por 1M users diários."
                                  ],
                                  "verification": "Escreva um relatório curto (200 palavras) com tabela de métricas comparativas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Benchmarks públicos (TechEmpower), planilha Google Sheets para simulações.",
                                  "tips": "Use gráficos para visualizar: barras de tempo execução vs. escala de dados.",
                                  "learningObjective": "Articular benefícios de forma mensurável e convincente para stakeholders.",
                                  "commonMistakes": "Exagerar ganhos sem evidências; ignorar que em I/O bound apps, impacto é menor."
                                }
                              ],
                              "practicalExample": "Em um servidor web Spring Boot processando 10k requests/segundo, use primitives int para contadores de views em vez de Integer: reduz GC de 15% para 2%, elevando throughput de 8k para 12k req/s, medido via JMeter.",
                              "finalVerifications": [
                                "Explica corretamente boxing/unboxing com exemplo de código.",
                                "Compara performance estática vs. dinâmica com métricas quantitativas.",
                                "Identifica 3+ hotspots em servidores web beneficiados.",
                                "Apresenta pelo menos 2 casos reais ou benchmarks.",
                                "Discute escalabilidade em termos de custos cloud.",
                                "Responde perguntas sobre trade-offs sem hesitação."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (20%): Definições e mecanismos corretos.",
                                "Profundidade técnica (25%): Uso de exemplos e benchmarks reais.",
                                "Clareza de comunicação (20%): Explicação acessível com analogias.",
                                "Relevância a escala (20%): Foco em apps high-load como servidores.",
                                "Evidências quantitativas (15%): Números, gráficos ou simulações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de complexidade Big-O em loops com overhead.",
                                "Negócios: Cálculo de ROI em performance para redução de custos de infraestrutura.",
                                "Engenharia de Software: Princípios de otimização e profiling em sistemas distribuídos.",
                                "Física/Computação: Analogia com eficiência energética em processadores."
                              ],
                              "realWorldApplication": "Em plataformas como Netflix ou AWS Lambda (Java), tipagem estática permite escalar para bilhões de requests/dia sem crashes por GC, economizando milhões em hardware e otimizando SLAs de 99.99% uptime."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.3",
                        "name": "Suporte a Otimizações do Compilador",
                        "description": "O conhecimento prévio dos tipos permite que o compilador aplique otimizações como inlining de métodos, eliminação de código morto e vetorização, gerando código mais eficiente.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.3.1",
                            "name": "Identificar otimizações baseadas em tipos",
                            "description": "Reconhecer técnicas como monomorfização em genéricos ou devirtualização de chamadas polimórficas em compiladores como GCC ou Javac, com exemplos de antes/depois.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Otimizações Baseadas em Tipos",
                                  "subSteps": [
                                    "Estude o que é tipagem estática e como ela permite inferências no tempo de compilação.",
                                    "Revise conceitos de polimorfismo e genéricos em linguagens como C++, Java e Rust.",
                                    "Identifique diferenças entre resolução dinâmica e estática de tipos.",
                                    "Analise como compiladores usam informações de tipo para eliminar overhead.",
                                    "Leia documentação oficial de GCC sobre otimizações de tipo."
                                  ],
                                  "verification": "Resuma em 3 frases os benefícios da tipagem estática para otimizações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação GCC Inline Assembly",
                                    "Capítulo sobre Tipagem em 'Modern C++ Design'",
                                    "Rust Book: Generics"
                                  ],
                                  "tips": "Comece com exemplos simples de funções genéricas para visualizar o impacto.",
                                  "learningObjective": "Explicar como a tipagem estática habilita otimizações específicas do compilador.",
                                  "commonMistakes": [
                                    "Confundir tipagem estática com dinâmica",
                                    "Ignorar overhead de runtime em polimorfismo virtual"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Monomorfização em Genéricos",
                                  "subSteps": [
                                    "Escreva um exemplo genérico em Rust ou C++ que use uma função template.",
                                    "Compile com flags de debug e otimizado, comparando o assembly gerado.",
                                    "Observe como o compilador gera código especializado para cada tipo usado.",
                                    "Teste com múltiplos tipos (int, float, string) e verifique duplicação de código.",
                                    "Use ferramentas como godbolt.org para visualizar antes/depois."
                                  ],
                                  "verification": "Gere assembly para um genérico e identifique instâncias monomorfizadas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Compiler Explorer (godbolt.org)",
                                    "Rust Playground",
                                    "C++ Templates: The Complete Guide (livro)"
                                  ],
                                  "tips": "Use -O0 vs -O3 no GCC para contrastar sem/sem otimizações.",
                                  "learningObjective": "Reconhecer monomorfização como geração de código especializado por tipo.",
                                  "commonMistakes": [
                                    "Achar que genéricos sempre evitam duplicação de código",
                                    "Não habilitar otimizações no compilador"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Devirtualização de Chamadas Polimórficas",
                                  "subSteps": [
                                    "Crie uma hierarquia de classes em Java ou C++ com métodos virtuais.",
                                    "Implemente chamadas polimórficas e compile com Javac ou GCC.",
                                    "Examine o bytecode ou assembly para vtables e chamadas indiretas.",
                                    "Aplique otimizações como devirtualização inline e compare tamanhos/performance.",
                                    "Teste cenários onde o compilador devirtualiza (conhecido no compile-time)."
                                  ],
                                  "verification": "Modifique código para forçar devirtualização e meça ganho de performance.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Javap para bytecode Java",
                                    "Objdump para GCC assembly",
                                    "Artigo 'Devirtualization in HotSpot'"
                                  ],
                                  "tips": "Foque em classes finais ou chamadas com tipo conhecido para devirtualização.",
                                  "learningObjective": "Identificar transformações de chamadas virtuais em diretas via análise de tipo.",
                                  "commonMistakes": [
                                    "Confundir devirtualização com inlining geral",
                                    "Testar sem perfis de uso conhecidos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação em Exemplos Reais",
                                  "subSteps": [
                                    "Selecione código open-source (ex: biblioteca STL) e disasseble funções genéricas.",
                                    "Compare versões otimizadas vs não-otimizadas, anotando otimizações de tipo.",
                                    "Crie um checklist para detectar monomorfização/devirtualização no assembly.",
                                    "Discuta exemplos antes/depois em um repositório GitHub pessoal.",
                                    "Resolva exercícios de identificação em plataformas como LeetCode com foco em perf."
                                  ],
                                  "verification": "Documente 2 exemplos reais com screenshots de assembly antes/depois.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "GitHub repos de benchmarks",
                                    "Perf tool no Linux",
                                    "LLVM Optimization Remarks"
                                  ],
                                  "tips": "Habilite -Rpass=missed no Clang para ver otimizações perdidas.",
                                  "learningObjective": "Aplicar conhecimento para identificar otimizações em código compilado.",
                                  "commonMistakes": [
                                    "Não usar ferramentas de disassemblagem",
                                    "Ignorar flags de otimização específicas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Rust: fn max<T: PartialOrd>(a: T, b: T) -> T { ... } Compilado para i32 e f64 gera duas funções idênticas mas tipadas, eliminando branches runtime vs versão boxed dinâmica.",
                              "finalVerifications": [
                                "Explicar monomorfização com diagrama antes/depois.",
                                "Identificar devirtualização em assembly de chamada virtual.",
                                "Medir speedup (>20%) em benchmark com otimizações ativadas.",
                                "Listar 3 cenários onde tipagem estática falha em otimizar.",
                                "Analisar código GCC -O3 vs -O0 para uma classe polimórfica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de monomorfização (ex: múltiplas instâncias no binário).",
                                "Correta distinção entre devirtualização e outras otimizações (ex: inlining).",
                                "Uso correto de ferramentas (godbolt, objdump) com evidências visuais.",
                                "Exemplos incluem métricas de performance (tempo/tamanho código).",
                                "Conexão clara com tipagem estática vs dinâmica.",
                                "Ausência de confusões comuns como overhead de vtables."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Entender impacto no cache e branch prediction.",
                                "Análise de Algoritmos: Otimizações afetam complexidade assintótica prática.",
                                "Engenharia de Software: Trade-offs em design genérico vs performance.",
                                "Matemática Discreta: Inferência de tipos como resolução de sistemas.",
                                "Sistemas Operacionais: Otimizações em kernels com tipagem forte."
                              ],
                              "realWorldApplication": "Em engines de jogos como Unreal (C++ templates monomorfizados para performance crítica) ou JVM HotSpot (devirtualização para apps de alta throughput como servidores web), reduzindo latência em 10-50% em loops quentes."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.3.2",
                            "name": "Usar flags de compilador para visualizar otimizações",
                            "description": "Aplicar opções como -O2 no GCC ou -server no JVM para observar otimizações estáticas em código OO, analisando relatórios de otimização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar ambiente e código de exemplo em linguagem OO estática",
                                  "subSteps": [
                                    "Instale um compilador como GCC para C++ ou javac/JVM para Java.",
                                    "Crie um código simples OO com loop ou recursão, ex: classe com método que soma números em loop.",
                                    "Compile o código sem otimizações (ex: g++ -O0) para baseline.",
                                    "Gere assembly ou bytecode inicial com ferramentas como objdump ou javap.",
                                    "Documente o tamanho do binário ou número de instruções."
                                  ],
                                  "verification": "Confirme que o código compila sem erros e gerei o assembly/bytecode baseline salvo em arquivo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "GCC/Clang instalado, editor de código (VS Code), terminal, código fonte exemplo (ex: SimpleLoop.cpp).",
                                  "tips": "Use códigos curtos (50-100 linhas) para facilitar análise.",
                                  "learningObjective": "Configurar ambiente para experimentos de compilação controlada.",
                                  "commonMistakes": "Esquecer de instalar dependências ou usar flags incorretas no baseline."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar flags básicas de otimização e compilar",
                                  "subSteps": [
                                    "Identifique flags comuns: -O1, -O2, -O3 no GCC; -server ou -XX:+UnlockDiagnosticVMOptions na JVM.",
                                    "Compile o mesmo código com -O2 (ex: g++ -O2 -S arquivo.cpp).",
                                    "Compare tamanhos de binários e tempos de execução com time ou perf.",
                                    "Ative verbose logging (ex: -v ou -Xlog:compilation na JVM).",
                                    "Salve outputs para comparação lado a lado."
                                  ],
                                  "verification": "Verifique redução no tamanho do assembly ou tempo de execução menor que baseline.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Mesmo código do step 1, ferramentas perf/time, diff para comparar arquivos.",
                                  "tips": "Use -S para gerar assembly diretamente no GCC.",
                                  "learningObjective": "Entender impacto imediato de flags de otimização em performance.",
                                  "commonMistakes": "Confundir flags de debug (-g) com otimizações, invalidando comparações."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar e analisar relatórios de otimizações do compilador",
                                  "subSteps": [
                                    "Ative relatórios detalhados: -fopt-info ou -fdump-tree-all no GCC; -XX:+PrintCompilation na JVM.",
                                    "Recompile com flags de relatório e capture outputs em arquivo de log.",
                                    "Identifique otimizações como inlining, loop unrolling, dead code elimination.",
                                    "Use ferramentas como godbolt.org para visualização online.",
                                    "Anotar mudanças específicas no código OO (ex: métodos inlineados)."
                                  ],
                                  "verification": "Localize pelo menos 3 otimizações nomeadas no log (ex: 'Inlining successful').",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Compiler Godbolt (online), logs de compilação salvos.",
                                  "tips": "Filtre logs com grep para 'optimize' ou 'inline'.",
                                  "learningObjective": "Interpretar relatórios para mapear otimizações a código fonte.",
                                  "commonMistakes": "Ignorar warnings ou não ativar logs verbosos o suficiente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar otimizações e testar em cenários OO reais",
                                  "subSteps": [
                                    "Compare assembly/bytecode otimizado vs baseline linha por linha.",
                                    "Teste em código OO maior: herança, polimorfismo virtual (note desotimizações).",
                                    "Meça performance com benchmarks (ex: Google Benchmark para C++).",
                                    "Documente trade-offs (ex: -O3 pode aumentar tamanho).",
                                    "Experimente flags específicas como -finline-functions."
                                  ],
                                  "verification": "Crie tabela comparativa mostrando pelo menos 2 otimizações impactantes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Benchmark libs, planilha para tabela (Google Sheets).",
                                  "tips": "Foco em polimorfismo: otimizações param em chamadas virtuais.",
                                  "learningObjective": "Aplicar análise a contextos OO complexos.",
                                  "commonMistakes": "Não isolar variáveis (ex: hardware diferente entre runs)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar aprendizados e planejar uso futuro",
                                  "subSteps": [
                                    "Resuma otimizações observadas e quando usá-las.",
                                    "Teste desabilitando flags específicas (ex: -fno-inline).",
                                    "Crie script para compilação automatizada com flags variáveis.",
                                    "Pesquise docs oficiais (GCC manual, JVM opts).",
                                    "Registre em relatório pessoal."
                                  ],
                                  "verification": "Relatório escrito com 5+ insights acionáveis.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de texto, docs GCC/JVM online.",
                                  "tips": "Automatize com Makefile para reprodutibilidade.",
                                  "learningObjective": "Internalizar flags para uso recorrente em dev.",
                                  "commonMistakes": "Generalizar demais sem testar em código real."
                                }
                              ],
                              "practicalExample": "Em C++ OO: Crie classe Calculator com método sumLoop(1000000). Compile com g++ -O0 vs -O2 -fopt-info. Observe loop unrolling e inlining de sumLoop no assembly otimizado, reduzindo iterações de 1M para vetorizado SIMD.",
                              "finalVerifications": [
                                "Gera relatórios de otimização com pelo menos 3 flags diferentes.",
                                "Identifica e explica 2+ otimizações específicas (ex: inlining, unrolling).",
                                "Compara performance/binário antes/depois com métricas quantificáveis.",
                                "Testa em código OO com polimorfismo, notando limitações.",
                                "Cria script reproduzível para futuras compilações.",
                                "Documenta trade-offs de flags em relatório."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação e interpretação de flags (90%+ correção).",
                                "Profundidade da análise de relatórios (cita otimizações nomeadas).",
                                "Uso correto de ferramentas de comparação (diff, perf).",
                                "Reprodutibilidade: outros podem rodar experimento.",
                                "Conexão clara com tipagem estática/OO (ex: inlining em métodos).",
                                "Relatório claro com tabelas/gráficos de métricas."
                              ],
                              "crossCurricularConnections": [
                                "Algoritmos: Impacto de otimizações em complexidade prática.",
                                "Arquitetura de Computadores: Entender instruções assembly geradas.",
                                "Desenvolvimento de Software: Perfis de performance em CI/CD.",
                                "Matemática: Vetorização e operações SIMD.",
                                "Engenharia de Software: Trade-offs otimização vs debuggability."
                              ],
                              "realWorldApplication": "Em equipes de software de alta performance (jogos, finanças), devs usam -O2/-O3 + relatórios para reduzir latência em 20-50%, otimizando métodos OO críticos sem quebrar funcionalidade, essencial em deploy de produção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.3.3",
                            "name": "Relacionar otimizações com princípios OO",
                            "description": "Explicar como encapsulamento e herança em tipagem estática facilitam otimizações, como resolução estática de métodos em hierarquias de classes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Princípios Fundamentais de Encapsulamento e Herança em OO",
                                  "subSteps": [
                                    "Definir encapsulamento: mecanismo para ocultar detalhes internos de uma classe e expor apenas uma interface pública.",
                                    "Explicar como encapsulamento usa modificadores de acesso (private, public) para proteger dados.",
                                    "Definir herança: processo pelo qual uma classe derivada herda atributos e métodos de uma classe base, formando hierarquias.",
                                    "Descrever hierarquias de classes e como elas promovem reutilização de código.",
                                    "Discutir polimorfismo via herança, mas focar em resolução de métodos."
                                  ],
                                  "verification": "Criar um diagrama UML simples de uma hierarquia de classes com encapsulamento aplicado e explicar verbalmente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação de OO (Java ou C#), ferramenta de diagramação como Draw.io, exemplos de código fonte."
                                  ],
                                  "tips": "Desenhe diagramas de classes para visualizar hierarquias claramente.",
                                  "learningObjective": "Compreender como encapsulamento e herança estruturam código em tipagem estática.",
                                  "commonMistakes": "Confundir herança com composição ou ignorar modificadores de acesso no encapsulamento."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender Tipagem Estática e Resolução Estática de Métodos",
                                  "subSteps": [
                                    "Explicar tipagem estática: tipos declarados em tempo de compilação, verificados pelo compilador.",
                                    "Contrastar com tipagem dinâmica: tipos resolvidos em runtime.",
                                    "Descrever resolução estática de métodos: compilador determina qual método chamar baseado no tipo declarado, não no runtime.",
                                    "Exemplificar com chamada de método em hierarquia: superclasse vs subclasse.",
                                    "Discutir benefícios para performance: elimina lookups em runtime."
                                  ],
                                  "verification": "Escrever um snippet de código em Java mostrando resolução estática e compilar sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador Java ou C#, IDE como IntelliJ ou VS Code, exemplos de código tipagem estática vs dinâmica."
                                  ],
                                  "tips": "Use 'super' para chamar métodos da superclasse e observe o comportamento em compile-time.",
                                  "learningObjective": "Identificar como tipagem estática permite análises prévias pelo compilador.",
                                  "commonMistakes": "Achar que resolução estática é a mesma que sobrescrita dinâmica (override)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar Encapsulamento, Herança e Otimizações do Compilador",
                                  "subSteps": [
                                    "Explicar como encapsulamento permite ao compilador otimizar acesso a dados internos sem exposição.",
                                    "Mostrar como herança em hierarquias permite resolução estática: compilador inline ou otimiza chamadas conhecidas.",
                                    "Discutir inlining de métodos: possível porque tipos são conhecidos estaticamente.",
                                    "Comparar com tipagem dinâmica: otimizações limitadas por dispatch dinâmico.",
                                    "Analisar dead code elimination em métodos encapsulados não usados."
                                  ],
                                  "verification": "Mapear em um fluxograma como o compilador otimiza uma chamada de método em herança estática.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramentas de análise de compilador como javap, documentação de otimizações JVM."
                                  ],
                                  "tips": "Use flags de compilador (-O2 ou similar) para observar otimizações geradas.",
                                  "learningObjective": "Explicar mecanicamente como OO + tipagem estática habilita otimizações.",
                                  "commonMistakes": "Ignorar que encapsulamento sozinho não otimiza; precisa de tipagem estática."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o Conceito em um Exemplo Prático e Verificar Otimizações",
                                  "subSteps": [
                                    "Implementar hierarquia simples: Classe Veiculo > Carro com métodos encapsulados.",
                                    "Compilar e disassemblar o bytecode para ver resolução estática.",
                                    "Medir performance comparando com versão dinâmica (ex: Python).",
                                    "Identificar otimizações específicas: inlining, eliminação de código.",
                                    "Refatorar para maximizar otimizações via OO."
                                  ],
                                  "verification": "Gerar relatório com bytecode antes/depois e métricas de tempo de execução.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "IDE com suporte a disassembly, benchmark tools como JMH para Java, código Python equivalente."
                                  ],
                                  "tips": "Execute benchmarks múltiplas vezes para médias confiáveis.",
                                  "learningObjective": "Demonstrar empiricamente as otimizações facilitadas por OO em tipagem estática.",
                                  "commonMistakes": "Comparar linguagens sem isolar a variável de tipagem."
                                }
                              ],
                              "practicalExample": "Em Java (tipagem estática), crie classe Animal com método privado makeSound() encapsulado, herdada por Dog que sobrescreve public speak(). O compilador resolve speak() estaticamente para Dog, permitindo inlining. Em Python (dinâmica), resolução em runtime impede otimizações semelhantes, resultando em dispatch mais lento.",
                              "finalVerifications": [
                                "Explica corretamente como encapsulamento protege dados para otimizações inline.",
                                "Descreve resolução estática em hierarquias de herança com exemplo de código.",
                                "Identifica pelo menos 3 otimizações específicas (inlining, dead code elimination, static dispatch).",
                                "Compara com tipagem dinâmica mostrando limitações.",
                                "Analisa bytecode ou assembly comprovando otimizações.",
                                "Aplica conceito em um exemplo personalizado sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de OO e tipagem estática (30%)",
                                "Profundidade de relação: explicação clara de otimizações habilitadas (25%)",
                                "Uso de exemplos: códigos e análises práticas relevantes (20%)",
                                "Comparação: distinção clara com tipagem dinâmica (15%)",
                                "Clareza e estrutura: comunicação lógica e visual (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Design de classes otimizadas para performance.",
                                "Algoritmos e Complexidade: Análise de tempo Big-O influenciada por otimizações estáticas.",
                                "Matemática Discreta: Lógica de tipos e grafos de herança.",
                                "Sistemas Operacionais: Otimizações de compilador em kernels e drivers."
                              ],
                              "realWorldApplication": "Em desenvolvimento de engines de jogos como Unity (C# estática), onde heranças otimizadas permitem resolução estática de métodos em hierarquias de GameObjects, reduzindo latência em renderização e física em tempo real."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.4",
                    "name": "Características da Tipagem Dinâmica",
                    "description": "Flexibilidade no código, prototipagem rápida e menor verbosidade na declaração de tipos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.4.1",
                        "name": "Flexibilidade na atribuição de tipos",
                        "description": "Na tipagem dinâmica, as variáveis não possuem tipo fixo declarado previamente, permitindo reatribuições de valores de diferentes tipos durante a execução, o que proporciona maior flexibilidade no desenvolvimento de código orientado a objetos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.1.1",
                            "name": "Identificar a ausência de declaração de tipos em variáveis",
                            "description": "Compreender que em linguagens como Python, variáveis são criadas e tipadas implicitamente no momento da primeira atribuição, sem necessidade de palavras-chave como 'int' ou 'String'. Exemplo: x = 5; x = 'texto'.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de tipagem dinâmica em Python",
                                  "subSteps": [
                                    "Leia a documentação oficial do Python sobre tipos de dados e atribuição de variáveis.",
                                    "Assista a um vídeo curto explicando tipagem estática vs dinâmica (ex: 5 minutos no YouTube).",
                                    "Anote as diferenças principais: Python infere o tipo na runtime, sem declaração explícita.",
                                    "Resuma em suas palavras: 'Variáveis em Python não precisam de 'int x;' ou similar'.",
                                    "Confirme entendendo que type(x) revela o tipo após atribuição."
                                  ],
                                  "verification": "Escreva um parágrafo explicando tipagem dinâmica sem usar declaração de tipos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Python (python.org), vídeo tutorial sobre tipagem"
                                  ],
                                  "tips": "Foquem em exemplos simples como x = 5 para evitar confusão inicial.",
                                  "learningObjective": "Diferenciar tipagem dinâmica de estática conceitualmente.",
                                  "commonMistakes": "Confundir com JavaScript (também dinâmica) ou assumir que Python requer 'var' ou 'let'."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar exemplos de atribuição implícita de tipos",
                                  "subSteps": [
                                    "Abra um editor de código ou REPL Python.",
                                    "Digite e execute: x = 5; print(type(x))  # Mostra <class 'int'>",
                                    "Reatribua: x = 'texto'; print(type(x))  # Agora <class 'str'>",
                                    "Teste com lista: x = [1,2]; print(type(x))",
                                    "Observe que a mesma variável muda de tipo sem erro."
                                  ],
                                  "verification": "Execute o código e capture prints mostrando mudança de tipo na mesma variável.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python REPL ou IDE como VS Code com Python extension"
                                  ],
                                  "tips": "Use print(type(x)) após cada atribuição para visualização imediata.",
                                  "learningObjective": "Identificar ausência de declaração ao ver atribuições diretas.",
                                  "commonMistakes": "Esquecer de verificar type() e assumir tipo fixo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar com linguagens de tipagem estática",
                                  "subSteps": [
                                    "Revise sintaxe de C++ ou Java: int x = 5; string y = 'texto';",
                                    "Tente código Python equivalente em um compilador online de Java (ex: repl.it).",
                                    "Note erros ao reatribuir tipos diferentes sem declaração nova.",
                                    "Crie uma tabela comparativa: Colunas Python vs Java para declaração e reatribuição.",
                                    "Explique por que Python é mais flexível."
                                  ],
                                  "verification": "Crie e compartilhe a tabela comparativa com exemplos que falham em Java.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Online compilers: repl.it para Java/C++, Python REPL"
                                  ],
                                  "tips": "Use exemplos idênticos para comparação direta.",
                                  "learningObjective": "Reconhecer ausência de keywords como 'int' ou 'String' em Python.",
                                  "commonMistakes": "Ignorar que Java permite reatribuição dentro do mesmo tipo, mas não mudança."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação em códigos reais",
                                  "subSteps": [
                                    "Baixe snippets de código Python de repositórios GitHub (ex: scripts simples).",
                                    "Marque linhas com atribuições sem declaração de tipo (todas!).",
                                    "Modifique um snippet para adicionar declarações desnecessárias e veja que funciona igual.",
                                    "Crie um quiz pessoal: 'Esta linha declara tipo explicitamente? Por quê?'",
                                    "Teste 5-10 linhas variadas."
                                  ],
                                  "verification": "Liste 5 exemplos identificados com justificativa de ausência de declaração.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "GitHub para códigos Python, editor de texto"
                                  ],
                                  "tips": "Procure por '=' sem precedentes como 'int' ou 'def'.",
                                  "learningObjective": "Detectar padrões de ausência de declaração em código real.",
                                  "commonMistakes": "Confundir funções/arguments com variáveis."
                                }
                              ],
                              "practicalExample": "Em um script de processamento de dados: user_age = 25; user_name = 'Alice'; user_age = '25_str'; print(f'{user_name} tem {user_age} anos') – Funciona sem erros apesar da mudança de int para str na mesma variável.",
                              "finalVerifications": [
                                "Explicar verbalmente por que 'x = 5; x = \"hello\"' não gera erro de tipo em Python.",
                                "Identificar corretamente 10/10 snippets sem declaração de tipos.",
                                "Criar um script com reatribuições de tipos e confirmar execução sem erros.",
                                "Comparar com Java: mostrar código que falha ao copiar de Python.",
                                "Usar type() em variáveis reatribuídas e interpretar resultados.",
                                "Discutir vantagens da flexibilidade em prototipagem rápida."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de ausência de declaração (100% em testes).",
                                "Compreensão conceitual demonstrada em explicações claras.",
                                "Execução correta de exemplos com mudança de tipos.",
                                "Comparação válida com linguagens estáticas.",
                                "Criação independente de exemplos práticos.",
                                "Evitar erros comuns como assumir tipagem fixa."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Analogia com variáveis algébricas que mudam valor sem redeclaração.",
                                "Lógica: Raciocínio sobre inferência automática vs explícita.",
                                "Inglês: Leitura de documentação técnica em inglês.",
                                "Física/Química: Modelagem de estados variáveis em simulações."
                              ],
                              "realWorldApplication": "Em desenvolvimento ágil e data science, permite scripts rápidos para análise exploratória onde tipos evoluem durante experimentação, acelerando protótipos em ferramentas como Jupyter Notebooks."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.2",
                            "name": "Demonstrar reatribuição de tipos diferentes",
                            "description": "Criar exemplos de código onde uma variável muda de tipo (ex: de inteiro para string) sem erros de compilação, destacando a flexibilidade em cenários de prototipagem em POO.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos da Tipagem Dinâmica",
                                  "subSteps": [
                                    "Revise a definição de tipagem dinâmica: tipos são determinados em tempo de execução.",
                                    "Compare com tipagem estática (ex: Java requer declaração explícita).",
                                    "Execute exemplos básicos: x = 5; print(type(x)); x = 'texto'; print(type(x)).",
                                    "Leia documentação oficial do Python sobre duck typing e type() function.",
                                    "Anote diferenças chave em um documento pessoal."
                                  ],
                                  "verification": "Explique em 3 frases próprias a flexibilidade da tipagem dinâmica e execute o exemplo básico sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python 3 instalado",
                                    "Editor de código (VS Code ou Jupyter Notebook)",
                                    "Documentação Python (docs.python.org)"
                                  ],
                                  "tips": "Use type() e isinstance() para inspecionar tipos dinamicamente durante testes.",
                                  "learningObjective": "Identificar e exemplificar como a tipagem dinâmica permite reatribuições sem declaração prévia de tipo.",
                                  "commonMistakes": [
                                    "Confundir tipagem dinâmica com tipagem fraca (Python é forte mas dinâmica)",
                                    "Esperar erros de compilação como em linguagens estáticas",
                                    "Ignorar type hints opcionais no Python moderno"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar Exemplo Básico de Reatribuição de Tipos",
                                  "subSteps": [
                                    "Crie um script Python simples com uma variável inicial como inteiro: valor = 42.",
                                    "Imprima o tipo inicial: print(f'Tipo inicial: {type(valor)}').",
                                    "Reatribua para string: valor = 'Quarenta e dois'.",
                                    "Imprima o novo tipo e valor: print(f'Novo tipo: {type(valor)}, Valor: {valor}').",
                                    "Execute o script e confirme ausência de erros de compilação ou runtime."
                                  ],
                                  "verification": "O script executa sem erros e mostra mudança de <class 'int'> para <class 'str'> nos prints.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Python interpreter ou IDE",
                                    "Arquivo .py novo"
                                  ],
                                  "tips": "Sempre use print(type()) após cada atribuição para visualizar a mudança imediata.",
                                  "learningObjective": "Demonstrar reatribuição de tipos primitivos em escopo global sem intervenção do compilador.",
                                  "commonMistakes": [
                                    "Tentar usar operadores incompatíveis pós-reatribuição (ex: valor + 1 após string)",
                                    "Esquecer de imprimir tipos para verificação",
                                    "Assumir que Python 'converte' tipos automaticamente (não converte implicitamente em +)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Reatribuição em Atributos de Classe POO",
                                  "subSteps": [
                                    "Defina uma classe simples Prototype: class Prototype: pass.",
                                    "No __init__, atribua self.data = 100 (int).",
                                    "Adicione método change_to_string(self): self.data = str(self.data) + ' alterado'.",
                                    "Crie instância, imprima tipo inicial, chame método, imprima novo tipo.",
                                    "Teste com diferentes tipos iniciais (float para list, ex: self.data = [1,2]; self.data = 'lista' )."
                                  ],
                                  "verification": "Instância da classe mostra mudança de tipo em self.data sem exceções ao executar métodos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python IDE",
                                    "Exemplos de classes Python básicas"
                                  ],
                                  "tips": "Use self para atributos de instância, permitindo flexibilidade por objeto.",
                                  "learningObjective": "Aplicar reatribuição dinâmica em objetos POO, destacando encapsulamento flexível.",
                                  "commonMistakes": [
                                    "Declarar atributos com tipo fixo (não faça em Python puro)",
                                    "Confundir atributos de classe vs instância",
                                    "Não testar múltiplas reatribuições sequenciais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular Prototipagem com Mudanças de Tipo Iterativas",
                                  "subSteps": [
                                    "Expanda a classe para um cenário de prototipagem: adicione método prototype_evolve(self, new_type_data).",
                                    "No método, permita self.data = new_type_data onde new_type_data varia (int, str, list).",
                                    "Crie loop de prototipagem: instancie, evolua 3 vezes com tipos diferentes, imprimindo estado cada vez.",
                                    "Adicione validação runtime opcional com isinstance() para cenários reais.",
                                    "Documente o código com comentários explicando ganhos de flexibilidade."
                                  ],
                                  "verification": "O loop executa 3 evoluções sem erros, mostrando tipos variados em self.data.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python IDE",
                                    "Notebook para anotações de prototipagem"
                                  ],
                                  "tips": "Em prototipagem, priorize velocidade: evite type hints rígidos inicialmente.",
                                  "learningObjective": "Construir um exemplo prático de prototipagem POO aproveitando reatribuição dinâmica.",
                                  "commonMistakes": [
                                    "Criar lógica que assume tipo fixo (quebra flexibilidade)",
                                    "Exceder escopo com reatribuições desnecessárias",
                                    "Não logar mudanças para depuração"
                                  ]
                                }
                              ],
                              "practicalExample": "```python\nclass PrototipoSensor:\n    def __init__(self):\n        self.dado = 42.5  # float inicial (leitura numérica)\n    \n    def evoluir_tipo(self, novo_dado):\n        self.dado = novo_dado  # Reatribui qualquer tipo\n    \n# Uso em prototipagem\nsensor = PrototipoSensor()\nprint(f'Inicial: {type(sensor.dado)} - {sensor.dado}')  # <class 'float'>\n\nsensor.evoluir_tipo('Falha no sensor')  # Muda para str\nprint(f'Após falha: {type(sensor.dado)} - {sensor.dado}')  # <class 'str'>\n\nsensor.evoluir_tipo(['erro', 404])  # Muda para list\nprint(f'Após log: {type(sensor.dado)} - {sensor.dado}')  # <class 'list'>\n```\nSaída: Inicial: <class 'float'> - 42.5\nApós falha: <class 'str'> - Falha no sensor\nApós log: <class 'list'> - ['erro', 404]",
                              "finalVerifications": [
                                "Código executa completamente sem erros de compilação ou runtime.",
                                "Tipos de self.data mudam corretamente em múltiplas reatribuições.",
                                "Prints confirmam flexibilidade em cenários POO de prototipagem.",
                                "Nenhuma exceção TypeError ocorre em operações pós-reatribuição.",
                                "Explicação escrita justifica ausência de erros devido à tipagem dinâmica.",
                                "Testes com 3+ tipos diferentes (int, str, list) funcionam."
                              ],
                              "assessmentCriteria": [
                                "Demonstração clara de reatribuição sem erros em variáveis e objetos POO.",
                                "Uso correto de type() para verificação visual de mudanças.",
                                "Exemplo contextualizado em prototipagem, com métodos evolutivos.",
                                "Código limpo, comentado e executável independentemente.",
                                "Compreensão verbal da flexibilidade vs. rigidez estática."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Manipulação dinâmica de estruturas numéricas e simbólicas.",
                                "Ciência de Dados: Prototipagem rápida de datasets heterogêneos.",
                                "Design de Software: Princípios ágeis de iteração flexível.",
                                "Lógica Computacional: Duck typing e polimorfismo implícito."
                              ],
                              "realWorldApplication": "Em prototipagem de aplicativos web ou IoT (ex: dashboards em Django/Flask), permite desenvolvedores alterarem representações de dados (de numérico para JSON/string) durante testes rápidos, acelerando MVPs em startups sem recompilações, comum em hackathons ou R&D onde requisitos evoluem iterativamente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.3",
                            "name": "Analisar vantagens e riscos da flexibilidade",
                            "description": "Discutir benefícios como adaptação rápida em objetos dinâmicos e riscos como erros em runtime (ex: TypeError em Python), comparando com tipagem estática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de flexibilidade na tipagem dinâmica",
                                  "subSteps": [
                                    "Defina tipagem dinâmica: tipos de dados são determinados em tempo de execução, não em tempo de compilação.",
                                    "Explique flexibilidade: capacidade de atribuir diferentes tipos a uma mesma variável sem declaração prévia.",
                                    "Exemplo básico em Python: declare uma variável como inteiro e reatribua como string.",
                                    "Compare brevemente com tipagem estática para contextualizar diferenças iniciais.",
                                    "Registre em um diagrama mental ou nota as características principais."
                                  ],
                                  "verification": "Escreva uma definição clara e um exemplo de código funcional sem erros de sintaxe.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código como VS Code ou Jupyter Notebook",
                                    "Documentação oficial do Python sobre tipos"
                                  ],
                                  "tips": "Use variáveis simples para testar atribuições múltiplas e observe o comportamento no interpretador.",
                                  "learningObjective": "Dominar a definição e exemplos básicos de flexibilidade na tipagem dinâmica.",
                                  "commonMistakes": [
                                    "Confundir flexibilidade com ausência de tipos",
                                    "Usar linguagens estáticas como exemplo",
                                    "Ignorar o impacto em tempo de execução"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e discutir vantagens da flexibilidade",
                                  "subSteps": [
                                    "Liste vantagens principais: adaptação rápida a mudanças em objetos dinâmicos e prototipagem ágil.",
                                    "Exemplo prático: desenvolva um script que mude o tipo de uma variável para processar dados variados (números ou textos).",
                                    "Discuta benefícios: código mais conciso, maior expressividade e suporte a polimorfismo dinâmico.",
                                    "Registre 3 cenários reais onde isso acelera o desenvolvimento.",
                                    "Avalie quantitativamente: compare linhas de código com equivalente em tipagem estática."
                                  ],
                                  "verification": "Crie um código de exemplo demonstrando adaptação rápida e explique verbalmente ou por escrito os ganhos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python interpretador",
                                    "Exemplos de código de bibliotecas dinâmicas como Pandas"
                                  ],
                                  "tips": "Pense em cenários de dados heterogêneos, como entrada de usuário imprevisível.",
                                  "learningObjective": "Reconhecer e exemplificar as vantagens práticas da flexibilidade.",
                                  "commonMistakes": [
                                    "Superestimar velocidade sem considerar manutenção",
                                    "Ignorar contextos onde estática é melhor",
                                    "Listar vantagens genéricas sem exemplos concretos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar riscos e desvantagens da flexibilidade",
                                  "subSteps": [
                                    "Identifique riscos principais: erros detectados apenas em runtime, como TypeError em Python.",
                                    "Simule um erro: escreva código que cause TypeError ao chamar método incompatível em variável reatribuída.",
                                    "Discuta impactos: depuração mais difícil, bugs sutis e menor segurança.",
                                    "Liste 3 exemplos comuns de erros runtime em projetos reais.",
                                    "Meça o custo: tempo gasto em debugging vs verificação estática."
                                  ],
                                  "verification": "Execute código com erro intencional, identifique o TypeError e corrija, documentando o processo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor com debugger",
                                    "Documentação de exceções Python"
                                  ],
                                  "tips": "Use print statements ou debugger para rastrear onde o erro ocorre em runtime.",
                                  "learningObjective": "Identificar e demonstrar riscos específicos da tipagem dinâmica.",
                                  "commonMistakes": [
                                    "Minimizar riscos achando que 'testes resolvem tudo'",
                                    "Confundir erros de sintaxe com runtime",
                                    "Não simular erros reais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com tipagem estática e sintetizar análise",
                                  "subSteps": [
                                    "Compare lado a lado: crie tabelas de prós/contras de flexibilidade dinâmica vs estática (ex: TypeScript).",
                                    "Avalie trade-offs: quando escolher cada uma com base em contexto de projeto.",
                                    "Sintetize: escreva um parágrafo equilibrado sobre vantagens e riscos.",
                                    "Teste em mini-projeto: adapte um código estático para dinâmico e vice-versa.",
                                    "Conclua com recomendação pessoal para cenários comuns."
                                  ],
                                  "verification": "Produza uma tabela comparativa e um resumo escrito de 200 palavras.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou Markdown para tabela",
                                    "Exemplos em TypeScript ou Java para estática"
                                  ],
                                  "tips": "Use critérios como tempo de desenvolvimento, manutenção e escalabilidade na comparação.",
                                  "learningObjective": "Realizar uma análise crítica comparativa para tomada de decisão informada.",
                                  "commonMistakes": [
                                    "Viés para uma tipagem sem evidências",
                                    "Comparação superficial sem exemplos",
                                    "Ignorar evoluções como type hints em Python"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: def processar_dados(x): return x * 2  # Vantagem: funciona para int ou str conciso. Mas risco: se x='abc', gera TypeError em runtime. Código: x=5; print(processar_dados(x))  # OK. x='abc'; print(processar_dados(x))  # Erro! Comparar com TypeScript: function processar(dado: number): number { return dado * 2; } // Erro em compile-time.",
                              "finalVerifications": [
                                "Pode listar e exemplificar pelo menos 3 vantagens da flexibilidade?",
                                "Simula e corrige um erro runtime como TypeError?",
                                "Cria uma tabela comparativa clara entre dinâmica e estática?",
                                "Explica trade-offs em um cenário real de projeto?",
                                "Identifica quando evitar flexibilidade excessiva?",
                                "Documenta análise em parágrafo coerente?"
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas sem confusões (30%)",
                                "Exemplos práticos: códigos funcionais e com erros simulados (25%)",
                                "Análise equilibrada: prós e contras bem ponderados (20%)",
                                "Comparação profunda: uso de tabelas e cenários (15%)",
                                "Síntese crítica: recomendações contextuais (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de probabilidades de erros runtime vs compile-time",
                                "Negócios: Trade-offs de agilidade (prototipagem) vs confiabilidade em produtos",
                                "Física/Engenharia: Analogia com sistemas dinâmicos mutáveis vs estáveis",
                                "Língua Portuguesa: Argumentação e redação de análises comparativas",
                                "Ética: Responsabilidade em software crítico onde erros custam vidas"
                              ],
                              "realWorldApplication": "Em desenvolvimento ágil de startups, como scripts de automação em Python para análise de dados variáveis (ex: ETL em machine learning), onde protótipos rápidos superam rigidez inicial, mas com type hints para mitigar riscos em produção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.2",
                        "name": "Prototipagem rápida",
                        "description": "A tipagem dinâmica acelera a criação de protótipos ao eliminar verificações de tipo em tempo de compilação, permitindo foco na lógica de negócios e iterações ágeis em aplicações orientadas a objetos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.2.1",
                            "name": "Criar protótipos simples sem declaração de tipos",
                            "description": "Desenvolver um exemplo de classe em Python com métodos que manipulam variáveis de tipos variados, demonstrando velocidade na implementação inicial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a estrutura básica da classe sem tipos explícitos",
                                  "subSteps": [
                                    "Abra um editor de código Python como VS Code ou IDLE.",
                                    "Crie um novo arquivo .py e defina uma classe simples, por exemplo, 'Veiculo'.",
                                    "Implemente o método __init__ com parâmetros variados como nome (str), velocidade (int/float), ligado (bool).",
                                    "Adicione atributos de instância diretamente nos parâmetros sem anotações de tipo.",
                                    "Salve o arquivo."
                                  ],
                                  "verification": "Execute o código e instancie a classe; verifique se não há erros de sintaxe e os atributos são atribuídos corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Editor de texto (VS Code), interpretador Python 3.x",
                                  "tips": "Use nomes descritivos para atributos para compensar a ausência de tipos.",
                                  "learningObjective": "Entender como Python permite criar classes funcionais sem declarações de tipo, acelerando a prototipagem.",
                                  "commonMistakes": "Esquecer dois underscores em __init__; usar palavras reservadas como nomes de atributos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Adicionar métodos que manipulam variáveis de tipos variados",
                                  "subSteps": [
                                    "Adicione um método 'acelerar' que receba um valor numérico (int ou float) e some à velocidade.",
                                    "Crie um método 'status' que retorne uma string combinando nome, velocidade e estado ligado.",
                                    "Implemente um método 'alternar_ligado' que inverta o booleano 'ligado' e imprima uma mensagem.",
                                    "Adicione um método 'info' que aceite um dicionário de specs extras e os imprima.",
                                    "Teste cada método individualmente no código."
                                  ],
                                  "verification": "Chame os métodos em uma instância; confirme que manipulam str, int/float, bool e dict sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Mesmo editor e Python REPL para testes rápidos",
                                  "tips": "Use print() temporários para depurar valores durante a prototipagem.",
                                  "learningObjective": "Demonstrar flexibilidade da tipagem dinâmica ao lidar com múltiplos tipos em métodos sem verificações prévias.",
                                  "commonMistakes": "Não tratar casos onde velocidade pode ser float vs int; esquecer return em métodos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Instanciar a classe e executar testes básicos",
                                  "subSteps": [
                                    "Crie 2-3 instâncias da classe com dados de tipos mistos (ex: str, int, float, bool).",
                                    "Chame métodos em cada instância, passando argumentos variados.",
                                    "Adicione prints ou asserts simples para verificar saídas esperadas.",
                                    "Execute o script completo e observe o comportamento.",
                                    "Registre o tempo total gasto na implementação."
                                  ],
                                  "verification": "O script roda sem TypeErrors; saídas mostram manipulação correta de tipos variados.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Terminal ou REPL Python para execução",
                                  "tips": "Use valores extremos (ex: velocidade negativa) para testar robustez inicial.",
                                  "learningObjective": "Validar que o protótipo é funcional e rápido de implementar, destacando benefícios da tipagem dinâmica.",
                                  "commonMistakes": "Passar argumentos incompatíveis sem notar (mas isso é intencional na prototipagem rápida)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Refinar o protótipo e documentar vantagens da abordagem",
                                  "subSteps": [
                                    "Adicione um método extra para simular uso real, como 'viajar' que usa todos os atributos.",
                                    "Comente o código destacando onde tipos não foram declarados.",
                                    "Compare mentalmente com uma versão tipada estática (ex: TypeScript) notando linhas extras evitadas.",
                                    "Salve uma versão 'prototipo_v1.py' e anote tempo total.",
                                    "Planeje próximas iterações (ex: adicionar type hints depois)."
                                  ],
                                  "verification": "Código comentado roda perfeitamente; tempo total < 45 minutos comprova rapidez.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Editor com suporte a comentários",
                                  "tips": "Mantenha o código 'sucio' intencionalmente para priorizar velocidade sobre perfeição.",
                                  "learningObjective": "Reconhecer quando e por que usar prototipagem sem tipos para MVP (Minimum Viable Product).",
                                  "commonMistakes": "Gastar tempo refatorando prematuramente em vez de validar a ideia."
                                }
                              ],
                              "practicalExample": "Crie uma classe Veiculo:\nclass Veiculo:\n    def __init__(self, nome, velocidade=0, ligado=False):\n        self.nome = nome\n        self.velocidade = velocidade\n        self.ligado = ligado\n    def acelerar(self, incremento):\n        if self.ligado:\n            self.velocidade += incremento\n    def status(self):\n        return f'{self.nome}: {self.velocidade} km/h, Ligado: {self.ligado}'\n\nv1 = Veiculo('Fusca', 50, True)\nv1.acelerar(30.5)\nprint(v1.status())  # Fusca: 80.5 km/h, Ligado: True",
                              "finalVerifications": [
                                "Código executa sem erros de sintaxe ou runtime inesperados.",
                                "Métodos manipulam str, int, float e bool corretamente.",
                                "Instâncias múltiplas funcionam independentemente.",
                                "Tempo total de implementação é inferior a 45 minutos.",
                                "Saídas dos prints/status refletem mudanças dinâmicas.",
                                "Nenhuma declaração de tipo (ex: : str) está presente."
                              ],
                              "assessmentCriteria": [
                                "Velocidade de implementação demonstrada (código curto e funcional).",
                                "Variedade de tipos manipulados nos métodos (pelo menos 4 tipos).",
                                "Clareza e legibilidade do código apesar da ausência de types.",
                                "Funcionalidade completa dos métodos testados.",
                                "Comentários ou prints que validam o comportamento dinâmico.",
                                "Ausência de boilerplate desnecessário para protótipo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações aritméticas com int/float em métodos como acelerar.",
                                "Design de Produto: Prototipagem rápida similar a wireframes em UX/UI.",
                                "Lógica e Algoritmos: Fluxo condicional em métodos sem rigidez de tipos.",
                                "Empreendedorismo: Criação de MVP para validar ideias de negócio."
                              ],
                              "realWorldApplication": "Em hackathons ou startups, desenvolvedores usam Python sem type hints para criar protótipos de apps (ex: dashboard de veículos) em horas, validando features com stakeholders antes de adicionar type checking com mypy ou dataclass para produção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.2",
                            "name": "Iterar código rapidamente com duck typing",
                            "description": "Aplicar o conceito de 'duck typing' (se parece e funciona como um pato, é um pato) para refatorar protótipos, alterando comportamentos sem alterar assinaturas de métodos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Duck Typing",
                                  "subSteps": [
                                    "Leia a definição: 'Se quack como um pato e anda como um pato, então é um pato'.",
                                    "Compare com tipagem estática: Duck typing verifica comportamento em runtime, não tipos declarados.",
                                    "Estude exemplos simples em Python, como funções que aceitam qualquer objeto com método específico (ex: len() para qualquer com __len__).",
                                    "Analise código fonte de bibliotecas como collections.abc para ver duck typing implícito.",
                                    "Discuta vantagens: flexibilidade em protótipos e polimorfismo sem herança."
                                  ],
                                  "verification": "Escreva um parágrafo explicando duck typing e dê 2 exemplos de código que falhariam sem ele.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Python: duck typing",
                                    "Exemplos de código em repl.it ou Jupyter Notebook"
                                  ],
                                  "tips": "Foquem em 'comportamento sobre tipo'; ignore hierarquias de classes desnecessárias.",
                                  "learningObjective": "Explicar duck typing e suas diferenças com tipagem estática.",
                                  "commonMistakes": [
                                    "Confundir com herança",
                                    "Assumir necessidade de interfaces explícitas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Oportunidades de Duck Typing em Código Existente",
                                  "subSteps": [
                                    "Revise um protótipo com herança rígida ou type checks (ex: isinstance()).",
                                    "Marque métodos com assinaturas idênticas em classes diferentes.",
                                    "Remova checagens de tipo desnecessárias e teste se o código ainda funciona.",
                                    "Registre pontos onde duck typing acelera iterações (ex: adicionar nova classe sem mudar chamadores).",
                                    "Crie um diagrama mostrando 'antes' (herança) vs 'depois' (duck typing)."
                                  ],
                                  "verification": "Liste 3 locais no código onde duck typing pode substituir herança, com justificativa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código protótipo de exemplo (ex: sistema de formas geométricas)",
                                    "Editor de código como VS Code"
                                  ],
                                  "tips": "Procure por 'if isinstance(obj, SpecificClass)' – candidato perfeito para remoção.",
                                  "learningObjective": "Detectar padrões rígidos que duck typing pode simplificar.",
                                  "commonMistakes": [
                                    "Remover type hints úteis",
                                    "Ignorar erros runtime potenciais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Refatorar Protótipo Usando Duck Typing",
                                  "subSteps": [
                                    "Escolha uma função genérica que dependa de métodos comuns (ex: def process(item): item.update() ).",
                                    "Crie classes 'duck-like' com os métodos necessários, sem herança comum.",
                                    "Altere o protótipo para usar a função genérica sem checagens de tipo.",
                                    "Execute testes unitários para validar comportamentos equivalentes.",
                                    "Meça tempo de refatoração vs versão original."
                                  ],
                                  "verification": "Rode o código refatorado com 3 classes diferentes e confirme saída idêntica à original.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python interpreter",
                                    "Biblioteca unittest ou pytest",
                                    "Código base fornecido"
                                  ],
                                  "tips": "Mantenha assinaturas de métodos idênticas para compatibilidade.",
                                  "learningObjective": "Implementar refatoração que preserva comportamento alterando estrutura.",
                                  "commonMistakes": [
                                    "Mudar assinaturas de métodos",
                                    "Adicionar type checks desnecessários"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Iterar e Otimizar com Duck Typing",
                                  "subSteps": [
                                    "Adicione uma nova 'classe duck' ao protótipo sem tocar código existente.",
                                    "Monitore performance e erros runtime; ajuste métodos conforme necessário.",
                                    "Refatore iterativamente: teste, quebrar, consertar em ciclos rápidos.",
                                    "Compare ciclos de iteração com versão tipada estaticamente.",
                                    "Documente lições aprendidas em um log de refatoração."
                                  ],
                                  "verification": "Adicione 2 novas classes e confirme que o sistema funciona sem modificações adicionais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmos do step 3",
                                    "Timer para medir ciclos de iteração"
                                  ],
                                  "tips": "Use TDD (Test-Driven Development) para iterações seguras.",
                                  "learningObjective": "Demonstrar iteração rápida via flexibilidade do duck typing.",
                                  "commonMistakes": [
                                    "Sobre-generalizar levando a erros runtime obscuros",
                                    "Perder rastreabilidade de bugs"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um protótipo de sistema de veículos: def drive(vehicle): vehicle.start_engine(); vehicle.accelerate(). Crie classes Car, Bike e Drone com start_engine() e accelerate(), sem herança comum. Adicione FlyingCar instantaneamente sem mudar drive().",
                              "finalVerifications": [
                                "Refatore código dado usando duck typing em <10 minutos.",
                                "Explique por que duck typing acelera prototipagem.",
                                "Identifique e corrija um erro runtime causado por duck typing inadequado.",
                                "Crie uma função genérica que aceite 3 tipos 'duck' diferentes.",
                                "Compare linhas de código antes/depois da refatoração."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de oportunidades de duck typing (80%+ cobertura).",
                                "Código refatorado mantém 100% dos testes passando.",
                                "Tempo de iteração reduzido em pelo menos 50% vs herança.",
                                "Explicação clara de trade-offs (flexibilidade vs segurança runtime).",
                                "Uso correto de subSteps sem alterar assinaturas.",
                                "Documentação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Agile/Scrum: Iterações rápidas em sprints de prototipagem.",
                                "Design Patterns: Relaciona com Strategy e Adapter sem herança.",
                                "Matemática: Abstrações funcionais semelhantes a polimorfismo paramétrico.",
                                "Engenharia de Software: Princípio 'Interface Segregation' via duck typing."
                              ],
                              "realWorldApplication": "Em data science com Pandas/NumPy, onde DataFrames duck type para iteráveis, permitindo protótipos rápidos de pipelines sem definir interfaces rígidas; ou em web dev com Flask/Django middleware que aceita handlers com métodos específicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.3",
                            "name": "Comparar tempo de desenvolvimento com tipagem estática",
                            "description": "Simular a criação de um protótipo de objeto em Python (dinâmica) versus C++ (estática), medindo redução no tempo e linhas de código.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambientes de desenvolvimento e revisar conceitos de tipagem",
                                  "subSteps": [
                                    "Instalar Python e um IDE como VS Code ou PyCharm.",
                                    "Instalar um compilador C++ como g++ e um IDE como Code::Blocks ou Visual Studio.",
                                    "Revisar diferenças chave: tipagem dinâmica (Python: sem declaração de tipos) vs. estática (C++: declaração explícita).",
                                    "Definir um protótipo simples: classe 'Carro' com atributos (marca, modelo, ano) e métodos (acelerar, frear).",
                                    "Preparar cronômetro e ferramenta de contagem de linhas (ex: wc -l no terminal)."
                                  ],
                                  "verification": "Ambientes instalados e funcionando; esboço do protótipo documentado em um arquivo README.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Computador com internet; Python 3.x; g++ ou Visual Studio; IDEs; cronômetro.",
                                  "tips": "Use ambientes virtuais no Python (venv) para isolar dependências.",
                                  "learningObjective": "Compreender e preparar ferramentas para comparação prática de tipagem.",
                                  "commonMistakes": "Ignorar instalação de compiladores C++; escolher protótipo muito complexo inicialmente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar protótipo em Python (tipagem dinâmica)",
                                  "subSteps": [
                                    "Criar classe Carro: def __init__(self, marca, modelo, ano): self.marca = marca, etc.",
                                    "Adicionar métodos simples: def acelerar(self): print('Acelerando...')",
                                    "Criar instância e testar: carro = Carro('Toyota', 'Corolla', 2020); carro.acelerar().",
                                    "Medir tempo total de codificação com cronômetro.",
                                    "Contar linhas de código relevantes (excluindo imports e testes)."
                                  ],
                                  "verification": "Código Python executável sem erros; tempo e linhas registradas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor Python; terminal para execução.",
                                  "tips": "Escreva código minimalista para destacar rapidez da tipagem dinâmica.",
                                  "learningObjective": "Experenciar prototipagem rápida sem declarações de tipo.",
                                  "commonMistakes": "Incluir lógica desnecessária que infla linhas; não cronometrar apenas codificação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o mesmo protótipo em C++ (tipagem estática)",
                                  "subSteps": [
                                    "Criar header carro.h: class Carro { private: string marca; int ano; public: Carro(string m, string mod, int a); void acelerar(); };",
                                    "Implementar em carro.cpp: construtor e métodos com #include <string>, usando std::string.",
                                    "Criar main.cpp: Carro c(\"Toyota\", \"Corolla\", 2020); c.acelerar();",
                                    "Compilar e executar: g++ *.cpp -o carro.",
                                    "Medir tempo de codificação e contar linhas (header + cpp)."
                                  ],
                                  "verification": "Programa C++ compila e executa corretamente; métricas registradas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Compilador C++; editor com suporte a C++.",
                                  "tips": "Use namespaces e includes mínimos; declare tipos explicitamente para simular rigidez.",
                                  "learningObjective": "Identificar overhead de tipagem estática em declarações e compilação.",
                                  "commonMistakes": "Erros de sintaxe por esquecer ; ou tipos; subestimar tempo de depuração."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Medir, comparar e analisar resultados",
                                  "subSteps": [
                                    "Tabular dados: Tempo Python vs. C++ (em minutos); Linhas de código Python vs. C++.",
                                    "Calcular reduções percentuais: (tempo_C++ - tempo_Python)/tempo_C++ * 100%.",
                                    "Executar testes funcionais idênticos em ambos para validar equivalência.",
                                    "Documentar observações qualitativas: facilidade de mudanças, erros de tipo.",
                                    "Gráfico simples (ex: Excel ou matplotlib) comparando métricas."
                                  ],
                                  "verification": "Tabela de comparação completa com cálculos; gráficos gerados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilha (Google Sheets/Excel); Python para gráficos opcionais.",
                                  "tips": "Registre múltiplas rodadas para média precisa.",
                                  "learningObjective": "Quantificar vantagens da tipagem dinâmica em prototipagem.",
                                  "commonMistakes": "Comparar funcionalidades desiguais; ignorar tempo de compilação no C++."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Concluir e refletir sobre implicações",
                                  "subSteps": [
                                    "Resumir achados: Python tipicamente 2-3x mais rápido e 50% menos linhas.",
                                    "Discutir cenários: Python para MVPs, C++ para produção.",
                                    "Refatorar um método em ambos e re-medir tempo de mudança.",
                                    "Escrever relatório curto com lições aprendidas.",
                                    "Compartilhar código em GitHub para revisão."
                                  ],
                                  "verification": "Relatório final escrito; repositório com códigos e dados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "GitHub ou documento compartilhável.",
                                  "tips": "Foque em generalizações além do exemplo específico.",
                                  "learningObjective": "Aplicar insights para escolhas de linguagem em projetos reais.",
                                  "commonMistakes": "Generalizar excessivamente sem considerar performance em runtime."
                                }
                              ],
                              "practicalExample": "Desenvolva uma classe 'Carro' com atributos marca, modelo, ano e métodos acelerar() e frear(). Em Python: ~15 linhas, 10min. Em C++: ~40 linhas (header+cpp), 40min. Redução: 60% menos tempo/linhas, destacando prototipagem rápida.",
                              "finalVerifications": [
                                "Protótipos em Python e C++ funcionam identicamente.",
                                "Tempos e linhas medidos com precisão (média de 3 tentativas).",
                                "Reduções percentuais calculadas corretamente.",
                                "Testes unitários básicos passam em ambos.",
                                "Relatório inclui análise qualitativa e quantitativa.",
                                "Códigos versionados em repositório."
                              ],
                              "assessmentCriteria": [
                                "Precisão das medições de tempo e linhas (erro <10%).",
                                "Equivalência funcional entre implementações.",
                                "Análise profunda das diferenças de tipagem.",
                                "Uso correto de ferramentas e ambientes.",
                                "Clareza no relatório e visualizações.",
                                "Reflexão sobre trade-offs (rapidez vs. segurança)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculos percentuais e estatísticas descritivas.",
                                "Inglês: Documentação técnica e relatório em inglês.",
                                "Física/Engenharia: Modelagem de objetos reais (ex: carro).",
                                "Gestão de Projetos: Métricas de produtividade em desenvolvimento."
                              ],
                              "realWorldApplication": "Em startups e hackathons, usar Python para protótipos rápidos de MVPs (Minimum Viable Products), validando ideias antes de reescrever em C++ para performance em produção, reduzindo time-to-market em semanas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.3",
                        "name": "Menor verbosidade na declaração de tipos",
                        "description": "Linguagens de tipagem dinâmica reduzem a quantidade de código necessário para declarar tipos, tornando o código mais conciso e legível, especialmente em estruturas orientadas a objetos como classes e métodos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.3.1",
                            "name": "Escrever classes sem anotações de tipo explícitas",
                            "description": "Definir uma classe Python com atributos e métodos sem usar type hints ou declarações explícitas, contrastando com linguagens como Java.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a estrutura básica de uma classe Python sem type hints",
                                  "subSteps": [
                                    "Abra um editor de código ou IDE com suporte a Python.",
                                    "Escreva 'class NomeDaClasse:' usando PascalCase para o nome da classe.",
                                    "Adicione indentação e a palavra 'pass' no corpo da classe para torná-la válida.",
                                    "Salve o arquivo com extensão .py e execute para verificar sintaxe."
                                  ],
                                  "verification": "O interpretador Python carrega o módulo sem erros de sintaxe e a classe é reconhecida via dir().",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Python 3.x instalado",
                                    "Editor de texto ou IDE (VS Code, PyCharm)"
                                  ],
                                  "tips": "Escolha nomes descritivos como 'Pessoa' ou 'Carro' para facilitar compreensão.",
                                  "learningObjective": "Dominar a sintaxe mínima de declaração de classe em Python sem qualquer anotação de tipo.",
                                  "commonMistakes": "Esquecer os dois pontos após o nome da classe ou adicionar type hints desnecessários como 'class Pessoa(str):'."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o construtor __init__ com atributos dinâmicos",
                                  "subSteps": [
                                    "Defina o método '__init__(self, param1, param2):' sem type hints nos parâmetros.",
                                    "Dentro do __init__, atribua atributos de instância: 'self.param1 = param1'.",
                                    "Evite declarações explícitas de tipos nos atributos.",
                                    "Teste instanciando: obj = NomeDaClasse('valor1', 'valor2') e acesse obj.param1.",
                                    "Execute e imprima os atributos para confirmação."
                                  ],
                                  "verification": "Instância é criada com sucesso e atributos são acessíveis via notação ponto sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python 3.x instalado",
                                    "Editor de texto ou IDE",
                                    "Terminal para execução"
                                  ],
                                  "tips": "Use 'self' consistentemente para referenciar atributos de instância.",
                                  "learningObjective": "Aprender a inicializar atributos dinamicamente sem especificar tipos, destacando a flexibilidade da tipagem dinâmica.",
                                  "commonMistakes": "Adicionar type hints como 'def __init__(self, nome: str)' ou esquecer 'self' nos atributos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar métodos de instância sem anotações de tipo",
                                  "subSteps": [
                                    "Defina um método como 'def metodo(self): print(self.param1)'.",
                                    "Inclua lógica que use atributos sem retornar tipos explícitos.",
                                    "Instancie a classe e chame o método: obj.metodo().",
                                    "Adicione um segundo método para complexidade, como um getter ou ação.",
                                    "Execute o código completo para testar interações."
                                  ],
                                  "verification": "Métodos são chamados em instâncias sem erros e produzem saída esperada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python 3.x instalado",
                                    "Editor de texto ou IDE",
                                    "Terminal para execução"
                                  ],
                                  "tips": "Mantenha métodos curtos e focados em uma responsabilidade para clareza.",
                                  "learningObjective": "Implementar comportamento em classes usando apenas duck typing, sem restrições de tipo.",
                                  "commonMistakes": "Usar '-> str' no retorno do método ou declarar parâmetros com tipos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar a classe completa e contrastar com linguagens estáticas como Java",
                                  "subSteps": [
                                    "Crie múltiplas instâncias com valores diferentes.",
                                    "Acesse e modifique atributos dinamicamente: obj.novo_attr = 'valor'.",
                                    "Compare código Python com equivalente Java (mentalmente ou escrito): note ausência de 'private String nome;'.",
                                    "Execute testes abrangentes e verifique ausência total de type hints.",
                                    "Documente uma frase explicando a menor verbosidade."
                                  ],
                                  "verification": "Código roda sem erros, atributos dinâmicos funcionam e contraste com Java é explicitado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3.x instalado",
                                    "Editor de texto ou IDE",
                                    "Referência rápida de sintaxe Java (opcional)"
                                  ],
                                  "tips": "Demonstre dinamismo adicionando atributos pós-instanciação para reforçar tipagem dinâmica.",
                                  "learningObjective": "Consolidar o conceito de menor verbosidade comparando com tipagem estática.",
                                  "commonMistakes": "Introduzir type hints durante testes ou confundir sintaxe com Java (ex: declarar variáveis fora de métodos)."
                                }
                              ],
                              "practicalExample": "```python\nclass Carro:\n    def __init__(self, marca, modelo):\n        self.marca = marca\n        self.modelo = modelo\n        self.combustivel = 100\n    \n    def dirigir(self, distancia):\n        self.combustivel -= distancia / 10\n        print(f'{self.marca} {self.modelo} dirigiu {distancia}km. Combustível restante: {self.combustivel}L')\n    \n    def abastecer(self, litros):\n        self.combustivel += litros\n\n# Uso\nmeu_carro = Carro('Toyota', 'Corolla')\nmeu_carro.dirigir(50)\nmeu_carro.abastecer(20)\nmeu_carro.nova_cor = 'azul'  # Dinâmico!\nprint(meu_carro.nova_cor)\n```",
                              "finalVerifications": [
                                "Nenhuma anotação de tipo (: tipo ou -> tipo) aparece no código da classe.",
                                "Instâncias são criadas e métodos executados sem erros de runtime.",
                                "Atributos podem ser adicionados dinamicamente pós-instanciação.",
                                "Código demonstra menor verbosidade em comparação a Java.",
                                "Saída dos métodos reflete valores corretos dos atributos.",
                                "Classe funciona com argumentos variados sem falhas."
                              ],
                              "assessmentCriteria": [
                                "Código da classe é executável e livre de type hints.",
                                "Implementação inclui __init__ e pelo menos dois métodos funcionais.",
                                "Demonstração clara de uso com múltiplas instâncias.",
                                "Explicação correta do contraste com tipagem estática (ex: Java).",
                                "Código é limpo, indentado corretamente e sem erros comuns.",
                                "Atributos dinâmicos são acessados e modificados com sucesso."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de objetos com atributos variáveis como em equações paramétricas.",
                                "Linguagens: Analogia com gramática flexível vs. regras estritas de sintaxe formal.",
                                "Design/Engenharia: Prototipagem rápida similar a esboços iniciais de projetos.",
                                "Ciências: Simulação de entidades biológicas sem especificações genéticas fixas."
                              ],
                              "realWorldApplication": "Essa técnica é essencial em protótipos rápidos, scripts de automação (ex: web scraping com BeautifulSoup), análise de dados em Jupyter Notebooks e desenvolvimento ágil onde a inferência dinâmica acelera iterações, comum em startups e data science."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.3.2",
                            "name": "Comparar verbosidade entre linguagens",
                            "description": "Analisar exemplos paralelos: declaração de uma lista de objetos em Python ('lista = []') versus C++ ('std::vector<MeuObjeto*> lista;'), destacando economia de código.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a sintaxe básica de declarações de coleções em Python e C++",
                                  "subSteps": [
                                    "Estude a declaração de lista vazia em Python: lista = []",
                                    "Revise a declaração de vector em C++: std::vector<MeuObjeto*> lista;",
                                    "Identifique diferenças iniciais: Python não requer tipo explícito, C++ sim.",
                                    "Compare importações: Python não precisa de includes para listas básicas, C++ requer #include <vector>."
                                  ],
                                  "verification": "Escreva exemplos corretos de declarações vazias em ambas linguagens sem erros de sintaxe.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Documentação oficial Python e C++ (cppreference.com)"
                                  ],
                                  "tips": "Use um compilador online como Replit para testar C++ rapidamente.",
                                  "learningObjective": "Compreender as diferenças fundamentais na declaração de coleções dinâmicas.",
                                  "commonMistakes": "Esquecer ponteiro (*) em C++ para objetos ou confundir list com array."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar exemplos paralelos com objetos simples",
                                  "subSteps": [
                                    "Defina uma classe simples MeuObjeto em ambas linguagens (atributos nome e idade).",
                                    "Declare e inicialize uma lista/vector com 3 instâncias em Python: lista = [MeuObjeto('A', 20), ...]",
                                    "Faça o equivalente em C++: std::vector<MeuObjeto*> lista = {new MeuObjeto(\"A\", 20), ...};",
                                    "Conte o número de linhas/caracteres necessários para cada declaração."
                                  ],
                                  "verification": "Execute os códigos e confirme que as listas são criadas com dados corretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador C++ (g++ ou online)",
                                    "Interpretador Python"
                                  ],
                                  "tips": "Em C++, lembre-se de usar new para alocação dinâmica e delete depois.",
                                  "learningObjective": "Praticar declarações paralelas para destacar verbosidade.",
                                  "commonMistakes": "Não gerenciar memória em C++ (vazamentos) ou usar {} incorreto em inicialização."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar e quantificar a verbosidade",
                                  "subSteps": [
                                    "Meça linhas de código: Python tipicamente 1-2 linhas vs C++ 4-6 linhas.",
                                    "Conte caracteres/tokens: Note ausência de tipos, ponteiros e includes em Python.",
                                    "Identifique elementos verbosos em C++: namespaces (std::), templates (<MeuObjeto*>), alocação (new).",
                                    "Crie uma tabela comparativa: coluna Linguagem, Linhas, Caracteres, Elementos Explícitos."
                                  ],
                                  "verification": "Produza uma tabela que mostre Python com ~50% menos código que C++ para o mesmo resultado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha (Google Sheets) ou papel para tabela",
                                    "Códigos dos passos anteriores"
                                  ],
                                  "tips": "Ignore formatação; foque em código essencial para comparação justa.",
                                  "learningObjective": "Desenvolver habilidade em quantificar economia de código.",
                                  "commonMistakes": "Incluir código desnecessário como main() na contagem de declaração pura."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir implicações da menor verbosidade na tipagem dinâmica",
                                  "subSteps": [
                                    "Explique como tipagem dinâmica reduz boilerplate em protótipos rápidos.",
                                    "Compare cenários: Python ideal para scripts, C++ para performance crítica.",
                                    "Avalie trade-offs: verbosidade em C++ traz segurança de tipos vs flexibilidade Python.",
                                    "Reflita: Quando priorizar economia vs precisão de tipos."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo vantagens da verbosidade menor em contextos reais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Notas dos passos anteriores"
                                  ],
                                  "tips": "Pense em produtividade: tempo de desenvolvimento vs tempo de execução.",
                                  "learningObjective": "Conectar verbosidade a escolhas de linguagem no mundo real.",
                                  "commonMistakes": "Ignorar desvantagens da tipagem dinâmica como erros em runtime."
                                }
                              ],
                              "practicalExample": "Em Python: class Objeto: def __init__(self, nome): self.nome = nome; objs = [Objeto('A'), Objeto('B')]; print([o.nome for o in objs]). Em C++: #include <vector> #include <string>; class Objeto { public: std::string nome; }; int main() { std::vector<Objeto*> objs; objs.push_back(new Objeto{\"A\"}); objs.push_back(new Objeto{\"B\"}); // print loop; for(auto* o : objs) delete o; }. Python: 4 linhas essenciais; C++: 12+ linhas.",
                              "finalVerifications": [
                                "Pode declarar lista de objetos em Python e C++ corretamente.",
                                "Identifica pelo menos 3 elementos que aumentam verbosidade em C++.",
                                "Quantifica economia: Python usa <60% dos caracteres de C++.",
                                "Explica trade-off entre verbosidade e segurança de tipos.",
                                "Cria tabela comparativa precisa para novos exemplos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de código (erro <10%).",
                                "Correção sintática nos exemplos paralelos.",
                                "Profundidade na análise de implicações (cobre produtividade e performance).",
                                "Clareza na tabela comparativa (legível e quantitativa).",
                                "Capacidade de generalizar para outras estruturas (ex: dicionários vs maps).",
                                "Identificação correta de erros comuns em cada linguagem."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise quantitativa (contagem de tokens/linhas).",
                                "Linguística: Comparação sintática como análise gramatical.",
                                "Economia: Trade-offs custo-benefício (tempo dev vs runtime).",
                                "Design de Software: Princípios de legibilidade e DRY (Don't Repeat Yourself)."
                              ],
                              "realWorldApplication": "Em desenvolvimento ágil, Python permite protótipos 2x mais rápidos que C++, ideal para data science ou web apps iniciais; C++ é usado em games/embedded onde performance supera verbosidade, como engines Unity (C# similar)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.3.3",
                            "name": "Otimizar código para legibilidade",
                            "description": "Refatorar código verboso de tipagem estática para versão dinâmica, avaliando impacto na manutenibilidade em projetos POO.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o código original de tipagem estática",
                                  "subSteps": [
                                    "Examine todas as declarações de variáveis, parâmetros e retornos com anotações de tipo explícitas",
                                    "Identifique seções verbosas causadas por tipos redundantes ou longos",
                                    "Mapeie a estrutura da classe POO, incluindo construtores, métodos e propriedades",
                                    "Execute o código em um ambiente compatível para validar funcionalidade atual",
                                    "Documente métricas iniciais de legibilidade, como linhas de código e densidade de tipos"
                                  ],
                                  "verification": "Criar um relatório com lista de pontos verbosos e métricas de legibilidade (ex: LOC - Lines of Code)",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código com suporte a tipagem estática (VS Code com TypeScript)",
                                    "Código fonte exemplo em TypeScript ou Java"
                                  ],
                                  "tips": "Use ferramentas como 'tslint' ou 'eslint' para destacar anotações de tipo",
                                  "learningObjective": "Compreender o impacto da verbosidade de tipos na legibilidade inicial do código POO",
                                  "commonMistakes": [
                                    "Subestimar verbosidade em métodos sobrecarregados",
                                    "Ignorar tipos implícitos ou inferidos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Planejar a refatoração para tipagem dinâmica",
                                  "subSteps": [
                                    "Liste todas as anotações de tipo a serem removidas (parâmetros, retornos, propriedades)",
                                    "Defina convenções de nomenclatura dinâmica para manter clareza sem tipos (ex: nomes descritivos)",
                                    "Planeje ajustes em construtores e métodos para inferência de tipos implícita",
                                    "Antecipe potenciais perdas de segurança de tipo e estratégias de mitigação (ex: JSDoc)",
                                    "Estime ganhos em legibilidade e impactos na manutenibilidade POO"
                                  ],
                                  "verification": "Documento de plano com lista de mudanças e trade-offs avaliados",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel ou ferramenta de diagramação (Draw.io)",
                                    "Referências de sintaxe dinâmica (docs Python/JS)"
                                  ],
                                  "tips": "Priorize nomes de variáveis autoexplicativos para compensar ausência de tipos",
                                  "learningObjective": "Planejar refatoração que equilibre legibilidade e manutenibilidade em POO dinâmica",
                                  "commonMistakes": [
                                    "Remover tipos sem planejar nomenclatura alternativa",
                                    "Superestimar segurança sem testes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a refatoração no código",
                                  "subSteps": [
                                    "Remova anotações de tipo de variáveis, parâmetros e retornos",
                                    "Ajuste construtores para inferência dinâmica de propriedades",
                                    "Refatore métodos para sintaxe limpa, adicionando JSDoc se necessário para documentação",
                                    "Teste unitariamente cada método refatorado",
                                    "Otimize formatação com linters para máxima legibilidade"
                                  ],
                                  "verification": "Código refatorado executa sem erros e passa em testes unitários",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ambiente de execução dinâmica (Node.js para JS ou Python interpreter)",
                                    "Ferramentas de teste (Jest ou unittest)",
                                    "Linter (ESLint ou Black)"
                                  ],
                                  "tips": "Use 'any' temporariamente em JS se inferência falhar, depois refine",
                                  "learningObjective": "Aplicar refatoração prática de estática para dinâmica otimizando legibilidade POO",
                                  "commonMistakes": [
                                    "Esquecer de testar encapsulamento POO após remoção de tipos",
                                    "Deixar código desformatado pós-refatoração"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar impacto na legibilidade e manutenibilidade",
                                  "subSteps": [
                                    "Compare métricas antes/depois (LOC, ciclomática, densidade de código)",
                                    "Avalie manutenibilidade: tempo estimado para adicionar feature nova",
                                    "Colete feedback simulado de 'revisão de código' em legibilidade",
                                    "Identifique riscos de erros runtime devido a dinâmica",
                                    "Documente lições aprendidas e recomendações para projetos POO"
                                  ],
                                  "verification": "Relatório final com métricas comparativas e avaliação qualitativa",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramentas de análise estática (SonarQube ou CodeClimate)",
                                    "Checklist de manutenibilidade POO"
                                  ],
                                  "tips": "Meça legibilidade com 'readability scores' de ferramentas como CodeReadability",
                                  "learningObjective": "Avaliar quantitativa e qualitativamente o trade-off estática vs dinâmica em POO",
                                  "commonMistakes": [
                                    "Ignorar impactos em equipes grandes",
                                    "Focar só em LOC sem considerar complexidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Código TypeScript verboso (estático):\nclass Employee {\n  private id: number;\n  private name: string;\n  constructor(id: number, name: string) {\n    this.id = id;\n    this.name = name;\n  }\n  getDetails(): string {\n    return `ID: ${this.id}, Name: ${this.name}`;\n  }\n}\n\nVersão JavaScript dinâmica otimizada:\nclass Employee {\n  constructor(id, name) {\n    this.id = id;\n    this.name = name;\n  }\n  getDetails() {\n    return `ID: ${this.id}, Name: ${this.name}`;\n  }\n}\nResultado: Redução de ~40% em verbosidade, maior legibilidade sem perda de POO.",
                              "finalVerifications": [
                                "Código refatorado executa identicamente ao original sem erros de runtime",
                                "Métricas mostram redução em LOC e densidade de tipos (>20%)",
                                "Adicionar nova propriedade leva menos tempo na versão dinâmica",
                                "Nenhum erro de tipo inferido causa falhas em cenários edge",
                                "Documentação (JSDoc) cobre pontos críticos de tipo"
                              ],
                              "assessmentCriteria": [
                                "Precisão na remoção de tipos sem quebrar funcionalidade (100%)",
                                "Melhoria mensurável em legibilidade (redução LOC 25-50%)",
                                "Avaliação equilibrada de trade-offs manutenibilidade (risco vs ganho)",
                                "Uso efetivo de nomenclatura e docs para clareza dinâmica",
                                "Testes cobrem 80%+ do código refatorado"
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Técnicas de refatoração e métricas de qualidade",
                                "Design de UX/UI: Legibilidade de código como analogia a interfaces intuitivas",
                                "Gestão de Projetos: Avaliação de trade-offs em produtividade vs segurança",
                                "Lógica Matemática: Inferência de tipos como raciocínio dedutivo"
                              ],
                              "realWorldApplication": "Em equipes de desenvolvimento ágil usando JavaScript/Node.js para apps web escaláveis, refatorar de TypeScript para JS puro acelera prototipagem e iterações, mantendo POO para grandes projetos como e-commerces (ex: Shopify scripts), onde legibilidade reduz tempo de onboarding de novos devs em 30%."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.5",
                    "name": "Diferenças entre Tipagem Estática e Dinâmica",
                    "description": "Comparação quanto a verificação de tipos, flexibilidade, desempenho e detecção de erros.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.5.1",
                        "name": "Verificação de Tipos",
                        "description": "Comparação do momento em que os tipos de dados são verificados: em tempo de compilação (tipagem estática) versus em tempo de execução (tipagem dinâmica).",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.1.1",
                            "name": "Identificar verificação em tipagem estática",
                            "description": "Explicar como linguagens de tipagem estática, como C++ e Java, verificam tipos durante a compilação, detectando erros de tipo antes da execução do programa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Tipagem Estática",
                                  "subSteps": [
                                    "Leia a definição: Tipagem estática verifica tipos de variáveis e expressões durante a compilação, antes da execução.",
                                    "Estude exemplos de linguagens: C++ declara 'int x;' e Java usa 'String s = \"hello\";'.",
                                    "Identifique o momento da verificação: Compilador checa compatibilidade de tipos em atribuições e operações.",
                                    "Anote benefícios: Detecta erros cedo, melhora performance e facilita manutenção.",
                                    "Revise fluxograma: Código fonte → Compilador (verifica tipos) → Executável."
                                  ],
                                  "verification": "Explique em suas palavras o que é tipagem estática e cite duas linguagens de exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial de Java ou C++",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Use analogia: compilador como professor corrigindo prova antes de entregar.",
                                  "learningObjective": "Definir tipagem estática e seu processo de verificação na compilação.",
                                  "commonMistakes": [
                                    "Confundir com verificação em runtime",
                                    "Achar que é só declaração de variáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Exemplos de Código Válido em Tipagem Estática",
                                  "subSteps": [
                                    "Escreva um código Java simples: 'int a = 5; double b = a; System.out.println(b);'.",
                                    "Compile e execute: Observe que compila sem erros devido a promoção implícita.",
                                    "Modifique para C++ equivalente: 'int a = 5; double b = a; cout << b;'.",
                                    "Identifique verificações: Compilador aprova conversão numérica segura.",
                                    "Registre o output e confirme ausência de erros de tipo."
                                  ],
                                  "verification": "Mostre código compilado com sucesso e explique por que passou na verificação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "JDK ou GCC instalado",
                                    "IDE como IntelliJ ou VS Code"
                                  ],
                                  "tips": "Compile com flags verbose para ver mensagens do compilador.",
                                  "learningObjective": "Reconhecer quando o compilador aprova tipos compatíveis.",
                                  "commonMistakes": [
                                    "Ignorar warnings como depreciações",
                                    "Confundir promoção com casting explícito"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e Corrigir Erros de Tipo na Compilação",
                                  "subSteps": [
                                    "Crie código com erro: Em Java, 'String s = 123;' ou em C++ 'string s = 123;'.",
                                    "Tente compilar: Anote a mensagem de erro exata (ex: 'incompatible types').",
                                    "Corrija: Use casting 'String s = String.valueOf(123);' ou concatenação.",
                                    "Teste variações: Atribuição inválida como 'int i = \"abc\";'.",
                                    "Compare erros: Liste 3 tipos comuns de falhas de verificação estática."
                                  ],
                                  "verification": "Demonstre código com erro, mensagem de compilação e correção funcional.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador Java/C++",
                                    "Referência de erros de tipo online"
                                  ],
                                  "tips": "Copie erros reais do compilador para prática autêntica.",
                                  "learningObjective": "Detectar e interpretar erros de tipo durante compilação.",
                                  "commonMistakes": [
                                    "Tentar executar sem compilar",
                                    "Confundir erros sintáticos com semânticos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com Tipagem Dinâmica e Sintetizar Conhecimento",
                                  "subSteps": [
                                    "Escreva código Python dinâmico: 's = 123; s = \"abc\"; print(s)'.",
                                    "Compare: Em Java/C++, isso falha na compilação; em Python, roda até uso.",
                                    "Crie tabela: Colunas para estática vs dinâmica, linhas para verificação, erros, performance.",
                                    "Simule cenário: Identifique onde estática previne bugs em um programa maior.",
                                    "Resuma: Liste 3 cenários onde identificação de verificação estática é crucial."
                                  ],
                                  "verification": "Apresente tabela comparativa e explique 2 vantagens da estática.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python instalado para contraste",
                                    "Planilha ou papel para tabela"
                                  ],
                                  "tips": "Pense em apps reais: Bancos não podem ter erros de tipo em runtime.",
                                  "learningObjective": "Diferenciar verificação estática de dinâmica e identificar seu valor.",
                                  "commonMistakes": [
                                    "Achar dinâmica 'melhor' por flexibilidade sem considerar riscos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema bancário Java, código 'double saldo = 1000.0; String transacao = saldo + \" transferida\";' compila e roda, mas 'int conta = \"12345\";' falha na compilação com 'incompatible types', prevenindo depósito inválido antes da execução.",
                              "finalVerifications": [
                                "Explicar processo de verificação estática sem erros.",
                                "Compilar código com erro de tipo e citar mensagem exata.",
                                "Corrigir 3 exemplos de incompatibilidade de tipos.",
                                "Comparar com Python: Identificar onde estática detecta o que dinâmica ignora.",
                                "Listar 2 benefícios em projetos reais.",
                                "Criar fluxograma de compilação com verificação de tipos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de verificações de compilação (90%+ acerto em exemplos).",
                                "Capacidade de interpretar mensagens de erro do compilador.",
                                "Correções de código funcionais e eficientes.",
                                "Comparação clara entre estática e dinâmica.",
                                "Exemplos práticos relevantes ao contexto OOB.",
                                "Uso correto de terminologia técnica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Tipos como conjuntos fechados com operações definidas.",
                                "Lógica: Verificação como prova de teoremas antes da aplicação.",
                                "Física/Engenharia: Detecção precoce de falhas como testes de material.",
                                "Inglês Técnico: Leitura de documentação de erros de compilador."
                              ],
                              "realWorldApplication": "Desenvolvedores usam isso em apps empresariais (ex: sistemas Java em bancos) para evitar crashes por tipos errados, reduzindo downtime e custos de debug em produção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.2",
                            "name": "Identificar verificação em tipagem dinâmica",
                            "description": "Descrever como linguagens de tipagem dinâmica, como Python, verificam tipos apenas em tempo de execução, permitindo duck typing e maior flexibilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos da Tipagem Dinâmica",
                                  "subSteps": [
                                    "Defina tipagem dinâmica como verificação de tipos em tempo de execução.",
                                    "Compare com tipagem estática, onde tipos são verificados em tempo de compilação.",
                                    "Liste linguagens exemplos: Python, JavaScript (dinâmica) vs Java, C# (estática).",
                                    "Explique a flexibilidade: variáveis podem mudar de tipo durante a execução.",
                                    "Discuta vantagens: código mais conciso e rápido para protótipos."
                                  ],
                                  "verification": "Escreva uma definição precisa e liste 2 exemplos de cada tipo de linguagem.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação oficial do Python (python.org), editor de texto como VS Code.",
                                  "tips": "Use analogias: tipagem dinâmica é como um ator que interpreta papéis variados sem contrato fixo.",
                                  "learningObjective": "Compreender o conceito básico e diferenças iniciais de tipagem dinâmica.",
                                  "commonMistakes": "Confundir com 'sem tipos' – lembre que tipos existem, mas são checados em runtime."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Verificação de Tipos em Tempo de Execução",
                                  "subSteps": [
                                    "Execute código Python simples atribuindo diferentes tipos a uma variável (int, str, list).",
                                    "Observe erros apenas ao usar funções incompatíveis, não na atribuição.",
                                    "Use isinstance() para checar tipos manualmente em runtime.",
                                    "Analise stack traces de TypeError para identificar verificações implícitas.",
                                    "Teste com funções que aceitam múltiplos tipos via sobrecarga implícita."
                                  ],
                                  "verification": "Execute 3 snippets de código e anote onde/por quê erros de tipo ocorrem.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python instalado (versão 3.8+), REPL interativo (IDLE ou Jupyter Notebook).",
                                  "tips": "Sempre rode o código: teoria sem execução não revela runtime checks.",
                                  "learningObjective": "Identificar quando e como o Python verifica tipos durante a execução.",
                                  "commonMistakes": "Achar que não há verificação – todo uso de operador/ função checa implicitamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar Duck Typing e sua Relação com Verificações Dinâmicas",
                                  "subSteps": [
                                    "Defina duck typing: 'Se anda como pato e quack como pato, é pato'.",
                                    "Escreva exemplo: função que chama .quack() sem checar tipo explicitamente.",
                                    "Crie classes customizadas que implementam métodos esperados sem herança.",
                                    "Teste falhas: objeto sem método necessário gera AttributeError em runtime.",
                                    "Compare com type hints opcionais (from typing import Any) para flexibilidade."
                                  ],
                                  "verification": "Implemente uma função duck-typed que aceite 2 objetos 'pato-like' e funcione.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor Python com linting (Pylance), exemplos de código online (Real Python).",
                                  "tips": "Foco no comportamento, não no nome da classe – isso é o cerne do duck typing.",
                                  "learningObjective": "Aplicar duck typing para entender verificações baseadas em uso, não declaração.",
                                  "commonMistakes": "Misturar com herança: duck typing ignora hierarquia de classes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Verificações em Código Real e Praticar Análise",
                                  "subSteps": [
                                    "Analise código existente: identifique linhas com potenciais runtime type checks.",
                                    "Adicione print(isinstance()) para visualizar verificações explícitas.",
                                    "Refatore código estático para dinâmico e observe mudanças em erros.",
                                    "Debugue cenários com tipos inesperados usando pdb ou breakpoints.",
                                    "Documente 3 verificações encontradas: onde, por quê e como identificar."
                                  ],
                                  "verification": "Anote e explique 3 verificações de tipo em um script de 20+ linhas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Scripts de exemplo (GitHub repos Python), debugger pdb.",
                                  "tips": "Procure TypeError/AttributeError – são assinaturas de runtime type checks.",
                                  "learningObjective": "Desenvolver habilidade de detectar verificações dinâmicas em código prático.",
                                  "commonMistakes": "Ignorar verificações implícitas em operadores como + (str vs int falha em runtime)."
                                }
                              ],
                              "practicalExample": "Em um script Python para processar dados: def process_item(item): return item.append('new')  # Aceita listas ou dicts com append-like, mas falha em str com AttributeError em runtime, exemplificando duck typing e verificação dinâmica.",
                              "finalVerifications": [
                                "Explicar corretamente 3 diferenças entre runtime e compile-time type checks.",
                                "Identificar duck typing em um código fornecido sem erros.",
                                "Executar e debugar um script com type mismatch dinâmico.",
                                "Listar 2 vantagens e 2 desvantagens da tipagem dinâmica.",
                                "Demonstrar uso de isinstance() para verificação explícita."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de runtime vs static checks (90% acerto).",
                                "Exemplos práticos corretos com código executável.",
                                "Explicação clara de duck typing sem confusão com herança.",
                                "Análise completa de erros comuns em cenários dinâmicos.",
                                "Uso adequado de ferramentas de debug para verificações."
                              ],
                              "crossCurricularConnections": [
                                "Lógica Matemática: Inferência baseada em propriedades observáveis (duck typing como axiomas).",
                                "Design de Software: Princípios SOLID (interface segregation via comportamento).",
                                "Análise de Dados: Flexibilidade em scripts Python para ETL dinâmicos.",
                                "Filosofia da Computação: Trade-offs entre rigidez e adaptabilidade."
                              ],
                              "realWorldApplication": "Em desenvolvimento web com Django/Flask, onde funções processam dados de usuário de tipos variados (JSON, forms), verificando tipos em runtime para flexibilidade em APIs REST dinâmicas, acelerando iterações em startups."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.3",
                            "name": "Comparar momentos de verificação",
                            "description": "Comparar as implicações da verificação em compile-time (estática) versus runtime (dinâmica) em termos de segurança e desenvolvimento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Verificação em Compile-Time (Estática)",
                                  "subSteps": [
                                    "Defina verificação estática: análise de código antes da execução pelo compilador.",
                                    "Identifique tipos de erros detectados: erros de tipo, sintaxe e referências indefinidas.",
                                    "Estude exemplos em linguagens como TypeScript ou Java: declarar variáveis com tipos explícitos.",
                                    "Analise o fluxo: código é rejeitado se falhar na compilação, impedindo execução.",
                                    "Compare com depuração manual: compilador automatiza checagem inicial."
                                  ],
                                  "verification": "Escreva um parágrafo explicando o processo e forneça um exemplo simples de código TypeScript que falha na compilação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de código (VS Code)",
                                    "Documentação TypeScript",
                                    "Compilador TypeScript (tsc)"
                                  ],
                                  "tips": "Use o compilador como um 'porteiro' que bloqueia código inválido antes de entrar em produção.",
                                  "learningObjective": "Compreender o mecanismo e benefícios iniciais da verificação estática.",
                                  "commonMistakes": [
                                    "Confundir com execução real do código",
                                    "Ignorar que nem todos os erros são pegos estaticamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Verificação em Runtime (Dinâmica)",
                                  "subSteps": [
                                    "Defina verificação dinâmica: análise durante a execução do programa.",
                                    "Identifique quando ocorre: ao atribuir valores ou chamar funções com tipos incompatíveis.",
                                    "Estude exemplos em JavaScript ou Python: passar string para função que espera número.",
                                    "Analise consequências: exceções ou erros em tempo de execução, como TypeError.",
                                    "Discuta flexibilidade: permite código mais dinâmico, mas com risco maior."
                                  ],
                                  "verification": "Execute um código JavaScript que gera erro em runtime e capture o erro com try-catch.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Node.js ou navegador",
                                    "Editor de código",
                                    "Documentação JavaScript erros de tipo"
                                  ],
                                  "tips": "Runtime é como um alarme que toca só quando o ladrão já entrou na casa.",
                                  "learningObjective": "Dominar o conceito e exemplos práticos de verificação dinâmica.",
                                  "commonMistakes": [
                                    "Achar que runtime é mais seguro por ser 'real'",
                                    "Subestimar custos de depuração tardia"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Implicações em Segurança",
                                  "subSteps": [
                                    "Liste vantagens estáticas: detecção precoce de vulnerabilidades como injeções de tipo inválido.",
                                    "Liste desvantagens dinâmicas: ataques exploram erros runtime não previstos.",
                                    "Analise cenários: em apps web, estática previne SQL injection via type safety.",
                                    "Discuta métricas: tempo médio para fixar bugs (compile-time: horas vs runtime: dias).",
                                    "Crie tabela comparativa: segurança (alta/baixa), cobertura de erros (parcial/total)."
                                  ],
                                  "verification": "Crie uma tabela comparando 3 riscos de segurança em cada abordagem.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilha ou Markdown para tabela",
                                    "Artigos sobre type safety em segurança"
                                  ],
                                  "tips": "Pense em segurança como camadas: estática é a primeira linha de defesa.",
                                  "learningObjective": "Avaliar trade-offs de segurança entre as abordagens.",
                                  "commonMistakes": [
                                    "Ignorar falsos positivos em estática",
                                    "Superestimar flexibilidade dinâmica em sistemas críticos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Implicações no Desenvolvimento",
                                  "subSteps": [
                                    "Avalie produtividade: estática acelera refatoração com autocompletar e renomeação segura.",
                                    "Discuta performance: dinâmica permite polimorfismo fácil, mas com overhead de checks.",
                                    "Analise manutenção: código estático é mais legível em equipes grandes.",
                                    "Compare ciclos de desenvolvimento: estática encurta iterações iniciais, dinâmica acelera protótipos.",
                                    "Sintetize: escolha baseada em contexto (ex: startup vs enterprise)."
                                  ],
                                  "verification": "Escreva um relatório curto (200 palavras) resumindo prós/contras no desenvolvimento.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ferramentas de IDE com suporte a tipos (IntelliSense)",
                                    "Exemplos de código de projetos open-source"
                                  ],
                                  "tips": "Considere o ciclo de vida do software: estática brilha em longo prazo.",
                                  "learningObjective": "Aplicar comparação prática ao fluxo de desenvolvimento.",
                                  "commonMistakes": [
                                    "Focar só em velocidade inicial, ignorando custo total de propriedade"
                                  ]
                                }
                              ],
                              "practicalExample": "Em TypeScript (estático): function soma(a: number, b: number): number { return a + b; } – Chamar soma('1', 2) falha na compilação. Em JavaScript (dinâmico): function soma(a, b) { return a + b; } – Executa como '12' ou lança TypeError se não concatenável, revelando bug só em runtime.",
                              "finalVerifications": [
                                "Explicar verbalmente diferenças sem consultar notas.",
                                "Identificar corretamente 5 erros em código misto estático/dinâmico.",
                                "Criar exemplo personalizado de risco segurança runtime.",
                                "Preencher tabela comparativa com 80% acurácia.",
                                "Discutir escolha de linguagem para app bancário.",
                                "Debugar código dinâmico simulando falha runtime."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (correta distinção compile vs runtime).",
                                "Uso de exemplos relevantes e executáveis.",
                                "Análise equilibrada de prós/contras em segurança e dev.",
                                "Profundidade em implicações práticas (não superficial).",
                                "Clareza na comunicação (tabelas, relatórios legíveis).",
                                "Aplicação crítica a cenários reais."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Verificação estática como prevenção de exploits.",
                                "Engenharia de Software: Trade-offs em design de sistemas escaláveis.",
                                "Lógica Matemática: Verificação formal de tipos como teoremas.",
                                "Gestão de Projetos: Impacto no tempo e custo de desenvolvimento."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software financeiro, use tipagem estática (ex: Rust ou TypeScript) para detectar erros de tipo em compile-time, reduzindo riscos de fraudes por dados inválidos e acelerando deploy seguro em produção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.2",
                        "name": "Flexibilidade",
                        "description": "Análise da flexibilidade na atribuição e uso de variáveis: rigidez em tipagem estática versus maleabilidade em tipagem dinâmica.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.2.1",
                            "name": "Avaliar flexibilidade em tipagem estática",
                            "description": "Explicar como a declaração explícita de tipos em linguagens estáticas limita mudanças, promovendo código mais previsível mas menos flexível.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Tipagem Estática",
                                  "subSteps": [
                                    "Defina tipagem estática como verificação de tipos em tempo de compilação.",
                                    "Identifique linguagens exemplos: Java, C++, TypeScript.",
                                    "Explique declaração explícita de tipos (ex: int x = 5;).",
                                    "Discuta o ciclo de vida: compilação vs execução.",
                                    "Liste benefícios iniciais: detecção precoce de erros."
                                  ],
                                  "verification": "Resuma em 3 frases os fundamentos e forneça 2 exemplos de linguagens.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial de Java ou TypeScript",
                                    "Editor de código como VS Code"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar compilação vs runtime.",
                                  "learningObjective": "Entender o conceito básico de tipagem estática e suas declarações explícitas.",
                                  "commonMistakes": [
                                    "Confundir com tipagem dinâmica",
                                    "Ignorar tempo de compilação",
                                    "Pensar que tipos mudam em runtime"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Declaração Explícita de Tipos e Suas Limitações",
                                  "subSteps": [
                                    "Escreva código simples em Java declarando variáveis com tipos fixos.",
                                    "Tente alterar o tipo de uma variável após declaração e observe erros de compilação.",
                                    "Modifique funções para aceitar apenas tipos específicos e teste chamadas inválidas.",
                                    "Compare com inferência de tipos (ex: var em C#) mas note rigidez inerente.",
                                    "Documente cenários onde mudanças requerem refatoração extensa."
                                  ],
                                  "verification": "Compile um código com erro de tipo e corrija, explicando o impacto na flexibilidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "JDK instalado ou online compiler como Replit",
                                    "Exemplos de código Java básicos"
                                  ],
                                  "tips": "Sempre compile após cada mudança para ver erros imediatos.",
                                  "learningObjective": "Identificar como declarações explícitas limitam alterações dinâmicas.",
                                  "commonMistakes": [
                                    "Usar casting como solução flexível",
                                    "Ignorar overhead de refatoração",
                                    "Confundir inferência com dinamismo total"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Flexibilidade com Tipagem Dinâmica",
                                  "subSteps": [
                                    "Escreva o mesmo código em Python (dinâmica) e observe ausência de declarações de tipo.",
                                    "Altere tipos dinamicamente em Python e execute sem erros de compilação.",
                                    "Avalie previsibilidade: trace erros em runtime vs compile-time.",
                                    "Crie tabela comparativa: flexibilidade vs previsibilidade.",
                                    "Discuta cenários onde estática é preferível (ex: APIs públicas)."
                                  ],
                                  "verification": "Crie tabela de comparação com 5 critérios e justifique escolhas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python interpreter ou online como Google Colab",
                                    "Planilha ou Markdown para tabela"
                                  ],
                                  "tips": "Execute ambos códigos com mudanças para sentir a diferença prática.",
                                  "learningObjective": "Contrastar limitações de flexibilidade estática com vantagens dinâmicas.",
                                  "commonMistakes": [
                                    "Superestimar flexibilidade estática com generics",
                                    "Subestimar bugs runtime em dinâmica",
                                    "Ignorar contextos de uso"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Trade-offs e Formular Conclusão",
                                  "subSteps": [
                                    "Liste prós da estática: código previsível, melhor performance, IDE support.",
                                    "Liste contras: menos flexível para protótipos, mais verboso.",
                                    "Avalie em cenários reais: startup (dinâmica) vs enterprise (estática).",
                                    "Crie métrica simples de flexibilidade (ex: tempo para mudar tipo).",
                                    "Escreva parágrafo avaliando quando usar cada abordagem."
                                  ],
                                  "verification": "Redija avaliação de 200 palavras com exemplos e métrica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas anteriores",
                                    "Artigos sobre trade-offs de tipagem (ex: Stack Overflow)"
                                  ],
                                  "tips": "Pondere trade-offs com pesos baseados em projetos reais.",
                                  "learningObjective": "Capacitar avaliação crítica da flexibilidade em tipagem estática.",
                                  "commonMistakes": [
                                    "Focar só em contras ignorando previsibilidade",
                                    "Generalizar sem contexto",
                                    "Não quantificar trade-offs"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Java (estática), defina class Pessoa { String nome; } e tente atribuir int a nome -> erro de compilação imediato, exigindo mudança de tipo. Em Python (dinâmica), pessoa['nome'] = 123 funciona em runtime, mas pode quebrar lógica posterior. Isso mostra rigidez estática promovendo previsibilidade.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 limitações à flexibilidade em tipagem estática.",
                                "Modificar código Java estático sem quebrar compilação vs Python runtime.",
                                "Criar tabela comparativa precisa de flexibilidade vs previsibilidade.",
                                "Identificar cenário real onde estática é menos flexível mas melhor.",
                                "Avaliar trade-offs em protótipo vs produção."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de limitações de declaração explícita (30%)",
                                "Qualidade da comparação com tipagem dinâmica (25%)",
                                "Profundidade na análise de trade-offs previsibilidade-flexibilidade (20%)",
                                "Uso correto de exemplos de código compiláveis (15%)",
                                "Clareza e estrutura na avaliação final (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Analogia com tipos fixos em álgebra vs variáveis em equações dinâmicas.",
                                "Engenharia de Software: Princípios de design rígido para estabilidade estrutural.",
                                "Lógica e Filosofia: Trade-offs entre rigidez (previsibilidade) e fluidez (adaptação).",
                                "Negócios: Avaliação de risco em protótipos rápidos vs sistemas legados."
                              ],
                              "realWorldApplication": "Em equipes de desenvolvimento enterprise (ex: bancos), tipagem estática como Java previne erros caros em produção, sacrificando flexibilidade para refatorações raras, garantindo conformidade e auditoria de código."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.2",
                            "name": "Avaliar flexibilidade em tipagem dinâmica",
                            "description": "Demonstrar como tipagem dinâmica permite atribuições de tipos variados sem declaração prévia, facilitando prototipagem rápida em Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de tipagem dinâmica",
                                  "subSteps": [
                                    "Defina tipagem dinâmica como a capacidade de uma variável assumir diferentes tipos de dados em tempo de execução sem declaração prévia.",
                                    "Explique que em Python, o interpretador infere o tipo automaticamente durante a atribuição.",
                                    "Diferencie de tipagem estática, onde tipos são declarados no momento da definição.",
                                    "Discuta como isso promove flexibilidade ao permitir mudanças de tipo sem recompilação.",
                                    "Revise exemplos iniciais: x = 5; x = 'texto'"
                                  ],
                                  "verification": "Escreva uma definição precisa em suas próprias palavras e identifique corretamente o tipo de uma variável após múltiplas atribuições usando type().",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de texto ou IDE Python (VS Code, PyCharm), documentação oficial do Python sobre tipos.",
                                  "tips": "Use print(type(variavel)) para visualizar inferência de tipos em tempo real.",
                                  "learningObjective": "Explicar o mecanismo de inferência de tipos dinâmicos em Python.",
                                  "commonMistakes": "Confundir tipagem dinâmica com tipagem fraca; lembrar que Python é fortemente tipado, mas dinâmico."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Demonstrar atribuições dinâmicas em código Python",
                                  "subSteps": [
                                    "Crie uma variável e atribua um inteiro, depois uma string e por fim uma lista.",
                                    "Execute o código e use type() para verificar as mudanças de tipo.",
                                    "Modifique uma função para aceitar e processar argumentos de tipos variados (ex: soma se números, concatenação se strings).",
                                    "Teste com diferentes entradas para observar a flexibilidade.",
                                    "Adicione comentários explicando como o Python gerencia essas mudanças."
                                  ],
                                  "verification": "Execute o script sem erros e demonstre que a mesma variável muda de tipo corretamente em múltiplas execuções.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Ambiente Python interativo (Jupyter Notebook ou REPL), exemplos de código simples.",
                                  "tips": "Comece com REPL (python no terminal) para testes rápidos sem arquivos.",
                                  "learningObjective": "Implementar e testar atribuições de tipos variados à mesma variável.",
                                  "commonMistakes": "Esquecer de imprimir type() após cada atribuição; assumir que tipo persiste após redefinição."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar flexibilidade com tipagem estática",
                                  "subSteps": [
                                    "Escreva um pseudocódigo de tipagem estática (ex: Java) mostrando necessidade de declaração explícita.",
                                    "Tente replicar o mesmo em Python e destaque a ausência de declarações.",
                                    "Simule um erro comum em estática (mudança de tipo requer nova variável) vs. Python.",
                                    "Meça tempo de prototipagem: crie um script rápido em Python vs. simulação estática.",
                                    "Registre vantagens: rapidez em experimentação e iteração."
                                  ],
                                  "verification": "Crie uma tabela comparativa com pelo menos 3 diferenças chave e exemplos de código para cada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Referências online: Python docs vs. Java type docs; planilha para tabela.",
                                  "tips": "Use difflib ou ferramentas online para comparar snippets de código.",
                                  "learningObjective": "Identificar e quantificar ganhos de flexibilidade em prototipagem.",
                                  "commonMistakes": "Ignorar overhead de compilação em estática; focar apenas em sintaxe, não em workflow."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em prototipagem rápida real",
                                  "subSteps": [
                                    "Desenvolva um protótipo simples: função de processamento de dados que aceita listas, dicts ou strings.",
                                    "Itere rapidamente mudando tipos de entrada e ajustando lógica condicional.",
                                    "Cronometre o tempo total de desenvolvimento e refatoração.",
                                    "Otimize para performance básica (ex: usar isinstance() para checagem dinâmica).",
                                    "Documente o processo destacando como tipagem dinâmica acelerou o ciclo."
                                  ],
                                  "verification": "Produza um script funcional que lida com 3 tipos diferentes de input e rode testes unitários simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com bibliotecas padrão (isinstance, type), timer para medição.",
                                  "tips": "Use if isinstance(x, int): para ramificações seguras sem quebrar flexibilidade.",
                                  "learningObjective": "Construir um protótipo demonstrando aceleração via tipagem dinâmica.",
                                  "commonMistakes": "Sobre-generalizar sem checagens de tipo, levando a TypeErrors em runtime."
                                }
                              ],
                              "practicalExample": "Crie uma função processa_dados(input_data): que, se input_data for int, retorna input_data * 2; se str, retorna input_data.upper(); se list, retorna [item.upper() for item in input_data if isinstance(item, str)]. Teste com x = 5; x = 'hello'; x = ['a', 'b']; print(processa_dados(x)) após cada atribuição, mostrando flexibilidade sem redeclaração.",
                              "finalVerifications": [
                                "Explica corretamente como Python infere tipos dinamicamente sem declaração prévia.",
                                "Executa código com atribuições múltiplas de tipos variados sem erros.",
                                "Compara tempo de prototipagem Python vs. estática com evidências cronometradas.",
                                "Identifica pelo menos 3 vantagens da flexibilidade em cenários reais.",
                                "Desenvolve e testa um protótipo funcional com checagens de tipo dinâmicas.",
                                "Lista erros comuns em tipagem dinâmica e como evitá-los."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições e comparações corretas (30%)",
                                "Qualidade do código: funcional, limpo e com type() verificações (25%)",
                                "Profundidade de análise: tabela comparativa detalhada e cronometragem (20%)",
                                "Criatividade no protótipo: aplicação realista e iterativa (15%)",
                                "Documentação: comentários claros e lições aprendidas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: analogia com variáveis algébricas que mudam valor sem redefinição.",
                                "Design de Software: prototipagem rápida similar a wireframes iterativos em UX.",
                                "Ciência de Dados: flexibilidade em pipelines de dados exploratórios com pandas.",
                                "Lógica e Filosofia: debate sobre trade-offs dinâmico vs. estrito como rigidez cognitiva."
                              ],
                              "realWorldApplication": "Em desenvolvimento ágil de startups, tipagem dinâmica em Python acelera MVPs (Minimum Viable Products), permitindo scripts de análise de dados que evoluem de protótipos para produção sem refatorações pesadas, como em ferramentas de web scraping ou automação de testes onde requisitos mudam frequentemente."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.3",
                            "name": "Comparar níveis de flexibilidade",
                            "description": "Comparar cenários práticos onde a flexibilidade dinâmica acelera desenvolvimento, mas pode levar a erros inesperados, versus estabilidade estática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Flexibilidade em Tipagem Estática e Dinâmica",
                                  "subSteps": [
                                    "Defina tipagem estática: verificação de tipos no tempo de compilação, promovendo estabilidade.",
                                    "Defina tipagem dinâmica: verificação de tipos no tempo de execução, permitindo maior flexibilidade.",
                                    "Liste vantagens da flexibilidade dinâmica: prototipagem rápida e código mais conciso.",
                                    "Liste desvantagens: erros em runtime e depuração mais complexa.",
                                    "Liste vantagens da estabilidade estática: detecção precoce de erros e melhor performance."
                                  ],
                                  "verification": "Crie um quadro comparativo com pelo menos 5 pontos para cada tipo de tipagem.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação oficial de linguagens como Java (estática) e Python (dinâmica); editor de texto.",
                                  "tips": "Use tabelas para visualização clara; foque em exemplos simples de código.",
                                  "learningObjective": "Compreender as bases conceituais de flexibilidade e estabilidade em tipagem.",
                                  "commonMistakes": "Confundir flexibilidade com ausência de tipos; ignorar impactos em performance."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Cenários Práticos de Aceleração pelo Flexibilidade Dinâmica",
                                  "subSteps": [
                                    "Escolha uma tarefa simples como processar dados heterogêneos (ex: lista mista de strings e números).",
                                    "Implemente em Python (dinâmica): escreva código sem declarações de tipo explícitas.",
                                    "Meça o tempo de desenvolvimento: cronometre desde a ideia até o código funcional.",
                                    "Execute e observe aceleração: note como mudanças rápidas são possíveis sem recompilação.",
                                    "Registre potenciais erros: identifique onde types poderiam causar falhas em runtime."
                                  ],
                                  "verification": "Demonstre código Python funcional com log de tempo de desenvolvimento < 5 minutos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ambiente Python (IDLE ou VS Code); amostra de dados mistos em JSON.",
                                  "tips": "Comece com código mínimo viável; use print() para simular runtime behaviors.",
                                  "learningObjective": "Reconhecer como flexibilidade dinâmica acelera iterações em protótipos.",
                                  "commonMistakes": "Sobrecarregar o exemplo com lógica complexa; não cronometrar precisamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Cenários de Estabilidade Estática Prevenindo Erros Inesperados",
                                  "subSteps": [
                                    "Reimplemente o mesmo tarefa em Java (estática): declare tipos explicitamente.",
                                    "Compile o código: observe erros de tipo detectados antes da execução.",
                                    "Compare tempos: note overhead inicial mas ausência de runtime crashes.",
                                    "Simule erros comuns: tente atribuir string a int e veja falha em compile-time.",
                                    "Documente trade-offs: estabilidade vs tempo de setup inicial."
                                  ],
                                  "verification": "Mostre output de compilação com erros corrigidos e execução sem falhas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "JDK e IDE como IntelliJ; mesmo conjunto de dados do Step 2.",
                                  "tips": "Use generics para flexibilidade controlada; compare linhas de código.",
                                  "learningObjective": "Identificar como estabilidade estática mitiga erros em cenários críticos.",
                                  "commonMistakes": "Ignorar warnings do compilador; usar linguagens híbridas como TypeScript."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Sintetizar Níveis de Flexibilidade em Cenários Integrados",
                                  "subSteps": [
                                    "Crie um relatório comparativo: tabela com métricas (tempo dev, erros, performance).",
                                    "Analise cenários híbridos: quando usar cada abordagem (ex: scripts vs apps enterprise).",
                                    "Desenvolva critérios de decisão: baseados em tamanho do projeto e equipe.",
                                    "Teste em um mini-projeto: adicione feature nova em ambos códigos e compare.",
                                    "Conclua com lições: balanceamento flexibilidade vs estabilidade."
                                  ],
                                  "verification": "Apresente relatório com tabela e conclusão em 1 página.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha (Google Sheets/Excel); códigos dos steps anteriores.",
                                  "tips": "Use métricas quantitativas como LOC e tempo de debug; visualize com gráficos.",
                                  "learningObjective": "Sintetizar comparações para decisões informadas em desenvolvimento.",
                                  "commonMistakes": "Viés para uma linguagem; omitir contexto de equipe/projeto."
                                }
                              ],
                              "practicalExample": "Desenvolva um validador de formulário web: em Python (dinâmica), adicione suporte rápido a novos campos sem tipos, acelerando protótipo mas arriscando erros como TypeError em inputs inválidos. Em Java (estática), defina classes rígidas, detectando mismatches em compile-time, ideal para apps de produção mas mais lento para iterar.",
                              "finalVerifications": [
                                "Pode listar 3 cenários onde dinâmica acelera >30% o desenvolvimento.",
                                "Identifica 3 erros runtime evitados por estática em exemplos reais.",
                                "Cria tabela comparativa com trade-offs precisos.",
                                "Explica decisão de tipagem para um projeto dado em <2 minutos.",
                                "Implementa mini-exemplo híbrido sem erros.",
                                "Discute impactos em manutenção de código legado."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas sem confusões (30%)",
                                "Profundidade de exemplos: cenários práticos e mensuráveis (25%)",
                                "Análise balanceada: prós/contras de ambos lados (20%)",
                                "Clareza na comparação: tabelas/gráficos eficazes (15%)",
                                "Aplicação prática: código funcional e verificável (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica formal e proof de propriedades (estabilidade como teoremas provados).",
                                "Física: Elasticidade vs rigidez em materiais (flexibilidade dinâmica como elástico).",
                                "Economia: Custo-benefício em trade-offs (desenvolvimento rápido vs manutenção longa).",
                                "Filosofia: Risco vs certeza em epistemologia prática."
                              ],
                              "realWorldApplication": "Em startups, use tipagem dinâmica (Python/JS) para MVPs rápidos em web apps; em bancos, prefira estática (Java/C#) para sistemas transacionais onde erros custam milhões, como em fintechs evitando fraudes por type-safety."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.3",
                        "name": "Desempenho",
                        "description": "Impacto no desempenho de execução: otimizações em tempo de compilação (estática) versus overhead de verificações em runtime (dinâmica).",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.3.1",
                            "name": "Analisar desempenho em tipagem estática",
                            "description": "Descrever como compiladores em linguagens estáticas otimizam código com base em tipos conhecidos, resultando em execução mais rápida.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos da Tipagem Estática",
                                  "subSteps": [
                                    "Defina tipagem estática e liste linguagens exemplares como Java, C++ e Rust.",
                                    "Explique o momento da verificação de tipos (tempo de compilação vs. execução).",
                                    "Descreva como tipos conhecidos permitem ao compilador inferir estruturas de dados.",
                                    "Identifique benefícios iniciais, como detecção precoce de erros e otimizações.",
                                    "Pesquise e anote um fluxograma simples do processo de compilação estática."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando tipagem estática e seus pré-requisitos para otimizações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial de Java ou C++",
                                    "Vídeo introdutório sobre compiladores (ex: YouTube - 'Static Typing Explained')"
                                  ],
                                  "tips": "Use analogias como 'tipos são blueprints conhecidos antes da construção' para fixar conceitos.",
                                  "learningObjective": "Dominar os conceitos básicos de tipagem estática e seu papel no processo de compilação.",
                                  "commonMistakes": [
                                    "Confundir verificação em tempo de compilação com runtime",
                                    "Ignorar que tipos estáticos são resolvidos antes da execução"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Investigar Otimizações Específicas de Compiladores",
                                  "subSteps": [
                                    "Estude 'dead code elimination': como tipos eliminam código inacessível.",
                                    "Analise 'function inlining': substituição direta de chamadas quando tipos são conhecidos.",
                                    "Explore 'monomorphization' em generics (ex: Rust ou C++ templates).",
                                    "Discuta otimizações de memória, como alocação estática de arrays tipados.",
                                    "Examine como tipos melhoram branch prediction e vetorização (SIMD)."
                                  ],
                                  "verification": "Liste e descreva 4 otimizações com exemplos pseudocódigo para cada uma.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação LLVM ou GCC optimizer",
                                    "Exemplos de código em Godbolt Compiler Explorer"
                                  ],
                                  "tips": "Use ferramentas online como Compiler Explorer para visualizar assembly gerado.",
                                  "learningObjective": "Identificar e explicar otimizações de compilador habilitadas por tipos conhecidos.",
                                  "commonMistakes": [
                                    "Atribuir otimizações a hardware em vez de tipos",
                                    "Não diferenciar otimizações de alto nível de baixo nível"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Desempenho com Tipagem Dinâmica",
                                  "subSteps": [
                                    "Escreva funções equivalentes: soma de array em Java (estático) e JavaScript (dinâmico).",
                                    "Meça tempos de execução com loops grandes (ex: 1 milhão de elementos).",
                                    "Compile o código Java e analise o bytecode ou assembly.",
                                    "Execute benchmarks repetidos e registre médias de tempo.",
                                    "Compare e quantifique diferenças percentuais em performance."
                                  ],
                                  "verification": "Crie um relatório com tabelas de benchmarks mostrando Java 20-50% mais rápido.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "IDE como IntelliJ para Java",
                                    "Node.js para JS",
                                    "Ferramenta de benchmark como Criterion ou console.time()"
                                  ],
                                  "tips": "Use arrays grandes para amplificar diferenças; isole variáveis externas.",
                                  "learningObjective": "Quantificar empiricamente vantagens de performance da tipagem estática.",
                                  "commonMistakes": [
                                    "Testes com dados pequenos que mascaram diferenças",
                                    "Não controlar por otimizações JIT no JS"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Análise de Desempenho",
                                  "subSteps": [
                                    "Resuma mecanismos: tipos → inferência → otimizações → código nativo eficiente.",
                                    "Crie um diagrama conectando tipos estáticos a ganhos de velocidade.",
                                    "Discuta cenários onde ganhos são mais pronunciados (ex: loops intensivos).",
                                    "Avalie trade-offs: tempo de compilação vs. runtime.",
                                    "Proponha refatorações de código dinâmico para estático em projetos reais."
                                  ],
                                  "verification": "Desenvolva uma apresentação de 1 slide explicando a cadeia de otimizações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama como Draw.io",
                                    "Notas dos steps anteriores"
                                  ],
                                  "tips": "Foque em causalidade: 'tipos conhecidos → X otimização → Y speedup'.",
                                  "learningObjective": "Integrar conhecimentos para analisar holisticamente o impacto no desempenho.",
                                  "commonMistakes": [
                                    "Generalizar ganhos sem contexto",
                                    "Ignorar overhead de compilação longa"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um aplicativo de processamento de imagens, um loop em C++ (tipagem estática) usa tipos conhecidos (uint8_t para pixels) para otimizar com SIMD/AVX, processando 4x mais rápido que equivalente em Python (dinâmico), reduzindo tempo de filtro de 500ms para 120ms em imagens HD.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 otimizações específicas de compilador baseadas em tipos.",
                                "Executar benchmark reproduzível mostrando speedup de 20%+ em código estático.",
                                "Identificar assembly otimizado vs. não-otimizado em Compiler Explorer.",
                                "Desenhar diagrama da cadeia: tipos → otimizações → performance.",
                                "Propor melhoria de performance em código dinâmico existente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de otimizações (dead code, inlining, etc.).",
                                "Quantificação empírica de ganhos de performance via benchmarks.",
                                "Uso correto de terminologia (compile-time, monomorphization).",
                                "Profundidade na análise comparativa estática vs. dinâmica.",
                                "Criatividade em exemplos e conexões reais.",
                                "Clareza na verificação e síntese final."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de complexidade algorítmica e otimização O(n).",
                                "Física: Analogias com eficiência termodinâmica em sistemas.",
                                "Administração: Gerenciamento de recursos computacionais em escala.",
                                "Engenharia: Princípios de design otimizado em sistemas embarcados."
                              ],
                              "realWorldApplication": "Em servidores web como os do Google (usando C++ e Go), tipagem estática permite otimizações que lidam com bilhões de requests/dia, reduzindo latência de ms para μs, essencial para serviços como Search e YouTube."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.3.2",
                            "name": "Analisar desempenho em tipagem dinâmica",
                            "description": "Explicar o custo adicional de verificações de tipo em runtime em linguagens dinâmicas, impactando velocidade em aplicações de alto desempenho.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Verificações de Tipo em Runtime",
                                  "subSteps": [
                                    "Defina tipagem dinâmica e liste linguagens exemplos (Python, JavaScript).",
                                    "Explique como verificações de tipo ocorrem em runtime (ex: duck typing, isinstance).",
                                    "Identifique overhead: alocação dinâmica, resolução de métodos.",
                                    "Compare com compilação estática onde tipos são resolvidos upfront.",
                                    "Revise documentação oficial de uma linguagem dinâmica sobre type checking."
                                  ],
                                  "verification": "Resuma em um diagrama ou parágrafo o fluxo de verificação de tipo em runtime vs compile-time.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação Python/JavaScript, diagramas de fluxo (Draw.io ou papel).",
                                  "tips": "Use analogias como 'verificar ID na porta vs ter lista pré-aprovada'.",
                                  "learningObjective": "Explicar mecanismos de verificação de tipo em linguagens dinâmicas.",
                                  "commonMistakes": "Confundir type hints (estáticos opcionais) com verificações reais em runtime."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Benchmarks Básicos",
                                  "subSteps": [
                                    "Escreva código simples em Python/JS: loop com operações em listas/dicionários.",
                                    "Adicione prints/timers para medir tempo de execução (timeit module).",
                                    "Repita testes com diferentes tamanhos de dados (10^3 a 10^6 elementos).",
                                    "Compare com equivalente em linguagem estática (C# ou Java snippet).",
                                    "Registre métricas: tempo médio, uso de CPU/memória."
                                  ],
                                  "verification": "Execute benchmarks e gere tabela com tempos de execução para cada linguagem.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de código (VS Code), Python/Node.js instalados, timeit ou performance.now().",
                                  "tips": "Rode testes múltiplas vezes e use média para reduzir variância.",
                                  "learningObjective": "Medir empiricamente o overhead de tipagem dinâmica.",
                                  "commonMistakes": "Ignorar garbage collection ou JIT warmup que mascaram diferenças."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Impacto no Desempenho",
                                  "subSteps": [
                                    "Calcule slowdown relativo: (tempo_dinamico / tempo_estatico) * 100%.",
                                    "Identifique gargalos: profile código com cProfile (Python) ou Chrome DevTools.",
                                    "Discuta cenários afetados: loops intensivos vs scripts curtos.",
                                    "Explore otimizações: NumPy/PyPy para mitigar overhead.",
                                    "Crie gráfico de performance vs tamanho de input."
                                  ],
                                  "verification": "Produza relatório com gráficos e conclusões sobre fatores de slowdown.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "cProfile/Chrome Profiler, Matplotlib/Excel para gráficos.",
                                  "tips": "Foquem em operações type-intensive como acessos a dicionários heterogêneos.",
                                  "learningObjective": "Quantificar e interpretar custos de performance em tipagem dinâmica.",
                                  "commonMistakes": "Atribuir todo slowdown à tipagem, ignorando outros fatores como GC."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Trade-offs e Aplicações",
                                  "subSteps": [
                                    "Liste prós/cons: flexibilidade vs performance em apps de alto throughput.",
                                    "Simule caso real: servidor web simples medindo RPS (requests per second).",
                                    "Pesquise benchmarks reais (TechEmpower para web frameworks).",
                                    "Proponha quando usar dinâmica: protótipos vs produção.",
                                    "Documente lições para escolha de linguagem."
                                  ],
                                  "verification": "Escreva parágrafo recomendando uso baseado em análise.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Benchmarks online (TechEmpower), frameworks leves (Flask/Express).",
                                  "tips": "Considere hot paths em apps reais onde runtime checks acumulam.",
                                  "learningObjective": "Aplicar análise para decisões arquiteturais informadas.",
                                  "commonMistakes": "Superestimar impacto em apps não CPU-bound (I/O heavy)."
                                }
                              ],
                              "practicalExample": "Implemente um benchmark comparando soma de 1 milhão de elementos em lista Python (dinâmica) vs array Java (estática). Python leva ~2x mais tempo devido a type checks em loop; profile mostra 30% overhead em getattr/isinstance.",
                              "finalVerifications": [
                                "Explicar com precisão o overhead de runtime type checks (>20% correto).",
                                "Benchmark reproduz slowdown mensurável (fator 1.5-5x).",
                                "Identificar pelo menos 3 gargalos específicos em profile.",
                                "Gráfico mostra escalabilidade linear com input size.",
                                "Relatório discute trade-offs com exemplos reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Correta distinção runtime vs compile-time (90%+).",
                                "Qualidade de benchmarks: Reprodutíveis, controlados, múltiplas runs.",
                                "Análise quantitativa: Cálculos de slowdown e profiling profundo.",
                                "Visualizações claras: Gráficos/tabelas interpretáveis.",
                                "Insights práticos: Recomendações contextualizadas.",
                                "Completude: Todos substeps cobertos sem erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de complexidade Big O para overhead acumulado.",
                                "Física/Engenharia: Simulações numéricas onde performance crítica (ex: CFD).",
                                "Economia: Custo-benefício em escolha de stack tech para startups.",
                                "Design de Sistemas: Trade-offs em arquitetura de software."
                              ],
                              "realWorldApplication": "Em trading de alta frequência (HFT), linguagens dinâmicas como Python causam latência extra por type checks, levando a uso de C++/Rust para edges de milissegundos; análise guia migração para hot paths otimizados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.3.3",
                            "name": "Comparar impactos no desempenho",
                            "description": "Comparar benchmarks reais entre C++ (estática) e Python (dinâmica), destacando trade-offs para diferentes tipos de aplicações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender fundamentos teóricos de desempenho em tipagem estática vs dinâmica",
                                  "subSteps": [
                                    "Estudar diferenças entre compilação estática (C++) e interpretação dinâmica (Python).",
                                    "Analisar impactos no ciclo de vida do programa: parse, type checking, execução.",
                                    "Identificar métricas chave: tempo de CPU, uso de memória, latência de inicialização.",
                                    "Revisar benchmarks públicos como TechEmpower ou Computer Language Benchmarks Game.",
                                    "Anotar trade-offs teóricos para loops intensivos, I/O e computação numérica."
                                  ],
                                  "verification": "Criar um resumo de 1 página com 5 diferenças teóricas chave e exemplos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Acesso à internet",
                                    "Notebook ou editor de texto",
                                    "Sites: benchmarks game, TechEmpower"
                                  ],
                                  "tips": "Priorize fontes acadêmicas ou benchmarks independentes para evitar viés.",
                                  "learningObjective": "Dominar as bases teóricas que explicam diferenças de desempenho.",
                                  "commonMistakes": [
                                    "Confundir overhead de type checking com tempo de execução total",
                                    "Ignorar otimizações como NumPy no Python ou -O3 no C++"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar ambiente de benchmark controlado",
                                  "subSteps": [
                                    "Instalar compiladores: g++ para C++ e Python 3.x com pip.",
                                    "Configurar IDEs ou terminais com timers precisos (time, perf).",
                                    "Padronizar hardware: usar mesma máquina, desabilitar background processes.",
                                    "Criar scripts para rodar testes múltiplos (ex: 10 iterações, calcular média).",
                                    "Testar com hello world para validar setup e medir baseline."
                                  ],
                                  "verification": "Executar teste baseline com resultados reproduzíveis em <1s para ambos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Máquina com Linux/Windows",
                                    "g++",
                                    "Python 3",
                                    "VS Code ou terminal"
                                  ],
                                  "tips": "Use flags consistentes: -O2/-O3 no C++, cProfile no Python.",
                                  "learningObjective": "Preparar um ambiente imparcial para comparações justas.",
                                  "commonMistakes": [
                                    "Rodar em máquinas diferentes",
                                    "Esquecer de aquecer cache ou JIT"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e executar benchmarks reais",
                                  "subSteps": [
                                    "Codificar tarefas comuns: matrix multiplication (1k x 1k), sorting (1M elementos), Fibonacci recursivo.",
                                    "Implementar em C++ puro e Python puro (sem libs externas inicialmente).",
                                    "Executar 20 rodadas por tarefa, registrar tempos e memória (valgrind/top).",
                                    "Repetir com otimizações: vectors no C++, NumPy no Python.",
                                    "Gerar gráficos com matplotlib ou Excel para visualização."
                                  ],
                                  "verification": "Tabela com dados de pelo menos 3 tarefas, mostrando médias e desvios.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código fonte preparado",
                                    "Ferramentas: time, valgrind, matplotlib"
                                  ],
                                  "tips": "Mantenha códigos idênticos logicamente para fair comparison.",
                                  "learningObjective": "Coletar dados empíricos de desempenho em cenários variados.",
                                  "commonMistakes": [
                                    "Usar libs só em um lado",
                                    "Ignorar garbage collection no Python"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar resultados e destacar trade-offs por tipo de aplicação",
                                  "subSteps": [
                                    "Comparar métricas: calcular speedups (C++/Python ratio).",
                                    "Classificar aplicações: CPU-bound (C++ vence), I/O-bound (Python próximo).",
                                    "Discutir trade-offs: velocidade vs produtividade/desenvolvimento rápido.",
                                    "Simular cenários: jogos (C++), data pipelines (Python), web servers.",
                                    "Documentar conclusões em relatório com gráficos e recomendações."
                                  ],
                                  "verification": "Relatório de 2 páginas com análises quantitativas e qualitativas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Dados dos benchmarks",
                                    "Ferramentas de plot: matplotlib, Excel"
                                  ],
                                  "tips": "Use estatística básica: média, mediana, para robustez.",
                                  "learningObjective": "Interpretar dados para decisões informadas em escolhas de linguagem.",
                                  "commonMistakes": [
                                    "Generalizar de um benchmark só",
                                    "Desconsiderar escalabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar com casos reais e sintetizar aprendizados",
                                  "subSteps": [
                                    "Pesquisar cases: Blender (C++), Pandas (Python wrappers).",
                                    "Executar benchmark em app real: web scraper ou simulação física simples.",
                                    "Debater prós/contras em grupo ou auto-reflexão.",
                                    "Criar cheat sheet de quando escolher cada linguagem.",
                                    "Testar refatoração: otimizar Python lento com Cython ou Pypy."
                                  ],
                                  "verification": "Cheat sheet e discussão gravada ou escrita.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Exemplos open-source no GitHub",
                                    "Cython/Pypy instalados"
                                  ],
                                  "tips": "Foque em hybrid approaches como pybind11 para melhores de ambos.",
                                  "learningObjective": "Aplicar comparações a contextos profissionais reais.",
                                  "commonMistakes": [
                                    "Viés por preferência pessoal",
                                    "Ignorar custos de manutenção"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente multiplicação de matrizes 1000x1000: em C++ usando arrays dinâmicos (~0.1s), em Python puro (~30s). Com NumPy (~0.5s). Meça e compare para computação científica.",
                              "finalVerifications": [
                                "Explicar speedup médio de 10-100x em C++ para CPU-bound tasks.",
                                "Identificar quando Python é viável apesar de lentidão (prototipagem, I/O).",
                                "Listar 3 trade-offs: performance vs legibilidade/desenvolvimento.",
                                "Reproduzir benchmark com variação <5%.",
                                "Recomendar linguagem para 3 cenários: jogos, ML, web APIs.",
                                "Analisar impacto de otimizações (JIT, vectorization)."
                              ],
                              "assessmentCriteria": [
                                "Precisão e reproduzibilidade dos benchmarks (dados numéricos exatos).",
                                "Profundidade da análise de trade-offs quantitativos e qualitativos.",
                                "Cobertura de múltiplos tipos de aplicações e métricas.",
                                "Uso correto de ferramentas e controle de variáveis.",
                                "Clareza no relatório com visualizações e conclusões acionáveis.",
                                "Identificação de limitações e sugestões de melhorias."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística descritiva e análise de variância nos dados.",
                                "Engenharia de Software: Princípios de profiling e otimização.",
                                "Ciência de Dados: Seleção de stacks para pipelines de ML.",
                                "Física/Engenharia: Simulações numéricas em HPC.",
                                "Economia/Gestão: Trade-offs custo-benefício em desenvolvimento."
                              ],
                              "realWorldApplication": "Em equipes de software, use C++ para engines de jogos como Unreal (alta performance) e Python para análise de dados em finanças (rápida iteração), equilibrando velocidade com produtividade em projetos híbridos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.4",
                        "name": "Detecção de Erros",
                        "description": "Diferenças na detecção e timing de erros de tipo: precoce em estática versus tardia em dinâmica.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.4.1",
                            "name": "Identificar detecção precoce em estática",
                            "description": "Mostrar como erros de tipo são capturados na compilação em linguagens estáticas, reduzindo falhas em produção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Tipagem Estática",
                                  "subSteps": [
                                    "Defina tipagem estática como verificação de tipos em tempo de compilação.",
                                    "Liste linguagens estáticas comuns: Java, C++, TypeScript.",
                                    "Explique que variáveis devem declarar tipos explicitamente ou inferidos estaticamente.",
                                    "Diferencie de tipagem dinâmica, onde tipos são verificados em runtime.",
                                    "Revise exemplos simples de declaração de variáveis em Java."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos chave e liste 3 linguagens estáticas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação oficial do Java (Oracle Docs), notebook para anotações.",
                                  "tips": "Use analogia: tipagem estática é como um inspetor de bagagens no aeroporto antes do voo.",
                                  "learningObjective": "Identificar e explicar o que é tipagem estática e suas características principais.",
                                  "commonMistakes": "Confundir com tipagem dinâmica; achar que estática é sempre explícita (inferência existe)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Processo de Compilação e Detecção de Erros",
                                  "subSteps": [
                                    "Descreva o ciclo: código fonte -> compilador -> bytecode/executável.",
                                    "Identifique fases do compilador: análise léxica, sintática, semântica (tipos).",
                                    "Simule detecção de erro de tipo: atribuição incompatível falha na semântica.",
                                    "Compare com runtime: em dinâmica, erro só em execução.",
                                    "Instale e rode um compilador simples para observar mensagens de erro."
                                  ],
                                  "verification": "Desenhe um fluxograma do processo de compilação destacando detecção de tipos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "JDK instalado, terminal ou IDE como IntelliJ ou VS Code com extensão Java.",
                                  "tips": "Foque nas mensagens de erro do compilador; elas são diagnósticos precisos.",
                                  "learningObjective": "Mapear como e quando erros de tipo são detectados na compilação estática.",
                                  "commonMistakes": "Ignorar que nem todos os erros são de tipo (sintaxe também); superestimar detecção total."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar com Exemplos de Código em Linguagem Estática",
                                  "subSteps": [
                                    "Escreva código Java com erro intencional: String para int.",
                                    "Tente compilar com javac e analise o erro reportado.",
                                    "Corrija o tipo e recompile com sucesso.",
                                    "Execute o código corrigido e confirme ausência de falhas de tipo.",
                                    "Varie com inferência de tipos (var em Java 10+) e observe detecção."
                                  ],
                                  "verification": "Compile dois códigos (errado e correto) e capture screenshots das saídas do compilador.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código (IntelliJ Community), JDK 17+, arquivo .java de teste.",
                                  "tips": "Comece com erros simples; use System.out.println para testar execução pós-correção.",
                                  "learningObjective": "Demonstrar na prática como compilador captura erros de tipo precocemente.",
                                  "commonMistakes": "Esquecer de salvar arquivo antes de compilar; confundir warnings com erros."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Benefícios e Redução de Falhas em Produção",
                                  "subSteps": [
                                    "Liste vantagens: detecção precoce reduz crashes runtime e debugging.",
                                    "Compare métricas: estudos mostram 50-70% menos bugs de tipo em estáticas.",
                                    "Discuta cenários de produção: apps web, sistemas embarcados.",
                                    "Crie tabela comparativa estática vs dinâmica para erros de tipo.",
                                    "Reflita sobre trade-offs: mais tempo de compilação vs segurança."
                                  ],
                                  "verification": "Escreva um parágrafo explicando como detecção precoce reduz falhas em produção.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilha ou documento para tabela comparativa, artigos sobre confiabilidade de software.",
                                  "tips": "Pesquise cases reais como Heartbleed (erro runtime em C dinâmico).",
                                  "learningObjective": "Conectar detecção precoce a impactos reais em desenvolvimento e produção.",
                                  "commonMistakes": "Subestimar custos de runtime em dinâmica; ignorar que estática não pega lógica errada."
                                }
                              ],
                              "practicalExample": "Em Java: Código errado - int numero = \"abc\"; // Erro de compilação: incompatible types. Corrigido: int numero = 123; Compila e roda sem falha de tipo, evitando crash em produção como em um app bancário processando transações.",
                              "finalVerifications": [
                                "Explica corretamente como compilador detecta erros de tipo antes da execução.",
                                "Identifica e corrige erro de tipo em código fornecido em <1 minuto.",
                                "Lista 3 benefícios da detecção precoce em cenários reais.",
                                "Compara estática vs dinâmica com exemplos precisos.",
                                "Cria código funcional sem erros de tipo em Java ou similar."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação de detecção em compilação (90%+ acerto).",
                                "Qualidade dos exemplos de código e análise de erros (compilações bem-sucedidas).",
                                "Profundidade na comparação com tipagem dinâmica (mínimo 3 diferenças).",
                                "Clareza na conexão com redução de falhas em produção (exemplos concretos).",
                                "Completude da tabela ou fluxograma de processos (todos elementos presentes)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de tipos como conjuntos e funções tipadas.",
                                "Lógica: Verificação formal similar a provas matemáticas.",
                                "Física/Engenharia: Modelagem precisa de sistemas para evitar falhas catastróficas.",
                                "Inglês Técnico: Leitura de mensagens de erro e documentação oficial."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software crítico como sistemas bancários ou aviônicos, tipagem estática previne erros de tipo que poderiam causar perdas financeiras ou acidentes, como o bug Knight Capital (US$440M em 45min) parcialmente atribuível a falhas runtime evitáveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.4.2",
                            "name": "Identificar detecção tardia em dinâmica",
                            "description": "Ilustrar como erros de tipo só são revelados em runtime em linguagens dinâmicas, exigindo testes extensivos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Tipagem Dinâmica",
                                  "subSteps": [
                                    "Defina tipagem dinâmica: verificação de tipos ocorre em tempo de execução.",
                                    "Liste linguagens dinâmicas comuns: Python, JavaScript, Ruby.",
                                    "Compare com tipagem estática: verificação em tempo de compilação.",
                                    "Identifique vantagens: flexibilidade e código mais conciso.",
                                    "Revise desvantagens iniciais: potenciais erros em runtime."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre tipagem dinâmica e estática, citando pelo menos duas linguagens de cada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação oficial do Python ou JavaScript sobre tipos",
                                    "Artigo comparativo de tipagem estática vs dinâmica"
                                  ],
                                  "tips": "Use analogias como 'cheque em tempo de uso' para runtime vs 'cheque antes de imprimir'.",
                                  "learningObjective": "Diferenciar tipagem dinâmica de estática e listar linguagens exemplares.",
                                  "commonMistakes": "Confundir tipagem dinâmica com 'sem tipos' – lembre que tipos existem, mas são checados tarde."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar um Exemplo de Código com Erro de Tipo em Linguagem Dinâmica",
                                  "subSteps": [
                                    "Escolha Python como linguagem dinâmica.",
                                    "Escreva uma função que soma um inteiro e uma string: def soma(a, b): return a + b.",
                                    "Chame a função com soma(5, 'dez') para forçar erro de tipo.",
                                    "Salve o código em um arquivo .py sem executar ainda.",
                                    "Anote onde o erro pode ocorrer baseado no conhecimento teórico."
                                  ],
                                  "verification": "Mostre o código escrito e aponte a linha problemática sem executar.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código como VS Code",
                                    "Instalação do Python"
                                  ],
                                  "tips": "Comece com variáveis simples para isolar o erro de tipo.",
                                  "learningObjective": "Construir código que demonstre potencial de erro de tipo oculto até runtime.",
                                  "commonMistakes": "Usar operadores corretos acidentalmente – force incompatibilidade intencional."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar o Código e Observar Detecção em Runtime",
                                  "subSteps": [
                                    "Execute o script Python no terminal: python arquivo.py.",
                                    "Registre o erro exato: TypeError: unsupported operand type(s) for +: 'int' and 'str'.",
                                    "Compile mentalmente: o erro só aparece em runtime, não em edição.",
                                    "Compare com equivalente em linguagem estática (ex: Java) que falharia na compilação.",
                                    "Documente o stack trace e timing do erro."
                                  ],
                                  "verification": "Capture screenshot ou log do erro em runtime e explique por que não foi detectado antes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Terminal ou IDE com Python",
                                    "Compilador Java ou TypeScript para comparação opcional"
                                  ],
                                  "tips": "Execute em ambiente limpo para evitar caches interferindo.",
                                  "learningObjective": "Demonstrar empiricamente a detecção tardia de erros de tipo.",
                                  "commonMistakes": "Ignorar warnings do IDE – foque no runtime puro."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Implicações e Necessidade de Testes Extensivos",
                                  "subSteps": [
                                    "Liste cenários onde erros runtime impactam: funções com inputs variáveis.",
                                    "Discuta testes unitários: cubra todos tipos esperados e edge cases.",
                                    "Crie um teste simples usando pytest para capturar o erro cedo.",
                                    "Compare cobertura de testes: dinâmica exige 90%+ vs estática 70%.",
                                    "Reflita: como mitigar com type hints (ex: Python typing module)."
                                  ],
                                  "verification": "Escreva um teste que falhe no seu código original e passe em versão corrigida.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pytest instalado",
                                    "Documentação de type hints em Python"
                                  ],
                                  "tips": "Priorize testes de integração para simular runtime real.",
                                  "learningObjective": "Reconhecer a demanda por testes rigorosos em tipagem dinâmica.",
                                  "commonMistakes": "Subestimar edge cases como None ou tipos inesperados de APIs."
                                }
                              ],
                              "practicalExample": "Em um script Python de e-commerce, uma função calculaTotal(preco, quantidade) recebe preco='10.5' (string de API) e quantidade=2 (int), falhando em runtime com TypeError ao somar, só detectado após deploy – exigindo testes que simulem inputs reais de JSON.",
                              "finalVerifications": [
                                "Explicar corretamente detecção runtime vs compile-time.",
                                "Executar exemplo com erro e capturar TypeError.",
                                "Criar teste que previna o erro.",
                                "Listar 3 linguagens dinâmicas e seus riscos.",
                                "Propor type hints como mitigação parcial.",
                                "Comparar com código estático equivalente sem erro em compile."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do momento da detecção de erro (runtime).",
                                "Qualidade do exemplo de código: reproduz erro de forma isolada.",
                                "Profundidade da análise de testes: menciona cobertura e edge cases.",
                                "Clareza na explicação oral/escrita das implicações.",
                                "Criatividade em mitigações além de testes (ex: hints).",
                                "Completude dos passos: todos substeps executados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de tipos e conjuntos (compatibilidade de operandos).",
                                "Lógica: Raciocínio dedutivo para prever erros runtime.",
                                "Inglês Técnico: Leitura de stack traces e documentação de erros.",
                                "Gestão de Projetos: Importância de testes em desenvolvimento ágil."
                              ],
                              "realWorldApplication": "Em desenvolvimento web com JavaScript (Node.js), erros de tipo em dados de usuário (ex: parsing JSON malformado) causam crashes em produção; equipes usam testes extensivos e ESLint com type checks para evitar downtime em apps como e-commerces ou redes sociais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.4.3",
                            "name": "Comparar estratégias de detecção",
                            "description": "Analisar vantagens da detecção precoce para robustez versus necessidade de type hints em dinâmica para mitigar riscos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Detecção de Erros em Tipagem Estática",
                                  "subSteps": [
                                    "Estude como compiladores detectam erros de tipo no tempo de compilação (ex: TypeScript, Java).",
                                    "Identifique exemplos de erros capturados precocemente, como atribuição de string a variável int.",
                                    "Analise o impacto na robustez: refatoração mais segura e menos crashes em runtime.",
                                    "Compare com fluxos de build que falham antes da execução.",
                                    "Documente 3 vantagens específicas da detecção estática."
                                  ],
                                  "verification": "Criar um diagrama ou tabela listando tipos de erros detectados estaticamente e seus benefícios.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação TypeScript/Java, editor de código como VS Code.",
                                  "tips": "Use exemplos simples de código para visualizar falhas de compilação.",
                                  "learningObjective": "Compreender como a detecção precoce melhora a robustez do código.",
                                  "commonMistakes": "Confundir detecção estática com verificações de runtime; ignorar overhead de compilação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Detecção de Erros em Tipagem Dinâmica com Type Hints",
                                  "subSteps": [
                                    "Revise detecção em runtime em linguagens como Python (ex: TypeError em execução).",
                                    "Aprenda sobre type hints (PEP 484) e ferramentas como mypy para checagem estática opcional.",
                                    "Teste código Python sem hints que falha em runtime vs com hints e mypy.",
                                    "Avalie riscos mitigados: hints não previnem runtime errors, mas auxiliam IDEs e linters.",
                                    "Liste limitações: flexibilidade dinâmica vs potenciais erros tardios."
                                  ],
                                  "verification": "Executar mypy em código Python com e sem hints, registrando warnings/erros.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python 3.10+, mypy instalado, exemplos de código em Jupyter Notebook.",
                                  "tips": "Instale mypy via pip e rode 'mypy arquivo.py --strict' para rigor.",
                                  "learningObjective": "Identificar como type hints mitigam riscos em tipagem dinâmica sem sacrificar flexibilidade.",
                                  "commonMistakes": "Achar que type hints tornam Python totalmente estático; ignorar que falham em runtime."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Vantagens e Desvantagens das Estratégias",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: detecção precoce (estática) vs hints dinâmicos.",
                                    "Analise trade-offs: robustez/velocidade de desenvolvimento vs performance/flexibilidade.",
                                    "Discuta cenários: estática para apps críticos (bancos), dinâmica para protótipos rápidos.",
                                    "Quantifique: tempo médio para detectar erros em cada abordagem via exemplos.",
                                    "Sintetize prós (robustez estática) vs contras (overhead) e mitigações dinâmicas."
                                  ],
                                  "verification": "Produzir tabela Markdown/PDF com pelo menos 5 métricas comparativas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Ferramenta de tabela como Google Sheets ou Markdown editor.",
                                  "tips": "Use critérios como 'tempo de detecção', 'facilidade de refatoração', 'overhead de tooling'.",
                                  "learningObjective": "Analisar trade-offs quantitativos e qualitativos entre estratégias.",
                                  "commonMistakes": "Viés para uma abordagem sem considerar contexto; omitir custos de manutenção."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Comparação em um Caso Prático",
                                  "subSteps": [
                                    "Escolha um snippet de código misto (ex: função de validação de dados).",
                                    "Implemente em TypeScript (estática) e Python com hints, simulando erros.",
                                    "Meça tempo de detecção e robustez ao alterar código.",
                                    "Registre lições: quando estática vence vs dinâmica com hints.",
                                    "Reflita sobre escolha de estratégia por projeto."
                                  ],
                                  "verification": "Relatório curto com códigos, outputs de erros e conclusão recomendada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "VS Code, Node.js para TS, Python/mypy.",
                                  "tips": "Introduza erros intencionais como TypeError ou mismatch de tipos.",
                                  "learningObjective": "Aplicar comparação para decidir estratégias em cenários reais.",
                                  "commonMistakes": "Exemplos triviais sem impacto real; não testar refatorações."
                                }
                              ],
                              "practicalExample": "Compare uma função de processamento de JSON: Em TypeScript, erro de tipo 'string' para 'number' falha no compile. Em Python sem hints, falha em runtime; com hints e mypy, warning pré-runtime, mas permite execução flexível para dados dinâmicos.",
                              "finalVerifications": [
                                "Pode listar 3 vantagens da detecção estática para robustez.",
                                "Explica como type hints mitigam riscos dinâmicos sem torná-la estática.",
                                "Cria tabela comparativa com trade-offs precisos.",
                                "Identifica cenários ideais para cada estratégia.",
                                "Demonstra com código real detecção em ambas abordagens.",
                                "Reflete sobre impacto em ciclos de desenvolvimento."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção entre detecção compile-time e runtime (30%).",
                                "Profundidade da análise de trade-offs (25%).",
                                "Uso de exemplos concretos e testáveis (20%).",
                                "Clareza na tabela/comparação (15%).",
                                "Conexão com contextos reais de projeto (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica formal e provas de correção de tipos.",
                                "Design de Software: Princípios de SOLID e refatoração segura.",
                                "Gestão de Projetos: Trade-offs custo-benefício em tooling.",
                                "Segurança da Informação: Prevenção de erros em apps críticos."
                              ],
                              "realWorldApplication": "Em equipes de devops, usar tipagem estática em microsserviços para evitar downtimes; em data science, tipagem dinâmica com hints para scripts rápidos de análise de dados variáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.4",
                "name": "Tipos de Dados e Operadores",
                "description": "Estudo de tipos de dados básicos e operadores em contextos orientados a objetos.",
                "totalSkills": 62,
                "atomicTopics": [
                  {
                    "id": "10.1.4.1",
                    "name": "Tipos de Dados Primitivos em POO",
                    "description": "Estudo dos tipos básicos como inteiros, floats, booleanos e strings em linguagens orientadas a objetos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.1.1.1",
                        "name": "Tipos Inteiros Primitivos em POO",
                        "description": "Estudo dos tipos de dados inteiros (int) em linguagens orientadas a objetos, como Python e Java, destacando que em Python os inteiros são objetos imutáveis com métodos, enquanto em Java existem primitivos int e classes wrapper Integer para integração com POO.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.1.1",
                            "name": "Declarar e inicializar variáveis inteiras",
                            "description": "Criar variáveis do tipo inteiro em Python (ex: x = 42) e Java (ex: int x = 42; ou Integer x = 42;), entendendo a diferença entre primitivos e objetos wrapper.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Fundamentais de Variáveis Inteiras",
                                  "subSteps": [
                                    "Defina o que é uma variável e seu papel em programação.",
                                    "Explique tipos de dados inteiros: limites e usos comuns (ex: int em Java: -2^31 a 2^31-1; Python: arbitrariamente grande).",
                                    "Diferencie primitivos (valor direto) de objetos wrapper (referência).",
                                    "Identifique sintaxe básica: Python (x = 42), Java (int x = 42).",
                                    "Discuta escopo e inicialização obrigatória em Java."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre primitivos e wrappers, citando exemplos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação oficial Python (python.org) e Java (docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)",
                                  "tips": "Use diagramas para visualizar memória: primitivos no stack, wrappers no heap.",
                                  "learningObjective": "Compreender diferenças conceituais entre linguagens e tipos.",
                                  "commonMistakes": "Confundir Python (dinâmico) com Java (estático); ignorar overflow em primitivos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar e Inicializar Variáveis Inteiras em Python",
                                  "subSteps": [
                                    "Abra um editor Python (ex: IDLE ou VS Code).",
                                    "Crie uma variável inteira: x = 42.",
                                    "Imprima o valor e tipo: print(x, type(x)).",
                                    "Teste atribuições múltiplas: y = x; x = 100.",
                                    "Experimente operações básicas: z = x + y."
                                  ],
                                  "verification": "Execute código sem erros e confirme type(x) == int.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor Python (VS Code com extensão Python), terminal.",
                                  "tips": "Use REPL (python no terminal) para testes rápidos.",
                                  "learningObjective": "Dominar sintaxe dinâmica de Python para inteiros.",
                                  "commonMistakes": "Esquecer importações desnecessárias; usar aspas em números (torna string)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Declarar e Inicializar int Primitivo em Java",
                                  "subSteps": [
                                    "Crie uma classe Java básica com método main.",
                                    "Declare: int x; (sem inicializar, observe erro de compilação).",
                                    "Inicialize: int x = 42;",
                                    "Imprima: System.out.println(x);",
                                    "Teste overflow: int max = Integer.MAX_VALUE; max++;"
                                  ],
                                  "verification": "Compilar e executar sem warnings/erros, output correto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "IDE Java (IntelliJ ou Eclipse), JDK instalado.",
                                  "tips": "Sempre inicialize variáveis locais em Java para evitar erros.",
                                  "learningObjective": "Aplicar tipagem estática com primitivos int.",
                                  "commonMistakes": "Usar Integer sem new ou autoboxing; esquecer ponto-vírgula."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Integer Wrapper em Java e Comparações",
                                  "subSteps": [
                                    "Declare Integer x = 42; (autoboxing).",
                                    "Compare com primitivo: int y = x; System.out.println(x == y);",
                                    "Teste null: Integer z = null; (não compila se usado como primitivo sem unboxing).",
                                    "Crie código comparativo Python vs Java.",
                                    "Discuta quando usar wrapper (ex: coleções como ArrayList<Integer>)."
                                  ],
                                  "verification": "Código roda corretamente, distinguindo == (valor) vs equals() (objeto).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesma IDE Java, docs Oracle sobre autoboxing.",
                                  "tips": "Lembre: wrappers são imutáveis e custosos; prefira primitivos quando possível.",
                                  "learningObjective": "Diferenciar e usar wrappers adequadamente.",
                                  "commonMistakes": "Confundir == com equals() em wrappers; NullPointerException em unboxing."
                                }
                              ],
                              "practicalExample": "Em um programa de calculadora simples: Python - total = 0; itens = [10, 20]; for i in itens: total += i. Java - int total = 0; int[] itens = {10, 20}; for(int i : itens) total += i; Integer totalWrapper = total; System.out.println('Soma: ' + totalWrapper);",
                              "finalVerifications": [
                                "Declara e inicializa int em Python sem erros de tipo.",
                                "Compila e executa int primitivo em Java com valor correto.",
                                "Usa Integer wrapper corretamente, evitando NPE.",
                                "Explica diferenças primitivos vs wrappers em entrevista simulada.",
                                "Identifica overflow em int Java.",
                                "Converte entre Python int e Java int/Integer em código misto."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe 100% correta em ambos idiomas (sem erros de compilação/execução).",
                                "Demonstra compreensão conceitual (primitivos vs objetos).",
                                "Código limpo, com comentários explicando escolhas.",
                                "Testes incluem edge cases (0, MAX_VALUE, null para wrappers).",
                                "Tempo de execução eficiente, sem loops desnecessários.",
                                "Explicação verbal clara das diferenças."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações aritméticas com inteiros e limites numéricos.",
                                "Lógica: Fluxo de controle dependente de variáveis inteiras (loops, condições).",
                                "Física/Engenharia: Modelagem de contadores, velocidades inteiras aproximadas.",
                                "Banco de Dados: IDs inteiros como chaves primárias."
                              ],
                              "realWorldApplication": "Desenvolvimento de apps: contadores de usuários em e-commerce (Python backend), IDs de produtos em sistemas Java enterprise (ex: Spring Boot), jogos (pontuações inteiras), análise de dados (agregações numéricas em Pandas/Java Streams)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.1.2",
                            "name": "Realizar operações aritméticas com inteiros",
                            "description": "Executar soma, subtração, multiplicação, divisão inteira e módulo com inteiros, utilizando métodos de objetos como abs() em Python ou Math.abs() em Java.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender tipos inteiros primitivos e operações aritméticas básicas",
                                  "subSteps": [
                                    "Revise os tipos inteiros primitivos: int em Python e int em Java.",
                                    "Identifique as operações suportadas: soma (+), subtração (-), multiplicação (*), divisão inteira (// em Python, / em Java para inteiros), e módulo (%).",
                                    "Estude o método abs(): abs() em Python para int, e Math.abs() em Java para int.",
                                    "Compare precedência de operadores aritméticos e uso de parênteses.",
                                    "Execute exemplos simples no console interativo de Python ou compilador Java."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as diferenças entre divisão inteira e módulo, com um exemplo de abs(-5).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Python int: https://docs.python.org/3/library/functions.html#abs",
                                    "Documentação Java Math: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#abs-int-",
                                    "Editor de código como VS Code ou IDE online como Replit"
                                  ],
                                  "tips": "Sempre priorize legibilidade: use espaços ao redor de operadores.",
                                  "learningObjective": "Identificar e descrever corretamente todas as operações aritméticas com inteiros em Python e Java.",
                                  "commonMistakes": [
                                    "Confundir divisão float (/) com divisão inteira (// ou / em int Java)",
                                    "Esquecer import de Math em Java",
                                    "Não tratar negativos com abs()"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar soma e subtração com inteiros em código",
                                  "subSteps": [
                                    "Crie uma classe simples em Java ou função em Python para receber dois inteiros.",
                                    "Implemente soma: a + b e subtração: a - b.",
                                    "Teste com valores positivos e negativos, incluindo abs() para valores absolutos.",
                                    "Adicione prints ou returns para exibir resultados.",
                                    "Execute e depure com casos como 10 + (-5) e abs(-10) - 3."
                                  ],
                                  "verification": "Código roda sem erros e produz saídas corretas para 5 testes manuais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ambiente Python (IDLE ou Jupyter)",
                                    "JDK e editor Java (Eclipse ou IntelliJ Community)",
                                    "Casos de teste: pares de inteiros variados"
                                  ],
                                  "tips": "Use variáveis com nomes descritivos como num1, num2 para clareza.",
                                  "learningObjective": "Codificar e testar soma/subtração com inteiros, incluindo tratamento de negativos via abs().",
                                  "commonMistakes": [
                                    "Overflow em valores grandes (considere limites int)",
                                    "Não usar parênteses em expressões compostas",
                                    "Ignorar sinal em subtrações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar multiplicação, divisão inteira e módulo",
                                  "subSteps": [
                                    "Estenda o código anterior para incluir a * b, a // b (Python) ou a / b (int Java), e a % b.",
                                    "Lide com divisão por zero: use try-except em Python ou if-check em Java.",
                                    "Incorpore abs() em cenários como módulo de negativos.",
                                    "Crie uma função que realize todas as operações em uma classe OO.",
                                    "Teste com exemplos: 10 * 3, 10 // 3, 10 % 3, abs(-10) % 3."
                                  ],
                                  "verification": "Função executa todas operações corretamente em 10 casos, incluindo edge cases como divisão por zero.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Mesmos do step anterior",
                                    "Lista de testes: [ (10,3), (-10,3), (10,0), (0,5) ]"
                                  ],
                                  "tips": "Lembre-se: em Java, / em ints é divisão inteira; % funciona similar ao Python.",
                                  "learningObjective": "Implementar multiplicação, divisão inteira e módulo com verificação de erros.",
                                  "commonMistakes": [
                                    "Divisão por zero sem tratamento",
                                    "Confundir // (Python floor) com / (truncating em Java)",
                                    "Módulo negativo inconsistente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar operações em um programa OO completo e verificar",
                                  "subSteps": [
                                    "Crie uma classe ArithmeticOperations com métodos para cada operação, usando int primitivos.",
                                    "Instancie a classe e chame métodos em main() (Java) ou script (Python).",
                                    "Adicione abs() como método utilitário.",
                                    "Execute um fluxo completo: leia inputs, compute, exiba resultados.",
                                    "Refatore para reutilização em contextos POO."
                                  ],
                                  "verification": "Programa processa inputs múltiplos e outputs corretos, sem crashes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador/interpretador",
                                    "Exemplos de input: 15, 4; -20, 6"
                                  ],
                                  "tips": "Encapsule lógica em métodos para modularidade POO.",
                                  "learningObjective": "Construir um módulo OO reutilizável para operações aritméticas com inteiros.",
                                  "commonMistakes": [
                                    "Não encapsular em classe/métodos",
                                    "Misturar tipos (int vs long)",
                                    "Ignorar validação de inputs"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de gerenciamento de estoque, calcule o saldo após venda: estoque_inicial (100) - quantidade_vendida (25) = 75; custo_total = quantidade * preco_unitario (25 * 2) = 50; resto = custo_total % 10 = 0; use abs() para estoque negativo temporário.",
                              "finalVerifications": [
                                "Código executa soma, subtração, multiplicação, divisão inteira e módulo corretamente para 10 pares de inteiros variados.",
                                "Método abs() é usado apropriadamente em pelo menos 3 cenários negativos.",
                                "Tratamento de divisão por zero previne crashes.",
                                "Resultados batem com calculadora manual em casos edge (0, negativos, grandes números).",
                                "Código está estruturado em classe OO com métodos dedicados.",
                                "Explicação oral cobre precedência e diferenças Python/Java."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 100% dos resultados corretos (40%)",
                                "Cobertura de operações: Todas 5 operações + abs() implementadas (20%)",
                                "Tratamento de erros: Divisão zero e inputs inválidos gerenciados (15%)",
                                "Estrutura OO: Encapsulamento em classe/métodos (15%)",
                                "Eficiência e legibilidade: Código limpo, comentado, sem warnings (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Reforça aritmética elementar e propriedades de inteiros.",
                                "Lógica/Algoritmos: Introduz controle de fluxo para erros.",
                                "Física/Engenharia: Aplicações em cálculos de forças/vetores discretos.",
                                "Economia: Operações em finanças como saldos e juros simples."
                              ],
                              "realWorldApplication": "Desenvolvimento de software para apps de finanças (cálculo de saldos bancários), jogos (pontuações e vidas), e sistemas embarcados (controle de sensores com contadores inteiros)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.1.3",
                            "name": "Converter inteiros para outros tipos",
                            "description": "Converter inteiros para string (str(42) em Python) ou float, e vice-versa, explorando métodos como int() e toString() em contextos OO.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e praticar conversão de inteiro para string em Python",
                                  "subSteps": [
                                    "Leia a documentação de str() no Python oficial.",
                                    "Escreva código simples: resultado = str(42); print(resultado).",
                                    "Experimente com inteiros negativos: str(-100).",
                                    "Compare tipos: type(42) vs type(str(42)).",
                                    "Use em concatenação: 'Idade: ' + str(25)."
                                  ],
                                  "verification": "Execute o código e confirme que '42' é impresso como string sem erros de tipo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor Python (IDLE ou VS Code), documentação Python.org",
                                  "tips": "Sempre verifique o tipo com isinstance() após conversão.",
                                  "learningObjective": "Dominar str() para converter int em string de forma segura.",
                                  "commonMistakes": "Esquecer parênteses em str(42) ou tentar somar int e string diretamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar conversão de inteiro para float e vice-versa",
                                  "subSteps": [
                                    "Teste float(42) e int(3.14), observe truncamento.",
                                    "Pratique com float(42.0) e int(float(42)).",
                                    "Lide com casos edge: int(float('inf')) e float('nan').",
                                    "Use em cálculos: total = int(10.9 * 2).",
                                    "Compare precisão: print(float(42) == 42.0)."
                                  ],
                                  "verification": "Confirme que int(3.14) retorna 3 e float(42) permite operações decimais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Console Python interativo (REPL), calculadora para validação",
                                  "tips": "int() trunca, use math.floor() para arredondar corretamente.",
                                  "learningObjective": "Compreender perdas de precisão em conversões numéricas.",
                                  "commonMistakes": "Ignorar truncamento em int(3.99) resultando em 3, não 4."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar métodos de conversão em classes OO (Python e Java-like)",
                                  "subSteps": [
                                    "Crie uma classe Python com __str__: class Numero: def __init__(self, v): self.valor = v; def __str__(self): return str(self.valor).",
                                    "Instancie e teste: n = Numero(42); print(str(n)).",
                                    "Simule toString() em pseudocódigo Java: public String toString() { return String.valueOf(this.valor); }.",
                                    "Sobrescreva em herança: classe derivada com formatação customizada.",
                                    "Teste coerção automática em print()."
                                  ],
                                  "verification": "A classe imprime '42' corretamente via str() sem acessar atributo diretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor com suporte a Python/Java, exemplos de classes POO",
                                  "tips": "Em Python, __str__ é chamado por str(), __repr__ por repr().",
                                  "learningObjective": "Aplicar conversões em objetos OO para representação legível.",
                                  "commonMistakes": "Retornar self.valor diretamente sem str(), causando TypeError em concatenação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar conversões reversas e lidar com exceções",
                                  "subSteps": [
                                    "Converta string para int: int('42'), trate ValueError com try-except.",
                                    "Float para int: int('3.14'), valide entrada.",
                                    "Crie função segura: def safe_int(s): try: return int(s); except: return 0.",
                                    "Teste com inputs inválidos: int('abc'), int('42.5').",
                                    "Integre em loop de usuário para parsing de input()."
                                  ],
                                  "verification": "Função lida com 'abc' retornando 0 sem crashar o programa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Scripts de teste com inputs variados",
                                  "tips": "Use int(s, base=10) para bases numéricas como hex.",
                                  "learningObjective": "Gerenciar erros em conversões bidirecionais de forma robusta.",
                                  "commonMistakes": "Não tratar ValueError, causando crash em inputs ruins."
                                }
                              ],
                              "practicalExample": "Em um jogo simples Python: class Score: def __init__(self, pontos): self.pontos = pontos; def __str__(self): return f'Pontos: {str(self.pontos)}'; s = Score(150); print(str(s) + ' - Parabéns!')  # Saída: 'Pontos: 150 - Parabéns!'",
                              "finalVerifications": [
                                "Converte 42 para '42' e concatena sem erro.",
                                "int('3.14') retorna 3 corretamente.",
                                "Classe OO imprime valor inteiro como string formatada.",
                                "Função safe_int('abc') retorna 0 sem exceção.",
                                "float(42) == 42.0 é True.",
                                "toString() simulado retorna String.valueOf(valor)."
                              ],
                              "assessmentCriteria": [
                                "Código executa sem erros de tipo em todas conversões.",
                                "Uso correto de try-except para entradas inválidas.",
                                "Classes OO sobrescrevem __str__ ou toString adequadamente.",
                                "Verificação de tipos com isinstance() em testes.",
                                "Exemplos incluem casos edge como negativos e não-numéricos.",
                                "Tempo de execução dentro do estimado com eficiência."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Compreensão de truncamento e precisão numérica.",
                                "Língua Portuguesa/Inglês: Leitura de documentação e formatação de strings.",
                                "Lógica: Tratamento de exceções como fluxos condicionais.",
                                "Design de Software: Encapsulamento em classes OO."
                              ],
                              "realWorldApplication": "Em aplicativos web/bancários, converter IDs inteiros para strings em JSON APIs; em jogos, exibir scores como texto formatado; parsing de dados de usuário em forms para evitar crashes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.1.2",
                        "name": "Tipos de Ponto Flutuante em POO",
                        "description": "Análise dos tipos float para números reais em linguagens OO, como float em Python (objeto com métodos) e double/float em Java, enfatizando precisão e representação binária.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.2.1",
                            "name": "Declarar e inicializar variáveis float",
                            "description": "Definir variáveis float em Python (ex: y = 3.14) e Java (ex: double y = 3.14;), reconhecendo-as como objetos com acesso a métodos como is_integer().",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos básicos de variáveis float em Python e Java",
                                  "subSteps": [
                                    "Estude a definição de float: representação de números de ponto flutuante para decimais precisos.",
                                    "Compare float em Python (objeto built-in) com double/float em Java (primitivos que podem ser boxed para objetos).",
                                    "Identifique limitações: precisão finita e possíveis erros de arredondamento.",
                                    "Revise sintaxe básica: Python usa 'float()', Java usa 'double' ou 'float'.",
                                    "Anote diferenças: Python floats têm métodos como is_integer(), Java usa wrappers como Double."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre float em Python e Java, incluindo exemplos de uso.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação oficial Python (docs.python.org) e Java (docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html), notebook de anotações.",
                                  "tips": "Use diagramas para visualizar a hierarquia de tipos em cada linguagem.",
                                  "learningObjective": "Diferenciar float como tipo de dado em Python e Java, reconhecendo suas características como objetos.",
                                  "commonMistakes": "Confundir float com int; ignorar que Java double é 64-bit por padrão."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar e inicializar variáveis float em Python",
                                  "subSteps": [
                                    "Abra um interpretador Python ou IDE.",
                                    "Declare uma variável float: y = 3.14 ou y = float(3.14).",
                                    "Teste inicialização com diferentes valores: inteiros (3.0), strings ('3.14'), expressões (2 * 1.57).",
                                    "Imprima o tipo com type(y) e valor com print(y).",
                                    "Explore método is_integer(): print(y.is_integer()) para y=3.14 (False) e y=3.0 (True)."
                                  ],
                                  "verification": "Execute código que declara y=3.14, imprime type(y) como <class 'float'>, e verifica y.is_integer() retornando False.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python IDLE, Jupyter Notebook ou VSCode com extensão Python.",
                                  "tips": "Sempre use ponto (.) para decimal, não vírgula.",
                                  "learningObjective": "Inicializar corretamente floats em Python e acessar métodos básicos de objeto.",
                                  "commonMistakes": "Esquecer parênteses em float(); usar aspas em vez de ponto decimal."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Declarar e inicializar variáveis float em Java",
                                  "subSteps": [
                                    "Crie uma classe Java simples em uma IDE.",
                                    "Declare double y = 3.14; e float x = 3.14f; (note o 'f' para float).",
                                    "Inicialize com literais, casting: double z = (double) 3;",
                                    "Use System.out.println(y) e imprima tipo com reflexão ou boxing: Double.valueOf(y).",
                                    "Acesse métodos de objeto: Double.isNaN(Double.valueOf(y)) ou similar para verificações."
                                  ],
                                  "verification": "Compile e execute código Java que declara double y=3.14, imprime 3.14 sem erros, e verifica se é finito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "IntelliJ IDEA, Eclipse ou VSCode com Java extension pack.",
                                  "tips": "Adicione 'f' ou 'F' para literais float em Java para evitar erros de compilação.",
                                  "learningObjective": "Implementar declaração e inicialização de double/float em Java, entendendo boxing para métodos.",
                                  "commonMistakes": "Esquecer 'f' em float literals; confundir double com Float wrapper."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e verificar uso integrado de floats em ambos os contextos",
                                  "subSteps": [
                                    "Escreva um programa Python que declara múltiplos floats e usa is_integer() em uma condição if.",
                                    "Em Java, crie um método que recebe double, verifica se é inteiro via Math.floor() == valor.",
                                    "Compare saídas de cálculos idênticos: PI * 2 em ambas linguagens.",
                                    "Debugue erros comuns como divisão por zero resultando em Infinity.",
                                    "Documente o código com comentários explicando cada declaração."
                                  ],
                                  "verification": "Rode ambos os códigos, capture saídas mostrando declarações corretas e métodos funcionando sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "IDEs para Python e Java, terminal para execução.",
                                  "tips": "Use print/debug statements para rastrear valores durante inicialização.",
                                  "learningObjective": "Aplicar declaração de floats em cenários práticos, integrando verificações de objeto.",
                                  "commonMistakes": "Ignorar precisão: 0.1 + 0.2 != 0.3; não tratar NaN/Infinity."
                                }
                              ],
                              "practicalExample": "Em Python: pi = 3.14159; print(pi.is_integer())  # False\nEm Java: double pi = 3.14159; System.out.println(Math.floor(pi) == pi ? \"Inteiro\" : \"Float\");  // Float. Use para calcular área de círculo: area = pi * r * r.",
                              "finalVerifications": [
                                "Declara float em Python sem TypeError e acessa is_integer() corretamente.",
                                "Compila e executa declaração double/float em Java sem erros de tipo.",
                                "Identifica corretamente se um float representa inteiro em ambos.",
                                "Calcula expressões decimais (ex: 1.5 * 2) com resultados precisos.",
                                "Explica diferenças entre primitivos Java e objetos Python.",
                                "Debuga e corrige erros comuns como literal sem 'f' em Java."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sintaxe de declaração (100% correto em ambos).",
                                "Demonstração de métodos de objeto (is_integer() ou equivalentes).",
                                "Tratamento de casos edge (inteiros como float, NaN).",
                                "Explicação clara de conceitos em relatório ou comentários.",
                                "Eficiência no tempo: completa em <80 minutos total.",
                                "Código limpo, legível e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação de números reais e precisão decimal.",
                                "Física: Modelagem de medidas contínuas como velocidade (m/s).",
                                "Engenharia de Software: Gerenciamento de tipos de dados em aplicações numéricas.",
                                "Estatística: Cálculos de médias e desvios com floats."
                              ],
                              "realWorldApplication": "Em simulações científicas (ex: trajetórias em jogos com física), finanças (cálculo de juros compostos com decimais), gráficos (coordenadas x,y em apps de visualização de dados)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.2.2",
                            "name": "Executar operações com floats",
                            "description": "Realizar operações aritméticas com floats, incluindo tratamento de precisão (ex: arredondamento com round() em Python ou Math.round() em Java).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e declarar variáveis float",
                                  "subSteps": [
                                    "Explicar a diferença entre inteiros (int) e floats (ponto flutuante) em termos de precisão e representação",
                                    "Declarar floats em Python: `pi = 3.14159` ou em Java: `double pi = 3.14159;`",
                                    "Verificar o tipo da variável usando `type()` em Python ou `getClass().getSimpleName()` em Java",
                                    "Criar e imprimir 5 variáveis float com valores decimais variados",
                                    "Experimentar conversão de int para float: `float(5)`"
                                  ],
                                  "verification": "Executar código que declara e imprime tipos e valores de floats corretamente sem erros",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (PyCharm, VSCode ou Eclipse)",
                                    "Documentação oficial de Python (float) e Java (double)"
                                  ],
                                  "tips": "Sempre use ponto (.) como separador decimal, independentemente da configuração regional",
                                  "learningObjective": "Identificar e declarar corretamente variáveis de ponto flutuante em linguagens de programação",
                                  "commonMistakes": [
                                    "Usar vírgula (,) em vez de ponto para decimais",
                                    "Confundir float com int ao atribuir valores inteiros sem conversão explícita"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar operações aritméticas básicas com floats",
                                  "subSteps": [
                                    "Realizar adição e subtração: `2.5 + 3.7` e `10.0 - 4.2`",
                                    "Executar multiplicação e divisão: `3.14 * 2` e `10.0 / 3`",
                                    "Aplicar potência: `2.0 ** 3` em Python ou `Math.pow(2.0, 3)` em Java",
                                    "Combinar múltiplas operações em uma expressão: `(5.5 + 2.3) * 1.1`",
                                    "Imprimir todos os resultados com `print()` ou `System.out.println()`"
                                  ],
                                  "verification": "Resultados das operações correspondem aos valores esperados quando impressos",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora para validar resultados manuais",
                                    "Ambiente de execução Python ou Java"
                                  ],
                                  "tips": "Use parênteses para controlar a ordem de operações e evitar ambiguidades",
                                  "learningObjective": "Realizar operações aritméticas básicas (+, -, *, /, **) com floats de forma precisa",
                                  "commonMistakes": [
                                    "Ignorar a precedência de operadores levando a resultados errados",
                                    "Dividir por zero acidentalmente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar problemas de precisão em operações com floats",
                                  "subSteps": [
                                    "Demonstrar imprecisão clássica: `0.1 + 0.2` em Python (resultado ≈ 0.30000000000000004)",
                                    "Explicar representação binária de floats e por que 0.1 não é exato em binário",
                                    "Testar comparações diretas: `if 0.1 + 0.2 == 0.3` (falso)",
                                    "Executar 3-5 operações que revelam imprecisão, como somas repetidas de 0.1",
                                    "Comparar resultados com cálculos manuais ou em papel"
                                  ],
                                  "verification": "Identificar e documentar pelo menos 3 casos onde o resultado float difere do esperado matematicamente",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigo sobre 'floating point arithmetic' (IEEE 754)",
                                    "Notebook Jupyter para experimentos interativos"
                                  ],
                                  "tips": "Nunca use comparações exatas (==) com floats; prefira tolerâncias como `abs(a - b) < 1e-9`",
                                  "learningObjective": "Reconhecer limitações de precisão inerentes aos floats e seus impactos em cálculos",
                                  "commonMistakes": [
                                    "Assumir precisão infinita como em números reais da matemática",
                                    "Ignorar pequenas discrepâncias nos resultados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar tratamento de precisão com funções de arredondamento",
                                  "subSteps": [
                                    "Usar `round(valor, casas)` em Python: `round(2.675, 2)` resulta em 2.68",
                                    "Em Java: `Math.round(valor * 100.0) / 100.0` para 2 casas decimais",
                                    "Aplicar em operações reais: arredondar resultado de `0.1 + 0.2` para 1 casa",
                                    "Formatar saída com f-strings em Python (`{valor:.2f}`) ou `String.format()` em Java",
                                    "Testar cenários com diferentes números de casas decimais e validar"
                                  ],
                                  "verification": "Códigos com arredondamento produzem resultados precisos e consistentes com expectativas",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação round() Python e Math Java",
                                    "Exemplos de código prontos para modificação"
                                  ],
                                  "tips": "Escolha o número de casas decimais baseado no contexto (ex: 2 para finanças)",
                                  "learningObjective": "Tratar problemas de precisão usando funções de arredondamento e formatação",
                                  "commonMistakes": [
                                    "Arredondar prematuramente perdendo precisão em cálculos intermediários",
                                    "Confundir banker's rounding em Python"
                                  ]
                                }
                              ],
                              "practicalExample": "Calcule a área de um círculo com raio 5.5: `area = 3.14159 * 5.5 ** 2`. Sem tratamento: ≈95.0331771. Com `round(area, 2)`: 95.03. Em seguida, aplique desconto de 12.5%: `final = round(area * 0.875, 2)` e imprima formatado.",
                              "finalVerifications": [
                                "Todas as declarações de float são corretas e tipadas adequadamente",
                                "Operações aritméticas produzem resultados sem erros de execução",
                                "Pelo menos um exemplo de imprecisão é identificado e demonstrado",
                                "Funções de arredondamento são aplicadas corretamente em 3+ cenários",
                                "Resultados finais são formatados e arredondados conforme especificado",
                                "Código roda em Python e/ou Java sem warnings de precisão"
                              ],
                              "assessmentCriteria": [
                                "Precisão e correção em todas as operações aritméticas (90%+ acurácia)",
                                "Demonstração clara de problemas de precisão e soluções",
                                "Uso apropriado de round() ou equivalentes com justificativa",
                                "Código limpo, comentado e reproduzível",
                                "Eficiência no tratamento de casas decimais contextualizadas",
                                "Capacidade de debugar erros comuns de float"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações com números reais e aproximações decimais",
                                "Física: Cálculos de grandezas com medidas (ex: velocidade, aceleração)",
                                "Economia/Finanças: Arredondamento em cálculos de impostos e descontos",
                                "Estatística: Manipulação de dados decimais em análises",
                                "Engenharia de Software: Boas práticas em representação numérica"
                              ],
                              "realWorldApplication": "Em sistemas financeiros como apps de banco para calcular juros compostos com arredondamento preciso evitando discrepâncias em saldos; em jogos para física realista (colisões com velocidades float); ou em simulações científicas para modelar fenômenos contínuos com tratamento de precisão."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.2.3",
                            "name": "Gerenciar conversões de float",
                            "description": "Converter float para int (int(3.14)), string e vice-versa, utilizando métodos OO como float() e toString().",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os conceitos básicos de conversão de tipos para float",
                                  "subSteps": [
                                    "Revise os tipos de dados primitivos em POO: float representa números com decimais.",
                                    "Identifique cenários onde conversões são necessárias, como entrada de usuário ou cálculos precisos.",
                                    "Estude o casting implícito vs explícito em linguagens OO como Python ou Java.",
                                    "Analise exemplos iniciais: float(3) resulta em 3.0.",
                                    "Discuta perda de precisão em conversões bidirecionais."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre float e int, com um exemplo de conversão.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação oficial da linguagem (ex: Python docs para float)",
                                    "Editor de código como VS Code"
                                  ],
                                  "tips": "Sempre priorize conversões explícitas para evitar erros silenciosos.",
                                  "learningObjective": "Compreender quando e por que converter float para outros tipos em contextos OO.",
                                  "commonMistakes": [
                                    "Confundir casting com operações aritméticas",
                                    "Ignorar overflow em conversões para int"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Praticar conversão de float para int e vice-versa",
                                  "subSteps": [
                                    "Escreva código para converter float para int: int(3.14) resulta em 3 (truncado).",
                                    "Teste com float para float via construtor OO: float(3.14).",
                                    "Converta int para float: float(5) resulta em 5.0.",
                                    "Crie uma função simples que receba float e retorne int truncado.",
                                    "Execute testes com valores negativos e zero: int(-2.7) = -2."
                                  ],
                                  "verification": "Execute o código e confirme saídas corretas para 5 valores de teste variados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ambiente de execução Python ou Java REPL",
                                    "Notebook Jupyter para testes interativos"
                                  ],
                                  "tips": "Use round() antes de int() se precisar de arredondamento em vez de truncamento.",
                                  "learningObjective": "Dominar conversões float ↔ int usando funções built-in e métodos OO.",
                                  "commonMistakes": [
                                    "Esperar arredondamento automático em int(float)",
                                    "Não tratar exceções em entradas inválidas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar conversões entre float e string",
                                  "subSteps": [
                                    "Converta float para string: str(3.14) ou em Java: Float.toString(3.14f).",
                                    "Converta string para float: float('3.14') ou Float.parseFloat('3.14').",
                                    "Teste formatação: '{:.2f}'.format(3.14159) para precisão.",
                                    "Crie um programa que leia string de input e converta para float, depois para string formatada.",
                                    "Lide com strings inválidas usando try-except para ValueError."
                                  ],
                                  "verification": "Desenvolva um snippet que converta bidirecionalmente sem erros para 4 casos (válido, inválido, decimal, científico).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Console interativo",
                                    "Exemplos de documentação str() e float()"
                                  ],
                                  "tips": "Use try-except para entradas de usuário que podem ser strings malformadas.",
                                  "learningObjective": "Aplicar métodos OO para conversões float ↔ string de forma segura.",
                                  "commonMistakes": [
                                    "Não especificar precisão em str(float)",
                                    "Ignorar notação científica como '1e3'"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar conversões em um fluxo OO completo",
                                  "subSteps": [
                                    "Crie uma classe simples (ex: Calculadora) com métodos que usam conversões float.",
                                    "Implemente um método que processe input string → float → int → string output.",
                                    "Adicione validação e tratamento de erros em cada conversão.",
                                    "Teste com dados reais: simule entrada de preço decimal.",
                                    "Refatore para usar propriedades OO como getters/setters para tipos float."
                                  ],
                                  "verification": "A classe executa sem erros e produz saídas corretas para um conjunto de testes unitários.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "IDE com suporte a POO (PyCharm ou IntelliJ)",
                                    "Framework de testes como unittest"
                                  ],
                                  "tips": "Encapsule conversões em métodos privados para reutilização.",
                                  "learningObjective": "Combinar múltiplas conversões em aplicações OO práticas.",
                                  "commonMistakes": [
                                    "Misturar tipos sem conversão explícita causando TypeError",
                                    "Perda de dados por conversões desnecessárias"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de e-commerce OO, converta o preço unitário (float 19.99) para quantidade inteira de itens (int), formate para string de recibo ('Total: R$ 39.98'), lendo input do usuário como string.",
                              "finalVerifications": [
                                "Consegue converter float para int sem erros de truncamento inesperado.",
                                "Realiza conversões string ↔ float com tratamento de exceções.",
                                "Integra conversões em classes OO sem TypeErrors.",
                                "Explica impactos de precisão em aplicações reais.",
                                "Testa bidirecionalmente com 10 valores variados.",
                                "Usa formatação adequada para strings de float."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas conversões (sem perda desnecessária de dados).",
                                "Tratamento robusto de erros e entradas inválidas.",
                                "Código limpo com métodos OO dedicados.",
                                "Eficiência temporal e legibilidade.",
                                "Cobertura de casos edge (negativos, zero, científicos).",
                                "Documentação inline explicando cada conversão."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de arredondamento e precisão numérica.",
                                "Física: Conversões em simulações de medidas decimais (velocidade, aceleração).",
                                "Economia: Cálculos financeiros com moedas decimais.",
                                "Inglês: Leitura de docs técnicas sobre tipos de dados."
                              ],
                              "realWorldApplication": "Desenvolvimento de apps financeiros (conversão de saldos decimais para relatórios inteiros), jogos (posições float para grid int), e parsing de dados JSON (strings numéricas para float em APIs)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.1.3",
                        "name": "Tipos Booleanos em POO",
                        "description": "Exploração do tipo booleano (bool) em POO, verdadeiro/falso, com suporte a operadores lógicos e métodos em linguagens como Python (True/False como subclasses de int) e Java (boolean primitive e Boolean wrapper).",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.3.1",
                            "name": "Declarar e usar variáveis booleanas",
                            "description": "Criar booleanos em Python (ex: ativo = True) e Java (boolean ativo = true;), entendendo seu uso em estruturas condicionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos básicos de valores booleanos",
                                  "subSteps": [
                                    "Estude a definição: booleanos representam valores lógicos verdadeiro (True/true) ou falso (False/false).",
                                    "Analise exemplos cotidianos: 'Está chovendo?' (sim/não).",
                                    "Compare com outros tipos: inteiros (números), strings (texto).",
                                    "Identifique operadores lógicos: == (igual), != (diferente), >, <.",
                                    "Pratique mentalmente: 5 > 3 é True."
                                  ],
                                  "verification": "Responda corretamente a 5 perguntas sobre o que é um booleano e dê exemplos de expressões booleanas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial Python (tipos de dados)",
                                    "Documentação Oracle Java (primitive types)",
                                    "Vídeo introdutório sobre lógica booleana (5 min)"
                                  ],
                                  "tips": [
                                    "Sempre capitalize True/False em Python; use true/false em Java.",
                                    "Pense em booleanos como interruptores on/off."
                                  ],
                                  "learningObjective": "Dominar a definição e exemplos iniciais de valores booleanos em programação.",
                                  "commonMistakes": [
                                    "Confundir booleanos com strings como 'true'",
                                    "Usar 1/0 em vez de True/false",
                                    "Ignorar sensibilidade a maiúsculas em Python"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar variáveis booleanas em Python",
                                  "subSteps": [
                                    "Abra um editor Python (ex: IDLE ou VS Code).",
                                    "Crie uma variável: ativo = True",
                                    "Atribua via expressão: logado = 'senha' == '123'",
                                    "Imprima o valor: print(ativo)",
                                    "Teste alteração: ativo = False; print(ativo)"
                                  ],
                                  "verification": "Execute código sem erros e imprima valores booleanos corretos no console.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor Python instalado",
                                    "Console interativo Python",
                                    "Notebook Jupyter opcional"
                                  ],
                                  "tips": [
                                    "Use nomes descritivos como 'isActive' para clareza.",
                                    "Booleanos em Python não precisam de tipo explícito."
                                  ],
                                  "learningObjective": "Declarar e inicializar variáveis booleanas em Python de forma correta.",
                                  "commonMistakes": [
                                    "Esquecer aspas em strings de comparação",
                                    "Usar = em vez de == para comparação",
                                    "Declarar como int: ativo = 1"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Declarar variáveis booleanas em Java",
                                  "subSteps": [
                                    "Crie uma classe Java básica.",
                                    "Declare: boolean ativo = true;",
                                    "Atribua via expressão: boolean logado = senha.equals('123');",
                                    "Compile e execute: System.out.println(ativo);",
                                    "Teste com false e operadores: boolean maior = 5 > 3;"
                                  ],
                                  "verification": "Compilar e rodar o programa Java sem erros de sintaxe, exibindo valores booleanos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "JDK instalado",
                                    "Editor como IntelliJ ou Eclipse",
                                    "Terminal para javac/java"
                                  ],
                                  "tips": [
                                    "Sempre use 'boolean' minúsculo; true/false também minúsculos.",
                                    "Strings em Java usam .equals(), não ==."
                                  ],
                                  "learningObjective": "Declarar e inicializar variáveis booleanas primitivas em Java.",
                                  "commonMistakes": [
                                    "Usar Boolean (wrapper) em vez de boolean (primitivo)",
                                    "Esquecer ponto e vírgula",
                                    "Comparar strings com =="
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Usar variáveis booleanas em estruturas condicionais",
                                  "subSteps": [
                                    "Em Python: if ativo: print('Sistema ativo')",
                                    "Em Java: if (ativo) { System.out.println('Sistema ativo'); }",
                                    "Combine expressões: if logado and nota >= 7: ...",
                                    "Use else: if not ativo: print('Inativo')",
                                    "Teste cenários: mude valores e verifique saídas."
                                  ],
                                  "verification": "Criar e executar programas que tomem decisões baseadas em booleanos em ambos os idiomas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editores de ambos os idiomas",
                                    "Exemplos de código prontos para referência"
                                  ],
                                  "tips": [
                                    "Evite if (x == true), use if (x) diretamente.",
                                    "Teste todos os ramos (true/false)."
                                  ],
                                  "learningObjective": "Aplicar booleanos em if/else para controle de fluxo.",
                                  "commonMistakes": [
                                    "Esquecer parênteses em Java",
                                    "Usar and em vez de && em Java",
                                    "Indentação errada em Python"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um validador de login: Crie variável booleana 'autenticado = usuario.equals('admin') && senha.equals('12345');'. Use if (autenticado) para imprimir 'Acesso concedido' em Java, ou if autenticado: print('Acesso concedido') em Python. Teste com credenciais erradas para ver 'Acesso negado'.",
                              "finalVerifications": [
                                "Declarar boolean em Python sem SyntaxError.",
                                "Declarar boolean em Java sem compile-time error.",
                                "Usar booleano em if/else produzindo saída correta.",
                                "Alterar valor booleano afeta o fluxo condicional.",
                                "Identificar e corrigir erros comuns em declarações.",
                                "Explicar diferença entre True/true e expressões booleanas."
                              ],
                              "assessmentCriteria": [
                                "Código compila/executa sem erros (100%).",
                                "Declarações usam sintaxe correta em ambos idiomas (90%).",
                                "Condicionais respondem corretamente a true/false (85%).",
                                "Nomes de variáveis são descritivos e lógicos (80%).",
                                "Comentários explicam uso do booleano (70%).",
                                "Testes cobrem múltiplos cenários (extra)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional e tabelas-verdade.",
                                "Física: Estados binários em circuitos lógicos (portas AND/OR).",
                                "Língua Portuguesa: Verdadeiro/falso em argumentos lógicos.",
                                "Ética: Decisões binárias em dilemas morais (sim/não)."
                              ],
                              "realWorldApplication": "Em aplicativos web para validar logins (autenticado = true), jogos para checar colisões (colidiu = true), sistemas bancários para aprovar transações (aprovada = saldo >= valor), e automação residencial para sensores (portaAberta = true ativando alarme)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.3.2",
                            "name": "Aplicar operadores lógicos booleanos",
                            "description": "Usar AND (and/&&), OR (or/||), NOT (not/!) com booleanos, explorando métodos como Boolean.logicalAnd() em Java.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos básicos dos operadores lógicos booleanos",
                                  "subSteps": [
                                    "Estude o operador AND (&& ou and): retorna true apenas se ambos os operandos forem true.",
                                    "Estude o operador OR (|| ou or): retorna true se pelo menos um operando for true.",
                                    "Estude o operador NOT (! ou not): inverte o valor booleano do operando.",
                                    "Analise tabelas-verdade para cada operador com exemplos simples.",
                                    "Compare os operadores em contextos lógicos cotidianos."
                                  ],
                                  "verification": "Crie uma tabela-verdade manual para AND, OR e NOT e explique verbalmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para tabelas-verdade",
                                    "Documentação Java sobre booleanos"
                                  ],
                                  "tips": "Use tabelas-verdade para visualizar todas as combinações possíveis.",
                                  "learningObjective": "Entender o comportamento lógico de AND, OR e NOT.",
                                  "commonMistakes": [
                                    "Confundir AND (ambos true) com OR (um true basta)",
                                    "Ignorar que NOT inverte sempre"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a sintaxe dos operadores em Java",
                                  "subSteps": [
                                    "Declare variáveis booleanas: boolean a = true; boolean b = false;",
                                    "Escreva expressões com &&: boolean resultado = a && b;",
                                    "Escreva expressões com ||: boolean resultado = a || b;",
                                    "Escreva expressões com !: boolean resultado = !a;",
                                    "Teste em um programa simples com System.out.println()."
                                  ],
                                  "verification": "Compile e execute um código que imprima resultados de expressões booleanas corretas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE como IntelliJ ou Eclipse",
                                    "JDK 8 ou superior"
                                  ],
                                  "tips": "Sempre use parênteses em expressões complexas para evitar ambiguidades.",
                                  "learningObjective": "Dominar a sintaxe de &&, || e ! em Java.",
                                  "commonMistakes": [
                                    "Usar = em vez de == para comparação",
                                    "Esquecer ponto e vírgula após declarações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar combinações de operadores lógicos",
                                  "subSteps": [
                                    "Crie expressões compostas: (a && b) || !c",
                                    "Incorpore em estruturas if-else: if ((idade >= 18) && (temPermissao)) { ... }",
                                    "Teste cenários com múltiplos booleanos.",
                                    "Debugue expressões incorretas alterando valores.",
                                    "Compare resultados esperados vs. obtidos."
                                  ],
                                  "verification": "Escreva e execute 5 expressões compostas com saídas corretas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE com console",
                                    "Exemplos de código online"
                                  ],
                                  "tips": "Lembre-se da precedência: ! > && > ||; use parênteses para clareza.",
                                  "learningObjective": "Aplicar operadores em expressões complexas e condicionais.",
                                  "commonMistakes": [
                                    "Ignorar precedência levando a lógicas erradas",
                                    "Não testar todos os casos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar métodos estáticos da classe Boolean",
                                  "subSteps": [
                                    "Estude Boolean.logicalAnd(boolean a, boolean b)",
                                    "Estude Boolean.logicalOr(boolean a, boolean b)",
                                    "Estude Boolean.logicalNot(boolean a)",
                                    "Compare métodos com operadores: Boolean.logicalAnd(a, b) vs. a && b",
                                    "Implemente um programa usando apenas métodos Boolean."
                                  ],
                                  "verification": "Converta um código com operadores para métodos Boolean e verifique equivalência.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial Java Boolean",
                                    "IDE para testes"
                                  ],
                                  "tips": "Métodos Boolean são úteis em contextos funcionais ou para legibilidade.",
                                  "learningObjective": "Usar métodos Boolean.logical* como alternativa aos operadores.",
                                  "commonMistakes": [
                                    "Confundir métodos estáticos com instância",
                                    "Passar non-booleanos sem wrapper"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um validador de acesso a um sistema: boolean podeAcessar = (idade >= 18 && usuarioAtivo) || isAdministrador; Use métodos Boolean para uma versão alternativa e teste com if-else para ações.",
                              "finalVerifications": [
                                "Explicar tabela-verdade de uma expressão composta.",
                                "Escrever código Java com &&, || e ! sem erros de compilação.",
                                "Converter operadores para métodos Boolean.logical* corretamente.",
                                "Debugar uma expressão lógica falha identificando o erro.",
                                "Aplicar em um if-else com 3 condições booleanas.",
                                "Prever resultado de expressões sem executar código."
                              ],
                              "assessmentCriteria": [
                                "Correção lógica das expressões (tabelas-verdade validadas).",
                                "Sintaxe Java impecável e compilável.",
                                "Uso adequado de precedência e parênteses.",
                                "Equivalência entre operadores e métodos Boolean.",
                                "Capacidade de debugar e testar cenários edge-case.",
                                "Clareza e comentários no código."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional e tabelas-verdade.",
                                "Física: Circuitos lógicos (portas AND/OR/NOT).",
                                "Matemática discreta: Álgebra booleana.",
                                "Lógica filosófica: Proposições verdadeiras/falsas."
                              ],
                              "realWorldApplication": "Validações de formulários (ex: email válido AND senha forte), filtros de busca (termo1 OR termo2 AND categoria), autenticação de usuários (logado AND permissões), automação de regras de negócio em apps empresariais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.3.3",
                            "name": "Converter valores para booleano",
                            "description": "Converter inteiros, strings ou floats para bool (bool(1) em Python), e usar valueOf() em Java.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender as regras de conversão para booleano em Python",
                                  "subSteps": [
                                    "Estude como bool() converte valores: 0, '', None, [], {} viram False; outros viram True.",
                                    "Teste conversões de inteiros: bool(0) -> False, bool(1) -> True, bool(-1) -> True.",
                                    "Teste strings: bool('') -> False, bool('0') -> True, bool('false') -> True.",
                                    "Teste floats: bool(0.0) -> False, bool(1.23) -> True.",
                                    "Anote as exceções: apenas valores 'falsy' viram False."
                                  ],
                                  "verification": "Execute pelo menos 10 exemplos no interpretador Python e confirme saídas esperadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Interpretador Python ou IDE como PyCharm/IDLE",
                                    "Documentação oficial Python: bool()"
                                  ],
                                  "tips": "Sempre priorize valores não-zero e não-vazios como True; memorize os 6 falsy principais.",
                                  "learningObjective": "Compreender as regras de coerção booleana em Python para qualquer tipo primitivo.",
                                  "commonMistakes": [
                                    "Confundir '0' (string) com 0 (int): '0' é True.",
                                    "Esquecer que [] e {} são falsy mesmo vazios.",
                                    "Achar que 'false' é False: é True por ser non-empty."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Praticar conversões bool() em código Python",
                                  "subSteps": [
                                    "Escreva uma função que converta input do usuário (int, str ou float) para bool.",
                                    "Crie testes unitários para casos edge: 0, '', 0.0, None.",
                                    "Implemente um script que valide se um número é 'positivo' via bool(conversao).",
                                    "Debugue erros comuns como TypeError em inputs inválidos.",
                                    "Refatore o código para usar try-except em conversões."
                                  ],
                                  "verification": "Rode o script com 5 inputs variados e verifique se as conversões são corretas sem crashes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código Python",
                                    "Biblioteca unittest para testes"
                                  ],
                                  "tips": "Use isinstance() para checar tipo antes de converter; evite bool(input()) direto.",
                                  "learningObjective": "Aplicar bool() em cenários reais de validação de dados em Python.",
                                  "commonMistakes": [
                                    "Não tratar exceções em inputs malformados.",
                                    "Confundir conversão com comparação == True.",
                                    "Ignorar que bool(None) é False."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Entender conversão para Boolean em Java usando valueOf()",
                                  "subSteps": [
                                    "Revise Boolean.valueOf(String): 'true' -> true, outros -> false (case-insensitive para 'true').",
                                    "Diferencie de Boolean.parseBoolean(): só 'true' exato -> true, ignore outros.",
                                    "Converta primitivos: (Boolean)1 não funciona; use Boolean.valueOf(String.valueOf(num)).",
                                    "Estude autoboxing: Boolean b = 1; // compila mas é wrapper, não direto.",
                                    "Compare com == para primitivos boolean."
                                  ],
                                  "verification": "Compile e rode snippets no JDK para confirmar Boolean.valueOf('false') == false.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "JDK 8+ ou IDE como IntelliJ/Eclipse",
                                    "Documentação Java: Boolean.valueOf()"
                                  ],
                                  "tips": "valueOf() é preferível a new Boolean() por pooling; use parseBoolean para simplicidade.",
                                  "learningObjective": "Dominar métodos estáticos de conversão em Java para strings e primitivos.",
                                  "commonMistakes": [
                                    "Usar valueOf em ints diretamente (precisa String.valueOf primeiro).",
                                    "Esquecer case-insensitivity só em valueOf para 'true'.",
                                    "Confundir Boolean (wrapper) com boolean (primitivo)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e comparar conversões em Java e Python",
                                  "subSteps": [
                                    "Escreva classes Java equivalentes às funções Python para converter int/str/float.",
                                    "Crie um programa que leia input e converta usando valueOf/parseBoolean.",
                                    "Compare comportamentos: Python bool('0')=True vs Java valueOf('0')=false.",
                                    "Implemente testes JUnit para casos cross-language simulados.",
                                    "Documente diferenças em um README."
                                  ],
                                  "verification": "Execute ambos códigos com mesmos inputs e valide saídas em tabela comparativa.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "IDE Java",
                                    "JUnit para testes",
                                    "Scripts Python para comparação"
                                  ],
                                  "tips": "Simule inputs idênticos; note que Java é mais estrito com strings.",
                                  "learningObjective": "Integrar conhecimentos de Python e Java para conversões booleanas em POO.",
                                  "commonMistakes": [
                                    "Não wrapper primitivos em Java.",
                                    "Ignorar NullPointerException em valueOf(null).",
                                    "Assumir paridade total entre linguagens."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de login, converta string de config 'enabled' para bool: Python bool(config.get('user_active', 'false')), Java Boolean.valueOf(config.get('user_active')). Use para ativar/desativar contas sem erros de tipo.",
                              "finalVerifications": [
                                "Converta corretamente 20 valores variados em Python sem erros.",
                                "Implemente valueOf/parseBoolean em Java para strings numéricas e textuais.",
                                "Identifique e explique 5 diferenças chave entre Python bool() e Java Boolean.valueOf().",
                                "Crie um método cross-plataforma simulado que funcione em ambos.",
                                "Debugue um código com input inválido em <5 minutos.",
                                "Escreva testes que cubram 100% dos casos falsy/truthy."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas conversões: 100% correto em testes automatizados.",
                                "Tratamento de exceções/edges: sem crashes em inputs inválidos.",
                                "Eficiência: código limpo, sem loops desnecessários.",
                                "Documentação: comentários explicando regras usadas.",
                                "Comparação: tabela clara de diferenças Python vs Java.",
                                "Criatividade: exemplo prático além dos básicos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional (verdadeiro/falso como 1/0).",
                                "Física/Engenharia: Sinais digitais (high/low como boolean).",
                                "Linguagens: Semântica de truthiness em parsing natural.",
                                "Banco de Dados: Conversão de BIT(1)/CHAR para BOOLEAN em SQL."
                              ],
                              "realWorldApplication": "Validação de formulários web: converter 'yes/no' ou '1/0' de usuário para boolean em backend (ex: ativar newsletter), evitando falhas em APIs REST ou configs YAML/JSON."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.1.4",
                        "name": "Tipos String em POO",
                        "description": "Estudo de strings como objetos imutáveis em POO, com métodos ricos em Python (str) e Java (String), suportando concatenação, slicing e formatação.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.4.1",
                            "name": "Declarar e inicializar strings",
                            "description": "Criar strings em Python (ex: nome = \"João\") e Java (String nome = \"João\";), acessando como objetos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Strings como Objetos",
                                  "subSteps": [
                                    "Estude a documentação oficial do tipo str em Python (python.org)",
                                    "Revise a classe String em Java (docs.oracle.com/javase/8/docs/api/java/lang/String.html)",
                                    "Identifique semelhanças: ambos são objetos imutáveis com métodos como length() e upper()",
                                    "Compare diferenças: Python usa aspas para declaração direta; Java requer 'String' explícito",
                                    "Anote exemplos básicos de declaração em um caderno"
                                  ],
                                  "verification": "Escreva um resumo de 3 pontos principais sobre strings como objetos em ambas linguagens",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Python str",
                                    "Documentação Java String",
                                    "Caderno ou editor de texto"
                                  ],
                                  "tips": "Pense em strings como caixas de texto que podem ser manipuladas via métodos, não alteradas diretamente",
                                  "learningObjective": "Diferenciar strings primitivas de objetos e entender declaração básica",
                                  "commonMistakes": [
                                    "Confundir strings com inteiros primitivos",
                                    "Esquecer que Java requer 'new' opcionalmente",
                                    "Ignorar imutabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar e Inicializar Strings em Python",
                                  "subSteps": [
                                    "Abra um ambiente Python (IDLE, VS Code ou Jupyter Notebook)",
                                    "Digite: nome = \"João\" e execute print(nome)",
                                    "Teste variações: nome2 = 'Maria' e sobrenome = \"Silva\"",
                                    "Verifique o tipo: print(type(nome)) deve retornar <class 'str'>",
                                    "Experimente escape de aspas: mensagem = \"Ele disse \\\"Olá\\\"\""
                                  ],
                                  "verification": "Código executa sem erros e imprime o conteúdo e tipo corretos da string",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python 3.x instalado",
                                    "Editor como VS Code ou IDLE"
                                  ],
                                  "tips": "Sempre use print(type()) para confirmar o tipo; aspas simples e duplas são intercambiáveis",
                                  "learningObjective": "Criar variáveis string em Python de forma idiomática e verificá-las",
                                  "commonMistakes": [
                                    "Omitir aspas",
                                    "Usar vírgulas em vez de atribuições",
                                    "Confundir com listas de strings"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Declarar e Inicializar Strings em Java",
                                  "subSteps": [
                                    "Crie uma classe Java simples em um IDE (Eclipse, IntelliJ ou online como Replit)",
                                    "Declare dentro de main: String nome = \"João\";",
                                    "Teste: String sobrenome = \"Silva\"; System.out.println(nome);",
                                    "Verifique comprimento inicial: System.out.println(nome.length());",
                                    "Experimente concatenação: String completo = nome + \" \" + sobrenome;"
                                  ],
                                  "verification": "Programa compila e executa sem erros, imprimindo strings e length correto",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "JDK 8+ instalado",
                                    "IDE Java como IntelliJ ou Eclipse"
                                  ],
                                  "tips": "Declare sempre com 'String' maiúsculo; use + para concatenação simples",
                                  "learningObjective": "Implementar declaração explícita de objetos String em Java",
                                  "commonMistakes": [
                                    "Esquecer ponto e vírgula",
                                    "Usar minúsculo 'string'",
                                    "Não importar java.lang (geralmente automático)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Acessar Strings como Objetos com Métodos Básicos",
                                  "subSteps": [
                                    "Em Python: print(nome.upper()) e print(nome[0]) para acessar caractere",
                                    "Em Java: System.out.println(nome.toUpperCase()); e System.out.println(nome.charAt(0));",
                                    "Compare saídas: teste length(), isEmpty() em ambas",
                                    "Crie um mini-programa que valida se string não está vazia",
                                    "Registre diferenças: Python slicing nome[0:3] vs Java substring(0,3)"
                                  ],
                                  "verification": "Métodos executam corretamente, alterando case ou acessando índices sem exceções",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ambientes Python e Java do passo anterior"
                                  ],
                                  "tips": "Lembre-se: strings são imutáveis, métodos retornam novas strings",
                                  "learningObjective": "Manipular strings via métodos orientados a objetos",
                                  "commonMistakes": [
                                    "Tentar modificar string diretamente (ex: nome[0] = 'J')",
                                    "Index out of bounds em Java",
                                    "Esquecer parênteses em métodos"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um programa em Python e Java que declara 'nome = \"João Silva\"', imprime em maiúscula (upper()/toUpperCase()), comprimento e primeiro caractere. Exemplo Python: nome = \"João Silva\"; print(nome.upper(), len(nome), nome[0]). Saída esperada: JOÃO SILVA 10 J. Repita em Java.",
                              "finalVerifications": [
                                "Declara string em Python sem erros de sintaxe",
                                "Declara String em Java que compila corretamente",
                                "Acessa length() e upper() em ambas linguagens",
                                "Identifica tipo correto (<class 'str'> ou String)",
                                "Manipula índices/caracteres iniciais sem exceções",
                                "Concatena duas strings e imprime resultado"
                              ],
                              "assessmentCriteria": [
                                "Sintaxe de declaração 100% correta em ambas linguagens",
                                "Execução sem erros de runtime ou compilação",
                                "Uso correto de pelo menos 3 métodos de string",
                                "Verificação de tipo e propriedades demonstrada",
                                "Código legível com comentários explicativos",
                                "Exemplo prático funcional e testado"
                              ],
                              "crossCurricularConnections": [
                                "Língua Portuguesa: Manipulação e formatação de texto",
                                "Matemática: Indexação e operações em sequências (como vetores)",
                                "Banco de Dados: Armazenamento e query de campos texto",
                                "Design de UX: Processamento de inputs de usuário como nomes"
                              ],
                              "realWorldApplication": "Em aplicativos de cadastro de usuários (ex: apps de e-commerce ou redes sociais), declara-se strings para nomes, emails e mensagens, acessando métodos para validação (length para senhas), formatação (upper para buscas) e exibição personalizada."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.4.2",
                            "name": "Manipular strings com métodos OO",
                            "description": "Usar upper(), lower(), find(), replace() em Python e Java, demonstrando encapsulamento de funcionalidades em objetos string.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Strings como Objetos em Python e Java",
                                  "subSteps": [
                                    "Estude a declaração de strings em Python (ex: s = 'hello') e Java (ex: String s = 'hello';).",
                                    "Identifique que strings são imutáveis em ambos e possuem métodos de instância.",
                                    "Compare o encapsulamento: em Python, str é uma classe built-in; em Java, String é uma classe.",
                                    "Crie uma string simples e acesse seu tipo com type() em Python ou getClass() em Java.",
                                    "Explore a documentação oficial: Python str methods e Java String API."
                                  ],
                                  "verification": "Explique em voz alta ou anote por que strings são objetos OO e liste 3 métodos comuns.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Editor Python (IDLE/PyCharm)",
                                    "JDK e IDE Java (Eclipse/IntelliJ)",
                                    "Documentação oficial Python/Java"
                                  ],
                                  "tips": [
                                    "Use print(type(s)) para visualizar o tipo objeto.",
                                    "Lembre-se: métodos OO operam na instância, não na classe diretamente."
                                  ],
                                  "learningObjective": "Reconhecer strings como objetos encapsulados com métodos prontos para uso.",
                                  "commonMistakes": [
                                    "Confundir strings com primitivos (não são em Java/Python moderno).",
                                    "Ignorar imutabilidade ao esperar mutação direta."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Métodos de Transformação de Caso: upper() e lower()",
                                  "subSteps": [
                                    "Em Python: Crie s = 'Python Java'; imprima s.upper() e s.lower().",
                                    "Em Java: String s = 'Python Java'; System.out.println(s.toUpperCase()); e toLowerCase().",
                                    "Teste com strings mistas: 'Olá Mundo' para upper() e lower().",
                                    "Armazene resultados em novas variáveis e compare comprimentos.",
                                    "Crie um programa que padronize entrada de usuário para minúscula."
                                  ],
                                  "verification": "Execute código que converte 'MixEd CaSe' para UPPER e lower, confirmando saídas corretas.",
                                  "estimatedTime": "40 minutes",
                                  "materials": [
                                    "REPL Python",
                                    "Compilador Java online/offline",
                                    "Notebook para testes"
                                  ],
                                  "tips": [
                                    "Métodos retornam novas strings devido à imutabilidade.",
                                    "Use locale se necessário para acentos (ex: Turkish locale em Java)."
                                  ],
                                  "learningObjective": "Dominar transformação de caso usando métodos de instância de string.",
                                  "commonMistakes": [
                                    "Esquecer de atribuir o retorno (s.upper() não altera s).",
                                    "Confundir upper() com capitalize()."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Usar Métodos de Busca: find() e Equivalentes",
                                  "subSteps": [
                                    "Em Python: Use s.find('sub') e s.index('sub') em 'Find in string'.",
                                    "Em Java: s.indexOf('sub') e s.lastIndexOf('sub').",
                                    "Teste casos: substring não encontrada (retorna -1), múltiplas ocorrências.",
                                    "Combine com slicing: em Python s[s.find('in'):], em Java s.substring(s.indexOf('in')).",
                                    "Crie função que verifica se palavra existe em texto."
                                  ],
                                  "verification": "Encontre posição de 'OO' em 'Programação Orientada a Objetos' e extraia substring.",
                                  "estimatedTime": "35 minutes",
                                  "materials": [
                                    "Ambiente de codificação Python/Java",
                                    "Strings de teste variadas"
                                  ],
                                  "tips": [
                                    "find() é seguro (não lança exceção em não-encontrado), index() lança ValueError/IndexOutOfBounds.",
                                    "Use start/end parâmetros para buscas parciais."
                                  ],
                                  "learningObjective": "Localizar substrings eficientemente com métodos OO.",
                                  "commonMistakes": [
                                    "Ignorar retorno -1 e causar erros em slicing.",
                                    "Confundir find() com count()."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Substituições com replace()",
                                  "subSteps": [
                                    "Em Python: s.replace('old', 'new', count=1) em 'old old new'.",
                                    "Em Java: s.replace('old', 'new') ou replaceAll para regex.",
                                    "Substitua múltiplas vezes e limite contagens.",
                                    "Crie pipeline: lower() + replace() + upper() em texto sujo.",
                                    "Teste em loop: limpe lista de nomes substituindo espaços por underscores."
                                  ],
                                  "verification": "Transforme 'banana apple banana' em 'fruit fruit fruit' usando replace().",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Scripts de teste",
                                    "Dados de entrada reais (ex: CSV de nomes)"
                                  ],
                                  "tips": [
                                    "Replace cria nova string; para eficiência em loops grandes, use StringBuilder em Java.",
                                    "Especifique count para evitar substituições excessivas."
                                  ],
                                  "learningObjective": "Modificar strings seletivamente demonstrando encapsulamento OO.",
                                  "commonMistakes": [
                                    "Não lidar com case-sensitivity (combine com lower()).",
                                    "Substituir demais sem count."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar Métodos em Aplicação OO Completa",
                                  "subSteps": [
                                    "Crie classe StringProcessor com métodos usando upper/lower/find/replace.",
                                    "Em Python: class StringProcessor: def normalize(self, s): return s.lower().replace(' ', '_').",
                                    "Em Java: classe similar com métodos de instância.",
                                    "Teste com input usuário: valide email limpando case e espaços.",
                                    "Adicione verificação: use find para checar formato."
                                  ],
                                  "verification": "Execute classe que processa 5 strings de teste com todas operações, sem erros.",
                                  "estimatedTime": "50 minutes",
                                  "materials": [
                                    "Full IDE",
                                    "Exemplos de dados reais"
                                  ],
                                  "tips": [
                                    "Encapsule lógica em métodos para reutilização OO.",
                                    "Teste edge cases: strings vazias, None/null."
                                  ],
                                  "learningObjective": "Construir funcionalidades OO compostas para manipulação de strings.",
                                  "commonMistakes": [
                                    "Não tratar exceções em find/index.",
                                    "Violar encapsulamento expondo variáveis privadas."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um validador de nomes: entrada 'JoHn  Doe' -> lower() para 'john doe', replace(' ', '_') para 'john_doe', upper() para 'JOHN_DOE'. Em Python: name = 'JoHn  Doe'; processed = name.lower().replace(' ', '_').upper(); print(processed). Em Java: similar com toLowerCase().replace().toUpperCase().",
                              "finalVerifications": [
                                "Consegue converter e padronizar case em qualquer string inputada.",
                                "Localiza substrings corretamente, lidando com -1/não-encontrado.",
                                "Executa replace seletivo sem alterar partes indesejadas.",
                                "Integra múltiplos métodos em pipeline sem erros de imutabilidade.",
                                "Implementa classe simples que encapsula manipulações de string.",
                                "Testa com dados reais (ex: nomes, emails) sem falhas."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 100% dos métodos produzem saídas corretas (80% proficiência).",
                                "Eficiência: Usa métodos OO built-in sem loops desnecessários (90%).",
                                "Encapsulamento: Lógica em classes/métodos, não scripts soltos (85%).",
                                "Tratamento de erros: Lida com casos edge (vazio, não-encontrado) (75%).",
                                "Criatividade: Aplica em exemplo real-world além dos básicos (95%).",
                                "Documentação: Código comentado explicando OO aspects (80%)."
                              ],
                              "crossCurricularConnections": [
                                "Linguagens: Processamento de texto em literatura/português (normalização).",
                                "Matemática: Padrões e algoritmos de busca/substituição.",
                                "Banco de Dados: Limpeza de dados strings em SQL/NoSQL.",
                                "Design: Formatação UI (capitalização em labels).",
                                "Ética: Privacidade em manipulação de dados pessoais (nomes/emails)."
                              ],
                              "realWorldApplication": "Em desenvolvimento web/apps: normalizar user inputs (ex: search bars com replace para wildcards), validar forms (find '@' em emails), processar logs (lower para padronizar erros), ou ETL em data science (limpar datasets com replace em massa)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.4.3",
                            "name": "Concatenar e formatar strings",
                            "description": "Concatenar com + ou format() em Python, e concat() ou String.format() em Java, explorando imutabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entendendo Concatenação Básica com Operador '+'",
                                  "subSteps": [
                                    "Estude o conceito de concatenação: junção de duas ou mais strings em uma única.",
                                    "Em Python, execute: nome = 'João'; saudacao = 'Olá, ' + nome + '!'; print(saudacao).",
                                    "Em Java, execute: String nome = \"João\"; String saudacao = \"Olá, \" + nome + \"!\"; System.out.println(saudacao);.",
                                    "Teste com números: em Java, 'Idade: ' + 25 resulta em 'Idade: 25'.",
                                    "Compare saídas e observe diferenças de sintaxe."
                                  ],
                                  "verification": "Códigos em Python e Java executam e produzem saídas corretas como 'Olá, João!' sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor Python (VS Code ou Replit)",
                                    "Editor Java (IntelliJ ou OnlineGDB)",
                                    "Documentação Python strings",
                                    "Java String API docs"
                                  ],
                                  "tips": "Sempre inclua espaços manualmente, pois '+' não os adiciona automaticamente.",
                                  "learningObjective": "Dominar concatenação básica com '+' em Python e Java, reconhecendo auto-conversão em Java.",
                                  "commonMistakes": [
                                    "Omitir espaços ('Olá'+'João' → 'OláJoão')",
                                    "Esquecer ponto-e-vírgula em Java",
                                    "Usar aspas simples/duplas inconsistentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorando Método concat() em Java",
                                  "subSteps": [
                                    "Leia sobre String.concat() na documentação Java: retorna nova string concatenada.",
                                    "Exemplo: String s1 = \"Olá\"; String s2 = s1.concat(\" Mundo\"); System.out.println(s2);.",
                                    "Teste encadeamento: \"A\".concat(\"B\").concat(\"C\").",
                                    "Compare com +: execute ambos e meça performance simples com loops.",
                                    "Note que strings são imutáveis: concat() cria nova instância."
                                  ],
                                  "verification": "Código Java compila/executa, produz 'Olá Mundo' e explica criação de nova string.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE Java (Eclipse ou IntelliJ)",
                                    "Javadoc para String.concat()",
                                    "Timer para testes de performance"
                                  ],
                                  "tips": "Use concat() para clareza em chains, mas prefira StringBuilder para loops.",
                                  "learningObjective": "Aplicar concat() em Java e compreender que não modifica a string original devido à imutabilidade.",
                                  "commonMistakes": [
                                    "Tentar modificar string original (s1.concat(s2) não altera s1)",
                                    "Confundir com Python (não existe)",
                                    "Ignorar NullPointerException se string nula"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formatando Strings com format() em Python e String.format() em Java",
                                  "subSteps": [
                                    "Em Python: use '{}'.format('João', 25): print('Nome: {}, Idade: {}'.format('João', 25)).",
                                    "Em Java: use String.format('Nome: %s, Idade: %d', \"João\", 25);.",
                                    "Teste placeholders: Python {0}, {1}; Java %s, %d, %.2f.",
                                    "Crie exemplo complexo: formatar data 'DD/MM/YYYY'.",
                                    "Compare legibilidade vs. concatenação."
                                  ],
                                  "verification": "Ambos códigos produzem 'Nome: João, Idade: 25' com formatação correta e sem erros de índice.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ambiente Python 3+",
                                    "Java 8+",
                                    "Documentação str.format Python",
                                    "Java Formatter docs"
                                  ],
                                  "tips": "Use f-strings em Python moderno (f'Nome: {nome}'), mas foque em .format() para compatibilidade.",
                                  "learningObjective": "Implementar formatação dinâmica de strings para inserção de variáveis em ambos idiomas.",
                                  "commonMistakes": [
                                    "Número errado de argumentos (IndexError/ArityException)",
                                    "Tipo incompatível (%d com string)",
                                    "Esquecer chaves/porcentagens"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compreendendo Imutabilidade e Boas Práticas",
                                  "subSteps": [
                                    "Explique imutabilidade: strings não mudam; operações criam novas.",
                                    "Teste em Java: String s = \"abc\"; s.concat(\"d\"); System.out.println(s); // ainda 'abc'.",
                                    "Em Python: similar, id('abc' + 'd') != id('abc').",
                                    "Boas práticas: use StringBuilder em Java para loops; ' '.join() em Python.",
                                    "Refatore exemplo anterior usando builders/join."
                                  ],
                                  "verification": "Demonstra imutabilidade com prints de ID/content e refatora código ineficiente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Função id() Python",
                                    "StringBuilder Java docs",
                                    "Profiler simples ou System.nanoTime()"
                                  ],
                                  "tips": "Evite concatenação em loops: O(n^2) tempo devido a cópias.",
                                  "learningObjective": "Reconhecer impactos da imutabilidade e adotar métodos eficientes para concatenação múltipla.",
                                  "commonMistakes": [
                                    "Acreditar que concat() modifica original",
                                    "Usar + em loops grandes",
                                    "Ignorar overhead de memória"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um programa que gera convite personalizado: 'Prezado {nome}, sua compra de {produto} no valor de R$ {preco:.2f} foi confirmada em {data}. Obrigado!' Use format() em Python e String.format() em Java, testando com dados reais.",
                              "finalVerifications": [
                                "Concatena strings básicas com '+' sem erros em Python e Java.",
                                "Aplica concat() corretamente em Java, reconhecendo nova string criada.",
                                "Formata strings com múltiplos placeholders usando format() em ambos.",
                                "Demonstra imutabilidade via testes de identidade/conteúdo.",
                                "Refatora código ineficiente usando join() ou StringBuilder.",
                                "Explica diferenças de performance entre métodos."
                              ],
                              "assessmentCriteria": [
                                "Códigos compilam/executam sem erros ou warnings.",
                                "Saídas exatas conforme especificado, com formatação precisa.",
                                "Comentários explicam imutabilidade e escolhas de método.",
                                "Uso eficiente: evita concatenação repetida em loops.",
                                "Testes incluem edge cases (strings vazias, nulas).",
                                "Explicação oral/código demonstra compreensão conceitual."
                              ],
                              "crossCurricularConnections": [
                                "Língua Portuguesa: Construção e formatação de textos compostos e personalizados.",
                                "Matemática: Manipulação simbólica e formatação numérica (decimais, inteiros).",
                                "Artes/Design: Criação de mensagens visuais e layouts textuais em interfaces.",
                                "Física/Engenharia: Modelagem de logs e relatórios de simulações.",
                                "Comunicação: Geração de emails e relatórios profissionais."
                              ],
                              "realWorldApplication": "Em aplicações web/mobile para personalizar dashboards de usuário (ex: 'Bem-vindo, João! Seu saldo: R$1500.00'), logs de sistemas ('Erro em {data}: {mensagem}'), geração de relatórios PDF/CSV em e-commerces, ou APIs REST para respostas JSON formatadas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.2",
                    "name": "Tipos de Dados Compostos e Classes",
                    "description": "Uso de classes e objetos como tipos de dados personalizados e estruturas orientadas a objetos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.2.1",
                        "name": "Definição de Classes como Tipos Compostos",
                        "description": "Compreender classes como estruturas personalizadas para tipos de dados compostos, permitindo a modelagem de entidades do mundo real com atributos e comportamentos em linguagens orientadas a objetos como Python e C++.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.1.1",
                            "name": "Declarar uma classe básica",
                            "description": "Criar a sintaxe fundamental para definir uma classe vazia ou com atributos iniciais, utilizando palavras-chave como 'class' em Python ou 'class' em C++, diferenciando de tipos primitivos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Classes",
                                  "subSteps": [
                                    "Estude a definição de classe como um blueprint para objetos em Programação Orientada a Objetos (POO).",
                                    "Diferencie classes de tipos primitivos (int, str) explicando que classes são compostas e personalizáveis.",
                                    "Analise exemplos simples: uma classe 'Carro' representa múltiplos carros com atributos comuns.",
                                    "Compare declaração de classe com definição de função para destacar diferenças.",
                                    "Revise palavras-chave: 'class' em Python e C++ inicia a definição."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que é uma classe e sua diferença de tipos primitivos.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Documentação oficial do Python (docs.python.org)",
                                    "Editor de texto como VS Code",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Visualize classes como moldes de bolos: o molde é a classe, os bolos são objetos.",
                                  "learningObjective": "Entender classes como tipos compostos abstratos em POO.",
                                  "commonMistakes": [
                                    "Confundir classes com instâncias (objetos)",
                                    "Achar que classes são apenas funções avançadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar uma Classe Básica Vazia em Python",
                                  "subSteps": [
                                    "Abra um editor de código e inicie um novo arquivo Python (.py).",
                                    "Escreva a sintaxe: 'class NomeDaClasse:' seguida de indentação com 'pass'.",
                                    "Escolha um nome descritivo em CamelCase (ex: MinhaClasse).",
                                    "Salve e execute o arquivo para verificar erros de sintaxe.",
                                    "Crie uma instância básica: obj = MinhaClasse() e imprima(type(obj))."
                                  ],
                                  "verification": "O código executa sem erros e type(obj) retorna o nome da classe.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Python 3 instalado",
                                    "Editor de código (IDLE ou VS Code)",
                                    "Terminal para execução"
                                  ],
                                  "tips": "Sempre use indentação de 4 espaços após os dois-pontos (:).",
                                  "learningObjective": "Dominar a sintaxe mínima para definir uma classe vazia.",
                                  "commonMistakes": [
                                    "Esquecer os dois-pontos após 'class Nome'",
                                    "Não indentar o corpo da classe",
                                    "Usar minúsculas no nome da classe"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar Atributos Iniciais com Método Construtor",
                                  "subSteps": [
                                    "Dentro da classe, defina o método especial '__init__(self)':.",
                                    "Adicione parâmetros como self, nome, idade e atribua self.nome = nome.",
                                    "Crie uma instância com argumentos: obj = NomeClasse('João', 25).",
                                    "Acesse atributos: print(obj.nome) para verificar.",
                                    "Compare brevemente com C++: 'class MinhaClasse { public: string nome; };'."
                                  ],
                                  "verification": "Instância criada acessa atributos corretamente sem erros.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Mesmo ambiente Python do step anterior",
                                    "Referência rápida de C++ (opcional)"
                                  ],
                                  "tips": "Lembre-se: 'self' refere-se à instância atual; sempre inclua-o nos métodos.",
                                  "learningObjective": "Implementar inicialização de atributos em classes.",
                                  "commonMistakes": [
                                    "Esquecer 'self' nos parâmetros ou atribuições",
                                    "Não usar duplo underline em '__init__'",
                                    "Confundir parâmetros com atributos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar a Declaração da Classe",
                                  "subSteps": [
                                    "Crie múltiplas instâncias e teste atributos únicos por objeto.",
                                    "Adicione um método simples (ex: def saudacao(self): return f'Olá {self.nome}').",
                                    "Execute testes em um script principal e verifique saídas.",
                                    "Debugue erros comuns como NameError ou AttributeError.",
                                    "Documente a classe com uma docstring triple-aspas após a linha 'class'."
                                  ],
                                  "verification": "Todas instâncias funcionam independentemente e métodos executam corretamente.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Script de teste Python",
                                    "Debugger do VS Code (opcional)"
                                  ],
                                  "tips": "Use print() liberalmente durante testes para rastrear valores.",
                                  "learningObjective": "Validar funcionalidade completa da classe declarada.",
                                  "commonMistakes": [
                                    "Modificar atributo de uma instância afetando outra",
                                    "Esquecer parênteses ao instanciar",
                                    "Não testar com dados variados"
                                  ]
                                }
                              ],
                              "practicalExample": "Declare a classe 'Pessoa': class Pessoa: def __init__(self, nome, idade): self.nome = nome; self.idade = idade. Crie p1 = Pessoa('Ana', 30); print(p1.nome) → 'Ana'. Em C++: class Pessoa { public: string nome; int idade; };",
                              "finalVerifications": [
                                "Código declara classe sem erros de sintaxe.",
                                "Instâncias são criadas e atributos acessados corretamente.",
                                "Múltiplas instâncias mantêm estados independentes.",
                                "Método __init__ inicializa atributos passados.",
                                "Comparação com C++ destaca similaridades na palavra-chave 'class'.",
                                "Docstring ou comentários explicam o propósito da classe."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe exata: 'class Nome:' com indentação correta.",
                                "Convenções de nomenclatura: CamelCase para classes.",
                                "Uso correto de 'self' em métodos e atributos.",
                                "Testes demonstram funcionalidade (criação, acesso, independência).",
                                "Ausência de erros comuns como falta de inicialização.",
                                "Inclusão de docstring ou comentários claros.",
                                "Breve menção a C++ para contextualização."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstração e modelagem de conjuntos (classes como conjuntos de objetos).",
                                "Língua Portuguesa: Nomenclatura precisa e documentação descritiva.",
                                "Física: Representação de entidades reais (objetos físicos como classes).",
                                "Artes: Design de blueprints (classes como projetos arquitetônicos)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, declarar classes básicas modela entidades reais como 'ContaBancaria' em apps financeiros ou 'Personagem' em jogos, permitindo criar múltiplas instâncias com atributos personalizados, base para sistemas complexos como e-commerces ou simulações científicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.2",
                            "name": "Definir atributos de classe e de instância",
                            "description": "Especificar variáveis de instância (não estáticas) e de classe (estáticas), entendendo o escopo e a inicialização em construtores como __init__ em Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a diferença entre atributos de instância e de classe",
                                  "subSteps": [
                                    "Estude o conceito de atributo de instância: variáveis únicas para cada objeto criado a partir da classe.",
                                    "Estude o conceito de atributo de classe: variáveis compartilhadas por todos os objetos da classe, definidas diretamente na classe.",
                                    "Compare escopo: atributos de instância acessíveis via self e instância, atributos de classe via nome da classe ou self.",
                                    "Analise exemplos simples em documentação Python sobre static vs instance variables.",
                                    "Anote as diferenças em um diagrama mental ou papel."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre os dois tipos de atributos, com exemplos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Python oficial (classes), editor de texto para anotações"
                                  ],
                                  "tips": "Lembre-se: atributos de classe são como propriedades globais da classe, instância são personalizadas por objeto.",
                                  "learningObjective": "Diferenciar conceitualmente atributos de classe (estáticos) e de instância (não estáticos).",
                                  "commonMistakes": [
                                    "Confundir atributos de classe com variáveis globais fora da classe",
                                    "Achar que atributos de instância são compartilhados entre objetos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir atributos de classe",
                                  "subSteps": [
                                    "Crie uma classe vazia, ex: class MinhaClasse: pass",
                                    "Adicione um atributo de classe dentro da classe, ex: contador = 0",
                                    "Crie múltiplas instâncias da classe.",
                                    "Acesse o atributo de classe via NomeClasse.contador e via instancia.contador, verificando que é o mesmo valor.",
                                    "Modifique o atributo via classe e observe o impacto em todas instâncias."
                                  ],
                                  "verification": "Execute código criando 2 instâncias e alterando o atributo de classe; confirme que ambas refletem a mudança.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Interpretador Python ou IDE como VS Code, PyCharm"
                                  ],
                                  "tips": "Use print() para depurar valores e confirmar compartilhamento.",
                                  "learningObjective": "Definir e acessar atributos de classe corretamente.",
                                  "commonMistakes": [
                                    "Definir atributo de classe dentro de __init__ (torna-se de instância)",
                                    "Acessar só via self sem entender herança"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir atributos de instância no construtor __init__",
                                  "subSteps": [
                                    "Adicione o método __init__ à classe com parâmetros self e outros.",
                                    "Defina atributos de instância usando self.nome_atributo = valor.",
                                    "Passe argumentos ao criar instâncias, ex: obj = Classe(arg1, arg2).",
                                    "Acesse atributos de instância via obj.nome_atributo em diferentes objetos.",
                                    "Tente acessar atributo de instância antes da inicialização e observe erro."
                                  ],
                                  "verification": "Crie 2 instâncias com valores diferentes para atributos de instância e confirme independência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Interpretador Python, exemplos de código de classes"
                                  ],
                                  "tips": "Sempre use self. para atributos de instância; parâmetros sem self são locais ao método.",
                                  "learningObjective": "Inicializar e gerenciar atributos de instância via __init__.",
                                  "commonMistakes": [
                                    "Esquecer self no __init__",
                                    "Confundir parâmetros com atributos de instância"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar atributos de classe e instância em uma classe funcional",
                                  "subSteps": [
                                    "Crie uma classe com ambos os tipos: atributo de classe (ex: total_objetos=0) e de instância (ex: nome, idade).",
                                    "No __init__, incremente o atributo de classe (total_objetos +=1).",
                                    "Crie métodos para acessar/modificar ambos os tipos.",
                                    "Teste criando várias instâncias e verificando contagens e valores únicos.",
                                    "Adicione tratamento de erros para atributos não inicializados."
                                  ],
                                  "verification": "Execute testes unitários simples confirmando escopo correto e contagem de instâncias.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "IDE com debugger, módulo unittest para testes opcionais"
                                  ],
                                  "tips": "Use propriedades (@property) para encapsulamento futuro, mas foque no básico agora.",
                                  "learningObjective": "Integrar atributos de classe e instância em classes OOP completas.",
                                  "commonMistakes": [
                                    "Modificar atributo de classe via instância sem intenção",
                                    "Não inicializar atributos de instância"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe Carro com atributo de classe 'total_carros = 0' (compartilhado) e atributos de instância 'cor' e 'modelo' no __init__. Ao criar carro1 = Carro('vermelho', 'Fusca'), total_carros vira 1; carro2 = Carro('azul', 'Gol') faz total_carros=2. Acesse Carro.total_carros ou carro1.total_carros (mesmo valor), mas carro1.cor é único.",
                              "finalVerifications": [
                                "Criar classe com atributo de classe acessível via classe e instâncias.",
                                "Definir e inicializar atributos de instância via __init__ com parâmetros.",
                                "Criar múltiplas instâncias e confirmar independência de atributos de instância.",
                                "Modificar atributo de classe e verificar reflexão em todas instâncias.",
                                "Acessar atributos sem erros de escopo ou AttributeError.",
                                "Implementar contador de instâncias via atributo de classe."
                              ],
                              "assessmentCriteria": [
                                "Correta distinção conceitual entre tipos de atributos (escopo e uso).",
                                "Código sintaticamente válido sem erros de inicialização.",
                                "Demonstração prática com pelo menos 2 instâncias testadas.",
                                "Uso apropriado de self em __init__ para atributos de instância.",
                                "Verificação de compartilhamento/atributos de classe via testes.",
                                "Explicação clara de quando usar cada tipo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Contadores e variáveis compartilhadas como em estatísticas globais.",
                                "Biologia: Classes de organismos com atributos de espécie (classe) vs indivíduo (instância).",
                                "Física: Modelagem de partículas com propriedades universais vs específicas.",
                                "Economia: Contas de banco com saldos individuais vs taxas globais."
                              ],
                              "realWorldApplication": "Em sistemas de gerenciamento como bancos (contas de usuário com saldo individual vs taxas de juros globais), jogos (pontuação total de jogadores vs stats por personagem), ou e-commerce (produtos com estoque total vs itens no carrinho do cliente)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.3",
                            "name": "Implementar construtor de classe",
                            "description": "Criar métodos especiais de inicialização para configurar objetos ao instanciá-los, passando parâmetros e lidando com tipagem dinâmica ou estática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Construtor",
                                  "subSteps": [
                                    "Estudar o que é um construtor: método especial executado automaticamente ao criar uma instância de classe.",
                                    "Identificar o método __init__ em Python como o construtor padrão.",
                                    "Explicar o parâmetro 'self': referência ao objeto instanciado.",
                                    "Diferenciar construtor de outros métodos de instância.",
                                    "Analisar exemplos simples de classes sem construtor."
                                  ],
                                  "verification": "Escrever uma definição curta do construtor e seu propósito em um comentário de código.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial Python sobre classes",
                                    "Editor de código como VS Code ou PyCharm"
                                  ],
                                  "tips": "Visualize o construtor como a 'configuração inicial' do objeto, similar a preparar uma casa antes de morar nela.",
                                  "learningObjective": "Entender o papel fundamental do construtor na inicialização de objetos.",
                                  "commonMistakes": [
                                    "Confundir __init__ com __new__",
                                    "Ignorar o uso obrigatório de 'self' como primeiro parâmetro"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Sintaxe Básica do Construtor",
                                  "subSteps": [
                                    "Criar uma classe simples, ex: class MinhaClasse:",
                                    "Adicionar o método def __init__(self): dentro da classe.",
                                    "Testar instanciação básica: obj = MinhaClasse() sem erros.",
                                    "Adicionar uma linha print('Construtor chamado!') para confirmar execução.",
                                    "Explicar indentação e convenções PEP8."
                                  ],
                                  "verification": "Executar o código e confirmar que a mensagem de print aparece na instanciação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python instalado (versão 3.8+)",
                                    "Terminal ou Jupyter Notebook"
                                  ],
                                  "tips": "Sempre teste imediatamente após escrever para detectar erros de sintaxe cedo.",
                                  "learningObjective": "Dominar a sintaxe essencial para definir um construtor vazio.",
                                  "commonMistakes": [
                                    "Esquecer os dois underscores em __init__",
                                    "Indentação incorreta do método dentro da classe"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Construtor com Parâmetros e Atributos",
                                  "subSteps": [
                                    "Modificar __init__ para aceitar parâmetros: def __init__(self, param1, param2):",
                                    "Atribuir valores aos atributos de instância: self.param1 = param1",
                                    "Instanciar com argumentos: obj = MinhaClasse('valor1', 'valor2')",
                                    "Acessar atributos: print(obj.param1)",
                                    "Adicionar validações básicas opcionais, como if not param1: raise ValueError"
                                  ],
                                  "verification": "Criar instância com parâmetros e verificar se atributos são acessíveis e corretos via print.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de código OOP em Python",
                                    "Debugger integrado no IDE"
                                  ],
                                  "tips": "Use nomes descritivos para parâmetros para facilitar debugging.",
                                  "learningObjective": "Criar construtores parametrizados que inicializem atributos de instância.",
                                  "commonMistakes": [
                                    "Esquecer 'self.' ao atribuir atributos",
                                    "Passar argumentos errados na instanciação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar Tipagem e Testes Finais",
                                  "subSteps": [
                                    "Adicionar type hints: from typing import Optional; def __init__(self, nome: str, idade: int) -> None:",
                                    "Instanciar com verificação de tipos usando mypy ou IDE linter.",
                                    "Criar múltiplas instâncias e testar comportamentos.",
                                    "Adicionar um método getter para atributos e testá-lo.",
                                    "Documentar o construtor com docstring: '''Inicializa a classe com nome e idade.'''"
                                  ],
                                  "verification": "Rodar mypy no código sem erros e testar 3 instâncias diferentes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "mypy instalado via pip",
                                    "Exemplos de type hints em repositórios GitHub"
                                  ],
                                  "tips": "Type hints melhoram legibilidade e previnem erros em equipes.",
                                  "learningObjective": "Integrar tipagem estática dinâmica em construtores para código robusto.",
                                  "commonMistakes": [
                                    "Type hints incorretos, como str para int",
                                    "Não importar typing"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe Pessoa: class Pessoa: def __init__(self, nome: str, idade: int) -> None: self.nome = nome; self.idade = idade. Instancie: p1 = Pessoa('Alice', 30); print(p1.nome)  # Saída: Alice. Adicione um método def saudacao(self): return f'Olá, sou {self.nome}'. Teste: print(p1.saudacao()).",
                              "finalVerifications": [
                                "O construtor é chamado automaticamente sem erros na instanciação.",
                                "Atributos de instância são inicializados corretamente com valores passados.",
                                "Type hints são válidos e detectados por linters como mypy.",
                                "Múltiplas instâncias mantêm atributos independentes.",
                                "Acesso a atributos via self funciona em métodos subsequentes.",
                                "Validações opcionais previnem entradas inválidas."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe correta de __init__ com self como primeiro parâmetro.",
                                "Atribuição adequada de parâmetros a atributos de instância.",
                                "Uso apropriado de type hints para todos os parâmetros.",
                                "Código testável com pelo menos 2 exemplos de instanciação.",
                                "Documentação clara via docstrings e comentários.",
                                "Ausência de erros comuns como esquecer self."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica condicional em validações de parâmetros.",
                                "Língua Portuguesa/Inglês: Convenções de nomenclatura (snake_case PEP8).",
                                "Física: Modelagem de entidades reais como objetos (ex: partículas com posição inicial).",
                                "Design: Princípios de encapsulamento e inicialização modular."
                              ],
                              "realWorldApplication": "Construtores são essenciais em frameworks como Django (modelos com __init__ customizado), jogos Unity (inicialização de GameObjects com stats), e apps web Flask (usuários com credenciais seguras), garantindo objetos prontos para uso imediato e reduzindo bugs de estado indefinido."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.2",
                        "name": "Criação e Manipulação de Objetos",
                        "description": "Criar instâncias de classes para formar objetos, manipulando-os como tipos de dados compostos com acesso a atributos e métodos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.2.1",
                            "name": "Instanciar objetos de uma classe",
                            "description": "Usar a sintaxe de instanciação para criar múltiplas instâncias independentes, demonstrando abstração de tipos compostos em código prático.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir uma classe simples como base para instanciação",
                                  "subSteps": [
                                    "Crie uma nova classe chamada 'Carro' com atributos básicos como 'cor' e 'modelo'.",
                                    "Adicione um método simples '__init__' para inicializar os atributos.",
                                    "Inclua um método de instância como 'acelerar()' que imprima uma mensagem.",
                                    "Salve o código em um arquivo Python e execute para verificar se a classe é definida sem erros.",
                                    "Teste a classe chamando o método diretamente (sem instância ainda)."
                                  ],
                                  "verification": "A classe é definida sem erros de sintaxe e o método __init__ é acessível.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou IDLE)",
                                    "Python 3.x instalado"
                                  ],
                                  "tips": [
                                    "Use nomes descritivos para classes e atributos para facilitar a compreensão.",
                                    "Sempre inclua docstrings na classe para documentação."
                                  ],
                                  "learningObjective": "Compreender a estrutura básica de uma classe para preparar instanciações.",
                                  "commonMistakes": [
                                    "Esquecer os dois underscores em __init__",
                                    "Não indentar corretamente os métodos da classe"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Instanciar um objeto único da classe",
                                  "subSteps": [
                                    "Use a sintaxe 'objeto = Classe()' para criar a primeira instância, como 'meu_carro = Carro(\"vermelho\", \"Fusca\")'.",
                                    "Acesse atributos do objeto com notação de ponto, ex: 'print(meu_carro.cor)'.",
                                    "Chame métodos do objeto, ex: 'meu_carro.acelerar()'.",
                                    "Modifique um atributo e verifique a mudança.",
                                    "Use 'type()' e 'id()' para confirmar que é um objeto da classe correta e único."
                                  ],
                                  "verification": "O objeto é criado, atributos são acessíveis e métodos funcionam sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Mesmo arquivo Python do step anterior",
                                    "Console ou terminal para execução"
                                  ],
                                  "tips": [
                                    "Passar argumentos no construtor na ordem correta.",
                                    "Use print() para debugar valores de atributos."
                                  ],
                                  "learningObjective": "Dominar a sintaxe básica de instanciação e manipulação de um objeto único.",
                                  "commonMistakes": [
                                    "Confundir nome da classe com nome do objeto",
                                    "Esquecer parênteses na instanciação: 'Classe' em vez de 'Classe()'"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar múltiplas instâncias independentes",
                                  "subSteps": [
                                    "Instancie um segundo objeto: 'outro_carro = Carro(\"azul\", \"Gol\")'.",
                                    "Instancie um terceiro com valores diferentes.",
                                    "Altere atributos de um objeto e verifique que os outros não mudam.",
                                    "Chame métodos em cada instância separadamente.",
                                    "Use 'id()' em cada objeto para provar que são independentes na memória."
                                  ],
                                  "verification": "Múltiplos objetos coexistem com estados independentes, confirmados por prints e id().",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Arquivo Python expandido",
                                    "Calculadora de ID de objetos no Python (built-in)"
                                  ],
                                  "tips": [
                                    "Cada instanciação cria um novo espaço na memória; pense em 'blueprints' vs 'cópias'.",
                                    "Teste independência alterando um e checando os outros."
                                  ],
                                  "learningObjective": "Demonstrar abstração criando várias instâncias independentes de um tipo composto.",
                                  "commonMistakes": [
                                    "Achar que alterar um objeto afeta todos",
                                    "Reatribuir o mesmo nome de variável, sobrescrevendo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar instanciação em um cenário prático e verificar abstração",
                                  "subSteps": [
                                    "Crie uma lista de objetos instanciados e itere sobre ela chamando métodos.",
                                    "Adicione um atributo compartilhado (classe variable) para ver diferença com instância variables.",
                                    "Simule um 'garagem' listando todos os carros com seus atributos.",
                                    "Execute o código completo e capture saídas.",
                                    "Refatore para mais instâncias e teste escalabilidade."
                                  ],
                                  "verification": "Lista de objetos funciona, independência mantida, abstração demonstrada em código funcional.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python REPL ou Jupyter Notebook para testes interativos"
                                  ],
                                  "tips": [
                                    "Use loops para demonstrar poder da instanciação múltipla.",
                                    "Diferencie self.atributo (instância) de Class.atributo (classe)."
                                  ],
                                  "learningObjective": "Integrar instanciação em código prático, destacando benefícios da OOO.",
                                  "commonMistakes": [
                                    "Confundir variáveis de instância com de classe",
                                    "Não usar self nos métodos"
                                  ]
                                }
                              ],
                              "practicalExample": "Defina classe Carro: class Carro: def __init__(self, cor, modelo): self.cor = cor; self.modelo = modelo; def acelerar(self): print(f'{self.modelo} acelerando!'). Instancie: carro1 = Carro('vermelho', 'Fusca'); carro2 = Carro('azul', 'Gol'); carro1.acelerar(); carro2.cor = 'verde'; print(carro2.cor)  # Saída: verde, provando independência.",
                              "finalVerifications": [
                                "Código roda sem erros de sintaxe ou runtime.",
                                "Múltiplas instâncias têm IDs diferentes (via id()).",
                                "Alterações em uma instância não afetam outras.",
                                "Atributos e métodos são acessíveis via notação de ponto.",
                                "Tipo do objeto é confirmado como a classe correta.",
                                "Exemplo prático com lista de objetos funciona."
                              ],
                              "assessmentCriteria": [
                                "Correta sintaxe de instanciação com construtor.",
                                "Demonstração explícita de independência de instâncias.",
                                "Manipulação correta de atributos e métodos.",
                                "Uso de verificações como id() e type().",
                                "Código limpo, comentado e escalável.",
                                "Integração em cenário prático funcional."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de entidades com variáveis independentes (funções compostas).",
                                "Ciências: Simulação de populações ou partículas independentes.",
                                "Design: Abstração de templates em prototipagem de produtos.",
                                "Lógica: Conceitos de conjuntos e instâncias únicas em raciocínio.",
                                "Artes: Criação de personagens únicos a partir de um 'molde' comum."
                              ],
                              "realWorldApplication": "Em desenvolvimento de jogos (instanciar inimigos únicos), apps de e-commerce (produtos em carrinho independentes), simulações científicas (partículas com propriedades únicas) ou sistemas bancários (contas de clientes separadas)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.2.2",
                            "name": "Acessar e modificar atributos de objetos",
                            "description": "Utilizar notação de ponto (.) para ler e alterar atributos de instância, respeitando convenções de nomenclatura e visibilidade pública/privada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender atributos de objetos e notação de ponto",
                                  "subSteps": [
                                    "Estude o conceito de atributos de instância em classes OOP.",
                                    "Aprenda a sintaxe da notação de ponto (objeto.atributo).",
                                    "Diferencie atributos públicos de privados (ex: _atributo ou __atributo em Python).",
                                    "Revise convenções de nomenclatura: snake_case para Python, camelCase para Java.",
                                    "Crie um diagrama mental ligando classe, instância e atributos."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre atributo de classe e instância, e demonstre a notação de ponto em pseudocódigo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação de Python OOP (docs.python.org), editor de texto como VS Code.",
                                  "tips": "Use exemplos simples como uma classe 'Carro' com atributo 'cor'.",
                                  "learningObjective": "Entender a estrutura e sintaxe básica para acessar atributos.",
                                  "commonMistakes": "Confundir notação de ponto com colchetes (usado para dicionários)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Acessar (ler) atributos de objetos",
                                  "subSteps": [
                                    "Crie uma classe simples com atributos públicos.",
                                    "Instancie o objeto e use notação de ponto para ler um atributo.",
                                    "Teste leitura de múltiplos atributos em sequência.",
                                    "Experimente acessar atributo inexistente para ver erros (AttributeError).",
                                    "Registre o valor lido em uma variável para uso posterior."
                                  ],
                                  "verification": "Execute código que imprima valores de atributos de um objeto sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ambiente Python (IDLE, Jupyter Notebook ou Replit).",
                                  "tips": "Sempre imprima o objeto com print(objeto) para inspecionar atributos.",
                                  "learningObjective": "Dominar a leitura de atributos usando notação de ponto.",
                                  "commonMistakes": "Esquecer parênteses em métodos vs. atributos (atributos não têm ())."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modificar (alterar) atributos de objetos",
                                  "subSteps": [
                                    "Use notação de ponto para atribuir novo valor a um atributo existente (objeto.atributo = novo_valor).",
                                    "Modifique atributos condicionalmente com if/else.",
                                    "Teste modificação em loop para múltiplas instâncias.",
                                    "Verifique a mudança lendo o atributo após alteração.",
                                    "Lide com validações básicas antes de modificar (ex: tipo correto)."
                                  ],
                                  "verification": "Altere um atributo e confirme a mudança com print antes/depois.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Mesmo ambiente Python do step anterior, exemplos de código salvos.",
                                  "tips": "Use variáveis temporárias para novos valores para evitar erros de digitação.",
                                  "learningObjective": "Habilitar alterações seguras em atributos de instância.",
                                  "commonMistakes": "Tentar modificar atributos privados sem getters/setters."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar convenções de nomenclatura e visibilidade",
                                  "subSteps": [
                                    "Renomeie atributos seguindo convenções (ex: self._privado).",
                                    "Implemente atributos privados com __ e teste acesso.",
                                    "Crie getters e setters para encapsulamento.",
                                    "Refatore código anterior para usar convenções corretas.",
                                    "Discuta em comentários por que visibilidade importa (segurança, manutenção)."
                                  ],
                                  "verification": "Código refatorado roda sem warnings de PEP8 e respeita visibilidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramenta de linting como pylint, PEP8 online checker.",
                                  "tips": "Prefixo _ indica 'não toque', __ name mangling para privado real.",
                                  "learningObjective": "Garantir código OOP limpo e seguro.",
                                  "commonMistakes": "Ignorar convenções levando a código confuso ou inseguro."
                                }
                              ],
                              "practicalExample": "Crie uma classe Pessoa: class Pessoa: def __init__(self, nome, idade): self.nome = nome; self._idade = idade. Instancie p = Pessoa('João', 30). Acesse print(p.nome). Modifique p.idade = 31. Para privado, use def get_idade(self): return self._idade.",
                              "finalVerifications": [
                                "Código acessa e modifica atributos sem AttributeError.",
                                "Atributos seguem convenções de nomenclatura (snake_case).",
                                "Atributos privados não são acessados diretamente.",
                                "Valores lidos/modificados são corretos em prints.",
                                "Múltiplas instâncias mantêm atributos independentes.",
                                "Refatoração remove todos os erros comuns identificados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sintaxe de notação de ponto (100% correto).",
                                "Uso adequado de visibilidade pública/privada.",
                                "Convenções de nomenclatura seguidas (PEP8).",
                                "Código funcional com exemplos de leitura e escrita.",
                                "Encapsulamento com getters/setters onde aplicável.",
                                "Tratamento de erros comuns demonstrado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estruturas de dados compostos semelhantes a vetores/matrizes.",
                                "Física: Modelagem de objetos reais (ex: partícula com posição/velocidade).",
                                "Língua Portuguesa: Nomenclatura clara e descritiva em variáveis.",
                                "Artes: Design de interfaces intuitivas para atributos de objetos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de jogos (Unity/C#), alterar posição de um personagem (objeto.pos_x = 10); em apps web (Django), atualizar perfil de usuário (user.nome = 'Novo Nome'); em simulações científicas, modificar parâmetros de modelos físicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.2.3",
                            "name": "Diferenciar tipagem estática e dinâmica em objetos",
                            "description": "Comparar o comportamento de objetos em linguagens de tipagem estática (C++) versus dinâmica (Python), verificando tipos em runtime.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os conceitos fundamentais de tipagem estática e dinâmica",
                                  "subSteps": [
                                    "Defina tipagem estática: tipos verificados em tempo de compilação, como em C++.",
                                    "Defina tipagem dinâmica: tipos verificados em tempo de execução, como em Python.",
                                    "Compare vantagens: estática previne erros cedo; dinâmica permite flexibilidade.",
                                    "Compare desvantagens: estática é rígida; dinâmica pode causar erros em runtime.",
                                    "Estude exemplos simples de variáveis para contextualizar objetos."
                                  ],
                                  "verification": "Escreva definições curtas e compare em um documento ou nota.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial C++ (cppreference.com)",
                                    "Documentação Python (docs.python.org)",
                                    "Bloco de notas ou editor de texto"
                                  ],
                                  "tips": "Use analogias: estática como 'declarar tipo de documento antes de imprimir'; dinâmica como 'verificar só ao ler'.",
                                  "learningObjective": "Diferenciar conceitualmente tipagem estática e dinâmica, preparando para aplicação em objetos.",
                                  "commonMistakes": [
                                    "Confundir com tipagem forte/fraca",
                                    "Ignorar verificação em runtime para dinâmica",
                                    "Achar que estática não permite polimorfismo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e testar objetos em C++ (tipagem estática)",
                                  "subSteps": [
                                    "Crie uma classe simples, como 'Pessoa' com atributos nome (string) e idade (int).",
                                    "Declare objetos com tipos explícitos e compile.",
                                    "Tente atribuir tipo incompatível (ex: string a int) e observe erro de compilação.",
                                    "Use operadores como dynamic_cast para verificação em runtime (opcional).",
                                    "Compile e execute para confirmar comportamento."
                                  ],
                                  "verification": "Código compila sem erros para tipos corretos e falha para incorretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador C++ (g++ ou IDE como Code::Blocks)",
                                    "Editor de código (VS Code)"
                                  ],
                                  "tips": "Sempre inclua #include <string> e using namespace std; para simplicidade.",
                                  "learningObjective": "Demonstrar como C++ enforce tipos em compile-time para objetos.",
                                  "commonMistakes": [
                                    "Esquecer ponto e vírgula após declarações",
                                    "Não inicializar membros da classe",
                                    "Confundir ponteiros com objetos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e testar objetos em Python (tipagem dinâmica)",
                                  "subSteps": [
                                    "Crie uma classe 'Pessoa' com atributos nome e idade usando self.",
                                    "Instancie objetos e atribua valores de diferentes tipos (ex: idade como string).",
                                    "Execute e observe erros apenas em runtime ao usar o atributo.",
                                    "Use isinstance() e type() para verificar tipos em runtime.",
                                    "Compare com o exemplo C++ executando lado a lado."
                                  ],
                                  "verification": "Código roda até uso incorreto do tipo, revelando erro em runtime.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Interpretador Python (IDLE ou Jupyter Notebook)",
                                    "Editor de código"
                                  ],
                                  "tips": "Use print(type(obj.idade)) para visualizar tipos dinamicamente.",
                                  "learningObjective": "Mostrar flexibilidade e riscos da tipagem dinâmica em objetos Python.",
                                  "commonMistakes": [
                                    "Esquecer self em métodos",
                                    "Não indentar corretamente",
                                    "Achar que Python verifica tipos em compile"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar comportamentos e verificar tipos em runtime",
                                  "subSteps": [
                                    "Crie códigos equivalentes em C++ e Python para a mesma classe.",
                                    "Teste cenários: atribuição válida/inválida, herança básica.",
                                    "Registre diferenças: C++ falha em compile; Python em runtime.",
                                    "Implemente verificações: static_cast em C++, isinstance em Python.",
                                    "Documente uma tabela de comparação."
                                  ],
                                  "verification": "Tabela ou relatório resume 3+ diferenças chave com evidências de código.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Dois terminais/IDs: um para C++, um para Python",
                                    "Planilha ou Markdown para tabela"
                                  ],
                                  "tips": "Rode códigos em paralelo para contrastes visuais imediatos.",
                                  "learningObjective": "Comparar e contrastar tipagem em objetos, enfatizando verificações runtime.",
                                  "commonMistakes": [
                                    "Ignorar overhead de runtime checks em dinâmica",
                                    "Não testar cenários de falha",
                                    "Generalizar demais sem exemplos"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie classe 'Carro' em C++: motor (int cilindradas) - erro se atribuir string. Em Python: motor aceita string inicialmente, mas falha ao somar: carro.motor + 100 gera TypeError em runtime.",
                              "finalVerifications": [
                                "Explicar verbalmente ou por escrito 3 diferenças chave entre estática e dinâmica.",
                                "Executar código C++ que falha em compile-time por tipo errado.",
                                "Executar código Python que falha em runtime por tipo errado.",
                                "Usar funções de type-checking em ambos (dynamic_cast/isinstance).",
                                "Preencher tabela comparativa com pelo menos 4 cenários.",
                                "Identificar quando usar cada tipo em projetos reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas sem confusões (30%)",
                                "Códigos funcionais: compilam/executam como esperado (25%)",
                                "Análise comparativa: tabela ou relatório claro e completo (20%)",
                                "Uso de verificações runtime: demonstrações práticas (15%)",
                                "Exemplos originais: além de cópias diretas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica booleana em type-checking (verdadeiro/falso).",
                                "Física/Engenharia: Modelagem de objetos reais com propriedades tipadas.",
                                "Língua Portuguesa/Inglês: Leitura de documentações técnicas bilíngues.",
                                "Filosofia: Debate rigidez vs flexibilidade em sistemas."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, tipagem estática (C++) é usada em sistemas embarcados para segurança (ex: carros autônomos); dinâmica (Python) em scripts de dados para prototipagem rápida (ex: análise de IA), ajudando na escolha de linguagem e debugging eficiente."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.3",
                        "name": "Métodos e Encapsulamento em Classes",
                        "description": "Definir métodos para encapsular comportamento e dados, promovendo abstração e controle de acesso em estruturas orientadas a objetos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.3.1",
                            "name": "Definir métodos de instância",
                            "description": "Criar funções dentro da classe que operam sobre instâncias específicas, usando 'self' em Python ou 'this' em C++, para manipular atributos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Métodos de Instância",
                                  "subSteps": [
                                    "Estude a definição: métodos de instância são funções definidas dentro de uma classe que operam em objetos específicos da classe.",
                                    "Aprenda o uso de 'self' em Python: refere-se à instância atual, permitindo acesso a atributos e outros métodos.",
                                    "Aprenda o uso de 'this' em C++: ponteiro para a instância atual, usado para acessar membros da classe.",
                                    "Compare com métodos de classe/estáticos: métodos de instância requerem uma instância para serem chamados.",
                                    "Revise exemplos simples de documentação oficial do Python e C++."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre self/this e um parâmetro regular de função, com um diagrama mental.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Python (docs.python.org), Documentação C++ (cppreference.com)",
                                    "Bloco de notas para anotações"
                                  ],
                                  "tips": "Pense em self/this como 'eu mesmo' – o objeto que está chamando o método.",
                                  "learningObjective": "Identificar quando e por que usar métodos de instância em vez de funções globais.",
                                  "commonMistakes": [
                                    "Confundir self/this com parâmetros de entrada",
                                    "Achar que self é global em vez de por instância"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir um Método de Instância Simples em Python",
                                  "subSteps": [
                                    "Crie uma classe básica, ex: class Carro: com atributo __init__(self, velocidade=0).",
                                    "Adicione um método de instância: def acelerar(self, incremento): self.velocidade += incremento.",
                                    "Crie uma instância: meu_carro = Carro() e chame meu_carro.acelerar(10).",
                                    "Imprima self.velocidade para verificar a mudança no atributo da instância.",
                                    "Teste com múltiplas instâncias para ver isolamento de dados."
                                  ],
                                  "verification": "Execute o código e confirme que atributos de instâncias diferentes não interferem.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Interpretador Python 3+"
                                  ],
                                  "tips": "Sempre inclua 'self' como primeiro parâmetro, mesmo que não o use explicitamente.",
                                  "learningObjective": "Implementar um método que modifica atributos específicos de uma instância usando self.",
                                  "commonMistakes": [
                                    "Esquecer 'self' na definição do método",
                                    "Chamar método sem instância (ex: Carro.acelerar())"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir um Método de Instância em C++",
                                  "subSteps": [
                                    "Crie uma classe: class Carro { private: int velocidade; public: Carro(int v=0); void acelerar(int incremento); };",
                                    "Implemente o construtor e o método: void Carro::acelerar(int incremento) { this->velocidade += incremento; }",
                                    "No main(), crie instâncias: Carro meuCarro; meuCarro.acelerar(10);",
                                    "Adicione um getter: int getVelocidade() { return this->velocidade; } e teste.",
                                    "Compile e execute para verificar o comportamento."
                                  ],
                                  "verification": "Compile sem erros e observe que this-> é opcional mas útil para clareza.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Compilador C++ (g++ ou IDE como Code::Blocks)",
                                    "Editor de texto"
                                  ],
                                  "tips": "Use this-> explicitamente para evitar ambiguidades com parâmetros locais.",
                                  "learningObjective": "Criar métodos que acessam e modificam membros de instância via this em C++.",
                                  "commonMistakes": [
                                    "Declarar métodos sem acesso público",
                                    "Esquecer ponto-e-vírgula após declarações de classe"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Depurar e Aplicar Encapsulamento",
                                  "subSteps": [
                                    "Adicione validações nos métodos: ex: if incremento < 0, não acelerar.",
                                    "Crie múltiplos métodos interdependentes: ex: frear(self, decremento) que chama acelerar(-decremento).",
                                    "Teste edge cases: aceleração negativa, múltiplas chamadas.",
                                    "Use print/debugger para rastrear mudanças em self/this->atributos.",
                                    "Refatore para usar propriedades privadas e getters/setters."
                                  ],
                                  "verification": "Código roda sem erros, métodos alteram apenas a instância correta, e validações funcionam.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Debugger integrado no IDE",
                                    "Exemplos de código anteriores"
                                  ],
                                  "tips": "Priorize encapsulamento: torne atributos private e acesse via métodos.",
                                  "learningObjective": "Integrar métodos de instância em classes funcionais com depuração.",
                                  "commonMistakes": [
                                    "Modificar atributos diretamente sem métodos",
                                    "Ignorar validações de input"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe ContaBancaria com métodos de instância depositar(self, valor) e sacar(self, valor) que usam self.saldo para atualizar o balance da conta específica, impedindo saques acima do saldo.",
                              "finalVerifications": [
                                "Criar e chamar método de instância em Python e C++ sem erros de sintaxe.",
                                "Método acessa e modifica corretamente atributos da instância (não compartilhados).",
                                "Múltiplas instâncias mantêm estados independentes.",
                                "Validações básicas funcionam (ex: não valores negativos onde inapropriado).",
                                "Código é legível com self/this usado consistentemente.",
                                "Testes unitários simples passam (ex: assert saldo mudou)."
                              ],
                              "assessmentCriteria": [
                                "Correta definição de métodos com self/this como primeiro argumento.",
                                "Manipulação precisa de atributos de instância (leitura/escrita).",
                                "Ausência de vazamento de estado entre instâncias.",
                                "Encapsulamento adequado (atributos privados, acesso via métodos).",
                                "Tratamento de erros e validações implementados.",
                                "Eficiência e clareza no código (nomes descritivos, comentários)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações aritméticas em atributos (soma, subtração em simulações).",
                                "Física: Modelagem de objetos com métodos para movimento (velocidade, aceleração).",
                                "Lógica e Álgebra: Condicionais e fluxos em métodos para decisões.",
                                "Design de Sistemas: Princípios de modularidade semelhantes a engenharia de software."
                              ],
                              "realWorldApplication": "Em desenvolvimento de jogos (métodos para mover personagens), apps bancários (gerenciar saldos por usuário), simulações científicas (atualizar estados de partículas) ou e-commerce (carrinhos de compra por sessão)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.3.2",
                            "name": "Implementar encapsulamento com getters e setters",
                            "description": "Proteger atributos privados e expor acesso controlado via métodos públicos, aplicando convenções como _ ou __ em Python para visibilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Declarar atributos privados em uma classe Python",
                                  "subSteps": [
                                    "Crie uma nova classe, por exemplo, 'ContaBancaria'.",
                                    "Adicione atributos de instância prefixados com um underscore simples (_) para protected, como _saldo.",
                                    "Use dois underscores (__) para atributos private verdadeiros, como __senha, para name mangling.",
                                    "Inicialize os atributos no método __init__ com valores padrão ou parâmetros.",
                                    "Instancie a classe e tente acessar os atributos diretamente para observar o comportamento."
                                  ],
                                  "verification": "Execute o código e confirme que acessar obj.__senha gera AttributeError ou nome mangled (_ContaBancaria__senha).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código Python (VS Code ou PyCharm)",
                                    "Console Python interativo"
                                  ],
                                  "tips": "Use print(dir(obj)) para inspecionar atributos disponíveis e entender name mangling.",
                                  "learningObjective": "Compreender e aplicar convenções de visibilidade (_ e __) para proteger dados em classes.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar no __init__",
                                    "Usar atributos públicos por engano",
                                    "Confundir _ (protected) com __ (private)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar métodos getter para acesso controlado",
                                  "subSteps": [
                                    "Defina um método getter público, como def get_saldo(self):, sem parâmetros além de self.",
                                    "Retorne o valor do atributo privado dentro do getter, ex: return self._saldo.",
                                    "Para __senha, use o nome mangled: return self._ContaBancaria__senha.",
                                    "Adicione o getter à classe e teste chamando obj.get_saldo().",
                                    "Verifique que o getter funciona sem expor o atributo diretamente."
                                  ],
                                  "verification": "Chame o getter e confirme que retorna o valor correto sem acessar o atributo privado diretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código Python",
                                    "Documentação oficial Python sobre classes"
                                  ],
                                  "tips": "Getters devem ser simples e read-only; evite lógica complexa inicialmente.",
                                  "learningObjective": "Criar métodos getter que forneçam acesso de leitura seguro a atributos privados.",
                                  "commonMistakes": [
                                    "Passar parâmetros no getter",
                                    "Retornar referência mutável em vez de valor",
                                    "Esquecer 'self' no retorno"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar métodos setter com validação",
                                  "subSteps": [
                                    "Crie um setter público, como def set_saldo(self, valor):.",
                                    "Adicione validação: if valor < 0: raise ValueError('Saldo não pode ser negativo').",
                                    "Atribua o valor validado ao atributo privado: self._saldo = valor.",
                                    "Para senha, valide comprimento: if len(valor) < 6: raise ValueError(...).",
                                    "Teste setters com valores válidos e inválidos para verificar exceções."
                                  ],
                                  "verification": "Use setter com valor inválido e confirme que levanta ValueError; valor válido atualiza corretamente via getter.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplos de exceções Python"
                                  ],
                                  "tips": "Sempre valide inputs nos setters para manter integridade dos dados.",
                                  "learningObjective": "Desenvolver setters que protejam atributos com lógica de validação robusta.",
                                  "commonMistakes": [
                                    "Não validar inputs",
                                    "Atribuir sem checks",
                                    "Usar print em vez de raise para erros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e verificar o encapsulamento completo",
                                  "subSteps": [
                                    "Crie uma instância da classe e execute acessos diretos falhando.",
                                    "Use getters e setters em sequência: set_saldo(100), get_saldo() == 100.",
                                    "Teste cenários de erro: set_saldo(-10) levanta exceção.",
                                    "Adicione métodos de uso como depositar() que chama setter internamente.",
                                    "Execute testes unitários simples ou interativos para cobertura total."
                                  ],
                                  "verification": "Todos os testes passam: acessos diretos falham, getters/setters funcionam com validação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Unittest ou pytest para testes",
                                    "Console Python"
                                  ],
                                  "tips": "Escreva testes antes de codificar para garantir encapsulamento (TDD).",
                                  "learningObjective": "Validar que o encapsulamento protege dados e expõe apenas APIs controladas.",
                                  "commonMistakes": [
                                    "Ignorar name mangling em testes",
                                    "Não testar casos de falha",
                                    "Expor setters desnecessários"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe ContaBancaria:\nclass ContaBancaria:\n    def __init__(self, saldo_inicial=0):\n        self._saldo = saldo_inicial\n        self.__senha = '123456'\n    def get_saldo(self):\n        return self._saldo\n    def set_saldo(self, valor):\n        if valor < 0:\n            raise ValueError('Saldo inválido')\n        self._saldo = valor\n    def get_senha(self):\n        return self._ContaBancaria__senha\n\nconta = ContaBancaria(100)\nprint(conta.get_saldo())  # 100\nconta.set_saldo(200)\nprint(conta.get_saldo())  # 200\n# print(conta._saldo)  # Funciona mas convenção contra\n# print(conta.__senha)  # AttributeError",
                              "finalVerifications": [
                                "Atributos privados não são acessíveis diretamente (AttributeError ou convenção violada).",
                                "Getters retornam valores corretos sem modificar estado.",
                                "Setters validam inputs e atualizam apenas valores válidos.",
                                "Name mangling funciona para __atributos (visível via _Class__attr).",
                                "Instância mantém integridade de dados após múltiplas operações.",
                                "Exceções são levantadas corretamente em validações falhas."
                              ],
                              "assessmentCriteria": [
                                "Uso correto de _ e __ para atributos (name mangling aplicado).",
                                "Getters são públicos, read-only e sem parâmetros extras.",
                                "Setters incluem validação lógica com raise ValueError.",
                                "Classe inicializa atributos privados adequadamente.",
                                "Testes demonstram falha em acesso direto e sucesso via métodos.",
                                "Código segue PEP 8 e é legível."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Validações numéricas e lógica condicional em setters.",
                                "Segurança da Informação: Proteção de dados sensíveis via encapsulamento.",
                                "Design de Sistemas: Princípios de abstração e interfaces públicas.",
                                "Lógica Computacional: Tratamento de exceções e fluxos de erro."
                              ],
                              "realWorldApplication": "Em aplicativos bancários para proteger saldos e PINs, evitando acessos indevidos; em jogos para gerenciar vida/HP de personagens com validações; em sistemas de e-commerce para controlar estoques com checks de não-negatividade."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.3.3",
                            "name": "Criar métodos e variáveis estáticas",
                            "description": "Definir elementos estáticos compartilhados por todas as instâncias, acessíveis via nome da classe, para utilitários e contadores globais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de membros estáticos",
                                  "subSteps": [
                                    "Diferencie variáveis e métodos de instância (pertencem a objetos) de estáticos (pertencem à classe).",
                                    "Identifique cenários de uso: contadores globais, constantes compartilhadas e utilitários sem estado.",
                                    "Analise exemplos simples de código onde elementos estáticos são acessados diretamente pela classe.",
                                    "Explique o ciclo de vida: inicializados uma vez na carga da classe.",
                                    "Discuta implicações de thread-safety em ambientes multithread."
                                  ],
                                  "verification": "Escreva um parágrafo explicando a diferença e cenários de uso, sem erros conceituais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (ex: IntelliJ, VS Code)",
                                    "Documentação oficial da linguagem (Java/Kotlin)"
                                  ],
                                  "tips": "Visualize a classe como um blueprint: estáticos são compartilhados por todos os objetos criados.",
                                  "learningObjective": "Dominar os fundamentos teóricos de elementos estáticos para aplicação correta.",
                                  "commonMistakes": [
                                    "Confundir acessibilidade: tentar usar 'this' em estáticos.",
                                    "Ignorar inicialização lazy para variáveis pesadas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar e manipular variáveis estáticas",
                                  "subSteps": [
                                    "Declare uma variável estática com a palavra-chave 'static' (ex: private static int contador = 0;).",
                                    "Inicialize-a diretamente ou via bloco static {}.",
                                    "Acesse-a via nome da classe (ex: MinhaClasse.contador++) de qualquer lugar.",
                                    "Modifique seu valor em métodos de instância e observe o compartilhamento entre objetos.",
                                    "Adicione modificador final para constantes (ex: public static final double PI = 3.14159;)."
                                  ],
                                  "verification": "Compile e execute código que incrementa uma variável estática compartilhada por múltiplas instâncias.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador/IDE com suporte a Java ou similar",
                                    "Terminal para execução"
                                  ],
                                  "tips": "Use 'static final' para constantes imutáveis, evitando recálculos desnecessários.",
                                  "learningObjective": "Criar e gerenciar variáveis estáticas de forma funcional e segura.",
                                  "commonMistakes": [
                                    "Acessar via instância em vez de classe (funciona, mas polui o código).",
                                    "Esquecer 'private' e expor dados globalmente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar e invocar métodos estáticos",
                                  "subSteps": [
                                    "Declare um método estático com 'static' (ex: public static int somar(int a, int b) { return a + b; }).",
                                    "Invoque-o diretamente pela classe (ex: Calculadora.somar(2, 3);), sem instância.",
                                    "Passe parâmetros e retorne valores, simulando funções utilitárias.",
                                    "Chame métodos estáticos de outros métodos estáticos ou de instância.",
                                    "Implemente um método estático que acessa/modifica variáveis estáticas."
                                  ],
                                  "verification": "Crie e teste um método estático que utilize uma variável estática, confirmando resultados corretos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "IDE com debugger",
                                    "Exemplos de código de referência"
                                  ],
                                  "tips": "Mantenha métodos estáticos puros (sem side-effects) para reutilização fácil.",
                                  "learningObjective": "Desenvolver métodos estáticos independentes de instâncias para lógica compartilhada.",
                                  "commonMistakes": [
                                    "Tentar acessar variáveis de instância dentro de métodos estáticos.",
                                    "Recursão infinita ao chamar métodos estáticos incorretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e testar em cenários completos",
                                  "subSteps": [
                                    "Integre variáveis e métodos estáticos em uma classe funcional (ex: gerenciador de IDs únicos).",
                                    "Crie múltiplas instâncias e verifique compartilhamento via prints e asserts.",
                                    "Refatore código existente para usar estáticos onde apropriado.",
                                    "Teste edge cases: carga da classe, multithreading básico com synchronized.",
                                    "Documente o código com Javadoc destacando elementos estáticos."
                                  ],
                                  "verification": "Execute testes unitários que validem o comportamento estático em cenários variados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Framework de testes (JUnit)",
                                    "Debugger integrado"
                                  ],
                                  "tips": "Evite overuse de estáticos para não violar princípios OO; prefira singletons quando necessário.",
                                  "learningObjective": "Integrar elementos estáticos em aplicações reais com testes robustos.",
                                  "commonMistakes": [
                                    "Violação de encapsulamento com acessos públicos desnecessários.",
                                    "Ignorar problemas de concorrência em apps multi-thread."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie a classe ContadorGlobal: private static int totalInstancias = 0; public ContadorGlobal() { totalInstancias++; } public static int getTotal() { return totalInstancias; }. Instancie 5 objetos e chame ContadorGlobal.getTotal() para retornar 5.",
                              "finalVerifications": [
                                "Explicar verbalmente ou por escrito quando usar estáticos vs não-estáticos.",
                                "Criar classe com variável estática compartilhada e método estático acessor.",
                                "Demonstrar acesso correto sem instância e com múltiplas instâncias.",
                                "Identificar e corrigir erros comuns em código fornecido.",
                                "Implementar constante estática final e usá-la em cálculos.",
                                "Testar em ambiente com asserts para confirmação numérica."
                              ],
                              "assessmentCriteria": [
                                "Correção sintática: uso preciso de 'static' e modificadores.",
                                "Compreensão conceitual: distinção clara entre instância e classe.",
                                "Funcionalidade: código compila, executa e produz resultados esperados.",
                                "Boas práticas: encapsulamento, documentação e avoidance de abusos.",
                                "Testabilidade: inclusão de verificações e edge cases.",
                                "Eficiência: inicialização adequada e performance implícita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Constantes universais como PI e funções utilitárias como sqrt().",
                                "Física: Simulações com contadores globais de partículas ou eventos.",
                                "Design de Software: Padrões como Factory Method usando métodos estáticos.",
                                "Banco de Dados: Contadores de IDs sequenciais compartilhados.",
                                "Administração: Métricas globais de performance em sistemas empresariais."
                              ],
                              "realWorldApplication": "Em aplicativos web para contadores de usuários únicos (ex: Logger.totalLogs), classes utilitárias como Math.random() ou geradores de IDs em bancos de dados distribuídos, evitando duplicação de lógica comum."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.3.4",
                            "name": "Representar classes em UML básico",
                            "description": "Desenhar diagramas de classe UML simples mostrando atributos, métodos e relacionamentos, usando notação padrão para visualização de tipos compostos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a estrutura básica de uma classe UML",
                                  "subSteps": [
                                    "Identifique as três seções principais: nome da classe (topo), atributos (meio) e métodos (fundo).",
                                    "Aprenda a notação do retângulo dividido por linhas horizontais.",
                                    "Estude símbolos de visibilidade: + para público, - para privado, # para protegido.",
                                    "Pratique esboçando um retângulo vazio com divisões.",
                                    "Revise exemplos de classes simples como 'Pessoa'."
                                  ],
                                  "verification": "Desenhe um retângulo com as três seções corretamente rotuladas e símbolos de visibilidade.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Editor online como draw.io ou Lucidchart"
                                  ],
                                  "tips": "Mantenha proporções equilibradas entre seções para clareza visual.",
                                  "learningObjective": "Compreender e reproduzir a estrutura visual padrão de uma classe UML.",
                                  "commonMistakes": [
                                    "Confundir ordem das seções (atributos acima de métodos)",
                                    "Esquecer símbolos de visibilidade",
                                    "Usar texto em vez de símbolos (+/-)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar atributos e métodos com notação padrão",
                                  "subSteps": [
                                    "Liste atributos no formato: visibilidade nome : tipo (ex: - nome : String).",
                                    "Adicione métodos no formato: visibilidade nome(param : tipo) : tipoRetorno (ex: + getNome() : String).",
                                    "Inclua tipos de dados compostos como arrays ou objetos (ex: - cursos : List<Curso>).",
                                    "Alinhe itens verticalmente dentro das seções.",
                                    "Valide sintaxe com referência UML oficial."
                                  ],
                                  "verification": "Crie uma classe com pelo menos 3 atributos e 2 métodos corretamente formatados.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Referência UML 2.5 (PDF online)",
                                    "Ferramenta de diagramação digital"
                                  ],
                                  "tips": "Use itálico para tipos de retorno em métodos e evite abreviações desnecessárias.",
                                  "learningObjective": "Dominar a notação textual para atributos e métodos, incluindo tipos compostos.",
                                  "commonMistakes": [
                                    "Omitir tipos de dados",
                                    "Colocar parâmetros incorretamente em métodos",
                                    "Misturar atributos com métodos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar relacionamentos básicos entre classes",
                                  "subSteps": [
                                    "Desenhe setas para herança (triângulo vazio → seta sólida).",
                                    "Use linha sólida para associação simples, com multiplicidade (ex: 1..*).",
                                    "Represente agregação (diamante vazio) e composição (diamante preenchido).",
                                    "Adicione rótulos nas linhas de relacionamento (ex: 'possui').",
                                    "Posicione classes logicamente no diagrama."
                                  ],
                                  "verification": "Conecte duas classes com pelo menos dois tipos de relacionamentos corretos.",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Papel milimetrado para alinhamento",
                                    "Software UML como PlantUML ou Visual Paradigm"
                                  ],
                                  "tips": "Comece com herança para simplicidade e teste espaçamento para evitar cruzamentos de linhas.",
                                  "learningObjective": "Aplicar notações padrão para relacionamentos em diagramas de classe UML.",
                                  "commonMistakes": [
                                    "Confundir agregação com composição",
                                    "Esquecer multiplicidade",
                                    "Usar setas erradas para direção"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Criar e refinar um diagrama de classe completo",
                                  "subSteps": [
                                    "Escolha um cenário com tipos compostos (ex: classe com lista de objetos).",
                                    "Desenhe todas as classes, atributos, métodos e relacionamentos.",
                                    "Revise legibilidade: títulos em negrito, espaçamento uniforme.",
                                    "Adicione notas para esclarecimentos se necessário.",
                                    "Exporte ou fotografe o diagrama final."
                                  ],
                                  "verification": "Produza um diagrama funcional com 2-3 classes interconectadas sem erros de notação.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Ferramenta digital para edição",
                                    "Modelo de exemplo impresso"
                                  ],
                                  "tips": "Itere duas vezes: desenhe rascunho primeiro, refine depois.",
                                  "learningObjective": "Integrar todos os elementos em um diagrama UML coeso e profissional.",
                                  "commonMistakes": [
                                    "Sobrecarregar o diagrama com muitos elementos",
                                    "Ignorar alinhamento",
                                    "Erros de digitação em nomes"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um diagrama UML para o sistema de biblioteca: Classe 'Livro' (- isbn: String, - titulo: String, + emprestar(): void) associada a 'Usuario' (1 para *), com agregação para 'Autor'. Use composição se 'Livro' contiver 'Capitulo[]'.",
                              "finalVerifications": [
                                "Diagrama possui retângulos com três seções corretas e visibilidades.",
                                "Atributos e métodos incluem tipos, especialmente compostos.",
                                "Relacionamentos têm setas, multiplicidades e rótulos apropriados.",
                                "Diagrama é legível e sem cruzamentos desnecessários de linhas.",
                                "Notação segue padrões UML 2.x sem ambiguidades.",
                                "Exemplo prático é representado fielmente."
                              ],
                              "assessmentCriteria": [
                                "Precisão da notação UML (100% conformidade).",
                                "Completude: todos elementos (atributos, métodos, relacionamentos) presentes.",
                                "Clareza visual e organização do diagrama.",
                                "Correta representação de tipos compostos.",
                                "Uso adequado de multiplicidades e rótulos.",
                                "Ausência de erros comuns como visibilidades omitidas."
                              ],
                              "crossCurricularConnections": [
                                "Banco de Dados: Similaridade com diagramas ER para modelagem de entidades.",
                                "Design de Software: Integração com padrões de projeto como MVC.",
                                "Matemática: Representação de conjuntos e relações (multiplicidade como cardinalidade).",
                                "Artes Visuais: Princípios de diagramação e hierarquia visual.",
                                "Negócios: Modelagem de processos em análise de requisitos."
                              ],
                              "realWorldApplication": "Desenvolvedores usam diagramas UML para documentar designs de classes em projetos de software, facilitando comunicação em equipes, revisão de código e manutenção de sistemas como apps de e-commerce ou ERPs."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.3",
                    "name": "Operadores Aritméticos e Relacionais",
                    "description": "Aplicação de operadores numéricos, de comparação e atribuição em contextos de programação OO.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.3.1",
                        "name": "Operadores Aritméticos",
                        "description": "Operadores que executam operações matemáticas básicas (+, -, *, /, //, %, **) em tipos numéricos, aplicados em contextos de programação orientada a objetos, incluindo sobrecarga em classes.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.1.1",
                            "name": "Aplicar operadores aritméticos em expressões simples",
                            "description": "Realizar operações básicas de soma, subtração, multiplicação, divisão, módulo e exponenciação usando inteiros e floats em métodos de classes OO, demonstrando resultados corretos em instâncias de objetos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar operadores aritméticos básicos e sua sintaxe em OO",
                                  "subSteps": [
                                    "Liste os operadores: + (soma), - (subtração), * (multiplicação), / (divisão), % (módulo), ** (exponenciação).",
                                    "Identifique tipos suportados: int e float.",
                                    "Estude precedência: parênteses > ** > * / % > + -.",
                                    "Pratique expressões simples no console: 2 + 3, 10 / 3.0, 2 ** 3.",
                                    "Anote exemplos com mistura de int e float."
                                  ],
                                  "verification": "Crie 5 expressões simples e execute no interpretador, confirmando resultados esperados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código (VS Code ou PyCharm), interpretador Python.",
                                  "tips": "Use print() para visualizar resultados imediatamente.",
                                  "learningObjective": "Compreender sintaxe e comportamento dos operadores aritméticos com diferentes tipos numéricos.",
                                  "commonMistakes": "Confundir / (float) com // (int); ignorar precedência sem parênteses."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir uma classe com atributos numéricos (int e float)",
                                  "subSteps": [
                                    "Crie classe 'Calculadora' com __init__ recebendo dois parâmetros: num1 (int) e num2 (float).",
                                    "Atribua self.num1 e self.num2.",
                                    "Adicione método de string representation (__str__) para mostrar valores.",
                                    "Instancie um objeto e imprima para verificar inicialização.",
                                    "Teste com diferentes valores: inteiros e floats misturados."
                                  ],
                                  "verification": "Instancie Calculadora(5, 2.5) e imprima; confirme self.num1=5 (int), self.num2=2.5 (float).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de código, Python instalado.",
                                  "tips": "Use type() para verificar tipos dos atributos.",
                                  "learningObjective": "Criar classes OO com atributos numéricos e instanciá-las corretamente.",
                                  "commonMistakes": "Esquecer self. nos atributos; não tratar tipos no __init__."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar métodos de classe usando operadores aritméticos",
                                  "subSteps": [
                                    "Adicione método soma(): return self.num1 + self.num2.",
                                    "Crie métodos para subtracao(), multiplicacao(), divisao(), modulo(), exponenciacao().",
                                    "Inclua expressões compostas: ex. multiplicacao(): return (self.num1 * 2) + self.num2.",
                                    "Use parênteses para controlar precedência em expressões complexas.",
                                    "Teste cada método com print em uma instância."
                                  ],
                                  "verification": "Chame todos os métodos em uma instância e compare saídas com cálculos manuais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código da classe anterior, calculadora física para validação.",
                                  "tips": "Nomeie métodos descritivamente; retorne valores em vez de imprimir dentro do método.",
                                  "learningObjective": "Aplicar operadores em métodos de instância, lidando com tipos e precedência.",
                                  "commonMistakes": "Dividir por zero sem verificação; usar ** incorretamente com floats."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e demonstrar resultados em múltiplas instâncias",
                                  "subSteps": [
                                    "Crie 3 instâncias com valores variados (int+int, int+float, float+float).",
                                    "Para cada instância, chame todos os métodos e armazene resultados em variáveis.",
                                    "Crie um método teste_todos() que executa e imprime todos os cálculos.",
                                    "Compare resultados com expectativas usando assert ou if.",
                                    "Registre saídas em um log ou arquivo."
                                  ],
                                  "verification": "Execute teste_todos() em todas instâncias sem erros; todos resultados corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Código completo, terminal para execução.",
                                  "tips": "Use loops para testar múltiplas instâncias eficientemente.",
                                  "learningObjective": "Demonstrar uso correto de operadores em objetos OO através de testes.",
                                  "commonMistakes": "Não converter tipos implicitamente; erros de indentação em métodos."
                                }
                              ],
                              "practicalExample": "Crie classe Calculadora:\nclass Calculadora:\n    def __init__(self, num1, num2):\n        self.num1 = int(num1)\n        self.num2 = float(num2)\n    def soma(self):\n        return self.num1 + self.num2\n    def multiplicacao(self):\n        return self.num1 * self.num2\n# Uso: calc = Calculadora(10, 3.5)\nprint(calc.soma())  # 13.5\nprint(calc.multiplicacao())  # 35.0",
                              "finalVerifications": [
                                "Método soma retorna valor correto para int + float (ex: 5 + 2.5 = 7.5).",
                                "Divisão produz float (ex: 10 / 4 = 2.5).",
                                "Módulo funciona com negativos (ex: 10 % 3 = 1).",
                                "Exponenciação eleva corretamente (ex: 2 ** 3 = 8).",
                                "Precedência respeitada em expressões compostas.",
                                "Tipos mantidos: int em entradas int, float em resultados de /."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática em todos os operadores (100% acerto nos testes).",
                                "Uso apropriado de self e instâncias OO.",
                                "Manuseio correto de tipos int/float sem conversões desnecessárias.",
                                "Código limpo, indentado e com nomes descritivos.",
                                "Testes abrangentes cobrindo casos edge (zero, negativos).",
                                "Demonstração de precedência com parênteses."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Reforça operações fundamentais e ordem de operações (PEMDAS).",
                                "Física: Cálculos de velocidade (distância/tempo) em simulações OO.",
                                "Economia: Operações em finanças, como juros compostos (**).",
                                "Engenharia: Modelagem de sistemas com classes numéricas."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, como jogos (cálculo de pontuações com soma/multiplicação), apps financeiros (juros com exponenciação) ou simuladores científicos (fórmulas físicas em classes OO), garantindo precisão em cálculos numéricos distribuídos por objetos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.2",
                            "name": "Utilizar operadores aritméticos em métodos de instância",
                            "description": "Implementar métodos em classes que utilizem operadores aritméticos para calcular propriedades de objetos, como somar atributos numéricos de duas instâncias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a classe com atributos numéricos",
                                  "subSteps": [
                                    "Crie uma classe chamada 'Conta' utilizando a sintaxe 'class Conta:'",
                                    "Implemente o método construtor __init__(self, saldo) e atribua self.saldo = saldo",
                                    "Crie duas instâncias de teste: c1 = Conta(100) e c2 = Conta(200)",
                                    "Adicione um print(c1.saldo) e print(c2.saldo) para verificação inicial",
                                    "Salve o código em um arquivo .py"
                                  ],
                                  "verification": "Execute o script e confirme que c1.saldo == 100 e c2.saldo == 200 sem erros de sintaxe",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Python 3.8+ instalado",
                                    "Terminal para execução"
                                  ],
                                  "tips": "Sempre inclua self como primeiro parâmetro em métodos de instância",
                                  "learningObjective": "Compreender a criação de classes e atributos de instância numéricos em Python",
                                  "commonMistakes": [
                                    "Esquecer 'self' nos parâmetros ou atribuições",
                                    "Erro de indentação no corpo da classe",
                                    "Usar nomes de variáveis inconsistentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar método simples usando operadores em atributos próprios",
                                  "subSteps": [
                                    "Adicione o método def dobrar_saldo(self): dentro da classe",
                                    "No corpo do método, retorne self.saldo * 2",
                                    "Teste chamando print(c1.dobrar_saldo()) e confirme saída 200",
                                    "Adicione uma docstring '''Retorna o dobro do saldo atual.'''",
                                    "Execute e verifique múltiplas chamadas"
                                  ],
                                  "verification": "O método retorna corretamente o valor dobrado para diferentes instâncias",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Mesmo editor e Python do passo anterior",
                                    "Console para prints de teste"
                                  ],
                                  "tips": "Use operadores aritméticos diretamente nos atributos para simplicidade",
                                  "learningObjective": "Aplicar operadores aritméticos (* para multiplicação) em atributos de instância dentro de métodos",
                                  "commonMistakes": [
                                    "Retornar self.saldo em vez de self.saldo * 2",
                                    "Esquecer return",
                                    "Confundir com atributos estáticos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar método usando operadores entre duas instâncias",
                                  "subSteps": [
                                    "Adicione o método def somar_saldos(self, outra): dentro da classe",
                                    "Implemente return self.saldo + outra.saldo no corpo",
                                    "Teste com print(c1.sommar_saldos(c2)) e confirme saída 300",
                                    "Teste com valores diferentes: crie c3 = Conta(50) e verifique c1.sommar_saldos(c3) == 150",
                                    "Adicione docstring '''Soma o saldo de self com o de outra instância.'''"
                                  ],
                                  "verification": "O método soma corretamente saldos de instâncias diferentes, incluindo casos com float",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Python interpreter"
                                  ],
                                  "tips": "Garanta que 'outra' seja uma instância da mesma classe para coerência",
                                  "learningObjective": "Utilizar operadores aritméticos (+) entre atributos de múltiplas instâncias em um método",
                                  "commonMistakes": [
                                    "Esquecer self. ou outra.",
                                    "Passar valor numérico em vez de instância",
                                    "Não tratar tipos incompatíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, depurar e expandir o método",
                                  "subSteps": [
                                    "Teste com saldos negativos: c4 = Conta(-100), verifique c1.sommar_saldos(c4) == 0",
                                    "Adicione suporte a divisão: def dividir_saldos(self, outra): return self.saldo / outra.saldo se outra.saldo != 0",
                                    "Crie uma função de teste unitário simples usando assert",
                                    "Depure qualquer erro com print intermediários",
                                    "Refatore o código para incluir type hints: def somar_saldos(self, outra: 'Conta') -> float"
                                  ],
                                  "verification": "Todos os testes passam sem exceções e resultados esperados são exibidos",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor com suporte a debugging",
                                    "Biblioteca unittest (opcional)"
                                  ],
                                  "tips": "Use try-except para divisão por zero em expansões futuras",
                                  "learningObjective": "Validar e refinar métodos com operadores aritméticos através de testes abrangentes",
                                  "commonMistakes": [
                                    "Não testar casos edge como zero ou negativo",
                                    "Ignorar type errors",
                                    "Expor implementação interna desnecessariamente"
                                  ]
                                }
                              ],
                              "practicalExample": "```python\nclass Conta:\n    def __init__(self, saldo: float):\n        self.saldo = saldo\n\n    def dobrar_saldo(self) -> float:\n        \"\"\"Retorna o dobro do saldo.\"\"\"\n        return self.saldo * 2\n\n    def somar_saldos(self, outra: 'Conta') -> float:\n        \"\"\"Soma saldos de duas contas.\"\"\"\n        return self.saldo + outra.saldo\n\n# Teste\nc1 = Conta(100.0)\nc2 = Conta(200.0)\nprint(c1.dobrar_saldo())  # 200.0\nprint(c1.sommar_saldos(c2))  # 300.0\n```",
                              "finalVerifications": [
                                "Código executa sem erros de sintaxe ou runtime",
                                "Métodos retornam valores numéricos corretos para entradas variadas",
                                "Instâncias mantêm atributos inalterados após chamadas de métodos",
                                "Docstrings estão presentes e descrevem corretamente a funcionalidade",
                                "Testes com valores negativos, zero e float passam",
                                "Type hints opcionais melhoram legibilidade sem quebrar código"
                              ],
                              "assessmentCriteria": [
                                "Uso correto e consistente de 'self' em todos os métodos",
                                "Operadores aritméticos aplicados precisamente aos atributos",
                                "Métodos são idempotentes (não modificam estado do objeto)",
                                "Código segue PEP 8 (indentação, espaçamentos)",
                                "Testes cobrem casos normais e edge cases",
                                "Documentação clara com docstrings e comentários"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Reforça operações aritméticas básicas (+, -, *, /)",
                                "Matemática Financeira: Cálculos de saldos e totais em contextos econômicos",
                                "Física: Similar a soma de vetores ou forças em simulações",
                                "Estatística: Agregação de dados numéricos em objetos"
                              ],
                              "realWorldApplication": "Em aplicativos bancários para calcular totais de transferências entre contas, em jogos para somar pontuações de jogadores, em sistemas de estoque para totalizar valores de produtos, ou em simulações científicas para agregar medidas numéricas de objetos modelados."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.3",
                            "name": "Sobrecarregar operadores aritméticos em classes",
                            "description": "Definir métodos especiais como __add__, __sub__ e __mul__ em classes Python ou equivalentes em C++ para permitir operações aritméticas entre objetos personalizados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos de Sobrecarga de Operadores Aritméticos",
                                  "subSteps": [
                                    "Estude a definição de sobrecarga de operadores: permitir que operadores como +, -, * sejam usados com objetos de classes personalizadas.",
                                    "Identifique métodos especiais em Python (__add__, __sub__, __mul__, etc.) e operadores equivalentes em C++ (operator+ , operator- , etc.).",
                                    "Revise exemplos básicos de classes Python sem sobrecarga e compare com o comportamento esperado após implementação.",
                                    "Analise a documentação oficial do Python para dunder methods e do C++ para operator overloading.",
                                    "Crie um diagrama mental ligando operadores nativos a métodos de classe."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos principais e liste 3 operadores aritméticos com seus métodos correspondentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação Python (docs.python.org), Documentação C++ (cppreference.com), Notebook para anotações.",
                                  "tips": "Comece com Python por ser mais simples; use print statements para debugar chamadas de métodos.",
                                  "learningObjective": "Entender o propósito e a sintaxe básica de sobrecarga de operadores em OOP.",
                                  "commonMistakes": "Confundir métodos especiais com funções normais; ignorar precedência de operadores."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Sobrecarga de Operadores em Python",
                                  "subSteps": [
                                    "Crie uma classe simples, como Vetor2D, com atributos x e y.",
                                    "Defina o método __add__ para somar dois vetores, retornando um novo objeto Vetor2D.",
                                    "Implemente __sub__ e __mul__ (multiplicação escalar) seguindo o mesmo padrão.",
                                    "Teste com instâncias: v1 + v2, v1 - v2, v1 * 2.",
                                    "Adicione __str__ para imprimir resultados de forma legível."
                                  ],
                                  "verification": "Execute código e confirme que v1 + v2 produz o vetor soma correto sem erros de sintaxe.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor Python (VS Code ou PyCharm), Interpretador Python 3.8+.",
                                  "tips": "Sempre retorne um novo objeto para evitar mutação; use self para acessar atributos.",
                                  "learningObjective": "Implementar métodos especiais para operadores aritméticos em classes Python.",
                                  "commonMistakes": "Esquecer de retornar self ou novo objeto; não tratar tipos diferentes nos argumentos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Sobrecarga em C++ e Comparar com Python",
                                  "subSteps": [
                                    "Defina uma struct ou class Vetor2D em C++ com membros double x, y.",
                                    "Sobrecarregue operator+ como membro ou friend function, retornando Vetor2D por valor.",
                                    "Implemente operator- e operator* seguindo o modelo de operator+.",
                                    "Compile e teste: Vetor2D v3 = v1 + v2; use cout para output.",
                                    "Compare sintaxe e comportamento com a versão Python."
                                  ],
                                  "verification": "Compilar sem warnings e executar testes que imprimam resultados corretos.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Compilador C++ (g++), IDE como CLion ou Code::Blocks.",
                                  "tips": "Use friend functions para operadores não-membros; evite operator+ como membro se precisar de simetria.",
                                  "learningObjective": "Aplicar sobrecarga de operadores em C++ e contrastar com Python.",
                                  "commonMistakes": "Esquecer #include <iostream>; não inicializar membros na declaração."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Depurar e Aplicar em um Cenário Prático",
                                  "subSteps": [
                                    "Crie testes unitários para todos os operadores em Python e C++ (use assert em Python, manual em C++).",
                                    "Introduza erros comuns (ex: divisão por zero em mul) e depure usando debugger.",
                                    "Estenda a classe para suportar mais operadores como __truediv__ ou operator/.",
                                    "Aplique em um mini-projeto: simule soma de forças vetoriais.",
                                    "Documente o código com comentários explicando cada sobrecarga."
                                  ],
                                  "verification": "Todos os testes passam e o mini-projeto roda sem crashes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Biblioteca unittest para Python, Debugger integrado na IDE.",
                                  "tips": "Use pytest para testes mais robustos em Python; priorize casos edge como zero vectors.",
                                  "learningObjective": "Validar implementações através de testes e aplicar em contextos reais.",
                                  "commonMistakes": "Não testar com objetos nulos; ignorar overflow em C++."
                                }
                              ],
                              "practicalExample": "Classe Vetor2D em Python: def __add__(self, other): return Vetor2D(self.x + other.x, self.y + other.y). Uso: v1 = Vetor2D(1,2); v2 = Vetor2D(3,4); print(v1 + v2) -> Vetor2D(4,6). Equivalente em C++: Vetor2D operator+(const Vetor2D& other) const { return {x + other.x, y + other.y}; }.",
                              "finalVerifications": [
                                "Criar duas instâncias de classe e usar + para somar sem erros.",
                                "Verificar que - subtrai corretamente os atributos.",
                                "* multiplica por escalar e retorna novo objeto.",
                                "Impressão via print ou cout mostra valores esperados.",
                                "Testes com valores negativos e zero passam.",
                                "Código compila e roda em ambos Python e C++."
                              ],
                              "assessmentCriteria": [
                                "Código implementa todos os métodos corretamente (100%).",
                                "Explicação clara dos conceitos em comentários (20%).",
                                "Testes abrangentes cobrem casos normais e edge (30%).",
                                "Eficiência: sem mutações desnecessárias ou loops extras (20%).",
                                "Comparação Python vs C++ documentada (15%).",
                                "Aplicação prática funcional (15%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra vetorial e operações lineares.",
                                "Física: Cálculo de forças e velocidades em simulações.",
                                "Engenharia de Software: Design de APIs intuitivas como NumPy.",
                                "Matemática Computacional: Operadores em bibliotecas científicas."
                              ],
                              "realWorldApplication": "Em bibliotecas como NumPy ou Eigen (C++), permite sintaxe natural como arr1 + arr2 para arrays, facilitando simulações científicas, jogos (Unity com Vector3 + Vector3) e machine learning sem código verboso."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.2",
                        "name": "Operadores Relacionais",
                        "description": "Operadores de comparação (==, !=, >, <, >=, <=) usados para avaliar relações entre valores numéricos ou objetos em programação OO, com suporte a sobrecarga.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.2.1",
                            "name": "Aplicar operadores relacionais em expressões booleanas",
                            "description": "Comparar valores numéricos usando operadores ==, !=, >, <, >= e <= em condições dentro de métodos de classes, retornando valores booleanos corretos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os operadores relacionais",
                                  "subSteps": [
                                    "Liste os operadores relacionais: == (igual), != (diferente), > (maior), < (menor), >= (maior ou igual), <= (menor ou igual).",
                                    "Estude o significado de cada um com exemplos numéricos simples, como 5 == 5 (true) e 5 > 3 (true).",
                                    "Diferencie operadores relacionais de aritméticos, focando no retorno booleano (true/false).",
                                    "Pratique mentalmente 10 comparações variadas entre números inteiros e decimais.",
                                    "Anote exemplos onde cada operador resulta em true e false."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o resultado de 5 expressões usando cada operador.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Documentação da linguagem de programação (ex: Java/Python)"
                                  ],
                                  "tips": "Sempre teste com valores iguais e diferentes para visualizar o comportamento.",
                                  "learningObjective": "Identificar e descrever corretamente o funcionamento de todos os operadores relacionais.",
                                  "commonMistakes": [
                                    "Confundir == (comparação) com = (atribuição)",
                                    "Ignorar precedência em expressões mistas",
                                    "Esquecer que compara valores numéricos, não strings"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir expressões booleanas simples",
                                  "subSteps": [
                                    "Escreva 10 expressões booleanas isoladas, como (10 > 5), (3.14 <= 3.14).",
                                    "Inclua comparações com variáveis: int a = 7; boolean res = (a != 0);.",
                                    "Teste as expressões em um interpretador ou compilador para verificar saídas booleanas.",
                                    "Combine operadores simples com parênteses para priorizar, ex: (x > 0) && (x < 10).",
                                    "Registre os resultados em uma tabela: expressão | valor esperado | resultado obtido."
                                  ],
                                  "verification": "Execute e capture saídas de pelo menos 8 expressões corretas sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (IDE como VS Code ou IntelliJ)",
                                    "Compilador/interpretador da linguagem"
                                  ],
                                  "tips": "Use System.out.println() ou print() para visualizar booleanos imediatamente.",
                                  "learningObjective": "Criar e avaliar expressões booleanas usando operadores relacionais com precisão.",
                                  "commonMistakes": [
                                    "Omitir parênteses em expressões compostas",
                                    "Usar == em floats sem considerar precisão",
                                    "Confundir tipos de dados (int vs double)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar operadores em métodos de classes",
                                  "subSteps": [
                                    "Crie uma classe simples, ex: class Numero { private int valor; }.",
                                    "Adicione um método booleano, ex: public boolean isPositivo() { return valor > 0; }.",
                                    "Implemente 4 métodos usando diferentes operadores: isZero(), isMaiorQue(int outro), etc.",
                                    "Instancie a classe e chame os métodos em main() para testar retornos booleanos.",
                                    "Adicione parâmetros aos métodos para comparações dinâmicas."
                                  ],
                                  "verification": "Compile e execute a classe com testes que cubram todos os operadores, confirmando booleanos corretos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "IDE com suporte a OOP",
                                    "Exemplos de classes básicas"
                                  ],
                                  "tips": "Retorne diretamente a expressão booleana para simplicidade inicial.",
                                  "learningObjective": "Aplicar operadores relacionais dentro de métodos de classes orientadas a objetos.",
                                  "commonMistakes": [
                                    "Acessar variáveis privadas sem getters",
                                    "Retornar void em vez de boolean",
                                    "Erros de escopo de variáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e depurar expressões em contextos reais",
                                  "subSteps": [
                                    "Crie cenários de teste: valores edge cases como 0, negativos, floats iguais.",
                                    "Use condicionais if-else nos métodos para validar booleanos, ex: if (isMaior()) { ... }.",
                                    "Introduza bugs propositalmente (ex: usar < em vez de <=) e depure com debugger.",
                                    "Escreva 5 testes unitários simples para cada método.",
                                    "Refatore o código para maior legibilidade, adicionando comentários."
                                  ],
                                  "verification": "Todos os testes passam com 100% de acerto em booleanos esperados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramentas de debug (breakpoints)",
                                    "Framework de testes básico (JUnit ou similar)"
                                  ],
                                  "tips": "Sempre teste com valores limite para capturar erros sutis.",
                                  "learningObjective": "Validar e depurar aplicações de operadores relacionais em classes.",
                                  "commonMistakes": [
                                    "Ignorar casos de precisão em decimais",
                                    "Não testar valores zero ou negativos",
                                    "Confundir operadores compostos"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie a classe ContaBancaria: public class ContaBancaria { private double saldo; public ContaBancaria(double saldoInicial) { this.saldo = saldoInicial; } public boolean temSaldoSuficiente(double valor) { return saldo >= valor; } public boolean saldoZero() { return saldo == 0; } public boolean emDebito() { return saldo < 0; } } No main: ContaBancaria c = new ContaBancaria(100.0); System.out.println(c.temSaldoSuficiente(50.0)); // true",
                              "finalVerifications": [
                                "Lista e explica corretamente os 6 operadores relacionais.",
                                "Escreve e executa 10 expressões booleanas sem erros sintáticos.",
                                "Implementa métodos de classe que retornam booleanos precisos.",
                                "Passa em testes com casos edge (0, negativos, floats).",
                                "Depura e corrige bugs em expressões relacionais.",
                                "Integra operadores em condicionais dentro de métodos OO."
                              ],
                              "assessmentCriteria": [
                                "Correção sintática e semântica das expressões (100%).",
                                "Cobertura de todos os 6 operadores em exemplos.",
                                "Retorno booleano preciso em todos os métodos testados.",
                                "Tratamento adequado de tipos numéricos (int/double).",
                                "Uso correto de OOP (encapsulamento, métodos).",
                                "Eficiência e legibilidade do código."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Resolução de desigualdades e equalidades numéricas.",
                                "Lógica: Construção de proposições verdadeiras/falsas.",
                                "Física: Condições em simulações (ex: velocidades comparadas).",
                                "Estatística: Filtros de dados baseados em thresholds."
                              ],
                              "realWorldApplication": "Em aplicativos bancários para verificar se saldo >= saque solicitado; em jogos para detectar colisões (posição1 < posição2); em sistemas de estoque para alertar quando quantidade <= mínimo; ou em análises de dados para filtrar registros onde idade > 18."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.2.2",
                            "name": "Usar operadores relacionais em comparações de objetos",
                            "description": "Implementar comparações entre instâncias de classes utilizando atributos numéricos em estruturas condicionais como if/else em contextos OO.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir uma classe simples com atributos numéricos",
                                  "subSteps": [
                                    "Selecione uma linguagem OO como Python ou Java.",
                                    "Crie uma classe exemplo, como 'Carro', com atributos numéricos (ex: velocidade_maxima: int, ano_fabricacao: int).",
                                    "Implemente o construtor (__init__ em Python ou constructor em Java) para inicializar os atributos.",
                                    "Crie uma instância da classe e atribua valores numéricos aos atributos.",
                                    "Teste o acesso aos atributos via print ou getter."
                                  ],
                                  "verification": "Execute o código e confirme que a instância é criada e atributos são acessíveis sem erros (ex: print(carro1.velocidade_maxima) mostra o valor correto).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Documentação oficial da linguagem OO (Python classes ou Java objects)"
                                  ],
                                  "tips": "Sempre inicialize atributos no construtor para evitar valores None ou null.",
                                  "learningObjective": "Dominar a criação de classes e objetos com atributos numéricos acessíveis.",
                                  "commonMistakes": [
                                    "Esquecer 'self.' em Python ou 'this.' em Java",
                                    "Usar tipo string em vez de int/float para atributos numéricos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar múltiplas instâncias e praticar acesso a atributos",
                                  "subSteps": [
                                    "Crie pelo menos duas instâncias da classe com valores diferentes para atributos numéricos (ex: carro1.velocidade_maxima = 180, carro2 = 200).",
                                    "Acesse os atributos de cada instância e armazene em variáveis temporárias.",
                                    "Imprima os valores para visualização.",
                                    "Experimente operações aritméticas simples nos atributos (ex: soma ou média).",
                                    "Verifique tipos dos atributos com funções como type() em Python."
                                  ],
                                  "verification": "Todas as instâncias são criadas e atributos impressos corretamente, sem erros de tipo ou referência nula.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Mesmo editor de código",
                                    "Console/terminal para execução interativa"
                                  ],
                                  "tips": "Use variáveis descritivas como carro1_velocidade para clareza durante testes.",
                                  "learningObjective": "Habilitar manipulação fluida de múltiplos objetos e seus atributos numéricos.",
                                  "commonMistakes": [
                                    "Confundir atributos entre instâncias",
                                    "Não converter strings para int ao atribuir valores"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar operadores relacionais em comparações de atributos",
                                  "subSteps": [
                                    "Liste operadores relacionais: ==, !=, >, <, >=, <=.",
                                    "Compare atributos de duas instâncias (ex: if carro1.velocidade_maxima > carro2.velocidade_maxima).",
                                    "Armazene o resultado da comparação em uma variável booleana.",
                                    "Teste todos os operadores com diferentes valores (maior, menor, igual).",
                                    "Registre os resultados booleanos via print."
                                  ],
                                  "verification": "Resultados booleanos corretos para pelo menos 6 cenários de comparação (ex: True para > quando 180 > 150).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Referência rápida de operadores relacionais da linguagem"
                                  ],
                                  "tips": "Lembre-se: comparações são entre valores numéricos, não objetos inteiros (não use == em objetos diretamente).",
                                  "learningObjective": "Executar comparações precisas usando operadores relacionais em atributos de objetos.",
                                  "commonMistakes": [
                                    "Comparar objetos diretamente em vez de atributos",
                                    "Ignorar precedência com parênteses desnecessários"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar comparações em estruturas condicionais if/else",
                                  "subSteps": [
                                    "Estruture um if/else usando comparação relacional de atributos (ex: if carro1.ano > carro2.ano: print('Carro1 mais novo')).",
                                    "Adicione elif para casos de igualdade e else para o restante.",
                                    "Inclua múltiplas condições com and/or (ex: if velocidade > 150 and ano > 2020).",
                                    "Execute com dados variados e observe saídas.",
                                    "Adicione tratamento de exceções para atributos inválidos."
                                  ],
                                  "verification": "Estrutura if/else executa corretamente em 5+ testes variados, produzindo mensagens condicionais apropriadas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplos de código de condicionais OO"
                                  ],
                                  "tips": "Use indentação correta e blocos else para cobrir todos os casos possíveis.",
                                  "learningObjective": "Construir lógica condicional robusta baseada em comparações de objetos.",
                                  "commonMistakes": [
                                    "Erro de indentação em blocos if/else",
                                    "Usar = em vez de == em condições"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe 'Pessoa' com atributo 'idade' (int). Instancie pessoa1 (25 anos) e pessoa2 (30 anos). Use if/else com operador > para imprimir 'Pessoa2 é mais velha' se pessoa2.idade > pessoa1.idade, elif para igualdade e else para o contrário. Teste alterando idades.",
                              "finalVerifications": [
                                "Código compila/executa sem erros de sintaxe ou runtime.",
                                "Comparações retornam booleanos corretos para todos operadores testados.",
                                "Estruturas if/else produzem saídas esperadas em cenários variados.",
                                "Atributos numéricos são manipulados sem perda de precisão.",
                                "Múltiplas instâncias coexistem sem interferência.",
                                "Tratamento básico de edge cases (ex: idades iguais ou negativas) funciona."
                              ],
                              "assessmentCriteria": [
                                "Correção lógica: Comparações e condicionais funcionam como esperado (40%).",
                                "Clareza do código: Nomes descritivos e comentários (20%).",
                                "Cobertura de operadores: Pelo menos 4 operadores relacionais usados (15%).",
                                "Robustez: Lida com casos edge sem crash (15%).",
                                "Eficiência: Sem loops ou operações desnecessárias (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aplicação de desigualdades e relações de ordem em números reais.",
                                "Lógica e Filosofia: Construção de proposições condicionais e tabelas-verdade.",
                                "Física: Comparação de grandezas mensuráveis como velocidade ou massa em simulações.",
                                "Estatística: Ordenação e filtragem de dados baseados em thresholds relacionais."
                              ],
                              "realWorldApplication": "Em sistemas de e-commerce para comparar preços de produtos (atributos de objetos Item); em jogos para detectar colisões baseadas em posições (x > y); em apps de fitness para alertar se frequência cardíaca > limite seguro; ou em bancos para verificar se saldo >= valor de saque."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.2.3",
                            "name": "Sobrecarregar operadores relacionais",
                            "description": "Definir métodos como __eq__, __lt__ e __gt__ em classes para personalizar comparações entre objetos, permitindo ordenação ou igualdade customizada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender operadores relacionais e métodos especiais em Python",
                                  "subSteps": [
                                    "Estude os operadores relacionais: ==, !=, <, >, <=, >= e como funcionam com tipos built-in (int, str, list).",
                                    "Leia a documentação oficial sobre métodos especiais (dunder methods) como __eq__, __ne__, __lt__, __le__, __gt__, __ge__.",
                                    "Execute exemplos simples no interpretador Python para ver o comportamento padrão em objetos de classes customizadas.",
                                    "Anote as diferenças entre comparação de valor (==) e identidade (is).",
                                    "Identifique cenários onde a comparação padrão falha em classes personalizadas."
                                  ],
                                  "verification": "Explique em um parágrafo como __eq__ é chamado pelo operador == e demonstre com print(id(objeto)) em comparações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Python: https://docs.python.org/3/reference/datamodel.html#special-method-names",
                                    "Editor Python (IDLE ou VS Code)",
                                    "Interpretador Python"
                                  ],
                                  "tips": "Use dir(objeto) para listar métodos especiais disponíveis em uma instância.",
                                  "learningObjective": "Entender o mecanismo subjacente dos operadores relacionais e os métodos especiais responsáveis por eles.",
                                  "commonMistakes": [
                                    "Confundir comparação de valor (==) com identidade (is)",
                                    "Ignorar que métodos não implementados usam comparação de identidade por padrão",
                                    "Não testar com objetos mutáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar sobrecarga de igualdade (__eq__ e __ne__)",
                                  "subSteps": [
                                    "Crie uma classe simples, como 'Ponto', com atributos x e y.",
                                    "Defina o método __eq__ para comparar se dois pontos têm as mesmas coordenadas.",
                                    "Implemente __ne__ explicitamente ou deixe Python derivá-lo de __eq__.",
                                    "Teste com instâncias iguais e diferentes usando == e !=.",
                                    "Adicione tratamento para comparação com None ou tipos incompatíveis."
                                  ],
                                  "verification": "Crie dois pontos iguais e diferentes; verifique se == retorna True/False corretamente e imprima o resultado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código Python",
                                    "Jupyter Notebook para testes interativos"
                                  ],
                                  "tips": "Sempre retorne NotImplemented se o outro objeto for de tipo incompatível para evitar erros.",
                                  "learningObjective": "Personalizar comparação de igualdade entre instâncias de classes customizadas.",
                                  "commonMistakes": [
                                    "Retornar True/False sem comparar atributos relevantes",
                                    "Esquecer de usar self e other nos parâmetros",
                                    "Não lidar com tipos diferentes no método"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar operadores de ordem (__lt__, __gt__, etc.)",
                                  "subSteps": [
                                    "Na classe Ponto, defina __lt__ para comparar pela soma x+y (distância ao origem aproximada).",
                                    "Implemente __gt__, __le__, __ge__ de forma consistente (ou derive-os).",
                                    "Teste comparações <, > entre múltiplas instâncias.",
                                    "Garanta transitividade: se A < B e B < C, então A < C.",
                                    "Adicione __repr__ para depuração visual."
                                  ],
                                  "verification": "Crie três pontos com somas crescentes e verifique se A < B < C funciona.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor Python",
                                    "Documentação de rich comparisons"
                                  ],
                                  "tips": "Retorne NotImplemented para permitir fallback ou herança; evite loops infinitos em comparações.",
                                  "learningObjective": "Habilitar ordenação total entre objetos customizados.",
                                  "commonMistakes": [
                                    "Implementar apenas __lt__ sem consistência nos outros",
                                    "Violar propriedades de ordem (não irreflexivo, assimétrico)",
                                    "Comparar tipos errados sem verificação isinstance"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em ordenação e estruturas de dados",
                                  "subSteps": [
                                    "Crie uma lista de 5 instâncias da classe Ponto.",
                                    "Use sorted(lista) ou lista.sort() e verifique a ordenação pela soma x+y.",
                                    "Teste com chave personalizada vs. sobrecarga de operadores.",
                                    "Integre em um dict com chaves como objetos (requer hashable via __hash__).",
                                    "Debug erros comuns como TypeError em sorting."
                                  ],
                                  "verification": "Imprima a lista antes e depois de sorted(); confirme ordem crescente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python lists e sorted()",
                                    "Exemplos de código testados"
                                  ],
                                  "tips": "Para sorting eficiente, implemente apenas __lt__ e __gt__; os outros são derivados.",
                                  "learningObjective": "Utilizar operadores sobrecarregados em algoritmos de ordenação reais.",
                                  "commonMistakes": [
                                    "Objetos não hashable em sets/dicts sem __hash__",
                                    "Ordenação instável sem chave única",
                                    "Esquecer que sorted() requer total order"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Refatorar e otimizar para cenários avançados",
                                  "subSteps": [
                                    "Adicione __hash__ consistente com __eq__ para uso em sets e dicts.",
                                    "Teste com max(), min() em listas de objetos.",
                                    "Crie um exemplo com herança: subclasse que altera critério de comparação.",
                                    "Profile performance com timeit em listas grandes.",
                                    "Documente a classe com docstrings explicando o critério de comparação."
                                  ],
                                  "verification": "Use set de pontos iguais (deve ter um elemento) e min/max em lista.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "timeit module",
                                    "pydoc para documentação"
                                  ],
                                  "tips": " __hash__ deve ser baseado nos mesmos atributos de __eq__ para consistência.",
                                  "learningObjective": "Garantir compatibilidade com estruturas de dados e boas práticas.",
                                  "commonMistakes": [
                                    "__hash__ inconsistente levando a erros em dicts",
                                    "Performance ruim em comparações complexas",
                                    "Não documentar critério de comparação"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe 'Produto' com atributos 'nome' (str) e 'preco' (float). Sobrecarregue __eq__ para igualdade por nome e preco, e __lt__ para comparar por preco. Crie uma lista de produtos e use sorted() para ordená-los por preco crescente. Teste: produtos = [Produto('A', 10), Produto('B', 5)]; assert sorted(produtos)[0].nome == 'B'.",
                              "finalVerifications": [
                                "Instâncias com atributos iguais retornam True em == e False em !=.",
                                "Lista de objetos ordena corretamente com sorted() sem erros TypeError.",
                                "max() e min() funcionam em listas de objetos usando o critério customizado.",
                                "Objetos são hashable e funcionam como chaves em dicts sem duplicatas inesperadas.",
                                "Comparações com objetos de tipos diferentes retornam NotImplemented ou valor lógico correto.",
                                "Propriedades de ordem são respeitadas (transitividade, irreflexividade)."
                              ],
                              "assessmentCriteria": [
                                "Correta implementação de todos métodos especiais relevantes sem erros de sintaxe.",
                                "Consistência entre __eq__ e __hash__ para uso em coleções.",
                                "Testes unitários passam para cenários de igualdade, ordem e sorting.",
                                "Critério de comparação é claro, documentado e baseado em atributos relevantes.",
                                "Eficiência: comparações O(1) e sorting O(n log n) em listas médias.",
                                "Tratamento robusto de casos edge (None, tipos incompatíveis)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Relações de ordem total e parciais, propriedades de equivalência.",
                                "Algoritmos e Estruturas de Dados: Implementação de comparações para quicksort, heaps.",
                                "Design de Software: Princípios de usabilidade em APIs intuitivas (operadores naturais).",
                                "Banco de Dados: Custom sorting em queries SQL-like.",
                                "Física/Engenharia: Comparação de vetores ou medidas em simulações."
                              ],
                              "realWorldApplication": "Em e-commerce, ordenar produtos por preço ou relevância; em jogos, priorizar entidades por distância ou score; em data science, custom sorting de DataFrames ou objetos em pandas; em sistemas de gerenciamento, comparar registros por múltiplos critérios sem funções lambda verbosas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.2.4",
                            "name": "Combinar operadores relacionais em expressões lógicas",
                            "description": "Construir expressões compostas com operadores relacionais e lógicos (and, or, not) em métodos de classes para validações complexas de objetos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Operadores Relacionais",
                                  "subSteps": [
                                    "Liste os principais operadores relacionais: == (igual), != (diferente), > (maior), < (menor), >= (maior ou igual), <= (menor ou igual).",
                                    "Escreva exemplos simples para cada operador usando variáveis numéricas e de string, como idade > 18 ou nome != null.",
                                    "Teste cada operador em um console ou editor de código para observar o retorno booleano (true/false).",
                                    "Identifique contextos onde cada operador é útil em validações de objetos.",
                                    "Pratique com variáveis de diferentes tipos (int, string, double)."
                                  ],
                                  "verification": "Liste corretamente os 6 operadores com pelo menos um exemplo funcional cada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (IDE como VS Code ou IntelliJ)",
                                    "Documentação da linguagem de programação (ex: Java/Python)"
                                  ],
                                  "tips": "Sempre teste expressões em código real para visualizar resultados booleanos.",
                                  "learningObjective": "Dominar o uso de operadores relacionais e seus retornos booleanos.",
                                  "commonMistakes": [
                                    "Confundir == com = (atribuição)",
                                    "Esquecer de lidar com null em comparações de strings",
                                    "Usar > em strings sem conversão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender Operadores Lógicos",
                                  "subSteps": [
                                    "Estude AND (&& ou and): retorna true se ambas as condições forem true.",
                                    "Estude OR (|| ou or): retorna true se pelo menos uma condição for true.",
                                    "Estude NOT (! ou not): inverte o valor booleano de uma expressão.",
                                    "Crie tabelas-verdade manuais para combinações simples de AND, OR e NOT.",
                                    "Teste operadores lógicos com expressões relacionais básicas no código."
                                  ],
                                  "verification": "Construa e execute 3 tabelas-verdade para AND, OR e NOT com resultados corretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para tabelas-verdade",
                                    "Editor de código com console interativo"
                                  ],
                                  "tips": "Lembre-se da precedência: NOT > AND > OR; use parênteses para clareza.",
                                  "learningObjective": "Aplicar operadores lógicos em combinações booleanas simples.",
                                  "commonMistakes": [
                                    "Esquecer parênteses em expressões mistas",
                                    "Confundir curto-circuite (&& para AND)",
                                    "Aplicar NOT incorretamente em compostas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir Expressões Lógicas Compostas",
                                  "subSteps": [
                                    "Combine operadores relacionais com lógicos: ex. (idade >= 18 && salario > 1000) || isEstudante.",
                                    "Crie 5 expressões complexas variando AND, OR e NOT.",
                                    "Teste cada expressão com valores de entrada diferentes para validar saídas.",
                                    "Refatore expressões para maior legibilidade usando parênteses.",
                                    "Simule cenários de validação como 'apto para empréstimo' ou 'usuário premium'."
                                  ],
                                  "verification": "Implemente e teste 5 expressões compostas com 100% de acerto nos casos de teste.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Conjunto de dados de teste (variáveis mock)"
                                  ],
                                  "tips": "Use variáveis mock para testar múltiplos cenários rapidamente.",
                                  "learningObjective": "Criar expressões booleanas compostas funcionais e legíveis.",
                                  "commonMistakes": [
                                    "Precedência errada sem parênteses",
                                    "Não testar bordas como 0, null ou negativos",
                                    "Expressões muito longas sem quebra"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar em Métodos de Classes para Validações",
                                  "subSteps": [
                                    "Crie uma classe simples (ex: Pessoa) com atributos como nome, idade, salario.",
                                    "Implemente um método isValid() usando expressões compostas para validar o objeto.",
                                    "Adicione métodos específicos como podeVotar() ou ehElegivel().",
                                    "Teste o método com instâncias válidas e inválidas.",
                                    "Refatore para lidar com exceções ou valores nulos."
                                  ],
                                  "verification": "Classe com método de validação que passa em 10 testes unitários.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "IDE com suporte a testes unitários (JUnit ou pytest)",
                                    "Templates de classes POO"
                                  ],
                                  "tips": "Retorne booleanos claros e adicione logs para depuração.",
                                  "learningObjective": "Aplicar expressões lógicas em validações orientadas a objetos.",
                                  "commonMistakes": [
                                    "Acessar atributos null sem verificação",
                                    "Método público sem encapsulamento",
                                    "Ignorar exceções em validações"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma classe Pessoa:\npublic boolean isElegivelParaEmprestimo() {\n  return (idade >= 18 && salario > 2000.0) || (idade >= 65 && patrimonio > 50000);\n}\nTeste: Pessoa p1 = new Pessoa(25, 2500); p1.isElegivelParaEmprestimo() -> true",
                              "finalVerifications": [
                                "Construir expressão: (nota >= 7 && faltas <= 10) || recuperacaoAprovada",
                                "Implementar validação em classe sem erros de sintaxe",
                                "Testar com 5 cenários variados retornando resultados corretos",
                                "Explicar precedência em uma expressão mista com NOT",
                                "Refatorar expressão longa para legibilidade",
                                "Aplicar em método de objeto com atributos null/zero"
                              ],
                              "assessmentCriteria": [
                                "Sintaxe correta de operadores relacionais e lógicos (100%)",
                                "Lógica booleana precisa em todos os casos de teste",
                                "Legibilidade com parênteses e nomes descritivos",
                                "Integração adequada em métodos POO com encapsulamento",
                                "Tratamento de bordas (null, extremos) sem exceções",
                                "Eficiência com curto-circuite onde aplicável"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra Booleana e Tabelas-Verdade",
                                "Lógica Formal: Proposições Compostas",
                                "Banco de Dados: Cláusulas WHERE com AND/OR",
                                "Matemática Discreta: Simplificação de Expressões Lógicas"
                              ],
                              "realWorldApplication": "Validações em sistemas empresariais, como regras de aprovação de crédito em bancos (idade && renda), filtros de busca em e-commerces ou autenticação de usuários em apps (email válido && senha forte)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.3",
                        "name": "Operadores de Atribuição",
                        "description": "Operadores compostos de atribuição (=, +=, -=, *=, /=, //=, %=) para modificar valores de atributos em objetos OO, com possibilidade de sobrecarga.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.3.1",
                            "name": "Utilizar operadores de atribuição simples e compostos",
                            "description": "Atribuir e atualizar valores numéricos em atributos de instâncias de classes usando =, +=, -=, *= e /= em métodos mutadores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e praticar atribuição simples com operador =",
                                  "subSteps": [
                                    "Crie uma variável numérica local e atribua um valor inicial usando =.",
                                    "Altere o valor da variável múltiplas vezes com novas atribuições =.",
                                    "Imprima o valor após cada atribuição para observar as mudanças.",
                                    "Teste atribuição em diferentes tipos numéricos (int e float).",
                                    "Experimente atribuir o resultado de expressões aritméticas."
                                  ],
                                  "verification": "Execute o código e confirme que os prints mostram valores atualizados corretamente sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código como VSCode ou PyCharm",
                                    "Interpretador Python ativo"
                                  ],
                                  "tips": "Use print() imediatamente após cada atribuição para visualizar mudanças em tempo real.",
                                  "learningObjective": "Dominar o uso do operador = para inicializar e atualizar valores numéricos em variáveis.",
                                  "commonMistakes": [
                                    "Confundir = (atribuição) com == (comparação)",
                                    "Esquecer de inicializar a variável antes de usá-la"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar operadores de atribuição compostos (+=, -=, *=, /=)",
                                  "subSteps": [
                                    "Crie variáveis numéricas e aplique += para somar valores incrementalmente.",
                                    "Pratique -= para subtrair valores de uma variável existente.",
                                    "Use *= para multiplicar o valor atual por um fator.",
                                    "Aplique /= para dividir o valor atual por um divisor, observando resultados float.",
                                    "Combine múltiplos operadores em sequência e imprima resultados intermediários."
                                  ],
                                  "verification": "Código executa sem erros e produz saídas numéricas esperadas para todos os operadores.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Documentação oficial de Python sobre operadores"
                                  ],
                                  "tips": "Lembre-se que operadores compostos modificam a variável in-place, economizando linhas de código.",
                                  "learningObjective": "Aplicar corretamente os operadores compostos para atualizar valores de forma concisa.",
                                  "commonMistakes": [
                                    "Usar /= com divisão por zero",
                                    "Esquecer que /= retorna float mesmo com inteiros"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar atribuições em atributos de instâncias de classes",
                                  "subSteps": [
                                    "Defina uma classe simples com um atributo numérico privado (ex: self._saldo).",
                                    "Crie um método mutador simples usando = para definir o atributo.",
                                    "Adicione métodos mutadores compostos: depositar (+=), sacar (-=), render (+=*), dividir (/=).",
                                    "Instancie a classe e chame os métodos em sequência.",
                                    "Acesse o atributo via getter para verificar atualizações."
                                  ],
                                  "verification": "Instância da classe reflete mudanças corretas no atributo após chamadas de métodos, confirmado por prints ou asserts.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de código com suporte a Python",
                                    "Console para testes interativos"
                                  ],
                                  "tips": "Sempre use self. para acessar atributos de instância dentro dos métodos.",
                                  "learningObjective": "Integrar operadores de atribuição em métodos mutadores de classes OO para modificar estados de objetos.",
                                  "commonMistakes": [
                                    "Esquecer self. no atributo",
                                    "Modificar atributo diretamente sem método mutador"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, depurar e otimizar o uso em cenários completos",
                                  "subSteps": [
                                    "Crie um script principal que instancie múltiplos objetos e aplique sequências de mutações.",
                                    "Adicione validações nos métodos (ex: evitar saldo negativo em saques).",
                                    "Depure erros comuns como divisão por zero ou tipos incompatíveis.",
                                    "Otimize métodos para lidar com entradas inválidas usando try-except.",
                                    "Execute testes unitários simples para verificar comportamentos."
                                  ],
                                  "verification": "Todos os testes passam sem exceções e resultados atendem expectativas definidas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Biblioteca unittest do Python",
                                    "Editor com debugger"
                                  ],
                                  "tips": "Use asserts para automação de verificações durante o desenvolvimento.",
                                  "learningObjective": "Garantir robustez e correção no uso de operadores de atribuição em contextos OO reais.",
                                  "commonMistakes": [
                                    "Não tratar exceções em operações como /=0",
                                    "Ignorar validações em mutadores"
                                  ]
                                }
                              ],
                              "practicalExample": "```python\nclass ContaBancaria:\n    def __init__(self, saldo_inicial=0.0):\n        self._saldo = saldo_inicial\n    \n    def depositar(self, valor):\n        if valor > 0:\n            self._saldo += valor\n    \n    def sacar(self, valor):\n        if valor > 0 and valor <= self._saldo:\n            self._saldo -= valor\n    \n    def aplicar_rendimento(self, taxa):\n        self._saldo *= (1 + taxa)\n    \n    def dividir_saldo(self, parcelas):\n        if parcelas != 0:\n            self._saldo /= parcelas\n    \n    def get_saldo(self):\n        return self._saldo\n\n# Uso\nconta = ContaBancaria(100.0)\nconta.depositar(50.0)  # saldo = 150.0\nconta.sacar(20.0)      # saldo = 130.0\nconta.aplicar_rendimento(0.05)  # saldo *= 1.05\nprint(conta.get_saldo())  # ~136.5\n```",
                              "finalVerifications": [
                                "Código compila e executa sem erros de sintaxe ou runtime.",
                                "Atributos de instâncias são atualizados corretamente com = e compostos.",
                                "Métodos mutadores alteram apenas o estado interno do objeto.",
                                "Valores numéricos refletem operações aritméticas precisas.",
                                "Tratamento de casos edge (ex: divisão por zero) evita crashes.",
                                "Getters confirmam mudanças esperadas após sequências de chamadas."
                              ],
                              "assessmentCriteria": [
                                "Correto uso de = para atribuições simples (100% precisão).",
                                "Aplicação fluida de +=, -=, *=, /= sem erros lógicos (90%+).",
                                "Integração em classes OO com métodos mutadores encapsulados.",
                                "Código limpo, legível e com validações básicas.",
                                "Testes demonstram compreensão via resultados verificáveis.",
                                "Eficiência: operadores compostos usados onde apropriado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Reforça operações aritméticas básicas e compostas.",
                                "Lógica e Algoritmos: Sequenciação de mutações em estados mutáveis.",
                                "Matemática Financeira: Modelagem de saldos e rendimentos.",
                                "Física/Engenharia: Atualização de variáveis dinâmicas em simulações."
                              ],
                              "realWorldApplication": "Em aplicativos bancários para atualizar saldos via depósitos/saques ( += / -= ), jogos para gerenciar pontuações e vidas ( += / -= ), simulações financeiras para aplicar juros compostos ( *= ) ou dividir recursos ( /= ), garantindo estados consistentes de objetos em sistemas OO escaláveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.3.2",
                            "name": "Aplicar atribuição em loops e condições OO",
                            "description": "Integrar operadores de atribuição em estruturas de repetição (for, while) e condicionais dentro de métodos de classes para manipular coleções de objetos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar operadores de atribuição e estruturas de controle em OO",
                                  "subSteps": [
                                    "Estude operadores de atribuição como +=, -=, *=, /= e %= em métodos de classes.",
                                    "Implemente um método simples em uma classe que use atribuição básica em variáveis de instância.",
                                    "Revise sintaxe de loops for e while dentro de métodos de classe.",
                                    "Analise condicionais if/else integradas a métodos OO.",
                                    "Compile e execute exemplos básicos para observar atribuições."
                                  ],
                                  "verification": "Criar um método que use += para incrementar um contador de instância e verificar saída no console.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (ex: IntelliJ ou VS Code)",
                                    "Documentação Java OO sobre operadores"
                                  ],
                                  "tips": "Comece com variáveis primitivas antes de objetos para fixar a sintaxe.",
                                  "learningObjective": "Compreender a integração de operadores de atribuição com estruturas de controle em contexto orientado a objetos.",
                                  "commonMistakes": [
                                    "Usar = em vez de +=, causando perda de valor anterior",
                                    "Esquecer de declarar variáveis de instância",
                                    "Ignorar escopo de métodos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar atribuição em loops dentro de métodos de classes",
                                  "subSteps": [
                                    "Crie uma classe com uma lista de inteiros como atributo.",
                                    "Implemente um método com loop for que use += para somar valores em um acumulador.",
                                    "Substitua for por while e teste atribuições compostas.",
                                    "Adicione um loop que itere sobre coleção e aplique -= em elementos.",
                                    "Teste com dados variados e verifique resultados."
                                  ],
                                  "verification": "O método retorna soma correta via acumulador com += e imprime lista alterada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ambiente de programação Java",
                                    "Lista de testes com 5-10 números"
                                  ],
                                  "tips": "Use System.out.println para debugar valores em cada iteração.",
                                  "learningObjective": "Dominar atribuição composta em loops para manipulação de dados em classes.",
                                  "commonMistakes": [
                                    "Índice fora de bounds no for",
                                    "Condição infinita no while",
                                    "Modificar lista durante iteração sem cópia"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar atribuição com condicionais em loops OO",
                                  "subSteps": [
                                    "Crie uma classe ObjetoSimples com atributos numéricos.",
                                    "Em um método, use loop for com if que aplique *= apenas se condição relacional for verdadeira.",
                                    "Inclua else com /= para casos alternativos.",
                                    "Teste com coleção de objetos e atribuições condicionais.",
                                    "Refatore para while com verificações múltiplas."
                                  ],
                                  "verification": "Executar método e confirmar que apenas objetos atendendo condição tiveram atributos alterados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Classe modelo ObjetoSimples.java",
                                    "JUnit para testes unitários opcionais"
                                  ],
                                  "tips": "Use break ou continue para otimizar loops condicionais.",
                                  "learningObjective": "Combinar operadores de atribuição, loops e condicionais para lógica complexa em métodos.",
                                  "commonMistakes": [
                                    "Erro lógico em condições (ex: > em vez de >=)",
                                    "Atribuição fora do if",
                                    "Variáveis não inicializadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Manipular coleções de objetos com atribuições em loops e condições",
                                  "subSteps": [
                                    "Defina classe Conta com saldo e crie lista de contas.",
                                    "Implemente método que percorra lista com for-each, aplique += em saldos se saldo > 0.",
                                    "Adicione condições aninhadas com -= para saldos negativos.",
                                    "Calcule totais com acumuladores usando atribuições compostas.",
                                    "Teste cenários edge (lista vazia, negativos)."
                                  ],
                                  "verification": "Método atualiza saldos corretamente e retorna relatório via console ou retorno.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "ArrayList<Conta>",
                                    "Exemplos de dados de teste"
                                  ],
                                  "tips": "Prefira for-each para coleções de objetos para simplicidade.",
                                  "learningObjective": "Aplicar integralmente atribuições em loops e condições para processar coleções OO.",
                                  "commonMistakes": [
                                    "NullPointerException em objetos nulos",
                                    "Mutabilidade inadvertida de objetos",
                                    "Off-by-one em contadores"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie classe Conta { private double saldo; public void atualizarSaldos(List<Conta> contas) { double total = 0; for(Conta c : contas) { if(c.getSaldo() > 100) { c.setSaldo(c.getSaldo() += 10.0); } else { c.setSaldo(c.getSaldo() -= 5.0); } total += c.getSaldo(); } System.out.println('Total: ' + total); } } – Executar com lista de 5 contas testa atribuições condicionais em loop.",
                              "finalVerifications": [
                                "Todos os loops iteram o número correto de vezes sem erros de índice.",
                                "Operadores de atribuição alteram valores conforme condições especificadas.",
                                "Coleções de objetos são manipuladas sem perda de dados ou exceções.",
                                "Métodos compilam e executam produzindo saídas esperadas.",
                                "Acumuladores refletem somas/parciais corretas pós-atribuições.",
                                "Testes com dados edge (vazio, negativos) funcionam adequadamente."
                              ],
                              "assessmentCriteria": [
                                "Correção sintática: uso preciso de +=, -= etc. em loops/condicionais.",
                                "Lógica funcional: condições alteram valores apenas quando apropriado.",
                                "Eficiência: loops evitam iterações desnecessárias.",
                                "Robustez: tratamento implícito de casos edge via condições.",
                                "Clareza de código: comentários e nomes variáveis descritivos.",
                                "Integração OO: métodos encapsulam lógica corretamente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações aritméticas compostas e somatórias em sequências.",
                                "Lógica: Estruturas condicionais e booleanas para decisões.",
                                "Banco de Dados: Atualizações em massa de registros via queries semelhantes a loops.",
                                "Estatística: Processamento de datasets com agregações condicionais."
                              ],
                              "realWorldApplication": "Em sistemas bancários, loops com atribuições condicionais atualizam saldos de milhares de contas (ex: aplicar juros se saldo > limite, ou multas caso contrário), otimizando processamento batch em aplicações empresariais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.3.3",
                            "name": "Sobrecarregar operadores de atribuição aumentada",
                            "description": "Implementar métodos como __iadd__ e __isub__ em classes Python para permitir atribuições compostas personalizadas entre objetos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender operadores de atribuição aumentada e métodos especiais",
                                  "subSteps": [
                                    "Estude o funcionamento dos operadores +=, -=, *=, /= em Python, que modificam o objeto in-place.",
                                    "Identifique os métodos dunder correspondentes: __iadd__ para +=, __isub__ para -=, __imul__ para *=, etc.",
                                    "Compare com operadores binários como __add__ (não modifica in-place, retorna novo objeto).",
                                    "Crie uma classe simples sem overload e teste falha em += para observar erro.",
                                    "Consulte a documentação oficial do Python sobre data model (Special method names)."
                                  ],
                                  "verification": "Explique em comentários no código a diferença entre __add__ e __iadd__, e execute um teste falhando.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código Python (VS Code ou PyCharm)",
                                    "Documentação Python: https://docs.python.org/3/reference/datamodel.html#special-method-names"
                                  ],
                                  "tips": "Lembre-se: operadores in-place devem retornar self para permitir chaining como a += b; c += a.",
                                  "learningObjective": "Entender o conceito e a necessidade de sobrecarga de operadores de atribuição aumentada.",
                                  "commonMistakes": [
                                    "Confundir __iadd__ com __add__",
                                    "Ignorar que in-place modifica o objeto original",
                                    "Não retornar self no método"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar __iadd__ em uma classe personalizada",
                                  "subSteps": [
                                    "Defina uma classe simples, como Vetor2D, com atributos x e y.",
                                    "Implemente o método __iadd__(self, other), somando componentes de other (supondo other é tupla ou Vetor2D).",
                                    "Garanta que modifique self.x e self.y in-place.",
                                    "Retorne self no final do método.",
                                    "Teste com v1 += (2, 3) e verifique se v1 foi alterado."
                                  ],
                                  "verification": "Execute v1 = Vetor2D(1,1); v1 += (2,3); assert v1.x == 3 and v1.y == 4.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python 3.x instalado",
                                    "REPL ou Jupyter Notebook para testes rápidos"
                                  ],
                                  "tips": "Use isinstance(other, (tuple, list)) para flexibilidade, convertendo se necessário.",
                                  "learningObjective": "Implementar corretamente __iadd__ para soma in-place personalizada.",
                                  "commonMistakes": [
                                    "Retornar novo objeto em vez de self",
                                    "Não tratar tipos diferentes de other",
                                    "Esquecer de atualizar atributos de self"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar __isub__ e outros operadores relacionados",
                                  "subSteps": [
                                    "Adicione __isub__(self, other) à classe Vetor2D, subtraindo componentes.",
                                    "Teste chaining: v1 += (1,1); v1 -= (0.5, 0.5).",
                                    "Opcionalmente, implemente __imul__ para multiplicação escalar in-place.",
                                    "Adicione validações para evitar erros, como divisão por zero em /= se aplicável.",
                                    "Registre os valores antes/depois para depuração com print."
                                  ],
                                  "verification": "Execute sequência de operações e confirme valores finais com asserts.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmos do step anterior",
                                    "Unittest ou pytest para automação"
                                  ],
                                  "tips": "Sempre priorize eficiência: evite criar objetos temporários desnecessários.",
                                  "learningObjective": "Estender a sobrecarga para múltiplos operadores in-place.",
                                  "commonMistakes": [
                                    "Alterar other acidentalmente",
                                    "Não suportar escalares em operações vetoriais",
                                    "Quebrar chaining ao não retornar self"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, depurar e otimizar a implementação",
                                  "subSteps": [
                                    "Crie testes unitários cobrindo casos normais, edge cases (zero, negativos) e tipos mistos.",
                                    "Depure erros comuns como TypeError em operações inválidas.",
                                    "Meça performance comparando com loops manuais vs. operadores.",
                                    "Adicione __repr__ para facilitar inspeção de estado.",
                                    "Refatore para maior robustez, como suporte a Vetor2D += Vetor2D."
                                  ],
                                  "verification": "Todos os testes passam (100% coverage) e performance é aceitável.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Biblioteca unittest ou pytest",
                                    "Profiler como cProfile"
                                  ],
                                  "tips": "Use try-except para operações inválidas, levantando ValueError customizado.",
                                  "learningObjective": "Validar e refinar a sobrecarga para uso production-ready.",
                                  "commonMistakes": [
                                    "Testes insuficientes para edge cases",
                                    "Ignorar performance em grandes objetos",
                                    "Expor atributos mutáveis sem controle"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe Vetor2D:\nclass Vetor2D:\n    def __init__(self, x=0, y=0):\n        self.x, self.y = x, y\n    def __iadd__(self, other):\n        ox, oy = other if isinstance(other, tuple) else (other.x, other.y)\n        self.x += ox\n        self.y += oy\n        return self\n    def __isub__(self, other):\n        ox, oy = other if isinstance(other, tuple) else (other.x, other.y)\n        self.x -= ox\n        self.y -= oy\n        return self\n    def __repr__(self):\n        return f'Vetor2D({self.x}, {self.y})'\n\n# Uso:\nv = Vetor2D(1, 2)\nv += (3, 4)  # v agora é (4, 6)\nv -= (1, 1)  # v agora é (3, 5)\nprint(v)",
                              "finalVerifications": [
                                "O objeto original é modificado após operação como v += other (in-place confirmado).",
                                "Chaining funciona: v += a; v -= b resulta em valores corretos.",
                                "Suporta múltiplos tipos (tupla, lista, instância da classe).",
                                "Edge cases como zero ou negativos não quebram o código.",
                                "Não há TypeError ou AttributeError em usos válidos.",
                                "Performance é eficiente comparada a métodos manuais."
                              ],
                              "assessmentCriteria": [
                                "Código limpo, com métodos corretos retornando self.",
                                "Tratamento robusto de tipos de entrada (flexível).",
                                "Testes unitários completos com asserts.",
                                "Sem side-effects indesejados (other não alterado).",
                                "Documentação/comentários explicando lógica.",
                                "Otimização básica para eficiência."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações vetoriais e álgebra linear.",
                                "Física: Simulações de movimento e forças acumuladas.",
                                "Engenharia de Software: Design de APIs intuitivas como NumPy.",
                                "Análise de Dados: Manipulação eficiente de estruturas numéricas."
                              ],
                              "realWorldApplication": "Em bibliotecas como NumPy ou Pandas, permite operações in-place eficientes em arrays/vetores, reduzindo uso de memória em simulações científicas, machine learning e processamento de big data."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.4",
                    "name": "Operadores Lógicos e Bitwise",
                    "description": "Funcionamento de operadores lógicos (AND, OR, NOT) e bitwise em expressões orientadas a objetos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.4.1",
                        "name": "Operadores Lógicos (AND, OR, NOT)",
                        "description": "Funcionamento dos operadores lógicos AND (&& ou and), OR (|| ou or) e NOT (! ou not) em expressões booleanas envolvendo objetos, instâncias e métodos em programação orientada a objetos, considerando avaliação de curto-circuito e tipos booleanos como subclasses de inteiros em linguagens como Python.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.1.1",
                            "name": "Aplicar operador AND lógico em expressões OO",
                            "description": "Construir e avaliar expressões utilizando o operador AND lógico em condições que envolvem chamadas a métodos de objetos ou atributos booleanos, demonstrando o comportamento de curto-circuito em linguagens como Python ou C++.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o operador AND lógico e avaliação de curto-circuito em contextos OO",
                                  "subSteps": [
                                    "Revise a tabela-verdade do operador AND lógico: True AND True = True; outros casos = False.",
                                    "Estude o comportamento de curto-circuito: em Python/C++, o segundo operando só é avaliado se o primeiro for True.",
                                    "Analise exemplos simples em código procedural vs. OO, focando em atributos booleanos de objetos.",
                                    "Identifique cenários onde curto-circuito otimiza performance em OO, como evitar chamadas desnecessárias.",
                                    "Compare AND com operadores condicionais (if) para validações múltiplas em objetos."
                                  ],
                                  "verification": "Explique em voz alta ou anote: 'O que acontece se o primeiro operando for False em user.is_active and user.check_permission()?'",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Python/C++ sobre operadores lógicos",
                                    "Editor de código (VS Code ou IDE preferida)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use print statements para visualizar a ordem de avaliação durante testes iniciais.",
                                  "learningObjective": "Entender como AND funciona com curto-circuito em expressões envolvendo objetos.",
                                  "commonMistakes": [
                                    "Confundir AND lógico com bitwise (&)",
                                    "Ignorar que curto-circuito previne exceções no segundo operando",
                                    "Assumir avaliação sempre esquerda-direita sem curto-circuito"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar AND com atributos booleanos de objetos",
                                  "subSteps": [
                                    "Crie uma classe simples, ex: class User com atributos is_active (bool) e is_premium (bool).",
                                    "Construa expressões como: access_granted = user.is_active and user.is_premium.",
                                    "Teste com instâncias variadas: ative/inativo, premium/não.",
                                    "Adicione prints nos atributos para confirmar avaliação sequencial.",
                                    "Refatore para método na classe: def can_access(self): return self.is_active and self.is_premium."
                                  ],
                                  "verification": "Execute testes unitários cobrindo todos casos da tabela-verdade; resultados devem coincidir.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Biblioteca unittest/pytest para testes",
                                    "Exemplos de classes Python/C++"
                                  ],
                                  "tips": "Inicialize objetos com diferentes combinações booleanas para testes exhaustivos.",
                                  "learningObjective": "Aplicar AND diretamente em atributos booleanos de instâncias OO.",
                                  "commonMistakes": [
                                    "Usar == True explicitamente (desnecessário)",
                                    "Esquecer de instanciar objetos antes de testar",
                                    "Não testar casos onde primeiro é False"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar AND com chamadas a métodos que retornam booleanos",
                                  "subSteps": [
                                    "Expanda a classe User adicionando métodos como def is_valid(self): return len(self.email) > 5 (ou similar).",
                                    "Crie expressões: if user.is_active and user.is_valid(): ... demonstrando curto-circuito.",
                                    "Simule método custoso: def expensive_check(self): print('Chamado!'); return True/False.",
                                    "Teste: se is_active=False, expensive_check não deve ser chamado.",
                                    "Implemente em C++ equivalente usando && para curto-circuito."
                                  ],
                                  "verification": "Use logs/prints para confirmar que métodos secundários só executam quando necessário.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código com debugger",
                                    "Documentação Python/C++ short-circuit evaluation"
                                  ],
                                  "tips": "Debugger é ideal para pausar e inspecionar ordem de chamadas.",
                                  "learningObjective": "Demonstrar otimização via curto-circuito em chamadas de métodos OO.",
                                  "commonMistakes": [
                                    "Usar & bitwise em vez de && lógico",
                                    "Não capturar exceções em métodos para testar robustez",
                                    "Ignorar diferenças entre linguagens (Python and vs C++ &&)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar, depurar e otimizar expressões AND em cenários OO complexos",
                                  "subSteps": [
                                    "Combine múltiplos ANDs: user.is_active and user.is_premium and user.has_permission().",
                                    "Introduza erros proposital: inverta ordem para forçar chamadas custosas desnecessárias.",
                                    "Depure usando debugger ou traces para validar curto-circuito.",
                                    "Otimize reordenando operandos: coloque mais rápidos/probáveis True primeiro.",
                                    "Escreva testes automatizados para cenários edge-case (None, exceções)."
                                  ],
                                  "verification": "Todos testes passam; logs confirmam otimização de curto-circuito em 100% dos casos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramentas de debugging (pdb em Python, gdb em C++)",
                                    "Framework de testes"
                                  ],
                                  "tips": "Sempre priorize operandos baratos (atributos) antes de custosos (métodos I/O).",
                                  "learningObjective": "Avaliar e refinar expressões AND OO para performance e corretude.",
                                  "commonMistakes": [
                                    "Não reordenar operandos para otimização",
                                    "Esquecer tratamento de exceções no segundo operando",
                                    "Sobrecomplicar com parênteses desnecessários"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de autenticação: class User { bool is_active; bool is_premium; bool has_valid_token() { /* checa DB */ } }; if (user.is_active && user.has_valid_token()) { grant_access(); } Aqui, se is_active=false, has_valid_token() não é chamado, evitando query desnecessária ao DB.",
                              "finalVerifications": [
                                "Expressões AND avaliam corretamente todos casos da tabela-verdade com objetos.",
                                "Curto-circuito comprovado via logs/debugger em testes.",
                                "Código roda sem exceções em cenários onde segundo operando falharia.",
                                "Testes unitários cobrem atributos e métodos booleanos.",
                                "Performance otimizada: chamadas secundárias só ocorrem quando necessário.",
                                "Equivalente funciona em Python e C++."
                              ],
                              "assessmentCriteria": [
                                "Uso correto de AND lógico (não bitwise).",
                                "Demonstração explícita de curto-circuito com evidências.",
                                "Expressões bem estruturadas em contextos OO (atributos/métodos).",
                                "Cobertura completa de casos True/False.",
                                "Otimização de ordem de operandos.",
                                "Código limpo, testável e sem erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional e tabelas-verdade.",
                                "Algoritmos: Otimização de avaliação condicional.",
                                "Design de Software: Princípios de validação e autenticação.",
                                "Análise de Performance: Impacto de curto-circuito em complexidade.",
                                "Lógica Computacional: Equivalências booleanas em programação."
                              ],
                              "realWorldApplication": "Em aplicações web como login de usuários (ex: Django/Flask), validações de formulários (primeiro checa campos obrigatórios, só então valida BD), jogos (verifica vida >0 and energia >0 antes de ação), ou sistemas embarcados (sensores: ativo and calibrado antes de leitura)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.2",
                            "name": "Aplicar operador OR lógico em expressões OO",
                            "description": "Implementar expressões com o operador OR lógico para combinar condições derivadas de instâncias de classes, entendendo a avaliação de curto-circuito e sua aplicação em estruturas de controle como if em contextos orientados a objetos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o operador OR lógico e avaliação de curto-circuito",
                                  "subSteps": [
                                    "Estude a definição do operador OR lógico: retorna true se pelo menos uma condição for true.",
                                    "Analise a avaliação de curto-circuito: a segunda condição só é avaliada se a primeira for false.",
                                    "Compare OR com AND, destacando diferenças no curto-circuito.",
                                    "Leia exemplos básicos em documentação de linguagens OO como Python ou Java.",
                                    "Anote cenários onde OR é útil em contextos de objetos."
                                  ],
                                  "verification": "Explique em suas palavras o funcionamento do OR com curto-circuito e dê um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial da linguagem OO (Python/Java)",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar o curto-circuito.",
                                  "learningObjective": "Entender semanticamente o OR lógico e seu comportamento em avaliações sequenciais.",
                                  "commonMistakes": [
                                    "Confundir OR com AND no curto-circuito",
                                    "Ignorar que OR para true na primeira condição true"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar classes com atributos para condições lógicas",
                                  "subSteps": [
                                    "Defina uma classe simples com atributos booleanos ou métodos que retornem booleanos (ex: Usuario com 'ativo' e 'premium').",
                                    "Instancie múltiplos objetos da classe.",
                                    "Crie métodos getters para acessar os atributos.",
                                    "Teste acesso aos atributos em console.",
                                    "Prepare condições derivadas de instâncias para uso em OR."
                                  ],
                                  "verification": "Compile e execute o código criando objetos e imprimindo seus estados booleanos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE com suporte OO (PyCharm, IntelliJ)",
                                    "Linguagem OO instalada (Python/Java)"
                                  ],
                                  "tips": "Comece com atributos booleanos diretos para simplicidade.",
                                  "learningObjective": "Modelar dados em objetos OO que gerem condições booleanas para operadores lógicos.",
                                  "commonMistakes": [
                                    "Esquecer de instanciar objetos antes de usar",
                                    "Erro de sintaxe em definições de classe"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar expressões OR combinando condições de objetos",
                                  "subSteps": [
                                    "Escreva uma expressão OR usando atributos de diferentes instâncias (ex: obj1.ativo or obj2.premium).",
                                    "Incorpore a expressão em uma estrutura if simples.",
                                    "Teste com combinações: ambas false, primeira true, segunda true.",
                                    "Adicione prints para observar ordem de avaliação e curto-circuito.",
                                    "Refatore para um método que receba múltiplos objetos."
                                  ],
                                  "verification": "Execute testes unitários mostrando que OR funciona corretamente em todos os casos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE com debugger",
                                    "Biblioteca de testes (unittest em Python, JUnit em Java)"
                                  ],
                                  "tips": "Use debugger para pausar na avaliação e confirmar curto-circuito.",
                                  "learningObjective": "Construir e validar expressões OR compostas por condições de instâncias OO.",
                                  "commonMistakes": [
                                    "Usar || em vez de or (dependendo da linguagem)",
                                    "Não testar casos de curto-circuito"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e debugar OR em estruturas de controle OO",
                                  "subSteps": [
                                    "Integre a expressão OR em um fluxo de controle maior (ex: if-or para permissões de acesso).",
                                    "Crie cenários de erro intencional e debugs.",
                                    "Adicione validações excepcionais para objetos nulos.",
                                    "Refatore código para melhor legibilidade (ex: extrair métodos booleanos).",
                                    "Documente o código com comentários sobre o OR usado."
                                  ],
                                  "verification": "O programa executa sem erros e toma decisões corretas baseadas no OR em 5 cenários de teste.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE com suporte a debugging",
                                    "Exemplos de código de repositórios GitHub"
                                  ],
                                  "tips": "Sempre teste bordas: null, false/true combinações.",
                                  "learningObjective": "Aplicar OR logicamente em contextos reais OO com debugging eficaz.",
                                  "commonMistakes": [
                                    "Prioridade de operadores errada sem parênteses",
                                    "Ignorar exceções em métodos de objetos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python:\nclass Usuario:\n    def __init__(self, ativo, premium):\n        self.ativo = ativo\n        self.premium = premium\n\n    def pode_acessar(self):\n        return self.ativo or self.premium\n\nu1 = Usuario(False, True)\nu2 = Usuario(True, False)\nif u1.pode_acessar() or u2.ativo:\n    print('Acesso concedido')  # Curto-circuito: u2.ativo não avaliado se u1 true",
                              "finalVerifications": [
                                "Expressão OR avalia true se pelo menos uma condição de objeto for true.",
                                "Curto-circuito comprovado: segunda condição não executada quando primeira true.",
                                "Integração correta em if sem erros de sintaxe ou runtime.",
                                "Testes cobrem todos casos lógicos (FF, FT, TF, TT).",
                                "Código refatorado é legível e documentado.",
                                "Debugging identifica e corrige erros comuns."
                              ],
                              "assessmentCriteria": [
                                "Precisão na avaliação lógica do OR (100% acerto em testes).",
                                "Demonstração explícita de curto-circuito via logs ou debugger.",
                                "Uso correto de instâncias OO em condições compostas.",
                                "Código limpo, com métodos booleanos extraídos.",
                                "Cobertura de edge cases (null, false all).",
                                "Explicação verbal clara do comportamento."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional e tabelas-verdade.",
                                "Lógica e Filosofia: Raciocínio disjuntivo em argumentos.",
                                "Administração: Tomada de decisões em permissões de acesso.",
                                "Engenharia de Software: Validações condicionais em sistemas.",
                                "Ciências da Computação: Otimização de performance via curto-circuito."
                              ],
                              "realWorldApplication": "Em sistemas de autenticação OO, como verificar se um usuário tem acesso via conta ativa OU assinatura premium, otimizando performance com curto-circuito em apps web ou jogos multiplayer."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.3",
                            "name": "Utilizar operador NOT lógico com objetos",
                            "description": "Negar valores booleanos retornados por métodos ou atributos de objetos usando o operador NOT, identificando seu impacto em expressões lógicas compostas dentro de classes orientadas a objetos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o operador NOT e booleanos em objetos OOP",
                                  "subSteps": [
                                    "Revise o operador NOT (! ou 'not' em Python) e como ele inverte valores booleanos (True vira False, False vira True).",
                                    "Identifique atributos e métodos de objetos que retornam booleanos, como is_valid() ou has_permission.",
                                    "Crie uma classe simples com um atributo booleano e um método getter que o retorna.",
                                    "Teste o valor booleano diretamente em console ou depurador.",
                                    "Experimente aplicar NOT diretamente ao resultado do método sem armazenar."
                                  ],
                                  "verification": "Execute código que imprima o valor booleano original e o negado, confirmando inversão correta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE (VS Code, PyCharm)",
                                    "Documentação de linguagem OOP (Python/Java)"
                                  ],
                                  "tips": "Use print statements para visualizar valores booleanos em tempo real.",
                                  "learningObjective": "Compreender como NOT atua em resultados booleanos de objetos.",
                                  "commonMistakes": [
                                    "Confundir NOT com operadores bit a bit (~)",
                                    "Aplicar NOT a objetos inteiros em vez de seus métodos booleanos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar NOT em expressões simples com objetos",
                                  "subSteps": [
                                    "Crie uma classe exemplo, como 'User', com método is_authenticated() retornando True/False.",
                                    "Escreva uma condição if usando not user.is_authenticated() para negar o estado.",
                                    "Armazene o resultado negado em uma variável booleana e teste seu valor.",
                                    "Inclua cenários onde o objeto muda estado (ex: user.login()) e reaplique NOT.",
                                    "Adicione validações para objetos nulos ou métodos inexistentes."
                                  ],
                                  "verification": "Rode testes unitários ou manuais mostrando que a condição if executa corretamente apenas quando negada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Framework de testes (unittest em Python, JUnit em Java)",
                                    "Exemplos de classes OOP básicas"
                                  ],
                                  "tips": "Sempre chame métodos em objetos instanciados, não na classe.",
                                  "learningObjective": "Aplicar NOT a métodos de objetos em estruturas condicionais simples.",
                                  "commonMistakes": [
                                    "Esquecer parênteses ao redor do método: not obj.method()",
                                    "Negar o objeto inteiro em vez do resultado do método"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar NOT em expressões lógicas compostas",
                                  "subSteps": [
                                    "Combine NOT com AND/OR: ex: if not user.is_active() or not user.has_role('admin').",
                                    "Crie múltiplos objetos e use NOT em comparações compostas.",
                                    "Implemente uma função que retorne booleano baseado em múltiplos NOTs de objetos.",
                                    "Teste todas combinações de True/False nos métodos originais.",
                                    "Use tabelas de verdade mentais para prever resultados das expressões."
                                  ],
                                  "verification": "Crie uma tabela de testes com inputs/outputs esperados e valide com asserts.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha para tabela de verdade",
                                    "Calculadora de expressões lógicas online"
                                  ],
                                  "tips": "Precedência: NOT > AND > OR; use parênteses para clareza.",
                                  "learningObjective": "Usar NOT em contextos lógicos complexos com múltiplos objetos.",
                                  "commonMistakes": [
                                    "Ignorar precedência de operadores levando a lógicas erradas",
                                    "Duplo NOT desnecessário (not not)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Debugar e otimizar uso de NOT com objetos",
                                  "subSteps": [
                                    "Introduza erros comuns em código existente e corrija-os.",
                                    "Profile performance de expressões com NOT em loops com objetos.",
                                    "Refatore código para evitar NOTs excessivos (ex: inverter lógica no método).",
                                    "Adicione logging para rastrear valores booleanos antes/depois NOT.",
                                    "Teste em cenários edge-case: objetos None, exceções em métodos."
                                  ],
                                  "verification": "Código refatorado passa todos testes e é mais legível/eficiente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Debugger da IDE",
                                    "Ferramentas de profiling (cProfile em Python)"
                                  ],
                                  "tips": "Evite chains longos de NOT; prefira métodos que retornem o inverso.",
                                  "learningObjective": "Identificar e corrigir problemas no uso de NOT com objetos.",
                                  "commonMistakes": [
                                    "Performance hit em loops por chamadas repetidas a métodos",
                                    "Não tratar exceções de métodos booleanos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma classe BankAccount com método is_locked() -> bool, use 'if not account.is_locked() and account.balance > 0:' para permitir saques apenas em contas desbloqueadas e com saldo positivo.",
                              "finalVerifications": [
                                "Inverte corretamente booleanos de métodos de objetos em expressões isoladas.",
                                "Integra NOT em condições compostas sem alterar precedência lógica.",
                                "Passa testes com múltiplos cenários True/False em objetos.",
                                "Código é legível, com parênteses adequados e sem erros comuns.",
                                "Debuga e corrige expressões lógicas falhas envolvendo NOT.",
                                "Otimiza uso evitando redundâncias como double NOT."
                              ],
                              "assessmentCriteria": [
                                "Precisão na inversão de booleanos de objetos (100% acerto em testes).",
                                "Correta precedência em expressões compostas (sem erros lógicos).",
                                "Clareza e legibilidade do código (uso de parênteses e nomes descritivos).",
                                "Tratamento de edge-cases (None, exceções).",
                                "Eficiência em loops e funções repetitivas.",
                                "Capacidade de refatorar lógicas complexas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Tabelas de verdade e álgebra booleana.",
                                "Lógica Filosófica: Negação em argumentos compostos.",
                                "Design de Software: Padrões de validação em sistemas.",
                                "Ciências da Computação: Otimização de expressões lógicas em algoritmos."
                              ],
                              "realWorldApplication": "Em sistemas de autenticação web (ex: negar acesso se not user.is_verified()), validação de formulários (not field.is_valid()), ou jogos (not player.is_alive() para game over), garantindo lógicas seguras e eficientes em aplicações OOP."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.2",
                        "name": "Operadores Bitwise",
                        "description": "Funcionamento dos operadores bitwise (&, |, ^, ~, <<, >>) aplicados a valores inteiros manipulados por objetos em programação OO, incluindo cenários de máscaras de bits em classes e herança de tipos numéricos como em Python.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.2.1",
                            "name": "Aplicar operadores AND e OR bitwise em objetos",
                            "description": "Realizar operações bitwise AND (&) e OR (|) em atributos inteiros de instâncias de classes, utilizando para manipulação de flags ou máscaras em aplicações orientadas a objetos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos dos operadores bitwise AND (&) e OR (|)",
                                  "subSteps": [
                                    "Estude a representação binária de inteiros: converta números decimais como 5 (101) e 3 (011) para binário.",
                                    "Aprenda AND (&): resulta em 1 apenas onde ambos os bits são 1 (ex: 5 & 3 = 1 ou 001).",
                                    "Aprenda OR (|): resulta em 1 onde pelo menos um bit é 1 (ex: 5 | 3 = 7 ou 111).",
                                    "Pratique com exemplos manuais: calcule 12 & 10 e 12 | 10.",
                                    "Teste em código simples: escreva um programa que imprima resultados de operações bitwise."
                                  ],
                                  "verification": "Corretamente calcular e explicar 5 & 3 (1) e 5 | 3 (7) em binário e decimal.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora binária online (ex: rapidtables.com)",
                                    "Editor de código (Java IDE como IntelliJ ou Eclipse)"
                                  ],
                                  "tips": "Visualize bits alinhados verticalmente para operações manuais; use printf com %b para binário em algumas linguagens.",
                                  "learningObjective": "Dominar o funcionamento bitwise AND e OR em inteiros isolados.",
                                  "commonMistakes": [
                                    "Confundir com operadores lógicos && e || que operam em booleanos inteiros",
                                    "Esquecer de considerar o tamanho do inteiro (32/64 bits)",
                                    "Ignorar overflow em números negativos signed"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir flags e máscaras em uma classe orientada a objetos",
                                  "subSteps": [
                                    "Crie constantes estáticas para flags: public static final int READ = 1, WRITE = 2, EXECUTE = 4, DELETE = 8.",
                                    "Defina uma classe Permissions com atributo privado int flags = 0.",
                                    "Adicione construtor que recebe int inicial e seta flags via OR: this.flags |= initialFlags.",
                                    "Crie getters para flags e um método toString() que liste flags ativas em binário.",
                                    "Instancie objetos e defina permissões iniciais como new Permissions(READ | WRITE)."
                                  ],
                                  "verification": "Compilar e executar classe que instancia objeto com flags READ | WRITE (3) e imprime corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Java JDK 8+",
                                    "Editor de código com compilador Java"
                                  ],
                                  "tips": "Use potências de 2 (1,2,4,8...) para flags mutuamente independentes; evite sobreposição de bits.",
                                  "learningObjective": "Integrar inteiros com flags em atributos de classes OOP.",
                                  "commonMistakes": [
                                    "Usar valores não-potências de 2 causando sobreposição",
                                    "Esquecer modificador final nas constantes",
                                    "Não inicializar flags como 0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar operações AND para verificação de flags em objetos",
                                  "subSteps": [
                                    "Adicione método boolean hasFlag(int flag) { return (this.flags & flag) != 0; }.",
                                    "Teste hasFlag em instâncias: crie objeto com READ | EXECUTE e verifique hasFlag(READ) true, hasFlag(WRITE) false.",
                                    "Crie método String getActiveFlags() que use AND para listar flags ativas via loop ou switch.",
                                    "Integre em um método de negócio: simule checagem de permissão antes de ação.",
                                    "Adicione validação: lance exceção se flag inválido (bit > suportado)."
                                  ],
                                  "verification": "Executar testes unitários onde hasFlag retorna corretamente true/false para flags setadas/não setadas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "JUnit para testes unitários",
                                    "Exemplos de código da classe Permissions"
                                  ],
                                  "tips": "AND com flag != 0 detecta presença; use unsigned shifts se necessário para precisão.",
                                  "learningObjective": "Aplicar AND bitwise para checar presença de flags em instâncias de classes.",
                                  "commonMistakes": [
                                    "Esquecer != 0 após AND (retorna flag se presente)",
                                    "Usar == flag em vez de !=0",
                                    "Não tratar flags múltiplas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar operações OR para adicionar flags e validar o sistema",
                                  "subSteps": [
                                    "Adicione método void addFlag(int flag) { this.flags |= flag; }.",
                                    "Crie método void removeFlag(int flag) { this.flags &= ~flag; } usando NOT (~).",
                                    "Teste sequência: adicione WRITE a objeto com READ, verifique hasFlag(WRITE) true.",
                                    "Implemente teste completo: simule upgrade de permissões e valide mudanças.",
                                    "Adicione serialização ou clone para persistir flags entre objetos."
                                  ],
                                  "verification": "Rodar cenários completos onde flags são adicionadas/removidas e verificações passam 100%.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "JUnit ou assert statements",
                                    "Debugger do IDE"
                                  ],
                                  "tips": "OR é idempotente: aplicar múltiplas vezes não muda; combine com AND para sets atômicos.",
                                  "learningObjective": "Usar OR para manipular e expandir flags em objetos OOP dinamicamente.",
                                  "commonMistakes": [
                                    "Usar + em vez de | para múltiplas flags",
                                    "Não usar ~ para remover com AND",
                                    "Modificar flags sem verificação de segurança"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de gerenciamento de usuários, classe User com int permissions. Para checar leitura: if (user.hasFlag(User.READ)) { lerArquivo(); }. Para conceder escrita: user.addFlag(User.WRITE);. Exemplo: User admin = new User(READ | WRITE | EXECUTE); admin.hasFlag(READ) retorna true.",
                              "finalVerifications": [
                                "Explicar em palavras o resultado binário e decimal de (5 & 3) e (5 | 3).",
                                "Implementar e testar classe Permissions com pelo menos 4 flags e métodos hasFlag/addFlag.",
                                "Demonstrar remoção de flag usando AND com NOT e verificar ausência.",
                                "Criar teste unitário que falhe se AND/OR estiverem trocados.",
                                "Listar flags ativas de um objeto com flags = 7 (READ|WRITE|EXECUTE).",
                                "Explicar por que flags usam potências de 2."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas operações bitwise: resultados corretos em todos testes (peso 30%).",
                                "Estrutura OOP: encapsulamento correto de flags e métodos (peso 25%).",
                                "Cobertura de casos: testes para set, check, add, remove (peso 20%).",
                                "Eficiência: operações O(1) sem loops desnecessários (peso 15%).",
                                "Clareza de código: nomes descritivos, comentários em métodos chave (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações em álgebra booleana e representação binária.",
                                "Eletrônica: Equivalência a portas lógicas AND/OR em circuitos digitais.",
                                "Segurança da Informação: Modelagem de RBAC (Role-Based Access Control) com bitmasks.",
                                "Desenvolvimento de Jogos: Gerenciamento de estados de entidades (vivo, invisível, etc.)."
                              ],
                              "realWorldApplication": "Em sistemas operacionais como Linux (chmod com octal masks para rwx), engines de jogos (Unity/Unreal para componentes de entidades), e apps web (JWT tokens com permission flags compactos para autenticação eficiente)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.2.2",
                            "name": "Utilizar XOR bitwise e NOT bit a bit",
                            "description": "Implementar XOR (^) para toggling de bits e NOT (~) para inversão em métodos de classes OO, compreendendo representação binária e aplicação em estruturas de dados encapsuladas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a representação binária de inteiros",
                                  "subSteps": [
                                    "Converta números decimais para binário manualmente (ex: 5 = 101).",
                                    "Identifique posições de bits (LSB e MSB).",
                                    "Represente inteiros negativos em complemento de 2.",
                                    "Use ferramentas como calculadoras binárias online para validar.",
                                    "Pratique com 10 números variados."
                                  ],
                                  "verification": "Converta corretamente 5 números decimais para binário e vice-versa sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora binária online (ex: rapidtables.com)",
                                    "Papel e caneta",
                                    "IDE com console (IntelliJ ou Eclipse)"
                                  ],
                                  "tips": "Sempre comece pela direita (LSB) e lembre que bits vão até 32 ou 64 dependendo da linguagem.",
                                  "learningObjective": "Representar e manipular números em base binária com fluência.",
                                  "commonMistakes": [
                                    "Confundir ordem dos bits (esquecer LSB à direita)",
                                    "Ignorar sinal para negativos",
                                    "Erros de contagem de potências de 2"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar o operador NOT bit a bit (~)",
                                  "subSteps": [
                                    "Entenda que ~ inverte todos os bits (0->1, 1->0).",
                                    "Aplique ~ em exemplos simples: ~5 (101 -> ...010).",
                                    "Considere o impacto em inteiros assinados (complemento de 2).",
                                    "Implemente um método simples para inverter bits.",
                                    "Teste com valores positivos e negativos."
                                  ],
                                  "verification": "Implemente e teste ~ em 5 valores, prevendo e confirmando resultados binários.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE Java",
                                    "Documentação Oracle: Bitwise Operators",
                                    "Calculadora binária"
                                  ],
                                  "tips": "Lembre que ~x = -x - 1 para inteiros assinados em Java.",
                                  "learningObjective": "Aplicar NOT para inverter bits e compreender efeitos em valores numéricos.",
                                  "commonMistakes": [
                                    "Esquecer do complemento de 2 em assinados",
                                    "Confundir com negação lógica (!)",
                                    "Não testar com negativos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar o operador XOR bit a bit (^) para toggling",
                                  "subSteps": [
                                    "Entenda XOR: 0^0=0, 0^1=1, 1^0=1, 1^1=0.",
                                    "Use XOR com 1 para toggle um bit específico: x ^= (1 << n).",
                                    "Aplique em múltiplos bits com máscaras.",
                                    "Implemente toggling em um inteiro representando flags.",
                                    "Teste toggling repetido (deve alternar estados)."
                                  ],
                                  "verification": "Crie função que toggle bit n e verifique alternância em 3 execuções.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE Java",
                                    "Exemplos de código bitwise no GeeksforGeeks"
                                  ],
                                  "tips": "Para toggle bit n: use máscara (1 << n), que é eficiente e idiomático.",
                                  "learningObjective": "Usar XOR para alternar bits individuais sem afetar outros.",
                                  "commonMistakes": [
                                    "Usar | ou & em vez de ^ para toggle",
                                    "Erros em shifts (<< vs >>)",
                                    "Overflow em shifts grandes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar XOR e NOT em classes OO encapsuladas",
                                  "subSteps": [
                                    "Crie classe BitManipulator com campos privados (int flags).",
                                    "Adicione métodos: toggleBit(int position), invertAllBits().",
                                    "Use getters/setters para encapsulamento.",
                                    "Aplique em estrutura de dados como UserState com flags (logado, admin).",
                                    "Teste métodos em main ou JUnit."
                                  ],
                                  "verification": "Classe funcional toggla/inverte bits corretamente em testes unitários.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "IDE com JUnit",
                                    "Padrões OO: Encapsulamento"
                                  ],
                                  "tips": "Mantenha estado privado; exponha apenas operações seguras.",
                                  "learningObjective": "Integrar operadores bitwise em OO com encapsulamento.",
                                  "commonMistakes": [
                                    "Expor campos públicos",
                                    "Não validar posições de bits (0-31)",
                                    "Ignorar imutabilidade onde possível"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar em estruturas de dados reais",
                                  "subSteps": [
                                    "Expanda classe para estrutura como Permissions (múltiplos flags).",
                                    "Implemente checkFlag, setFlag com XOR/NOT.",
                                    "Simule cenários: toggle admin, invert permissions.",
                                    "Otimize para performance (bitwise vs booleans).",
                                    "Refatore código para reutilização."
                                  ],
                                  "verification": "Estrutura manipula flags corretamente em cenários simulados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "JUnit para testes",
                                    "Exemplos de bit flags em bibliotecas como EnumSet"
                                  ],
                                  "tips": "Bit flags economizam memória vs arrays de boolean.",
                                  "learningObjective": "Aplicar bitwise em dados encapsulados para eficiência.",
                                  "commonMistakes": [
                                    "Máscaras erradas para múltiplos bits",
                                    "Perder track de quais bits representam o quê",
                                    "Não documentar máscaras"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe UserPermissions com int flags onde bit 0=leitura, bit 1=escrita, bit 2=admin. Implemente togglePermission(int bit) usando XOR e invertPermissions() usando NOT. Teste: usuário ganha admin (^=4), depois inverte tudo (~flags).",
                              "finalVerifications": [
                                "Converte decimais para binário corretamente.",
                                "Aplica ~ e prevê resultado em assinados.",
                                "Toggles bit específico com XOR sem afetar outros.",
                                "Classe OO encapsula e manipula flags via métodos.",
                                "Testes unitários passam para 5 cenários.",
                                "Explica eficiência bitwise vs alternativas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na manipulação binária (sem erros de cálculo).",
                                "Correta implementação de toggle/inversão (resultados esperados).",
                                "Encapsulamento OO adequado (private fields, public methods).",
                                "Eficiência e legibilidade do código.",
                                "Cobertura de testes abrangente.",
                                "Compreensão verbal de conceitos bitwise."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra booleana e lógica digital.",
                                "Ciências da Computação: Criptografia (ex: one-time pad com XOR).",
                                "Engenharia de Software: Otimização de memória em embedded systems.",
                                "Física: Representação de estados quânticos (qubits com NOT/XOR)."
                              ],
                              "realWorldApplication": "Em jogos para flags de estado de jogador (poderes ativos), sistemas operacionais para permissões de arquivos (chmod bitwise), ou protocolos de rede para checksums e criptografia simples."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.2.3",
                            "name": "Aplicar operadores de deslocamento bitwise",
                            "description": " Empregar operadores de shift esquerdo (<<) e direito (>>) em valores numéricos de objetos para multiplicação/divisão por potências de 2 ou packing de dados em contextos de programação orientada a objetos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o funcionamento dos operadores de deslocamento bitwise",
                                  "subSteps": [
                                    "Estude a representação binária de números inteiros em memória.",
                                    "Analise como o operador << (shift esquerdo) move bits para a esquerda, adicionando zeros à direita.",
                                    "Analise como o operador >> (shift direito) move bits para a direita, preservando o sinal em shifts aritméticos.",
                                    "Compare shifts com multiplicação/divisão por 2^n, onde n é o número de posições deslocadas.",
                                    "Teste exemplos simples em um interpretador ou IDE."
                                  ],
                                  "verification": "Resuma em suas palavras o que <<3 faz em 5 (resultado: 40) e verifique com cálculo binário.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code)",
                                    "Documentação de bitwise operators na linguagem (Java, C#, etc.)",
                                    "Calculadora binária online"
                                  ],
                                  "tips": "Sempre converta para binário para visualizar o shift; lembre que << n é equivalente a * (2^n).",
                                  "learningObjective": "Entender conceitualmente como shifts manipulam bits para operações matemáticas eficientes.",
                                  "commonMistakes": [
                                    "Confundir shift lógico (>>>) com aritmético (>>)",
                                    "Ignorar overflow em shifts esquerdos",
                                    "Aplicar shifts em números flutuantes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar operador << para multiplicação por potências de 2",
                                  "subSteps": [
                                    "Crie uma classe simples (ex: CalculadoraBitwise) com método que recebe um inteiro e um expoente n.",
                                    "Implemente multiplicação usando num << n e compare com num * (1 << n).",
                                    "Teste com valores como 10 << 2 (40) e valide resultados.",
                                    "Adicione tratamento para overflow usando tipos maiores (long).",
                                    "Integre em um objeto OOP, como um Vetor2D que escala componentes."
                                  ],
                                  "verification": "Execute testes unitários comprovando que 7 << 3 == 56 e sem erros de precisão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE com suporte a testes (JUnit, NUnit)",
                                    "Exemplos de código em GitHub sobre bitwise"
                                  ],
                                  "tips": "Use shifts para otimizar loops de multiplicação por constantes como 2,4,8.",
                                  "learningObjective": "Dominar << para substituir multiplicações por potências de 2 em código performático.",
                                  "commonMistakes": [
                                    "Usar em negativos sem considerar sinal",
                                    "Esquecer que << pode causar overflow rápido",
                                    "Comparar incorretamente com floats"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar operador >> para divisão por potências de 2",
                                  "subSteps": [
                                    "Na mesma classe, implemente divisão usando num >> n e compare com num / (1 << n).",
                                    "Teste com 100 >> 2 (25) e observe truncamento para inteiros.",
                                    "Diferencie >> lógico e aritmético em linguagens como JavaScript.",
                                    "Aplique em um objeto como Pixel que divide cores por 4 para downsampling.",
                                    "Valide com casos de borda: números ímpares e negativos."
                                  ],
                                  "verification": "Confirme que 17 >> 1 == 8 e que resultados batem com divisão inteira.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação específica da linguagem sobre shifts",
                                    "Ferramenta de depuração binária"
                                  ],
                                  "tips": ">> é mais rápido que / para potências de 2, mas arredonda para baixo sempre.",
                                  "learningObjective": "Usar >> para divisões eficientes e entender truncamento.",
                                  "commonMistakes": [
                                    "Esperar divisão exata em ímpares",
                                    "Usar >>> em contextos assinados",
                                    "Ignorar perda de precisão em múltiplos shifts"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Utilizar shifts para packing de dados em objetos OOP",
                                  "subSteps": [
                                    "Crie uma classe compacta (ex: FlagsContainer) que packa múltiplos booleanos em um int usando shifts.",
                                    "Implemente set/get de flags com |, &, << (ex: flag1 = 1 << 0).",
                                    "Teste packing de 4 flags em 32 bits e extração com >>.",
                                    "Aplique em um contexto real: objeto de configurações de jogo com bits para opções.",
                                    "Otimize memória comparando tamanhos antes/depois."
                                  ],
                                  "verification": "Demonstre packing de 3 flags e recuperação correta sem perda de dados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplos de bitfields em C# ou Java",
                                    "Ferramenta de profiling de memória"
                                  ],
                                  "tips": "Mantenha flags em posições fixas para portabilidade; use enums para nomes.",
                                  "learningObjective": "Aplicar shifts em packing para economia de memória em OOP.",
                                  "commonMistakes": [
                                    "Sobrepor bits com shifts inadequados",
                                    "Exceder 32/64 bits",
                                    "Esquecer máscaras com & após >>"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma classe JogadorOOP, packe status como vida (8 bits), mana (8 bits), level (8 bits) em um int flags. Use << para setar level*256 e >>8 para extrair, permitindo envio eficiente em rede multiplayer.",
                              "finalVerifications": [
                                "Implementa corretamente << para multiplicar 15 por 16 (240).",
                                "Usa >> para dividir 128 por 4 (32) sem erros.",
                                "Packa e despacka 4 flags em um int com 100% acurácia.",
                                "Explica binariamente o resultado de 5 << 2 >> 1.",
                                "Otimiza um método substituindo *8 por <<3 com ganho de performance.",
                                "Trata overflow em shifts com tipos long."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Correta equivalência shift x potências de 2 (90%).",
                                "Implementação OOP: Integração limpa em classes com encapsulamento.",
                                "Eficiência: Código mais rápido que operações aritméticas padrão.",
                                "Tratamento de erros: Lida com overflow, negativos e bordas.",
                                "Testes: Cobertura completa com asserts em unit tests.",
                                "Clareza: Código comentado e legível."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações com bases 2 e logaritmos binários.",
                                "Eletrônica: Registradores de shift em microcontroladores (Arduino).",
                                "Física Computacional: Representação de vetores em simulações binárias.",
                                "Design de Jogos: Flags de estado em engines como Unity.",
                                "Criptografia: Shifts em algoritmos como AES para rotação de bits."
                              ],
                              "realWorldApplication": "Em desenvolvimento de jogos (otimização de posições de sprites via << para x2 scale), dispositivos IoT (packing de sensores em bytes para transmissão wireless), engines gráficas (manipulação de máscaras de cores) e bibliotecas de compressão de dados para economia de banda."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.5",
                    "name": "Tipagem Estática versus Dinâmica",
                    "description": "Características e impactos da tipagem estática e dinâmica no uso de tipos de dados em POO.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.5.1",
                        "name": "Tipagem Estática",
                        "description": "Características da tipagem estática, onde os tipos de variáveis e expressões são verificados em tempo de compilação, promovendo detecção precoce de erros e otimização de performance em linguagens POO como C++ e Java.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.1.1",
                            "name": "Definir tipagem estática",
                            "description": "Explicar que na tipagem estática o tipo de uma variável deve ser declarado explicitamente antes do uso e é verificado pelo compilador, evitando erros de tipo em tempo de execução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição e Características da Tipagem Estática",
                                  "subSteps": [
                                    "Leia a definição: Tipagem estática requer declaração explícita do tipo de variável antes do uso.",
                                    "Identifique características principais: verificação pelo compilador em tempo de compilação, tipos fixos após declaração.",
                                    "Anote exemplos de linguagens com tipagem estática: Java, C++, C#.",
                                    "Explique verbalmente ou por escrito o que acontece se um tipo incompatível for atribuído.",
                                    "Compare brevemente com tipagem dinâmica (sem declaração explícita, verificada em runtime)."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo a definição e liste 3 características principais; revise se cobre declaração explícita e verificação pelo compilador.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de linguagens como Java ou C++ (online)",
                                    "Bloco de notas ou editor de texto"
                                  ],
                                  "tips": [
                                    "Use analogia: como um contrato fixo antes de assinar, não muda depois.",
                                    "Foque em 'compilador verifica' vs 'runtime detecta'."
                                  ],
                                  "learningObjective": "Definir tipagem estática e listar suas características principais.",
                                  "commonMistakes": [
                                    "Confundir com tipagem dinâmica (ex: achar que é verificada em runtime)",
                                    "Pensar que tipos podem mudar após declaração",
                                    "Esquecer declaração explícita"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Diferenças com Tipagem Dinâmica",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: colunas para Estática vs Dinâmica (declaração, verificação, performance, erros).",
                                    "Estude exemplo: em Python (dinâmica) vs Java (estática) atribuindo string a variável numérica.",
                                    "Discuta vantagens da estática: detecção precoce de erros, melhor performance.",
                                    "Identifique desvantagens: menos flexibilidade, código mais verboso.",
                                    "Registre 2 cenários onde estática previne erros em runtime."
                                  ],
                                  "verification": "Complete a tabela comparativa e explique uma vantagem com exemplo; verifique se tabela tem pelo menos 4 linhas de comparação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de código Python e Java (copiados de tutoriais online)",
                                    "Planilha ou papel para tabela"
                                  ],
                                  "tips": [
                                    "Lembre: estática = 'segura no compile time', dinâmica = 'flexível mas arriscada'.",
                                    "Use IDE para testar snippets rápidos."
                                  ],
                                  "learningObjective": "Comparar tipagem estática com dinâmica, destacando verificação pelo compilador.",
                                  "commonMistakes": [
                                    "Achar que dinâmica é sempre melhor por flexibilidade",
                                    "Ignorar impacto na performance",
                                    "Confundir compilador com interpretador"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar Declaração de Variáveis com Tipos Estáticos",
                                  "subSteps": [
                                    "Instale ou abra um ambiente Java (ex: IntelliJ, VS Code com JDK).",
                                    "Escreva código declarando variáveis: int idade = 25; String nome = \"João\"; double salario = 5000.5;",
                                    "Tente atribuir tipos errados: nome = 123; (deve dar erro de compilação).",
                                    "Corrija e compile o código com javac ou via IDE.",
                                    "Adicione prints para exibir valores após declaração correta."
                                  ],
                                  "verification": "Compile o código sem erros e execute mostrando saídas corretas; capture screenshot do erro de tipo incompatível.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "JDK instalado",
                                    "Editor de código (IntelliJ ou VS Code)",
                                    "Terminal para javac"
                                  ],
                                  "tips": [
                                    "Sempre declare tipo antes: int x; x = 5;",
                                    "Use 'public class Main { public static void main(String[] args) { ... } }' para programa Java mínimo."
                                  ],
                                  "learningObjective": "Declarar variáveis com tipos estáticos e observar erros de compilação.",
                                  "commonMistakes": [
                                    "Esquecer ponto e vírgula ou chaves",
                                    "Usar var sem contexto (pré-Java 10)",
                                    "Atribuir sem inicializar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em um Programa Simples e Analisar Benefícios",
                                  "subSteps": [
                                    "Crie um programa que calcule média de notas: declare arrays de double, some e divida.",
                                    "Introduza erro intencional: atribua String a double e compile para ver falha.",
                                    "Refatore para usar apenas tipos corretos e discuta como evitou runtime crash.",
                                    "Meça tempo de compilação vs execução e anote observações sobre performance.",
                                    "Escreva comentário no código explicando por que tipagem estática foi usada."
                                  ],
                                  "verification": "Programa compila e executa corretamente; relatório de 100 palavras sobre um erro evitado pelo compilador.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ambiente Java configurado",
                                    "Exemplos de código de cálculo de média online"
                                  ],
                                  "tips": [
                                    "Teste incremental: compile após cada declaração.",
                                    "Comente código generosamente para reforçar conceitos."
                                  ],
                                  "learningObjective": "Implementar tipagem estática em programa funcional, analisando prevenção de erros.",
                                  "commonMistakes": [
                                    "Misturar tipos sem casting",
                                    "Ignorar warnings do compilador",
                                    "Fazer programa muito complexo inicialmente"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Java: 'int numero = 42; String texto = \"Olá\"; numero = texto;' → Erro de compilação: 'incompatible types: String cannot be converted to int'. Isso previne crash em runtime, como ocorreria em Python.",
                              "finalVerifications": [
                                "Explica corretamente que tipos são declarados explicitamente e verificados pelo compilador.",
                                "Identifica e corrige erro de tipo incompatível em código fornecido.",
                                "Lista 3 vantagens da tipagem estática sobre dinâmica.",
                                "Compila programa Java simples sem erros de tipo.",
                                "Descreve cenário real onde tipagem estática evitou bug.",
                                "Compara declaração em Java vs Python com exemplos precisos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (declaração explícita e verificação em compile-time): 30%",
                                "Exemplos de código corretos e erros demonstrados: 25%",
                                "Compreensão de diferenças com tipagem dinâmica: 20%",
                                "Aplicação prática em programa funcional: 15%",
                                "Análise de benefícios e prevenção de erros: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Tipos numéricos (int, double) e precisão em cálculos.",
                                "Lógica e Algoritmos: Detecção precoce de inconsistências lógicas via compilador.",
                                "Inglês Técnico: Leitura de documentação e mensagens de erro em inglês.",
                                "Física/Engenharia: Modelagem precisa de variáveis como grandezas físicas (ex: velocidade como double)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software bancário (Java), tipagem estática previne erros como somar CPF (String) com saldo (double), evitando perdas financeiras por crashes em produção."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.2",
                            "name": "Identificar vantagens da tipagem estática em POO",
                            "description": "Listar benefícios como detecção precoce de erros, melhor performance por otimização em compilação e suporte a herança e polimorfismo tipados estaticamente em classes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Tipagem Estática",
                                  "subSteps": [
                                    "Defina tipagem estática como a verificação de tipos de variáveis no tempo de compilação.",
                                    "Compare com tipagem dinâmica, onde tipos são verificados em runtime.",
                                    "Identifique linguagens exemplos: Java, C++, TypeScript (estática) vs Python, JavaScript (dinâmica).",
                                    "Estude como o compilador atribui e verifica tipos explicitamente.",
                                    "Revise sintaxe básica de declaração de tipos em uma linguagem estática."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre tipagem estática e dinâmica, citando exemplos de linguagens.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial de Java ou C++",
                                    "Tutoriais online sobre tipos de dados",
                                    "Editor de código como VS Code"
                                  ],
                                  "tips": [
                                    "Use diagramas para visualizar o fluxo de compilação vs execução.",
                                    "Pratique declarando variáveis tipadas simples."
                                  ],
                                  "learningObjective": "Dominar a definição e características fundamentais da tipagem estática.",
                                  "commonMistakes": [
                                    "Confundir tipagem estática com declaração explícita de variáveis.",
                                    "Achar que tipagem estática elimina todos os erros em runtime."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Benefícios Gerais da Tipagem Estática",
                                  "subSteps": [
                                    "Liste detecção precoce de erros: compilador flagga incompatibilidades de tipo antes da execução.",
                                    "Discuta melhor performance: otimizações em compilação sem verificações de tipo em runtime.",
                                    "Explore refatoração segura: IDEs fornecem autocompletar e navegação baseadas em tipos.",
                                    "Analise documentação implícita: tipos servem como contrato claro para funções e métodos.",
                                    "Registre cenários onde esses benefícios reduzem tempo de debug."
                                  ],
                                  "verification": "Crie uma lista de pelo menos 4 benefícios gerais e justifique cada um com uma frase.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigos sobre 'Static Typing Benefits'",
                                    "Compiladores online como JDoodle para Java",
                                    "Livros de introdução a linguagens compiladas"
                                  ],
                                  "tips": [
                                    "Associe cada benefício a um problema real de programação dinâmica.",
                                    "Anote exemplos pessoais de erros em código dinâmico."
                                  ],
                                  "learningObjective": "Reconhecer e explicar os principais benefícios da tipagem estática em programação geral.",
                                  "commonMistakes": [
                                    "Superestimar performance sem considerar otimizações específicas.",
                                    "Ignorar que tipagem estática pode adicionar verbosidade inicial."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Vantagens Específicas da Tipagem Estática em POO",
                                  "subSteps": [
                                    "Analise suporte a herança: compilador verifica compatibilidade de tipos em subclasses.",
                                    "Estude polimorfismo tipado: interfaces e superclasses garantem contratos tipados estaticamente.",
                                    "Examine detecção de erros em overrides: assinaturas de métodos devem coincidir exatamente.",
                                    "Discuta otimização em compilação para hierarquias de classes complexas.",
                                    "Crie um diagrama UML simples mostrando herança com tipos estáticos."
                                  ],
                                  "verification": "Descreva como tipagem estática previne erros em um exemplo de herança em POO.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramentas UML como draw.io",
                                    "Exemplos de código POO em Java",
                                    "Documentação de OOP em linguagens tipadas"
                                  ],
                                  "tips": [
                                    "Pense em polimorfismo como 'duck typing seguro' com verificação antecipada.",
                                    "Teste overrides incorretos para ver erros de compilação."
                                  ],
                                  "learningObjective": "Identificar como tipagem estática aprimora herança e polimorfismo em POO.",
                                  "commonMistakes": [
                                    "Confundir polimorfismo dinâmico com estático.",
                                    "Achar que POO só funciona bem com tipagem estática."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Comparar com Exemplos Práticos",
                                  "subSteps": [
                                    "Escreva código POO com herança em linguagem estática (Java) e dinâmica (Python).",
                                    "Introduza um erro de tipo intencional e compile/executar ambos.",
                                    "Meça diferenças em tempo de detecção de erros e performance básica.",
                                    "Refatore o código estático usando IDE com suporte a tipos.",
                                    "Documente lições aprendidas em um relatório curto."
                                  ],
                                  "verification": "Execute os códigos e capture screenshots dos erros de compilação vs runtime.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "IDEs como IntelliJ para Java, PyCharm para Python",
                                    "Plataformas online como Replit",
                                    "Cronômetro para testes de performance"
                                  ],
                                  "tips": [
                                    "Use exemplos simples como Animal > Dog com métodos override.",
                                    "Compare tamanhos de binários compilados para performance."
                                  ],
                                  "learningObjective": "Aplicar conhecimentos para demonstrar vantagens práticas em cenários POO reais.",
                                  "commonMistakes": [
                                    "Usar exemplos muito complexos que obscurecem o ponto.",
                                    "Ignorar overhead inicial de tipagem estática."
                                  ]
                                }
                              ],
                              "practicalExample": "Em Java (estática): classe Animal { void fazerSom(); } classe Cachorro extends Animal { void fazerSom() { System.out.println('Au'); } } // Erro detectado em compilação se override errado. Em Python (dinâmica): mesmo código roda até execução, falhando em runtime se tipos incompatíveis, atrasando debug em apps grandes.",
                              "finalVerifications": [
                                "Liste 5 vantagens da tipagem estática em POO sem consultar notas.",
                                "Explique como compilador otimiza polimorfismo estático.",
                                "Identifique 3 erros comuns em POO dinâmica que estática previne.",
                                "Crie um exemplo de herança tipada estática e valide.",
                                "Compare performance em um teste simples de código.",
                                "Descreva impacto em equipes de desenvolvimento."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de benefícios (detecção de erros, performance, herança).",
                                "Completude da lista de vantagens com justificativas claras.",
                                "Uso correto de exemplos de código em linguagens apropriadas.",
                                "Demonstração de compreensão via comparações estático vs dinâmico.",
                                "Criatividade em aplicações reais de POO tipada.",
                                "Clareza na explicação de polimorfismo e herança."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Rigor dos tipos semelhantes a provas formais e teoremas.",
                                "Lógica e Filosofia: Contratos explícitos como axiomas em sistemas formais.",
                                "Engenharia de Software: Otimização e confiabilidade como em engenharia civil.",
                                "Design de Sistemas: Hierarquias tipadas como modelagem de dados em bancos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software enterprise como sistemas bancários (Java/Spring), tipagem estática previne erros caros em transações; em jogos AAA (C++), otimiza performance para heranças de entidades; em apps escaláveis (TypeScript/Node), facilita manutenção em equipes grandes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.3",
                            "name": "Exemplificar com linguagens POO",
                            "description": "Demonstrar declaração de classes e variáveis tipadas estaticamente em C++, destacando verificação de tipos em métodos e herança.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Declarar uma classe base com variáveis tipadas estaticamente",
                                  "subSteps": [
                                    "Abra um editor de código C++ como Visual Studio Code ou Code::Blocks.",
                                    "Inclua as bibliotecas necessárias: #include <iostream> e usando namespace std.",
                                    "Defina uma classe base chamada 'Veiculo' com variáveis privadas tipadas: int id; string modelo; double preco.",
                                    "Adicione um construtor para inicializar essas variáveis.",
                                    "Inclua um método público para exibir os dados."
                                  ],
                                  "verification": "Compilar o código e verificar se não há erros de declaração de tipos; instancie a classe no main e chame o método sem warnings.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código C++ (ex: VS Code com extensão C++), compilador g++.",
                                  "tips": "Sempre declare variáveis com tipos explícitos como 'int' ou 'double' para evitar inferências dinâmicas inexistentes em C++.",
                                  "learningObjective": "Entender e aplicar declaração estática de tipos em classes C++ para encapsulamento de dados.",
                                  "commonMistakes": "Esquecer ponto-e-vírgula após a declaração da classe; usar 'var' ou tipos dinâmicos como em Python."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar métodos com verificação de tipos estática",
                                  "subSteps": [
                                    "Na classe Veiculo, adicione métodos como 'setPreco(double p)' que verifica se p > 0 antes de atribuir.",
                                    "Crie um método 'getPreco()' que retorna double.",
                                    "Adicione sobrecarga de métodos para diferentes tipos, ex: setModelo(string m).",
                                    "No main, teste chamadas com tipos incorretos para observar erros de compilação.",
                                    "Compile e execute para confirmar verificação em tempo de compilação."
                                  ],
                                  "verification": "Tentar passar string para setPreco deve gerar erro de compilação; execução bem-sucedida com tipos corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesmo editor e compilador; terminal para g++ -o programa main.cpp.",
                                  "tips": "Use 'const' em parâmetros de métodos para reforçar imutabilidade e tipagem rigorosa.",
                                  "learningObjective": "Demonstrar como o compilador C++ verifica tipos em métodos antes da execução.",
                                  "commonMistakes": "Passar tipos incompatíveis sem notar que o erro surge na compilação, não runtime."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estender a classe com herança e polimorfismo básico",
                                  "subSteps": [
                                    "Crie uma classe derivada 'Carro' que herda publicamente de Veiculo: class Carro : public Veiculo {}.",
                                    "Adicione variáveis específicas em Carro: int portas; bool automatico.",
                                    "Sobrescreva o método de exibição em Carro para incluir novas variáveis.",
                                    "No main, crie objetos Veiculo e Carro, chame métodos e acesse via ponteiro base para mostrar herança.",
                                    "Compile e teste upcasting/downcasting com verificação de tipos."
                                  ],
                                  "verification": "Código compila; saída mostra dados corretos da classe derivada via ponteiro base sem erros de tipo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor C++, compilador; debugger opcional como gdb.",
                                  "tips": "Use virtual em métodos da base para polimorfismo futuro; evite herança múltipla inicial.",
                                  "learningObjective": "Aplicar herança em C++ mantendo tipagem estática em hierarquias de classes.",
                                  "commonMistakes": "Esquecer 'public' na herança, causando acesso privado; slicing ao atribuir derivada a base sem ponteiro."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e demonstrar benefícios da tipagem estática",
                                  "subSteps": [
                                    "Expanda o main com cenários de erro: tente atribuir int a string para ver falha na compilação.",
                                    "Compare com pseudocódigo dinâmico (comentado) mostrando onde runtime errors ocorreriam.",
                                    "Execute testes unitários simples com ifs para validar herança e tipos.",
                                    "Gere relatório de saída compilada vs. erros potenciais.",
                                    "Refatore código para otimizar tipos (ex: usar enum para status)."
                                  ],
                                  "verification": "Compilação falha intencionalmente em testes errados; sucesso nos corretos com saída verificável.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Compilador, terminal para múltiplas compilações.",
                                  "tips": "Use static_assert para verificações de tipo em tempo de compilação avançadas.",
                                  "learningObjective": "Consolidar compreensão dos ganhos de tipagem estática em detecção precoce de erros.",
                                  "commonMistakes": "Ignorar warnings do compilador como -Wall; confundir erros de link com tipo."
                                }
                              ],
                              "practicalExample": "Crie um programa C++ com classe Veiculo { private: int id; string modelo; double preco; public: Veiculo(int i, string m, double p) : id(i), modelo(m), preco(p) {} void exibir() { cout << 'ID: ' << id << ', Modelo: ' << modelo << ', Preco: ' << preco << endl; } }; class Carro : public Veiculo { int portas; public: Carro(int i, string m, double p, int pt) : Veiculo(i,m,p), portas(pt) {} void exibir() override { Veiculo::exibir(); cout << 'Portas: ' << portas << endl; } }; int main() { Veiculo* v = new Carro(1, \"Fusca\", 20000.0, 2); v->exibir(); delete v; return 0; } // Compila e executa mostrando tipagem estática em ação.",
                              "finalVerifications": [
                                "Código compila sem erros ou warnings de tipo usando g++ -Wall -Wextra.",
                                "Execução produz saída correta demonstrando herança e acesso tipado.",
                                "Tentativas de atribuição de tipos incorretos falham na compilação.",
                                "Métodos sobrecarregados funcionam apenas com tipos exatos.",
                                "Herança permite polimorfismo básico via ponteiro base.",
                                "Nenhuma exceção runtime por violação de tipo ocorre."
                              ],
                              "assessmentCriteria": [
                                "Precisão na declaração de classes e tipos estáticos (30%).",
                                "Correta implementação de métodos com verificação de tipos (25%).",
                                "Uso efetivo de herança sem erros de acesso (20%).",
                                "Demonstração clara de erros de compilação vs. runtime (15%).",
                                "Código limpo, comentado e executável (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Uso de tipos numéricos precisos como double para cálculos financeiros.",
                                "Lógica e Algoritmos: Verificação estática como pré-condição lógica em fluxos.",
                                "Inglês Técnico: Leitura de documentação C++ e erros de compilador.",
                                "Design de Software: Princípios SOLID iniciais via herança."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software enterprise como sistemas bancários (C++ para performance), onde tipagem estática previne erros caros em produção, como em engines de jogos (Unreal Engine) ou simulações físicas com herança de entidades."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.2",
                        "name": "Tipagem Dinâmica",
                        "description": "Características da tipagem dinâmica, onde os tipos são determinados em tempo de execução, oferecendo flexibilidade mas com risco de erros em runtime, comum em Python para POO.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.2.1",
                            "name": "Definir tipagem dinâmica",
                            "description": "Descrever que na tipagem dinâmica os tipos não precisam ser declarados explicitamente e são resolvidos durante a execução, permitindo duck typing em objetos POO.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Tipagem Dinâmica",
                                  "subSteps": [
                                    "Leia a definição oficial de tipagem dinâmica: tipos inferidos em tempo de execução sem declaração explícita.",
                                    "Identifique linguagens com tipagem dinâmica: Python, JavaScript, Ruby.",
                                    "Explique verbalmente ou por escrito como o interpretador resolve tipos automaticamente.",
                                    "Compare com declaração estática usando pseudocódigo simples.",
                                    "Anote diferenças chave em um quadro comparativo."
                                  ],
                                  "verification": "Crie um quadro comparativo entre tipagem dinâmica e estática com pelo menos 5 diferenças.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de Python ou JavaScript sobre tipos",
                                    "Papel e caneta ou editor de texto"
                                  ],
                                  "tips": "Use analogias como 'o tipo é descoberto como uma surpresa em uma caixa' para fixar o conceito.",
                                  "learningObjective": "Explicar o que é tipagem dinâmica e como ela difere da estática.",
                                  "commonMistakes": [
                                    "Confundir com tipagem fraca",
                                    "Achar que não há verificação de tipos",
                                    "Ignorar overhead de performance em runtime"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Resolução de Tipos em Tempo de Execução",
                                  "subSteps": [
                                    "Escreva um script simples em Python atribuindo diferentes tipos a uma mesma variável.",
                                    "Execute o código e observe mudanças de tipo com funções como type() e isinstance().",
                                    "Teste operações entre tipos mistos e veja como o runtime lida com elas.",
                                    "Registre erros comuns de tipo incompatível em runtime.",
                                    "Modifique o código para forçar um erro de tipo e depure-o."
                                  ],
                                  "verification": "Demonstre um script que muda o tipo de uma variável 3 vezes e imprime type() a cada mudança.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou IDLE)",
                                    "Python instalado"
                                  ],
                                  "tips": "Sempre use print(type(variavel)) após atribuições para visualizar inferência.",
                                  "learningObjective": "Demonstrar como tipos são resolvidos dinamicamente durante execução.",
                                  "commonMistakes": [
                                    "Declarar tipos explicitamente (violando dinamismo)",
                                    "Não testar com tipos mistos",
                                    "Ignorar exceções TypeError"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir Duck Typing em Objetos POO",
                                  "subSteps": [
                                    "Defina duck typing: 'Se anda como pato e grasna como pato, é um pato'.",
                                    "Crie classes POO sem herança explícita, mas com métodos comuns (ex: quack(), walk()).",
                                    "Implemente uma função que aceita qualquer objeto com os métodos necessários.",
                                    "Teste com objetos de classes diferentes que implementam os mesmos métodos.",
                                    "Explique por que isso funciona sem declarações de tipo ou interfaces."
                                  ],
                                  "verification": "Escreva uma função que funcione com 2 classes diferentes via duck typing.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor Python",
                                    "Referência POO Python (classes e métodos)"
                                  ],
                                  "tips": "Evite herança; foque em métodos compartilhados implicitamente.",
                                  "learningObjective": "Aplicar duck typing para flexibilidade em POO com tipagem dinâmica.",
                                  "commonMistakes": [
                                    "Forçar herança desnecessária",
                                    "Verificar tipos com isinstance()",
                                    "Não testar falhas sem métodos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Aplicar o Conceito Completo",
                                  "subSteps": [
                                    "Resuma em um parágrafo: definição, resolução runtime e duck typing.",
                                    "Crie um exemplo realista: sistema de animais com comportamentos variados.",
                                    "Compare performance com equivalente em linguagem estática (pseudocódigo Java).",
                                    "Discuta prós (flexibilidade) e contras (erros runtime).",
                                    "Autoavalie compreensão respondendo 3 perguntas chave."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras e um código exemplo com duck typing.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Notas anteriores"
                                  ],
                                  "tips": "Use bullet points para prós/contras para clareza.",
                                  "learningObjective": "Integrar todos os aspectos da tipagem dinâmica em uma visão coesa.",
                                  "commonMistakes": [
                                    "Omitir contras como debugging difícil",
                                    "Exagerar flexibilidade sem mencionar riscos",
                                    "Não ligar de volta a POO"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python, def faz_barulho(obj): return obj.quack()  # Funciona para qualquer obj com .quack(), sem declarar tipo. Classe Pato: def quack(self): return 'Quack!'  Classe Robot: def quack(self): return 'Beep!'  faz_barulho(Pato()) e faz_barulho(Robot()) ambos funcionam via duck typing.",
                              "finalVerifications": [
                                "Explique tipagem dinâmica sem olhar notas.",
                                "Identifique 3 linguagens dinâmicas e 2 estáticas.",
                                "Corrija um código com erro de tipo runtime.",
                                "Implemente duck typing em novo exemplo.",
                                "Liste 2 prós e 2 contras.",
                                "Compare com tipagem estática em tabela."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (sem confusão com tipagem fraca).",
                                "Demonstração prática com código funcional.",
                                "Compreensão de duck typing via exemplo POO.",
                                "Identificação correta de resolução em runtime.",
                                "Análise equilibrada de vantagens/desvantagens.",
                                "Uso correto de verificações como type() e AttributeError."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Inferência de tipos similar a resolução de equações implícitas.",
                                "Lógica: Duck typing como raciocínio por propriedades observáveis.",
                                "Física: Analogia com propriedades emergentes em sistemas dinâmicos.",
                                "Linguística: Semântica dinâmica em interpretação de linguagem natural."
                              ],
                              "realWorldApplication": "Desenvolvimento web com JavaScript (React apps flexíveis), scripts de automação em Python (bibliotecas como Pandas inferem tipos), e jogos em Ruby on Rails onde objetos heterogêneos interagem sem rigidez de tipos."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.2.2",
                            "name": "Identificar vantagens da tipagem dinâmica em POO",
                            "description": "Explicar flexibilidade em prototipagem rápida, suporte a polimorfismo por duck typing e redução de código boilerplate em classes Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos da Tipagem Dinâmica em POO",
                                  "subSteps": [
                                    "Defina tipagem dinâmica: tipos de variáveis determinados em tempo de execução.",
                                    "Compare com tipagem estática: tipos declarados em tempo de compilação.",
                                    "Examine exemplos simples em Python: crie uma classe sem anotações de tipo.",
                                    "Discuta implicações em POO: herança e métodos sem rigidez de tipos.",
                                    "Identifique cenários onde a dinâmica é preferível em desenvolvimento ágil."
                                  ],
                                  "verification": "Escreva uma definição precisa e um exemplo de código Python de uma classe com tipagem dinâmica que rode sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código Python (ex: VS Code)",
                                    "Documentação Python oficial sobre tipos"
                                  ],
                                  "tips": [
                                    "Use print(type(obj)) para inspecionar tipos em runtime.",
                                    "Evite misturar com type hints inicialmente para focar na dinâmica pura."
                                  ],
                                  "learningObjective": "Diferenciar tipagem dinâmica de estática e seu impacto inicial em classes POO.",
                                  "commonMistakes": [
                                    "Confundir tipagem dinâmica com tipagem fraca.",
                                    "Assumir que dinâmica ignora completamente os tipos (Python tem type checking opcional)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Flexibilidade para Prototipação Rápida",
                                  "subSteps": [
                                    "Crie uma classe base simples em Python sem declarações de tipo.",
                                    "Adicione subclasses e instâncias variadas sem recompilar.",
                                    "Modifique atributos e métodos dinamicamente durante testes.",
                                    "Meça tempo de iteração comparado a linguagens estáticas como Java.",
                                    "Teste refatorações rápidas alterando estruturas de classes em minutos."
                                  ],
                                  "verification": "Desenvolva e itere uma classe protótipo em menos de 5 minutos, demonstrando mudanças sem erros de tipo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python REPL ou Jupyter Notebook",
                                    "Timer para medir iterações"
                                  ],
                                  "tips": [
                                    "Use __dict__ para inspecionar atributos dinâmicos.",
                                    "Comece com classes mínimas e adicione features incrementalmente."
                                  ],
                                  "learningObjective": "Demonstrar como tipagem dinâmica acelera ciclos de prototipagem em POO.",
                                  "commonMistakes": [
                                    "Sobreengenhar classes iniciais, perdendo a vantagem de rapidez.",
                                    "Ignorar erros runtime causados por tipos incompatíveis."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Suporte a Polimorfismo via Duck Typing",
                                  "subSteps": [
                                    "Explique duck typing: 'Se anda como pato e grasna como pato, é um pato'.",
                                    "Crie interfaces implícitas com métodos comuns em classes diferentes.",
                                    "Implemente uma função polimórfica que aceite qualquer objeto com método requerido.",
                                    "Teste com classes não relacionadas que compartilhem métodos.",
                                    "Compare com polimorfismo explícito em linguagens estáticas."
                                  ],
                                  "verification": "Escreva uma função que processe objetos de classes distintas via duck typing, sem herança explícita.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de código Python para duck typing",
                                    "Ferramenta de linting opcional como mypy para contraste"
                                  ],
                                  "tips": [
                                    "Priorize 'if hasattr(obj, 'method')' para checks dinâmicos.",
                                    "Mantenha métodos com assinaturas compatíveis para polimorfismo suave."
                                  ],
                                  "learningObjective": "Identificar como duck typing habilita polimorfismo flexível sem hierarquias rígidas.",
                                  "commonMistakes": [
                                    "Forçar herança desnecessária, perdendo essência do duck typing.",
                                    "Não testar casos edge onde métodos existem mas comportamentos diferem."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar Redução de Código Boilerplate em Classes",
                                  "subSteps": [
                                    "Compare declaração de classes Python vs Java/C#: sem getters/setters obrigatórios.",
                                    "Use @property para encapsulamento dinâmico sem boilerplate extra.",
                                    "Crie dataclasses ou namedtuples para estruturas simples sem código repetitivo.",
                                    "Refatore uma classe verbose de linguagem estática para Python conciso.",
                                    "Avalie linhas de código salvas e legibilidade melhorada."
                                  ],
                                  "verification": "Converta uma classe Java hipotética para Python, reduzindo pelo menos 30% do código sem perda de funcionalidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de classes boilerplate em Java/C#",
                                    "Biblioteca dataclasses do Python 3.7+"
                                  ],
                                  "tips": [
                                    "Aproveite slots em classes para otimização sem sacrificar dinamismo.",
                                    "Use type hints opcionais só para IDEs, não runtime."
                                  ],
                                  "learningObjective": "Quantificar redução de boilerplate e ganhos em produtividade em POO dinâmica.",
                                  "commonMistakes": [
                                    "Adicionar type hints obrigatórios, reintroduzindo rigidez.",
                                    "Criar classes excessivamente dinâmicas levando a código frágil."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de análise de dados, crie rapidamente uma classe DataProcessor que aceita qualquer fonte de dados (listas, dicionários ou objetos custom) via duck typing, sem declarar interfaces. Prototipe métodos de processamento em minutos, alterando dinamicamente para testes A/B, reduzindo boilerplate comparado a Java.",
                              "finalVerifications": [
                                "Liste e explique 3 vantagens principais com exemplos de código.",
                                "Compare um snippet Python dinâmico vs estático equivalente.",
                                "Demonstre duck typing funcionando com 2 classes não relacionadas.",
                                "Meça tempo de prototipagem de uma classe simples (<5 min).",
                                "Identifique 2 cenários onde tipagem dinâmica supera estática em POO.",
                                "Explique redução de boilerplate com contagem de linhas."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas sem confusões com tipagem fraca.",
                                "Exemplos práticos: código executável e relevante a POO.",
                                "Profundidade: cobertura de todas vantagens (prototipagem, duck typing, boilerplate).",
                                "Clareza: explicações concisas com comparações explícitas.",
                                "Criatividade: aplicações originais além de exemplos básicos.",
                                "Completude: todos steps com verificações e substeps detalhados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstração de funções polimórficas similar a overloads em álgebra.",
                                "Design de Software: Princípios SOLID beneficiados por flexibilidade dinâmica.",
                                "Gestão de Projetos: Alinhamento com metodologias ágeis (Scrum/Kanban) via iterações rápidas.",
                                "Lógica Computacional: Relação com lambda calculus e avaliação dinâmica."
                              ],
                              "realWorldApplication": "Em startups de IA/ML usando Python (ex: TensorFlow protótipos), tipagem dinâmica permite engenheiros iterarem modelos POO rapidamente, integrando dados heterogêneos via duck typing, reduzindo tempo de MVP de semanas para dias, como no desenvolvimento de bots de chat personalizáveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.2.3",
                            "name": "Exemplificar com linguagens POO",
                            "description": "Mostrar criação de classes e métodos em Python sem declaração de tipos, ilustrando binding dinâmico e tratamento de exceções por erros de tipo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e criar classe básica sem declaração de tipos",
                                  "subSteps": [
                                    "Instale o Python e um editor de código como VS Code ou IDLE.",
                                    "Crie um arquivo novo chamado 'dynamic_binding.py'.",
                                    "Defina uma classe simples, ex: class Animal: pass",
                                    "Instancie a classe: meu_animal = Animal()",
                                    "Imprima o tipo: print(type(meu_animal))"
                                  ],
                                  "verification": "Execute o código e confirme que a classe é criada e instanciada sem erros, mostrando <class '__main__.Animal'>.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Python 3.x instalado, editor de texto/código",
                                  "tips": "Use print() para debugar tipos dinamicamente durante o desenvolvimento.",
                                  "learningObjective": "Entender que Python permite criar classes sem especificar tipos, demonstrando tipagem dinâmica.",
                                  "commonMistakes": "Esquecer de salvar o arquivo ou usar indentação incorreta, causando SyntaxError."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Adicionar métodos e demonstrar binding dinâmico",
                                  "subSteps": [
                                    "Adicione um método init sem tipos: def __init__(self, nome): self.nome = nome",
                                    "Crie outro método: def fazer_som(self, som): print(f'{self.nome} faz: {som}')",
                                    "Instancie com diferentes tipos: cachorro = Animal('Rex'); gato = Animal('Miau')",
                                    "Chame métodos: cachorro.fazer_som('Au au'); gato.fazer_som(123)"
                                  ],
                                  "verification": "O código executa e imprime corretamente, aceitando string e int como 'som' sem erros de tipo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Arquivo dynamic_binding.py, terminal para executar python dynamic_binding.py",
                                  "tips": "Experimente passar diferentes tipos para som (str, int, list) para ver binding dinâmico em ação.",
                                  "learningObjective": "Ilustrar como atributos e parâmetros se ligam dinamicamente a qualquer tipo válido em runtime.",
                                  "commonMistakes": "Confundir self com parâmetros nomeados, levando a AttributeError ao acessar self.nome."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir erros de tipo e observar exceções",
                                  "subSteps": [
                                    "Adicione um método que force erro: def som_invalido(self, valor): return valor + 'extra'",
                                    "Tente chamar com int: cachorro.som_invalido(42)",
                                    "Observe o TypeError: unsupported operand type(s) for + ('int', 'str')",
                                    "Registre o traceback completo em um print ou log.",
                                    "Explique verbalmente ou em comentário como isso difere de tipagem estática."
                                  ],
                                  "verification": "Execute e capture o TypeError exato, confirmando detecção em runtime.",
                                  "estimatedTime": "12 minutos",
                                  "materials": "Mesmo arquivo Python, console para ver stack trace",
                                  "tips": "Use try-except temporariamente para capturar e imprimir o erro sem crashar o programa.",
                                  "learningObjective": "Reconhecer que erros de tipo só são detectados em runtime, destacando binding dinâmico.",
                                  "commonMistakes": "Evitar o erro intencionalmente, perdendo a lição sobre exceções dinâmicas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar tratamento de exceções para erros de tipo",
                                  "subSteps": [
                                    "Envolva chamadas em try-except: try: cachorro.som_invalido(42) except TypeError as e: print(f'Erro de tipo: {e}')",
                                    "Crie um método robusto: def som_seguro(self, valor): try: return str(valor) + '!' except: return 'Som inválido'",
                                    "Teste com múltiplos tipos: str, int, list, None.",
                                    "Adicione validação opcional com isinstance() sem forçar tipos.",
                                    "Execute testes completos e documente resultados."
                                  ],
                                  "verification": "Programa roda sem crash, tratando exceções e produzindo saídas coerentes para inputs variados.",
                                  "estimatedTime": "18 minutos",
                                  "materials": "Arquivo atualizado, possivelmente Jupyter Notebook para testes interativos",
                                  "tips": "Prefira exceções específicas como TypeError em vez de except genérico para precisão.",
                                  "learningObjective": "Aprender a tratar exceções de tipo dinâmico, mantendo flexibilidade da POO em Python.",
                                  "commonMistakes": "Usar except Exception amplo demais, mascarando outros erros importantes."
                                }
                              ],
                              "practicalExample": "Crie uma classe Veiculo: class Veiculo: def __init__(self, modelo): self.modelo = modelo; def acelerar(self, velocidade): try: print(f'{self.modelo} acelera para {velocidade} km/h'); return velocidade * 1.1; except TypeError: print('Velocidade deve ser numérica'); carro = Veiculo('Fusca'); carro.acelerar('rápido')  # TypeError tratado; carro.acelerar(100)  # Funciona dinamicamente.",
                              "finalVerifications": [
                                "Código completo executa sem crashes não tratados.",
                                "Binding dinâmico aceita múltiplos tipos em métodos.",
                                "TypeErrors são gerados e capturados corretamente.",
                                "Instâncias de classe funcionam com atributos dinâmicos.",
                                "Comentários explicam diferenças vs. tipagem estática.",
                                "Testes cobrem casos válidos e inválidos."
                              ],
                              "assessmentCriteria": [
                                "Classe e métodos criados sem anotações de tipo (100%).",
                                "Demonstração clara de binding dinâmico com exemplos variados (90-100%).",
                                "Exceções de tipo identificadas e tratadas adequadamente (80-90%).",
                                "Código limpo, indentado e comentado (70-80%).",
                                "Explicação oral/escrita conecta ao conceito de tipagem dinâmica (total).",
                                "Tempo de execução e testes funcionais (bônus)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operadores e tipos de dados dinâmicos em expressões.",
                                "Lógica: Fluxo condicional com try-except como estruturas de decisão.",
                                "Inglês: Documentação de código com comentários em inglês padrão.",
                                "Física: Modelagem de objetos reais (ex: Veiculo com velocidade)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de APIs web (Flask/Django), scripts de automação (data science com Pandas) ou jogos (Pygame), onde flexibilidade dinâmica acelera prototipagem, mas exige tratamento robusto de exceções para produção confiável."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.3",
                        "name": "Comparação e Impactos em POO",
                        "description": "Diferenças entre tipagem estática e dinâmica, e seus impactos no desenvolvimento POO, como performance, manutenibilidade e tratamento de tipos genéricos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.3.1",
                            "name": "Comparar características principais",
                            "description": "Elaborar tabela ou lista comparando verificação de tipos, performance, flexibilidade e suporte a abstração/polimorfismo entre estática e dinâmica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Tipagem Estática e Dinâmica",
                                  "subSteps": [
                                    "Defina tipagem estática: verificação de tipos em tempo de compilação (ex: Java, C++).",
                                    "Defina tipagem dinâmica: verificação de tipos em tempo de execução (ex: Python, JavaScript).",
                                    "Liste vantagens e desvantagens iniciais de cada uma baseadas em documentação oficial.",
                                    "Identifique exemplos de linguagens para cada tipo.",
                                    "Anote diferenças básicas em POO, como declaração de classes."
                                  ],
                                  "verification": "Criar um glossário com definições claras e exemplos de linguagens para ambos os tipos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação de linguagens (Java, Python), notas de aula sobre POO.",
                                  "tips": "Use diagramas de fluxo para visualizar quando a verificação ocorre.",
                                  "learningObjective": "Compreender as definições e diferenças fundamentais entre tipagem estática e dinâmica.",
                                  "commonMistakes": "Confundir tipagem forte/fraca com estática/dinâmica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Detalhar Características Principais para Comparação",
                                  "subSteps": [
                                    "Liste as características: verificação de tipos, performance, flexibilidade, suporte a abstração/polimorfismo.",
                                    "Pesquise verificação de tipos: estática (compile-time errors) vs dinâmica (runtime errors).",
                                    "Analise performance: estática (otimizações em compilação) vs dinâmica (overhead em runtime).",
                                    "Descreva flexibilidade: dinâmica permite duck typing vs estática requer declarações explícitas.",
                                    "Examine suporte a POO: polimorfismo em estática via interfaces vs dinâmica via herança dinâmica."
                                  ],
                                  "verification": "Criar uma lista anotada com pelo menos 3 pontos por característica para cada tipo de tipagem.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Artigos comparativos (ex: Stack Overflow, docs oficiais), editor de texto.",
                                  "tips": "Use tabelas preliminares para organizar notas por característica.",
                                  "learningObjective": "Mapear as quatro características principais e suas implicações específicas.",
                                  "commonMistakes": "Ignorar contexto de POO, focando apenas em linguagens genéricas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Coletar Exemplos Práticos e Evidências para Cada Característica",
                                  "subSteps": [
                                    "Escreva código exemplo em Java (estática) para uma classe com polimorfismo.",
                                    "Escreva equivalente em Python (dinâmica) destacando diferenças.",
                                    "Meça performance simples: compile e execute loops com tipos mistos.",
                                    "Teste flexibilidade: tente atribuir tipos incompatíveis e observe erros.",
                                    "Documente resultados com screenshots ou outputs de console."
                                  ],
                                  "verification": "Compilar e executar pelo menos 2 exemplos por característica, salvando resultados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "IDEs (IntelliJ para Java, VS Code para Python), compiladores instalados.",
                                  "tips": "Use timers para medir performance real em benchmarks simples.",
                                  "learningObjective": "Aplicar conceitos com código prático para validar diferenças.",
                                  "commonMistakes": "Usar exemplos irrelevantes para POO, como scripts simples sem classes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Elaborar Tabela ou Lista Comparativa Final e Analisar Impactos",
                                  "subSteps": [
                                    "Crie tabela com colunas: Característica, Tipagem Estática, Tipagem Dinâmica, Impacto em POO.",
                                    "Preencha com dados das etapas anteriores, incluindo exemplos de código.",
                                    "Adicione linha de análise: quando usar cada uma em projetos POO.",
                                    "Revise por precisão e adicione referências.",
                                    "Formate para clareza (Markdown ou Excel)."
                                  ],
                                  "verification": "Compartilhar tabela com peer para feedback inicial e ajustes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramentas de tabela (Google Sheets, Markdown editor).",
                                  "tips": "Use cores para destacar diferenças (verde para vantagens estática, azul para dinâmica).",
                                  "learningObjective": "Sintetizar informações em formato comparativo acionável.",
                                  "commonMistakes": "Tabela desbalanceada, com mais detalhes em um lado."
                                }
                              ],
                              "practicalExample": "Compare tipagem em um sistema de gerenciamento de formas geométricas em POO: Em Java (estática), defina interface Shape com métodos area() e implemente Circle/Rectangle com verificação em compile-time; em Python (dinâmica), use classes com duck typing, onde area() é chamado em runtime, destacando performance mais rápida em Java para grandes loops mas flexibilidade maior em Python para protótipos rápidos.",
                              "finalVerifications": [
                                "Tabela/lista cobre todas as 4 características com exemplos de código.",
                                "Diferenças em verificação de tipos, performance, flexibilidade e POO estão precisas.",
                                "Impactos em abstração/polimorfismo são explicitados com prós/contras.",
                                "Formato é claro e legível (tabela bem estruturada).",
                                "Referências a linguagens reais (Java/Python) e testes executados.",
                                "Análise inclui cenários de uso em projetos reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão factual: 100% correto sobre diferenças entre estática/dinâmica.",
                                "Completude: Todas características abordadas com evidências.",
                                "Clareza e organização: Tabela intuitiva, sem ambiguidades.",
                                "Profundidade em POO: Ligação explícita a abstração/polimorfismo.",
                                "Evidências práticas: Códigos testados e resultados documentados.",
                                "Análise crítica: Discussão de trade-offs e impactos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica comparativa e análise de conjuntos (estática vs dinâmica como conjuntos disjuntos).",
                                "Física/Engenharia: Analogia com sistemas estáticos (estruturas rígidas) vs dinâmicos (fluidos adaptáveis).",
                                "Língua Portuguesa: Estruturação de textos comparativos e tabelas argumentativas.",
                                "Ciências da Computação Geral: Otimização de algoritmos e trade-offs de design."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software enterprise, use tipagem estática (Java) para apps bancários onde erros de tipo em runtime são inaceitáveis; em data science, prefira dinâmica (Python) para scripts flexíveis de prototipagem rápida em machine learning com polimorfismo dinâmico."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.1",
                              "10.1.4.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.3.2",
                            "name": "Analisar impactos no uso de tipos de dados",
                            "description": "Discutir como tipagem afeta encapsulamento, herança e genéricos em POO, com exemplos de erros comuns e estratégias de mitigação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Tipagem Estática e Dinâmica em POO",
                                  "subSteps": [
                                    "Defina tipagem estática (ex: Java, tipos declarados no compile-time) e dinâmica (ex: Python, tipos verificados em runtime).",
                                    "Compare verificação de tipos: compile-time vs runtime, com exemplos simples de declaração de variáveis.",
                                    "Discuta vantagens/desvantagens iniciais: performance, flexibilidade e depuração em contextos POO."
                                  ],
                                  "verification": "Crie um diagrama comparativo de tipagem estática vs dinâmica e explique verbalmente as diferenças.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de Java/Python, editor de código (VS Code), quadro branco ou ferramenta de diagrama (Draw.io).",
                                  "tips": "Use tabelas para listar prós e contras para visualização rápida.",
                                  "learningObjective": "Compreender as diferenças fundamentais de tipagem e seu papel inicial em POO.",
                                  "commonMistakes": "Confundir tipagem forte/fraca com estática/dinâmica; ignorar exemplos concretos de linguagens."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Impacto da Tipagem no Encapsulamento",
                                  "subSteps": [
                                    "Explique encapsulamento em POO: hiding de dados via getters/setters e modificadores de acesso.",
                                    "Compare em tipagem estática: erros de tipo detectados cedo protegem integridade de dados encapsulados.",
                                    "Em tipagem dinâmica: riscos de runtime errors ao atribuir tipos incompatíveis pós-encapsulamento.",
                                    "Codifique exemplos: classe com campo privado em Java (estática) vs Python (dinâmica)."
                                  ],
                                  "verification": "Implemente uma classe encapsulada em ambas linguagens e teste atribuições inválidas, registrando erros.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "IDEs como IntelliJ para Java e PyCharm para Python, snippets de código de exemplo.",
                                  "tips": "Sempre compile/teste código para observar erros reais em tempo real.",
                                  "learningObjective": "Identificar como tipagem influencia a robustez do encapsulamento.",
                                  "commonMistakes": "Subestimar runtime errors em dinâmica; não testar cenários de violação de encapsulamento."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Impacto da Tipagem na Herança",
                                  "subSteps": [
                                    "Revise herança em POO: subclasses herdando de superclasses.",
                                    "Em estática: polimorfismo via interfaces/abstract classes garante tipos compatíveis em compile-time.",
                                    "Em dinâmica: herança flexível mas propensa a erros de tipo em chamadas polimórficas runtime.",
                                    "Exemplos: herança de Animal -> Dog em Java (estática) vs Python, com métodos sobrescritos."
                                  ],
                                  "verification": "Crie hierarquia de classes herdadas em ambas linguagens e demonstre polimorfismo com lista de objetos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Compiladores/IDEs, exemplos de código com herança polimórfica.",
                                  "tips": "Use 'duck typing' em Python como contraponto ao polimorfismo explícito em Java.",
                                  "learningObjective": "Avaliar como tipagem afeta segurança e flexibilidade na herança.",
                                  "commonMistakes": "Ignorar Liskov Substitution Principle em análises; confundir herança com composição."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Impacto da Tipagem em Genéricos",
                                  "subSteps": [
                                    "Defina genéricos: tipos parametrizados para reutilização (ex: List<T> em Java).",
                                    "Estática: type erasure/security em compile-time, evitando erros de tipo em collections.",
                                    "Dinâmica: simulação via duck typing ou Type Hints (Python 3.5+), mas sem verificação forte.",
                                    "Compare: GenericStack<String> em Java vs lista genérica em Python com erros potenciais."
                                  ],
                                  "verification": "Implemente estrutura genérica em ambas linguagens e insira tipos errados, analisando falhas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Referências de genéricos (Java Generics Tutorial, Python typing module docs).",
                                  "tips": "Foque em bounded types em Java vs Any em Python para contrastes claros.",
                                  "learningObjective": "Compreender limitações e benefícios de genéricos sob diferentes tipagens.",
                                  "commonMistakes": "Assumir genéricos idênticos cross-language; não abordar performance de type erasure."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Identificar Erros Comuns e Estratégias de Mitigação",
                                  "subSteps": [
                                    "Liste erros: type mismatches em runtime (dinâmica), cast failures (estática), generic misuse.",
                                    "Estratégias: static analysis tools (SonarQube), type hints (mypy em Python), unit tests.",
                                    "Crie tabela de erros x mitigação para encapsulamento/herança/genéricos.",
                                    "Teste cenários reais com código buggy e aplique fixes."
                                  ],
                                  "verification": "Documente 5 erros comuns com código reprodutível e soluções em relatório.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramentas de linting (mypy, Checkstyle), exemplos de código com bugs intencionais.",
                                  "tips": "Priorize testes automatizados para mitigar riscos em qualquer tipagem.",
                                  "learningObjective": "Desenvolver habilidades para prever e mitigar impactos negativos da tipagem.",
                                  "commonMistakes": "Focar só em uma linguagem; ignorar ferramentas modernas de análise estática."
                                }
                              ],
                              "practicalExample": "Em um sistema de gerenciamento de biblioteca: Crie uma classe Livro genérica em Java (estática) com herança para LivroFisico/LivroDigital, encapsulando ISBN como String. Em Python (dinâmica), tente atribuir int a ISBN em runtime, causando crash. Mitigue com type hints e mypy.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 impactos distintos da tipagem em encapsulamento/herança/genéricos.",
                                "Demonstrar código funcional com genéricos em linguagem estática e dinâmica.",
                                "Identificar e corrigir 2 erros comuns em um snippet fornecido.",
                                "Criar diagrama de fluxos de erro por tipagem.",
                                "Discutir trade-offs em um cenário de projeto real."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção de impactos por conceito POO (encapsulamento, herança, genéricos).",
                                "Uso de exemplos codificados concretos e reproduzíveis.",
                                "Profundidade na análise de erros comuns e estratégias práticas de mitigação.",
                                "Clareza em comparações estática vs dinâmica com evidências.",
                                "Criatividade em conexões com cenários reais de desenvolvimento."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica formal e teoria de tipos para modelar verificações.",
                                "Língua Portuguesa/Inglês: Terminologia técnica precisa em documentação de código.",
                                "Física/Engenharia: Analogias com sistemas robustos (ex: encapsulamento como isolamento térmico).",
                                "Ética: Discussão de segurança de software e impactos em dados sensíveis."
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps empresariais (ex: bancos usam Java estática para evitar erros em transações financeiras), mitigando riscos de runtime crashes que custam milhões; ou em scripts de data science (Python dinâmica) com type hints para equipes colaborativas."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.2",
                              "10.1.4.5.2.2"
                            ]
                          },
                          {
                            "id": "10.1.4.5.3.3",
                            "name": "Avaliar escolha em projetos POO",
                            "description": "Justificar seleção de tipagem estática ou dinâmica baseada em requisitos de performance, equipe e bibliotecas, referenciando UML e padrões de projeto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e analisar requisitos do projeto",
                                  "subSteps": [
                                    "Listar requisitos funcionais e não funcionais do projeto POO.",
                                    "Priorizar fatores como performance, tamanho da equipe e disponibilidade de bibliotecas.",
                                    "Mapear restrições técnicas e humanas (ex: experiência da equipe em linguagens específicas).",
                                    "Documentar trade-offs iniciais entre flexibilidade e rigidez.",
                                    "Criar uma matriz de requisitos com pesos para cada critério."
                                  ],
                                  "verification": "Verificar se a matriz de requisitos está completa, com pelo menos 5 itens priorizados e justificadas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação do projeto",
                                    "Planilha ou ferramenta como Excel/Google Sheets",
                                    "Referências sobre requisitos em POO"
                                  ],
                                  "tips": "Use MoSCoW (Must, Should, Could, Won't) para priorização rápida.",
                                  "learningObjective": "Compreender como requisitos guiam escolhas arquiteturais em POO.",
                                  "commonMistakes": [
                                    "Ignorar experiência da equipe",
                                    "Focar apenas em performance sem considerar custo de desenvolvimento",
                                    "Não documentar trade-offs"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Comparar tipagem estática versus dinâmica em contexto POO",
                                  "subSteps": [
                                    "Listar prós e contras da tipagem estática (ex: Java, C#): detecção precoce de erros, melhor performance.",
                                    "Listar prós e contras da tipagem dinâmica (ex: Python, JavaScript): flexibilidade, prototipagem rápida.",
                                    "Analisar impactos em POO: herança, polimorfismo e encapsulamento.",
                                    "Referenciar exemplos de projetos reais para cada tipo.",
                                    "Criar tabela comparativa com métricas qualitativas e quantitativas."
                                  ],
                                  "verification": "Conferir se a tabela comparativa cobre performance, manutenção e escalabilidade com exemplos POO.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação de linguagens (Java, Python)",
                                    "Artigos sobre tipagem em POO",
                                    "Ferramentas de comparação como tabelas Markdown"
                                  ],
                                  "tips": "Considere métricas como tempo de compilação vs runtime errors.",
                                  "learningObjective": "Diferenciar impactos de tipagem em princípios POO.",
                                  "commonMistakes": [
                                    "Confundir tipagem com paradigmas de programação",
                                    "Ignorar overhead de runtime em dinâmica",
                                    "Generalizar sem contexto de POO"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar impactos específicos nos critérios do projeto",
                                  "subSteps": [
                                    "Simular cenários de performance: benchmarks para estática vs dinâmica em operações POO.",
                                    "Avaliar fit com equipe: curva de aprendizado e produtividade.",
                                    "Verificar compatibilidade com bibliotecas: disponibilidade e integração em POO.",
                                    "Calcular scores ponderados baseados na matriz de requisitos.",
                                    "Identificar riscos e mitigações para cada escolha."
                                  ],
                                  "verification": "Validar scores com justificativas numéricas e pelo menos 3 riscos identificados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Benchmarks online (ex: TechEmpower)",
                                    "Lista de bibliotecas por linguagem",
                                    "Calculadora ou script simples"
                                  ],
                                  "tips": "Use dados reais de benchmarks para embasar, não intuição.",
                                  "learningObjective": "Quantificar trade-offs de tipagem em contextos reais.",
                                  "commonMistakes": [
                                    "Subestimar custos de treinamento da equipe",
                                    "Ignorar licenças de bibliotecas",
                                    "Focar só em performance isolada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar UML e padrões de projeto na decisão",
                                  "subSteps": [
                                    "Modelar classes em UML para ambas tipagens, destacando diferenças.",
                                    "Mapear padrões como Factory, Observer para estática vs dinâmica.",
                                    "Analisar como tipagem afeta implementação de padrões (ex: type safety em estática).",
                                    "Revisar diagrama UML com foco em interfaces e herança.",
                                    "Ajustar scores da avaliação anterior com insights de UML/padrões."
                                  ],
                                  "verification": "Inspecionar diagramas UML atualizados com anotações sobre tipagem.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramentas UML (Draw.io, Lucidchart)",
                                    "Livro GoF Padrões de Projeto",
                                    "Exemplos de código POO"
                                  ],
                                  "tips": "Comece com diagrama de classes simples e evolua para sequências.",
                                  "learningObjective": "Integrar modelagem UML e padrões na escolha de tipagem.",
                                  "commonMistakes": [
                                    "Não modelar polimorfismo adequadamente",
                                    "Aplicar padrões sem considerar tipagem",
                                    "Diagramas UML muito complexos no início"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Formular justificativa, documentar e validar escolha",
                                  "subSteps": [
                                    "Redigir relatório com escolha recomendada e razões baseadas em análise.",
                                    "Incluir evidências: matriz, tabela, UML e benchmarks.",
                                    "Simular revisão por pares: argumentos contra e refutações.",
                                    "Prototipar trecho POO mínimo para validar.",
                                    "Iterar com base em feedback simulado."
                                  ],
                                  "verification": "Relatório completo com protótipo funcional e auto-revisão.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Editor de texto/Markdown",
                                    "IDE para protótipo (IntelliJ, VSCode)",
                                    "Checklist de revisão"
                                  ],
                                  "tips": "Estruture relatório como: Introdução, Análise, Recomendação, Conclusão.",
                                  "learningObjective": "Comunicar decisões técnicas de forma persuasiva.",
                                  "commonMistakes": [
                                    "Justificativa vaga sem dados",
                                    "Não prototipar para validar",
                                    "Ignorar viés pessoal"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de sistema de gerenciamento de estoque POO, com equipe júnior e necessidade de alta performance: escolha tipagem estática (Java) por detecção de erros em compile-time, suporte a bibliotecas robustas como Spring, modelado em UML com diagrama de classes usando padrão Repository, justificando contra Python (dinâmica) por riscos de runtime errors em escala.",
                              "finalVerifications": [
                                "Consegue criar matriz de requisitos priorizada corretamente.",
                                "Lista prós/contras de tipagem com exemplos POO específicos.",
                                "Produz diagrama UML adaptado à escolha de tipagem.",
                                "Justifica decisão com dados de performance e bibliotecas.",
                                "Identifica pelo menos 3 riscos e mitigações.",
                                "Prototipa código POO funcional demonstrando a escolha."
                              ],
                              "assessmentCriteria": [
                                "Precisão na análise de requisitos (30%)",
                                "Profundidade da comparação estática/dinâmica (25%)",
                                "Integração correta de UML e padrões (20%)",
                                "Qualidade da justificativa e evidências (15%)",
                                "Prototipo funcional e verificações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Gerenciamento de Projetos: Análise de requisitos e trade-offs",
                                "Design de Software: UML e padrões de projeto",
                                "Desempenho e Otimização: Benchmarks e métricas",
                                "Trabalho em Equipe: Consideração de skills humanas",
                                "Engenharia de Software: Documentação e revisão de código"
                              ],
                              "realWorldApplication": "Em empresas como Google ou Nubank, arquitetos usam essa avaliação para escolher linguagens em projetos POO escaláveis, balanceando performance (estática para backend crítico) com agilidade (dinâmica para scripts), documentando em RFCs para equipes distribuídas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.3.4",
                            "name": "Aplicar em cenários práticos",
                            "description": "Resolver exercício comparando código C++ e Python para mesma classe POO, analisando compilação vs execução e impactos em exceções.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a estrutura da classe POO comum para comparação",
                                  "subSteps": [
                                    "Identifique atributos tipados (ex: int idade, string nome) e métodos (ex: void imprimir(), void setIdade(int novaIdade)).",
                                    "Desenhe um diagrama UML simples da classe para visualizar herança e composição.",
                                    "Liste cenários de erro potenciais: atribuição inválida de tipo, divisão por zero em métodos.",
                                    "Especifique exceções esperadas: em C++ (compile-time), Python (runtime).",
                                    "Documente diferenças iniciais de sintaxe entre C++ e Python."
                                  ],
                                  "verification": "Diagrama UML criado e lista de cenários documentada em um arquivo Markdown ou papel.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto (VS Code), papel/caneta para diagrama, documentação oficial C++ e Python.",
                                  "tips": "Use uma classe simples como 'ContaBancaria' para evitar complexidade inicial.",
                                  "learningObjective": "Compreender elementos comuns de POO independentemente da linguagem.",
                                  "commonMistakes": "Ignorar polimorfismo ou sobrecarga, focando apenas em atributos básicos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e testar compilação da classe em C++ (tipagem estática)",
                                  "subSteps": [
                                    "Escreva o código C++ com tipos explícitos e construtor.",
                                    "Compile com g++ e identifique erros de tipo no compile-time.",
                                    "Introduza erros intencionais (ex: atribuir string a int) e observe falhas de compilação.",
                                    "Corrija erros e execute o programa para verificar runtime.",
                                    "Registre logs de compilação e execução."
                                  ],
                                  "verification": "Código C++ compila sem erros e executa corretamente, com relatório de erros de compilação salvo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Compilador g++ (ou IDE como Code::Blocks), terminal.",
                                  "tips": "Use flags -Wall -Wextra para detectar mais warnings de tipo.",
                                  "learningObjective": "Experenciar detecção precoce de erros via tipagem estática.",
                                  "commonMistakes": "Esquecer includes (#include <string>) ou namespace std."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e testar execução da classe em Python (tipagem dinâmica)",
                                  "subSteps": [
                                    "Traduza o código C++ para Python usando classes e métodos.",
                                    "Execute o script Python e observe que compila sempre, mas falha em runtime com erros de tipo.",
                                    "Introduza os mesmos erros (ex: atribuir 'abc' a variável numérica) e capture exceções.",
                                    "Use try-except para gerenciar exceções e compare com C++.",
                                    "Registre traces de erro (TypeError, ValueError)."
                                  ],
                                  "verification": "Script Python executa parcialmente com exceções capturadas e logadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python 3.x, IDLE ou Jupyter Notebook.",
                                  "tips": "Use print(type(obj)) para inspecionar tipos dinamicamente.",
                                  "learningObjective": "Identificar atraso na detecção de erros até runtime.",
                                  "commonMistakes": "Confundir indentação ou esquecer self em métodos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar impactos em exceções e cenários práticos",
                                  "subSteps": [
                                    "Compare logs: C++ falha em compile vs Python em runtime.",
                                    "Teste exceções em métodos (ex: divisão por zero em getSaldo()).",
                                    "Discuta trade-offs: segurança estática vs flexibilidade dinâmica.",
                                    "Crie tabela comparativa de tempos de detecção e impactos em debugging.",
                                    "Proponha melhorias híbridas (type hints em Python)."
                                  ],
                                  "verification": "Tabela comparativa completa e discussão escrita (200+ palavras).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha (Google Sheets/Excel) para tabela, editor de texto.",
                                  "tips": "Execute testes múltiplos com inputs variados para robustez.",
                                  "learningObjective": "Avaliar impactos práticos da tipagem em POO e exceções.",
                                  "commonMistakes": "Generalizar demais sem evidências de testes reais."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar aprendizados e verificar domínio",
                                  "subSteps": [
                                    "Resuma diferenças chave em um relatório final.",
                                    "Refatore códigos para mitigar fraquezas (ex: assertions em Python).",
                                    "Crie um exercício similar para auto-teste.",
                                    "Compartilhe relatório em fórum ou GitHub para feedback.",
                                    "Avalie critérios de sucesso pessoalmente."
                                  ],
                                  "verification": "Relatório final submetido e auto-exercício resolvido.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "GitHub ou Google Docs para compartilhamento.",
                                  "tips": "Use versionamento Git para rastrear mudanças nos códigos.",
                                  "learningObjective": "Consolidar conhecimento comparativo para aplicações futuras.",
                                  "commonMistakes": "Pular refatoração, mantendo códigos originais com bugs."
                                }
                              ],
                              "practicalExample": "Crie uma classe 'ContaBancaria' com atributos saldo (float), titular (string) e métodos depositar(valor), sacar(valor). Em C++, erro de tipo em depositar('abc') falha na compilação; em Python, gera TypeError em runtime. Analise exceções como ZeroDivisionError em operações de saldo.",
                              "finalVerifications": [
                                "Códigos C++ e Python implementados e testados com pelo menos 5 cenários de erro.",
                                "Tabela comparativa de erros compile-time vs runtime completa.",
                                "Relatório discute impactos em exceções com exemplos de traces.",
                                "Refatorações aplicadas para melhorar robustez em ambas linguagens.",
                                "Auto-exercício resolvido corretamente sem consulta.",
                                "Feedback externo recebido e incorporado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de diferenças de tipagem (90%+ acurácia).",
                                "Qualidade dos testes: cobertura de 5+ cenários com logs detalhados.",
                                "Profundidade da análise: trade-offs discutidos com evidências.",
                                "Clareza do relatório: estrutura lógica, tabelas e diagramas.",
                                "Criatividade em refatorações e aplicações práticas.",
                                "Tempo de resolução dentro do estimado total (3 horas)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica de fluxos e algoritmos em métodos POO.",
                                "Física/Engenharia: Modelagem de sistemas reais (ex: contas bancárias como simulações).",
                                "Língua Portuguesa: Redação técnica de relatórios e documentação.",
                                "Ética: Discussão de segurança em software (erros runtime vs compile)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software empresarial, C++ é usado para sistemas críticos (ex: bancos) onde erros de tipo devem ser detectados cedo; Python para protótipos rápidos em data science, com type hints para mitigar exceções runtime, impactando debugging e manutenção em equipes multidisciplinares."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.3",
                              "10.1.4.5.2.3"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.4",
                        "name": "Ferramentas de Suporte Moderno",
                        "description": "Recursos como type hints em Python e inferência de tipos para mitigar limitações da tipagem dinâmica em contextos POO.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.4.1",
                            "name": "Explorar type hints em Python",
                            "description": "Implementar anotações de tipo em classes Python para simular verificação estática, usando mypy para linting.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Type Hints em Python",
                                  "subSteps": [
                                    "Leia a documentação oficial do módulo typing no Python (https://docs.python.org/3/library/typing.html).",
                                    "Estude exemplos básicos de anotações de tipo para variáveis, funções e retornos.",
                                    "Identifique os benefícios: suporte a IDEs, detecção precoce de erros e melhor legibilidade de código.",
                                    "Compare tipagem dinâmica (Python nativo) com simulação estática via type hints.",
                                    "Anote diferenças chave em um documento pessoal."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando type hints e seus benefícios, sem erros conceituais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Documentação Python typing, editor de texto ou notebook Jupyter.",
                                  "tips": "Use o módulo typing para tipos complexos como List, Dict; comece com built-ins como str, int.",
                                  "learningObjective": "Entender o propósito e sintaxe básica de type hints para preparar aplicação em código.",
                                  "commonMistakes": "Confundir type hints (checagem em tempo de compilação via mypy) com verificação em runtime (ex: isinstance)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Type Hints em Funções e Variáveis Simples",
                                  "subSteps": [
                                    "Crie um script Python com funções anotadas: def soma(a: int, b: int) -> int.",
                                    "Anotar variáveis locais: nome: str = 'Exemplo'.",
                                    "Use tipos do typing: from typing import List; def processar_lista(nums: List[int]) -> List[float].",
                                    "Teste execução do código sem mypy para confirmar compatibilidade runtime.",
                                    "Adicione docstrings explicando as anotações."
                                  ],
                                  "verification": "O código executa sem erros de sintaxe e todas as funções/variáveis têm anotações corretas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python 3.8+, editor de código (VS Code ou PyCharm com suporte a typing).",
                                  "tips": "Instale extensões de IDE para autocomplete de tipos; evite Optional desnecessário inicialmente.",
                                  "learningObjective": "Dominar sintaxe básica de anotações para funções e variáveis primitivas/complexas.",
                                  "commonMistakes": "Esquecer de importar typing para tipos genéricos; usar tipos incorretos como str para int."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Type Hints em Classes Python",
                                  "subSteps": [
                                    "Defina uma classe simples: class Pessoa: def __init__(self, nome: str, idade: int) -> None.",
                                    "Anotar atributos de instância com self.nome: str.",
                                    "Anotar métodos: def envelhecer(self, anos: int) -> None.",
                                    "Use typing para tipos avançados: from typing import ClassVar, Final.",
                                    "Crie instâncias e chame métodos para testar funcionalidade."
                                  ],
                                  "verification": "Classe instanciada corretamente com métodos funcionando e todas as anotações presentes.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python instalado, arquivo .py para a classe.",
                                  "tips": "Use __annotations__ para inspecionar anotações em runtime; priorize __init__ e métodos principais.",
                                  "learningObjective": "Implementar type hints completos em classes, incluindo init e métodos de instância.",
                                  "commonMistakes": "Não anotar self ou retornos de métodos; confundir tipos de classe vs instância."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar e Usar Mypy para Verificação Estática",
                                  "subSteps": [
                                    "Instale mypy: pip install mypy.",
                                    "Crie um arquivo pyproject.toml ou mypy.ini com configurações básicas.",
                                    "Execute mypy no seu código: mypy seu_arquivo.py --strict.",
                                    "Identifique e corrija erros reportados (ex: tipos incompatíveis).",
                                    "Adicione --disallow-untyped-defs para forçar anotações completas e reexecute."
                                  ],
                                  "verification": "Mypy passa sem erros ou warnings no código da classe com type hints.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "pip, terminal, código dos steps anteriores.",
                                  "tips": "Use mypy --help para opções; integre com pre-commit hooks para automação.",
                                  "learningObjective": "Usar mypy para linting estático, simulando verificação de tipos em compilação.",
                                  "commonMistakes": "Ignorar erros de third-party libs (use stubs); não usar --strict inicialmente."
                                }
                              ],
                              "practicalExample": "Crie uma classe ContaBancaria com atributos saldo: float, titular: str. Métodos: depositar(valor: float) -> None e sacar(valor: float) -> bool. Rode mypy antes/depois de anotações para ver erros como 'Argument 1 to \"sacar\" has incompatible type \"str\"; expected \"float\"'. Corrija e confirme 'Success: no issues found'.",
                              "finalVerifications": [
                                "Todas funções, variáveis e métodos na classe têm type hints precisos.",
                                "Mypy executa sem erros em modo strict.",
                                "Código mantém funcionalidade runtime idêntica.",
                                "IDE mostra autocomplete e hover tips baseados em tipos.",
                                "Documentação inline via docstrings menciona tipos.",
                                "Testes unitários passam com anotações adicionadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude das anotações (100% cobertos).",
                                "Correção de todos erros mypy identificados.",
                                "Explicação clara de pelo menos 3 benefícios observados.",
                                "Código refatorado é mais legível e mantém performance.",
                                "Uso correto de typing para genéricos e unions.",
                                "Integração seamless com IDE para sugestões de tipo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Entender conjuntos e tipos como teoria de conjuntos.",
                                "Lógica e Algoritmos: Detecção precoce de erros lógicos via tipos.",
                                "Inglês Técnico: Leitura e interpretação de documentação oficial.",
                                "Design de Software: Princípios de clean code e maintainability."
                              ],
                              "realWorldApplication": "Em equipes de desenvolvimento profissionais, type hints com mypy reduzem tempo de debugging em 20-30%, melhoram colaboração via IDEs compartilhadas e facilitam refatorações em projetos grandes como Django ou FastAPI apps."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.2.3"
                            ]
                          },
                          {
                            "id": "10.1.4.5.4.2",
                            "name": "Discutir inferência de tipos",
                            "description": "Explicar como linguagens estáticas usam inferência para reduzir declarações explícitas, comparando com generics em Java.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito fundamental de inferência de tipos",
                                  "subSteps": [
                                    "Defina inferência de tipos como o processo pelo qual o compilador ou interpretador deduz automaticamente o tipo de uma variável ou expressão com base no contexto do código.",
                                    "Diferencie inferência de tipagem explícita, onde o desenvolvedor declara o tipo manualmente (ex: int x = 5;).",
                                    "Identifique linguagens estáticas com suporte forte: Kotlin, TypeScript, Swift e C#.",
                                    "Explique como a inferência mantém a segurança de tipos estáticos sem boilerplate excessivo.",
                                    "Discuta o papel da inferência em reduzir declarações verbosas em código moderno."
                                  ],
                                  "verification": "Escreva uma definição precisa em suas próprias palavras e liste 3 linguagens com exemplos breves.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação oficial de Kotlin ou TypeScript",
                                    "Editor de código como IntelliJ ou VS Code"
                                  ],
                                  "tips": "Visualize o compilador como um 'detetive' que analisa o valor inicial e o uso da variável para deduzir o tipo.",
                                  "learningObjective": "Compreender a definição e distinção entre inferência de tipos e declaração explícita em linguagens estáticas.",
                                  "commonMistakes": "Confundir inferência com tipagem dinâmica, onde tipos são resolvidos em runtime."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar exemplos práticos de inferência em linguagens estáticas",
                                  "subSteps": [
                                    "Analise em Kotlin: 'val numero = 42' (infere Int) vs. 'val numero: Int = 42'.",
                                    "Examine em TypeScript: 'let mensagem = \"Olá\"' (infere string) e como o IDE sugere tipos.",
                                    "Teste em Swift: 'let preco = 19.99' (infere Double) e observe erros se usar como Int.",
                                    "Compare com declaração explícita nessas linguagens para medir redução de código.",
                                    "Compile e execute snippets simples para ver inferência em ação."
                                  ],
                                  "verification": "Crie e execute 3 snippets de código com inferência, confirmando tipos deduzidos no IDE ou output.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Playground online de Kotlin (kotlinlang.org)",
                                    "TypeScript Playground",
                                    "Editor com suporte a linting"
                                  ],
                                  "tips": "Sempre inicialize variáveis com valores concretos para facilitar a inferência pelo compilador.",
                                  "learningObjective": "Aplicar inferência de tipos em exemplos reais de linguagens estáticas e observar sua funcionalidade.",
                                  "commonMistakes": "Ignorar ambiguidades que impedem inferência, como funções genéricas sem contexto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar inferência de tipos com generics em Java",
                                  "subSteps": [
                                    "Revise generics em Java: 'List<String> lista = new ArrayList<String>();' (pré-Java 7) vs. diamond operator 'new ArrayList<>()'.",
                                    "Compare limitações: Java ainda requer tipos explícitos na declaração da variável, sem inferência local como 'val'.",
                                    "Analise Java 10+: 'var lista = new ArrayList<String>();' (inferência limitada a variáveis locais).",
                                    "Discuta trade-offs: Java generics focam em parametrização de classes, enquanto inferência reduz verbosidade em vars simples.",
                                    "Escreva código paralelo em Java e Kotlin para destacar diferenças."
                                  ],
                                  "verification": "Produza um side-by-side de código Java vs. Kotlin, explicando onde a inferência reduz declarações.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "JDK 17+ instalado",
                                    "Exemplos de código Java generics",
                                    "Kotlin Koans online"
                                  ],
                                  "tips": "Use 'javap' ou IDE para inspecionar tipos inferidos em Java moderno e valide a comparação.",
                                  "learningObjective": "Comparar mecanismos de inferência em linguagens modernas com as limitações dos generics em Java.",
                                  "commonMistakes": "Superestimar inferência em Java antigos, ignorando que ela é parcial e não equivalente a Kotlin/Swift."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir benefícios, limitações e implicações práticas",
                                  "subSteps": [
                                    "Liste benefícios: Menos código boilerplate, melhor legibilidade, manutenção de segurança estática.",
                                    "Aborde limitações: Pode obscurecer tipos em código complexo; depende de contexto claro.",
                                    "Compare impacto: Em projetos grandes, inferência acelera desenvolvimento vs. Java tradicional.",
                                    "Debata cenários ideais: Use inferência para vars locais, mas tipos explícitos para APIs públicas.",
                                    "Reflita sobre evolução: Como inferência pavimenta caminho para linguagens mais expressivas."
                                  ],
                                  "verification": "Redija um parágrafo resumindo prós/contras e uma recomendação para uso em projetos OOO.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigos sobre 'Type Inference in Modern Languages'",
                                    "Fórum Stack Overflow sobre Java var"
                                  ],
                                  "tips": "Pergunte: 'O tipo inferido é óbvio para outro dev?' para guiar decisões.",
                                  "learningObjective": "Avaliar vantagens da inferência sobre generics Java e formular opiniões fundamentadas.",
                                  "commonMistakes": "Ignorar legibilidade: inferência excessiva pode tornar código 'mágico' e difícil de debugar."
                                }
                              ],
                              "practicalExample": "Em um app de gerenciamento de estoque: Java - 'private List<Produto> produtos = new ArrayList<>();'. Kotlin - 'val produtos = mutableListOf(Produto(\"Item1\", 10.0))' (infere MutableList<Produto>), reduzindo declarações explícitas e melhorando fluidez.",
                              "finalVerifications": [
                                "Explica inferência de tipos sem usar declaração explícita em exemplos?",
                                "Identifica corretamente linguagens estáticas com inferência forte?",
                                "Compara precisamente generics Java com inferência em Kotlin/TypeScript?",
                                "Lista pelo menos 3 benefícios e 2 limitações?",
                                "Produz código funcional demonstrando inferência?",
                                "Discute implicações em contextos reais de programação OOO?"
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Definição e distinções corretas (30%)",
                                "Exemplos práticos: Código compilável e comparativo (25%)",
                                "Análise comparativa: Diferenças claras com Java generics (20%)",
                                "Profundidade de discussão: Benefícios, limitações e implicações (15%)",
                                "Clareza e estrutura: Resposta organizada e legível (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Inferência lógica e dedução de tipos semelhantes a provas formais.",
                                "Linguística: Análise sintática e semântica em processamento de linguagem natural.",
                                "Filosofia da Computação: Debate sobre expressividade vs. explicitidade em linguagens formais.",
                                "Design de Software: Princípios de legibilidade e DRY (Don't Repeat Yourself)."
                              ],
                              "realWorldApplication": "Em desenvolvimento Android com Kotlin, inferência reduz código em listas de dados (ex: RecyclerView adapters), acelerando iterações em equipes grandes, contrastando com Java onde generics verbosos aumentam erros de tipagem em refatorações."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.3"
                            ]
                          },
                          {
                            "id": "10.1.4.5.4.3",
                            "name": "Integrar com UML e padrões",
                            "description": "Modelar classes em UML destacando tipos, e aplicar padrões como Factory considerando tipagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Representação de Classes e Tipos em UML",
                                  "subSteps": [
                                    "Estude os elementos básicos de diagramas de classes UML: classes, atributos, métodos e relacionamentos.",
                                    "Aprenda a anotar tipos de dados em atributos e parâmetros de métodos (ex: String, int, List<Integer>).",
                                    "Pratique diferenciando tipagem estática (ex: Java) vs dinâmica (ex: Python) na notação UML.",
                                    "Crie um diagrama simples com 2-3 classes destacando tipos explícitos.",
                                    "Use multiplicidades e visibilidades para reforçar contratos tipados."
                                  ],
                                  "verification": "Gerar um diagrama UML válido com tipos anotados corretamente em pelo menos 3 classes, sem erros de sintaxe UML.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Ferramenta UML (PlantUML, Lucidchart ou Draw.io), documentação UML 2.5 oficial.",
                                  "tips": "Sempre use <<interface>> para tipos abstratos e generalize com setas para herança tipada.",
                                  "learningObjective": "Dominar a notação UML para representar tipagem estática em classes e interfaces.",
                                  "commonMistakes": "Esquecer de especificar tipos em atributos (ex: usar 'name' em vez de 'name: String'); ignorar visibilidade (+ para public)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o Padrão Factory com Ênfase em Tipagem",
                                  "subSteps": [
                                    "Leia sobre Factory Method e Abstract Factory, focando em como criam instâncias tipadas sem expor construtores.",
                                    "Analise exemplos em linguagens tipadas estáticas (Java, C#) vs dinâmicas (JavaScript).",
                                    "Identifique papéis: Creator, Product (interface tipada), ConcreteProduct.",
                                    "Desenhe fluxogramas mostrando resolução de tipos em runtime vs compile-time.",
                                    "Compare com new() direto, destacando encapsulamento de tipagem."
                                  ],
                                  "verification": "Resumir em um mapa mental os componentes do Factory e seu impacto na tipagem, com 5 pontos chave.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro 'Design Patterns' (Gang of Four), exemplos de código em GitHub (Java Factory pattern).",
                                  "tips": "Pense em Factory como um 'switch tipado' para polimorfismo sem if-else poluídos.",
                                  "learningObjective": "Compreender como Factory preserva contratos tipados em criação de objetos.",
                                  "commonMistakes": "Confundir Factory com Singleton; ignorar que Factory retorna interfaces tipadas, não concretas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar um Sistema em UML Integrando Factory e Tipos",
                                  "subSteps": [
                                    "Escolha um domínio simples (ex: sistema de veículos: Car, Truck extends Vehicle).",
                                    "Desenhe classes com tipos anotados (ex: engine: EngineType).",
                                    "Adicione Factory: VehicleFactory com método createVehicle(type: VehicleType): Vehicle.",
                                    "Inclua relacionamentos: Factory -> Product (composição), herança tipada.",
                                    "Valide o diagrama com estereótipos UML para padrões (<<Factory>>)."
                                  ],
                                  "verification": "Produzir um diagrama UML completo com Factory integrado, exportado como imagem ou código PlantUML.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "PlantUML online editor, exemplos de UML com padrões de sites como UML-Diagrams.org.",
                                  "tips": "Use enums para VehicleType para reforçar tipagem estática no UML.",
                                  "learningObjective": "Projetar diagramas UML que incorporem padrões Factory com tipagem explícita.",
                                  "commonMistakes": "Não conectar Factory corretamente à hierarquia de Products; omitir retornos tipados nos métodos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Validar a Integração em Código",
                                  "subSteps": [
                                    "Implemente o diagrama UML em Java (tipagem estática), usando interface Vehicle e Factory.",
                                    "Teste criação de instâncias tipadas via Factory.",
                                    "Compare com versão dinâmica em Python para contrastar.",
                                    "Refatore se houver violações de tipagem (ex: casting desnecessário).",
                                    "Documente o código com comentários ligando ao UML."
                                  ],
                                  "verification": "Código compilável e testes passando, com 80% cobertura de Factory scenarios.",
                                  "estimatedTime": "3 horas",
                                  "materials": "IDE (IntelliJ ou VS Code), JUnit para testes, repositório Git para versionamento.",
                                  "tips": "Sempre retorne a interface mais genérica do Factory para polimorfismo.",
                                  "learningObjective": "Aplicar o modelo UML-Factory em código real, validando benefícios da tipagem.",
                                  "commonMistakes": "Expor construtores concretos; não tratar exceções de tipo inválido no Factory."
                                }
                              ],
                              "practicalExample": "Em um sistema de e-commerce, modele 'PaymentProcessor' como interface tipada. Crie PaymentFactory com createProcessor(type: PaymentType): PaymentProcessor. UML mostra Factory com switch para CreditCardProcessor ou PayPalProcessor, preservando tipagem estática em Java: factory.createProcessor(PaymentType.CREDIT).process(amount: BigDecimal).",
                              "finalVerifications": [
                                "Diagrama UML gerado com todos os tipos anotados e Factory corretamente representado.",
                                "Código implementado compila sem warnings de tipagem e passa em testes unitários.",
                                "Documentação liga UML ao código, explicando resolução de tipos.",
                                "Exemplo prático executa criando 3 instâncias diferentes via Factory.",
                                "Análise escrita compara tipagem estática vs dinâmica no padrão.",
                                "Nenhum erro comum identificado nos steps foi cometido."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação UML para tipos e relacionamentos (0-25%).",
                                "Correta aplicação do padrão Factory com interfaces tipadas (0-25%).",
                                "Qualidade e detalhe dos subSteps em cada step (0-20%).",
                                "Funcionalidade e testes do código implementado (0-20%).",
                                "Conexão clara entre modelagem, padrões e tipagem (0-10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de tipos como conjuntos tipados e funções polimórficas.",
                                "Design Gráfico: Visualização de diagramas UML como blueprints arquitetônicos.",
                                "Lógica e Filosofia: Abstração e encapsulamento como princípios ontológicos.",
                                "Negócios: Padrões reutilizáveis para escalabilidade em software enterprise."
                              ],
                              "realWorldApplication": "Em frameworks como Spring (Java), Factories injetam beans tipados via @Bean factories, permitindo DI sem expor implementações concretas; usado em apps bancários para processadores de pagamento seguros e tipados."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.6",
                    "name": "Sobrecarga de Operadores",
                    "description": "Mecanismo para redefinir operadores em classes, permitindo polimorfismo em operações.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.6.1",
                        "name": "Definição e Propósito da Sobrecarga de Operadores",
                        "description": "Compreensão do mecanismo que permite redefinir o comportamento de operadores (+, -, *, etc.) em classes personalizadas, promovendo polimorfismo ad-hoc e facilitando a criação de tipos de dados intuitivos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.6.1.1",
                            "name": "Definir sobrecarga de operadores",
                            "description": "Explicar o que é sobrecarga de operadores, diferenciando-a de sobrescrita de métodos, e descrever como ela permite que instâncias de classes se comportem como tipos primitivos em expressões.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender operadores e métodos em Programação Orientada a Objetos",
                                  "subSteps": [
                                    "Revise o que são operadores aritméticos, relacionais e lógicos em linguagens como C++ ou Python.",
                                    "Identifique exemplos de operadores em tipos primitivos (ex: +, -, *, /).",
                                    "Explique o conceito de métodos em classes e sobrescrita (override) de métodos virtuais.",
                                    "Compare como objetos são tratados em expressões sem sobrecarga.",
                                    "Liste limitações de usar métodos em vez de operadores para operações em objetos."
                                  ],
                                  "verification": "Liste 5 operadores comuns e explique um exemplo de sobrescrita de método em uma hierarquia de classes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial de C++ (cppreference.com)",
                                    "Editor de código como Visual Studio Code",
                                    "Exemplos de código OOP básico"
                                  ],
                                  "tips": [
                                    "Comece com tipos primitivos para fixar conceitos antes de OOP.",
                                    "Use diagramas para visualizar hierarquias de classes."
                                  ],
                                  "learningObjective": "Entender os fundamentos de operadores e métodos como base para sobrecarga.",
                                  "commonMistakes": [
                                    "Confundir operadores com funções imediatamente.",
                                    "Ignorar que sobrescrita é para polimorfismo em herança."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o conceito de sobrecarga de operadores",
                                  "subSteps": [
                                    "Defina sobrecarga de operadores: mecanismo para redefinir o comportamento de operadores em classes user-defined.",
                                    "Explique que é uma forma de polimorfismo ad-hoc.",
                                    "Identifique sintaxe básica: operator+() como membro ou friend function.",
                                    "Discuta operadores que podem ser sobrecarregados (ex: +, -, [], () ) e os que não podem (ex: ::, . ).",
                                    "Analise um pseudocódigo simples de sobrecarga."
                                  ],
                                  "verification": "Escreva a definição de sobrecarga de operadores e cite 3 operadores sobrecarregáveis.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Referência de sobrecarga em C++ (GeeksforGeeks ou livros como 'C++ Primer')",
                                    "Compilador online como Compiler Explorer"
                                  ],
                                  "tips": [
                                    "Lembre-se: é redefinição, não criação nova.",
                                    "Teste sintaxe em um compilador para validar."
                                  ],
                                  "learningObjective": "Dominar a definição e sintaxe inicial de sobrecarga de operadores.",
                                  "commonMistakes": [
                                    "Pensar que todos os operadores podem ser sobrecarregados.",
                                    "Confundir com templates."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar sobrecarga de operadores de sobrescrita de métodos",
                                  "subSteps": [
                                    "Compare: sobrescrita (override) altera implementação em subclasses para polimorfismo via herança.",
                                    "Sobrecarga de operadores: define novo comportamento para o mesmo operador em classes, sem herança obrigatória.",
                                    "Crie uma tabela comparativa: propósito, sintaxe, contexto de uso.",
                                    "Exemplo: override de método virtual vs. operator= em uma classe.",
                                    "Discuta quando usar cada um: usabilidade vs. extensibilidade."
                                  ],
                                  "verification": "Explique com exemplos a diferença entre os dois conceitos em um parágrafo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Artigos comparativos sobre overload vs override",
                                    "Quadro branco ou ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": [
                                    "Use mnemônicos: 'sobrecarga = mais opções para mesmo operador; sobrescrita = mesma assinatura, nova impl.'"
                                  ],
                                  "learningObjective": "Distinguir claramente os dois conceitos para evitar confusões comuns.",
                                  "commonMistakes": [
                                    "Achar que ambos são a mesma coisa.",
                                    "Aplicar override a operadores não virtuais."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar o propósito: comportamento como tipos primitivos",
                                  "subSteps": [
                                    "Descreva como sobrecarga permite expressões naturais: obj1 + obj2 em vez de obj1.add(obj2).",
                                    "Analise benefícios: legibilidade, integração com código existente, simulação de primitivos.",
                                    "Discuta riscos: ambiguidade, perda de clareza se abusada.",
                                    "Implemente um exemplo mínimo e teste em expressões mistas (obj + int).",
                                    "Reflita sobre padrões de design que usam isso (ex: iterators)."
                                  ],
                                  "verification": "Escreva uma expressão usando objetos que se comporta como primitivos e justifique.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exemplos de código de bibliotecas STL",
                                    "Ambiente de desenvolvimento com debugger"
                                  ],
                                  "tips": [
                                    "Priorize operadores binários comuns primeiro.",
                                    "Sempre teste com tipos mistos."
                                  ],
                                  "learningObjective": "Compreender como a sobrecarga melhora a usabilidade de classes.",
                                  "commonMistakes": [
                                    "Sobrecarregar operadores desnecessariamente, violando princípio de least surprise."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe Complexo para números complexos. Sobrecarregue o operador +: Complexo operator+(const Complexo& outro) const { return Complexo(real + outro.real, imag + outro.imag); }. Uso: Complexo c1(1,2), c2(3,4); auto c3 = c1 + c2; // Resulta em (4,6), comportando-se como tipos primitivos.",
                              "finalVerifications": [
                                "Defina sobrecarga de operadores em suas próprias palavras.",
                                "Diferencie-a de sobrescrita de métodos com um exemplo.",
                                "Explique por que permite que objetos se comportem como primitivos.",
                                "Identifique 3 operadores sobrecarregáveis e 1 não.",
                                "Crie uma expressão válida usando sobrecarga.",
                                "Liste 2 benefícios e 1 risco."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e diferenciação conceitual (30%).",
                                "Correta identificação de sintaxe e limitações (25%).",
                                "Explicação clara do propósito e usabilidade (20%).",
                                "Exemplo prático funcional sem erros (15%).",
                                "Análise de riscos e melhores práticas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operadores aritméticos em álgebra (ex: vetores, matrizes).",
                                "Design de Software: Padrões como Iterator e princípios de usabilidade.",
                                "Lógica Computacional: Polimorfismo ad-hoc e expressões bem-formadas.",
                                "Física/Engenharia: Simulação de grandezas vetoriais com overload (+, *)."
                              ],
                              "realWorldApplication": "Em engines de jogos como Unity (C#), sobrecarga de operadores em Vector3 permite expressões naturais como position += velocity * deltaTime, facilitando simulações físicas intuitivas e código legível em equipes grandes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.6.1.2",
                            "name": "Identificar cenários de uso",
                            "description": "Reconhecer situações onde a sobrecarga melhora a legibilidade do código, como em classes representando vetores, matrizes ou números complexos, relacionando com princípios de polimorfismo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de sobrecarga de operadores e legibilidade",
                                  "subSteps": [
                                    "Ler a definição de sobrecarga de operadores: permitir que operadores como +, -, * sejam redefinidos para classes personalizadas.",
                                    "Entender legibilidade: código que usa operadores intuitivos é mais fácil de ler do que chamadas de métodos explícitas.",
                                    "Comparar código sem sobrecarga (ex: vector1.add(vector2)) vs. com sobrecarga (vector1 + vector2).",
                                    "Identificar o propósito principal: tornar código de domínios matemáticos mais natural.",
                                    "Anotar 3 benefícios para legibilidade em um caderno."
                                  ],
                                  "verification": "Resumir em 2-3 frases os conceitos chave e benefícios, conferindo com documentação oficial.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de OOO sobre operadores (C++ ou Python)",
                                    "Caderno ou editor de texto"
                                  ],
                                  "tips": "Use exemplos simples de tipos built-in como int + int para analogia.",
                                  "learningObjective": "Compreender como a sobrecarga transforma código verboso em expressões naturais.",
                                  "commonMistakes": [
                                    "Confundir sobrecarga com sobrescrita de métodos.",
                                    "Ignorar que nem todos os operadores devem ser sobrecarregados."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar cenários comuns onde sobrecarga melhora legibilidade",
                                  "subSteps": [
                                    "Listar classes matemáticas: vetores, matrizes, números complexos, frações.",
                                    "Para cada uma, imaginar operações: soma de vetores (v1 + v2), multiplicação de matrizes (m1 * m2).",
                                    "Analisar por que método explícito seria menos legível: mais verboso e menos intuitivo.",
                                    "Pesquisar bibliotecas reais: Eigen (C++) para vetores, NumPy (Python) para arrays.",
                                    "Criar uma tabela comparativa de 3 cenários com 'sem' vs. 'com' sobrecarga."
                                  ],
                                  "verification": "Tabela completa com pelo menos 3 cenários, justificando legibilidade em cada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Bibliotecas de exemplo: Eigen docs, NumPy tutorial",
                                    "Planilha ou papel para tabela"
                                  ],
                                  "tips": "Pense em expressões matemáticas do dia a dia: sempre priorize notação infix.",
                                  "learningObjective": "Reconhecer padrões onde operadores matemáticos se aplicam naturalmente a classes.",
                                  "commonMistakes": [
                                    "Aplicar sobrecarga a classes não-matemáticas como String para concatenação (já built-in).",
                                    "Sobrecarregar operadores lógicos em contextos numéricos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar exemplos específicos e contra-exemplos",
                                  "subSteps": [
                                    "Implementar ou pseudocódigo para classe Vetor: sobrecarregar + para soma componente a componente.",
                                    "Fazer o mesmo para Matriz (* para multiplicação) e Complexo (+ para soma real/imaginária).",
                                    "Testar legibilidade: escrever expressões como c = a + b vs. c.sum(a, b).",
                                    "Identificar contra-exemplo: classe Pessoa, onde + não faz sentido (evitar antropomorfismo).",
                                    "Discutir em fórum ou auto-refletir: quando NÃO usar."
                                  ],
                                  "verification": "Código ou pseudocódigo funcional para 2 exemplos + 1 contra-exemplo justificado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, Replit)",
                                    "Compilador C++ ou interpretador Python"
                                  ],
                                  "tips": "Comece com 2D para vetores para simplicidade; valide outputs manualmente.",
                                  "learningObjective": "Diferenciar cenários apropriados de inadequados via exemplos práticos.",
                                  "commonMistakes": [
                                    "Sobrecarregar = para deep copy sem cuidado com memória.",
                                    "Ignorar precedência de operadores em expressões compostas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar com princípios de polimorfismo e praticar identificação",
                                  "subSteps": [
                                    "Explicar polimorfismo: operadores sobrecarregados permitem tratar objetos como built-ins.",
                                    "Comparar: polimorfismo via herança vs. via operadores (mais seamless).",
                                    "Praticar: dado um snippet de código, identificar se sobrecarga melhora legibilidade.",
                                    "Criar quiz pessoal: 5 cenários (3 sim, 2 não), auto-corrigir.",
                                    "Refletir: como isso se conecta ao SOLID (Interface Segregation, etc.)."
                                  ],
                                  "verification": "Quiz resolvido com 80% acerto + parágrafo relacionando a polimorfismo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Snippets de código de exemplos online",
                                    "Quiz auto-gerado em papel"
                                  ],
                                  "tips": "Use polimorfismo ad-hoc: operadores como funções polimórficas.",
                                  "learningObjective": "Integrar sobrecarga ao ecossistema OOO, enfatizando polimorfismo.",
                                  "commonMistakes": [
                                    "Confundir polimorfismo runtime com sobrecarga estática.",
                                    "Aplicar polimorfismo sem necessidade de legibilidade."
                                  ]
                                }
                              ],
                              "practicalExample": "Em C++, classe Vetor2D com operador+ sobrecarregado: Vetor2D operator+(const Vetor2D& other) { return {x + other.x, y + other.y}; }. Uso: auto resultado = v1 + v2; // Legível como matemática, ao invés de v1.soma(v2).",
                              "finalVerifications": [
                                "Listar 4 cenários apropriados (vetores, matrizes, complexos, quaternions).",
                                "Explicar por que sobrecarga melhora legibilidade em 2 exemplos.",
                                "Identificar 2 cenários inadequados e justificar.",
                                "Relacionar corretamente a polimorfismo em uma frase.",
                                "Analisar um snippet real e propor sobrecarga se aplicável."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de cenários matemáticos (peso 30%).",
                                "Justificativa clara de legibilidade vs. verbosidade (25%).",
                                "Correta distinção de contra-exemplos (20%).",
                                "Integração com polimorfismo (15%).",
                                "Exemplos práticos viáveis e testáveis (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (vetores/matrizes).",
                                "Física: Números complexos em ondas/elétrica.",
                                "Engenharia de Software: Design patterns (Operator Overloading).",
                                "Lógica: Princípios de abstração em computação teórica."
                              ],
                              "realWorldApplication": "Bibliotecas como NumPy (Python) ou GLM (C++ para games) usam sobrecarga para vetores/matrizes, permitindo código como 'pos += velocity * dt' em engines de jogos, simuladores físicos ou ML, tornando simulações científicas intuitivas e eficientes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.6.1.3",
                            "name": "Diferenciar de outras formas de polimorfismo",
                            "description": "Comparar sobrecarga de operadores com polimorfismo de subtipo e paramétrico, destacando seu papel em operações binárias e unárias para abstração de dados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Polimorfismo",
                                  "subSteps": [
                                    "Defina polimorfismo como a capacidade de um operador ou função se comportar de diferentes formas dependendo do contexto.",
                                    "Classifique os tipos principais: ad-hoc (sobrecarga), subtipo (herança) e paramétrico (templates/generics).",
                                    "Identifique exemplos iniciais de cada tipo em linguagens como C++ ou Java.",
                                    "Anote as motivações gerais do polimorfismo: flexibilidade e abstração.",
                                    "Crie um diagrama mental conectando os três tipos."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras definindo e classificando os tipos de polimorfismo sem erros conceituais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação de C++ (cppreference.com), caderno para anotações, editor de texto.",
                                  "tips": "Use analogias cotidianas, como 'um botão de play que funciona em diferentes mídias'.",
                                  "learningObjective": "Compreender a definição ampla e classificação de polimorfismo para contextualizar diferenças.",
                                  "commonMistakes": "Confundir polimorfismo com herança em geral, ignorando que herança é meio para subtipo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Sobrecarga de Operadores em Detalhe",
                                  "subSteps": [
                                    "Explique sobrecarga de operadores como polimorfismo ad-hoc para operadores específicos (+, -, etc.).",
                                    "Diferencie operações unárias (ex: -x) e binárias (ex: x + y), destacando abstração de dados.",
                                    "Implemente exemplos simples em C++: overload de + para uma classe Vetor.",
                                    "Compile e teste o código para observar o comportamento.",
                                    "Registre como isso permite sintaxe natural sem funções nomeadas."
                                  ],
                                  "verification": "Compile e execute um programa com overload de operador binário e unário, confirmando resultados corretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Compilador C++ (g++ ou IDE como Visual Studio Code), exemplos de código de referência.",
                                  "tips": "Comece com operadores simples como == antes de aritméticos para evitar erros de precedência.",
                                  "learningObjective": "Dominar sobrecarga de operadores como forma ad-hoc, enfatizando seu papel em abstrações.",
                                  "commonMistakes": "Sobrecarregar operadores de forma não intuitiva, violando expectativas do usuário."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Polimorfismo de Subtipo",
                                  "subSteps": [
                                    "Defina polimorfismo de subtipo via herança e overriding de métodos virtuais.",
                                    "Compare com overload: subtipo usa hierarquia de classes em runtime, não compile-time.",
                                    "Crie uma hierarquia simples: classe base Shape com método virtual area(), subclasses Circle e Rectangle.",
                                    "Demonstre chamada polimórfica via ponteiro base.",
                                    "Note ausência de overload de operadores específicos nesse contexto."
                                  ],
                                  "verification": "Implemente e execute um programa com overriding virtual, mostrando polimorfismo em runtime.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Compilador C++, exemplos de herança polimórfica online.",
                                  "tips": "Sempre declare métodos virtuais com 'virtual' e use ponteiros base para testar.",
                                  "learningObjective": "Entender polimorfismo de subtipo como runtime e hierárquico, contrastando com ad-hoc.",
                                  "commonMistakes": "Esquecer destructores virtuais, causando vazamentos em hierarquias."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Investigar Polimorfismo Paramétrico",
                                  "subSteps": [
                                    "Descreva templates/generics como polimorfismo paramétrico em compile-time.",
                                    "Exemplo: template <typename T> T max(T a, T b); funciona para int, double, etc.",
                                    "Compare: não depende de herança, gera código especializado por tipo.",
                                    "Implemente um template para container genérico com overload de operadores.",
                                    "Observe limitações: requer tipos completos em compile-time."
                                  ],
                                  "verification": "Crie e compile um template que overload operadores para tipos diferentes, sem erros de instanciação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Compilador C++ com suporte a templates, documentação STL.",
                                  "tips": "Use 'typename' em templates para evitar erros de dependência.",
                                  "learningObjective": "Compreender paramétrico como compile-time genérico, sem hierarquia.",
                                  "commonMistakes": "Confundir com subtipo, achando que templates requerem herança."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar e Contrastar as Formas de Polimorfismo",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: tempo de resolução (compile vs runtime), dependência de herança, uso em operadores.",
                                    "Destaque overload para abstração em ops binárias/unárias (ex: std::string::operator+).",
                                    "Discuta cenários ideais: overload para notação infix, subtipo para comportamentos derivados, paramétrico para reutilização.",
                                    "Refatore um exemplo unificado mostrando falhas ao usar o tipo errado.",
                                    "Resuma diferenças chave em um mapa mental."
                                  ],
                                  "verification": "Produza uma tabela ou diagrama explicando 3 diferenças principais com exemplos código.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Ferramenta de diagrama (Draw.io), códigos dos steps anteriores.",
                                  "tips": "Foque em 'quando usar cada um' para fixar diferenças práticas.",
                                  "learningObjective": "Diferenciar claramente as três formas, enfatizando papéis únicos.",
                                  "commonMistakes": "Achar que overload é subtipo porque ambos usam classes."
                                }
                              ],
                              "practicalExample": "Em uma biblioteca de álgebra linear, overload de + permite Vetor2D v1 + v2; polimorfismo subtipo permite Shape* shapes[] com shapes[i]->draw(); paramétrico permite template <typename T> Matrix<T> para floats ou ints.",
                              "finalVerifications": [
                                "Explique verbalmente as 3 diferenças principais sem hesitação.",
                                "Identifique corretamente o tipo de polimorfismo em 5 trechos de código dados.",
                                "Crie um exemplo híbrido usando dois tipos corretamente.",
                                "Discuta prós/contras de cada em um parágrafo.",
                                "Resolva um quiz com 80% de acerto sobre distinções."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas sem confusões (30%)",
                                "Uso de exemplos: códigos funcionais e relevantes (25%)",
                                "Comparação clara: tabela/diagrama destacando diferenças (20%)",
                                "Compreensão aplicada: cenários corretos de uso (15%)",
                                "Clareza de expressão: explicações concisas e lógicas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operadores binários/unários semelhantes a vetores e matrizes.",
                                "Design de Software: Padrões como Visitor usam polimorfismo subtipo.",
                                "Linguagens Formais: Teoria de tipos e inferência em compiladores.",
                                "Engenharia de Software: Abstração para APIs intuitivas."
                              ],
                              "realWorldApplication": "Na biblioteca Eigen (C++), overload de operadores permite expressões matriciais naturais como A + B * C, melhorando legibilidade em simulações físicas e machine learning, onde subtipo gerencia hierarquias de modelos e paramétrico suporta precisões variadas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.6.2",
                        "name": "Métodos Especiais para Sobrecarga em Python",
                        "description": "Conhecimento dos métodos mágicos (dunder methods) como __add__, __eq__ e outros que definem o comportamento dos operadores em classes Python.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.6.2.1",
                            "name": "Listar operadores sobrecarregáveis em Python",
                            "description": "Enumerar e descrever os principais métodos especiais: __add__ para +, __sub__ para -, __mul__ para *, __eq__ para ==, __lt__ para <, incluindo operadores unários como __neg__ e __str__.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de métodos especiais para sobrecarga de operadores",
                                  "subSteps": [
                                    "Leia a documentação oficial do Python sobre métodos especiais (data model).",
                                    "Identifique que métodos como __add__ permitem customizar operadores como + em classes personalizadas.",
                                    "Diferencie métodos binários (ex: __add__) de unários (ex: __neg__).",
                                    "Anote exemplos iniciais de operadores comuns como +, -, *."
                                  ],
                                  "verification": "Explique em 2-3 frases o que é sobrecarga de operador via __add__ e dê um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Python: https://docs.python.org/3/reference/datamodel.html#special-method-names",
                                    "Editor de código como VS Code ou Jupyter Notebook"
                                  ],
                                  "tips": [
                                    "Foquem nos nomes exatos: sempre duplos underscores (__method__).",
                                    "Use print(dir(obj)) para listar métodos disponíveis em objetos."
                                  ],
                                  "learningObjective": "Entender o papel dos métodos especiais na customização de comportamento de operadores em classes Python.",
                                  "commonMistakes": [
                                    "Confundir métodos especiais com funções lambda ou decoradores.",
                                    "Ignorar que nem todos os operadores são sobrecarregáveis (ex: // requer __floordiv__)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar e descrever operadores aritméticos binários sobrecarregáveis",
                                  "subSteps": [
                                    "Liste os principais: __add__ (+), __sub__ (-), __mul__ (*), __truediv__ (/), __floordiv__ (//), __mod__ (%), __pow__ (**).",
                                    "Para cada um, escreva uma frase descrevendo sua função (ex: __add__ implementa soma).",
                                    "Crie uma tabela simples no papel ou editor com operador, método e símbolo.",
                                    "Teste memorização recitando a lista 3 vezes."
                                  ],
                                  "verification": "Recite a lista de 7 operadores aritméticos binários com seus símbolos correspondentes sem consultar notas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta ou Google Sheets para tabela",
                                    "Notebook Python para testes rápidos"
                                  ],
                                  "tips": [
                                    "Agrupe por similaridade: adição/subtração, multiplicação/divisão.",
                                    "Associe mnemonicamente: 'add-sub-mul' como operações básicas."
                                  ],
                                  "learningObjective": "Dominar a lista e descrições precisas de operadores aritméticos binários.",
                                  "commonMistakes": [
                                    "Esquecer operadores compostos como __pow__ ou __mod__.",
                                    "Confundir __truediv__ com __floordiv__."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Listar e descrever operadores de comparação e atribuição",
                                  "subSteps": [
                                    "Liste: __eq__ (==), __ne__ (!=), __lt__ (<), __le__ (<=), __gt__ (>), __ge__ (>=), __hash__ para hashability.",
                                    "Descreva cada um: ex: __lt__ define ordem para < em sorting.",
                                    "Note que __eq__ e __hash__ são cruciais para sets e dicts.",
                                    "Pratique escrevendo pares: símbolo -> método."
                                  ],
                                  "verification": "Escreva corretamente os métodos para ==, < e !=, e explique uso de __hash__.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Python sobre rich comparisons",
                                    "Flashcards app como Anki"
                                  ],
                                  "tips": [
                                    "Lembre: comparações ricas (rich comparisons) formam uma cadeia lógica.",
                                    "__eq__ deve ser consistente com __hash__."
                                  ],
                                  "learningObjective": "Conhecer operadores de comparação e seu impacto em estruturas de dados.",
                                  "commonMistakes": [
                                    "Omitir __ne__ ou confundir com bitwise (!= é comparação, ^ é XOR).",
                                    "Ignorar que __hash__ afeta usabilidade em containers."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar operadores unários e de representação",
                                  "subSteps": [
                                    "Liste unários: __neg__ (-unário), __pos__ (+unário), __abs__ (abs()), __bool__ (bool()).",
                                    "Inclua representação: __str__ (str()), __repr__ (repr()).",
                                    "Compare __str__ (user-friendly) vs __repr__ (dev-friendly).",
                                    "Compile lista completa de 15+ operadores em um documento.",
                                    "Revise todas as listas anteriores integrando-as."
                                  ],
                                  "verification": "Liste 5 unários/representação e descreva diferenças entre __str__ e __repr__.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de código em classes built-in como int, list",
                                    "Seu documento de compilação"
                                  ],
                                  "tips": [
                                    "Teste com classes simples: def __neg__(self): return type(self)(-self.x).",
                                    "Sempre implemente __repr__ para debugging."
                                  ],
                                  "learningObjective": "Completar conhecimento com unários e métodos de exibição.",
                                  "commonMistakes": [
                                    "Confundir unário (-) com binário (-- não existe).",
                                    "Subestimar importância de __repr__ para depuração."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Compilar e praticar a lista completa de operadores sobrecarregáveis",
                                  "subSteps": [
                                    "Crie uma lista master com 20+ métodos, agrupados por categoria (aritmética, comparação, unária).",
                                    "Use flashcards ou quiz online para testar recall.",
                                    "Escreva um cheat sheet com descrições breves.",
                                    "Ensine o conceito a um 'aluno imaginário' verbalmente."
                                  ],
                                  "verification": "Sem consultar, liste 15 operadores principais com símbolos e categorias corretas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Anki ou Quizlet para flashcards",
                                    "Cheat sheet template em Markdown"
                                  ],
                                  "tips": [
                                    "Revise diariamente por 5 dias para retenção.",
                                    "Agrupe em categorias para memorização chunked."
                                  ],
                                  "learningObjective": "Consolidar lista completa para recall imediato.",
                                  "commonMistakes": [
                                    "Listas incompletas: sempre cheque docs para mais como __imatmul__.",
                                    "Falta de prática ativa de recall."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe `Ponto2D`: def __init__(self, x, y); def __add__(self, other): return Ponto2D(self.x + other.x, self.y + other.y); def __str__(self): return f'Ponto({self.x}, {self.y})'; def __lt__(self, other): return self.x < other.x or (self.x == other.x and self.y < other.y). Teste: p1 = Ponto2D(1,2); p2 = Ponto2D(3,4); print(p1 + p2); print(p1 < p2).",
                              "finalVerifications": [
                                "Pode listar pelo menos 15 métodos especiais com símbolos corretos.",
                                "Descreve precisamente o papel de __add__, __eq__, __neg__ e __str__.",
                                "Identifica diferenças entre operadores binários e unários.",
                                "Explica impacto de __hash__ e __eq__ em dicts/sets.",
                                "Cria um exemplo funcional de sobrecarga básica.",
                                "Distingue __str__ de __repr__ com exemplos.",
                                "Enumera categorias principais sem omissões graves."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 100% dos métodos listados corretos (nome e símbolo).",
                                "Completude: Pelo menos 80% da lista oficial coberta (20+ itens).",
                                "Descrições claras e concisas para cada operador.",
                                "Exemplo prático executável sem erros.",
                                "Explicação verbal fluida sem hesitação.",
                                "Uso correto de termos técnicos (ex: 'método especial', 'sobrecarga').",
                                "Cheat sheet organizado e útil para referência futura."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sobrecarga para álgebra linear (vetores, matrizes).",
                                "Design de Software: Criação de APIs intuitivas como em NumPy ou Pandas.",
                                "Lógica e Algoritmos: Comparações customizadas para sorting personalizado.",
                                "Física/Engenharia: Modelagem de grandezas com operadores naturais (ex: Vetor + Força).",
                                "Linguagens: Comparação com operator overloading em C++ ou Java."
                              ],
                              "realWorldApplication": "Em bibliotecas científicas como NumPy (ndarray.__add__ para vetores), desenvolvimento de DSLs (Domain-Specific Languages) para finanças (Money.__add__), ou jogos (Vector2.__mul__ para escala), permitindo código intuitivo como v1 + v2 em vez de v1.add(v2)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.6.2.2",
                            "name": "Implementar sobrecarga de operador binário",
                            "description": "Criar um método como __add__ em uma classe para somar instâncias, retornando uma nova instância ou modificando o existente, com tratamento de tipos compatíveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender métodos especiais para operadores binários em Python",
                                  "subSteps": [
                                    "Pesquise a documentação oficial do Python sobre métodos especiais (dunder methods) como __add__, __sub__, __mul__.",
                                    "Identifique que operadores binários como + chamam __add__ na instância esquerda.",
                                    "Note que o método recebe self e other como parâmetros.",
                                    "Leia exemplos básicos na documentação para familiarizar com a sintaxe.",
                                    "Anote os operadores binários suportados: +, -, *, /, etc."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como + chama __add__ e liste 3 operadores binários com seus métodos correspondentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Python: https://docs.python.org/3/reference/datamodel.html#special-method-names",
                                    "Editor de código como VS Code ou Jupyter Notebook"
                                  ],
                                  "tips": "Use print statements dentro de __add__ para depurar chamadas iniciais.",
                                  "learningObjective": "Compreender o mapeamento entre operadores e métodos especiais em Python.",
                                  "commonMistakes": [
                                    "Confundir __add__ com __radd__ (chamado quando other não suporta __add__)",
                                    "Esquecer que self é a instância esquerda"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir uma classe base com atributos somáveis",
                                  "subSteps": [
                                    "Crie uma classe simples, como Vetor2D, com atributos x e y (inteiros ou floats).",
                                    "Adicione um método __init__ para inicializar x e y.",
                                    "Implemente um método __repr__ ou __str__ para visualização clara das instâncias.",
                                    "Crie duas instâncias de teste: v1 = Vetor2D(1, 2), v2 = Vetor2D(3, 4).",
                                    "Teste a criação e impressão das instâncias."
                                  ],
                                  "verification": "Instancie dois objetos e imprima-os; confirme que os atributos estão corretos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor Python",
                                    "REPL Python para testes rápidos"
                                  ],
                                  "tips": "Use type hints como def __init__(self, x: float, y: float) para clareza.",
                                  "learningObjective": "Criar uma classe com dados numéricos compatíveis para operações binárias.",
                                  "commonMistakes": [
                                    "Esquecer self em __init__",
                                    "Não definir __repr__ levando a saídas confusas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o método __add__ para somar instâncias",
                                  "subSteps": [
                                    "Defina def __add__(self, other): dentro da classe.",
                                    "Verifique se other é uma instância da mesma classe usando isinstance(other, Vetor2D).",
                                    "Calcule new_x = self.x + other.x e new_y = self.y + other.y.",
                                    "Retorne uma nova instância: return Vetor2D(new_x, new_y).",
                                    "Evite modificar self ou other (imutabilidade)."
                                  ],
                                  "verification": "Execute v3 = v1 + v2 e imprima v3; deve ser Vetor2D(4, 6).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código da classe do step 2",
                                    "Unittest ou pytest para testes"
                                  ],
                                  "tips": "Sempre retorne uma nova instância para evitar efeitos colaterais inesperados.",
                                  "learningObjective": "Implementar sobrecarga correta de operador binário retornando nova instância.",
                                  "commonMistakes": [
                                    "Modificar self em vez de retornar novo objeto",
                                    "Não tratar se other não é Vetor2D (TypeError)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar casos edge e expandir tratamento de tipos",
                                  "subSteps": [
                                    "Adicione raise TypeError('Tipos incompatíveis') se not isinstance(other, Vetor2D).",
                                    "Teste soma com números: permita other ser int/float somando a ambos x e y.",
                                    "Implemente suporte básico: if isinstance(other, (int, float)): return Vetor2D(self.x + other, self.y + other).",
                                    "Execute testes: v1 + 5, 5 + v1 (para __radd__ básico se necessário), v1 + v2.",
                                    "Use asserts ou testes unitários para validar todos os casos."
                                  ],
                                  "verification": "Rode uma suíte de testes cobrindo soma de instâncias, escalares e casos inválidos sem crashes inesperados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Biblioteca unittest",
                                    "Exemplos de teste no código"
                                  ],
                                  "tips": "Implemente __radd__ para simetria com escalares: def __radd__(self, other): return self + other.",
                                  "learningObjective": "Lidar com compatibilidade de tipos e casos edge em sobrecarga de operadores.",
                                  "commonMistakes": [
                                    "Não levantar TypeError para tipos inválidos",
                                    "Esquecer ordem em operações não-comutativas"
                                  ]
                                }
                              ],
                              "practicalExample": "Classe Vetor2D:\nclass Vetor2D:\n    def __init__(self, x, y):\n        self.x, self.y = x, y\n    def __add__(self, other):\n        if isinstance(other, Vetor2D):\n            return Vetor2D(self.x + other.x, self.y + other.y)\n        elif isinstance(other, (int, float)):\n            return Vetor2D(self.x + other, self.y + other)\n        raise TypeError('Incompatível')\n    def __repr__(self):\n        return f'Vetor2D({self.x}, {self.y})'\n\nv1 = Vetor2D(1, 2)\nv2 = Vetor2D(3, 4)\nprint(v1 + v2)  # Vetor2D(4, 6)\nprint(v1 + 5)   # Vetor2D(6, 7)",
                              "finalVerifications": [
                                "Criar duas instâncias e usar + resulta em nova instância com valores somados corretos.",
                                "Soma com escalar (int/float) ajusta ambos componentes corretamente.",
                                "Tentativa de soma com tipo incompatível levanta TypeError claro.",
                                "Instâncias originais permanecem inalteradas após operação.",
                                "Impressão de resultado usa __repr__ para clareza.",
                                "Testes unitários passam para todos os casos suportados."
                              ],
                              "assessmentCriteria": [
                                "Método __add__ recebe self e other corretamente e retorna nova instância.",
                                "Tratamento adequado de tipos: mesma classe, escalares e erro para incompatíveis.",
                                "Código segue princípios OOP: imutabilidade e encapsulamento.",
                                "Sem side effects: objetos originais não modificados.",
                                "Comentários e docstrings explicam lógica.",
                                "Cobertura de testes >80% para cenários principais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações vetoriais e álgebra linear.",
                                "Física: Soma de vetores de força ou velocidade em simulações.",
                                "Engenharia de Software: Design de APIs intuitivas como em NumPy.",
                                "Design de Jogos: Cálculo de posições e movimentos de entidades."
                              ],
                              "realWorldApplication": "Em bibliotecas como NumPy ou Pygame, sobrecarga de operadores permite sintaxe intuitiva como vec1 + vec2 para somar vetores em simulações físicas, jogos ou análise de dados, facilitando código legível e eficiente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.6.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.6.2.3",
                            "name": "Implementar sobrecarga de operador de comparação",
                            "description": "Definir __eq__, __lt__ e __gt__ em uma classe para permitir comparações entre objetos, garantindo consistência com o método __hash__ para uso em sets e dicts.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os métodos especiais de comparação e hash em Python",
                                  "subSteps": [
                                    "Leia a documentação oficial do Python sobre métodos especiais (dunder methods) para comparação: __eq__, __lt__, __gt__.",
                                    "Estude o contrato de hash: __hash__ deve ser consistente com __eq__ (iguais em eq => mesmo hash).",
                                    "Revise exemplos básicos de classes com esses métodos usando o REPL do Python.",
                                    "Anote as regras: retornar NotImplemented para comparações não suportadas entre tipos diferentes.",
                                    "Teste comportamentos padrão sem sobrecarga em classes simples."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as diferenças entre __eq__ e ==, e por que __hash__ é necessário para sets/dicts.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Python: https://docs.python.org/3/reference/datamodel.html#object.__eq__",
                                    "Editor de código (VS Code ou PyCharm)",
                                    "REPL Python"
                                  ],
                                  "tips": "Use dir(obj) para listar métodos disponíveis e help(obj.__eq__) para detalhes.",
                                  "learningObjective": "Compreender o papel e as regras de consistência dos dunder methods de comparação e hash.",
                                  "commonMistakes": [
                                    "Confundir __eq__ com == (== chama __eq__), esquecer que __hash__ muda se __eq__ muda."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o método __eq__ em uma classe personalizada",
                                  "subSteps": [
                                    "Crie uma classe simples, como Point(x, y), representando pontos 2D.",
                                    "Defina __eq__(self, other) que compara x e y se other é Point, senão retorna NotImplemented.",
                                    "Adicione verificação de tipo com isinstance(other, Point).",
                                    "Teste com p1 == p2 para pontos iguais e diferentes.",
                                    "Verifique se p1 == 5 retorna False ou TypeError adequadamente."
                                  ],
                                  "verification": "Execute testes unitários: assert Point(1,2) == Point(1,2) é True, e Point(1,2) == Point(3,4) é False.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Biblioteca unittest ou pytest instalada"
                                  ],
                                  "tips": "Sempre verifique isinstance para evitar AttributeError em comparações cross-tipo.",
                                  "learningObjective": "Implementar __eq__ corretamente, lidando com tipos diferentes.",
                                  "commonMistakes": [
                                    "Não checar tipo de other, causando AttributeError; retornar True/False em vez de NotImplemented para outros tipos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar __lt__ e __gt__ para ordenação total",
                                  "subSteps": [
                                    "Adicione __lt__(self, other) comparando primeiro x, depois y (ordenação lexicográfica).",
                                    "Implemente __gt__(self, other) como not (self < other or self == other).",
                                    "Ou use return not (self < other or self == other), mas prefira lógica simétrica.",
                                    "Teste com sorted([p1, p2, p3]) e confirme ordem correta.",
                                    "Garanta que retorne NotImplemented se tipos incompatíveis."
                                  ],
                                  "verification": "Execute sorted(lista_de_points) e verifique se a ordem é correta baseada em (x,y).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Lista de instâncias de Point para testar sorted()"
                                  ],
                                  "tips": "Para ordenação total, defina apenas __lt__ e deixe Python derivar os outros via functools.total_ordering.",
                                  "learningObjective": "Criar operadores de comparação para permitir ordenação de objetos customizados.",
                                  "commonMistakes": [
                                    "Implementar __gt__ incorretamente levando a inconsistências; esquecer ordem total (transitiva)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Garantir consistência com __hash__ e testar em coleções",
                                  "subSteps": [
                                    "Implemente __hash__(self) baseado em atributos imutáveis: return hash((self.x, self.y)).",
                                    "Certifique-se de que se a == b então hash(a) == hash(b).",
                                    "Teste inserção em set: {p1, p2} deve remover duplicatas baseadas em ==.",
                                    "Teste em dict como chaves: d[p1] = 'value'; assert d[p2] == 'value' se p1 == p2.",
                                    "Verifique que mudanças em atributos mutáveis invalidem hash (torne atributos readonly)."
                                  ],
                                  "verification": "Adicione pontos iguais/duplicados a um set e confirme len(set) correto; teste dict keys.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Sets e dicts em scripts de teste"
                                  ],
                                  "tips": "Use tuple de atributos imutáveis em hash para simplicidade e corretude.",
                                  "learningObjective": "Assegurar que objetos sejam hasháveis consistentemente para uso em hash-based collections.",
                                  "commonMistakes": [
                                    "__hash__ baseado em atributos mutáveis; não chamar super().__hash__ se herdando."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testes integrados e depuração de erros comuns",
                                  "subSteps": [
                                    "Escreva testes abrangentes cobrindo ==, <, >, sorted, set, dict.",
                                    "Teste casos edge: comparação com None, diferentes tipos, auto-comparação (p < p é False).",
                                    "Use debugger para inspecionar chamadas de métodos durante comparações.",
                                    "Refatore para usar @total_ordering do functools para reduzir código.",
                                    "Documente a classe com docstrings explicando as comparações."
                                  ],
                                  "verification": "Todos os testes passam com 100% coverage; objetos funcionam em min(), max(), sorted().",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "pytest ou unittest",
                                    "coverage.py opcional"
                                  ],
                                  "tips": "Importe from functools import total_ordering e use como decorator na classe.",
                                  "learningObjective": "Validar a implementação completa através de testes robustos.",
                                  "commonMistakes": [
                                    "Esquecer que < em iguais deve ser False; problemas com herança múltipla em hash."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe Employee com atributos name (str) e salary (float). Implemente comparações por salary (__lt__, __gt__, __eq__) e use em sorted(employees) para listar por salário crescente. Adicione a um set para remover duplicatas de salário exato, confirmando uso em dict de salários.",
                              "finalVerifications": [
                                "Instâncias da classe podem ser comparadas com ==, < e > sem erros.",
                                "sorted() em lista de instâncias produz ordem correta baseada nos critérios definidos.",
                                "Objetos iguais via __eq__ têm o mesmo hash e se comportam como duplicatas em sets/dicts.",
                                "Comparaçōes com objetos de tipos diferentes retornam NotImplemented ou resultados lógicos corretos.",
                                "min() e max() funcionam em listas de instâncias.",
                                "Nenhum AttributeError ou TypeError em cenários edge como comparação com None."
                              ],
                              "assessmentCriteria": [
                                "__eq__ implementado corretamente com checagem de tipo e consistência.",
                                "__lt__ e __gt__ fornecem ordem total (antisimétrica, transitiva).",
                                "__hash__ consistente com __eq__, baseado em atributos imutáveis.",
                                "Testes demonstram funcionamento em sets, dicts e sorted sem colisões ou erros.",
                                "Código limpo, com docstrings e uso de total_ordering se aplicável.",
                                "Tratamento de casos edge (diferentes tipos, self-comparação)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Relações de ordem parcial/total e funções hash (equivalência modular).",
                                "Algoritmos e Estruturas de Dados: Hash tables, árvores de busca balanceadas (BST).",
                                "Design de Software: Princípios SOLID (especialmente substituição de Liskov).",
                                "Banco de Dados: Índices e ordenação em queries SQL (ORDER BY custom).",
                                "Física/Engenharia: Modelagem de entidades comparáveis (ex: partículas por massa/posição)."
                              ],
                              "realWorldApplication": "Em sistemas de gerenciamento de estoque, compare produtos por preço e código para ordenação em relatórios e remoção de duplicatas em caches; em jogos, ordene entidades por pontuação ou nível para leaderboards usando sets para rankings únicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.6.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.6.2.4",
                            "name": "Sobrecarregar operadores unários",
                            "description": "Implementar métodos como __neg__ para negação unária, __len__ para len() e __str__ para print(), ilustrando extensibilidade de comportamentos built-in.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender operadores unários e métodos especiais em Python",
                                  "subSteps": [
                                    "Estude os operadores unários comuns: negação unária (-), len() e str() para print().",
                                    "Identifique os métodos especiais correspondentes: __neg__, __len__ e __str__.",
                                    "Leia a documentação oficial do Python sobre data model (Special method names).",
                                    "Anote exemplos built-in: como -5 para int ou len('string') para str.",
                                    "Compare com operadores binários para diferenciar (ex: + vs - unário)."
                                  ],
                                  "verification": "Liste corretamente pelo menos 3 operadores unários e seus dunder methods em um documento ou comentário no código.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código Python (VS Code ou PyCharm)",
                                    "Documentação Python: https://docs.python.org/3/reference/datamodel.html#special-method-names"
                                  ],
                                  "tips": "Use o IPython ou REPL para testar comportamentos built-in rapidamente.",
                                  "learningObjective": "Dominar os conceitos fundamentais de operadores unários e como classes os sobrecarregam via métodos especiais.",
                                  "commonMistakes": "Confundir operadores unários com binários ou esquecer que __str__ é chamado por print() e str()."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a sobrecarga do operador de negação unária (__neg__)",
                                  "subSteps": [
                                    "Crie uma classe simples, como Vetor2D, com atributos x e y.",
                                    "Defina o método __neg__(self) que retorna uma nova instância com x e y negados.",
                                    "Teste criando um objeto v = Vetor2D(3, 4) e verificando -v == Vetor2D(-3, -4).",
                                    "Garanta que __neg__ retorne uma nova instância, não modifique self.",
                                    "Adicione um método auxiliar para criar instâncias se necessário."
                                  ],
                                  "verification": "Execute -objeto e confirme que os valores são corretamente negados sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ambiente Python 3.8+",
                                    "REPL ou Jupyter Notebook para testes interativos"
                                  ],
                                  "tips": "Sempre retorne self.__class__(...), nunca None ou modifique o objeto original.",
                                  "learningObjective": "Implementar com sucesso __neg__ para permitir negação unária em objetos customizados.",
                                  "commonMistakes": "Retornar None em vez de nova instância; esquecer de importar ou usar self corretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a sobrecarga para len() via __len__",
                                  "subSteps": [
                                    "Adicione o atributo size ou use len(self.data) se aplicável à classe Vetor2D.",
                                    "Defina __len__(self) retornando um inteiro fixo (ex: 2 para Vetor2D) ou dinâmico.",
                                    "Teste com len(v) e confirme o retorno esperado.",
                                    "Considere casos edge: objeto vazio ou com tamanho variável.",
                                    "Integre com __neg__ testando len(-v) == len(v)."
                                  ],
                                  "verification": "len(objeto) retorna o valor correto e funciona após negação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código da classe do passo anterior",
                                    "Unittest ou pytest para automação de testes"
                                  ],
                                  "tips": "__len__ deve sempre retornar int, nunca float ou str.",
                                  "learningObjective": "Sobrecarregar __len__ para integrar objetos customizados com funções built-in como len().",
                                  "commonMistakes": "Retornar float em vez de int; não testar com coleções vazias."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar __str__ e realizar testes integrados",
                                  "subSteps": [
                                    "Defina __str__(self) retornando uma string legível como 'Vetor2D(3, 4)'.",
                                    "Teste com print(objeto), str(objeto) e f-strings.",
                                    "Execute testes completos: -v, len(v), print(-v).",
                                    "Refatore a classe para incluir todos os métodos e documente com docstrings.",
                                    "Crie um script de teste com asserts para verificação automatizada."
                                  ],
                                  "verification": "Todos os operadores funcionam: print mostra formato correto, len retorna 2, -v inverte valores.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código completo da classe",
                                    "Biblioteca unittest para testes unitários"
                                  ],
                                  "tips": "Diferencie __str__ (para humanos) de __repr__ (para debug).",
                                  "learningObjective": "Completar a sobrecarga de múltiplos operadores unários com testes robustos.",
                                  "commonMistakes": "Fazer __str__ retornar print() em vez de string; erros de formatação em __str__."
                                }
                              ],
                              "practicalExample": "Crie uma classe Vetor2D(x, y). Implemente __neg__ para retornar Vetor2D(-x, -y), __len__ retornando 2 e __str__ como 'Vetor2D({self.x}, {self.y})'. Teste: v = Vetor2D(5, 12); assert str(-v) == 'Vetor2D(-5, -12)'; assert len(v) == 2.",
                              "finalVerifications": [
                                "O operador -objeto cria uma nova instância com valores negados corretamente.",
                                "len(objeto) retorna o tamanho esperado sem exceções.",
                                "print(objeto) exibe uma representação legível e formatada.",
                                "Todos os métodos funcionam em conjunto sem interferências.",
                                "Testes unitários passam para cenários normais e edge cases.",
                                "A classe mantém estado imutável após operações unárias."
                              ],
                              "assessmentCriteria": [
                                "Código executa sem erros de sintaxe ou runtime.",
                                "Métodos especiais estão implementados corretamente conforme documentação Python.",
                                "Testes demonstram funcionalidade para todos os operadores.",
                                "Explicações ou docstrings mostram compreensão conceitual.",
                                "Eficiência: métodos são O(1) quando possível.",
                                "Boas práticas: uso de self.__class__ e retornos apropriados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações vetoriais e negação em espaços euclidianos.",
                                "Física: Representação de vetores de força ou posição com inversão.",
                                "Design de Software: Criação de APIs intuitivas como em NumPy ou Pandas.",
                                "Lógica Computacional: Extensibilidade de comportamentos built-in."
                              ],
                              "realWorldApplication": "Bibliotecas científicas como NumPy usam sobrecarga de unários em ndarray para operações como -array (negativa elemento-wise), len(array) para dimensões e print(array) para visualização amigável, permitindo código matemático natural em simulações, ML e análise de dados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.6.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.6.3",
                        "name": "Exemplos Práticos e Boas Práticas",
                        "description": "Aplicação prática da sobrecarga em cenários reais, com exemplos de classes como Vetor e Complexo, e diretrizes para evitar abusos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.6.3.1",
                            "name": "Criar classe com múltiplos operadores sobrecarregados",
                            "description": "Desenvolver uma classe Vetor2D com __add__, __sub__, __mul__ (escalar), __eq__ e __str__, testando expressões como v1 + v2 e print(v1).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a estrutura básica da classe Vetor2D",
                                  "subSteps": [
                                    "Crie um arquivo Python novo chamado vetor2d.py.",
                                    "Defina a classe Vetor2D com atributos privados _x e _y.",
                                    "Implemente o método __init__ para inicializar _x e _y com valores passados como parâmetros (use float por padrão)."
                                  ],
                                  "verification": "Execute Vetor2D(1.0, 2.0) sem erros e acesse os atributos via propriedades ou getters se implementados.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Editor de código (VS Code, PyCharm), Python 3.8+ instalado",
                                  "tips": "Use type hints como def __init__(self, x: float = 0.0, y: float = 0.0) -> None:",
                                  "learningObjective": "Entender a criação de classes com construtor e encapsulamento básico.",
                                  "commonMistakes": "Esquecer de inicializar self._x e self._y; não usar float para permitir decimais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o método __str__ para representação",
                                  "subSteps": [
                                    "Adicione o método __str__ que retorne uma string formatada como 'Vetor2D({self._x}, {self._y})'.",
                                    "Teste printando uma instância para verificar a saída.",
                                    "Opcionalmente, adicione __repr__ similar para depuração."
                                  ],
                                  "verification": "print(v1) exibe 'Vetor2D(1.0, 2.0)' corretamente.",
                                  "estimatedTime": "5 minutos",
                                  "materials": "Terminal ou console Python interativo (REPL)",
                                  "tips": "Use f-strings para formatação limpa: f'Vetor2D({self._x}, {self._y})'.",
                                  "learningObjective": "Dominar a sobrecarga de operador de string para output legível.",
                                  "commonMistakes": "Retornar print() em vez de string; esquecer self."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Sobrecarregar operadores aritméticos __add__, __sub__ e __mul__",
                                  "subSteps": [
                                    "Implemente __add__(self, other) para somar componentes: retornar Vetor2D(self._x + other._x, self._y + other._y).",
                                    "Implemente __sub__(self, other) similar para subtração.",
                                    "Implemente __mul__(self, scalar) assumindo scalar float/int: retornar Vetor2D(self._x * scalar, self._y * scalar); levante TypeError se other não for numérico."
                                  ],
                                  "verification": "Teste v1 + v2 resulta em Vetor2D correto; v1 * 2 escala corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Console Python para testes interativos",
                                  "tips": "Sempre retorne uma nova instância, não modifique self (imutabilidade).",
                                  "learningObjective": "Aplicar sobrecarga para operações vetoriais naturais.",
                                  "commonMistakes": "Modificar self em vez de retornar novo; não tratar tipos errados em __mul__."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar o operador de igualdade __eq__",
                                  "subSteps": [
                                    "Adicione __eq__(self, other) que retorne True se other é Vetor2D e _x e _y iguais.",
                                    "Use isinstance(other, Vetor2D) para checagem de tipo.",
                                    "Teste v1 == v1 (True) e v1 == v2 (False)."
                                  ],
                                  "verification": "v1 == Vetor2D(1.0, 2.0) retorna True; diferente retorna False.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Editor e console",
                                  "tips": "Para igualdade profunda, compare floats com tolerância se necessário, mas use == exato aqui.",
                                  "learningObjective": "Sobrecarregar comparação para objetos customizados.",
                                  "commonMistakes": "Esquecer checagem isinstance; comparar classes erradas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar completamente a classe com expressões",
                                  "subSteps": [
                                    "Crie script de teste com v1 = Vetor2D(1,2), v2 = Vetor2D(3,4).",
                                    "Execute e verifique: print(v1 + v2), print(v1 - v2), print(v1 * 2), print(v1), v1 == v1.",
                                    "Adicione asserts para automação: assert (v1 + v2) == Vetor2D(4,6)."
                                  ],
                                  "verification": "Todos os testes passam sem erros e outputs corretos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Arquivo de teste vetor2d_test.py",
                                  "tips": "Use pytest ou unittest para testes robustos futuramente.",
                                  "learningObjective": "Validar sobrecargas com testes práticos.",
                                  "commonMistakes": "Não testar casos edge como zero ou negativos."
                                }
                              ],
                              "practicalExample": "v1 = Vetor2D(1.0, 2.0)\nv2 = Vetor2D(3.0, 4.0)\nprint(v1)  # Vetor2D(1.0, 2.0)\nprint(v1 + v2)  # Vetor2D(4.0, 6.0)\nprint(v1 * 2)  # Vetor2D(2.0, 4.0)\nprint(v1 == v2)  # False",
                              "finalVerifications": [
                                "Instanciação sem erros com valores float/int.",
                                "print() exibe formato correto 'Vetor2D(x, y)'.",
                                "v1 + v2 retorna novo Vetor2D com soma componente-wise.",
                                "v1 - v2 e v1 * scalar funcionam corretamente.",
                                "__eq__ distingue vetores iguais e diferentes.",
                                "Sem TypeError em usos válidos; erros em inválidos."
                              ],
                              "assessmentCriteria": [
                                "Código limpo com type hints e docstrings opcionais.",
                                "Todos operadores implementados retornam novas instâncias.",
                                "Tratamento de tipos em __mul__ e __eq__.",
                                "Testes cobrem todos os operadores com asserts.",
                                "Sem mutação de self; imutabilidade preservada.",
                                "Formato __str__ legível e preciso."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra vetorial (soma, subtração, escalar).",
                                "Física: Vetores de posição, velocidade em 2D.",
                                "Jogos/Gráficos: Movimentação em engines como Pygame.",
                                "Engenharia de Software: Design de classes imutáveis."
                              ],
                              "realWorldApplication": "Em desenvolvimento de jogos 2D (ex: Unity-like com Python/Pygame), simulações físicas (movimento de partículas), gráficos computacionais (transformações vetoriais) e bibliotecas como NumPy que usam sobrecarga similar para arrays."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.6.2.2",
                              "10.1.4.6.2.3"
                            ]
                          },
                          {
                            "id": "10.1.4.6.3.2",
                            "name": "Aplicar em números complexos",
                            "description": "Implementar classe Complexo com operadores aritméticos (+, -, *, /) usando métodos especiais, validando resultados contra a biblioteca cmath.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a estrutura básica da classe Complexo",
                                  "subSteps": [
                                    "Crie uma classe chamada Complexo com atributos privados para parte real (real) e imaginária (imag).",
                                    "Implemente o método __init__ para inicializar os atributos com valores float padrão 0.0.",
                                    "Adicione métodos getters para acessar real e imag.",
                                    "Implemente __str__ para retornar uma string no formato 'a + bi' ou 'a - bi'.",
                                    "Teste a instanciação básica com print."
                                  ],
                                  "verification": "Instancie Complexo(3, 4) e imprima; deve mostrar '3 + 4i'.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor Python (VS Code ou PyCharm), documentação Python para classes.",
                                  "tips": "Use float para precisão; valide entrada no __init__ para números reais.",
                                  "learningObjective": "Entender encapsulamento e representação de objetos em OOP.",
                                  "commonMistakes": "Esquecer de usar self nos atributos; não tratar imag negativo em __str__."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar operadores de adição e subtração",
                                  "subSteps": [
                                    "Defina __add__(self, other) para somar partes real e imag separadamente.",
                                    "Defina __sub__(self, other) similarmente para subtrair.",
                                    "Garanta que other seja convertido para Complexo se for float ou int.",
                                    "Retorne uma nova instância Complexo com o resultado.",
                                    "Teste com exemplos: (1+2i) + (3+4i) e (5+1i) - (2+3i)."
                                  ],
                                  "verification": "Execute testes; resultados devem coincidir com cálculos manuais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Import cmath para referência futura; console Python interativo.",
                                  "tips": "Sempre retorne self.__class__(real, imag) para criar nova instância.",
                                  "learningObjective": "Dominar sobrecarga de operadores binários básicos.",
                                  "commonMistakes": "Modificar o objeto original em vez de retornar novo; esquecer conversão de tipos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar operadores de multiplicação e divisão",
                                  "subSteps": [
                                    "Defina __mul__(self, other) usando fórmula (a+bi)(c+di) = (ac-bd) + (ad+bc)i.",
                                    "Defina __truediv__(self, other) usando divisão complexa: multiplique numerador e denominador pelo conjulgado.",
                                    "Calcule módulo ao quadrado para divisão: other.real**2 + other.imag**2.",
                                    "Trate divisão por zero lançando ValueError.",
                                    "Teste: (1+1i) * (1+1i) = 0 + 2i; (1+1i) / (1+1i) = 1 + 0i."
                                  ],
                                  "verification": "Compare resultados com cálculos manuais e prints intermediários.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Referência matemática de números complexos; calculadora para verificação.",
                                  "tips": "Evite divisão por zero verificando if abs(other) == 0.",
                                  "learningObjective": "Aplicar álgebra complexa em programação orientada a objetos.",
                                  "commonMistakes": "Erro no sinal da parte imaginária na multiplicação; overflow em floats grandes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar implementação contra biblioteca cmath e adicionar testes",
                                  "subSteps": [
                                    "Importe cmath e crie função de validação que compara Complexo com cmath.rect ou operações diretas.",
                                    "Defina testes unitários para todos operadores com casos edge (zero, puro real/imag, negativos).",
                                    "Implemente __eq__ para comparação precisa com tolerância epsilon (1e-10).",
                                    "Execute bateria de testes e assert que resultados batem com cmath.",
                                    "Refatore código para boa práticas: docstrings e type hints."
                                  ],
                                  "verification": "Todos testes passam com assert; erro < 1e-10 em comparações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Biblioteca cmath; pytest ou unittest para testes automatizados.",
                                  "tips": "Use complex(real, imag) do Python built-in para validação rápida.",
                                  "learningObjective": "Garantir robustez e precisão via testes e bibliotecas padrão.",
                                  "commonMistakes": "Ignorar precisão de float; não testar casos edge como divisão por zero."
                                }
                              ],
                              "practicalExample": "Crie z1 = Complexo(3, 4), z2 = Complexo(1, -1); resultado = z1 + z2 * z2 / z1; imprima resultado e valide com cmath: abs((3+4j) + (1-1j)*(1-1j)/(3+4j) - complex(resultado.real, resultado.imag)) < 1e-10.",
                              "finalVerifications": [
                                "Classe suporta todos operadores + - * / corretamente.",
                                "Resultados validam contra cmath com precisão de float.",
                                "Tratamento de erros para divisão por zero.",
                                "Representação string correta para casos positivos/negativos.",
                                "Testes unitários cobrem 80%+ do código.",
                                "Conversão automática de float/int para Complexo."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática em todos operadores (peso 40%).",
                                "Uso correto de métodos especiais sem mutação (20%).",
                                "Validação robusta com cmath e testes (20%).",
                                "Código limpo com docstrings e type hints (10%).",
                                "Tratamento de edge cases e erros (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra complexa e operações polares.",
                                "Física: Análise de circuitos AC e ondas eletromagnéticas.",
                                "Engenharia: Simulações de sinais e controle.",
                                "Ciências da Computação: Bibliotecas NumPy/SciPy para arrays complexos."
                              ],
                              "realWorldApplication": "Desenvolvimento de software para processamento de sinais digitais (DSP), simulações físicas em engenharia elétrica (ex: análise de Fourier), jogos 2D/3D com rotações complexas, e machine learning com transformadas rápidas de Fourier (FFT)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.6.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.6.3.3",
                            "name": "Identificar limitações e boas práticas",
                            "description": "Discutir operadores não sobrecarregáveis (como //, % em alguns casos), riscos de legibilidade e regras como retornar novo objeto em vez de mutar, citando referências bibliográficas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar operadores não sobrecarregáveis e restrições comuns",
                                  "subSteps": [
                                    "Estude a documentação da linguagem (ex: Python __slots__ ou C++ restrições) para listar operadores proibidos como ::, ., -> em C++ ou limitações em // e % em contextos específicos.",
                                    "Compile uma tabela comparativa de operadores sobrecarregáveis vs. não sobrecarregáveis em pelo menos duas linguagens OOP.",
                                    "Analise exemplos de código onde tentativa de overload falha, como divisão inteira // em classes customizadas com restrições.",
                                    "Discuta casos onde % (modulo) pode levar a ambiguidades semânticas.",
                                    "Registre pelo menos 5 operadores com restrições e razões."
                                  ],
                                  "verification": "Criar uma lista documentada com exemplos de código inválidos que compilam/er ram com erro.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação oficial Python/C++ (PEP 3129), livro 'Effective C++' de Scott Meyers.",
                                  "tips": "Use IDE com linting para testar overloads inválidos rapidamente.",
                                  "learningObjective": "Compreender limitações fundamentais de sobrecarga para evitar erros de design.",
                                  "commonMistakes": "Confundir operadores aritméticos com lógicos; ignorar diferenças entre linguagens."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar riscos de legibilidade e usabilidade",
                                  "subSteps": [
                                    "Revise código com overload excessivo (ex: + para concatenação e soma) e identifique ambiguidades.",
                                    "Compare legibilidade de código com overload vs. métodos nomeados explícitos.",
                                    "Simule cenários onde overload de % ou // mascara intenções, como em classes de matrizes.",
                                    "Debata com pares ou anote 3 casos onde legibilidade é prejudicada.",
                                    "Refatore um exemplo ruim para melhorar clareza."
                                  ],
                                  "verification": "Produzir relatório com before/after de código, destacando métricas de legibilidade (ex: cyclomatic complexity).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Exemplos de código do GitHub (buscar 'operator overloading pitfalls'), ferramenta pylint ou clang-tidy.",
                                  "tips": "Leia código em voz alta para detectar confusões intuitivas.",
                                  "learningObjective": "Reconhecer impactos na manutenção e colaboração em código sobrecarregado.",
                                  "commonMistakes": "Sobrecarregar operadores para 'coolness' sem priorizar semântica intuitiva."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar boas práticas: retornar novos objetos e imutabilidade",
                                  "subSteps": [
                                    "Implemente overload de + em uma classe (ex: Vector) que retorna novo objeto, não muta self.",
                                    "Teste mutação vs. imutabilidade com asserts em unit tests.",
                                    "Aplique a regra para // e %: sempre retornar cópia para evitar side-effects.",
                                    "Compare performance de mutável vs. imutável em benchmarks simples.",
                                    "Documente a classe com docstrings explicando escolhas."
                                  ],
                                  "verification": "Executar testes unitários que confirmem ausência de mutação (ex: id(obj1) != id(result)).",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Editor com suporte a OOP (VS Code + Python), bibliotecas unittest/pytest.",
                                  "tips": "Use 'copy.deepcopy' como fallback para objetos complexos.",
                                  "learningObjective": "Dominar princípios de imutabilidade para código thread-safe e previsível.",
                                  "commonMistakes": "Mutar self acidentalmente, violando expectativas de operadores."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Citar referências bibliográficas e sintetizar conhecimentos",
                                  "subSteps": [
                                    "Pesquise fontes como PEP 3129 (Python), 'C++ Coding Standards' de Sutter/Alexandrescu.",
                                    "Compile 4-6 referências com citações APA/MLA sobre limitações e práticas.",
                                    "Crie um resumo de 1 página integrando todos os tópicos.",
                                    "Valide síntese com quiz auto-aplicado sobre conceitos chave.",
                                    "Compartilhe em fórum ou repo para feedback."
                                  ],
                                  "verification": "Gerar documento PDF com referências e resumo, sem plágio detectado.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Google Scholar, livros digitais, Zotero para gerenciamento de referências.",
                                  "tips": "Priorize fontes primárias como specs da linguagem.",
                                  "learningObjective": "Integrar teoria acadêmica com prática para aprendizado duradouro.",
                                  "commonMistakes": "Citar blogs não confiáveis em vez de papers ou livros."
                                }
                              ],
                              "practicalExample": "Em uma classe ComplexNumber, sobrecarregue __add__ para retornar um novo ComplexNumber sem mutar os operandos: def __add__(self, other): return ComplexNumber(self.real + other.real, self.imag + other.imag). Evite: self.real += other.real, que muta o objeto original, causando bugs em chains como a = b + c; d = b + e.",
                              "finalVerifications": [
                                "Listar corretamente 5 operadores com restrições em Python/C++.",
                                "Explicar com código um risco de legibilidade em overload de %.",
                                "Implementar overload imutável de // com testes passando.",
                                "Citar 3 referências bibliográficas relevantes.",
                                "Refatorar código legado para seguir boas práticas.",
                                "Passar em quiz de 10 perguntas sobre tópicos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de limitações (90% acerto).",
                                "Profundidade na análise de legibilidade com exemplos concretos.",
                                "Adesão rigorosa a imutabilidade nos códigos implementados.",
                                "Qualidade e relevância das referências citadas.",
                                "Clareza e estrutura no resumo final.",
                                "Criatividade em aplicações práticas demonstradas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Semântica de operadores aritméticos como // e %.",
                                "Design de Software: Princípios SOLID (Single Responsibility em overloads).",
                                "Ética em Programação: Priorizar legibilidade para equipes colaborativas.",
                                "Linguística: Analogia com sobrecarga semântica em linguagem natural."
                              ],
                              "realWorldApplication": "Em bibliotecas como NumPy, overload de + e * em arrays permite sintaxe intuitiva sem mutações inesperadas, facilitando data science; violações levam a bugs caros em produção, como em finanças onde imutabilidade previne erros de cálculo cumulativos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.6.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.6.3.4",
                            "name": "Depurar erros comuns em sobrecarga",
                            "description": "Diagnosticar e corrigir problemas como TypeError em operações mistas, falhas em __hash__ com __eq__, e comportamentos inesperados em chains de operadores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Reproduzir Erros Comuns em Sobrecarga",
                                  "subSteps": [
                                    "Revise o código da classe com operadores sobrecarregados (__add__, __eq__, etc.).",
                                    "Execute o código com entradas mistas (ex: objeto + int) para reproduzir TypeError.",
                                    "Registre o traceback completo usando print ou logging.",
                                    "Identifique padrões: TypeError em ops mistas, AttributeError em chains.",
                                    "Crie um teste unitário mínimo que falhe consistentemente."
                                  ],
                                  "verification": "O erro é reproduzível em um teste unitário isolado com traceback claro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código (VS Code/PyCharm), Python interpreter, unittest ou pytest.",
                                  "tips": "Use `pdb` ou breakpoints para pausar na falha.",
                                  "learningObjective": "Reproduzir erros para isolar problemas em sobrecarga.",
                                  "commonMistakes": "Ignorar tipos mistos; não isolar o teste."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diagnosticar Causas Raiz via Traceback e Inspeção",
                                  "subSteps": [
                                    "Analise o traceback: localize linha exata do operador chamado.",
                                    "Inspecione assinaturas: verifique se self/other são compatíveis.",
                                    "Para __eq__/__hash__: cheque se ambos implementados corretamente.",
                                    "Teste chains: exiba tipos com isinstance() em pontos chave.",
                                    "Use debugger para inspecionar frames de pilha."
                                  ],
                                  "verification": "Documente causa raiz em comentário (ex: 'TypeError: unsupported operand type(s)').",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Debugger (pdb, ipdb), logging module, type hints.",
                                  "tips": "Adicione assert isinstance(other, MyClass) temporariamente.",
                                  "learningObjective": "Mapear tracebacks a falhas específicas em overload.",
                                  "commonMistakes": "Confundir self/other; ignorar herança."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar Correções com Casos Edge",
                                  "subSteps": [
                                    "Escreva testes para ops mistas, chains, eq/hash (use hash(obj) == hash(obj2)).",
                                    "Teste edge: None, subclasses, imutabilidade.",
                                    "Meça performance se aplicável (timeit).",
                                    "Execute coverage >90% nos métodos overload.",
                                    "Simule uso real em script maior."
                                  ],
                                  "verification": "Todos testes passam; coverage relatório confirma.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "pytest, pytest-cov, mock library.",
                                  "tips": "Use parametrize para múltiplos tipos.",
                                  "learningObjective": "Garantir robustez pós-correção.",
                                  "commonMistakes": "Testes insuficientes; ignorar subclasses."
                                }
                              ],
                              "practicalExample": "Classe Vetor2D com __add__ falhando em Vetor2D + tuple: TypeError. Correção: if isinstance(other, tuple): other = Vetor2D(*other). Para __eq__/__hash__: def __hash__(self): return hash((self.x, self.y)); teste hash(v1) == hash(v2) if v1 == v2.",
                              "finalVerifications": [
                                "TypeError resolvido em ops mistas sem crashes.",
                                "__eq__ e __hash__ consistentes em dict/set.",
                                "Chains de operadores (a + b == c) funcionam.",
                                "Testes unitários passam 100%.",
                                "Sem warnings de mypy ou pylint.",
                                "Performance aceitável em loops."
                              ],
                              "assessmentCriteria": [
                                "Diagnóstico preciso da causa raiz (80% traceback análise).",
                                "Correção idiomática Python (sem hacks).",
                                "Cobertura de testes >90% com edges.",
                                "Documentação clara em código/testes.",
                                "Eficiência: tempo de execução similar a built-ins.",
                                "Generalização: funciona para subclasses."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear em vetores/matrices overload.",
                                "Lógica: Equivalência e transitividade em __eq__.",
                                "Ciência da Computação: Hash tables e colisões.",
                                "Design de Software: SOLID principles em overload."
                              ],
                              "realWorldApplication": "Bibliotecas como NumPy/SymPy usam overload para ops vetoriais eficientes; data pipelines custom com classes seguras para ETL sem erros de tipo em merges."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.6.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.5",
                "name": "Métodos e Variáveis Estáticas",
                "description": "Declaração e uso de métodos e variáveis estáticas em classes.",
                "totalSkills": 36,
                "atomicTopics": [
                  {
                    "id": "10.1.5.1",
                    "name": "Declaração de Variáveis Estáticas",
                    "description": "Como declarar variáveis estáticas em uma classe, incluindo sintaxe e modificadores de acesso.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.1.1",
                        "name": "Definição e Propósito de Variáveis Estáticas",
                        "description": "Compreender o conceito de variáveis estáticas como atributos pertencentes à classe, compartilhados por todas as instâncias, e seu uso para armazenar dados comuns a todos os objetos da classe.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.1",
                            "name": "Diferenciar variáveis de instância e variáveis estáticas",
                            "description": "Identificar e explicar a diferença entre variáveis de instância (específicas de cada objeto) e variáveis estáticas (compartilhadas pela classe), incluindo exemplos em linguagens como Java, C++ ou Python (atributos de classe).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Variáveis de Instância",
                                  "subSteps": [
                                    "Defina variáveis de instância como atributos únicos para cada objeto criado a partir da classe.",
                                    "Identifique que elas são declaradas sem modificador 'static' e pertencem a uma instância específica.",
                                    "Observe que cada objeto tem seu próprio valor para essas variáveis.",
                                    "Analise um exemplo simples em Java: 'private int id;' em uma classe Pessoa.",
                                    "Compare com linguagens como Python: self.id em métodos de instância."
                                  ],
                                  "verification": "Crie uma classe com uma variável de instância e instancie dois objetos; verifique se cada um tem valor independente alterando um sem afetar o outro.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (IDE como IntelliJ ou VS Code)",
                                    "Documentação de Java ou Python sobre OOP"
                                  ],
                                  "tips": "Sempre pense em 'cada objeto tem sua cópia própria'.",
                                  "learningObjective": "Explicar o conceito e características das variáveis de instância com exemplos.",
                                  "commonMistakes": [
                                    "Confundir com variáveis locais do método",
                                    "Acessar sem instância do objeto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender Variáveis Estáticas",
                                  "subSteps": [
                                    "Defina variáveis estáticas como atributos compartilhados por todos os objetos da classe, declarados com 'static'.",
                                    "Identifique que pertencem à classe, não a instâncias individuais.",
                                    "Observe que há apenas uma cópia na memória, acessível via nome da classe.",
                                    "Analise exemplo em Java: 'private static int contador = 0;' em uma classe.",
                                    "Compare com Python: '@classmethod' ou variáveis no escopo da classe."
                                  ],
                                  "verification": "Adicione uma variável estática a uma classe, crie múltiplos objetos e altere via um objeto; confirme que todos veem a mudança.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Referências OOP para C++ (static members)"
                                  ],
                                  "tips": "Pense nelas como 'propriedade comum da classe inteira'.",
                                  "learningObjective": "Descrever o propósito e comportamento das variáveis estáticas.",
                                  "commonMistakes": [
                                    "Acessar via instância em vez de classe",
                                    "Usar para dados únicos por objeto"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Diferenças Chave",
                                  "subSteps": [
                                    "Compare escopo: instância (por objeto) vs. estática (por classe).",
                                    "Analise memória: múltiplas cópias vs. única cópia compartilhada.",
                                    "Discuta acesso: via objeto vs. via classe (ex: Classe.varStatic).",
                                    "Liste usos: instância para estados únicos, estática para contadores ou constantes.",
                                    "Crie uma tabela comparativa incluindo exemplos em Java e Python."
                                  ],
                                  "verification": "Preencha uma tabela de diferenças e explique verbalmente ou por escrito para um par.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel ou ferramenta de tabela (Google Sheets)",
                                    "Exemplos de código preparados"
                                  ],
                                  "tips": "Use diagramas de memória para visualizar cópias.",
                                  "learningObjective": "Diferenciar precisamente os dois tipos em termos de comportamento e uso.",
                                  "commonMistakes": [
                                    "Ignorar impacto na memória ou thread-safety",
                                    "Confundir com métodos estáticos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar com Exemplos e Testes",
                                  "subSteps": [
                                    "Implemente uma classe Carro com id (instância) e totalCarros (estática).",
                                    "Crie 3 objetos, altere ids individualmente e incremente totalCarros.",
                                    "Teste em Java; adapte para Python usando atributos de classe.",
                                    "Debugue cenários onde confundir os tipos causa erros.",
                                    "Refatore código existente para usar o tipo correto."
                                  ],
                                  "verification": "Execute o código e capture saída mostrando comportamentos distintos; sem erros de compilação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE com compilador Java/Python",
                                    "Terminal para execução"
                                  ],
                                  "tips": "Compile e rode múltiplas vezes para observar consistência.",
                                  "learningObjective": "Aplicar conceitos em código funcional e debugar diferenças.",
                                  "commonMistakes": [
                                    "Esquecer 'static' keyword",
                                    "Inicializar estática incorretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Java: classe Conta { private int saldo; // instância private static int totalContas = 0; // estática }. Crie c1 e c2: c1.saldo=100; totalContas++ via Conta.totalContas. Saída: c1 e c2 têm saldos independentes, mas totalContas é 2 para ambos.",
                              "finalVerifications": [
                                "Explicar verbalmente a diferença sem hesitação.",
                                "Identificar corretamente variáveis estáticas em código fornecido.",
                                "Prever saída de programa com ambos os tipos.",
                                "Refatorar código misturando tipos para correção.",
                                "Discutir prós/contras de cada em um cenário dado.",
                                "Comparar sintaxe em duas linguagens."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e exemplos (90% correto).",
                                "Demonstração prática via código executável.",
                                "Compreensão de implicações em memória e acesso.",
                                "Identificação correta em código alheio.",
                                "Uso apropriado em contexto real.",
                                "Clareza na explicação comparativa."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Variáveis globais vs. locais em funções.",
                                "Física: Propriedades individuais (posição) vs. constantes universais (G).",
                                "Biologia: Atributos individuais (DNA único) vs. características da espécie.",
                                "Economia: Contas pessoais vs. taxa de juros global."
                              ],
                              "realWorldApplication": "Em apps bancários, variáveis de instância para saldo de cada conta; estáticas para contador de transações totais ou configurações globais como taxa de juros padrão, garantindo eficiência e consistência."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.2",
                            "name": "Identificar cenários de uso de variáveis estáticas",
                            "description": "Reconhecer situações práticas onde variáveis estáticas são apropriadas, como contadores de instâncias criados ou constantes de classe, com exemplos como um contador de objetos em uma classe.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definição e características de variáveis estáticas",
                                  "subSteps": [
                                    "Ler a definição oficial de variáveis estáticas: pertencem à classe, não à instância, compartilhadas por todas as instâncias.",
                                    "Identificar palavras-chave: 'static' em linguagens como Java ou C++.",
                                    "Listar propriedades: inicializadas uma vez, valor comum a todas instâncias, acessíveis via nome da classe.",
                                    "Comparar lifecycle: persistem durante toda a execução da classe, ao contrário de variáveis de instância.",
                                    "Anotar sintaxe básica: ex. 'static int contador;' em uma classe."
                                  ],
                                  "verification": "Criar um resumo de 3-5 frases explicando o que são variáveis estáticas e suas diferenças com variáveis de instância.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial da linguagem (ex: Java Docs)",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Use diagramas de Venn para visualizar compartilhamento vs. individualidade.",
                                  "learningObjective": "Compreender as propriedades fundamentais das variáveis estáticas.",
                                  "commonMistakes": [
                                    "Confundir com variáveis globais",
                                    "Achar que são reinicializadas por instância",
                                    "Ignorar acesso via classe"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar cenários de uso de variáveis estáticas vs. de instância",
                                  "subSteps": [
                                    "Analisar código exemplo: classe sem static vs. com static contador.",
                                    "Perguntar: 'O valor precisa ser único por objeto ou compartilhado?'",
                                    "Classificar 5 exemplos: ID único (instância), total de objetos (estática).",
                                    "Discutir quando NÃO usar static: dados mutáveis por instância.",
                                    "Criar tabela comparativa: colunas 'Estática', 'Instância', linhas 'Uso', 'Exemplo'."
                                  ],
                                  "verification": "Preencher tabela com 4 cenários corretamente classificados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de código em IDE (ex: IntelliJ, VS Code)",
                                    "Papel e caneta para tabela"
                                  ],
                                  "tips": "Pense em 'um para todos' para static, 'cada um o seu' para instância.",
                                  "learningObjective": "Distinguir contextos onde static é apropriada.",
                                  "commonMistakes": [
                                    "Usar static para dados exclusivos de instância",
                                    "Subestimar problemas de concorrência em static mutáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar cenários práticos comuns para variáveis estáticas",
                                  "subSteps": [
                                    "Listar cenários: 1) Contador de instâncias criadas; 2) Constantes de classe (ex: PI); 3) Cache compartilhado; 4) Contador de acessos.",
                                    "Analisar cada um: por que static? (Compartilhado, economiza memória).",
                                    "Pesquisar exemplos reais: Singleton pattern, logging counters.",
                                    "Simular: Criar pseudocódigo para contador de objetos em classe 'Carro'.",
                                    "Avaliar alternativas: por que não variável global ou instância?"
                                  ],
                                  "verification": "Listar e justificar 3 cenários válidos com pseudocódigo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pseudocódigo templates",
                                    "Fórum Stack Overflow para exemplos reais"
                                  ],
                                  "tips": "Foque em 'estado compartilhado' como chave para identificar uso.",
                                  "learningObjective": "Reconhecer situações onde static resolve problemas de compartilhamento.",
                                  "commonMistakes": [
                                    "Usar static para tudo compartilhado sem considerar thread-safety",
                                    "Confundir com métodos estáticos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação em códigos reais e contra-exemplos",
                                  "subSteps": [
                                    "Analisar 3 trechos de código: um com static correto, um incorreto, um sem static.",
                                    "Identificar: 'Este é cenário para static? Justifique.'",
                                    "Corrigir código incorreto adicionando/removendo static.",
                                    "Criar próprio exemplo: classe 'Aluno' com contador de matrículas.",
                                    "Testar em IDE: compilar e executar para ver comportamento."
                                  ],
                                  "verification": "Corrigir 2 códigos e executar com output esperado (ex: contador incrementa corretamente).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "IDE com suporte a OOP (Java/C#)",
                                    "Códigos de exemplo preparados"
                                  ],
                                  "tips": "Execute o código múltiplas vezes criando várias instâncias para validar.",
                                  "learningObjective": "Aplicar identificação em contextos reais de código.",
                                  "commonMistakes": [
                                    "Não testar com múltiplas instâncias",
                                    "Ignorar inicialização única"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma classe 'Funcionario', use uma variável estática 'contadorInstancias' para contar quantos funcionários foram criados: static int contadorInstancias = 0; No construtor: contadorInstancias++; Assim, ao criar 5 objetos, contadorInstancias == 5 para todos.",
                              "finalVerifications": [
                                "Listar 4 cenários válidos para static com justificativa.",
                                "Analisar código e identificar corretamente uso de static em 90% dos casos.",
                                "Explicar diferença entre static e instância sem erros.",
                                "Criar exemplo funcional de contador de instâncias.",
                                "Identificar 2 contra-exemplos onde static NÃO deve ser usado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de cenários (80%+ acertos).",
                                "Justificativas claras e lógicas baseadas em compartilhamento.",
                                "Uso correto de exemplos reais sem confusões conceituais.",
                                "Capacidade de corrigir códigos com static adequadamente.",
                                "Demonstração prática via código executável."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Contadores e acumuladores em algoritmos.",
                                "Banco de Dados: IDs sequenciais compartilhados como auto-increment.",
                                "Design de Software: Padrões como Singleton que usam static.",
                                "Concorrência: Thread-safety em variáveis compartilhadas."
                              ],
                              "realWorldApplication": "Em sistemas empresariais, contadores estáticos rastreiam total de usuários cadastrados sem duplicar dados por usuário; em jogos, contam inimigos spawnados globalmente; em apps web, caches estáticos otimizam performance compartilhando dados entre sessões."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.3",
                            "name": "Explicar o ciclo de vida de variáveis estáticas",
                            "description": "Descrever como variáveis estáticas são inicializadas na carga da classe e persistem durante toda a execução do programa, independentemente da criação ou destruição de instâncias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a declaração e o escopo de variáveis estáticas",
                                  "subSteps": [
                                    "Leia a sintaxe de declaração: 'static tipo nome;' em uma classe.",
                                    "Identifique que variáveis estáticas pertencem à classe, não a instâncias.",
                                    "Compare com variáveis de instância (non-static) em termos de alocação de memória.",
                                    "Analise o modificador 'static' e seu impacto no heap (área estática da JVM).",
                                    "Escreva um exemplo simples de declaração estática."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre static e non-static, citando um exemplo de código.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial da linguagem (ex: Java static variables)",
                                    "Editor de código como IntelliJ ou VS Code",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Visualize a classe como um blueprint: static é compartilhado por todos os objetos criados a partir dele.",
                                  "learningObjective": "Diferenciar declaração e escopo de variáveis estáticas versus de instância.",
                                  "commonMistakes": [
                                    "Confundir 'static' com 'final' (imutável)",
                                    "Achar que static precisa de instância para acesso",
                                    "Ignorar que static é carregada uma vez por classe"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a inicialização durante a carga da classe",
                                  "subSteps": [
                                    "Estude o processo de carregamento de classe pela JVM/CLR: load, link, initialize.",
                                    "Identifique que static fields são inicializados na fase 'initialize' da classe.",
                                    "Teste com código: crie uma classe com static int x = 10; e acesse sem instância.",
                                    "Observe o timing: inicialização ocorre na primeira referência à classe.",
                                    "Registre logs ou use debugger para ver o momento exato da inicialização.",
                                    "Analise inicializadores estáticos (static blocks)."
                                  ],
                                  "verification": "Execute código e confirme que o valor estático é setado antes de qualquer instância ser criada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE com debugger (Eclipse, IntelliJ)",
                                    "Código-fonte de exemplo com static block",
                                    "Referência JVM spec sobre class loading"
                                  ],
                                  "tips": "Use System.out.println em static block para ver 'Eu fui inicializado!' na primeira chamada.",
                                  "learningObjective": "Descrever precisamente quando e como variáveis estáticas são inicializadas.",
                                  "commonMistakes": [
                                    "Pensar que inicialização ocorre no construtor",
                                    "Confundir com lazy initialization",
                                    "Ignorar ordem de inicialização em herança"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a persistência e o ciclo de vida durante a execução",
                                  "subSteps": [
                                    "Crie múltiplas instâncias e modifique a variável estática para ver persistência.",
                                    "Monitore o ciclo: permanece viva até o fim da JVM (unload da classe).",
                                    "Compare lifetime: static vs instância (destruída com garbage collection).",
                                    "Teste cenários: modifique em threads diferentes para ver compartilhamento.",
                                    "Discuta unload de classe (raro, mas possível em classloaders dinâmicos).",
                                    "Registre mudanças em um log para visualizar persistência."
                                  ],
                                  "verification": "Crie 3 instâncias, incremente static counter em cada; verifique valor único compartilhado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplo de código com contador estático",
                                    "Ferramenta de profiling como VisualVM"
                                  ],
                                  "tips": "Lembre: static vive no Metaspace/PermGen, não no heap de objetos.",
                                  "learningObjective": "Explicar como static persiste independentemente de instâncias.",
                                  "commonMistakes": [
                                    "Achar que static é resetada por new objeto()",
                                    "Confundir com variáveis locais",
                                    "Subestimar impactos em multithreading"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e verificar o ciclo completo com exemplos práticos",
                                  "subSteps": [
                                    "Implemente um contador de instâncias usando static.",
                                    "Simule destruição de instâncias (set null e GC) e confirme static intacta.",
                                    "Adicione static block para custom init e teste ordem.",
                                    "Compare com non-static em um programa completo.",
                                    "Debate edge cases: herança, interfaces, aninhadas classes."
                                  ],
                                  "verification": "Escreva um relatório curto resumindo o ciclo de vida observado no código executado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código completo de teste",
                                    "Debugger",
                                    "Documentação sobre classloaders"
                                  ],
                                  "tips": "Use -XX:+TraceClassLoading para logs de carregamento na JVM.",
                                  "learningObjective": "Integrar conceitos em um exemplo funcional e identificar ciclo completo.",
                                  "commonMistakes": [
                                    "Esquecer thread-safety (use volatile/synchronized)",
                                    "Não testar unload",
                                    "Ignorar static em lambdas/inner classes"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe Counter com 'private static int count = 0;' e no construtor 'count++;'. Instancie 5 objetos: o count final será 5 para todos, inicializado na carga da classe e persistindo até o fim do programa, mesmo após objetos serem destruídos.",
                              "finalVerifications": [
                                "Descreva o momento exato de inicialização de uma static variable.",
                                "Explique por que modificar uma static afeta todas as instâncias.",
                                "Diferencie lifetime de static vs instância com diagrama de memória.",
                                "Identifique quando uma static é destruída (fim da JVM).",
                                "Teste e confirme com código: static block executa apenas uma vez.",
                                "Discuta impacto de múltiplos classloaders."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da fase de inicialização (carga da classe).",
                                "Correta explicação de persistência independente de instâncias.",
                                "Uso de exemplos de código funcionais sem erros.",
                                "Identificação de erros comuns como confusão com construtores.",
                                "Capacidade de diagramar ciclo de vida em memória.",
                                "Análise de cenários edge como multithreading."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de contadores cumulativos e funções globais.",
                                "Física: Simulações com constantes globais (ex: gravidade em um universo simulado).",
                                "Engenharia de Software: Padrões como Singleton para recursos compartilhados.",
                                "Banco de Dados: Conceitos de variáveis de sessão globais vs por conexão."
                              ],
                              "realWorldApplication": "Em aplicações web, variáveis estáticas rastreiam métricas globais como 'total de usuários logados' ou caches compartilhados, persistindo durante a vida do servidor sem recriação por requisição, otimizando performance em sistemas como logs de auditoria ou contadores de sessões."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.2",
                        "name": "Sintaxe de Declaração de Variáveis Estáticas",
                        "description": "Dominar a sintaxe exata para declarar variáveis estáticas em classes, considerando linguagens como Java/C++ (com palavra-chave 'static') e Python (atributos de classe).",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.2.1",
                            "name": "Escrever sintaxe básica de variável estática",
                            "description": "Declarar uma variável estática simples em uma classe, como 'private static int contador = 0;' em Java ou 'contador = 0' no nível da classe em Python, explicando cada elemento da sintaxe.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes da sintaxe de variável estática em Java",
                                  "subSteps": [
                                    "Identifique o modificador de acesso (ex: private, public).",
                                    "Explique o keyword 'static', que indica que a variável pertence à classe.",
                                    "Defina o tipo de dado (ex: int, String).",
                                    "Escolha um nome descritivo para a variável.",
                                    "Aprenda a inicializar com um valor (ex: = 0)."
                                  ],
                                  "verification": "Liste e descreva corretamente os 5 componentes da sintaxe em um papel ou editor.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Documentação oficial do Java (Oracle Docs)",
                                    "Editor de texto simples"
                                  ],
                                  "tips": [
                                    "Lembre-se: 'static' permite acesso sem instância da classe.",
                                    "Use nomes em camelCase para variáveis."
                                  ],
                                  "learningObjective": "Identificar e explicar cada elemento da declaração de variável estática em Java.",
                                  "commonMistakes": [
                                    "Confundir 'static' com variáveis de instância.",
                                    "Esquecer o ponto e vírgula no final.",
                                    "Usar tipo incorreto sem import."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever e validar a declaração básica em Java",
                                  "subSteps": [
                                    "Crie uma classe simples (ex: public class Exemplo {}).",
                                    "Declare dentro da classe: private static int contador = 0;.",
                                    "Compile o código usando javac no terminal.",
                                    "Acesse a variável via classe (Exemplo.contador).",
                                    "Corrija erros de sintaxe se houver."
                                  ],
                                  "verification": "O código compila sem erros e a variável é acessível estaticamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "JDK instalado",
                                    "Editor de código (Eclipse ou VS Code)",
                                    "Terminal/Command Prompt"
                                  ],
                                  "tips": [
                                    "Sempre declare dentro da classe, fora de métodos.",
                                    "Teste com System.out.println para verificar."
                                  ],
                                  "learningObjective": "Produzir uma declaração sintaticamente correta de variável estática em Java.",
                                  "commonMistakes": [
                                    "Declarar dentro de um método (torna local).",
                                    "Omitir 'static' (torna variável de instância).",
                                    "Erro de escopo sem modificador de acesso."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a sintaxe equivalente em Python",
                                  "subSteps": [
                                    "Crie uma classe em Python (class MinhaClasse:).",
                                    "Declare a variável no nível da classe: contador = 0 (sem 'static').",
                                    "Acesse via instância ou classe (MinhaClasse.contador).",
                                    "Compare diferenças: Python usa convenção de classe compartilhada.",
                                    "Teste modificando o valor em múltiplas instâncias."
                                  ],
                                  "verification": "Execute o código Python e confirme que o valor é compartilhado entre instâncias.",
                                  "estimatedTime": "12 minutos",
                                  "materials": [
                                    "Python 3 instalado",
                                    "Editor como PyCharm ou IDLE",
                                    "Terminal"
                                  ],
                                  "tips": [
                                    "Em Python, variáveis de classe são 'estáticas' por padrão.",
                                    "Use self.__class__.contador para acesso explícito."
                                  ],
                                  "learningObjective": "Adaptar a sintaxe de variável estática para Python e entender as diferenças.",
                                  "commonMistakes": [
                                    "Adicionar 'static' desnecessariamente em Python.",
                                    "Confundir com variáveis de instância (self.contador).",
                                    "Não indentar corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e integrar a variável estática em um exemplo prático",
                                  "subSteps": [
                                    "Crie uma classe com método que incrementa o contador estático.",
                                    "Instancie múltiplos objetos e chame o método.",
                                    "Verifique se o contador é compartilhado.",
                                    "Adicione getter estático para acessar o valor.",
                                    "Execute e depure se necessário."
                                  ],
                                  "verification": "O contador incrementa corretamente para todas as instâncias, mostrando comportamento estático.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ambiente de desenvolvimento Java/Python",
                                    "Exemplos de código online (GeeksforGeeks)"
                                  ],
                                  "tips": [
                                    "Use métodos estáticos para manipular variáveis estáticas.",
                                    "Evite mutação direta para thread-safety."
                                  ],
                                  "learningObjective": "Aplicar variável estática em código funcional e validar seu comportamento.",
                                  "commonMistakes": [
                                    "Acessar via instância em vez de classe.",
                                    "Inicializar múltiplas vezes.",
                                    "Ignorar concorrência em apps multi-thread."
                                  ]
                                }
                              ],
                              "practicalExample": "Em Java: public class Contador { private static int total = 0; public static void incrementar() { total++; } } - Chame Contador.incrementar() de qualquer lugar para contar eventos globais. Em Python: class Contador: total = 0 def incrementar(cls): cls.total += 1",
                              "finalVerifications": [
                                "Declara corretamente 'private static int contador = 0;' em Java sem erros.",
                                "Explica a diferença de sintaxe entre Java e Python.",
                                "Código compila/executa e demonstra compartilhamento entre instâncias.",
                                "Identifica e corrige erros comuns como falta de 'static'.",
                                "Acessa a variável via nome da classe.",
                                "Integra em um método estático funcional."
                              ],
                              "assessmentCriteria": [
                                "Precisão da sintaxe: todos os componentes corretos (100%).",
                                "Compreensão conceitual: explica 'static' vs instância.",
                                "Funcionalidade: código executável e testa comportamento.",
                                "Comparação linguagens: destaca diferenças Java/Python.",
                                "Boas práticas: usa modificadores adequados e nomes descritivos.",
                                "Tratamento de erros: identifica e evita pitfalls comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Uso de contadores para sequências numéricas e aritmética.",
                                "Lógica e Algoritmos: Gerenciamento de estado global em fluxos de dados.",
                                "Física/Engenharia: Modelagem de constantes universais (ex: pi em simulações).",
                                "Banco de Dados: Conceito similar a variáveis de sessão globais."
                              ],
                              "realWorldApplication": "Em aplicações web, contadores estáticos rastreiam sessões ativas ou visitas totais sem duplicação de dados por usuário; em jogos, pontuações globais; em sistemas empresariais, IDs sequenciais únicos compartilhados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.2.2",
                            "name": "Declarar variáveis estáticas com tipos primitivos e de referência",
                            "description": "Criar declarações para variáveis estáticas de tipos primitivos (int, double) e de referência (String, arrays, objetos), incluindo inicialização inline, como 'public static String NOME_CLASSE = \"Exemplo\";'.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os conceitos fundamentais de variáveis estáticas",
                                  "subSteps": [
                                    "Leia a definição de variável estática: pertence à classe, não a instâncias, compartilhada por todos os objetos.",
                                    "Compare com variáveis de instância: estáticas são inicializadas uma vez, acessíveis via nome da classe.",
                                    "Estude modificadores: 'public static' para visibilidade global e compartilhamento.",
                                    "Revise tipos primitivos (int, double, boolean) vs. referência (String, int[], Object).",
                                    "Anote diferenças em inicialização inline: = valor para primitivos, = new ou literal para referências."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos chave e identifique 2 exemplos de cada tipo em um diagrama mental.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Java: Modificadores de acesso e static",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Use analogia: estática como 'propriedade do prédio' vs. instância como 'móvel do apartamento'.",
                                  "learningObjective": "Compreender o propósito e escopo de variáveis estáticas em OOP.",
                                  "commonMistakes": [
                                    "Confundir static com final (imutável)",
                                    "Esquecer que static não precisa de objeto para acesso"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Praticar declaração de variáveis estáticas com tipos primitivos",
                                  "subSteps": [
                                    "Crie uma classe Java vazia chamada StaticPrimitives.",
                                    "Declare 'public static int MAX_VALUE = 100;' e 'public static double PI = 3.14159;'.",
                                    "Acesse via System.out.println(StaticPrimitives.PI); sem instanciar.",
                                    "Teste compilação e execução em IDE.",
                                    "Adicione boolean e char: 'public static boolean IS_ACTIVE = true;'."
                                  ],
                                  "verification": "Código compila e imprime valores corretos sem erros de compilação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE como IntelliJ ou Eclipse",
                                    "Compilador Java JDK 8+"
                                  ],
                                  "tips": "Sempre use minúsculas para nomes de variáveis, maiúsculas SNAKE_CASE para constantes.",
                                  "learningObjective": "Dominar sintaxe exata para primitivos estáticos com inicialização inline.",
                                  "commonMistakes": [
                                    "Omitir 'static'",
                                    "Usar new para primitivos",
                                    "Erro de ponto e vírgula"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Declarar variáveis estáticas de tipos de referência",
                                  "subSteps": [
                                    "Na mesma classe, declare 'public static String CLASS_NAME = \"MinhaClasse\";'.",
                                    "Crie array: 'public static int[] SCORES = {90, 85, 95};'.",
                                    "Declare objeto simples: 'public static java.util.ArrayList<String> NAMES = new java.util.ArrayList<>();'.",
                                    "Inicialize array de objetos: 'public static String[] OPTIONS = {\"A\", \"B\"};'.",
                                    "Acesse e imprima: System.out.println(StaticPrimitives.CLASS_NAME.length());."
                                  ],
                                  "verification": "Valores são acessíveis e manipuláveis sem NullPointerException.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE com auto-complete",
                                    "Referência Oracle Java: Arrays e Strings"
                                  ],
                                  "tips": "Para referências, lembre que 'static' compartilha a referência; inicialize para evitar null.",
                                  "learningObjective": "Aplicar sintaxe para Strings, arrays e objetos estáticos.",
                                  "commonMistakes": [
                                    "Não importar classes necessárias",
                                    "Confundir inicialização de array com new int[3]",
                                    "Acessar como instância"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e refatorar declarações estáticas completas",
                                  "subSteps": [
                                    "Combine tudo em uma classe utilitária com múltiplas estáticas.",
                                    "Adicione método main para demonstrar acesso: ex. imprimir todas variáveis.",
                                    "Refatore para usar final onde apropriado: 'public static final int MAX = 100;'.",
                                    "Teste cenários: múltiplas classes acessando as mesmas estáticas.",
                                    "Corrija erros e documente com Javadoc."
                                  ],
                                  "verification": "Programa roda sem erros, todas variáveis acessíveis de classes diferentes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE debugger",
                                    "Exemplos de código de repositórios GitHub"
                                  ],
                                  "tips": "Use static para configurações globais, evite para dados mutáveis.",
                                  "learningObjective": "Integrar declarações em código funcional e identificar melhores práticas.",
                                  "commonMistakes": [
                                    "Violação de encapsulamento com public",
                                    "Inicializar referências vazias sem new"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma classe Calculadora: public static final double PI = 3.14159; public static String APP_VERSION = \"1.0\"; public static int[] FATTORES = {1, 2, 3}; Acesse como Calculadora.PI em qualquer lugar.",
                              "finalVerifications": [
                                "Código declara corretamente 3 primitivos e 3 referências estáticas.",
                                "Compilação sem warnings de 'unused' ou sintaxe.",
                                "Acesso via nome da classe sem instância funciona.",
                                "Inicializações inline são usadas corretamente.",
                                "Nenhum NullPointer ao acessar referências.",
                                "Uso de final para constantes imutáveis."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe 100% precisa (modificadores, tipos, inicialização).",
                                "Diferenciação clara entre primitivos e referências.",
                                "Acesso correto sem dependência de objetos.",
                                "Código limpo, legível com convenções de nomenclatura.",
                                "Tratamento de edge cases como arrays vazios.",
                                "Integração em classe funcional sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Constantes como PI para cálculos numéricos.",
                                "Língua Portuguesa: Strings para mensagens e labels em apps.",
                                "Física: Arrays de dados experimentais estáticos.",
                                "Banco de Dados: Configurações de conexão compartilhadas."
                              ],
                              "realWorldApplication": "Em frameworks como Spring, constantes estáticas definem configurações de app (ex. URL de API); em jogos, scores globais ou níveis; em utils, valores fixos como tamanhos de buffers para performance."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.2.3",
                            "name": "Comparar sintaxe em diferentes linguagens OO",
                            "description": "Contrastar a declaração em Java/C++ ('static tipo nome;') com Python ('self.__class__.nome = valor' ou atributo de classe direto), destacando peculiaridades como ausência de 'static' explícito em Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a sintaxe de declaração de variáveis estáticas em Java e C++",
                                  "subSteps": [
                                    "Revise a sintaxe básica: 'static tipo nome;' dentro de uma classe.",
                                    "Compile e execute um exemplo simples em Java: declare uma variável static int count = 0; em uma classe.",
                                    "Repita o processo em C++: use 'static int count = 0;' dentro de uma classe ou função.",
                                    "Observe o escopo: variáveis estáticas pertencem à classe, não à instância.",
                                    "Teste acessando via nomeDaClasse.nome em Java e similar em C++."
                                  ],
                                  "verification": "Execute o código e confirme que todas as instâncias compartilham o mesmo valor da variável static.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "IDEs como IntelliJ para Java, Visual Studio para C++; documentação oficial de Java e C++.",
                                  "tips": "Use System.out.println em Java e std::cout em C++ para imprimir valores e visualizar compartilhamento.",
                                  "learningObjective": "Dominar a sintaxe explícita 'static' em linguagens compiladas como Java e C++.",
                                  "commonMistakes": "Esquecer o modificador 'static' (torna variável de instância); acessar via instância em vez de classe."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a sintaxe de atributos de classe em Python",
                                  "subSteps": [
                                    "Declare um atributo de classe diretamente: class MinhaClasse: count = 0",
                                    "Acesse via MinhaClasse.count ou self.__class__.count dentro de métodos.",
                                    "Compare com self.count (atributo de instância) para diferenciar comportamentos.",
                                    "Teste modificação: altere MinhaClasse.count e veja o impacto em todas as instâncias.",
                                    "Experimente self.count = valor para shadowar o atributo de classe."
                                  ],
                                  "verification": "Crie múltiplas instâncias e confirme que mudanças no atributo de classe afetam todas, mas self.count cria um novo por instância.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor Python como PyCharm ou VS Code; REPL Python para testes rápidos.",
                                  "tips": "Use print(self.__class__.__dict__) para inspecionar atributos de classe dinamicamente.",
                                  "learningObjective": "Compreender que Python não requer 'static' explícito, usando convenções de namespace.",
                                  "commonMistakes": "Confundir atributos de classe com de instância; usar self.nome em vez de NomeDaClasse.nome."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar sintaxes lado a lado entre Java/C++, Python",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: sintaxe, escopo, acesso, modificação.",
                                    "Escreva código equivalente para um contador compartilhado em cada linguagem.",
                                    "Execute e compare saídas: destaque diferenças em declaração e acesso.",
                                    "Analise peculiaridades: tipagem estática vs dinâmica; compilação vs interpretação.",
                                    "Documente diferenças em um markdown ou notebook."
                                  ],
                                  "verification": "A tabela deve cobrir pelo menos 5 diferenças chave, com códigos executáveis comprovando cada uma.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramentas de código paralelo como GitHub Codespaces; tabelas em Google Docs ou Jupyter.",
                                  "tips": "Use diff tools ou side-by-side editors para visualizar códigos semelhantes.",
                                  "learningObjective": "Identificar contrastes fundamentais na sintaxe OO estática entre linguagens.",
                                  "commonMistakes": "Ignorar diferenças de tipagem; assumir sintaxe Python idêntica a Java."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar peculiaridades e cenários avançados",
                                  "subSteps": [
                                    "Estude shadowing em Python: self.nome vs classe.nome.",
                                    "Compare inicialização: Java/C++ permite = valor; Python também, mas dinâmico.",
                                    "Discuta ausência de 'static' em Python: convenção via atributos de classe.",
                                    "Teste em herança: como statics se comportam em subclasses.",
                                    "Resuma prós/contras: explicitude em Java vs flexibilidade em Python."
                                  ],
                                  "verification": "Escreva um relatório curto (200 palavras) listando 4 peculiaridades com exemplos de código.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação Python (dataclasses, descriptors); fóruns Stack Overflow para edge cases.",
                                  "tips": "Use dir() e vars() em Python para debugar namespaces.",
                                  "learningObjective": "Dominar nuances que vão além da sintaxe básica para uso real.",
                                  "commonMistakes": "Superestimar portabilidade de código; ignorar herança em statics."
                                }
                              ],
                              "practicalExample": "Implemente um contador de instâncias compartilhado: Em Java/C++, 'static int instanceCount = 0;' incrementado no construtor. Em Python, 'instanceCount = 0' na classe. Crie 3 instâncias, incremente e imprima: todas devem mostrar o mesmo count final (3).",
                              "finalVerifications": [
                                "Pode declarar corretamente static em Java/C++ e atributo de classe em Python.",
                                "Explica pelo menos 3 diferenças sintáticas com exemplos.",
                                "Identifica quando usar self.__class__.nome em Python.",
                                "Cria código funcional comparativo sem erros de compilação/execução.",
                                "Discute impacto de shadowing em Python vs Java.",
                                "Compara escopo e acesso em tabela clara."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sintaxe: 100% correta em todas linguagens.",
                                "Completude da comparação: cobre declaração, acesso, peculiaridades.",
                                "Profundidade de análise: inclui exemplos executáveis e edge cases.",
                                "Clareza na documentação: tabelas/diagramas legíveis.",
                                "Correção prática: códigos rodam sem erros e demonstram conceitos.",
                                "Originalidade: vai além de cópias, com insights pessoais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de variáveis globais vs locais em funções matemáticas.",
                                "Lógica/Algoritmos: Uso de contadores estáticos em recursão e iterações.",
                                "Design de Software: Padrões como Singleton dependem de statics.",
                                "Linguística: Analogia com gramáticas formais em sintaxes de programação."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software multi-plataforma, como bibliotecas de logging ou caches compartilhados em apps web (Spring Boot em Java, Django em Python), onde contadores estáticos rastreiam métricas globais sem duplicação por usuário."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.3",
                        "name": "Modificadores de Acesso para Variáveis Estáticas",
                        "description": "Aplicar modificadores de acesso (public, private, protected) às variáveis estáticas para controlar visibilidade e encapsulamento em classes.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.3.1",
                            "name": "Aplicar modificador public a variável estática",
                            "description": "Declarar e acessar uma variável estática pública de qualquer lugar, como 'public static final double PI = 3.14159;', explicando implicações de segurança e boas práticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os modificadores 'public' e 'static'",
                                  "subSteps": [
                                    "Leia a definição oficial de 'public': permite acesso irrestrito de qualquer classe ou pacote.",
                                    "Estude 'static': variáveis pertencem à classe, não à instância, acessíveis sem objeto.",
                                    "Compare com 'private static': acessível apenas dentro da classe.",
                                    "Analise exemplos de código simples para static vs instance variables.",
                                    "Identifique quando usar public static: constantes globais compartilhadas."
                                  ],
                                  "verification": "Escreva um parágrafo explicando a diferença entre public static e private static, com exemplos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação Oracle Java: Modificadores de Acesso",
                                    "Editor de código como IntelliJ ou VS Code"
                                  ],
                                  "tips": "Comece pela documentação oficial para evitar mitos comuns sobre visibilidade.",
                                  "learningObjective": "Explicar precisamente o impacto de 'public' e 'static' na acessibilidade e escopo de variáveis.",
                                  "commonMistakes": [
                                    "Confundir 'public' com 'protected'",
                                    "Acreditar que 'static' requer instanciação de objeto",
                                    "Ignorar que 'public static' expõe dados globalmente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar uma variável estática pública",
                                  "subSteps": [
                                    "Crie uma nova classe Java, ex: 'Constants.java'.",
                                    "Declare: 'public static final double PI = 3.14159;' dentro da classe.",
                                    "Adicione comentários explicando cada modificador.",
                                    "Compile o código para verificar erros de sintaxe.",
                                    "Teste declaração adicionando um método getter simples."
                                  ],
                                  "verification": "O código compila sem erros e a variável é declarada corretamente sem warnings.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "JDK instalado",
                                    "Editor de código com suporte a Java"
                                  ],
                                  "tips": "Sempre use 'final' para constantes imutáveis para reforçar boas práticas.",
                                  "learningObjective": "Criar sintaxe correta para variáveis public static, incluindo uso de 'final'.",
                                  "commonMistakes": [
                                    "Esquecer 'final' em constantes",
                                    "Usar tipo primitivo errado",
                                    "Colocar declaração fora da classe"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Acessar a variável de diferentes escopos",
                                  "subSteps": [
                                    "Na mesma classe, acesse via 'PI' diretamente.",
                                    "Crie outra classe e acesse via 'Constants.PI'.",
                                    "Instancie um objeto da classe Constants e teste acesso via objeto (deve funcionar igual).",
                                    "Compile e execute um main() que imprima o valor de PI de fora.",
                                    "Modifique o valor (se não final) e observe comportamento global."
                                  ],
                                  "verification": "Imprima o valor de PI de uma classe externa sem erros, confirmando acessibilidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Projeto Java com múltiplas classes",
                                    "Terminal para compilação e execução"
                                  ],
                                  "tips": "Use System.out.println para testes rápidos de acessibilidade.",
                                  "learningObjective": "Demonstrar acesso correto a public static de dentro e fora da classe.",
                                  "commonMistakes": [
                                    "Tentar acessar como instância obrigatória",
                                    "Erro de pacote ao importar",
                                    "Confundir nome da classe"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar implicações de segurança e boas práticas",
                                  "subSteps": [
                                    "Discuta riscos: qualquer código pode alterar (se não final), violando encapsulamento.",
                                    "Compare com alternativas: getters privados ou enums para constantes.",
                                    "Refatore para 'public static final' e teste imutabilidade.",
                                    "Pesquise exemplos reais como Math.PI e por quê public static final.",
                                    "Documente em comentários as melhores práticas para uso."
                                  ],
                                  "verification": "Escreva um relatório curto listando 3 riscos e 3 boas práticas para public static.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação Java: Best Practices",
                                    "Exemplos de código open-source"
                                  ],
                                  "tips": "Prefira 'final' sempre; considere ThreadLocal para multi-threading.",
                                  "learningObjective": "Avaliar trade-offs de segurança e manutenção em variáveis public static.",
                                  "commonMistakes": [
                                    "Ignorar multi-threading (static compartilhado)",
                                    "Expor dados sensíveis como senhas",
                                    "Não usar final em constantes"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe 'MathUtils' com 'public static final double PI = 3.14159;'. Em uma classe 'Circle', calcule área como 'MathUtils.PI * radius * radius' sem instanciar MathUtils, demonstrando acesso global e imutabilidade.",
                              "finalVerifications": [
                                "Código compila e executa acessando a variável de classe externa.",
                                "Variável mantém valor imutável (se final).",
                                "Acesso funciona sem instância de objeto.",
                                "Comentários explicam cada modificador.",
                                "Teste falha ao tentar modificar se final.",
                                "Relatório de segurança identifica pelo menos 2 riscos."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe 100% correta na declaração e acesso.",
                                "Explicação clara de visibilidade e escopo.",
                                "Identificação precisa de riscos de segurança.",
                                "Uso apropriado de 'final' para constantes.",
                                "Código limpo com comentários e boas práticas.",
                                "Testes demonstram compreensão prática."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Uso de constantes universais como π em cálculos.",
                                "Segurança da Informação: Princípios de controle de acesso e encapsulamento.",
                                "Design de Software: Padrões como Singleton e Factory para shared state.",
                                "Física/Engenharia: Constantes físicas globais em simulações."
                              ],
                              "realWorldApplication": "Bibliotecas padrão como java.lang.Math.PI para cálculos matemáticos compartilhados; contadores de sessões em aplicações web; configurações globais em frameworks como Spring, onde acesso irrestrito é intencional mas controlado por 'final'."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.3.2",
                            "name": "Usar modificador private com variáveis estáticas",
                            "description": "Declarar variáveis estáticas privadas e acessá-las via métodos getter/setter estáticos, como 'private static int total; public static int getTotal() { return total; }', promovendo encapsulamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e declarar variável estática private",
                                  "subSteps": [
                                    "Abra sua IDE Java (ex: IntelliJ ou Eclipse) e crie um novo projeto.",
                                    "Crie uma classe pública chamada 'Contador'.",
                                    "Declare uma variável estática private dentro da classe: 'private static int total = 0;'",
                                    "Compile o código para verificar ausência de erros.",
                                    "Adicione um comentário explicando o propósito: compartilhamento seguro entre instâncias."
                                  ],
                                  "verification": "O código compila sem erros e a variável é visível apenas dentro da classe.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "IDE Java (IntelliJ, Eclipse ou VS Code com extensão Java)",
                                    "JDK 8 ou superior"
                                  ],
                                  "tips": "Sempre inicialize a variável estática para evitar valores indefinidos.",
                                  "learningObjective": "Identificar e declarar corretamente variáveis estáticas privadas para promover encapsulamento.",
                                  "commonMistakes": [
                                    "Esquecer o modificador 'static'",
                                    "Omitir 'private'",
                                    "Usar tipo não compatível sem inicialização"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar método getter estático",
                                  "subSteps": [
                                    "Na classe Contador, crie um método público estático: 'public static int getTotal() { return total; }'.",
                                    "Teste o método em uma classe principal criando instâncias e chamando getTotal().",
                                    "Verifique se o valor é acessível de fora da classe.",
                                    "Adicione validação básica no getter se necessário (ex: log).",
                                    "Compile e execute para confirmar retorno correto."
                                  ],
                                  "verification": "Chamar getTotal() retorna o valor atual de 'total' sem acesso direto à variável.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Mesma IDE e JDK do passo anterior",
                                    "Classe Main para testes"
                                  ],
                                  "tips": "Mantenha o getter simples e sem side-effects para previsibilidade.",
                                  "learningObjective": "Criar acessores estáticos para leitura segura de variáveis privadas estáticas.",
                                  "commonMistakes": [
                                    "Esquecer 'static' no método",
                                    "Retornar referência mutável em vez de valor",
                                    "Tornar o método não-estático"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar método setter estático",
                                  "subSteps": [
                                    "Adicione um método setter: 'public static void setTotal(int novoTotal) { if (novoTotal >= 0) total = novoTotal; }'.",
                                    "Inclua validação para valores negativos (ex: throw exception ou ignore).",
                                    "Teste chamando setTotal() seguido de getTotal() na classe Main.",
                                    "Crie múltiplas instâncias para demonstrar compartilhamento.",
                                    "Compile e execute, imprimindo valores antes/depois."
                                  ],
                                  "verification": "O valor de 'total' é alterado apenas via setter e getter reflete a mudança.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE Java",
                                    "JDK",
                                    "Classe Main atualizada"
                                  ],
                                  "tips": "Valide entradas no setter para manter integridade dos dados.",
                                  "learningObjective": "Implementar modificadores estáticos seguros para alteração controlada de estado compartilhado.",
                                  "commonMistakes": [
                                    "Não validar entrada",
                                    "Esquecer 'static'",
                                    "Permitir valores inválidos sem restrições"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar encapsulamento e uso completo",
                                  "subSteps": [
                                    "Na classe Main, tente acessar 'Contador.total' diretamente (deve dar erro de compilação).",
                                    "Crie 3 instâncias de Contador, cada uma incrementando via setter.",
                                    "Verifique se getTotal() reflete o total compartilhado.",
                                    "Adicione um construtor que chama setTotal(getTotal() + 1).",
                                    "Execute e capture saída no console para análise."
                                  ],
                                  "verification": "Acesso direto falha, mas via métodos funciona; encapsulamento comprovado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE Java",
                                    "JDK",
                                    "Console para output"
                                  ],
                                  "tips": "Use try-catch para demonstrar exceções em acessos inválidos.",
                                  "learningObjective": "Demonstrar encapsulamento efetivo com variáveis e métodos estáticos privados.",
                                  "commonMistakes": [
                                    "Expor variável acidentalmente",
                                    "Não testar múltiplas instâncias",
                                    "Ignorar erros de compilação"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe 'Contador' com 'private static int totalInstancias = 0;'. No construtor: setTotal(getTotal() + 1);. Em Main: crie 5 objetos e imprima Contador.getTotal() (deve ser 5). Tentativa de 'Contador.totalInstancias++' falha.",
                              "finalVerifications": [
                                "Código compila sem warnings de acesso.",
                                "Variável privada não é acessível diretamente de fora da classe.",
                                "Getter retorna valor atualizado corretamente.",
                                "Setter altera o valor com validação.",
                                "Múltiplas instâncias compartilham o estado via métodos.",
                                "Encapsulamento impede modificações indevidas."
                              ],
                              "assessmentCriteria": [
                                "Declaração correta de 'private static'.",
                                "Métodos getter/setter estáticos funcionais e validados.",
                                "Demonstração de encapsulamento via testes.",
                                "Código limpo com comentários e estrutura OOP.",
                                "Uso prático em cenário com múltiplas instâncias.",
                                "Tratamento de erros em setters."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de contadores e acumuladores.",
                                "Design de Software: Princípios de encapsulamento e singletons.",
                                "Banco de Dados: Variáveis de sessão compartilhadas.",
                                "Gestão de Projetos: Controle de estado global seguro."
                              ],
                              "realWorldApplication": "Em aplicações web para contadores de usuários logados (ex: sessões ativas em um servidor), caches compartilhados em multithreading ou logs globais em sistemas empresariais, garantindo acesso controlado e thread-safety básica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.3.3",
                            "name": "Aplicar protected e default em variáveis estáticas",
                            "description": "Diferenciar e declarar variáveis estáticas com protected (acesso em subclasses) ou package-private (default), com exemplos em hierarquias de classes e considerações de herança.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Modificadores protected e default para Variáveis Estáticas",
                                  "subSteps": [
                                    "Leia a documentação oficial do Java sobre modificadores de acesso: protected permite acesso em subclasses (qualquer pacote) e classes no mesmo pacote; default (sem modificador) limita ao mesmo pacote.",
                                    "Estude como variáveis estáticas pertencem à classe, acessadas via NomeClasse.variavel, independentemente de instância.",
                                    "Analise diagramas de visibilidade: desenhe uma tabela comparando public, protected, default e private para static vars em hierarquias.",
                                    "Revise herança: subclasses herdam statics da superclasse conforme regras de acesso.",
                                    "Compare com variáveis de instância para reforçar diferenças."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando diferenças e forneça um diagrama simples de acesso.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação Java Access Modifiers (Oracle Docs)",
                                    "IDE como IntelliJ ou Eclipse",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use mnemônicos: 'Protected Protege Filhos (subclasses em qualquer lugar), Default Delimita ao Pacote'.",
                                  "learningObjective": "Diferenciar regras de acesso de protected e default aplicadas a variáveis estáticas em contextos de herança.",
                                  "commonMistakes": [
                                    "Confundir protected com public (protected não é visível fora de subclasses/pacote)",
                                    "Achar que static ignora modificadores de acesso",
                                    "Esquecer que default requer ausência de modificador explícito"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar e Testar Variáveis Estáticas com Modificador default (Package-Private)",
                                  "subSteps": [
                                    "Crie um pacote 'com.exemplo.base' e uma classe SuperClass com 'static int defaultStaticVar = 10;' (sem modificador).",
                                    "No mesmo pacote, crie TestSamePackage e acesse via SuperClass.defaultStaticVar; imprima o valor.",
                                    "Crie um pacote 'com.exemplo.sub' com classe TestOtherPackage tentando acessar SuperClass.defaultStaticVar.",
                                    "Compile o projeto: confirme sucesso no mesmo pacote e erro de compilação (cannot access) no outro.",
                                    "Adicione um setter/getter estático na SuperClass para manipular o valor e teste."
                                  ],
                                  "verification": "Código compila sem erros no mesmo pacote; gera erro 'defaultStaticVar has private access' ou similar em outro pacote.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "JDK 8+ instalado",
                                    "IDE com suporte a pacotes Java",
                                    "Terminal para compilação javac"
                                  ],
                                  "tips": "Organize pastas de pacotes corretamente: src/com/exemplo/base/SuperClass.java.",
                                  "learningObjective": "Implementar e validar acesso package-private a variáveis estáticas.",
                                  "commonMistakes": [
                                    "Adicionar 'default' como palavra-chave (inválido; use ausência)",
                                    "Acessar via instância em vez de NomeClasse",
                                    "Ignorar importações de pacote"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Declarar e Testar Variáveis Estáticas com Modificador protected",
                                  "subSteps": [
                                    "Na SuperClass (mesmo pacote base), altere para 'protected static int protectedStaticVar = 20;'.",
                                    "No pacote 'com.exemplo.sub', crie SubClass extends SuperClass e acesse protectedStaticVar diretamente ou via SuperClass.protectedStaticVar.",
                                    "Crie uma classe não-subclass TestOtherPackageNoExtend no mesmo sub-pacote: acesso deve falhar.",
                                    "Compile e execute: confirme acesso bem-sucedido na subclasse e erro na não-subclass.",
                                    "Teste herança: incremente protectedStaticVar na SubClass e verifique reflexão na SuperClass."
                                  ],
                                  "verification": "Subclasse em pacote diferente acessa e modifica sem erros; classe não-herdeira falha com erro de acesso.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Mesmo projeto da Step 2",
                                    "IDE debugger para rastrear acessos"
                                  ],
                                  "tips": "Use 'super.protectedStaticVar' em subclasses para clareza, mesmo que direto funcione.",
                                  "learningObjective": "Implementar acesso protegido em hierarquias cross-package para static vars.",
                                  "commonMistakes": [
                                    "Esquecer 'protected' keyword",
                                    "Testar só em mesmo pacote (máscara o comportamento)",
                                    "Confundir com default em subclasses"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Hierarquia Completa e Comparar Modificadores",
                                  "subSteps": [
                                    "Expanda: crie hierarquia Animal > Mammal > Dog com static vars: defaultStaticVar (Animal), protectedStaticVar (Mammal).",
                                    "Implemente contadores: default para total no pacote, protected para subtipos.",
                                    "Teste acessos: Dog acessa ambos; classe externa acessa só default se mesmo pacote.",
                                    "Adicione métodos estáticos para demonstrar uso em herança.",
                                    "Refatore código comparando impactos e documente em comentários."
                                  ],
                                  "verification": "Execute testes unitários ou main methods confirmando acessos corretos e erros esperados em cenários variados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "JUnit para testes opcionais",
                                    "IDE com refatoração"
                                  ],
                                  "tips": "Use System.out.println em main para logs de acesso durante testes.",
                                  "learningObjective": "Integrar protected/default em design OOP real com herança multi-nível.",
                                  "commonMistakes": [
                                    "Não testar cross-package adequadamente",
                                    "Usar instâncias para statics",
                                    "Expor acidentalmente via public"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de zoológico: classe Animal { static int defaultStaticVar = 0; // contagem package-local } e class Mammal extends Animal { protected static int protectedStaticVar = 0; // subclasses contam mamíferos }. Dog (outro pacote) acessa Animal.defaultStaticVar? Não (se outro pkg). Acessa Mammal.protectedStaticVar? Sim, como subclass. Útil para métricas compartilhadas em frameworks.",
                              "finalVerifications": [
                                "Declaração correta: ausência de modificador para default; 'protected' explícito.",
                                "Acesso package-private funciona só no mesmo pacote para default static.",
                                "Protected static acessível de subclasses em pacotes diferentes via nome da classe.",
                                "Compilação falha em acessos inválidos com mensagens de erro específicas.",
                                "Herança preserva valores estáticos compartilhados conforme acesso.",
                                "Nenhum vazamento de acesso para classes não autorizadas."
                              ],
                              "assessmentCriteria": [
                                "Correção sintática e semântica (100% compilação sem warnings de acesso): 30%",
                                "Testes cross-package e herança demonstrados (múltiplos cenários): 25%",
                                "Uso apropriado em hierarquia (não over/under exposure): 20%",
                                "Documentação/comentários explicando escolhas: 15%",
                                "Eficiência: sem código desnecessário ou workarounds: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Design de Software: Princípios de encapsulamento e modularidade em OOP.",
                                "Segurança Computacional: Modelos de controle de acesso e visibilidade.",
                                "Lógica e Matemática: Árvores de herança como grafos direcionados.",
                                "Banco de Dados: Analogia com visibilidade de atributos em esquemas relacionais."
                              ],
                              "realWorldApplication": "Em bibliotecas Java como Hibernate ou Spring Framework, classes base usam protected static vars para caches ou contadores compartilhados por subclasses customizadas (ex: entidades estendendo BaseEntity com protected static Logger), permitindo extensão segura sem expor internals a pacotes externos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.2",
                    "name": "Características das Variáveis Estáticas",
                    "description": "Propriedades das variáveis estáticas, como compartilhamento entre instâncias e inicialização.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.2.1",
                        "name": "Compartilhamento entre Instâncias",
                        "description": "As variáveis estáticas pertencem à classe e são compartilhadas por todas as instâncias, mantendo um único valor acessível e modificável por qualquer objeto da classe, independentemente de quantas instâncias sejam criadas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.1.1",
                            "name": "Identificar o comportamento de compartilhamento",
                            "description": "Analisar um trecho de código em linguagens como Python ou Java para identificar que modificações em uma variável estática por uma instância afetam todas as outras instâncias da classe.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Variáveis Estáticas",
                                  "subSteps": [
                                    "Leia a definição de variável estática: pertence à classe, compartilhada por todas as instâncias, armazenada na memória da classe.",
                                    "Compare com variáveis de instância: únicas por objeto.",
                                    "Estude exemplos em Python (usando @staticmethod ou referência de classe) e Java (static keyword).",
                                    "Anote diferenças no ciclo de vida: estática existe enquanto classe carregada.",
                                    "Visualize diagrama mental: classe como 'contêiner' compartilhado."
                                  ],
                                  "verification": "Escreva uma definição de 3-5 frases em suas próprias palavras e compare com documentação oficial.",
                                  "estimatedTime": "15-20 minutes",
                                  "materials": [
                                    "Documentação Python (dataclasses ou classes normais), Java static docs",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Pense em 'estática = propriedade da classe inteira, não de um objeto específico'.",
                                  "learningObjective": "Dominar a definição e armazenamento de variáveis estáticas em OOP.",
                                  "commonMistakes": "Confundir estática com variável local ou de instância; ignorar necessidade de referência pela classe em Python."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar Comportamento de Variáveis Estáticas vs. de Instância",
                                  "subSteps": [
                                    "Crie uma classe simples com variável de instância e crie 2 instâncias; modifique em uma e verifique a outra.",
                                    "Converta para variável estática e repita: modifique via uma instância e observe impacto em todas.",
                                    "Use prints para rastrear valores antes/depois da modificação.",
                                    "Teste em Python e Java para comparar sintaxe.",
                                    "Registre outputs em tabela comparativa."
                                  ],
                                  "verification": "Execute código e confirme que mudança em estática afeta todas instâncias, mas não em de instância.",
                                  "estimatedTime": "20-25 minutes",
                                  "materials": [
                                    "IDE como VS Code ou PyCharm",
                                    "Python/Java runtime"
                                  ],
                                  "tips": "Sempre acesse estática via nome da classe (ex: Classe.var) em Python para evitar confusão.",
                                  "learningObjective": "Identificar diferenças práticas no comportamento de compartilhamento via experimentação.",
                                  "commonMistakes": "Modificar estática via self em Python sem qualificar pela classe, causando NameError; achar que estática é 'global' sem escopo de classe."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Trechos de Código para Identificar Compartilhamento",
                                  "subSteps": [
                                    "Receba um trecho de código com variável estática modificada por instância.",
                                    "Identifique declaração estática e linha de modificação.",
                                    "Preveja output para múltiplas instâncias.",
                                    "Execute o código e valide previsão.",
                                    "Explique em comentários por que o comportamento ocorre."
                                  ],
                                  "verification": "Anote previsão vs. output real; deve prever compartilhamento corretamente em 100%.",
                                  "estimatedTime": "25-30 minutes",
                                  "materials": [
                                    "Códigos exemplo em Python/Java",
                                    "Debugger ou print statements"
                                  ],
                                  "tips": "Procure por 'static' (Java) ou acesso via Classe.var (Python); trace fluxo de execução.",
                                  "learningObjective": "Desenvolver habilidade de análise estática e dinâmica de código para detectar compartilhamento.",
                                  "commonMistakes": "Ignorar que modificação em método de instância afeta estática; confundir com herança ou shadowing."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e Verificar Identificação em Cenários Variados",
                                  "subSteps": [
                                    "Resolva 3-5 exercícios com códigos mistos (estática, instância, não-estáticas).",
                                    "Identifique e anote comportamentos de compartilhamento.",
                                    "Crie seu próprio exemplo com contador compartilhado.",
                                    "Discuta com par ou autoavalie explicando verbalmente.",
                                    "Refatore código para usar estática intencionalmente."
                                  ],
                                  "verification": "Complete exercícios com 90% acerto; crie exemplo funcional que demonstre compartilhamento.",
                                  "estimatedTime": "30-40 minutes",
                                  "materials": [
                                    "Lista de exercícios",
                                    "Repositório GitHub com exemplos OOP"
                                  ],
                                  "tips": "Use asserts ou testes unitários para automação de verificação.",
                                  "learningObjective": "Aplicar conhecimento para identificar e criar cenários de compartilhamento de forma independente.",
                                  "commonMistakes": "Sobre-generalizar para todas variáveis; não considerar multi-threading onde compartilhamento pode causar races."
                                }
                              ],
                              "practicalExample": "Em Python:\n```python\nclass Contador:\n    valor_compartilhado = 0  # Variável estática\n\n    def incrementar(self):\n        Contador.valor_compartilhado += 1\n\nc1 = Contador()\nc2 = Contador()\nprint(c1.valor_compartilhado)  # 0\nc1.incrementar()\nprint(c2.valor_compartilhado)  # 1 (compartilhado!)\n```\nModificação por c1 afeta c2.",
                              "finalVerifications": [
                                "Explicar verbalmente por que modificação em estática afeta todas instâncias.",
                                "Analisar novo código e prever output corretamente.",
                                "Identificar ausência de compartilhamento em variáveis de instância.",
                                "Criar classe com estática funcional e demonstrar.",
                                "Diferenciar sintaxe em Python vs. Java.",
                                "Debugar código onde compartilhamento causa bug inesperado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na previsão de outputs (100% em exemplos).",
                                "Explicação clara do mecanismo de compartilhamento (memória da classe).",
                                "Identificação correta em códigos mistos (90%+).",
                                "Uso adequado de sintaxe em pelo menos duas linguagens.",
                                "Criação de exemplo original sem erros.",
                                "Reconhecimento de pitfalls como race conditions."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Analogia com variáveis globais em modelagem algébrica.",
                                "Lógica e Algoritmos: Entender escopo e estado compartilhado em fluxogramas.",
                                "Design de Sistemas: Padrões Singleton e contadores em arquitetura de software.",
                                "Física: Propriedades compartilhadas em simulações de partículas (estado global)."
                              ],
                              "realWorldApplication": "Em aplicações web, contadores de visitas ou sessões compartilhadas (ex: Django models com class vars); logs globais em multi-usuário; caches estáticos em jogos multiplayer onde estado de pontuação é compartilhado sem banco de dados imediato."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.2",
                            "name": "Demonstrar compartilhamento com código",
                            "description": "Escrever e executar um programa que cria múltiplas instâncias de uma classe, modifica uma variável estática através de uma instância e verifica que o valor é refletido em todas as instâncias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a classe com uma variável estática",
                                  "subSteps": [
                                    "Abra um editor de código ou IDE com suporte a Python.",
                                    "Crie uma nova classe chamada 'Contador' usando a sintaxe 'class Contador:'",
                                    "Dentro da classe, defina uma variável estática chamada 'total_instancias' inicializada com 0 (ex: total_instancias = 0).",
                                    "Adicione um método de instância simples, como 'get_total(self)', que retorna Contador.total_instancias.",
                                    "Salve o arquivo como 'estatico_compartilhamento.py'."
                                  ],
                                  "verification": "Verifique se a classe é definida corretamente sem erros de sintaxe executando um teste simples de importação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, PyCharm ou IDLE)",
                                    "Python 3.x instalado"
                                  ],
                                  "tips": "Use a convenção de nomenclatura clara e idente corretamente para evitar erros de indentação.",
                                  "learningObjective": "Compreender como declarar uma variável estática no nível da classe em Python.",
                                  "commonMistakes": [
                                    "Confundir com variável de instância usando 'self.total_instancias'",
                                    "Esquecer de acessar via nome da classe (Contador.total_instancias)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar múltiplas instâncias da classe",
                                  "subSteps": [
                                    "No corpo principal do script, crie a primeira instância: instancia1 = Contador().",
                                    "Incremente a variável estática na criação: Contador.total_instancias += 1.",
                                    "Crie a segunda instância: instancia2 = Contador() e incremente novamente.",
                                    "Adicione um print para exibir o valor atual: print(Contador.total_instancias).",
                                    "Execute o código e confirme que total_instancias é 2."
                                  ],
                                  "verification": "Ao rodar o script, o print deve mostrar 2, confirmando duas instâncias criadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Arquivo 'estatico_compartilhamento.py'",
                                    "Terminal ou console Python"
                                  ],
                                  "tips": "Use if __name__ == '__main__': para isolar o código principal.",
                                  "learningObjective": "Demonstrar a criação de instâncias independentes que compartilham a variável estática.",
                                  "commonMistakes": [
                                    "Incrementar via self em vez de classe",
                                    "Não inicializar corretamente o contador"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modificar a variável estática através de uma instância",
                                  "subSteps": [
                                    "Adicione um método de instância 'incrementar(self)' que faz Contador.total_instancias += 1.",
                                    "Chame instancia1.incrementar() para modificar o valor.",
                                    "Adicione prints antes e depois: print('Antes:', instancia1.get_total()) e print('Depois:', instancia1.get_total()).",
                                    "Execute e verifique se o valor aumenta para 3.",
                                    "Teste acessando via nome da classe: print(Contador.total_instancias)."
                                  ],
                                  "verification": "O valor deve mudar de 2 para 3 após a chamada do método na instância1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Mesmo arquivo Python",
                                    "Console para execução iterativa"
                                  ],
                                  "tips": "Lembre-se: modificação via instância afeta a classe inteira por ser estática.",
                                  "learningObjective": "Entender que métodos de instância podem alterar variáveis estáticas compartilhadas.",
                                  "commonMistakes": [
                                    "Tentar modificar com self.total_instancias (cria instância local)",
                                    "Não usar o nome da classe no método"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar o compartilhamento em todas as instâncias",
                                  "subSteps": [
                                    "Após modificar via instancia1, acesse get_total() na instancia2: print('Instancia2:', instancia2.get_total()).",
                                    "Crie uma terceira instância e verifique: instancia3 = Contador(); print('Instancia3:', instancia3.get_total()).",
                                    "Adicione prints comparativos para todas as instâncias.",
                                    "Execute o programa completo e observe que todas mostram o mesmo valor atualizado.",
                                    "Comente o código explicando o compartilhamento."
                                  ],
                                  "verification": "Todas as instâncias devem refletir o mesmo valor da variável estática (ex: 4 após incrementos).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Arquivo atualizado",
                                    "Documentação Python OOP para referência"
                                  ],
                                  "tips": "Use str() ou f-strings para prints claros e formatados.",
                                  "learningObjective": "Confirmar experimentalmente o compartilhamento de estado via variável estática.",
                                  "commonMistakes": [
                                    "Acessar incorretamente, esperando valores diferentes",
                                    "Reescrever a variável como instância"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Executar, depurar e documentar o programa",
                                  "subSteps": [
                                    "Execute o script completo várias vezes com variações (ex: mais incrementos).",
                                    "Identifique e corrija qualquer erro de sintaxe ou lógica.",
                                    "Adicione comentários no código explicando cada parte.",
                                    "Crie um README simples descrevendo o experimento e resultados.",
                                    "Compartilhe ou teste em outro ambiente para validação."
                                  ],
                                  "verification": "Programa roda sem erros e demonstra compartilhamento consistentemente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "GitHub ou pasta de projetos para versionamento",
                                    "Ferramenta de depuração (pdb ou debugger IDE)"
                                  ],
                                  "tips": "Use print statements para depuração passo a passo.",
                                  "learningObjective": "Consolidar o conhecimento através de execução, depuração e documentação.",
                                  "commonMistakes": [
                                    "Ignorar erros de runtime",
                                    "Não testar com múltiplas execuções"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de gerenciamento de biblioteca, crie uma classe 'Livro' com variável estática 'total_livros_emprestados'. Toda vez que um livro é emprestado via qualquer instância, o contador global é atualizado e refletido em consultas de qualquer outro livro, simulando um registro compartilhado de empréstimos.",
                              "finalVerifications": [
                                "O programa cria pelo menos duas instâncias sem erros.",
                                "Modificação via uma instância altera o valor acessado por todas.",
                                "Métodos de get_total() retornam o mesmo valor para todas instâncias.",
                                "Execução múltipla confirma consistência do compartilhamento.",
                                "Código está comentado e legível.",
                                "Nenhum erro de sintaxe ou runtime ocorre."
                              ],
                              "assessmentCriteria": [
                                "Correta declaração e uso da variável estática (acesso via classe).",
                                "Criação e manipulação de múltiplas instâncias independentes.",
                                "Demonstração clara de modificação e verificação compartilhada.",
                                "Código executável, bem estruturado e documentado.",
                                "Uso apropriado de métodos de instância para alterar estática.",
                                "Ausência de confusão com variáveis de instância."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de contadores globais e funções compartilhadas.",
                                "Física: Simulações onde propriedades globais (ex: tempo universal) são compartilhadas entre partículas.",
                                "Administração: Sistemas de contabilidade com totais compartilhados em múltiplos registros.",
                                "Design de Jogos: Pontuação ou vidas globais acessíveis por todos os personagens."
                              ],
                              "realWorldApplication": "Em aplicações web como contadores de usuários logados (variável estática em uma classe Sessao), onde o número total é atualizado por uma sessão e visível a todas, otimizando gerenciamento de recursos sem bancos de dados para estados globais simples."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.3",
                            "name": "Diferenciar de variáveis de instância",
                            "description": "Comparar o comportamento de variáveis estáticas (compartilhadas) versus variáveis de instância (exclusivas por objeto), ilustrando com exemplos de código que destacam as diferenças no acesso e modificação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de variáveis de instância",
                                  "subSteps": [
                                    "Defina variáveis de instância como atributos exclusivos de cada objeto criado a partir de uma classe.",
                                    "Explique que cada instância possui sua própria cópia independente dessas variáveis.",
                                    "Discuta o escopo: acessíveis via objeto específico (ex: objeto.nome).",
                                    "Ilustre com diagrama mental: múltiplos objetos, cada um com seu valor único.",
                                    "Compare brevemente com variáveis locais para contextualizar."
                                  ],
                                  "verification": "Crie um diagrama simples mostrando 3 objetos com valores diferentes para a mesma variável de instância.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de texto ou papel para diagrama; documentação de Java OOP.",
                                  "tips": "Use nomes descritivos como 'cor' para variáveis de instância para facilitar visualização.",
                                  "learningObjective": "Identificar e descrever variáveis de instância como exclusivas por objeto.",
                                  "commonMistakes": "Confundir com variáveis estáticas achando que são compartilhadas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o conceito de variáveis estáticas",
                                  "subSteps": [
                                    "Defina variáveis estáticas como atributos compartilhados por todas as instâncias de uma classe.",
                                    "Explique que pertencem à classe, não ao objeto (keyword 'static').",
                                    "Discuta o escopo: acessíveis via nome da classe (ex: Classe.contador).",
                                    "Ilustre com diagrama: um único valor compartilhado entre múltiplos objetos.",
                                    "Mencione usos comuns como contadores globais."
                                  ],
                                  "verification": "Escreva uma definição curta e crie um diagrama contrastando com variáveis de instância.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de texto; exemplos de código Java estático.",
                                  "tips": "Lembre-se: estáticas são 'da classe', instância são 'do objeto'.",
                                  "learningObjective": "Diferenciar o compartilhamento único das variáveis estáticas.",
                                  "commonMistakes": "Esquecer o 'static' e tratar como instância."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar comportamentos com exemplos de código",
                                  "subSteps": [
                                    "Crie uma classe simples (ex: Carro) com variável de instância 'cor' e estática 'totalCarros'.",
                                    "Instancie múltiplos objetos e modifique 'cor' de um: verifique independência.",
                                    "Incremente 'totalCarros' em um construtor: observe reflexão em todos os objetos.",
                                    "Acesse e modifique via objeto e via classe, registrando saídas.",
                                    "Compile e execute o código para validar diferenças."
                                  ],
                                  "verification": "Execute o código e capture prints mostrando valores diferentes para instância e iguais para estática.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "IDE como IntelliJ ou VS Code com Java; terminal para execução.",
                                  "tips": "Use System.out.println para depuração imediata das diferenças.",
                                  "learningObjective": "Ilustrar via código as diferenças no acesso e modificação.",
                                  "commonMistakes": "Acessar estática via objeto sem erro, mas não entender o compartilhamento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e praticar diferenças em cenários reais",
                                  "subSteps": [
                                    "Modifique o código: altere uma variável de instância em um objeto e verifique outros.",
                                    "Altere variável estática e confirme impacto global.",
                                    "Crie um exercício: adicione método que usa ambas e compare saídas.",
                                    "Discuta quando usar cada uma (ex: ID único vs contador total).",
                                    "Refatore código para corrigir uso inadequado."
                                  ],
                                  "verification": "Escreva um relatório curto com 3 exemplos de código e suas saídas explicando diferenças.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "IDE Java; exemplos prévios salvos.",
                                  "tips": "Teste com 4-5 instâncias para padrões claros.",
                                  "learningObjective": "Aplicar e diferenciar na prática o comportamento das variáveis.",
                                  "commonMistakes": "Usar estática para dados únicos por objeto."
                                }
                              ],
                              "practicalExample": "Em uma classe 'Carro': variável de instância 'cor' (cada carro tem sua cor única); variável estática 'totalCarros' (incrementada no construtor, compartilhada: Carro.totalCarros reflete total de carros criados). Código: public class Carro { private String cor; static int totalCarros = 0; public Carro(String c) { cor = c; totalCarros++; } }. Criar carro1.cor=\"vermelho\"; carro2.cor=\"azul\"; System.out.println(carro1.totalCarros == carro2.totalCarros); // true",
                              "finalVerifications": [
                                "Explicar verbalmente a diferença entre acesso objeto.cor vs Classe.total.",
                                "Prever saída de código com 3 instâncias modificando cada tipo.",
                                "Identificar em código fornecido qual variável é estática.",
                                "Criar diagrama de memória mostrando compartilhamento.",
                                "Corrigir código com uso incorreto de variáveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção conceitual (80% correto).",
                                "Exemplos de código funcionais e ilustrativos.",
                                "Análise correta de saídas e modificações.",
                                "Uso adequado de diagramas ou visualizações.",
                                "Aplicação em cenários práticos sem erros comuns.",
                                "Relatório claro e estruturado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de funções globais vs locais (compartilhamento de estado).",
                                "Física: Analogia com propriedades intrínsecas (instância) vs leis universais (estática).",
                                "Banco de Dados: Campos globais em tabelas vs atributos por registro."
                              ],
                              "realWorldApplication": "Em sistemas de gerenciamento, variáveis estáticas contam usuários logados (compartilhado); variáveis de instância armazenam dados pessoais por usuário (ex: apps bancários, jogos multiplayer onde score individual vs total jogadores)."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.2",
                        "name": "Inicialização e Vida Útil das Variáveis Estáticas",
                        "description": "As variáveis estáticas são inicializadas uma única vez, no momento da primeira carga da classe (ou definição em Python), e persistem durante toda a execução do programa, independentemente da criação ou destruição de instâncias.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.2.1",
                            "name": "Explicar o momento de inicialização",
                            "description": "Descrever o processo de inicialização de variáveis estáticas, incluindo quando ocorre (carregamento da classe em Java/C++ ou definição da classe em Python) e os valores padrão atribuídos se não inicializados explicitamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Geral de Inicialização de Variáveis Estáticas",
                                  "subSteps": [
                                    "Defina o que é uma variável estática em programação orientada a objetos.",
                                    "Identifique que a inicialização ocorre uma única vez por classe, não por instância.",
                                    "Revise a diferença entre inicialização estática e inicialização de instância.",
                                    "Estude o ciclo de vida da classe: carregamento, inicialização e uso.",
                                    "Anote exemplos conceituais sem código ainda."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo quando e por que a inicialização estática acontece, sem referenciar linguagens específicas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial de OOP (Java, C++, Python)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Pense na classe como um blueprint: estáticos são preparados antes de qualquer casa ser construída.",
                                  "learningObjective": "Dominar o conceito abstrato de inicialização estática independente de linguagem.",
                                  "commonMistakes": "Confundir inicialização estática com construtores de instância, que ocorrem por objeto."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Inicialização em Linguagens Compiladas (Java e C++)",
                                  "subSteps": [
                                    "Em Java: Estude que ocorre durante o carregamento da classe pela JVM.",
                                    "Em C++: Aprenda sobre inicialização em tempo de compilação ou linkage para globals estáticos.",
                                    "Compile e execute um código simples em Java mostrando static init com System.out.",
                                    "Use debugger em C++ para observar o momento exato da inicialização.",
                                    "Registre diferenças sutis entre as duas linguagens."
                                  ],
                                  "verification": "Execute um programa Java/C++ e confirme que o valor estático é inicializado antes de main ou instâncias.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "JDK para Java",
                                    "GCC/Clang para C++",
                                    "IDE como IntelliJ ou VS Code"
                                  ],
                                  "tips": "Use blocos static {} em Java para demonstrações claras de ordem de inicialização.",
                                  "learningObjective": "Explicar precisamente o timing de inicialização em Java (class loading) e C++ (program startup).",
                                  "commonMistakes": "Achar que em Java statics são inicializados em runtime por thread; é lazy e one-time por classloader."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Inicialização em Python e Valores Padrão",
                                  "subSteps": [
                                    "Em Python: Entenda que ocorre na definição da classe (module load time).",
                                    "Teste com print em class-level static vars para ver execução imediata.",
                                    "Liste valores padrão: Java/C++ (0, null, false), Python (None para objetos).",
                                    "Escreva código comparativo inicializando explicitamente vs. implícito.",
                                    "Discuta implicações de inicialização eager em Python vs. lazy em Java."
                                  ],
                                  "verification": "Crie um módulo Python e importe múltiplas vezes; confirme inicialização única.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python 3.x interpreter",
                                    "Jupyter Notebook para testes rápidos"
                                  ],
                                  "tips": "Em Python, evite código pesado na definição da classe; use metaclasses se necessário.",
                                  "learningObjective": "Comparar inicialização em Python com compiladas e memorizar valores padrão por linguagem.",
                                  "commonMistakes": "Esquecer que Python não tem 'static' keyword explícito; usa class vars."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Conhecimento com Exemplos e Testes Práticos",
                                  "subSteps": [
                                    "Crie um exemplo unificado comparando as três linguagens em um documento.",
                                    "Teste cenários de não-inicialização para observar defaults.",
                                    "Simule erros comuns, como dependências circulares em inicializações estáticas.",
                                    "Explique verbalmente ou grave um vídeo de 1min resumindo tudo.",
                                    "Resolva 3 exercícios online sobre static init."
                                  ],
                                  "verification": "Responda a perguntas de auto-teste: 'Quando em Java? Default em C++?' com 100% acerto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exercícios online (LeetCode/HackerRank OOP)",
                                    "Gravador de tela opcional"
                                  ],
                                  "tips": "Use tabelas para comparar linguagens: coluna Timing, Default Values, Exemplo.",
                                  "learningObjective": "Integrar conhecimentos para explicar inicialização estática de forma completa e comparativa.",
                                  "commonMistakes": "Ignorar contextos multi-threaded em Java, onde init é sincronizado."
                                }
                              ],
                              "practicalExample": "Em Java: public class StaticInit { static int count = 42; static { System.out.println('Static block executed'); } public static void main(String[] args) { System.out.println(StaticInit.count); } } Saída: 'Static block executed' seguido de 42, provando init no class load antes de main.",
                              "finalVerifications": [
                                "Explicar corretamente o momento: Java/C++ (class load/startup), Python (definição).",
                                "Listar valores padrão sem hesitação para cada linguagem.",
                                "Demonstrar com código que init é one-time por classe.",
                                "Identificar ordem: static vars/blocos antes de instâncias.",
                                "Discutir exceções como lazy loading em Java.",
                                "Comparar impactos em performance e thread-safety."
                              ],
                              "assessmentCriteria": [
                                "Precisão factual no timing de inicialização (100% correto).",
                                "Uso correto de terminologia (class loading, module load, defaults).",
                                "Capacidade de codificar e debugar exemplos funcionais.",
                                "Explicação clara de diferenças entre linguagens.",
                                "Identificação de pitfalls como circular dependencies.",
                                "Integração conceitual sem confusão com instance vars."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Inicialização de constantes globais em simulações numéricas.",
                                "Física/Engenharia: Configurações estáticas em modeladores (ex: constantes físicas).",
                                "Lógica/Algoritmos: Contadores globais em estruturas de dados compartilhadas.",
                                "Inglês Técnico: Leitura de specs de linguagem (JLS, Python PEP)."
                              ],
                              "realWorldApplication": "Em aplicações web (Spring Boot Java), contadores de sessões estáticos inicializam no startup do servidor para métricas globais; em jogos C++, scores high estáticos persistem via init no load; em scripts Python (Django), configs de banco carregam uma vez no module import para eficiência."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.2",
                            "name": "Implementar inicialização explícita",
                            "description": "Criar uma classe com variáveis estáticas inicializadas com valores literais, expressões ou chamadas de métodos, testando para confirmar que a inicialização ocorre apenas uma vez mesmo com múltiplas instâncias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de inicialização explícita de variáveis estáticas",
                                  "subSteps": [
                                    "Leia a documentação da linguagem sobre variáveis estáticas e seu ciclo de vida.",
                                    "Identifique que variáveis estáticas são inicializadas uma única vez, na primeira referência à classe.",
                                    "Diferencie inicialização explícita (no ponto de declaração) de inicialização lazy.",
                                    "Anote exemplos de valores literais, expressões e chamadas de métodos para inicialização.",
                                    "Crie um diagrama mental: classe carregada → static init → valor fixo para todas instâncias."
                                  ],
                                  "verification": "Resuma em 3 frases o que é inicialização explícita e por que ocorre apenas uma vez.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação da linguagem (ex: Java Docs para static fields)",
                                    "Bloco de notas ou editor de texto"
                                  ],
                                  "tips": "Use exemplos simples como 'static int contador = 0;' para fixar o conceito.",
                                  "learningObjective": "Explicar o mecanismo de inicialização única de variáveis estáticas.",
                                  "commonMistakes": [
                                    "Confundir com variáveis de instância",
                                    "Achar que static é instanciado por objeto",
                                    "Ignorar ordem de inicialização em blocos static"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar classe com variáveis estáticas inicializadas com literais e expressões",
                                  "subSteps": [
                                    "Defina uma classe simples, ex: public class Config { }",
                                    "Adicione static int versao = 1; (literal)",
                                    "Adicione static String nome = \"App v\" + versao; (expressão)",
                                    "Adicione um método getter para cada variável: public static int getVersao() { return versao; }",
                                    "Compile a classe sem erros."
                                  ],
                                  "verification": "A classe compila e os getters retornam valores esperados sem instanciar.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE como IntelliJ ou Eclipse",
                                    "Compilador Java (JDK 8+)"
                                  ],
                                  "tips": "Use expressões simples primeiro para evitar erros de dependência circular.",
                                  "learningObjective": "Implementar inicializações explícitas com literais e expressões em código funcional.",
                                  "commonMistakes": [
                                    "Esquecer 'static'",
                                    "Usar this. em static",
                                    "Expressões com variáveis não-estáticas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar inicialização com chamada de método e preparar testes",
                                  "subSteps": [
                                    "Adicione um método static auxiliar: private static List<String> criarLista() { return new ArrayList<>(); }",
                                    "Declare static List<String> logs = criarLista();",
                                    "Crie um construtor que chame System.out.println(\"Instância criada\");",
                                    "Escreva um método main para criar 3 instâncias: new Config(); new Config(); new Config();",
                                    "Adicione prints nos getters para mostrar valores."
                                  ],
                                  "verification": "Execute main e confirme que construtor roda 3x, mas logs.size() é 0 (init uma vez).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE com console",
                                    "JDK instalado"
                                  ],
                                  "tips": "Mantenha métodos auxiliares simples e private para encapsulamento.",
                                  "learningObjective": "Usar chamadas de métodos em inicializações estáticas de forma segura.",
                                  "commonMistakes": [
                                    "Método auxiliar não-static",
                                    "Chamada recursiva acidental",
                                    "Lista não inicializada corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e verificar inicialização única com múltiplas instâncias",
                                  "subSteps": [
                                    "Execute o main e observe saídas: construtores múltiplos, mas valores static iguais.",
                                    "Modifique uma variável static via instância e verifique propagação.",
                                    "Adicione um bloco static { System.out.println(\"Bloco static executado\"); } e confirme execução única.",
                                    "Crie teste unitário com JUnit: assertEquals(1, Config.getVersao()); após múltiplas new.",
                                    "Registre logs de execução para análise."
                                  ],
                                  "verification": "Testes passam e prints confirmam init uma vez (bloco static roda 1x).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "JUnit ou framework de testes",
                                    "IDE com debugger"
                                  ],
                                  "tips": "Use debugger para pausar no bloco static e ver execução única.",
                                  "learningObjective": "Validar empiricamente a inicialização única de variáveis estáticas.",
                                  "commonMistakes": [
                                    "Não criar múltiplas instâncias",
                                    "Confundir output de construtor com static",
                                    "Testes sem asserts"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe SingletonLogger com static List<String> logs = new ArrayList<>(); inicializada com método que adiciona \"Logger iniciado\". Crie 5 instâncias; logs deve ter tamanho 1 e conter a mensagem única, provando inicialização uma vez.",
                              "finalVerifications": [
                                "Variáveis static retornam valores idênticos em todas instâncias.",
                                "Bloco static ou método auxiliar executa exatamente uma vez.",
                                "Código compila sem warnings de inicialização.",
                                "Testes unitários passam com múltiplas criações de objetos.",
                                "Valores persistem após garbage collection de instâncias.",
                                "Modificação static afeta todas instâncias imediatamente."
                              ],
                              "assessmentCriteria": [
                                "Código demonstra inicialização com literal, expressão e método.",
                                "Testes cobrem cenários de múltiplas instâncias (mínimo 3).",
                                "Verificação empírica via prints ou asserts confirma unicidade.",
                                "Estrutura da classe segue boas práticas (getters, private auxiliares).",
                                "Sem erros comuns como recursão ou dependências circulares.",
                                "Tempo de execução é eficiente (sem loops desnecessários)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Uso de contadores estáticos para estatísticas globais.",
                                "Física/Engenharia: Simulação de constantes universais (ex: gravidade).",
                                "Banco de Dados: Conexões singleton para pools compartilhados.",
                                "Design de Sistemas: Padrões como Singleton dependem disso."
                              ],
                              "realWorldApplication": "Em aplicações web, variáveis estáticas inicializam caches globais ou configurações de log uma única vez, evitando recarga desnecessária em servidores multi-threaded, otimizando performance e memória."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.3",
                            "name": "Utilizar blocos de inicialização estática",
                            "description": "Em linguagens que suportam (como Java ou C++), implementar blocos estáticos para inicializar variáveis estáticas com lógica complexa, demonstrando a execução única desses blocos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos de Blocos de Inicialização Estática",
                                  "subSteps": [
                                    "Estude a definição: blocos estáticos executam uma única vez quando a classe é carregada pela JVM.",
                                    "Compare com inicializadores de variáveis estáticas simples (ex: int x = 10;).",
                                    "Leia documentação oficial do Java sobre static initializer blocks.",
                                    "Identifique cenários onde lógica complexa é necessária (ex: validações ou cálculos).",
                                    "Anote diferenças com construtores e blocos de instância."
                                  ],
                                  "verification": "Resuma em 3 pontos chave o que diferencia blocos estáticos de outros inicializadores.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação Java (Oracle Docs), editor de texto para anotações.",
                                  "tips": "Use diagramas de fluxo para visualizar a ordem de execução na JVM.",
                                  "learningObjective": "Explicar o propósito e o momento de execução de blocos estáticos.",
                                  "commonMistakes": "Confundir com construtores que executam por instância."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar um Bloco Estático Simples",
                                  "subSteps": [
                                    "Crie uma classe Java com uma variável estática.",
                                    "Adicione um bloco estático simples que atribua um valor à variável.",
                                    "Crie um método main para instanciar a classe múltiplas vezes.",
                                    "Compile e execute para observar a saída.",
                                    "Adicione um print no bloco para confirmar execução única."
                                  ],
                                  "verification": "Execute o programa e confirme que o print do bloco aparece apenas uma vez.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "JDK 8+, IDE como IntelliJ ou Eclipse, terminal para compilação.",
                                  "tips": "Use System.out.println para logs claros durante testes.",
                                  "learningObjective": "Criar e testar um bloco estático básico.",
                                  "commonMistakes": "Esquecer o modificador 'static' na variável."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar Lógica Complexa ao Bloco Estático",
                                  "subSteps": [
                                    "Expanda o bloco para incluir condicionais (if-else) ou loops.",
                                    "Implemente uma lógica como calcular e popular um array estático.",
                                    "Inclua tratamento de exceções se necessário (ex: try-catch).",
                                    "Teste com diferentes entradas para validar a lógica.",
                                    "Refatore para garantir que o bloco seja eficiente."
                                  ],
                                  "verification": "Verifique se a variável estática recebe o valor correto após lógica complexa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "IDE com depurador, JDK.",
                                  "tips": "Mantenha o bloco conciso; divida lógica em métodos auxiliares estáticos se crescer.",
                                  "learningObjective": "Aplicar lógica não-trivial em blocos estáticos.",
                                  "commonMistakes": "Colocar lógica de instância dentro do bloco estático."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar Execução Única em Cenários Avançados",
                                  "subSteps": [
                                    "Crie múltiplas classes que referenciem a classe com bloco estático.",
                                    "Teste carregamento lazy da classe (sem instanciar).",
                                    "Use reflection para forçar carregamento e verificar.",
                                    "Meça performance com System.nanoTime para confirmar execução única.",
                                    "Documente observações em comentários no código."
                                  ],
                                  "verification": "Confirme via logs e debugger que o bloco executa apenas uma vez, mesmo com múltiplas threads ou classes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "IDE com suporte a reflection e threading, JUnit para testes unitários.",
                                  "tips": "Evite exceções no bloco, pois elas impedem carregamento da classe.",
                                  "learningObjective": "Validar comportamento em contextos reais como multithreading.",
                                  "commonMistakes": "Ignorar ordem de inicialização em herança."
                                }
                              ],
                              "practicalExample": "Em uma classe LoggerUtil, use um bloco estático para inicializar um mapa de configurações de log lendo um arquivo properties e validando entradas, garantindo que todas as instâncias da aplicação usem a mesma configuração carregada uma única vez.",
                              "finalVerifications": [
                                "O bloco executa exatamente uma vez por classe, independentemente do número de instâncias.",
                                "Variáveis estáticas são corretamente inicializadas com a lógica do bloco.",
                                "Não há exceções não tratadas durante a inicialização.",
                                "O código compila e roda sem warnings relacionados a statics.",
                                "Testes com múltiplas threads confirmam thread-safety implícito.",
                                "Comparação com inicializador simples mostra equivalência em casos básicos."
                              ],
                              "assessmentCriteria": [
                                "Código demonstra uso correto de sintaxe de bloco estático.",
                                "Lógica complexa é implementada e testada adequadamente.",
                                "Execução única é comprovada via evidências (logs, testes).",
                                "Código é limpo, comentado e segue boas práticas (ex: sem side-effects desnecessários).",
                                "Exemplo prático é relevante e funcional.",
                                "Documentação explica quando usar vs. alternativas como singletons."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculos em loops para inicializar tabelas de lookup (ex: seno/cosseno).",
                                "Design de Software: Padrões como Singleton para recursos compartilhados.",
                                "Sistemas Operacionais: Entender carregamento de classes e memória estática.",
                                "Banco de Dados: Inicializar pools de conexão estáticos."
                              ],
                              "realWorldApplication": "Em aplicações empresariais Java, blocos estáticos inicializam caches de configurações, tabelas de constantes ou conexões de banco uma única vez, otimizando performance e evitando recálculos desnecessários em servidores multithreaded como Tomcat."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.3",
                    "name": "Declaração de Métodos Estáticos",
                    "description": "Sintaxe para declarar métodos estáticos em classes e suas restrições de acesso a membros.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.3.1",
                        "name": "Sintaxe de Declaração de Métodos Estáticos",
                        "description": "Regras e sintaxe para declarar métodos estáticos dentro de classes em linguagens como Python e C++, incluindo o uso de decoradores ou palavras-chave específicas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.1.1",
                            "name": "Declarar método estático em Python",
                            "description": "Utilizar o decorador @staticmethod acima da definição do método para torná-lo estático, sem parâmetro self, permitindo chamada direta pela classe sem instância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito e planejar o método estático",
                                  "subSteps": [
                                    "Revise a definição de método estático: método que pertence à classe, não à instância, sem acesso a self.",
                                    "Identifique o propósito do método: deve realizar operação independente de estado da instância.",
                                    "Escolha um nome descritivo para o método, como 'calculate_area' para uma classe de formas.",
                                    "Planeje os parâmetros e retorno: sem 'self', apenas argumentos necessários.",
                                    "Verifique pré-requisitos: conhecimento de classes e métodos de instância."
                                  ],
                                  "verification": "Escreva um resumo de 2-3 frases explicando quando usar @staticmethod vs métodos de instância.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, PyCharm)",
                                    "Documentação Python oficial sobre staticmethods"
                                  ],
                                  "tips": [
                                    "Métodos estáticos são ideais para utilitários que não precisam de estado da classe.",
                                    "Compare com funções livres para decidir se precisa da classe."
                                  ],
                                  "learningObjective": "Compreender o papel e casos de uso de métodos estáticos em OOP.",
                                  "commonMistakes": [
                                    "Confundir com métodos de classe (@classmethod, que usa cls).",
                                    "Achar que staticmethods acessam variáveis de instância."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a classe e adicionar o decorador @staticmethod",
                                  "subSteps": [
                                    "Crie uma classe vazia: class MinhaClasse: pass",
                                    "Dentro da classe, inicie a definição do método: def nome_metodo():",
                                    "Adicione o decorador exatamente acima: @staticmethod",
                                    "Garanta indentação correta: 4 espaços para o método dentro da classe.",
                                    "Salve o arquivo como .py."
                                  ],
                                  "verification": "Execute o código sem erros de sintaxe e confirme que o decorador é reconhecido (sem warnings).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python 3.x instalado",
                                    "Terminal ou IDE com interpretador Python"
                                  ],
                                  "tips": [
                                    "O decorador deve estar na linha imediatamente anterior à def, sem linhas em branco.",
                                    "Use pylint ou flake8 para checar sintaxe."
                                  ],
                                  "learningObjective": "Aplicar corretamente a sintaxe do decorador @staticmethod em uma classe.",
                                  "commonMistakes": [
                                    "Esquecer a indentação do método dentro da classe.",
                                    "Colocar @staticmethod após a def.",
                                    "Usar @static_method com underscore."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o corpo do método sem parâmetro self",
                                  "subSteps": [
                                    "Remova ou evite qualquer 'self' na assinatura: def nome_metodo(param1):",
                                    "Escreva lógica simples no corpo, usando apenas parâmetros e constantes.",
                                    "Adicione return se necessário, ex: return param1 * 2",
                                    "Evite referências a atributos de instância ou cls.",
                                    "Teste mentalmente: o método deve funcionar sem criar objeto."
                                  ],
                                  "verification": "Analise o código: confirme ausência de 'self' e dependências de instância.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Console Python interativo (REPL)"
                                  ],
                                  "tips": [
                                    "Mantenha o método puro: entradas determinam saída, sem efeitos colaterais.",
                                    "Use type hints: def nome(param: int) -> bool:"
                                  ],
                                  "learningObjective": "Escrever métodos estáticos funcionais sem dependências de instância.",
                                  "commonMistakes": [
                                    "Incluir 'self' por hábito de métodos de instância.",
                                    "Acessar variáveis de classe sem 'cls' (para @classmethod)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar a declaração do método estático",
                                  "subSteps": [
                                    "Crie instância da classe (opcional) e chame: Classe.nome_metodo(arg)",
                                    "Tente chamar sem instância: confirme que funciona.",
                                    "Compare com chamada via instância: obj.nome_metodo(arg) também deve funcionar.",
                                    "Adicione print ou assert para validar saída.",
                                    "Execute e depure erros."
                                  ],
                                  "verification": "Método executa corretamente via classe e instância, sem AttributeError.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python REPL ou script de teste",
                                    "Unittest ou pytest para automação"
                                  ],
                                  "tips": [
                                    "Sempre teste chamadas diretas: Classe.metodo() é o hallmark de staticmethod.",
                                    "Use dir(Classe) para listar métodos."
                                  ],
                                  "learningObjective": "Validar funcionalidade de métodos estáticos em cenários reais.",
                                  "commonMistakes": [
                                    "Tentar chamar como obj.metodo() e achar que falhou se não usa self.",
                                    "Esquecer de passar argumentos obrigatórios."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie a classe MathUtils:\n\nclass MathUtils:\n    @staticmethod\n    def is_even(number):\n        return number % 2 == 0\n\n# Teste:\nprint(MathUtils.is_even(4))  # True\nprint(MathUtils.is_even(5))  # False\nobj = MathUtils()\nprint(obj.is_even(4))  # True (também funciona)",
                              "finalVerifications": [
                                "@staticmethod está posicionado corretamente acima da def.",
                                "Assinatura do método não inclui 'self'.",
                                "Método é chamável diretamente pela classe: Classe.metodo(args).",
                                "Não há referências a atributos de instância dentro do método.",
                                "Código executa sem erros de sintaxe ou runtime em chamadas diretas.",
                                "Saída esperada é produzida em testes unitários simples."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe precisa do decorador @staticmethod.",
                                "Ausência completa de 'self' na assinatura e corpo.",
                                "Funcionalidade independente de instâncias.",
                                "Indentação e estrutura de classe corretas.",
                                "Testes demonstram chamada via classe sem erros.",
                                "Lógica do método é coerente e sem side-effects."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Implementação de funções puras e utilitários numéricos.",
                                "Lógica e Algoritmos: Conceitos de funções stateless.",
                                "Design de Software: Padrões de classes utilitárias e singletons.",
                                "Banco de Dados: Métodos estáticos para validações de dados comuns."
                              ],
                              "realWorldApplication": "Métodos estáticos são usados em bibliotecas como math (ex: math.gcd) para utilitários independentes; em frameworks web para validators (ex: validar emails sem instância); factory methods em classes de configuração; ou conversores de dados em APIs."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.2",
                            "name": "Declarar método estático em C++",
                            "description": "Usar a palavra-chave 'static' antes do tipo de retorno e nome do método na declaração da classe, e implementá-lo fora da classe se necessário, acessível via nome da classe.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito e sintaxe básica de métodos estáticos",
                                  "subSteps": [
                                    "Leia a documentação oficial do C++ sobre qualificadores static em métodos de classe.",
                                    "Identifique que métodos estáticos pertencem à classe, não a instâncias, e são acessíveis via nome da classe.",
                                    "Anote exemplos de cenários onde static é útil, como funções utilitárias.",
                                    "Compare com métodos não-estáticos para destacar diferenças.",
                                    "Revise a sintaxe: 'static tipoRetorno nomeMetodo(parametros);' dentro da classe."
                                  ],
                                  "verification": "Explique em suas palavras o que é um método estático e escreva a sintaxe básica em um papel ou editor.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação C++ (cppreference.com)",
                                    "Editor de texto como VS Code",
                                    "Compilador g++"
                                  ],
                                  "tips": "Foquem em funções que não precisam de estado de instância, como cálculos matemáticos.",
                                  "learningObjective": "Compreender o propósito e sintaxe fundamental de métodos estáticos em C++.",
                                  "commonMistakes": [
                                    "Confundir static com métodos de instância",
                                    "Esquecer que static não acessa membros não-estáticos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar um método estático dentro da classe",
                                  "subSteps": [
                                    "Crie uma nova classe simples, ex: class Calculadora {}.",
                                    "Adicione a declaração: static int soma(int a, int b); dentro da seção public.",
                                    "Certifique-se de usar 'static' imediatamente antes do tipo de retorno.",
                                    "Salve o arquivo como Calculadora.h ou inline em main.cpp.",
                                    "Compile para verificar erros de sintaxe."
                                  ],
                                  "verification": "O código compila sem erros de declaração e o método aparece como static no IDE.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (CLion ou VS Code com C++ extension)",
                                    "Compilador g++",
                                    "Terminal para g++ -o teste main.cpp"
                                  ],
                                  "tips": "Use seção public para acessibilidade; evite private inicialmente.",
                                  "learningObjective": "Declarar corretamente um método estático na definição da classe.",
                                  "commonMistakes": [
                                    "Colocar static após o nome do método",
                                    "Omitir ponto e vírgula",
                                    "Declarar em seção private sem getter"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar (definir) o método estático fora da classe",
                                  "subSteps": [
                                    "Fora da classe, escreva: int Calculadora::soma(int a, int b) { return a + b; }",
                                    "Inclua o escopo :: para qualificar com o nome da classe.",
                                    "Adicione static na definição se for inline, mas geralmente só na declaração.",
                                    "Integre em um main() para testar.",
                                    "Compile e execute para validar."
                                  ],
                                  "verification": "O programa executa e retorna o resultado correto sem erros de linker.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmo setup do step anterior",
                                    "Exemplo de código base fornecido"
                                  ],
                                  "tips": "Use :: para evitar ambiguidades em namespaces ou múltiplas classes.",
                                  "learningObjective": "Definir e implementar métodos estáticos corretamente fora da declaração da classe.",
                                  "commonMistakes": [
                                    "Esquecer o :: no escopo",
                                    "Não incluir static na definição (não obrigatório mas confuso)",
                                    "Acessar this-> em static"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Chamar o método estático e verificar funcionalidade",
                                  "subSteps": [
                                    "No main(), chame: int resultado = Calculadora::soma(5, 3);",
                                    "Note que não precisa instanciar a classe (sem Calculadora c;).",
                                    "Adicione cout para imprimir resultado.",
                                    "Teste casos edge: soma(0,0), negativos.",
                                    "Debugue se houver erros de compilação ou runtime."
                                  ],
                                  "verification": "O programa imprime resultados corretos para múltiplos testes sem crashes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código dos steps anteriores",
                                    "Terminal para execução ./teste"
                                  ],
                                  "tips": "Sempre use NomeClasse::metodoStatico() para clareza.",
                                  "learningObjective": "Invocar métodos estáticos corretamente e validar seu comportamento.",
                                  "commonMistakes": [
                                    "Tentar chamar via instância (c.soma())",
                                    "Esquecer includes <iostream>",
                                    "Não testar casos variados"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe MathUtils com método estático double pi() { return 3.14159; }. Declare em classe: static double pi(); Defina fora: double MathUtils::pi() { return 3.14159; }. Chame: cout << MathUtils::pi(); // Saída: 3.14159",
                              "finalVerifications": [
                                "Código compila sem warnings ou erros usando g++.",
                                "Método é acessível via NomeClasse::metodo() sem instância.",
                                "Implementação retorna valores corretos em testes unitários simples.",
                                "Não há acesso a 'this' ou membros não-estáticos dentro do método.",
                                "Comentários explicam uso de 'static' no código.",
                                "Testes com parâmetros variados passam."
                              ],
                              "assessmentCriteria": [
                                "Uso correto da palavra-chave 'static' na declaração.",
                                "Escopo :: utilizado na definição e chamada.",
                                "Método acessível sem criar objeto da classe.",
                                "Sintaxe impecável, sem erros de compilação.",
                                "Exemplo prático funcional e bem documentado.",
                                "Compreensão demonstrada em explicação escrita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Implementação de constantes e funções puras como PI ou factorial.",
                                "Design de Software: Padrões utilitários (Utility Classes) sem estado.",
                                "Lógica Computacional: Entender escopo e visibilidade de funções.",
                                "Física/Engenharia: Bibliotecas de cálculos estáticos para simulações."
                              ],
                              "realWorldApplication": "Em bibliotecas como std::numeric_limits ou custom utilitários em jogos (ex: Math::random()), APIs REST (configurações estáticas), ou ferramentas de logging onde funções não dependem de instâncias específicas, otimizando performance e acessibilidade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.3",
                            "name": "Escrever exemplo básico de método estático",
                            "description": "Criar uma classe com um método estático que realiza uma operação utilitária, como calcular uma constante matemática, e demonstrar sua invocação via classe ou instância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejar e criar a estrutura básica da classe",
                                  "subSteps": [
                                    "Escolha uma operação utilitária simples que não dependa de estado, como converter Celsius para Fahrenheit usando a fórmula (C * 9/5) + 32.",
                                    "Defina o nome da classe como 'TemperatureUtils' para refletir sua finalidade utilitária.",
                                    "Abra seu IDE (ex: IntelliJ ou Eclipse) e crie um novo arquivo Java chamado TemperatureUtils.java.",
                                    "Escreva a declaração da classe: 'public class TemperatureUtils { }'",
                                    "Salve o arquivo e verifique se não há erros de sintaxe iniciais."
                                  ],
                                  "verification": "A classe compila sem erros e está vazia, pronta para adicionar membros.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "IDE Java (IntelliJ, Eclipse ou VS Code com extensão Java), JDK 8 ou superior instalado",
                                  "tips": "Priorize nomes descritivos para classe e método para facilitar reutilização.",
                                  "learningObjective": "Entender o propósito de classes utilitárias com métodos estáticos e criar a estrutura básica.",
                                  "commonMistakes": "Esquecer o modificador 'public' na classe, tornando-a inacessível de outros pacotes; usar métodos de instância desnecessariamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar e implementar o método estático",
                                  "subSteps": [
                                    "Dentro da classe, adicione a assinatura: 'public static double celsiusToFahrenheit(double celsius) { }'.",
                                    "Implemente o corpo do método: 'return (celsius * 9.0 / 5.0) + 32;'.",
                                    "Adicione um comentário Javadoc acima do método explicando seu propósito e parâmetros.",
                                    "Use double para precisão em cálculos de ponto flutuante.",
                                    "Teste compilação parcial para garantir sintaxe correta."
                                  ],
                                  "verification": "Compilar a classe isoladamente e confirmar que o método estático é reconhecido sem instância.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Mesmo IDE e JDK do passo anterior",
                                  "tips": "Sempre use 'static' para métodos que não acessam campos de instância; prefira double para cálculos matemáticos.",
                                  "learningObjective": "Dominar a sintaxe exata de declaração de métodos estáticos e implementar lógica utilitária simples.",
                                  "commonMistakes": "Omitir 'static', causando erro em chamadas via classe; usar int em vez de double, perdendo precisão; esquecer parênteses na fórmula."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar código cliente para demonstrar invocações",
                                  "subSteps": [
                                    "Crie uma nova classe 'TestStaticMethod.java' com método main.",
                                    "No main, invoque via classe: 'System.out.println(TemperatureUtils.celsiusToFahrenheit(0.0));'.",
                                    "Crie uma instância: 'TemperatureUtils utils = new TemperatureUtils();' e invoque via instância: 'System.out.println(utils.celsiusToFahrenheit(100.0));'.",
                                    "Adicione prints para inputs conhecidos (0°C → 32°F, 100°C → 212°F).",
                                    "Importe a classe se necessário (mesmo pacote)."
                                  ],
                                  "verification": "Compilar ambas as classes e verificar se as invocações funcionam sem erros.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "IDE com suporte a múltiplos arquivos, terminal para compilação (opcional)",
                                  "tips": "Demonstre ambas as formas de chamada para reforçar que estáticos são acessíveis via classe ou instância.",
                                  "learningObjective": "Aprender a invocar métodos estáticos de diferentes maneiras e preparar testes.",
                                  "commonMistakes": "Tentar acessar via instância sem criar objeto; esquecer ponto e vírgula ou parênteses nas chamadas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar, depurar e validar o código",
                                  "subSteps": [
                                    "Compile todas as classes: 'javac *.java'.",
                                    "Execute: 'java TestStaticMethod' e verifique saídas (32.0 e 212.0).",
                                    "Teste edge cases: negativo (-40°C → -40°F), decimal (37.0°C → 98.6°F).",
                                    "Use debugger do IDE para inspecionar valores durante execução.",
                                    "Refatore se necessário e documente observações."
                                  ],
                                  "verification": "Saídas corretas para múltiplos inputs; nenhuma exceção ou warning.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Terminal ou console do IDE, JDK com javac/java",
                                  "tips": "Registre saídas esperadas vs. reais em um log para aprendizado.",
                                  "learningObjective": "Validar funcionalidade completa e debugar métodos estáticos.",
                                  "commonMistakes": "Erro de compilação por falta de import; divisão inteira sem .0 (9/5=1); não testar múltiplos cenários."
                                }
                              ],
                              "practicalExample": "// TemperatureUtils.java\npublic class TemperatureUtils {\n  /**\n   * Converte Celsius para Fahrenheit.\n   * @param celsius temperatura em °C\n   * @return temperatura em °F\n   */\n  public static double celsiusToFahrenheit(double celsius) {\n    return (celsius * 9.0 / 5.0) + 32;\n  }\n}\n\n// TestStaticMethod.java\nimport static java.lang.System.out;\npublic class TestStaticMethod {\n  public static void main(String[] args) {\n    out.println(TemperatureUtils.celsiusToFahrenheit(0));     // Via classe: 32.0\n    TemperatureUtils utils = new TemperatureUtils();\n    out.println(utils.celsiusToFahrenheit(100));              // Via instância: 212.0\n  }\n}",
                              "finalVerifications": [
                                "Método compila e executa sem erros de sintaxe ou runtime.",
                                "Invocação via nome da classe retorna resultado correto.",
                                "Invocação via instância de objeto retorna o mesmo resultado.",
                                "Fórmula matemática produz saídas precisas para inputs conhecidos (0°C=32°F, 100°C=212°F).",
                                "Nenhum campo de instância é acessado no método estático.",
                                "Código inclui comentários explicativos."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe correta: 'public static' e tipo de retorno adequados.",
                                "Lógica implementada sem side-effects ou dependência de estado.",
                                "Demonstração explícita de chamadas estáticas e por instância.",
                                "Tratamento apropriado de tipos (double para precisão).",
                                "Código limpo, legível com comentários e testes de validação.",
                                "Ausência de warnings de compilação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aplicação de álgebra linear em fórmulas de conversão.",
                                "Física/Ciências: Compreensão de escalas de temperatura (Celsius/Fahrenheit).",
                                "Engenharia de Software: Padrões de design para bibliotecas utilitárias (ex: java.lang.Math)."
                              ],
                              "realWorldApplication": "Métodos estáticos são fundamentais em bibliotecas como java.lang.Math (Math.PI, Math.sqrt) ou Apache Commons Lang, permitindo funções puras reutilizáveis sem overhead de instâncias, como cálculos utilitários em apps de clima, jogos ou ferramentas científicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.2",
                        "name": "Restrições de Acesso a Membros em Métodos Estáticos",
                        "description": "Limitações impostas aos métodos estáticos quanto ao acesso a variáveis e métodos de instância, enfatizando o uso exclusivo de membros estáticos ou parâmetros passados.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.2.1",
                            "name": "Identificar acesso proibido a membros de instância",
                            "description": "Reconhecer erros de compilação ou runtime ao tentar acessar atributos ou métodos não-estáticos dentro de um método estático, como 'self.atributo' em Python sem instância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a diferença entre membros de instância e membros estáticos",
                                  "subSteps": [
                                    "Revise a definição de atributos e métodos de instância: eles requerem uma instância da classe (self em Python).",
                                    "Estude membros estáticos: declarados com @staticmethod, acessíveis via classe sem instância.",
                                    "Compare exemplos: atributo self.x (instância) vs x no escopo estático.",
                                    "Analise o papel do 'self': passado automaticamente em métodos de instância, ausente em estáticos.",
                                    "Pratique declarando uma classe simples com ambos os tipos."
                                  ],
                                  "verification": "Escreva uma classe com um atributo de instância e um método estático que não acessa self; execute sem erros.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Python 3.x instalado",
                                    "Documentação oficial Python sobre staticmethods"
                                  ],
                                  "tips": "Sempre pergunte: 'Preciso de estado da instância ou é uma operação da classe?'",
                                  "learningObjective": "Diferenciar claramente membros de instância (dependem de self) de estáticos (independentes).",
                                  "commonMistakes": "Confundir métodos estáticos com métodos de classe (@classmethod), que recebem cls."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o contexto de métodos estáticos e suas restrições",
                                  "subSteps": [
                                    "Decore um método com @staticmethod e tente acessá-lo via classe e instância.",
                                    "Tente acessar um atributo de instância dentro do método estático e observe o comportamento.",
                                    "Leia a documentação: métodos estáticos não recebem self ou cls implicitamente.",
                                    "Crie um exemplo funcional: método estático que retorna um valor constante.",
                                    "Teste chamadas: MinhaClasse.metodo_estatico() vs instancia.metodo_estatico()."
                                  ],
                                  "verification": "Execute código onde método estático acessa apenas membros estáticos; confirme funcionamento em ambos contextos.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "REPL Python ou Jupyter Notebook",
                                    "Exemplos de código de classes OOP"
                                  ],
                                  "tips": "Use print statements para rastrear se self está disponível (será NameError).",
                                  "learningObjective": "Compreender que métodos estáticos operam no escopo da classe sem acesso implícito a instância.",
                                  "commonMistakes": "Esquecer o decorator @staticmethod, tornando-o método de instância."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar padrões de acesso proibido em código",
                                  "subSteps": [
                                    "Examine snippets de código com self.atributo ou self.metodo() dentro de @staticmethod.",
                                    "Marque linhas problemáticas: qualquer referência a self ou chamadas de instância.",
                                    "Diferencie erros de compilação (syntax) vs runtime (AttributeError/NameError).",
                                    "Crie uma checklist: 'Há self? É método estático?'.",
                                    "Refatore um código inválido removendo dependências de instância."
                                  ],
                                  "verification": "Analise 3 snippets de código e liste acessos proibidos com justificativa.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Snippets de código de teste",
                                    "Debugger Python (pdb)"
                                  ],
                                  "tips": "Procure por 'self.' como primeiro sinal de alerta em métodos estáticos.",
                                  "learningObjective": "Reconhecer sintaticamente acessos a membros de instância em contextos estáticos.",
                                  "commonMistakes": "Ignorar que métodos não-decorados se comportam como de instância."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reconhecer e diagnosticar erros de compilação ou runtime",
                                  "subSteps": [
                                    "Execute código inválido e capture o traceback: espere NameError ou TypeError.",
                                    "Interprete mensagens: 'self' is not defined ou unbound method.",
                                    "Compare com código válido para contrastar erros.",
                                    "Use linters como pylint para detecção estática de erros.",
                                    "Documente o erro e a solução em um relatório curto."
                                  ],
                                  "verification": "Rode 2 códigos errados, identifique o erro exato e proponha correção.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Terminal com Python",
                                    "Ferramentas de linting (flake8 ou pylint)"
                                  ],
                                  "tips": "Sempre rode o código: teoria sem execução não revela runtime errors.",
                                  "learningObjective": "Associar erros específicos a acessos proibidos em métodos estáticos.",
                                  "commonMistakes": "Confundir NameError de self com variáveis indefinidas."
                                }
                              ],
                              "practicalExample": "Em Python: class Conta:\n    @staticmethod\n    def validar_saldo(self):  # Erro: self não existe aqui!\n        return self.saldo > 0\n\nTentativa de chamada: Conta.validar_saldo() resulta em NameError: name 'self' is not defined. Correção: Remova self e use parâmetro explícito ou torne método de instância.",
                              "finalVerifications": [
                                "Explica por que 'self' causa erro em métodos estáticos.",
                                "Identifica acessos proibidos em um snippet desconhecido.",
                                "Distingue erros de runtime de acessos inválidos vs outros bugs.",
                                "Propõe refatoração para código estático válido.",
                                "Executa e debuga código sem consultar referências.",
                                "Lista 3 restrições de métodos estáticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de self ou membros de instância (100% em testes).",
                                "Interpretação correta de tracebacks relacionados.",
                                "Qualidade das refatorações propostas (funcionais e idiomáticas).",
                                "Velocidade e confiança em análise de código (em <2 min por snippet).",
                                "Uso de terminologia OOP precisa (instância vs estático).",
                                "Criatividade em exemplos práticos fornecidos."
                              ],
                              "crossCurricularConnections": [
                                "Debugging e Lógica Computacional: Análise de erros e tracebacks.",
                                "Design de Software: Princípios de encapsulamento e responsabilidade única.",
                                "Matemática Discreta: Funções puras vs dependentes de estado.",
                                "Engenharia de Software: Boas práticas em APIs utilitárias."
                              ],
                              "realWorldApplication": "Em desenvolvimento de bibliotecas como functools ou math, onde funções estáticas evitam overhead de instâncias desnecessárias; debugging de código legado em equipes para evitar erros sutis em utilitários de classe."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.2",
                            "name": "Acessar corretamente membros estáticos",
                            "description": "Utilizar variáveis e métodos estáticos diretamente pelo nome da classe ou implicitamente dentro do método estático, garantindo independência de instâncias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de membros estáticos",
                                  "subSteps": [
                                    "Leia a definição de variáveis e métodos estáticos na documentação da linguagem (ex: Java).",
                                    "Identifique que membros estáticos pertencem à classe, não à instância.",
                                    "Compare com membros de instância através de diagramas UML simples.",
                                    "Anote exemplos reais como Math.PI em Java.",
                                    "Explique em suas palavras a independência de objetos."
                                  ],
                                  "verification": "Resuma o conceito em um parágrafo coerente sem erros conceituais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Documentação oficial da linguagem (ex: Oracle Java Docs), caderno para anotações",
                                  "tips": "Use analogias: estáticos são como 'propriedades da fábrica', instâncias como 'carros produzidos'.",
                                  "learningObjective": "Diferenciar membros estáticos de não-estáticos e entender sua independência de instâncias.",
                                  "commonMistakes": "Confundir estáticos com globais; achar que precisam de 'new' para acessar."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar variáveis e métodos estáticos",
                                  "subSteps": [
                                    "Crie uma classe simples (ex: MinhaClasse).",
                                    "Declare uma variável estática: 'public static int contador = 0;'.",
                                    "Declare um método estático: 'public static void incrementar() { contador++; }'.",
                                    "Compile a classe para verificar sintaxe.",
                                    "Adicione um método de instância para contraste."
                                  ],
                                  "verification": "Código compila sem erros e declaração é reconhecida pelo IDE.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "IDE (Eclipse, IntelliJ ou VSCode com Java extension), JDK 8+",
                                  "tips": "Sempre use 'static' keyword; teste compilação incrementalmente.",
                                  "learningObjective": "Declarar corretamente membros estáticos com modificadores apropriados.",
                                  "commonMistakes": "Esquecer 'static'; usar 'final' sem necessidade ou incorretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Acessar membros estáticos explicitamente pelo nome da classe",
                                  "subSteps": [
                                    "Em um método main(), acesse: 'MinhaClasse.contador'.",
                                    "Chame método: 'MinhaClasse.incrementar()'.",
                                    "Imprima o valor para observar mudanças.",
                                    "Tente acessar sem instância e confirme funcionamento.",
                                    "Compare com acesso via instância (deve falhar para não-estáticos)."
                                  ],
                                  "verification": "Programa executa e acessa valores corretos sem criar instância.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "IDE com console de saída, classe do step anterior",
                                  "tips": "Use 'ClasseNome.membro' sempre fora da classe para clareza.",
                                  "learningObjective": "Acessar membros estáticos diretamente pelo nome da classe de qualquer contexto.",
                                  "commonMistakes": "Tentar 'new Classe().membroEstatico'; acessar não-estático como estático."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Acessar membros estáticos implicitamente em métodos estáticos",
                                  "subSteps": [
                                    "Dentro de um método estático, acesse diretamente: 'contador++'.",
                                    "Chame outro método estático: 'outroMetodo()'.",
                                    "Teste de dentro de método de instância: use 'ClasseNome.contador'.",
                                    "Execute cenários mistos e observe logs.",
                                    "Refatore código para usar acessos implícitos onde possível."
                                  ],
                                  "verification": "Código roda sem erros de compilação em contextos estáticos e de instância.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "IDE, código expandido dos steps anteriores",
                                  "tips": "Em métodos estáticos, omita o nome da classe para simplicidade.",
                                  "learningObjective": "Utilizar acessos implícitos em contextos estáticos e explícitos em outros.",
                                  "commonMistakes": "Usar 'this' ou instância em método estático; acessar 'this.membroEstatico'."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e depurar erros comuns de acesso",
                                  "subSteps": [
                                    "Introduza erros proposital: acesse não-estático em estático.",
                                    "Compile e analise mensagens de erro (ex: 'non-static variable cannot be referenced').",
                                    "Corrija e recompile até sucesso.",
                                    "Crie teste unitário simples com JUnit para verificações automáticas.",
                                    "Documente 3 erros comuns e soluções."
                                  ],
                                  "verification": "Todos testes passam e documentação de erros está completa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "IDE com JUnit, exemplos de código com erros intencionais",
                                  "tips": "Leia erros de compilação com atenção; use debugger para pausar em falhas.",
                                  "learningObjective": "Identificar e corrigir violações de regras de acesso a membros estáticos.",
                                  "commonMistakes": "Ignorar warnings; confundir escopo de 'this' em estáticos."
                                }
                              ],
                              "practicalExample": "Crie classe Contador:\npublic class Contador {\n  public static int count = 0;\n  public static void incrementar() { count++; }\n  public static int getCount() { return count; }\n}\nEm main: System.out.println(Contador.getCount()); // 0\nContador.incrementar(); System.out.println(Contador.getCount()); // 1\nDentro incrementar(), use implicitamente: count++;",
                              "finalVerifications": [
                                "Código compila e executa sem erros de acesso estático.",
                                "Valores estáticos persistem sem instâncias.",
                                "Testes unitários cobrem acessos explícitos e implícitos.",
                                "Logs mostram mudanças corretas em múltiplas chamadas.",
                                "Nenhum uso de 'this' ou instância em métodos estáticos.",
                                "Documentação pessoal explica regras de acesso."
                              ],
                              "assessmentCriteria": [
                                "Correção sintática em 100% dos acessos estáticos.",
                                "Demonstração de acessos explícitos e implícitos.",
                                "Identificação precisa de 3+ erros comuns.",
                                "Explicação conceitual clara sem confusões.",
                                "Código limpo, comentado e testável.",
                                "Tempo de execução eficiente sem overhead desnecessário."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Constantes universais como PI em classes utilitárias.",
                                "Lógica e Algoritmos: Contadores globais em estruturas de dados.",
                                "Design de Software: Padrões como Utility Classes e Singleton.",
                                "Banco de Dados: Variáveis de configuração compartilhadas."
                              ],
                              "realWorldApplication": "Em sistemas bancários, use contadores estáticos para IDs de transações únicas sem instâncias; em bibliotecas matemáticas como Math, acesse PI ou sqrt() diretamente para cálculos eficientes em qualquer app, evitando criação desnecessária de objetos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.3",
                            "name": "Passar instâncias como parâmetro para acesso indireto",
                            "description": "Receber uma instância como argumento no método estático para acessar seus membros não-estáticos, contornando restrições sem violar o escopo estático.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as restrições de acesso em métodos estáticos",
                                  "subSteps": [
                                    "Revise a declaração de um método estático usando a palavra-chave 'static'.",
                                    "Tente compilar um código onde o método estático acessa diretamente um campo de instância sem parâmetro, observando o erro de compilação.",
                                    "Analise a mensagem de erro: 'Cannot make a static reference to the non-static field'.",
                                    "Explique em suas palavras por que métodos estáticos não têm acesso a 'this' ou membros de instância.",
                                    "Compare com métodos de instância, que acessam membros via 'this'."
                                  ],
                                  "verification": "Identificar e explicar corretamente o erro de compilação em um exemplo simples.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de código (IDE como IntelliJ ou VS Code), documentação oficial de Java sobre métodos estáticos.",
                                  "tips": "Lembre-se: contexto estático é da classe, não de uma instância específica.",
                                  "learningObjective": "Entender as limitações de escopo em métodos estáticos e a necessidade de parâmetros para acesso indireto.",
                                  "commonMistakes": "Confundir métodos estáticos com de instância; ignorar que 'this' não existe em estáticos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar uma classe com membros não-estáticos",
                                  "subSteps": [
                                    "Defina uma classe simples, como 'Pessoa', com um campo privado não-estático (ex: String nome).",
                                    "Adicione um construtor para inicializar o campo de instância.",
                                    "Inclua um método getter não-estático para o campo (ex: getNome()).",
                                    "Crie uma instância da classe no método main e atribua um valor ao campo.",
                                    "Teste a criação da instância imprimindo o valor via getter."
                                  ],
                                  "verification": "Instância criada compila e executa, exibindo o valor do campo corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código, compilador Java (JDK).",
                                  "tips": "Use modificadores de acesso apropriados (private para encapsulamento).",
                                  "learningObjective": "Praticar declaração de membros de instância e sua inicialização.",
                                  "commonMistakes": "Declarar campos como static por engano; esquecer construtor."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar método estático com parâmetro de instância",
                                  "subSteps": [
                                    "Na classe 'Pessoa', declare um método estático público que receba 'Pessoa p' como parâmetro (ex: static void imprimirDados(Pessoa p)).",
                                    "Dentro do método, acesse o campo não-estático via 'p.nome' ou 'p.getNome()'.",
                                    "Adicione lógica simples, como imprimir o nome ou realizar uma operação no campo.",
                                    "Garanta que o método não use 'this' ou acesse outros membros estáticos desnecessariamente.",
                                    "Compile o método isoladamente para verificar ausência de erros."
                                  ],
                                  "verification": "Método compila sem erros e acessa corretamente o membro via parâmetro.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código com autocompletar, referências de API Java.",
                                  "tips": "Nomeie o parâmetro claramente para evitar confusão com nomes de classe.",
                                  "learningObjective": "Aplicar passagem de instância como parâmetro para contornar restrições estáticas.",
                                  "commonMistakes": "Tentar acessar campo diretamente sem 'p.'; esquecer 'static' na declaração."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar o acesso indireto",
                                  "subSteps": [
                                    "No método main, crie uma instância de 'Pessoa' e passe-a como argumento para o método estático.",
                                    "Execute o programa e verifique se o membro não-estático é acessado e exibido corretamente.",
                                    "Adicione um segundo teste com valores diferentes para validar generalidade.",
                                    "Refatore ligeiramente o método para incluir mais acessos (ex: múltiplos campos) e reteste.",
                                    "Documente o código com comentários explicando o contorno da restrição."
                                  ],
                                  "verification": "Programa executa sem exceções, produz output esperado com dados da instância.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Terminal para execução, debugger da IDE.",
                                  "tips": "Use System.out.println para depuração rápida.",
                                  "learningObjective": "Verificar funcionalidade completa do padrão de acesso indireto.",
                                  "commonMistakes": "Passar null como parâmetro (causa NullPointerException); não testar múltiplas instâncias."
                                }
                              ],
                              "practicalExample": "Classe Pessoa:\npublic class Pessoa {\n    private String nome;\n    public Pessoa(String nome) { this.nome = nome; }\n    public String getNome() { return nome; }\n    public static void imprimirDados(Pessoa p) {\n        System.out.println(\"Nome: \" + p.getNome()); // Acesso indireto via p\n    }\n}\nNo main: Pessoa p = new Pessoa(\"João\"); Pessoa.imprimirDados(p); // Output: Nome: João",
                              "finalVerifications": [
                                "Código compila sem erros de referência estática/não-estática.",
                                "Execução exibe dados corretos da instância passada.",
                                "Múltiplas instâncias produzem outputs independentes.",
                                "NullPointerException é evitada com verificação de parâmetro (opcional).",
                                "Comentários explicam o uso do parâmetro para acesso indireto.",
                                "Getter/setter são usados corretamente para encapsulamento."
                              ],
                              "assessmentCriteria": [
                                "Correta declaração de método estático com parâmetro de instância.",
                                "Acesso exclusivo via parâmetro, sem violações de escopo.",
                                "Código limpo, compilável e executável sem warnings.",
                                "Uso de boas práticas: encapsulamento, nomes claros.",
                                "Explicação escrita da técnica em comentários ou relatório.",
                                "Testes cobrem casos positivos e edge cases (ex: null)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de funções parametrizadas e abstração.",
                                "Lógica Computacional: Passagem de argumentos e escopo de variáveis.",
                                "Design de Software: Padrões de design como Factory ou Utility classes.",
                                "Física/Engenharia: Modelagem de objetos com propriedades instanciadas."
                              ],
                              "realWorldApplication": "Em bibliotecas utilitárias como Apache Commons, funções estáticas validam ou processam objetos passados (ex: validação de beans em frameworks); em singletons ou factories para operações centralizadas sem instanciar novos objetos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.4",
                    "name": "Uso de Métodos e Variáveis Estáticas",
                    "description": "Exemplos práticos de invocação e aplicação de métodos e variáveis estáticas em programas OOP.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.4.1",
                        "name": "Variáveis Estáticas",
                        "description": "Variáveis que pertencem à classe em vez de a instâncias individuais, sendo compartilhadas por todos os objetos da classe. Elas mantêm um único valor acessível e modificável independentemente da criação de instâncias, ideais para contadores, configurações globais ou dados comuns.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.1.1",
                            "name": "Declarar e inicializar variáveis estáticas",
                            "description": "Definir uma variável estática no escopo da classe utilizando sintaxe específica, como declaração direta no corpo da classe em Python (ex: class_var = 0) ou 'static' em Java/C++, garantindo que ela seja inicializada uma única vez.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de variáveis estáticas",
                                  "subSteps": [
                                    "Leia a definição: variáveis estáticas pertencem à classe, não a instâncias, e são inicializadas uma única vez.",
                                    "Compare com variáveis de instância: estáticas são compartilhadas por todas as instâncias.",
                                    "Estude exemplos conceituais: contador de objetos criados ou configurações globais da classe.",
                                    "Anote diferenças em memória: estáticas no escopo da classe, acessíveis via nome da classe.",
                                    "Revise quando usar: para estado compartilhado sem dependência de instância."
                                  ],
                                  "verification": "Resuma em 3 frases o que é uma variável estática e suas diferenças com variáveis de instância.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação oficial de Python/Java OOP",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use diagramas de Venn para visualizar compartilhamento vs. individual.",
                                  "learningObjective": "Diferenciar conceitualmente variáveis estáticas de variáveis de instância.",
                                  "commonMistakes": [
                                    "Confundir com variáveis globais fora da classe",
                                    "Achar que estáticas são reinicializadas por instância"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar e inicializar variável estática em Python",
                                  "subSteps": [
                                    "Crie uma classe vazia: class MinhaClasse: pass",
                                    "Adicione no corpo da classe: class_var = 0  # ou qualquer valor inicial",
                                    "Acesse via classe: print(MinhaClasse.class_var)",
                                    "Crie instâncias e verifique: obj1 = MinhaClasse(); print(obj1.class_var)  # mesmo valor",
                                    "Modifique via classe e veja propagação: MinhaClasse.class_var = 10"
                                  ],
                                  "verification": "Execute código e confirme que todas as instâncias veem o mesmo valor alterado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code/IDLE)",
                                    "Console Python interativo"
                                  ],
                                  "tips": "Sempre acesse via nome da classe para evitar confusões com self.",
                                  "learningObjective": "Aplicar sintaxe correta de declaração direta no corpo da classe em Python.",
                                  "commonMistakes": [
                                    "Usar self.class_var em vez de classe.class_var",
                                    "Declarar dentro de __init__ como estática"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Declarar e inicializar variável estática em Java",
                                  "subSteps": [
                                    "Defina classe: public class MinhaClasse {}",
                                    "Adicione: public static int classVar = 0;  // ou private static",
                                    "Compile e acesse: System.out.println(MinhaClasse.classVar);",
                                    "Crie instâncias: MinhaClasse obj1 = new MinhaClasse(); System.out.println(obj1.classVar);",
                                    "Altere: MinhaClasse.classVar = 10; e verifique em múltiplas instâncias."
                                  ],
                                  "verification": "Compilar sem erros e executar, confirmando valor único compartilhado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "JDK instalado",
                                    "IDE como IntelliJ/Eclipse",
                                    "Terminal para javac/java"
                                  ],
                                  "tips": "Use modificadores de acesso (public/private) adequados desde o início.",
                                  "learningObjective": "Dominar sintaxe 'static' no corpo da classe em Java.",
                                  "commonMistakes": [
                                    "Esquecer 'static'",
                                    "Inicializar dentro do construtor",
                                    "Acessar sem qualificador da classe"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, debugar e comparar entre linguagens",
                                  "subSteps": [
                                    "Implemente um contador estático em ambas linguagens: incremente a cada nova instância.",
                                    "Crie método estático para acessar/modificar e teste chamadas.",
                                    "Introduza erro comum (ex: esquecer static) e corrija.",
                                    "Compare sintaxes: Python (direta) vs. Java (static keyword).",
                                    "Documente em um arquivo: código funcional e lições aprendidas."
                                  ],
                                  "verification": "Códigos rodam corretamente, contador funciona em múltiplas instâncias sem reinicialização.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Códigos dos steps anteriores",
                                    "Comparador de sintaxe online"
                                  ],
                                  "tips": "Use print/debugger para rastrear valores em runtime.",
                                  "learningObjective": "Integrar declaração em contextos reais e debugar erros.",
                                  "commonMistakes": [
                                    "Reincializar acidentalmente via construtor",
                                    "Confundir acesso de instância com classe"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe Contador que usa uma variável estática 'count' inicializada em 0. A cada nova instância, incremente count via método estático ou direto. Em Python: class Contador: count = 0; def __init__(self): Contador.count += 1. Em Java: public class Contador { public static int count = 0; public Contador() { count++; } }. Crie 3 instâncias e imprima Contador.count (deve ser 3).",
                              "finalVerifications": [
                                "Declara variável estática corretamente em Python e Java sem erros de sintaxe.",
                                "Confirma que valor é compartilhado e inicializado uma única vez entre instâncias.",
                                "Acessa e modifica via nome da classe, não instância.",
                                "Implementa exemplo prático de contador funcional.",
                                "Identifica e corrige 3 erros comuns de declaração estática.",
                                "Explica diferenças sintáticas entre linguagens em poucas palavras."
                              ],
                              "assessmentCriteria": [
                                "Correção sintática: 100% sem erros de compilação/execução.",
                                "Compreensão conceitual: explica compartilhamento corretamente.",
                                "Prática aplicada: exemplo funcional com inicialização única.",
                                "Debugging: identifica e corrige erros comuns.",
                                "Eficiência: usa acesso via classe consistentemente.",
                                "Documentação: anotações claras sobre testes realizados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: contadores e acumuladores como somas compartilhadas.",
                                "Banco de Dados: variáveis estáticas semelhantes a tabelas globais ou IDs sequenciais.",
                                "Física/Engenharia: modelagem de constantes globais como gravidade em simulações.",
                                "Gestão/Economia: contadores de transações ou estoques compartilhados em sistemas."
                              ],
                              "realWorldApplication": "Em aplicações web, use variáveis estáticas para caches globais (ex: configurações de app) ou contadores de usuários logados, garantindo eficiência sem duplicação por sessão; em jogos, para pontuações high-score compartilhadas entre níveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.2",
                            "name": "Acessar variáveis estáticas via nome da classe",
                            "description": "Invocar e modificar o valor de uma variável estática diretamente pelo nome da classe (ex: Classe.var_estatica), demonstrando que não requer instância do objeto e afeta todas as instâncias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Declarar uma classe com variável estática",
                                  "subSteps": [
                                    "Crie uma nova classe Java em sua IDE, por exemplo, 'ExemploEstatico'.",
                                    "Declare uma variável estática pública dentro da classe, como: public static int contador = 0;",
                                    "Adicione um construtor que incremente o contador: contador++;",
                                    "Crie um método getter para a variável estática: public static int getContador() { return contador; }",
                                    "Compile a classe para verificar se não há erros de sintaxe."
                                  ],
                                  "verification": "A classe compila sem erros e a variável estática é declarada corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "IDE Java (IntelliJ, Eclipse ou VS Code com extensão Java)",
                                    "JDK instalado"
                                  ],
                                  "tips": "Sempre use 'public static' para variáveis compartilhadas entre instâncias.",
                                  "learningObjective": "Compreender como declarar variáveis que pertencem à classe e não às instâncias.",
                                  "commonMistakes": [
                                    "Esquecer o modificador 'static'",
                                    "Declarar como variável de instância sem 'static'",
                                    "Usar tipo primitivo sem inicialização"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Acessar variável estática via nome da classe sem instância",
                                  "subSteps": [
                                    "No método main da classe principal, acesse diretamente: System.out.println(ExemploEstatico.contador);",
                                    "Crie duas instâncias da classe: ExemploEstatico obj1 = new ExemploEstatico(); ExemploEstatico obj2 = new ExemploEstatico();",
                                    "Imprima o valor via instâncias: System.out.println(obj1.getContador()); System.out.println(obj2.getContador());",
                                    "Observe que o acesso via classe funciona sem criar objetos.",
                                    "Execute o programa e verifique a saída no console."
                                  ],
                                  "verification": "O valor da variável é impresso corretamente sem necessidade de instância.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Mesma IDE e JDK do passo anterior",
                                    "Terminal para executar o programa"
                                  ],
                                  "tips": "Use o nome completo da classe (pacote.Classe.var) se houver namespaces.",
                                  "learningObjective": "Demonstrar que variáveis estáticas são acessíveis diretamente pela classe.",
                                  "commonMistakes": [
                                    "Tentar acessar sem qualificar com o nome da classe",
                                    "Confundir com variáveis de instância",
                                    "Esquecer de importar a classe"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modificar variável estática via classe e verificar impacto em instâncias",
                                  "subSteps": [
                                    "No main, modifique via classe: ExemploEstatico.contador = 10;",
                                    "Crie novas instâncias após a modificação e imprima seus contadores.",
                                    "Acesse e imprima via instâncias para confirmar que todas veem o novo valor.",
                                    "Tente modificar via instância (obj1.contador = 5;) e observe se afeta a classe.",
                                    "Execute e analise a saída para confirmar o compartilhamento global."
                                  ],
                                  "verification": "Todas as instâncias refletem a modificação feita via nome da classe.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "IDE Java",
                                    "JDK"
                                  ],
                                  "tips": "Modificações estáticas propagam imediatamente a todas as instâncias.",
                                  "learningObjective": "Verificar que alterações em variáveis estáticas afetam todo o escopo da classe.",
                                  "commonMistakes": [
                                    "Achar que cada instância tem sua própria cópia",
                                    "Usar modificadores private sem getter estático",
                                    "Ignorar thread-safety em ambientes multi-thread"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em um cenário prático e testar exceções",
                                  "subSteps": [
                                    "Crie um método main expandido com menu para acessar/modificar contador.",
                                    "Teste acesso sem instância em cenários de erro (ex: classe não importada).",
                                    "Adicione logs para rastrear acessos: System.out.println('Acessado via classe');",
                                    "Execute múltiplas vezes e verifique consistência.",
                                    "Refatore para usar em uma aplicação simulada de contagem de usuários."
                                  ],
                                  "verification": "O programa executa cenários corretos e incorretos, demonstrando o conceito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE Java",
                                    "JDK"
                                  ],
                                  "tips": "Use try-catch para erros de compilação em testes.",
                                  "learningObjective": "Integrar o conceito em um fluxo prático e identificar edge cases.",
                                  "commonMistakes": [
                                    "Não testar sem instância",
                                    "Confundir com singletons",
                                    "Ignorar visibilidade (private/public)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma classe Banco com 'public static int totalContas = 0;', no main: Banco.totalContas++; cria obj1 e obj2; System.out.println(obj1.totalContas + \" \" + obj2.totalContas); saída: 1 1, provando compartilhamento sem instância.",
                              "finalVerifications": [
                                "Acesso à variável funciona sem criar instância da classe?",
                                "Modificação via nome da classe altera o valor para todas as instâncias?",
                                "O valor é o mesmo quando acessado via instância ou classe?",
                                "Compilação ocorre sem erros de 'non-static variable'?",
                                "Getter estático retorna o valor correto global?",
                                "Não é possível modificar se for private sem método?"
                              ],
                              "assessmentCriteria": [
                                "Código declara corretamente variável com 'static'.",
                                "Demonstra acesso direto via Classe.var sem new.",
                                "Modificação propaga a múltiplas instâncias.",
                                "Saída do console confirma compartilhamento.",
                                "Identifica e evita erros comuns como confusão com instância.",
                                "Inclui verificações e logs para depuração."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Contadores globais semelhantes a acumuladores em somas infinitas.",
                                "Banco de Dados: Variáveis de sessão ou configurações globais em SQL.",
                                "Física: Constantes universais como velocidade da luz, acessíveis globalmente.",
                                "Administração: Métricas compartilhadas em dashboards empresariais."
                              ],
                              "realWorldApplication": "Em aplicações web, contadores de sessões ativas (ex: UserSession.count++) ou caches globais de configurações, permitindo acesso rápido sem instâncias, otimizando performance em servidores multi-usuário."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.3",
                            "name": "Acessar variáveis estáticas via instância",
                            "description": "Acessar a mesma variável estática através de uma instância da classe (ex: obj.var_estatica), ilustrando o compartilhamento de valor e a possibilidade de modificação que reflete em todas as instâncias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Declarar uma classe com variável estática",
                                  "subSteps": [
                                    "Abra seu IDE ou editor de código com suporte a Java.",
                                    "Crie uma nova classe pública chamada 'ContadorExemplo'.",
                                    "Declare uma variável estática dentro da classe: 'public static int valorCompartilhado = 0;'",
                                    "Adicione um método main para testes iniciais.",
                                    "Compile e execute para verificar que a variável é acessível via nome da classe (ContadorExemplo.valorCompartilhado)."
                                  ],
                                  "verification": "A classe compila sem erros e imprimir o valor inicial (0) via acesso direto à classe.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "IDE como IntelliJ IDEA, Eclipse ou VS Code com extensão Java",
                                    "JDK 8 ou superior instalado"
                                  ],
                                  "tips": "Use 'public static' para facilitar o acesso inicial; evite inicializações complexas no campo estático.",
                                  "learningObjective": "Compreender a sintaxe e o escopo de declaração de variáveis estáticas em uma classe.",
                                  "commonMistakes": [
                                    "Esquecer o modificador 'static'",
                                    "Declarar como variável de instância (sem static)",
                                    "Tornar private sem métodos de acesso"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar múltiplas instâncias da classe",
                                  "subSteps": [
                                    "No método main, crie a primeira instância: 'ContadorExemplo obj1 = new ContadorExemplo();'",
                                    "Crie a segunda instância: 'ContadorExemplo obj2 = new ContadorExemplo();'",
                                    "Imprima o valorCompartilhado acessando via obj1 e via obj2 para confirmar valor inicial igual.",
                                    "Execute o código e observe a saída no console.",
                                    "Adicione prints com System.out.println(obj1.valorCompartilhado + \" e \" + obj2.valorCompartilhado);"
                                  ],
                                  "verification": "Ambas as instâncias mostram o mesmo valor inicial (0), confirmando compartilhamento.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Mesmo IDE e JDK do passo anterior",
                                    "Console para observar saídas"
                                  ],
                                  "tips": "Use variáveis descritivas como 'obj1' e 'obj2' para clareza no compartilhamento.",
                                  "learningObjective": "Demonstrar que variáveis estáticas são compartilhadas entre todas as instâncias.",
                                  "commonMistakes": [
                                    "Confundir com variáveis de instância que seriam únicas por objeto",
                                    "Não criar múltiplas instâncias para testar"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Acessar e modificar a variável estática via instância",
                                  "subSteps": [
                                    "Via obj1, modifique o valor: 'obj1.valorCompartilhado = 42;'",
                                    "Imprima o valor via obj1 imediatamente após a modificação.",
                                    "Imprima o valor via obj2 sem modificá-lo diretamente.",
                                    "Execute e verifique se obj2 reflete a mudança feita em obj1.",
                                    "Adicione um terceiro print via nome da classe para comparar."
                                  ],
                                  "verification": "O valor modificado em obj1 (42) aparece igual em obj2 e na classe, provando reflexão global.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "IDE com depurador opcional para breakpoints",
                                    "Console para saídas sequenciais"
                                  ],
                                  "tips": "Coloque prints antes e depois da modificação para visualizar a mudança em tempo real.",
                                  "learningObjective": "Ilustrar que modificações via instância afetam o estado compartilhado de forma global.",
                                  "commonMistakes": [
                                    "Aguardar que variáveis de instância se comportem da mesma forma",
                                    "Modificar via nome da classe e esperar diferença"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e comparar acessos estáticos",
                                  "subSteps": [
                                    "Modifique novamente via nome da classe: 'ContadorExemplo.valorCompartilhado = 100;'",
                                    "Acesse e imprima via obj1, obj2 e classe para comparar.",
                                    "Discuta em comentários no código as implicações de cada acesso.",
                                    "Teste com um depurador se disponível, observando o valor único em memória.",
                                    "Refatore o código adicionando um método estático para acessar/modificar."
                                  ],
                                  "verification": "Todos os acessos (instância e classe) mostram o mesmo valor final (100), com comentários explicativos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE com suporte a depuração",
                                    "Documentação Java sobre static (opcional)"
                                  ],
                                  "tips": "Prefira acesso via nome da classe para clareza semântica, mesmo que via instância funcione.",
                                  "learningObjective": "Diferenciar acessos via instância vs. classe e entender boas práticas.",
                                  "commonMistakes": [
                                    "Acreditar que acesso via instância cria cópias",
                                    "Ignorar warnings de IDE sobre acesso preferencial"
                                  ]
                                }
                              ],
                              "practicalExample": "```java\npublic class ContadorExemplo {\n    public static int valorCompartilhado = 0;\n\n    public static void main(String[] args) {\n        ContadorExemplo obj1 = new ContadorExemplo();\n        ContadorExemplo obj2 = new ContadorExemplo();\n        System.out.println(\"Inicial: \" + obj1.valorCompartilhado + \" e \" + obj2.valorCompartilhado); // 0 e 0\n        obj1.valorCompartilhado = 42;\n        System.out.println(\"Após obj1: \" + obj1.valorCompartilhado + \" e \" + obj2.valorCompartilhado); // 42 e 42\n        ContadorExemplo.valorCompartilhado = 100;\n        System.out.println(\"Após classe: \" + obj1.valorCompartilhado + \" e \" + obj2.valorCompartilhado); // 100 e 100\n    }\n}\n``` Saída esperada demonstra compartilhamento.",
                              "finalVerifications": [
                                "Modificação via instância de um objeto altera o valor para todas as instâncias.",
                                "Acesso via nome da classe reflete mudanças feitas via instância.",
                                "Código compila e executa sem erros de compilação ou runtime.",
                                "Saídas no console confirmam valores idênticos em múltiplas instâncias.",
                                "Comentários no código explicam o comportamento observado.",
                                "Teste com pelo menos três instâncias mostra consistência."
                              ],
                              "assessmentCriteria": [
                                "Correta declaração com 'static' e acessibilidade pública.",
                                "Criação e uso de múltiplas instâncias para demonstrar compartilhamento.",
                                "Modificação via instância resulta em reflexão global comprovada por prints.",
                                "Comparação explícita entre acessos via instância e classe.",
                                "Código limpo com comentários e saídas claras.",
                                "Compreensão demonstrada em explicação escrita do porquê do comportamento."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de contadores globais e variáveis compartilhadas em algoritmos.",
                                "Física: Analogia com constantes universais como a gravidade, acessíveis por qualquer 'instância'.",
                                "Lógica e Filosofia: Conceito de 'estado global' vs. individual em sistemas complexos.",
                                "Inglês Técnico: Leitura de documentação Java sobre modificadores 'static'."
                              ],
                              "realWorldApplication": "Em aplicações como contadores de sessões ativas em servidores web (ex: número total de usuários logados), caches globais em jogos multiplayer ou configurações compartilhadas em frameworks empresariais, onde um valor único deve ser visível e mutável por qualquer instância sem duplicação de memória."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.4",
                            "name": "Aplicar variáveis estáticas em cenários práticos",
                            "description": "Implementar um exemplo real como um contador de instâncias da classe, incrementando a variável estática no construtor para rastrear o total de objetos criados em um programa OOP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejar a estrutura da classe com contador de instâncias",
                                  "subSteps": [
                                    "Analise o cenário prático: rastrear o número total de objetos criados de uma classe específica.",
                                    "Defina o nome da classe (ex: 'Carro') e o nome da variável estática (ex: 'contadorInstancias').",
                                    "Esboce a classe incluindo construtor, variável estática e um método getter futuro.",
                                    "Liste os testes necessários: criar 0, 1, 3 objetos e verificar valores.",
                                    "Desenhe um diagrama simples da classe destacando o membro estático."
                                  ],
                                  "verification": "Esboço ou diagrama da classe revisado e aprovado, confirmando uso de variável estática compartilhada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel, editor de texto ou ferramenta de diagrama como Draw.io",
                                  "tips": "Sempre priorize nomes descritivos para variáveis estáticas para clareza no código.",
                                  "learningObjective": "Compreender o papel de variáveis estáticas como contadores compartilhados entre instâncias.",
                                  "commonMistakes": "Confundir variável estática com variável de instância, que seria única por objeto."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar a variável estática na classe",
                                  "subSteps": [
                                    "Abra o editor de código e crie uma nova classe (ex: public class Carro).",
                                    "Declare a variável dentro da classe: 'private static int contadorInstancias = 0;'.",
                                    "Garanta modificadores 'static' e visibilidade apropriada (private para encapsulamento).",
                                    "Inicialize com zero para começar a contagem corretamente.",
                                    "Compile o código para verificar declaração sem erros."
                                  ],
                                  "verification": "Código compila e a variável é reconhecida como estática ao inspecionar com IDE.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "IDE como IntelliJ, Eclipse ou VS Code com Java",
                                  "tips": "Use 'private static' para evitar acesso direto externo e promover boas práticas OOP.",
                                  "learningObjective": "Implementar declaração correta de variável estática com inicialização.",
                                  "commonMistakes": "Esquecer o modificador 'static', tornando-a variável de instância."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incrementar o contador no construtor",
                                  "subSteps": [
                                    "Crie ou edite o construtor da classe (ex: public Carro() {...}).",
                                    "Adicione a linha 'contadorInstancias++;' como primeira instrução no construtor.",
                                    "Teste compilação após adição.",
                                    "Adicione um parâmetro simples ao construtor para simular uso real (ex: String modelo).",
                                    "Verifique se o incremento ocorre toda vez que o construtor é chamado."
                                  ],
                                  "verification": "Inserir System.out.println(contadorInstancias) no construtor e criar um objeto: imprime 1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "IDE com Java configurado",
                                  "tips": "Coloque o incremento no início do construtor para contar todas as instâncias, mesmo em falhas posteriores.",
                                  "learningObjective": "Integrar lógica de incremento estático no ciclo de vida do objeto via construtor.",
                                  "commonMistakes": "Incrementar em método errado ou esquecer ponto-e-vírgula, causando erro de sintaxe."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar método getter para acessar o contador",
                                  "subSteps": [
                                    "Crie um método público: 'public static int getContadorInstancias() { return contadorInstancias; }'.",
                                    "Garanta que o método seja 'static' para acessar sem instância.",
                                    "Adicione comentários explicando o propósito.",
                                    "Compile e teste chamando o getter sem criar objeto (deve retornar 0).",
                                    "Integre no main para imprimir após criações."
                                  ],
                                  "verification": "Chamar getContadorInstancias() retorna valor atualizado corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "IDE Java",
                                  "tips": "Métodos estáticos são ideais para acessar dados estáticos sem precisar de instância.",
                                  "learningObjective": "Criar acesso controlado e estático a dados compartilhados.",
                                  "commonMistakes": "Tornar o getter não-estático, exigindo instância para chamar."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e validar a implementação completa",
                                  "subSteps": [
                                    "Crie um método main na classe ou em outra para testes.",
                                    "Crie múltiplas instâncias: Carro c1 = new Carro(); System.out.println(Carro.getContadorInstancias());",
                                    "Teste cenários: 0, 1, 3, 5 objetos e verifique saídas 0,1,3,5.",
                                    "Adicione prints no construtor para depuração.",
                                    "Refatore código para remover prints e usar apenas getter."
                                  ],
                                  "verification": "Programa executa e contador reflete exatamente o número de objetos criados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "IDE com terminal para execução",
                                  "tips": "Use asserts ou testes unitários (JUnit) para automação em projetos reais.",
                                  "learningObjective": "Validar comportamento estático em cenários múltiplos de instanciação.",
                                  "commonMistakes": "Resetar contador acidentalmente ou testar sem recompilar."
                                }
                              ],
                              "practicalExample": "Crie uma classe 'Carro' com variável estática 'private static int contadorInstancias = 0;'. No construtor: contadorInstancias++; e String modelo. Método: public static int getContadorInstancias(). No main: crie 3 Carro, imprima getContadorInstancias() após cada (1,2,3). Exemplo código: public class Carro { ... } public static void main(String[] args) { new Carro(); System.out.println(Carro.getContadorInstancias()); //1 ... }",
                              "finalVerifications": [
                                "O contador inicia em 0 antes de qualquer instanciação.",
                                "Cada chamada ao construtor incrementa o contador em exatamente 1.",
                                "O getter retorna o valor atual sem precisar de instância da classe.",
                                "Criação de múltiplas instâncias reflete contagem cumulativa corretamente.",
                                "O código compila e executa sem erros ou exceções.",
                                "Valor persiste entre criações, demonstrando natureza estática."
                              ],
                              "assessmentCriteria": [
                                "Declaração correta da variável como private static com inicialização.",
                                "Incremento implementado exclusivamente no construtor.",
                                "Método getter estático e funcional para acesso.",
                                "Testes abrangentes demonstram comportamento esperado em múltiplos cenários.",
                                "Código limpo, comentado e seguindo convenções OOP (encapsulamento).",
                                "Ausência de erros comuns como variáveis não-estáticas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Uso de contadores e operações aritméticas incrementais.",
                                "Design de Software: Padrões como contadores globais semelhantes a singletons.",
                                "Banco de Dados: Geração de IDs sequenciais sem dependência de tabelas.",
                                "Gestão de Projetos: Rastreamento de métricas compartilhadas em equipes."
                              ],
                              "realWorldApplication": "Em aplicações empresariais, variáveis estáticas contam sessões de usuário ativas, instâncias de conexões de banco gerenciadas ou logs de eventos globais, otimizando alocação de recursos sem bancos de dados adicionais, como em sistemas de e-commerce rastreando pedidos processados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.2",
                        "name": "Métodos Estáticos",
                        "description": "Métodos pertencentes à classe que não requerem uma instância para serem invocados, operando apenas com argumentos passados ou variáveis estáticas, úteis para funções utilitárias, validações ou padrões como factory.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.2.1",
                            "name": "Declarar métodos estáticos",
                            "description": "Definir um método estático na classe usando decorador @staticmethod em Python ou palavra-chave 'static' em Java/C++, sem acesso a 'self' ou 'this' para atributos de instância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Métodos Estáticos",
                                  "subSteps": [
                                    "Estude a definição: métodos estáticos pertencem à classe, não à instância, acessíveis via nome da classe.",
                                    "Compare com métodos de instância: sem acesso a 'self' (Python) ou 'this' (Java/C++).",
                                    "Revise exemplos de documentação oficial: Python @staticmethod, Java/C++ static.",
                                    "Identifique cenários de uso: utilitários, factories, constantes.",
                                    "Anote diferenças entre linguagens: decorador em Python vs. keyword em Java/C++."
                                  ],
                                  "verification": "Explique em suas palavras o que é um método estático e dê um exemplo de quando usá-lo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação Python: https://docs.python.org/3/library/functions.html#staticmethod",
                                    "Documentação Java: Oracle Java Tutorials - Static Methods",
                                    "Compilador/IDE: VS Code, PyCharm, IntelliJ"
                                  ],
                                  "tips": "Foque em 'pertence à classe' para fixar o conceito.",
                                  "learningObjective": "Diferenciar métodos estáticos de métodos de instância e entender restrições de acesso.",
                                  "commonMistakes": [
                                    "Confundir com métodos de classe (@classmethod em Python).",
                                    "Achar que métodos estáticos podem acessar atributos de instância."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar Método Estático em Python",
                                  "subSteps": [
                                    "Crie uma classe simples, ex: class Utils:",
                                    "Adicione o decorador @staticmethod acima do método def metodo_estatico():",
                                    "Implemente o corpo sem usar 'self'.",
                                    "Salve e execute print(Utils.metodo_estatico())."
                                  ],
                                  "verification": "O método é chamado via classe sem instância e executa sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor Python (IDLE, Jupyter)",
                                    "Arquivo .py novo"
                                  ],
                                  "tips": "Use @staticmethod logo acima da def, sem indentação extra.",
                                  "learningObjective": "Aplicar sintaxe correta do @staticmethod em Python.",
                                  "commonMistakes": [
                                    "Esquecer o decorador, tornando-o método de instância.",
                                    "Usar 'self' dentro do método."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Declarar Método Estático em Java ou C++",
                                  "subSteps": [
                                    "Em Java: class Utils { public static void metodoEstatico() { } }",
                                    "Em C++: class Utils { public: static void metodoEstatico() { } };",
                                    "Implemente corpo sem 'this'.",
                                    "Chame via Utils.metodoEstatico() em main.",
                                    "Compile e execute."
                                  ],
                                  "verification": "Compilação bem-sucedida e chamada sem objeto instancia.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "JDK para Java ou GCC para C++",
                                    "IDE: Eclipse, Code::Blocks"
                                  ],
                                  "tips": "Em C++, declare e defina static fora da classe se necessário.",
                                  "learningObjective": "Dominar keyword 'static' em Java/C++ para métodos de classe.",
                                  "commonMistakes": [
                                    "Acessar variáveis de instância dentro do método.",
                                    "Esquecer modificador de acesso (public/private)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Verificar Correção",
                                  "subSteps": [
                                    "Tente acessar atributo de instância dentro do método estático (deve dar erro).",
                                    "Crie instância e chame método via instância (funciona, mas conceitualmente via classe).",
                                    "Adicione print/log para confirmar execução sem self/this.",
                                    "Refatore um método de instância para estático onde apropriado.",
                                    "Documente o código com comentários."
                                  ],
                                  "verification": "Erros ocorrem ao tentar usar self/this; método funciona via classe.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Terminal/Console para execução",
                                    "Debugger do IDE"
                                  ],
                                  "tips": "Use try-catch ou comentários para demonstrar erros intencionais.",
                                  "learningObjective": "Validar que método estático não depende de estado de instância.",
                                  "commonMistakes": [
                                    "Chamar método apenas via instância, ignorando chamada estática.",
                                    "Ignorar warnings de compilador sobre acesso inválido."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe MathUtils com método estático 'multiply(a, b)' que retorna a * b. Chame MathUtils.multiply(3, 4) sem criar instância, imprimindo 12.",
                              "finalVerifications": [
                                "Método declarado com @staticmethod (Python) ou 'static' (Java/C++).",
                                "Chamada via nome da classe sem instância funciona.",
                                "Tentativa de acesso a self/this gera erro de compilação/execução.",
                                "Método executa corretamente com argumentos passados.",
                                "Código comentado explica o porquê de ser estático.",
                                "Não há dependência de atributos de instância."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe 100% correta para a linguagem escolhida.",
                                "Conceitual: explica restrições sem self/this.",
                                "Funcional: método roda e retorna resultado esperado.",
                                "Testes: demonstra erro ao violar regras estáticas.",
                                "Clareza: código legível com comentários.",
                                "Eficiência: sem código desnecessário."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Implementa funções utilitárias como soma/produto.",
                                "Design de Software: Padrões Factory e Utility Classes.",
                                "Lógica Computacional: Abstração e modularidade.",
                                "Banco de Dados: Métodos estáticos para queries utilitárias."
                              ],
                              "realWorldApplication": "Em bibliotecas como Math (Java/Python) para funções como sqrt() ou pi, acessíveis sem instância; em frameworks para factories de objetos ou validações globais, otimizando performance ao evitar criação desnecessária de objetos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.2",
                            "name": "Invocar métodos estáticos via nome da classe",
                            "description": "Chamar um método estático diretamente pelo nome da classe (ex: Classe.metodo_estatico()), executando lógica independente de objetos instanciados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de métodos estáticos",
                                  "subSteps": [
                                    "Leia a definição de método estático: pertence à classe, não a instâncias.",
                                    "Compare com métodos de instância: não requer 'new' para chamar.",
                                    "Identifique cenários de uso: utilitários, constantes, lógica compartilhada.",
                                    "Analise exemplos built-in como Math.PI ou Math.sqrt().",
                                    "Anote diferenças chave em um papel ou editor."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre método estático e de instância, com 2 exemplos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Java sobre static",
                                    "Editor de texto"
                                  ],
                                  "tips": "Lembre-se: estáticos são como funções globais organizadas em classes.",
                                  "learningObjective": "Entender por que e quando usar métodos estáticos.",
                                  "commonMistakes": [
                                    "Confundir com variáveis de instância",
                                    "Achar que precisa de objeto para chamar"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a sintaxe de invocação via nome da classe",
                                  "subSteps": [
                                    "Estude a sintaxe: NomeClasse.metodoStatico(argumentos);",
                                    "Pratique escrevendo sintaxe seca sem código completo.",
                                    "Diferencie de chamada via objeto: obj.metodo() vs Classe.metodo().",
                                    "Teste com exemplo built-in: System.out.println(Math.max(5, 3));",
                                    "Registre 3 variações: sem args, com args, com retorno."
                                  ],
                                  "verification": "Escreva 3 linhas de sintaxe correta para métodos estáticos diferentes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "IDE como IntelliJ ou VS Code",
                                    "Referência Java API"
                                  ],
                                  "tips": "Use o nome completo da classe, mesmo no mesmo pacote.",
                                  "learningObjective": "Dominar a sintaxe exata para invocação estática.",
                                  "commonMistakes": [
                                    "Usar parênteses extras",
                                    "Esquecer ponto entre classe e método"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e invocar um método estático customizado",
                                  "subSteps": [
                                    "Crie uma classe Util com método estático soma(int a, int b).",
                                    "Implemente lógica: return a + b;",
                                    "Invoque no main: int resultado = Util.soma(10, 20);",
                                    "Compile e execute o código.",
                                    "Modifique para outro método, como potencia(int base, int exp)."
                                  ],
                                  "verification": "Código compila e executa produzindo saída correta sem instanciar Util.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador Java (javac/java)",
                                    "IDE"
                                  ],
                                  "tips": "Certifique-se de que o método tem modificador 'static'.",
                                  "learningObjective": "Aplicar invocação em código funcional.",
                                  "commonMistakes": [
                                    "Chamar via new Util().soma()",
                                    "Esquecer import se em pacote diferente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar cenários avançados e depurar erros comuns",
                                  "subSteps": [
                                    "Tente invocar método não-estático estaticamente: observe erro.",
                                    "Use em classes diferentes: pacote ou import.",
                                    "Crie teste com herança: superclasse estática chamada de subclasse.",
                                    "Depure erro 'non-static method cannot be referenced'.",
                                    "Documente lições em comentários no código."
                                  ],
                                  "verification": "Corrija 2 códigos com erros comuns e execute com sucesso.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE com debugger",
                                    "Exemplos de código com erros intencionais"
                                  ],
                                  "tips": "Ferramentas como JUnit para testes unitários estáticos.",
                                  "learningObjective": "Identificar e corrigir problemas na invocação estática.",
                                  "commonMistakes": [
                                    "Acessar variáveis de instância em estático",
                                    "Conflitos de visibilidade (private static)"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie classe Calculadora com método estático static double raizQuadrada(double x) { return Math.sqrt(x); }. No main: System.out.println(Calculadora.raizQuadrada(16)); // Saída: 4.0",
                              "finalVerifications": [
                                "Invoca método estático sem criar instância da classe.",
                                "Código compila sem warnings de non-static reference.",
                                "Método funciona corretamente com diferentes argumentos.",
                                "Explica verbalmente ou por escrito a vantagem sobre métodos de instância.",
                                "Aplica em exemplo built-in e customizado sem erros.",
                                "Depura erro comum relacionado a static."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe precisa: Classe.metodo() usada corretamente.",
                                "Independência de instâncias demonstrada.",
                                "Lógica do método implementada sem side-effects.",
                                "Tratamento de erros em argumentos inválidos.",
                                "Eficiência: evita criação desnecessária de objetos.",
                                "Clareza no código com comentários explicativos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções puras como em bibliotecas numéricas.",
                                "Design de Software: Padrões utilitários e singletons implícitos.",
                                "Lógica Computacional: Procedimentos independentes de estado.",
                                "Banco de Dados: Queries estáticas em ORMs como Hibernate.",
                                "Física/Engenharia: Cálculos constantes em simuladores."
                              ],
                              "realWorldApplication": "Bibliotecas padrão Java como Math.random(), Arrays.sort(), ou frameworks como Apache Commons com métodos utilitários para validações, conversões e cálculos compartilhados em aplicações empresariais, evitando overhead de instâncias."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.3",
                            "name": "Invocar métodos estáticos via instância",
                            "description": "Demonstrar a invocação de método estático através de uma instância (ex: obj.metodo_estatico()), destacando que funciona mas é menos idiomático, delegando à classe.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Métodos Estáticos",
                                  "subSteps": [
                                    "Defina método estático: função pertencente à classe, não requer instância, acessível via nome da classe.",
                                    "Explique diferenças: métodos de instância usam 'self', estáticos não.",
                                    "Identifique cenários de uso: utilitários como cálculos matemáticos ou validações.",
                                    "Revise sintaxe em Python: decorador @staticmethod.",
                                    "Discuta por que invocar via instância 'funciona' mas é menos idiomático."
                                  ],
                                  "verification": "Resuma em 3 frases o que é um método estático e por que invocá-lo via instância não é ideal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Python sobre staticmethod",
                                    "Editor de código (VS Code ou IDLE)"
                                  ],
                                  "tips": "Leia exemplos da documentação oficial para fixar conceitos.",
                                  "learningObjective": "Diferenciar métodos estáticos de métodos de instância e entender acessos válidos.",
                                  "commonMistakes": [
                                    "Confundir com métodos de classe (@classmethod)",
                                    "Achar que métodos estáticos precisam de 'self'"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar uma Classe com Método Estático",
                                  "subSteps": [
                                    "Crie uma classe simples, ex: Calculadora.",
                                    "Adicione um método estático, ex: def somar(a, b): return a + b, com @staticmethod.",
                                    "Teste invocação idiomática: Calculadora.somar(2, 3).",
                                    "Verifique que não precisa instanciar a classe.",
                                    "Adicione print para output visível."
                                  ],
                                  "verification": "Execute o código e confirme que somar(2,3) retorna 5 sem instância.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python 3.x instalado",
                                    "Terminal ou Jupyter Notebook"
                                  ],
                                  "tips": "Use print() para debugar saídas imediatamente.",
                                  "learningObjective": "Implementar corretamente um método estático e invocá-lo via classe.",
                                  "commonMistakes": [
                                    "Esquecer o decorador @staticmethod",
                                    "Passar 'self' como parâmetro"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Invocar Método Estático via Instância",
                                  "subSteps": [
                                    "Instancie a classe: calc = Calculadora().",
                                    "Invoque via instância: calc.somar(2, 3).",
                                    "Observe que funciona e produz o mesmo resultado.",
                                    "Use debugger ou print para rastrear chamada.",
                                    "Note no código que Python delega internamente para a classe."
                                  ],
                                  "verification": "Execute e capture output/screenshot mostrando sucesso via instância.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Mesmo código do Step 2",
                                    "Debugger integrado no IDE"
                                  ],
                                  "tips": "Compare traces de pilha para ver delegação interna.",
                                  "learningObjective": "Demonstrar que invocação via instância é possível, mas não recomendada.",
                                  "commonMistakes": [
                                    "Esperar erro em runtime",
                                    "Não notar delegação para classe"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Melhores Práticas e Refatorar",
                                  "subSteps": [
                                    "Compare pros/cons: via classe é claro e eficiente; via instância confunde leitores.",
                                    "Refatore código para sempre usar via classe.",
                                    "Crie teste unitário distinguindo acessos.",
                                    "Discuta legibilidade em equipes.",
                                    "Documente na classe com comentário explicativo."
                                  ],
                                  "verification": "Escreva um relatório curto (5 linhas) sobre por que evitar via instância.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "PEP 8 guidelines",
                                    "Ferramenta de linting como pylint"
                                  ],
                                  "tips": "Use pylint para checar estilo de código.",
                                  "learningObjective": "Adotar convenções idiomáticas em programação OO.",
                                  "commonMistakes": [
                                    "Ignorar impacto na manutenção de código",
                                    "Não refatorar exemplos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python:\nclass Calculadora:\n    @staticmethod\n    def somar(a, b):\n        return a + b\n\n# Idiomático\nprint(Calculadora.somar(5, 3))  # 8\n\n# Via instância (funciona, mas evite)\ncalc = Calculadora()\nprint(calc.somar(5, 3))  # 8",
                              "finalVerifications": [
                                "Explicar verbalmente por que obj.metodo_estatico() delega para Classe.metodo_estatico().",
                                "Criar e executar código com método estático invocado ambos os jeitos.",
                                "Identificar em código legado qual invocação é usada.",
                                "Refatorar snippet para usar apenas via classe.",
                                "Passar em linting sem warnings de estilo.",
                                "Discutir em 1 parágrafo desvantagens da invocação via instância."
                              ],
                              "assessmentCriteria": [
                                "Correção técnica: código executa sem erros.",
                                "Idiomaticidade: prefere invocação via classe.",
                                "Compreensão conceitual: explica delegação interna.",
                                "Documentação: comentários claros nas diferenças.",
                                "Testes: inclui verificações para ambos acessos.",
                                "Eficiência: evita padrões confusos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: métodos estáticos para funções utilitárias como cálculos.",
                                "Design de Software: princípios de legibilidade e convenções (Clean Code).",
                                "Lógica Computacional: entender binding de métodos em runtime.",
                                "Inglês Técnico: ler docs sobre staticmethod."
                              ],
                              "realWorldApplication": "Em bibliotecas como math.sqrt() ou datetime.now() (estático em algumas impls), desenvolvedores evitam instâncias desnecessárias para clareza; em APIs como Flask.utils, usa-se via classe para helpers globais, melhorando manutenção em equipes."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.4",
                            "name": "Aplicar métodos estáticos em exemplos práticos",
                            "description": "Criar um método estático para validação de dados de entrada ou implementação de um factory method que retorna instâncias configuradas, integrando com variáveis estáticas em um programa completo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejar o método estático e suas integrações",
                                  "subSteps": [
                                    "Escolha o tipo de método estático: validação de dados de entrada (ex: email) ou factory method para criar instâncias configuradas.",
                                    "Defina os parâmetros de entrada, tipo de retorno e variáveis estáticas necessárias (ex: configuração padrão como regex para validação).",
                                    "Esboce a estrutura da classe principal e do programa que usará o método.",
                                    "Identifique casos de uso e edge cases (ex: input inválido).",
                                    "Anote o fluxo: como o método será chamado sem instância da classe."
                                  ],
                                  "verification": "Plano escrito em documento ou comentário no código, cobrindo todos os elementos planejados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de texto (VS Code ou similar), documentação oficial de Java sobre métodos estáticos.",
                                  "tips": "Priorize simplicidade: métodos estáticos são ideais para utilitários independentes de estado de instância.",
                                  "learningObjective": "Compreender quando e por que usar métodos estáticos em cenários práticos.",
                                  "commonMistakes": "Confundir métodos estáticos com métodos de instância, exigindo 'new' desnecessário."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar variáveis e método estático na classe",
                                  "subSteps": [
                                    "Crie uma classe Java (ex: Validator ou Factory).",
                                    "Declare uma variável estática (ex: private static final String DEFAULT_CONFIG = \"regex_pattern\";).",
                                    "Implemente o método estático (ex: public static boolean validateEmail(String email) usando a variável estática).",
                                    "Para factory: public static User createUser(String name) { return new User(name, DEFAULT_AGE); }.",
                                    "Adicione lógica de validação ou configuração dentro do método."
                                  ],
                                  "verification": "Código compila sem erros e método é acessível via NomeClasse.metodo().",
                                  "estimatedTime": "30 minutos",
                                  "materials": "IDE Java (IntelliJ ou Eclipse), JDK instalado.",
                                  "tips": "Use 'static' apenas no que é compartilhado; evite estado mutável em variáveis estáticas.",
                                  "learningObjective": "Desenvolver habilidade em codificar métodos estáticos funcionais com suporte de variáveis estáticas.",
                                  "commonMistakes": "Acessar variáveis de instância dentro de método estático, causando erro de compilação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar o método estático em um programa completo",
                                  "subSteps": [
                                    "Crie uma classe principal com método main().",
                                    "Chame o método estático diretamente (ex: if (Validator.validateEmail(input)) {...}).",
                                    "Incorpore em um fluxo maior, como ler input do usuário e processar.",
                                    "Use o factory para criar múltiplas instâncias configuradas.",
                                    "Exiba resultados ou retorne valores processados."
                                  ],
                                  "verification": "Programa executa e integra o método estático corretamente, produzindo output esperado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Terminal ou console da IDE para execução.",
                                  "tips": "Teste chamadas sem criar instância da classe para reforçar o conceito estático.",
                                  "learningObjective": "Aplicar métodos estáticos em contextos reais de programa.",
                                  "commonMistakes": "Tentar instanciar a classe antes de chamar o método estático."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e refinar a implementação",
                                  "subSteps": [
                                    "Execute o programa com inputs válidos e inválidos.",
                                    "Verifique se variáveis estáticas influenciam corretamente o comportamento.",
                                    "Adicione testes unitários simples (ex: JUnit para método estático).",
                                    "Corrija bugs e otimize (ex: exceções para inputs inválidos).",
                                    "Documente o código com comentários explicando o uso estático."
                                  ],
                                  "verification": "Todos os testes passam e edge cases são tratados adequadamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramentas de teste (JUnit opcional), debugger da IDE.",
                                  "tips": "Use System.out.println para logs durante testes iniciais.",
                                  "learningObjective": "Garantir robustez e corretude na aplicação de métodos estáticos.",
                                  "commonMistakes": "Ignorar thread-safety em variáveis estáticas mutáveis em apps multi-thread."
                                }
                              ],
                              "practicalExample": "Classe Validator:\npublic class Validator {\n    private static final String EMAIL_REGEX = \"^[A-Za-z0-9+_.-]+@(.+)$\";\n    public static boolean validateEmail(String email) {\n        return email.matches(EMAIL_REGEX);\n    }\n}\nPrograma principal:\npublic class Main {\n    public static void main(String[] args) {\n        String input = \"user@example.com\";\n        if (Validator.validateEmail(input)) {\n            System.out.println(\"Válido!\");\n        }\n    }\n}\nOu Factory: public static Car createEconomyCar() { return new Car(\"Economy\", DEFAULT_ENGINE); }",
                              "finalVerifications": [
                                "Método estático é chamado sem instância da classe (ex: Classe.metodo()).",
                                "Variáveis estáticas são usadas corretamente no método.",
                                "Validação ou factory produz resultados esperados para inputs variados.",
                                "Programa completo compila e executa sem erros.",
                                "Edge cases (inputs inválidos) são tratados adequadamente.",
                                "Código está documentado e legível."
                              ],
                              "assessmentCriteria": [
                                "Corretude: Método realiza validação/factory conforme especificado (80%).",
                                "Eficiência: Uso otimizado de static, sem acessos inválidos (10%).",
                                "Robustez: Trata exceções e edge cases (5%).",
                                "Clareza: Código comentado e estruturado (3%).",
                                "Integração: Funciona em programa completo (2%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Expressões regulares e lógica booleana para validação.",
                                "Design de Software: Padrão Factory Method para criação de objetos.",
                                "Segurança da Informação: Validação de inputs contra injeções.",
                                "Banco de Dados: Sanitização de dados antes de inserção."
                              ],
                              "realWorldApplication": "Em aplicações web como validação de formulários (ex: Apache Commons Validator usa métodos estáticos); factories em frameworks como Spring para beans configurados; utilitários como Math.max() ou Collections.sort() em bibliotecas Java."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.5",
                    "name": "Diferenças entre Estáticos e de Instância",
                    "description": "Comparação entre métodos/variáveis estáticos e de instância em termos de escopo e comportamento.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.5.1",
                        "name": "Métodos e Variáveis Estáticas",
                        "description": "Elementos declarados com a palavra-chave 'static' que pertencem à classe em si, não a instâncias específicas. São compartilhados por todas as instâncias da classe e podem ser acessados diretamente pelo nome da classe, sem necessidade de criar um objeto.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.1.1",
                            "name": "Identificar o escopo de variáveis estáticas",
                            "description": "Reconhecer que variáveis estáticas mantêm um único valor compartilhado entre todas as instâncias da classe, inicializado uma vez na carga da classe e acessível globalmente via classe.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de variáveis estáticas",
                                  "subSteps": [
                                    "Revise o que são variáveis de instância: cada objeto tem sua própria cópia.",
                                    "Defina variáveis estáticas: pertencem à classe, compartilhadas por todas as instâncias.",
                                    "Entenda 'escopo': região onde a variável é acessível, para estáticas é a classe inteira.",
                                    "Note que inicialização ocorre uma vez, na carga da classe.",
                                    "Compare com variáveis globais: estáticas são encapsuladas na classe."
                                  ],
                                  "verification": "Escreva uma definição em suas palavras e compare com a documentação oficial.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Java/Kotlin sobre 'static'",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Visualize a classe como um blueprint; estáticas são rabiscadas no blueprint, não nas cópias.",
                                  "learningObjective": "Diferenciar variáveis de instância e estáticas quanto ao escopo e compartilhamento.",
                                  "commonMistakes": [
                                    "Confundir static com global fora da classe",
                                    "Achar que cada instância reinicializa a static"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender declaração e inicialização de variáveis estáticas",
                                  "subSteps": [
                                    "Declare uma variável estática: 'static int contador;' dentro da classe.",
                                    "Inicialize na declaração: 'static int contador = 0;' ou no bloco static {}.",
                                    "Teste inicialização: crie código simples e observe o valor antes de instâncias.",
                                    "Acesse via nome da classe: 'MinhaClasse.contador' mesmo sem instância.",
                                    "Evite acesso via objeto: isso mascara o escopo real."
                                  ],
                                  "verification": "Compile e execute código que acessa a static sem instância e confirme o valor inicial.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE como IntelliJ ou VS Code",
                                    "Compilador Java"
                                  ],
                                  "tips": "Use 'static {}' para inicializações complexas que dependem de ordem.",
                                  "learningObjective": "Saber declarar, inicializar e acessar corretamente variáveis estáticas.",
                                  "commonMistakes": [
                                    "Inicializar no construtor (reinicializa por instância)",
                                    "Acessar só via objeto"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o escopo e acessibilidade de variáveis estáticas",
                                  "subSteps": [
                                    "Identifique o escopo: acessível em toda a classe, métodos estáticos e de instância.",
                                    "Teste visibilidade: publique ou privada, mas sempre via classe para static.",
                                    "Crie múltiplas instâncias e modifique a static: verifique compartilhamento.",
                                    "Analise ciclo de vida: persiste até JVM unload da classe.",
                                    "Discuta thread-safety: use synchronized se multi-threaded."
                                  ],
                                  "verification": "Modifique a static via uma instância e leia via classe; confirme mudança global.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE com debugger",
                                    "Exemplos de código online sobre static"
                                  ],
                                  "tips": "Lembre: static é 'global à classe', não ao programa inteiro.",
                                  "learningObjective": "Reconhecer o escopo global dentro da classe e seu comportamento compartilhado.",
                                  "commonMistakes": [
                                    "Pensar que escopo é limitado à instância",
                                    "Ignorar herança em subclasses"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação de escopo em códigos reais",
                                  "subSteps": [
                                    "Analise código fornecido: destaque declarações static e trace acessos.",
                                    "Crie exercício: adicione static a uma classe existente e teste escopo.",
                                    "Compare cenários: static vs não-static em loops de instâncias.",
                                    "Debug erros comuns: como NullPointer em static mal usado.",
                                    "Refatore código: identifique onde static resolve problemas de compartilhamento."
                                  ],
                                  "verification": "Resolva 3 exercícios de identificação e explique escolhas em relatório curto.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exercícios impressos ou online (LeetCode, HackerRank)",
                                    "IDE para testes"
                                  ],
                                  "tips": "Procure 'static' e pergunte: 'Isso muda para todas as instâncias?'",
                                  "learningObjective": "Identificar corretamente o escopo de variáveis estáticas em qualquer código.",
                                  "commonMistakes": [
                                    "Não notar acessos via classe",
                                    "Confundir com singletons"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe 'ContaBancaria' com 'static int totalContas = 0;'. No construtor, incremente totalContas. Crie 3 instâncias: totalContas será 3 para todas, acessível como ContaBancaria.totalContas, demonstrando escopo compartilhado e inicialização única.",
                              "finalVerifications": [
                                "Explicar por que uma variável static mantém valor único após múltiplas instâncias.",
                                "Identificar em código: qual linha declara static com escopo de classe.",
                                "Prever saída: imprimir static antes/depois de construtores.",
                                "Diferenciar acesso: classe vs instância sem erros.",
                                "Descrever inicialização: quando e quantas vezes ocorre.",
                                "Reconhecer limite: não acessível fora da classe sem qualificação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de escopo static (compartilhado, classe-level).",
                                "Correta identificação em exemplos de código (100% acerto).",
                                "Explicação clara de inicialização única e acessibilidade.",
                                "Uso correto de terminologia (escopo, lifecycle, compartilhamento).",
                                "Aplicação em cenários práticos sem confusão com instância.",
                                "Análise de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Constantes globais como π, compartilhadas em cálculos.",
                                "Física: Propriedades invariantes como velocidade da luz em simulações.",
                                "Banco de Dados: Contadores de conexões globais em pools.",
                                "Economia: Variáveis de mercado compartilhadas como taxa de juros.",
                                "Biologia: Contadores de população em modelos ecológicos."
                              ],
                              "realWorldApplication": "Em aplicativos web, variáveis estáticas contam usuários ativos simultâneos (ex: ChatApp.totalUsuariosOnline), caches globais de configurações ou logs centralizados, garantindo eficiência sem duplicação por usuário."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.2",
                            "name": "Declarar e acessar métodos estáticos",
                            "description": "Criar métodos estáticos que não recebem 'self' ou 'this' implicitamente, não acessam variáveis de instância e são invocados diretamente pela classe, como ClassName.metodoEstatico().",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Diferença entre Métodos de Instância e Estáticos",
                                  "subSteps": [
                                    "Leia a definição de método de instância: recebe 'self' implicitamente, acessa atributos e métodos da instância específica.",
                                    "Estude método estático: decorado com @staticmethod, não recebe 'self', não acessa variáveis de instância, pertence à classe.",
                                    "Analise exemplos: método de instância como def get_nome(self): return self.nome; estático como @staticmethod def utilitario(): return 'valor'.",
                                    "Anote pelo menos 3 diferenças chave (ex: acesso a self, invocação, propósito).",
                                    "Pense em 2 cenários reais onde cada tipo é preferível."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo as diferenças em suas próprias palavras e compartilhe com um colega ou anote.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação oficial Python @staticmethod (docs.python.org)",
                                    "Notebook para anotações",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Métodos estáticos organizam funções relacionadas à classe sem estado de instância, como utilitários.",
                                  "learningObjective": "Diferenciar conceitualmente métodos estáticos de métodos de instância para uso apropriado.",
                                  "commonMistakes": [
                                    "Confundir e incluir 'self' em estáticos.",
                                    "Achar que estáticos requerem sempre instância para chamada."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar um Método Estático Corretamente",
                                  "subSteps": [
                                    "Crie uma classe vazia: class MinhaClasse: pass",
                                    "Adicione o decorador: @staticmethod logo acima da definição do método.",
                                    "Defina o método sem 'self': def meu_estatico(): print('Método estático executado!')",
                                    "Salve em um arquivo .py e execute para checar sintaxe.",
                                    "Adicione um return simples para testar, ex: return 'Sucesso'."
                                  ],
                                  "verification": "Execute o script e confirme ausência de erros de sintaxe; método reconhecido pelo interpretador.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, PyCharm ou IDLE)",
                                    "Python 3.x instalado"
                                  ],
                                  "tips": "O @staticmethod é um decorador; em classes antigas, use staticmethod(meu_estatico), mas prefira o moderno.",
                                  "learningObjective": "Produzir sintaxe válida para declaração de método estático.",
                                  "commonMistakes": [
                                    "Esquecer o @staticmethod, causando comportamento como método de instância.",
                                    "Incluir 'self' por hábito, gerando erro ao chamar."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Acessar e Invocar Métodos Estáticos",
                                  "subSteps": [
                                    "Sem criar instância, chame diretamente: MinhaClasse.meu_estatico()",
                                    "Adicione parâmetros: @staticmethod def somar(a, b): return a + b",
                                    "Teste: print(MinhaClasse.somar(4, 6)) deve imprimir 10.",
                                    "Crie uma instância opcionalmente e chame via ela para comparar: obj = MinhaClasse(); obj.somar(4,6)",
                                    "Registre saídas em comentários no código."
                                  ],
                                  "verification": "Método executa corretamente via nome da classe sem instância e produz saída esperada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Mesmo arquivo .py do step anterior",
                                    "Terminal para execução python arquivo.py"
                                  ],
                                  "tips": "Idiomático chamar via classe; via instância funciona mas não é recomendado para clareza.",
                                  "learningObjective": "Invocar métodos estáticos de forma direta e correta.",
                                  "commonMistakes": [
                                    "Chamar como obj.metodo() obrigatoriamente.",
                                    "Erro de digitação no nome da classe."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e Testar em Exemplo Completo com Verificação de Diferenças",
                                  "subSteps": [
                                    "Crie classe Utilitarios com método estático: @staticmethod def eh_par(n): return n % 2 == 0",
                                    "Adicione método de instância: def __init__(self, valor): self.valor = valor; def get_valor(self): return self.valor",
                                    "Teste: print(Utilitarios.eh_par(4)) e obj = Utilitarios(10); print(obj.get_valor())",
                                    "Compare: tente acessar self.valor no estático (erro esperado) e corrija.",
                                    "Adicione comentários explicando diferenças observadas."
                                  ],
                                  "verification": "Código roda integralmente; estático funciona sem instância, instância requer objeto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Terminal Python"
                                  ],
                                  "tips": "Use assert para testes automáticos: assert Utilitarios.eh_par(4) == True",
                                  "learningObjective": "Aplicar métodos estáticos em contexto real, contrastando com de instância.",
                                  "commonMistakes": [
                                    "Referenciar self ou atributos de instância no método estático.",
                                    "Não testar ambos os tipos."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie a classe Calculadora: class Calculadora: @staticmethod def somar(a, b): return a + b; @staticmethod def multiplicar(a, b): return a * b. No script principal: print(Calculadora.somar(5, 3))  # Saída: 8; print(Calculadora.multiplicar(4, 2))  # Saída: 8. Nenhum objeto criado, funções utilitárias acessadas diretamente via classe.",
                              "finalVerifications": [
                                "Método declarado com @staticmethod e sem parâmetro 'self'.",
                                "Invocação bem-sucedida diretamente pela classe (ClassName.metodo()).",
                                "Método não acessa variáveis ou métodos de instância.",
                                "Testes com parâmetros produzem resultados corretos.",
                                "Diferenças com métodos de instância demonstradas via código funcional.",
                                "Código executa sem erros de runtime ou sintaxe."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe precisa do decorador @staticmethod.",
                                "Ausência total de 'self' ou referências a instância no método.",
                                "Chamadas corretas via nome da classe sem instância.",
                                "Funcionalidade comprovada com testes e saídas esperadas.",
                                "Código comentado explicando escolhas e diferenças.",
                                "Estrutura limpa, legível e sem warnings no interpretador."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Implementação de operações aritméticas independentes como funções utilitárias.",
                                "Lógica e Algoritmos: Criação de funções reutilizáveis sem estado.",
                                "Design de Software: Padrões de classes utilitárias e modularidade.",
                                "Ciência da Computação: Abstração e encapsulamento em OOP.",
                                "Engenharia de Software: Bibliotecas de helpers estáticos."
                              ],
                              "realWorldApplication": "Bibliotecas padrão como math (math.sqrt(x), math.pi) usam métodos e atributos estáticos para utilitários globais sem instância. Em projetos, classes como StringUtils com is_valid_email(email) ou DateUtils.format_date(data) organizam funções comuns, acessíveis diretamente, promovendo código limpo e reutilizável em apps web, APIs e ferramentas de dados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.3",
                            "name": "Explicar o comportamento em linguagens como Python e C++",
                            "description": "Comparar uso em Python (@staticmethod) e C++ (static), destacando que em Python são definidos em classes mas funcionam como funções globais, sem herança de instância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender métodos estáticos em Python com @staticmethod",
                                  "subSteps": [
                                    "Leia a documentação oficial do Python sobre @staticmethod (https://docs.python.org/3/library/functions.html#staticmethod).",
                                    "Crie uma classe simples com um método decorado por @staticmethod.",
                                    "Teste chamando o método diretamente pela classe (ex: ClassName.method()).",
                                    "Teste chamando o método por uma instância da classe (ex: obj.method()).",
                                    "Verifique que o método não recebe 'self' e não acessa atributos de instância."
                                  ],
                                  "verification": "Execute o código e confirme que o método funciona sem instância e imprime a saída esperada sem erros de 'self'.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de código Python (ex: VS Code, PyCharm)",
                                    "Documentação Python oficial"
                                  ],
                                  "tips": "@staticmethod transforma o método em uma função regular associada à classe, ignorando o primeiro argumento (self).",
                                  "learningObjective": "Compreender a definição, sintaxe e chamada de métodos estáticos em Python.",
                                  "commonMistakes": [
                                    "Confundir @staticmethod com @classmethod (que recebe cls).",
                                    "Tentar acessar atributos de instância dentro do método estático."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender métodos estáticos em C++ com 'static'",
                                  "subSteps": [
                                    "Estude a documentação C++ sobre funções membro estáticas (ex: cppreference.com).",
                                    "Declare uma classe com um método membro 'static' no header (.h).",
                                    "Defina o método no arquivo .cpp.",
                                    "Compile e chame o método pela classe (ex: ClassName::method()).",
                                    "Teste chamada por instância e verifique que não acessa membros não-estáticos."
                                  ],
                                  "verification": "Compilar e executar o programa sem erros, confirmando que o método estático é acessível sem objeto.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Compilador C++ (ex: g++ via terminal ou IDE como CLion)",
                                    "Referência C++ (cppreference.com)",
                                    "Arquivos .h e .cpp"
                                  ],
                                  "tips": "Em C++, métodos static pertencem à classe, não à instância, e não podem acessar membros não-estáticos.",
                                  "learningObjective": "Dominar a sintaxe e restrições de métodos estáticos em C++.",
                                  "commonMistakes": [
                                    "Esquecer o escopo :: ao chamar pela classe.",
                                    "Acessar membros não-estáticos dentro de static, causando erro de compilação."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar comportamentos entre Python e C++",
                                  "subSteps": [
                                    "Crie tabelas comparativas: sintaxe, acesso (classe vs instância), herança.",
                                    "Note que em Python, @staticmethod ignora self e age como função global namespaced.",
                                    "Analise herança: em Python, copiados para subclasses; em C++, compartilhados.",
                                    "Teste herança criando subclasses em ambos e chamando o método estático.",
                                    "Discuta ausência de 'herança de instância' em Python (sem acesso a self)."
                                  ],
                                  "verification": "Preencha uma tabela de comparação e execute códigos de herança sem erros.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha ou documento para tabela comparativa",
                                    "Códigos de exemplo de ambos os passos anteriores"
                                  ],
                                  "tips": "Foque na diferença chave: Python permite chamada por instância por conveniência, mas sem self.",
                                  "learningObjective": "Identificar semelhanças e diferenças, especialmente herança e acesso a instância.",
                                  "commonMistakes": [
                                    "Ignorar que Python staticmethods não herdam estado de instância.",
                                    "Confundir com métodos de instância."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e sintetizar explicação",
                                  "subSteps": [
                                    "Escreva um parágrafo explicando o comportamento em ambas linguagens.",
                                    "Crie um exemplo unificado mostrando uso em contexto de herança.",
                                    "Explique verbalmente ou grave um vídeo de 2 min resumindo diferenças.",
                                    "Responda a perguntas hipotéticas sobre cenários reais.",
                                    "Revise e refine a explicação com base em testes."
                                  ],
                                  "verification": "Sua explicação cobre sintaxe, chamada, herança e ausência de instância em Python.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Gravador de vídeo ou notas",
                                    "Códigos consolidados"
                                  ],
                                  "tips": "Use analogia: em Python, como função global 'emprestada' pela classe.",
                                  "learningObjective": "Capacitar-se a explicar claramente as diferenças para outros.",
                                  "commonMistakes": [
                                    "Omitir que em Python funcionam como funções globais sem herança de instância.",
                                    "Generalizar incorretamente herança."
                                  ]
                                }
                              ],
                              "practicalExample": "**Python:**\nclass Animal:\n    @staticmethod\n    def make_sound():\n        print('Some sound')\nclass Dog(Animal):\n    pass\nAnimal.make_sound()  # Some sound\nDog.make_sound()     # Some sound (copiado, sem self)\n\n**C++:**\nclass Animal {\npublic:\n    static void makeSound() { std::cout << \"Some sound\" << std::endl; }\n};\nclass Dog : public Animal {};\nAnimal::makeSound(); // Some sound\nDog::makeSound();    // Some sound (compartilhado)",
                              "finalVerifications": [
                                "Pode definir corretamente @staticmethod em Python e static em C++ sem erros.",
                                "Explica que Python staticmethods não recebem self e funcionam como funções globais.",
                                "Demonstra chamada por classe e instância em ambos.",
                                "Mostra herança: copiados/compartilhados, sem herança de instância em Python.",
                                "Identifica restrições: sem acesso a não-estáticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sintaxe e exemplos de código (sem erros).",
                                "Clareza na explicação de diferenças chave (herança, self).",
                                "Uso de analogias ou tabelas para comparação.",
                                "Capacidade de responder dúvidas sobre cenários reais.",
                                "Profundidade: cobre acesso, herança e aplicações."
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Conceitos de herança e encapsulamento em OOP.",
                                "Matemática: Funções puras e stateless, semelhantes a funções matemáticas.",
                                "Design de Software: Padrões como Utility Classes e Factory Methods.",
                                "Linguística: Comparação de terminologia técnica entre linguagens."
                              ],
                              "realWorldApplication": "Em bibliotecas utilitárias (ex: funções matemáticas em classes como math_utils), singletons ou métodos de fábrica que não dependem de estado de instância, otimizando performance e reutilização em projetos multi-classe."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.2",
                        "name": "Métodos e Variáveis de Instância",
                        "description": "Elementos que pertencem a cada objeto (instância) individual da classe. Cada instância tem sua própria cópia, acessível apenas após criar um objeto via obj.variavel ou obj.metodo().",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.2.1",
                            "name": "Identificar o escopo de variáveis de instância",
                            "description": "Entender que cada objeto mantém valores independentes para variáveis de instância, alterados individualmente sem afetar outras instâncias da mesma classe.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Teórico de Variáveis de Instância",
                                  "subSteps": [
                                    "Leia a definição: variáveis de instância pertencem a cada objeto individual, não à classe.",
                                    "Compare com variáveis estáticas: estas são compartilhadas por todas as instâncias.",
                                    "Desenhe um diagrama mostrando uma classe com duas instâncias e seus valores independentes.",
                                    "Explique em suas palavras por que alterar uma instância não afeta outra.",
                                    "Revise exemplos de documentação oficial de linguagens OOP como Python ou Java."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo o escopo e recite sem consultar notas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação OOP (Python/Java)",
                                    "Papel e caneta para diagrama",
                                    "Editor de texto"
                                  ],
                                  "tips": "Visualize objetos como casas idênticas no blueprint (classe), mas com móveis diferentes (variáveis de instância).",
                                  "learningObjective": "Definir e diferenciar o escopo de variáveis de instância de estáticas.",
                                  "commonMistakes": [
                                    "Confundir escopo de instância com global ou estático.",
                                    "Achar que construtor cria variáveis compartilhadas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar uma Classe Simples com Variáveis de Instância",
                                  "subSteps": [
                                    "Crie uma classe 'Carro' com variáveis de instância: cor e velocidade.",
                                    "Adicione um construtor (__init__ em Python) para inicializar essas variáveis.",
                                    "Inclua um método 'acelerar()' que modifica apenas a velocidade da instância.",
                                    "Teste criando um objeto e chamando o método.",
                                    "Imprima os valores para confirmar inicialização."
                                  ],
                                  "verification": "Execute o código e confirme que o objeto mantém seus valores iniciais antes da modificação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE como VS Code ou PyCharm",
                                    "Interpretador Python"
                                  ],
                                  "tips": "Use print() em cada atributo para rastrear mudanças durante o desenvolvimento.",
                                  "learningObjective": "Criar e inicializar variáveis de instância em uma classe funcional.",
                                  "commonMistakes": [
                                    "Declarar variáveis fora do construtor como estáticas acidentalmente.",
                                    "Esquecer self. ou this. ao acessar variáveis de instância."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar Independência com Múltiplas Instâncias",
                                  "subSteps": [
                                    "Crie duas instâncias da classe 'Carro' com valores iniciais diferentes.",
                                    "Modifique a velocidade de apenas uma instância usando o método acelerar().",
                                    "Imprima os atributos de ambas as instâncias para verificar independência.",
                                    "Tente modificar diretamente uma variável de uma instância e observe o impacto.",
                                    "Repita com um terceiro objeto para reforçar o conceito."
                                  ],
                                  "verification": "Confirme via prints que a segunda instância reteve seu valor original.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código da Step 2",
                                    "Terminal para execução interativa"
                                  ],
                                  "tips": "Nomeie instâncias claramente como carro1, carro2 para evitar confusão.",
                                  "learningObjective": "Provar empiricamente que variáveis de instância são independentes por objeto.",
                                  "commonMistakes": [
                                    "Usar variáveis estáticas por engano, causando compartilhamento.",
                                    "Modificar a classe em vez da instância."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Contrastar com Variáveis Estáticas e Aplicar em Cenário Complexo",
                                  "subSteps": [
                                    "Adicione uma variável estática à classe 'Carro' (e.g., totalCarros).",
                                    "Crie instâncias e modifique a estática; observe o compartilhamento.",
                                    "Compare saídas com variáveis de instância via prints lado a lado.",
                                    "Expanda para uma classe 'ContaBancaria' com saldo (instância) e taxaJuros (estática).",
                                    "Simule depósitos em contas separadas."
                                  ],
                                  "verification": "Gere relatório comparativo das saídas mostrando diferenças de escopo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código anterior",
                                    "Notebook Jupyter para visualização tabular"
                                  ],
                                  "tips": "Use asserts para automação: assert carro1.velocidade != carro2.velocidade após mudança.",
                                  "learningObjective": "Diferenciar comportamentos e aplicar em exemplo realista.",
                                  "commonMistakes": [
                                    "Ignorar modificadores de acesso como static.",
                                    "Confundir métodos de instância com estáticos."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe ContaBancaria com saldo (variável de instância). Instancie conta1 (saldo=1000) e conta2 (saldo=500). Deposite 200 em conta1. Imprima: conta1.saldo deve ser 1200, conta2.saldo permanece 500, provando independência.",
                              "finalVerifications": [
                                "Crie 3 instâncias de uma classe e altere variáveis de instância em 2 delas; confirme independência via prints.",
                                "Identifique e corrija código onde variável de instância parece compartilhada (é estática).",
                                "Explique verbalmente ou por escrito o escopo usando diagrama de objetos.",
                                "Modifique uma instância e verifique que métodos de outras instâncias não são afetados.",
                                "Compare saídas de código com e sem static em variáveis semelhantes.",
                                "Simule erro comum: inicializar instância var fora do construtor e debugar."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação teórica do escopo (sem confusão com estáticos).",
                                "Código funcional com múltiplas instâncias demonstrando independência.",
                                "Uso correto de construtores e métodos de instância.",
                                "Identificação de erros comuns em cenários de compartilhamento indevido.",
                                "Aplicação em exemplo prático sem orientação.",
                                "Relatório claro comparando instância vs. estática."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Similar a variáveis locais em funções, independentes por chamada.",
                                "Biologia: Cada organismo (instância) tem características únicas apesar do mesmo genótipo (classe).",
                                "Física: Cada partícula tem posição/velocidade independentes no espaço.",
                                "Economia: Cada conta bancária tem saldo próprio, não compartilhado."
                              ],
                              "realWorldApplication": "Em aplicativos de jogos, cada personagem (instância) tem vida/saúde independentes; alterar um não afeta outros. Em sistemas bancários, cada cliente tem saldo único, permitindo transações isoladas sem impacto global."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.2.2",
                            "name": "Declarar e invocar métodos de instância",
                            "description": "Definir métodos que recebem referência à instância ('self' em Python, 'this' em C++), permitindo acesso a variáveis de instância, e invocá-los apenas em objetos criados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender conceitos fundamentais de métodos de instância",
                                  "subSteps": [
                                    "Estude a diferença entre métodos de instância e estáticos: métodos de instância recebem 'self' (Python) ou 'this' (C++) como primeiro parâmetro.",
                                    "Aprenda que métodos de instância acessam variáveis de instância específicas do objeto.",
                                    "Revise exemplos simples de classes sem métodos para contrastar.",
                                    "Identifique cenários onde métodos de instância são necessários (ex: personalização por objeto).",
                                    "Anote definições chave em um caderno."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre método de instância e estático, com exemplos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial Python (docs.python.org), Documentação C++ (cppreference.com)",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Use diagramas UML para visualizar 'self/this' apontando para o objeto.",
                                  "learningObjective": "Compreender o papel e a sintaxe inicial de métodos de instância em OOP.",
                                  "commonMistakes": [
                                    "Confundir com métodos estáticos (sem self/this)",
                                    "Esquecer que eles operam em instâncias específicas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar métodos de instância em Python",
                                  "subSteps": [
                                    "Crie uma classe simples, ex: class Carro: com variáveis de instância como self.velocidade = 0.",
                                    "Defina um método def acelerar(self, incremento): self.velocidade += incremento.",
                                    "Adicione outro método def status(self): print(f'Velocidade: {self.velocidade}')",
                                    "Salve o código em um arquivo .py.",
                                    "Teste declaração sem invocar para verificar sintaxe."
                                  ],
                                  "verification": "O código roda sem erros de sintaxe ao definir a classe.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python instalado (versão 3.8+)",
                                    "IDE como VS Code ou PyCharm"
                                  ],
                                  "tips": "Sempre use 'self' como primeiro parâmetro; idente corretamente.",
                                  "learningObjective": "Dominar a declaração de métodos que acessam variáveis de instância via 'self'.",
                                  "commonMistakes": [
                                    "Omitir 'self' na definição",
                                    "Não inicializar variáveis no __init__"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Invocar métodos de instância e demonstrar acesso a dados",
                                  "subSteps": [
                                    "Crie uma instância: meu_carro = Carro()",
                                    "Invoque métodos: meu_carro.acelerar(50); meu_carro.status()",
                                    "Crie múltiplas instâncias e mostre independência: carro2 = Carro(); carro2.acelerar(30)",
                                    "Adicione verificação: assert meu_carro.velocidade == 50",
                                    "Execute e observe saídas."
                                  ],
                                  "verification": "Múltiplas instâncias mantêm estados independentes após invocações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Terminal ou Jupyter Notebook",
                                    "Código do Step 2"
                                  ],
                                  "tips": "Invocação sempre via objeto: obj.metodo(), nunca Classe.metodo().",
                                  "learningObjective": "Executar invocações corretas e validar acesso a variáveis de instância.",
                                  "commonMistakes": [
                                    "Chamar método diretamente na classe",
                                    "Confundir ordem de argumentos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e praticar em C++",
                                  "subSteps": [
                                    "Traduza para C++: class Carro { int velocidade; public: void acelerar(int inc) { velocidade += inc; } int getVelocidade() { return velocidade; } };",
                                    "Crie objetos: Carro meuCarro; meuCarro.acelerar(50);",
                                    "Compare sintaxe: 'this->velocidade' explícito se necessário.",
                                    "Compile e execute: g++ arquivo.cpp -o exec && ./exec",
                                    "Reflita sobre similaridades/diferenças com Python."
                                  ],
                                  "verification": "Programa C++ compila e roda, mostrando velocidades independentes.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Compilador g++ instalado",
                                    "Editor com suporte C++"
                                  ],
                                  "tips": "Em C++, métodos não precisam de 'this' explícito na maioria dos casos.",
                                  "learningObjective": "Aplicar conceitos cross-language e reforçar compreensão.",
                                  "commonMistakes": [
                                    "Esquecer ponto-e-vírgula em declarações C++",
                                    "Não declarar variáveis como membro"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe ContaBancaria com self.saldo = 0 e método depositar(self, valor): self.saldo += valor. Instancie duas contas, deposite valores diferentes e imprima saldos para verificar independência.",
                              "finalVerifications": [
                                "Declara método com 'self' (Python) ou acessa via 'this' (C++) sem erros.",
                                "Invoca método apenas em objetos instanciados, não na classe.",
                                "Método modifica corretamente variáveis de instância específicas do objeto.",
                                "Cria múltiplas instâncias com comportamentos independentes.",
                                "Código executa sem exceções e produz saídas esperadas.",
                                "Explica verbalmente o fluxo de 'self/this' durante invocação."
                              ],
                              "assessmentCriteria": [
                                "Correção sintática na declaração (100% dos casos testados).",
                                "Acesso preciso a variáveis de instância (sem escopo errado).",
                                "Invocação exclusiva via instância (sem chamadas estáticas acidentais).",
                                "Independência de estados entre objetos (testes com asserts).",
                                "Clareza e documentação no código (comentários em métodos).",
                                "Eficiência: métodos simples e sem loops desnecessários."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica de modificação de estados (aritmética em variáveis).",
                                "Língua Portuguesa/Inglês: Documentação de código e nomenclatura clara.",
                                "Física: Modelagem de objetos reais (ex: carro com velocidade).",
                                "Design: Princípios de encapsulamento em OOP como abstração."
                              ],
                              "realWorldApplication": "Em desenvolvimento de jogos (métodos para mover personagens individualmente), apps bancários (gerenciar saldos por usuário) ou simulações (atualizar atributos de entidades únicas como veículos em um tráfego virtual)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.3",
                        "name": "Diferenças entre Estáticos e de Instância",
                        "description": "Comparação direta: estáticos têm escopo de classe (compartilhados, sem instância necessária), enquanto de instância têm escopo por objeto (individuais, requerem instância); comportamentos incluem restrições de acesso mútuo.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.3.1",
                            "name": "Comparar escopo e acessibilidade",
                            "description": "Diferenciar que estáticos são acessados via Classe.nomedoElemento (sem objeto) e de instância via objeto.nomedoElemento, com estáticos visíveis em toda a aplicação após carga da classe.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições básicas de membros estáticos e de instância",
                                  "subSteps": [
                                    "Leia a documentação oficial sobre variáveis e métodos estáticos em Java (Oracle Docs).",
                                    "Anote as diferenças fundamentais: estáticos pertencem à classe, de instância pertencem ao objeto.",
                                    "Identifique que estáticos são inicializados quando a classe é carregada pela JVM.",
                                    "Crie um diagrama mental ou no papel mostrando classe vs. objetos e seus membros.",
                                    "Liste 3 exemplos de uso comum de cada tipo em bibliotecas padrão (ex: Math.PI é estático)."
                                  ],
                                  "verification": "Você pode explicar verbalmente ou por escrito as diferenças sem consultar notas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação Java (docs.oracle.com), caderno para anotações, editor de texto.",
                                  "tips": "Use analogias: estáticos como 'propriedade do prédio', instância como 'móvel do apartamento'.",
                                  "learningObjective": "Compreender os conceitos fundamentais de escopo de classe vs. objeto.",
                                  "commonMistakes": "Confundir inicialização (estáticos na carga da classe vs. construtor para instância)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e testar acesso a membros estáticos",
                                  "subSteps": [
                                    "Crie uma classe simples com uma variável e método estáticos (ex: public static int contador = 0; public static void incrementar()).",
                                    "Acesse-os diretamente via NomeDaClasse.contador e NomeDaClasse.incrementar() sem instanciar.",
                                    "Compile e execute o código, imprimindo valores para confirmar acesso global.",
                                    "Adicione um main() que use apenas chamadas estáticas e observe o comportamento.",
                                    "Teste carregamento: crie múltiplas classes e verifique visibilidade após carga."
                                  ],
                                  "verification": "Código compila e executa sem erros, acessando estáticos sem objeto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "IDE como IntelliJ ou VS Code com JDK 8+, terminal para compilação.",
                                  "tips": "Sempre use 'static' no modificador e teste com 'java NomeDaClasse'.",
                                  "learningObjective": "Demonstrar acesso via nome da classe e visibilidade app-wide.",
                                  "commonMistakes": "Tentar acessar estático via objeto (funciona mas mascara o escopo real)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e testar acesso a membros de instância",
                                  "subSteps": [
                                    "Na mesma classe, adicione variáveis e métodos de instância (ex: private int id; public void setId(int i)).",
                                    "Crie um objeto com 'new NomeDaClasse()' e acesse via objeto.id e objeto.setId(1).",
                                    "Teste múltiplos objetos: cada um tem seu próprio valor de instância.",
                                    "Tente acessar sem objeto (deve dar erro de compilação).",
                                    "Compare saídas com o passo anterior em um programa unificado."
                                  ],
                                  "verification": "Código requer instância para acessar membros de instância; erro sem 'new'.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesma IDE e JDK do passo anterior, arquivo .java expandido.",
                                  "tips": "Use System.out.println em loops para mostrar diferenças entre objetos.",
                                  "learningObjective": "Contrastar acesso dependente de objeto com estáticos.",
                                  "commonMistakes": "Esquecer 'new' ou confundir com acesso estático acidental."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar escopo e acessibilidade em cenários práticos",
                                  "subSteps": [
                                    "Crie um programa que use ambos: contador estático compartilhado vs. IDs únicos por objeto.",
                                    "Teste visibilidade: carregue classe via Class.forName() e acesse estático sem main tradicional.",
                                    "Analise erros: tente acessar instância estáticamente e vice-versa; documente mensagens.",
                                    "Meça escopo: execute em app com múltiplas threads e observe compartilhamento estático.",
                                    "Resuma em tabela: coluna 'Estático' vs 'Instância' para acesso, escopo, visibilidade."
                                  ],
                                  "verification": "Tabela ou relatório compara corretamente os 3 aspectos (acesso, escopo, visibilidade).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "IDE com debugger, JDK com suporte a reflection (Class.forName).",
                                  "tips": "Use reflection para simular carga dinâmica e destacar visibilidade pós-carregamento.",
                                  "learningObjective": "Sintetizar diferenças em contexto real de aplicação.",
                                  "commonMistakes": "Ignorar que estáticos são únicos por classe loader (visibilidade não é infinita)."
                                }
                              ],
                              "practicalExample": "Em uma classe ContaBancaria: static double TAXA_JUROS = 0.05; (acesso: ContaBancaria.TAXA_JUROS). Cada conta tem double saldo; (acesso: conta1.saldo). TAXA_JUROS é compartilhada app-wide após carga da classe.",
                              "finalVerifications": [
                                "Explicar sem hesitação: 'Math.PI' é acessado como Math.PI, não new Math().PI.",
                                "Identificar erro em código: tentativa de 'new Classe().metodoStatico()' como inadequada.",
                                "Demonstrar que static init roda na primeira referência à classe.",
                                "Criar 2 objetos e provar que variáveis de instância diferem, mas estática é igual.",
                                "Discutir por que singletons usam privados não-estáticos mas fábricas estáticas.",
                                "Testar em IDE: refatorar instância para estática e vice-versa sem quebrar código."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção de sintaxe: Classe.estatico vs objeto.instancia (100% correto).",
                                "Compreensão de escopo: Correta identificação de visibilidade pós-carregamento da classe.",
                                "Exemplos práticos: Pelo menos 2 cenários reais com código funcional.",
                                "Análise de erros: Identificação e explicação de 3+ erros comuns de compilação/execução.",
                                "Síntese comparativa: Tabela ou diagrama claro contrastando os conceitos.",
                                "Aplicação contextual: Ligação a boas práticas OOO (ex: constantes globais)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de funções globais vs. parametrizadas (análogas a estáticas/instância).",
                                "Design de Software: Padrões como Singleton (usa privados não-estáticos + fábrica estática).",
                                "Banco de Dados: Variáveis de sessão (instância) vs. configurações globais (estáticas).",
                                "Física/Engenharia: Propriedades intrínsecas do material (estáticas) vs. estado do objeto (instância)."
                              ],
                              "realWorldApplication": "Em apps bancários, taxas de juros estáticas são acessíveis globalmente sem instância de conta; saldos de conta são por instância, garantindo isolamento e escalabilidade em servidores multi-threaded."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.1",
                              "10.1.5.5.2"
                            ]
                          },
                          {
                            "id": "10.1.5.5.3.2",
                            "name": "Analisar comportamento e restrições",
                            "description": "Explicar que métodos estáticos não acessam variáveis de instância (erro em tempo de execução), enquanto métodos de instância acessam ambos; discutir memória (estáticos em área estática, instância em heap por objeto).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Conceituar métodos estáticos e métodos de instância",
                                  "subSteps": [
                                    "Ler a definição de método estático: pertence à classe, não requer instância para ser chamado.",
                                    "Ler a definição de método de instância: pertence ao objeto, requer instância para acesso.",
                                    "Comparar sintaxe: static no método estático vs. ausência em método de instância.",
                                    "Identificar exemplos básicos em código Java.",
                                    "Explicar que estáticos são compartilhados por todas as instâncias."
                                  ],
                                  "verification": "Escrever definições curtas e exemplos de código para cada tipo de método.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (IntelliJ ou VS Code)",
                                    "Documentação oficial Java sobre modificador static"
                                  ],
                                  "tips": "Sempre pense em 'classe vs. objeto' para diferenciar.",
                                  "learningObjective": "Diferenciar conceitualmente métodos estáticos de métodos de instância.",
                                  "commonMistakes": [
                                    "Confundir com variáveis; lembrar que métodos seguem regras semelhantes às variáveis."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar acesso a variáveis de instância e estáticas",
                                  "subSteps": [
                                    "Testar chamada de variável de instância dentro de método estático: observar erro de compilação ou runtime.",
                                    "Testar chamada de variável estática dentro de método estático: confirmar sucesso.",
                                    "Testar ambos os acessos dentro de método de instância: confirmar sucesso.",
                                    "Executar código com 'this' em método de instância para acessar variáveis de instância.",
                                    "Documentar o erro exato: 'non-static variable cannot be referenced from a static context'."
                                  ],
                                  "verification": "Compilar e executar 3 snippets de código mostrando sucessos e falhas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "JDK instalado",
                                    "Editor com terminal integrado",
                                    "Snippets de código de exemplo"
                                  ],
                                  "tips": "Use System.out.println para debugar acessos e erros.",
                                  "learningObjective": "Identificar restrições de acesso e prever erros de runtime/compilação.",
                                  "commonMistakes": [
                                    "Achar que erro é só de compilação; testar runtime para métodos não-void."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender alocação de memória",
                                  "subSteps": [
                                    "Explicar área estática (Method Area/PermGen): única por classe, para estáticos.",
                                    "Explicar heap: uma área por objeto para variáveis de instância.",
                                    "Desenhar diagrama: classe com estática compartilhada vs. múltiplos objetos no heap.",
                                    "Discutir ciclo de vida: estática vive enquanto JVM; instância com garbage collection.",
                                    "Comparar com analogia: estática como 'geladeira da casa', instância como 'geladeira de cada quarto'."
                                  ],
                                  "verification": "Criar diagrama manual ou digital ilustrando memória para 2 objetos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta como Draw.io",
                                    "Artigo sobre JVM Memory Model"
                                  ],
                                  "tips": "Visualize: sem objeto, só estática existe.",
                                  "learningObjective": "Associar comportamentos de acesso às diferenças de memória.",
                                  "commonMistakes": [
                                    "Confundir heap com stack; heap é para objetos, stack para primitivas locais."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar análise de cenários reais com restrições",
                                  "subSteps": [
                                    "Analisar código legado: identificar por que método estático falha com instância.",
                                    "Refatorar: mover lógica para método de instância ou passar objeto como parâmetro.",
                                    "Simular cenários: contador global (estático) vs. contador por usuário (instância).",
                                    "Discutir trade-offs: performance (estático mais rápido) vs. flexibilidade.",
                                    "Testar em main: chamar estático diretamente vs. via instância."
                                  ],
                                  "verification": "Refatorar 2 códigos com erros e testar execução sem falhas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Códigos de exemplo com erros intencionais",
                                    "Debugger do IDE"
                                  ],
                                  "tips": "Pergunte: 'Preciso de estado do objeto?' Se sim, use instância.",
                                  "learningObjective": "Aplicar conhecimentos para diagnosticar e corrigir restrições.",
                                  "commonMistakes": [
                                    "Ignorar performance; estáticos evitam criação desnecessária de objetos."
                                  ]
                                }
                              ],
                              "practicalExample": "Em Java: class Exemplo { int instancia = 10; static int estatica = 20; static void metodoStatico() { System.out.println(instancia); // ERRO: non-static field 'instancia' cannot be referenced from a static context } void metodoInstancia() { System.out.println(instancia); System.out.println(estatica); // Ambos OK } public static void main(String[] args) { metodoStatico(); // Runtime/Compile error Exemplo obj = new Exemplo(); obj.metodoInstancia(); // OK } } Estática na Method Area (compartilhada), instância no Heap por objeto.",
                              "finalVerifications": [
                                "Explicar verbalmente por que método estático gera erro ao acessar variável de instância.",
                                "Executar código demonstrando acesso bem-sucedido apenas em método de instância.",
                                "Desenhar mapa de memória correto para classe com 2 objetos.",
                                "Identificar e corrigir 3 erros comuns em código fornecido.",
                                "Discutir quando usar estático vs. instância em um cenário real."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação de erros de acesso (100% correto).",
                                "Correção na representação de alocação de memória (diagrama sem falhas).",
                                "Capacidade de refatorar código com restrições (funciona sem erros).",
                                "Profundidade na discussão de trade-offs (pelo menos 3 pontos).",
                                "Uso correto de terminologia (static, instance, heap, method area).",
                                "Execução prática sem runtime errors em testes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de funções globais vs. parametrizadas (estático como constante global).",
                                "Física: Analogia de memória como espaço compartilhado vs. individual (energia potencial).",
                                "Lógica: Análise de restrições como em provas matemáticas (condições necessárias).",
                                "Inglês Técnico: Leitura de stack traces e documentação JVM."
                              ],
                              "realWorldApplication": "Em aplicações web (Spring Boot), métodos estáticos para utilitários globais como Math.random() ou configurações de log; variáveis de instância para dados por usuário (e.g., carrinho de compras). Evita erros em singletons ou factories, otimizando memória em apps escaláveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.1",
                              "10.1.5.5.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.6",
                "name": "Estruturas de Dados OO e Tipos Genéricos",
                "description": "Estruturas de dados orientadas a objetos e suporte a tipos genéricos para maior flexibilidade.",
                "totalSkills": 46,
                "atomicTopics": [
                  {
                    "id": "10.1.6.1",
                    "name": "Estruturas de Dados Orientadas a Objetos",
                    "description": "Princípios de implementação de estruturas como listas, pilhas e filas utilizando classes, objetos e encapsulamento.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.1.1",
                        "name": "Encapsulamento e Abstração em Estruturas de Dados OO",
                        "description": "Princípios de encapsulamento para ocultar detalhes de implementação de estruturas de dados como listas, pilhas e filas, utilizando classes para abstrair dados e operações, promovendo reutilização e manutenção.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.1.1",
                            "name": "Definir classes para encapsular estruturas de dados",
                            "description": "Criar classes em linguagens OO como Python ou C++ que encapsulem elementos de dados (nós) e operações (inserir, remover), utilizando atributos privados e métodos públicos para acessar e modificar o estado interno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Encapsulamento",
                                  "subSteps": [
                                    "Estude a definição de encapsulamento: ocultar detalhes internos e expor apenas interfaces públicas.",
                                    "Aprenda sobre atributos privados (ex: _data em Python ou private em C++) e métodos públicos (getters/setters).",
                                    "Analise exemplos simples de classes sem encapsulamento vs. com encapsulamento.",
                                    "Identifique benefícios: segurança de dados, modularidade e manutenção.",
                                    "Revise abstração como complemento ao encapsulamento em estruturas de dados."
                                  ],
                                  "verification": "Explique em suas palavras os 4 benefícios do encapsulamento e dê um exemplo de violação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Python OOP",
                                    "Tutoriais online sobre encapsulamento (Real Python ou GeeksforGeeks)"
                                  ],
                                  "tips": "Use convenções como _ para protected em Python; memorize que private previne acesso acidental.",
                                  "learningObjective": "Dominar os princípios teóricos de encapsulamento para justificar seu uso em classes de dados.",
                                  "commonMistakes": [
                                    "Confundir encapsulamento com herança",
                                    "Expor todos atributos como públicos",
                                    "Ignorar name mangling em Python"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Planejar a Estrutura da Classe para um Nó de Lista Ligada",
                                  "subSteps": [
                                    "Defina os atributos privados: _data (valor do nó) e _next (referência ao próximo nó).",
                                    "Liste métodos públicos necessários: __init__, get_data(), set_data(), get_next(), set_next(), inserir_dado(), remover_proximo().",
                                    "Desenhe um diagrama UML simples da classe com visibilidade (+ público, - privado).",
                                    "Considere genéricos: planeje para tipos como int ou str (use typing em Python).",
                                    "Valide o design: garanta que estado interno só mude via métodos."
                                  ],
                                  "verification": "Crie um esboço em papel ou ferramenta como draw.io mostrando atributos privados e métodos públicos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta ou draw.io/Lucidchart",
                                    "Referência UML para classes"
                                  ],
                                  "tips": "Comece com o mínimo viável; adicione genéricos depois para escalabilidade.",
                                  "learningObjective": "Projetar classes que encapsulem dados de estruturas como nós, priorizando interfaces limpas.",
                                  "commonMistakes": [
                                    "Incluir lógica de lista inteira na classe Node",
                                    "Esquecer ponteiros/referências em _next",
                                    "Misturar dados públicos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a Classe em Python com Encapsulamento",
                                  "subSteps": [
                                    "Crie o arquivo node.py e defina class Node: com __init__ inicializando _data e _next=None.",
                                    "Implemente getters/setters: def get_data(self): return self._data; def set_data(self, data): self._data = data.",
                                    "Adicione métodos operacionais: def append_next(self, node): self._next = node; def remove_next(self): self._next = None.",
                                    "Use typing: from typing import Any; _data: Any; _next: 'Node | None'.",
                                    "Teste básico: crie instância e acesse via métodos, confirme erro em self._data direto."
                                  ],
                                  "verification": "Execute código e confirme AttributeError ao acessar self._data diretamente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de código (VS Code/PyCharm)",
                                    "Python 3.8+ instalado"
                                  ],
                                  "tips": "Use pylint ou mypy para checar convenções de private; teste em REPL primeiro.",
                                  "learningObjective": "Codificar classes funcionais que demonstrem encapsulamento estrito em Python.",
                                  "commonMistakes": [
                                    "Esquecer self em métodos",
                                    "Não tratar None em _next",
                                    "Publicar _data acidentalmente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Refinar Encapsulamento e Operações",
                                  "subSteps": [
                                    "Escreva testes unitários com unittest: teste init, getters/setters, inserir/remover.",
                                    "Simule violações: tente acessar/modificar _data diretamente e capture exceções.",
                                    "Adicione validações nos setters: ex: if data is None: raise ValueError.",
                                    "Compare com C++: esboce equivalente usando private e public.",
                                    "Refatore para genéricos reais com TypeVar se avançado."
                                  ],
                                  "verification": "Rode suite de testes: 100% pass com encapsulamento intacto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "unittest ou pytest",
                                    "Exemplos C++ OOP online"
                                  ],
                                  "tips": "Mock entradas inválidas cedo; use assertRaises para checar privacidade.",
                                  "learningObjective": "Validar e iterar na classe para garantir robustez e aderência a OO.",
                                  "commonMistakes": [
                                    "Testes superficiais sem checar privacidade",
                                    "Ignorar edge cases como None",
                                    "Sobre-engenharia sem necessidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Classe Node para lista ligada em Python:\n```python\nfrom typing import Any\n\nclass Node:\n    def __init__(self, data: Any):\n        self._data: Any = data\n        self._next: 'Node | None' = None\n\n    def get_data(self) -> Any:\n        return self._data\n\n    def set_data(self, data: Any) -> None:\n        self._data = data\n\n    def get_next(self) -> 'Node | None':\n        return self._next\n\n    def set_next(self, next_node: 'Node | None') -> None:\n        self._next = next_node\n```\nUso: node = Node(42); print(node.get_data())  # OK; print(node._data)  # Convenção privada, evite.",
                              "finalVerifications": [
                                "Atributos _data e _next não são acessíveis diretamente sem convenção privada violada.",
                                "Métodos públicos alteram estado interno corretamente sem expor detalhes.",
                                "Instância pode ser criada e encadeada via append_next sem erros.",
                                "Testes unitários passam para todas operações (inserir/remover).",
                                "Explicação oral: 'Por que getters/setters em vez de atributos públicos?'.",
                                "Adaptação rápida para C++: private int _data; public int getData() {return _data;}"
                              ],
                              "assessmentCriteria": [
                                "Todos atributos são privados (convenção _ ou private keyword).",
                                "Métodos públicos cobrem todas operações essenciais sem vazamento de estado.",
                                "Código é limpo, com typing e sem erros de sintaxe.",
                                "Testes demonstram encapsulamento (AttributeError ou warnings em acesso direto).",
                                "Design suporta genéricos e extensibilidade para listas/grafos.",
                                "Tempo de execução eficiente para operações básicas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de grafos e árvores com nós encapsulados.",
                                "Design de Software: Princípios SOLID (especialmente Single Responsibility).",
                                "Ciência da Computação: Fundamentos de ADT (Abstract Data Types).",
                                "Engenharia de Software: Padrões como Factory para criação de nós."
                              ],
                              "realWorldApplication": "Em implementações de árvores binárias para busca em bancos de dados (ex: índices B-Tree), grafos em redes sociais (nós como usuários/amigos), ou pilhas/filas em simuladores de sistemas operacionais, garantindo que dados sensíveis (ex: senhas em nós de autenticação) sejam protegidos contra acessos indevidos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.2",
                            "name": "Aplicar abstração em interfaces de estruturas",
                            "description": "Desenvolver interfaces ou classes abstratas que definam contratos para operações comuns (ex: push, pop) em pilhas e filas, escondendo a implementação específica de listas encadeadas ou arrays.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar operações essenciais para pilhas e filas",
                                  "subSteps": [
                                    "Liste as operações padrão de uma pilha (Stack): push (inserir), pop (remover topo), peek (ver topo), isEmpty (verificar vazia), size (tamanho).",
                                    "Liste as operações padrão de uma fila (Queue): enqueue (inserir final), dequeue (remover frente), front/peek (ver frente), isEmpty, size.",
                                    "Documente pré-condições e pós-condições para cada operação (ex: pop em pilha vazia lança exceção).",
                                    "Compare operações comuns entre pilha e fila para identificar o contrato abstrato.",
                                    "Crie um diagrama simples (UML ou texto) mostrando as operações."
                                  ],
                                  "verification": "Documentação completa com listas de operações, pré/pós-condições e diagrama salvo em arquivo texto ou imagem.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto (Notepad++), Documentação Java Collections (Stack/Queue)"
                                  ],
                                  "tips": [
                                    "Priorize operações LIFO para pilha e FIFO para fila; inclua exceções para casos de erro."
                                  ],
                                  "learningObjective": "Compreender as operações fundamentais e contratos de pilhas e filas para abstração.",
                                  "commonMistakes": [
                                    "Confundir LIFO/FIFO",
                                    "Esquecer métodos de consulta (peek/front)",
                                    "Ignorar tratamento de pilha/fila vazia"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolver a interface genérica IStack<T>",
                                  "subSteps": [
                                    "Crie um novo arquivo Java: public interface IStack<T> {}",
                                    "Adicione void push(T item);",
                                    "Adicione T pop() throws Exception;",
                                    "Adicione T peek() throws Exception;",
                                    "Adicione boolean isEmpty(); e int size();",
                                    "Compile a interface para verificar sintaxe."
                                  ],
                                  "verification": "Interface IStack<T> compila sem erros e contém exatamente os 5 métodos declarados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE (IntelliJ, Eclipse ou VS Code com Java extension)",
                                    "JDK 8+ instalado"
                                  ],
                                  "tips": [
                                    "Use <T> para genéricos; declare exceções em pop/peek para casos vazios."
                                  ],
                                  "learningObjective": "Criar um contrato abstrato para pilhas usando interfaces genéricas.",
                                  "commonMistakes": [
                                    "Esquecer genéricos <T>",
                                    "Implementar métodos na interface",
                                    "Não declarar exceções necessárias"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver a interface genérica IQueue<T>",
                                  "subSteps": [
                                    "Crie public interface IQueue<T> {}",
                                    "Adicione void enqueue(T item);",
                                    "Adicione T dequeue() throws Exception;",
                                    "Adicione T front() throws Exception;",
                                    "Adicione boolean isEmpty(); e int size();",
                                    "Compile e compare com IStack para reutilização de ideias."
                                  ],
                                  "verification": "Interface IQueue<T> compila sem erros e contém os 5 métodos corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Mesma IDE e JDK do passo anterior"
                                  ],
                                  "tips": [
                                    "Mantenha consistência com IStack; front() é equivalente a peek() em fila."
                                  ],
                                  "learningObjective": "Estender abstração para filas, reforçando padrões de interfaces.",
                                  "commonMistakes": [
                                    "Usar push/pop em vez de enqueue/dequeue",
                                    "Confundir ordem FIFO",
                                    "Variar assinaturas entre interfaces"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar classes concretas usando arrays",
                                  "subSteps": [
                                    "Crie class ArrayStack<T> implements IStack<T> { private T[] data; private int top; ... }",
                                    "Implemente push: redimensione array se cheio, data[++top] = item.",
                                    "Implemente pop/peek: verifique vazia, retorne data[top] e decrement top.",
                                    "Repita para ArrayQueue<T> implements IQueue<T> usando array circular.",
                                    "Adicione construtor com capacidade inicial (ex: 10) e métodos isEmpty/size."
                                  ],
                                  "verification": "Classes compilam e testes unitários básicos (push/pop 5 itens) funcionam sem vazamentos ou erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "IDE com debugger",
                                    "JUnit para testes simples (opcional)"
                                  ],
                                  "tips": [
                                    "Use array dinâmico com resize; trate exceções como IllegalStateException para vazio/cheio."
                                  ],
                                  "learningObjective": "Esconder detalhes de array por trás da interface abstrata.",
                                  "commonMistakes": [
                                    "Não encapsular array (tornar público)",
                                    "Índices off-by-one em array circular",
                                    "Falta de resize levando a StackOverflow"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar polimorfismo e abstração com código cliente",
                                  "subSteps": [
                                    "Crie classe Client { public static void useStack(IStack<String> stack) { stack.push(\"A\"); ... } }",
                                    "No main: IStack<String> stack = new ArrayStack<>(); useStack(stack);",
                                    "Repita para IQueue<String> queue = new ArrayQueue<>();",
                                    "Altere para simular troca de impl (ex: comente Array e use futura Linked impl).",
                                    "Execute e verifique saída correta sem recompilar cliente."
                                  ],
                                  "verification": "Código cliente roda com ambas impl sem mudanças, demonstrando polimorfismo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE para execução",
                                    "Terminal para rodar java Client"
                                  ],
                                  "tips": [
                                    "Evite casting; use só métodos da interface no cliente."
                                  ],
                                  "learningObjective": "Validar abstração via uso polimórfico, escondendo implementações.",
                                  "commonMistakes": [
                                    "Referenciar classes concretas no cliente",
                                    "Não tratar exceções no teste",
                                    "Ignorar genéricos no cliente"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um editor de texto, crie IStack<Command> para undo (push Command, pop para desfazer). Implemente ArrayStack e LinkedStack; o cliente Editor usa IStack sem saber a impl interna, permitindo trocar para otimizar memória.",
                              "finalVerifications": [
                                "Interfaces IStack<T> e IQueue<T> definem contratos sem implementações.",
                                "ArrayStack e ArrayQueue implementam todos métodos corretamente com encapsulamento.",
                                "Código cliente compila e executa usando referências de interface.",
                                "Troca entre implementações não quebra o cliente.",
                                "Genéricos <T> funcionam com tipos como String e Integer.",
                                "Exceções são lançadas corretamente em pop/dequeue vazios."
                              ],
                              "assessmentCriteria": [
                                "Corretude funcional: todas operações produzem resultados esperados.",
                                "Abstração: cliente não acessa detalhes internos.",
                                "Uso de genéricos: type-safety sem warnings.",
                                "Encapsulamento: campos privados, só métodos públicos da interface.",
                                "Tratamento de erros: exceções para estados inválidos.",
                                "Eficiência: resize evita overflow, O(1) amortizado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos LIFO/FIFO em recursão e algoritmos.",
                                "Design de Software: Padrões como Template Method em classes abstratas.",
                                "Engenharia: Abstração em APIs como Java Collections Framework.",
                                "Lógica: Contratos com pré/pós-condições formais."
                              ],
                              "realWorldApplication": "Bibliotecas como Java's Deque abstraem Stack/Queue para uso em navegadores (histórico via pilha), sistemas operacionais (filas de processos), e apps (playlists FIFO ou undo LIFO), permitindo impl otimizadas sem recriar código cliente."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.3",
                            "name": "Utilizar instâncias de objetos como nós",
                            "description": "Implementar nós como objetos instanciados de uma classe Node, com atributos para dado e ponteiro para próximo, integrando-os em estruturas maiores como listas ou pilhas via encapsulamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a classe Node com atributos essenciais",
                                  "subSteps": [
                                    "Crie uma nova classe chamada Node.",
                                    "Adicione um atributo privado para o dado (ex: data de tipo genérico T).",
                                    "Adicione um atributo privado para o ponteiro próximo (ex: Node<T> next).",
                                    "Inclua um construtor que inicialize o dado e defina next como null.",
                                    "Adicione métodos getters e setters para encapsulamento."
                                  ],
                                  "verification": "Compilar a classe sem erros e instanciar um objeto Node para testar o construtor.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "IDE (Eclipse ou IntelliJ), linguagem Java ou similar OO",
                                  "tips": "Use tipos genéricos para flexibilidade (ex: Node<T>).",
                                  "learningObjective": "Compreender encapsulamento em classes para nós de estruturas de dados.",
                                  "commonMistakes": "Esquecer de tornar atributos privados ou não inicializar next como null."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Instanciar objetos Node individuais",
                                  "subSteps": [
                                    "No método main, crie uma instância de Node com um dado específico (ex: new Node<>(10)).",
                                    "Crie uma segunda instância com outro dado (ex: new Node<>(20)).",
                                    "Acesse o dado via getter para verificar.",
                                    "Teste setter para alterar o dado.",
                                    "Imprima os nós para confirmar criação."
                                  ],
                                  "verification": "Executar o código e ver os valores impressos corretamente sem exceções.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "IDE com código da classe Node",
                                  "tips": "Sempre use new para instanciar; evite null pointers.",
                                  "learningObjective": "Dominar instanciação de objetos como nós independentes.",
                                  "commonMistakes": "Passar null no construtor ou não chamar getters/setters."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Vincular instâncias de Node via ponteiro próximo",
                                  "subSteps": [
                                    "Pegue a primeira instância e use setter para apontar next para a segunda instância.",
                                    "Verifique a ligação percorrendo: imprima data da primeira, depois da next.",
                                    "Crie uma terceira instância e ligue a segunda à terceira.",
                                    "Implemente um método toString na classe Node para facilitar depuração.",
                                    "Teste a cadeia completa."
                                  ],
                                  "verification": "Percorrer a cadeia e imprimir todos os dados na ordem correta.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código anterior expandido",
                                  "tips": "Desenhe no papel a estrutura antes de codificar.",
                                  "learningObjective": "Implementar ligações dinâmicas entre nós.",
                                  "commonMistakes": "Criar ciclos acidentais (next apontando para si mesmo)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar nós em uma estrutura maior com encapsulamento",
                                  "subSteps": [
                                    "Crie uma classe LinkedList simples com head como Node.",
                                    "Adicione métodos add(Node) e printList() na LinkedList.",
                                    "Instancie a lista, adicione os nós criados anteriormente.",
                                    "Teste printList() para exibir a lista ligada.",
                                    "Adicione encapsulamento: métodos públicos para manipular head privadamente."
                                  ],
                                  "verification": "Executar e ver a lista impressa corretamente; modificar via métodos públicos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código completo das classes Node e LinkedList",
                                  "tips": "Mantenha head privado e exponha apenas via API.",
                                  "learningObjective": "Aplicar nós em estruturas compostas com abstração.",
                                  "commonMistakes": "Expor head diretamente, violando encapsulamento."
                                }
                              ],
                              "practicalExample": "Implemente uma lista ligada de nomes de estudantes: Node<String> aluno1 = new Node<>(\"João\"); Node<String> aluno2 = new Node<>(\"Maria\"); aluno1.setNext(aluno2); Em uma classe ListaEstudantes, adicione e imprima a lista.",
                              "finalVerifications": [
                                "Classe Node compila com atributos privados e genéricos.",
                                "Instâncias são criadas e ligadas corretamente sem vazamentos de memória.",
                                "Encapsulamento funciona: acesso só via getters/setters.",
                                "Estrutura maior (lista) integra nós e opera sem erros.",
                                "Código roda e produz saída esperada em cenários de teste.",
                                "Não há ciclos ou referências nulas inesperadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição da classe Node (atributos e construtor).",
                                "Correta instanciação e ligação de pelo menos 3 nós.",
                                "Uso efetivo de encapsulamento em todas as classes.",
                                "Funcionalidade da estrutura integrada (add/print).",
                                "Código limpo, comentado e sem erros comuns.",
                                "Eficiência: O(1) para adição no início."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Grafos e teoria dos conjuntos (nós como vértices).",
                                "Física: Modelagem de cadeias moleculares ou partículas ligadas.",
                                "Banco de Dados: Registros encadeados em índices.",
                                "Engenharia de Software: Padrões de design como Singleton para gerenciar listas."
                              ],
                              "realWorldApplication": "Em navegadores web, listas ligadas gerenciam histórico de páginas (navegação forward/backward); em sistemas operacionais, filas de processos usam nós para escalonamento dinâmico."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.2",
                        "name": "Implementação de Listas Orientadas a Objetos",
                        "description": "Construção de listas encadeadas simples e duplamente encadeadas utilizando classes, objetos e métodos para operações CRUD (criar, ler, atualizar, deletar).",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.2.1",
                            "name": "Criar classe ListaEncadeada com métodos básicos",
                            "description": "Implementar uma classe ListaEncadeada com construtor, método insert_begin, insert_end, remove e size, utilizando objetos Node para encadeamento e encapsulamento de contadores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a classe Node e o esqueleto da classe ListaEncadeada",
                                  "subSteps": [
                                    "Crie a classe Node com atributos privados data e next.",
                                    "Implemente o construtor da classe Node que recebe data e define next como None.",
                                    "Crie a classe ListaEncadeada com atributo privado head (inicializado como None) e private counter (inicializado como 0).",
                                    "Implemente o construtor da ListaEncadeada que inicializa head e counter.",
                                    "Adicione método privado para acessar counter."
                                  ],
                                  "verification": "Instancie Node e ListaEncadeada sem erros; verifique se head é None e counter é 0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Python 3.x instalado",
                                    "Console para testes"
                                  ],
                                  "tips": "Use convenção _head e _counter para encapsulamento em Python.",
                                  "learningObjective": "Compreender a estrutura básica de nós e lista encadeada com encapsulamento.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar next como None",
                                    "Não usar atributos privados",
                                    "Erro no nome dos atributos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o método size",
                                  "subSteps": [
                                    "Crie o método público size que retorna o valor do counter.",
                                    "Teste o size em uma lista vazia (deve retornar 0).",
                                    "Adicione um print ou assert para verificar após inicialização.",
                                    "Considere tornar counter privado e acessível apenas via getter.",
                                    "Documente o método com docstring explicando O(1) tempo."
                                  ],
                                  "verification": "Chame size() e confirme retorno correto (0 para vazia).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Console Python para testes interativos"
                                  ],
                                  "tips": "Manter counter garante O(1) para size, evitando contagem manual.",
                                  "learningObjective": "Implementar consulta eficiente de tamanho com encapsulamento.",
                                  "commonMistakes": [
                                    "Incrementar counter incorretamente em outros métodos",
                                    "Retornar head ao invés de counter",
                                    "Expor counter publicamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar insert_begin e insert_end",
                                  "subSteps": [
                                    "No insert_begin: Crie novo Node, defina seu next como atual head, atualize head para novo Node, incremente counter.",
                                    "No insert_end: Se vazia, use insert_begin; senão, percorra até o final e adicione novo Node, incremente counter.",
                                    "Teste insert_begin com 2 elementos e verifique ordem.",
                                    "Teste insert_end e confirme size atualizado.",
                                    "Adicione docstrings explicando casos vazia e não-vazia."
                                  ],
                                  "verification": "Insira 3 elementos (2 begin, 1 end); liste ou imprima para verificar ordem e size=3.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Função auxiliar para imprimir lista (print_list)"
                                  ],
                                  "tips": "Crie método auxiliar to_string() para visualizar a lista durante testes.",
                                  "learningObjective": "Dominar inserções em extremidades com manutenção de counter.",
                                  "commonMistakes": [
                                    "Não atualizar head em insert_begin",
                                    "Loop infinito em insert_end por next mal setado",
                                    "Esquecer incrementar counter"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar o método remove",
                                  "subSteps": [
                                    "Crie remove(valor): Se head.data == valor, atualize head e decremente counter.",
                                    "Senão, percorra a lista buscando next.data == valor, remova ligando prev.next ao next.next.",
                                    "Lide com casos: lista vazia (raise exceção), único elemento, não encontrado.",
                                    "Teste remoção no início, meio e fim.",
                                    "Verifique size após cada remoção."
                                  ],
                                  "verification": "Insira elementos, remova alguns, confirme size e ordem restantes sem vazamentos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Console para testes com asserts"
                                  ],
                                  "tips": "Use try-except para casos não encontrados; salve prev em loop.",
                                  "learningObjective": "Gerenciar remoções em listas encadeadas com busca linear.",
                                  "commonMistakes": [
                                    "Não atualizar counter",
                                    "Perder ponteiro head",
                                    "Remover errado por comparação errada"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma lista encadeada para gerenciar uma playlist de músicas. Use insert_begin para adicionar faixas ao topo da fila de reprodução, insert_end para adicionar ao final, remove para tirar uma música específica e size para mostrar quantas faixas restam. Exemplo: insira 'Música A' (end), 'Música B' (begin), 'Música C' (begin), remova 'Música A', verifique size=2 e ordem B -> C.",
                              "finalVerifications": [
                                "Lista vazia: head=None, size=0.",
                                "insert_begin: novo elemento vira primeiro, size++.",
                                "insert_end: adiciona no final corretamente, size++.",
                                "remove: remove elemento correto, size--, sem quebrar encadeamento.",
                                "Múltiplas operações: ordem e contagens preservadas.",
                                "Casos edge: remover de lista unitária ou não encontrada."
                              ],
                              "assessmentCriteria": [
                                "Corretude funcional: todos métodos passam em testes unitários.",
                                "Encapsulamento: atributos privados, acesso via métodos públicos.",
                                "Eficiência: size O(1), inserções O(1) begin/end, remove O(n).",
                                "Tratamento de erros: exceções para vazia ou não encontrada.",
                                "Código limpo: docstrings, nomes claros, sem vazamentos de memória.",
                                "Testes embutidos: verificações em exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Contadores e recursão em percursos de listas.",
                                "Algoritmos: Análise de complexidade temporal O(1) vs O(n).",
                                "Banco de Dados: Listas ligadas em estruturas de índices invertidos.",
                                "Física/Engenharia: Modelagem de cadeias ou filas dinâmicas."
                              ],
                              "realWorldApplication": "Listas encadeadas são fundamentais em navegadores web para gerenciar histórico de abas (inserções rápidas no início), editores de texto para pilhas de desfazer/refazer, sistemas operacionais para filas de processos e jogos para inventários dinâmicos de itens."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.2.2",
                            "name": "Implementar iteração e busca em listas OO",
                            "description": "Adicionar métodos como __iter__ (em Python) ou iteradores personalizados para percorrer a lista, e um método search que retorne um objeto Node ou None, respeitando encapsulamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Implementar a classe Iterator personalizada",
                                  "subSteps": [
                                    "Defina a classe Iterator com um atributo current para rastrear o nó atual.",
                                    "Crie o método __init__(self, head) que inicializa current = head.",
                                    "Implemente __iter__(self) que retorna self para cumprir o protocolo de iterador.",
                                    "Implemente __next__(self): verifique se current is not None, retorne current.data e avance current = current.next; caso contrário, levante StopIteration.",
                                    "Teste manualmente chamando next() múltiplas vezes em uma instância."
                                  ],
                                  "verification": "Instancie Iterator(head) e chame next() até StopIteration sem erros; verifique se valores são retornados na ordem correta.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de código Python (ex: VS Code, PyCharm)",
                                    "Documentação oficial Python sobre iteradores (docs.python.org)"
                                  ],
                                  "tips": "Use 'yield' apenas se for generator; aqui usamos classe explícita para controle fino.",
                                  "learningObjective": "Dominar o protocolo de iteradores (__iter__ e __next__) para estruturas personalizadas.",
                                  "commonMistakes": [
                                    "Esquecer de avançar current.next em __next__",
                                    "Não inicializar current corretamente no __init__",
                                    "Retornar self em __next__ em vez de levantar StopIteration"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Adicionar o método __iter__ à classe Lista",
                                  "subSteps": [
                                    "Na classe Lista, defina def __iter__(self):.",
                                    "Retorne uma instância de Iterator(self._head) (assumindo _head como atributo encapsulado).",
                                    "Crie uma lista de teste com 3-5 nós e use 'for item in lista:' para percorrer e imprimir.",
                                    "Verifique se itera apenas os dados, sem expor a estrutura interna.",
                                    "Adicione tratamento para lista vazia (Iterator com current=None levanta StopIteration imediatamente)."
                                  ],
                                  "verification": "Execute 'for item in minha_lista: print(item)' e confirme que imprime todos os itens na ordem sem acessar _head diretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código base da classe Lista e Node",
                                    "Console Python para testes interativos"
                                  ],
                                  "tips": "Mantenha _head privado (com underscore) para reforçar encapsulamento.",
                                  "learningObjective": "Integrar iterador à classe principal para compatibilidade com loops for nativos.",
                                  "commonMistakes": [
                                    "Passar self._head incorretamente",
                                    "Implementar iteração diretamente em __iter__ sem classe separada",
                                    "Não tratar lista vazia"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o método search na classe Lista",
                                  "subSteps": [
                                    "Defina def search(self, value): na classe Lista.",
                                    "Inicialize current = self._head.",
                                    "Use um loop while current is not None: se current.data == value, retorne current; senão current = current.next.",
                                    "Após o loop, retorne None se não encontrado.",
                                    "Teste com valores existentes, inexistentes e lista vazia."
                                  ],
                                  "verification": "Chame lista.search('valor_existente') e confirme que retorna o Node correto; para inexistente, retorna None.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código das classes Lista e Node atualizadas",
                                    "Casos de teste pré-definidos (listas com/duas sem valores)"
                                  ],
                                  "tips": "Compare com == para valores primitivos; para objetos, use __eq__ se necessário.",
                                  "learningObjective": "Criar método de busca linear respeitando encapsulamento, retornando referência ao nó.",
                                  "commonMistakes": [
                                    "Retornar o valor em vez do Node",
                                    "Loop infinito por não avançar current",
                                    "Acessar data sem checar current"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar integração, encapsulamento e edge cases",
                                  "subSteps": [
                                    "Crie testes unitários para iteração completa, parcial e vazia.",
                                    "Teste search com matches no início, meio, fim e não-match.",
                                    "Tente acessar self._head diretamente e confirme que é desencorajado (mas funcionalmente possível; discuta convenções).",
                                    "Meça performance com lista grande (ex: 100 itens) para O(n).",
                                    "Refatore código para aderir a PEP8 e adicione docstrings."
                                  ],
                                  "verification": "Todos testes passam; iteração e search funcionam sem quebrar encapsulamento.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Biblioteca unittest ou pytest",
                                    "Gerador de listas grandes para stress test"
                                  ],
                                  "tips": "Use assert para verificações automáticas nos testes.",
                                  "learningObjective": "Garantir robustez e boas práticas em implementações OO.",
                                  "commonMistakes": [
                                    "Ignorar listas vazias",
                                    "Expor _head em métodos públicos",
                                    "Não testar edge cases"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma ListaOO de 'produtos' (ex: Node('Maçã'), Node('Banana'), Node('Laranja')). Use 'for produto in lista: print(produto.data)' para listar todos. Em seguida, node = lista.search('Banana'); print(node.data if node else 'Não encontrado') – deve imprimir 'Banana'.",
                              "finalVerifications": [
                                "Loop 'for' percorre todos os itens corretamente, incluindo listas vazias.",
                                "Método search retorna o Node exato ou None sem erros.",
                                "Atributos internos como _head não são acessados diretamente nos testes.",
                                "Código roda sem exceções em Python 3.x.",
                                "Performance é linear (O(n)) em listas grandes.",
                                "Docstrings explicam uso de __iter__ e search."
                              ],
                              "assessmentCriteria": [
                                "Implementação completa de Iterator com __iter__ e __next__ corretos.",
                                "Respeito total ao encapsulamento (uso de _head).",
                                "Tratamento de edge cases (vazia, único item, não encontrado).",
                                "Código limpo, legível e PEP8-compliant.",
                                "Testes demonstram funcionalidade em cenários variados.",
                                "Eficiência algorítmica adequada (busca linear)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Complexidade O(n) e algoritmos de busca linear.",
                                "Lógica e Algoritmos: Estruturas de repetição (while/for) e condicionais.",
                                "Inglês Técnico: Leitura de documentação Python e escrita de docstrings.",
                                "Design de Software: Princípios SOLID (especialmente Single Responsibility no Iterator)."
                              ],
                              "realWorldApplication": "Em aplicações como gerenciadores de tarefas (percorrer lista de itens pendentes via for; buscar tarefa específica retornando seu Node para edição), playlists musicais (iterar faixas, buscar por título) ou inventários de e-commerce (buscar produto sem expor banco de dados interno), mantendo encapsulamento para segurança e modularidade."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.2.3",
                            "name": "Gerenciar memória e exceções em listas",
                            "description": "Tratar exceções como Underflow ao remover de lista vazia e usar garbage collection ou delete manual (C++) para nós removidos, integrando try-catch em operações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Implementar detecção de underflow em operações de remoção",
                                  "subSteps": [
                                    "Analise o método de remoção (ex: pop_front ou remove) na classe da lista ligada.",
                                    "Adicione uma verificação if (head == nullptr) antes de prosseguir com a remoção.",
                                    "Defina uma exceção customizada derivada de std::runtime_error, como class ListUnderflow : public std::runtime_error {}.",
                                    "Lance a exceção usando throw ListUnderflow(\"Lista vazia\"); se underflow detectado.",
                                    "Compile e teste com lista vazia para confirmar lançamento da exceção."
                                  ],
                                  "verification": "Execute pop em lista vazia e verifique se a exceção é lançada sem crash.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "IDE com C++ (Visual Studio Code + g++ ou CLion)",
                                    "Header <stdexcept> incluído"
                                  ],
                                  "tips": "Use std::runtime_error como base para exceções customizadas para herdar funcionalidades.",
                                  "learningObjective": "Identificar e sinalizar condições de erro como underflow em estruturas de dados.",
                                  "commonMistakes": [
                                    "Esquecer de incluir <stdexcept>",
                                    "Não verificar nullptr após remoção",
                                    "Lançar exceção sem mensagem descritiva"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Integrar blocos try-catch nas operações da lista",
                                  "subSteps": [
                                    "No código cliente, envolva chamadas de remoção em try { lista.pop(); } catch (ListUnderflow& e) { ... }.",
                                    "No bloco catch, imprima a mensagem de erro usando e.what() e evite prosseguir com operação inválida.",
                                    "Adicione catches para outras exceções potenciais como std::bad_alloc em inserções.",
                                    "Teste cenários: remoção válida, underflow e inserção falha.",
                                    "Registre logs ou retorne status de erro para o chamador."
                                  ],
                                  "verification": "Execute código com try-catch e confirme que exceções são capturadas e tratadas sem término abrupto.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código da lista do step anterior",
                                    "Biblioteca de logging opcional como spdlog"
                                  ],
                                  "tips": "Sempre re-lance exceções (throw;) se não puder tratar localmente para propagação.",
                                  "learningObjective": "Capturar e tratar exceções específicas para robustez do programa.",
                                  "commonMistakes": [
                                    "Catch-all com catch(...) sem especificidade",
                                    "Ignorar o bloco catch vazio",
                                    "Não usar referência (&) no catch para evitar cópias"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerenciar memória manualmente ao remover nós",
                                  "subSteps": [
                                    "No método de remoção, após desvincular o nó (ex: temp = head; head = head->next;), execute delete temp;.",
                                    "Para remoção no meio da lista, atualize ponteiros prev->next = next e delete o nó alvo.",
                                    "Evite vazamentos iterando com iterações seguras (não modifique durante iteração simples).",
                                    "Adicione verificação de nullptr antes de delete para segurança extra.",
                                    "Use valgrind ou AddressSanitizer para detectar vazamentos de memória."
                                  ],
                                  "verification": "Remova nós múltiplos e use ferramenta de detecção de leaks para confirmar zero vazamentos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Compilador com AddressSanitizer (-fsanitize=address)",
                                    "Valgrind instalado"
                                  ],
                                  "tips": "Sempre delete apenas após desvincular completamente o nó da estrutura.",
                                  "learningObjective": "Prevenir vazamentos de memória em listas ligadas com delete manual.",
                                  "commonMistakes": [
                                    "Delete múltiplo no mesmo nó (double delete)",
                                    "Não atualizar ponteiros corretamente causando dangling pointers",
                                    "Esquecer delete em remoções condicionais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar integração completa e otimizar gerenciamento",
                                  "subSteps": [
                                    "Crie testes unitários para cenários: vazia, um elemento, múltiplos, underflow repetido.",
                                    "Integre try-catch em todos métodos mutadores (push, pop, remove).",
                                    "Implemente destructor da lista para delete chain completo em ~List().",
                                    "Meça performance com grandes listas e otimize se necessário (ex: pooling de nós).",
                                    "Documente o código com comentários sobre exceções e gerenciamento de memória."
                                  ],
                                  "verification": "Todos testes passam sem crashes, leaks ou exceções não tratadas; cobertura >80%.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Framework de testes como Google Test",
                                    "Profiler como gprof"
                                  ],
                                  "tips": "Use RAII principles com smart pointers (std::unique_ptr) para automação futura.",
                                  "learningObjective": "Validar sistema completo de exceções e memória em listas OO.",
                                  "commonMistakes": [
                                    "Testes insuficientes para edge cases",
                                    "Destructor não chamando delete recursivo",
                                    "Ignorar performance em listas longas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma lista ligada de inteiros, implemente pop_front(): se vazia, throw ListUnderflow; senão, Node* temp = head; head = head->next; delete temp; No main(): try { lista.pop_front(); } catch (ListUnderflow& e) { cout << \"Erro: \" << e.what(); } – teste com lista vazia mostra mensagem sem crash e sem leak.",
                              "finalVerifications": [
                                "Código compila e executa sem warnings de memória ou exceções não tratadas.",
                                "Remoção em lista vazia lança e captura exceção corretamente.",
                                "Valgrind relata zero leaks após múltiplas inserções/remoções.",
                                "Destructor limpa toda memória alocada.",
                                "Testes unitários cobrem 100% dos cenários de underflow e remoção.",
                                "Performance aceitável em listas de 10k+ elementos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção e lançamento de exceções (sem falsos positivos).",
                                "Ausência total de vazamentos de memória comprovada por ferramentas.",
                                "Tratamento de exceções com mensagens claras e recuperação graciosa.",
                                "Código limpo com comentários e estrutura OO adequada.",
                                "Cobertura de testes abrangente incluindo edge cases.",
                                "Eficiência no gerenciamento manual de memória."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos para modelar listas ligadas como cadeias.",
                                "Lógica e Debug: Análise de fluxos de exceções como fluxogramas.",
                                "Sistemas Operacionais: Conceitos de alocação dinâmica e garbage collection comparativo.",
                                "Engenharia de Software: Princípios RAII e exceções em design robusto."
                              ],
                              "realWorldApplication": "Em editores de texto como Vim (listas de linhas), jogos (listas de entidades), ou servidores web (colas de requisições), previne crashes por underflow em buffers vazios e vazamentos que causam OOM kills, garantindo estabilidade em produção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.3",
                        "name": "Implementação de Pilhas e Filas com OO",
                        "description": "Desenvolvimento de pilhas (LIFO) e filas (FIFO) baseadas em listas OO, explorando herança ou composição para reutilizar código e polimorfismo em operações.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.3.1",
                            "name": "Implementar classe Pilha usando lista OO",
                            "description": "Criar classe Stack que herde ou componha ListaEncadeada, com métodos push, pop, peek e is_empty, garantindo encapsulamento e lançamento de exceções apropriadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejar e definir a estrutura básica da classe Stack com composição",
                                  "subSteps": [
                                    "Analise os requisitos: Stack deve compor ListaEncadeada para encapsulamento, com métodos push, pop, peek e is_empty.",
                                    "Crie a classe Stack com um atributo privado ListaEncadeada<T> lista; (use genéricos para tipagem).",
                                    "Defina o construtor padrão que inicializa a lista vazia.",
                                    "Declare as assinaturas dos métodos públicos: void push(T item), T pop() throws EmptyStackException, T peek() throws EmptyStackException, boolean isEmpty().",
                                    "Crie uma exceção customizada EmptyStackException se necessário."
                                  ],
                                  "verification": "Classe Stack compilada sem erros de sintaxe, com atributos e métodos declarados corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (Eclipse/IntelliJ/VSCode)",
                                    "JDK 8+ para Java",
                                    "Documentação de Java Collections"
                                  ],
                                  "tips": "Prefira composição sobre herança para melhor encapsulamento e flexibilidade.",
                                  "learningObjective": "Entender composição em OO e planejar interfaces de estruturas de dados.",
                                  "commonMistakes": [
                                    "Usar herança em vez de composição",
                                    "Esquecer genéricos <T>",
                                    "Tornar lista pública"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o método push",
                                  "subSteps": [
                                    "No método push(T item), chame lista.inserirInicio(item) ou equivalente para adicionar no topo da pilha.",
                                    "Garanta que não haja verificações desnecessárias (push sempre funciona).",
                                    "Teste internamente adicionando um item e verificando se lista não está vazia.",
                                    "Adicione comentário explicando por que inserir no início simula LIFO.",
                                    "Compile e teste com um main simples: Stack<String> s = new Stack<>(); s.push(\"A\");"
                                  ],
                                  "verification": "Push adiciona item corretamente no topo; tamanho da lista aumenta em 1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código da ListaEncadeada",
                                    "JUnit para testes unitários (opcional)"
                                  ],
                                  "tips": "Sempre insira no início da lista para O(1) em push/pop.",
                                  "learningObjective": "Implementar operação de inserção em pilha com eficiência.",
                                  "commonMistakes": [
                                    "Inserir no final da lista (vira fila)",
                                    "Não usar genéricos no push",
                                    "Retornar algo em push void"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar pop com tratamento de exceções",
                                  "subSteps": [
                                    "No método pop(), verifique se lista.isVazia(); se sim, lance EmptyStackException.",
                                    "Caso contrário, retorne lista.removerInicio() ou equivalente.",
                                    "Garanta que pop remova e retorne o topo corretamente.",
                                    "Teste: push itens, pop e verifique ordem LIFO.",
                                    "Adicione logs ou prints para depuração durante testes."
                                  ],
                                  "verification": "Pop remove e retorna topo; lança exceção em pilha vazia; ordem LIFO preservada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exceções Java (RuntimeException)",
                                    "Testes manuais ou JUnit"
                                  ],
                                  "tips": "Use if (isEmpty()) throw new EmptyStackException(); no início.",
                                  "learningObjective": "Gerenciar exceções em estruturas de dados e implementar remoção LIFO.",
                                  "commonMistakes": [
                                    "Não lançar exceção em vazia",
                                    "Pop do final da lista",
                                    "Não retornar o item removido"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar peek e isEmpty",
                                  "subSteps": [
                                    "No peek(), verifique vazia e lance exceção se necessário; retorne lista.getInicio() sem remover.",
                                    "Implemente isEmpty() como return lista.isVazia();",
                                    "Teste peek: não altera pilha, retorna topo correto.",
                                    "Teste isEmpty em vazia e não vazia.",
                                    "Verifique encapsulamento: métodos da lista não expostos publicamente."
                                  ],
                                  "verification": "Peek retorna topo sem remover; isEmpty correto; exceções em vazia.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código existente da Stack",
                                    "Ferramentas de depuração"
                                  ],
                                  "tips": "Peek é como pop mas sem remoção; delegue para lista internamente.",
                                  "learningObjective": "Completar interface de Stack com consulta e verificação de estado.",
                                  "commonMistakes": [
                                    "Peek remove item",
                                    "Expor métodos da lista",
                                    "isEmpty inverter lógica"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar integralmente e refatorar para encapsulamento",
                                  "subSteps": [
                                    "Crie um main com sequência: push múltiplos, pop/peek, testar vazia e exceções.",
                                    "Verifique ordem LIFO: push A B C, pop C B A.",
                                    "Use debugger para inspecionar lista privada.",
                                    "Refatore se necessário: garanta private e sem getters/setters desnecessários.",
                                    "Documente classe com Javadoc."
                                  ],
                                  "verification": "Todos testes passam; código encapsulado; exceções lançadas corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "JUnit 5",
                                    "Debugger do IDE"
                                  ],
                                  "tips": "Escreva testes primeiro (TDD) para guiar implementação.",
                                  "learningObjective": "Validar implementação completa e práticas de teste em OO.",
                                  "commonMistakes": [
                                    "Testes incompletos para exceções",
                                    "Expor internals da lista",
                                    "Ignorar genéricos em testes"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente uma Stack<Integer> para simular histórico de undo em um editor: push posições de cursor, pop para desfazer, peek para pré-visualizar ação.",
                              "finalVerifications": [
                                "Classe compila sem warnings de encapsulamento ou genéricos.",
                                "Testes unitários cobrem push/pop/peek/isEmpty/exceções (100% pass rate).",
                                "Ordem LIFO confirmada com múltiplos itens.",
                                "Exceções EmptyStackException lançadas corretamente em pop/peek vazios.",
                                "Atributo lista permanece privado e inacessível externamente.",
                                "Performance O(1) em todas operações (verifique com profiler se possível)."
                              ],
                              "assessmentCriteria": [
                                "Encapsulamento total: sem exposição de ListaEncadeada.",
                                "Correta implementação LIFO com composição.",
                                "Tratamento robusto de exceções.",
                                "Uso apropriado de genéricos <T>.",
                                "Código limpo, comentado e testado.",
                                "Eficiência temporal O(1) em operações principais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos e recursão (pilhas em DFS).",
                                "Algoritmos: Análise de complexidade Big O.",
                                "Engenharia de Software: Design patterns (Composite).",
                                "Lógica: Princípios booleanos em verificações de estado."
                              ],
                              "realWorldApplication": "Pilhas são usadas em navegadores web para histórico 'voltar' (push URL atual, pop para anterior), compiladores para parsing expressões, e sistemas operacionais para pilha de chamadas de funções."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.3.2",
                            "name": "Desenvolver classe Fila com encadeamento OO",
                            "description": "Construir classe Queue com enqueue, dequeue, front e size, utilizando composição com dois ponteiros (head, tail) em objetos Node para eficiência O(1).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a classe Node para encadeamento",
                                  "subSteps": [
                                    "Crie uma classe interna ou separada chamada Node com atributos genéricos: data (T) e next (Node<T>).",
                                    "Implemente o construtor da classe Node que recebe o data e inicializa next como null.",
                                    "Adicione getters para data e next, se necessário para encapsulamento.",
                                    "Garanta que a classe seja genérica para suportar qualquer tipo T.",
                                    "Teste a criação de um Node isolado."
                                  ],
                                  "verification": "Compile o código e crie um objeto Node; verifique se data e next estão corretos via debug ou toString.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (ex: IntelliJ, VS Code)",
                                    "Compilador Java (JDK 8+)"
                                  ],
                                  "tips": "Use <T> para generics desde o início para reutilização.",
                                  "learningObjective": "Compreender composição em OO para nodes de lista encadeada.",
                                  "commonMistakes": [
                                    "Esquecer generics",
                                    "Inicializar next com valor incorreto",
                                    "Não encapsular atributos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar estrutura básica da classe Queue",
                                  "subSteps": [
                                    "Defina a classe Queue<T> com atributos privados: Node<T> head, tail; int size.",
                                    "Implemente o construtor padrão que inicializa head e tail como null, size como 0.",
                                    "Adicione método auxiliar isEmpty() que retorna size == 0.",
                                    "Crie um toString() para visualizar o estado da fila (encadeamento).",
                                    "Compile e teste instanciação vazia."
                                  ],
                                  "verification": "Instancie Queue e chame isEmpty() e toString(); deve mostrar vazia.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Compilador Java"
                                  ],
                                  "tips": "Mantenha size como int para O(1) em size().",
                                  "learningObjective": "Estruturar classe OO com composição e estado inicial correto.",
                                  "commonMistakes": [
                                    "Confundir head e tail na inicialização",
                                    "Esquecer inicializar size=0",
                                    "Não usar private"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar método enqueue (inserir no tail)",
                                  "subSteps": [
                                    "Crie Node<T> novo = new Node<>(data).",
                                    "Se fila vazia (size==0), defina head = tail = novo.",
                                    "Senão, tail.next = novo; tail = novo.",
                                    "Incremente size++.",
                                    "Teste enqueue em fila vazia e não vazia."
                                  ],
                                  "verification": "Enqueue múltiplos itens; toString() mostra ordem FIFO no tail.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Compilador Java",
                                    "Console para testes"
                                  ],
                                  "tips": "Sempre atualize tail para o novo nó após ligação.",
                                  "learningObjective": "Garantir eficiência O(1) com ponteiro tail.",
                                  "commonMistakes": [
                                    "Não atualizar tail",
                                    "Perder referência ao head",
                                    "Esquecer size++"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar dequeue (remover do head) e front",
                                  "subSteps": [
                                    "Para dequeue: se vazio, lance exceção ou retorne null.",
                                    "T ret = head.data; Node<T> temp = head; head = head.next; size--.",
                                    "Se size==0, tail=null; temp.next=null (liberar memória).",
                                    "Para front: retorne head.data se não vazio.",
                                    "Teste dequeue até esvaziar e front em estados variados."
                                  ],
                                  "verification": "Enqueue itens, dequeue e verifique remoção do primeiro; front retorna correto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Compilador Java"
                                  ],
                                  "tips": "Libere referências para evitar vazamentos de memória.",
                                  "learningObjective": "Manter eficiência O(1) com ponteiro head.",
                                  "commonMistakes": [
                                    "Não decrementar size",
                                    "Não nullificar tail ao esvaziar",
                                    "Erro em front sem checar vazio"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Implementar size e realizar testes completos",
                                  "subSteps": [
                                    "Método size(): retorne this.size.",
                                    "Crie main() ou JUnit para testar: enqueue/dequeue misturados, edge cases (vazio, um item, full).",
                                    "Verifique complexidade: cada op O(1).",
                                    "Adicione exceções para dequeue/front em vazio.",
                                    "Documente o código com Javadoc."
                                  ],
                                  "verification": "Todos testes passam; size reflete corretamente após ops.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "JUnit (opcional)",
                                    "Compilador Java"
                                  ],
                                  "tips": "Use assert ou prints para validar estados.",
                                  "learningObjective": "Validar implementação completa com testes unitários.",
                                  "commonMistakes": [
                                    "Size não sincronizado",
                                    "Testes insuficientes para edge cases"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente uma fila para gerenciar jobs de impressão: enqueue documentos, dequeue para imprimir o próximo, front para ver o atual, size para contar fila.",
                              "finalVerifications": [
                                "Classe compila sem erros e roda testes.",
                                "Enqueue preserva ordem FIFO.",
                                "Dequeue remove e retorna head corretamente.",
                                "Front acessa head sem remover.",
                                "Size é O(1) e preciso após todas operações.",
                                "Gerencia vazia sem exceções indevidas.",
                                "Memória liberada (next=null em removidos)."
                              ],
                              "assessmentCriteria": [
                                "Eficiência O(1) para todas operações principais.",
                                "Uso correto de composição com Node (encadeamento).",
                                "Encapsulamento OO (private, getters se needed).",
                                "Tratamento de casos edge (vazio, um item).",
                                "Código limpo, comentado e genérico.",
                                "Testes cobrem cenários principais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Filas (Fila M/M/1).",
                                "Algoritmos: Análise de complexidade temporal/espacial.",
                                "Sistemas Operacionais: Filas de processos prontos.",
                                "Banco de Dados: Filas de transações.",
                                "Design Patterns: Iterator para percorrer fila."
                              ],
                              "realWorldApplication": "Filas em sistemas de impressão, gerenciamento de tarefas em SO (ready queue), buffering de rede (pacotes TCP), call centers (atendimento FIFO)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.3.3",
                            "name": "Aplicar polimorfismo em estruturas derivadas",
                            "description": "Usar interfaces comuns (ex: IStack, IQueue) para tratar pilhas e filas de forma polimórfica, demonstrando chamadas virtuais ou duck typing em Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir Interfaces Abstratas IStack e IQueue",
                                  "subSteps": [
                                    "Importe o módulo abc do Python: from abc import ABC, abstractmethod.",
                                    "Crie a classe IStack(ABC) com métodos abstratos: push(item), pop(), peek(), is_empty(), size().",
                                    "Crie a classe IQueue(ABC) com métodos abstratos: enqueue(item), dequeue(), peek(), is_empty(), size().",
                                    "Adicione docstrings a cada método descrevendo seu propósito.",
                                    "Teste a abstração criando uma subclasse vazia para verificar erros de implementação."
                                  ],
                                  "verification": "Tente instanciar IStack ou IQueue diretamente; deve levantar TypeError. Crie uma subclasse mínima que implemente todos os métodos e verifique se instancia sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código (VS Code ou PyCharm), documentação Python abc module (https://docs.python.org/3/library/abc.html)",
                                  "tips": "Use @abstractmethod apenas em métodos que devem ser obrigatoriamente implementados nas subclasses.",
                                  "learningObjective": "Compreender como definir contratos de interface em Python para garantir polimorfismo via duck typing e ABC.",
                                  "commonMistakes": "Esquecer de herdar de ABC ou não usar @abstractmethod, permitindo instanciação prematura; confundir nomes de métodos entre stack e queue."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Classe Stack Concreta",
                                  "subSteps": [
                                    "Crie a classe Stack que herda de IStack.",
                                    "Inicialize com self._items = [] na __init__.",
                                    "Implemente push(self, item): self._items.append(item).",
                                    "Implemente pop(self): return self._items.pop() if not self.is_empty() else None.",
                                    "Implemente peek(self): return self._items[-1] if not self.is_empty() else None.",
                                    "Implemente is_empty(self): return len(self._items) == 0 e size(self): return len(self._items)."
                                  ],
                                  "verification": "Crie uma instância de Stack, execute push/pop/peek/size/is_empty com valores de teste e imprima resultados; todos devem funcionar sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código, console Python para testes interativos",
                                  "tips": "Use convenção _ para atributos privados; levante ValueError em pop/peek se vazio para robustez.",
                                  "learningObjective": "Implementar uma estrutura de pilha aderindo estritamente à interface definida, preparando para uso polimórfico.",
                                  "commonMistakes": "Não chamar super() ou esquecer de implementar todos os métodos abstratos; usar pop(0) em vez de append/pop para LIFO."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Classe Queue Concreta",
                                  "subSteps": [
                                    "Crie a classe Queue que herda de IQueue.",
                                    "Inicialize com self._items = [] ou use collections.deque para eficiência.",
                                    "Implemente enqueue(self, item): self._items.append(item).",
                                    "Implemente dequeue(self): return self._items.pop(0) if not self.is_empty() else None (ou deque.popleft()).",
                                    "Implemente peek(self): return self._items[0] if not self.is_empty() else None.",
                                    "Implemente is_empty(self) e size(self) similar à Stack."
                                  ],
                                  "verification": "Crie instância de Queue, teste enqueue/dequeue/peek/size/is_empty; confirme FIFO com sequência de itens.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código, módulo collections (import collections)",
                                  "tips": "Prefira collections.deque para O(1) em ambos os fins; evite list.pop(0) em loops grandes por ineficiência O(n).",
                                  "learningObjective": "Construir uma fila aderindo à interface, destacando diferenças operacionais para polimorfismo seletivo.",
                                  "commonMistakes": "Confundir ordem FIFO com LIFO (usar append/pop); esquecer eficiência em dequeue com lists."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar Uso Polimórfico com Duck Typing",
                                  "subSteps": [
                                    "Crie funções genéricas: def process_stack(stack: 'IStack') -> None: ... (use push/pop em loop).",
                                    "Similar para process_queue(queue: 'IQueue'): use enqueue/dequeue.",
                                    "Crie instâncias: my_stack = Stack(), my_queue = Queue().",
                                    "Chame process_stack(my_stack) e process_queue(my_queue); demonstre com múltiplas stacks/queues.",
                                    "Adicione uma lista mista de estruturas e dispatch baseado em tipo ou hasattr para duck typing puro."
                                  ],
                                  "verification": "Execute o código cliente; confirme que funções aceitam tanto Stack quanto uma segunda implementação sem modificar assinaturas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código, script de teste com print statements",
                                  "tips": "Use type hints com forward references ('IStack') para clareza; teste duck typing com objeto mock sem herança.",
                                  "learningObjective": "Aplicar polimorfismo tratando objetos via interfaces comuns, demonstrando flexibilidade em código cliente.",
                                  "commonMistakes": "Passar Queue para process_stack (falha em runtime); ignorar type hints ou não testar com múltiplas implementações."
                                }
                              ],
                              "practicalExample": "Em um simulador de banco, use Stack para histórico de transações (LIFO para undo) e Queue para fila de clientes (FIFO). Funções como process_transactions(stack: IStack) e process_customers(queue: IQueue) tratam polimórficamente diferentes implementações (array vs linked-list based).",
                              "finalVerifications": [
                                "Código roda sem TypeErrors ou AttributeErrors em todas as implementações.",
                                "Stack opera LIFO e Queue FIFO corretamente em testes unitários.",
                                "Funções cliente aceitam instâncias de Stack/Queue interchangeably via interfaces.",
                                "Duck typing funciona com mock objects tendo os métodos requeridos.",
                                "Métodos levam exceções apropriadas (ex: pop em vazio).",
                                "Type hints e docstrings estão presentes e corretos."
                              ],
                              "assessmentCriteria": [
                                "Implementações aderem 100% às interfaces definidas (todos métodos presentes e funcionais).",
                                "Demonstração clara de polimorfismo com código cliente genérico.",
                                "Eficiência adequada (O(1) preferencial para operações principais).",
                                "Tratamento de casos edge (vazio, um item, múltiplos).",
                                "Código limpo, com comentários e testes embutidos.",
                                "Uso correto de ABC e duck typing sem herança desnecessária."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de sequências discretas e recursão em pilhas.",
                                "Design de Software: Padrões Strategy/Factory para implementações intercambiáveis.",
                                "Algoritmos: Análise de complexidade em estruturas lineares.",
                                "Sistemas Operacionais: Filas de processos e stacks de interrupções."
                              ],
                              "realWorldApplication": "Desenvolvimento de software como editores de texto (stack para undo/redo), sistemas de filas de impressão ou mensagens (queues em servidores web), permitindo extensibilidade com novas implementações sem alterar código cliente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.3.4",
                            "name": "Modelar estruturas em UML",
                            "description": "Criar diagramas de classes UML para Lista, Pilha e Fila, mostrando relacionamentos de composição, herança e multiplicidades, conforme padrões OO.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de UML e Estruturas de Dados",
                                  "subSteps": [
                                    "Estude a notação UML para classes (atributos, métodos, visibilidade), herança (seta triangular) e composição (diamante preenchido).",
                                    "Revise definições: Lista (acesso indexado), Pilha (LIFO), Fila (FIFO).",
                                    "Identifique operações chave: push/pop para Pilha, enqueue/dequeue para Fila, add/remove para Lista.",
                                    "Anote exemplos de multiplicidades: 1..*, 0..1.",
                                    "Compare padrões OO: herança vs composição para reutilização."
                                  ],
                                  "verification": "Criar um glossário com 10 termos chave e símbolos UML desenhados corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Guia UML 2.5 oficial (PDF)",
                                    "Notas de estruturas de dados OO",
                                    "Ferramenta de desenho como Draw.io ou Lucidchart"
                                  ],
                                  "tips": "Use flashcards para símbolos UML; foque em composição para 'tem-um' vs herança para 'é-um'.",
                                  "learningObjective": "Dominar notação UML essencial e operações das estruturas para modelagem precisa.",
                                  "commonMistakes": [
                                    "Confundir herança com composição",
                                    "Ignorar visibilidade de métodos (+ pública, - privada)",
                                    "Esquecer operações específicas de cada estrutura"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar Classes Individuais para Lista, Pilha e Fila",
                                  "subSteps": [
                                    "Desenhe classe Lista com atributos (tamanho: int, elementos: Object[]) e métodos (add(index, obj), remove(index), get(index)).",
                                    "Crie classe Pilha herdando ou compondo Lista, adicionando push(obj), pop(), top(), isEmpty().",
                                    "Desenhe classe Fila similarmente com enqueue(obj), dequeue(), front(), isFull().",
                                    "Defina tipos genéricos: use <T> para elementos.",
                                    "Adicione construtores vazios e atributos privados."
                                  ],
                                  "verification": "Classes individuais desenhadas com atributos/métodos completos e sem erros de sintaxe UML.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel milimetrado ou ferramenta UML (PlantUML, StarUML)",
                                    "Templates de classes UML"
                                  ],
                                  "tips": "Comece com Lista como base; use retângulos divididos em 3 seções (nome, atributos, métodos).",
                                  "learningObjective": "Criar representações UML precisas das classes isoladas com padrões OO.",
                                  "commonMistakes": [
                                    "Omitir tipos de retorno nos métodos",
                                    "Usar herança desnecessária em vez de composição",
                                    "Esquecer genéricos <T>"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer Relacionamentos de Herança e Composição",
                                  "subSteps": [
                                    "Conecte Pilha e Fila à Lista via composição (diamante em Lista para 'contém elementos').",
                                    "Adicione herança se aplicável (ex: PilhaCirculante herda PilhaArray).",
                                    "Marque setas: seta sólida para herança, linha com diamante para composição.",
                                    "Defina direção: de subclasse para superclasse na herança.",
                                    "Teste logicamente: Pilha 'compõe' Lista interna."
                                  ],
                                  "verification": "Relacionamentos conectados com setas corretas e rótulos (ex: '1' para composição única).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta UML interativa",
                                    "Exemplos de diagramas OO de livros como 'Head First Design Patterns'"
                                  ],
                                  "tips": "Composição implica ciclo de vida dependente; herança para comportamento compartilhado.",
                                  "learningObjective": "Aplicar relacionamentos UML para modelar hierarquias OO corretas.",
                                  "commonMistakes": [
                                    "Usar seta errada (cheia vs tracejada)",
                                    "Inverter direção da herança",
                                    "Confundir agregação (diamante vazio) com composição"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar Multiplicidades, Refinar e Validar Diagrama",
                                  "subSteps": [
                                    "Aplique multiplicidades: Lista '1' compõe '0..*' Elementos; Pilha '1' usa '1' Lista.",
                                    "Adicione constraints {ordered} para Lista, {stack} para Pilha.",
                                    "Verifique encapsulamento: todos atributos privados, getters/setters.",
                                    "Exporte diagrama em imagem e revise contra padrões UML.",
                                    "Simule uso: trace um push/pop no diagrama."
                                  ],
                                  "verification": "Diagrama final com multiplicidades, constraints e sem erros lógicos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Validador UML online (como UMLet)",
                                    "Checklist de padrões OO"
                                  ],
                                  "tips": "Multiplicidades evitam ambiguidades; use {abstract} para classes base se genéricas.",
                                  "learningObjective": "Refinar diagrama com detalhes avançados para conformidade OO.",
                                  "commonMistakes": [
                                    "Multiplicidades incorretas (ex: 1..1 em vez de 0..*)",
                                    "Expor atributos públicos",
                                    "Ignorar constraints semânticos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e Testar o Diagrama Contra Cenários Reais",
                                  "subSteps": [
                                    "Escreva legenda explicando cada relacionamento.",
                                    "Gere código skeleton de uma ferramenta UML-to-Code.",
                                    "Teste com cenário: simule fila de tarefas em app.",
                                    "Colete feedback ou auto-revise.",
                                    "Arquive versão final."
                                  ],
                                  "verification": "Documento com legenda e código gerado compilável.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "PlantUML para código",
                                    "Editor de texto"
                                  ],
                                  "tips": "PlantUML texto gera diagramas rápidos; valide código compilando.",
                                  "learningObjective": "Garantir usabilidade prática do diagrama em desenvolvimento.",
                                  "commonMistakes": [
                                    "Falta de legenda",
                                    "Código gerado com erros de herança",
                                    "Não testar cenários"
                                  ]
                                }
                              ],
                              "practicalExample": "Modelar um sistema de gerenciamento de pedidos em e-commerce: use Lista para histórico de itens, Pilha para desfazer ações (LIFO), Fila para processar pagamentos pendentes (FIFO), com Pilha e Fila compondo Lista interna e multiplicidade 1..1 para container único.",
                              "finalVerifications": [
                                "Diagrama contém classes Lista, Pilha e Fila com atributos/métodos completos.",
                                "Relacionamentos de composição e herança corretamente notados.",
                                "Multiplicidades definidas em todas associações (ex: 0..* para elementos).",
                                "Notação UML padrão sem erros visuais.",
                                "Diagrama gera código skeleton funcional.",
                                "Constraints como {ordered} ou {LIFO} presentes onde aplicável."
                              ],
                              "assessmentCriteria": [
                                "Precisão da notação UML (100% símbolos corretos).",
                                "Correção conceitual dos relacionamentos OO (herança vs composição).",
                                "Completude de atributos/métodos e genéricos.",
                                "Uso apropriado de multiplicidades e constraints.",
                                "Clareza visual e legibilidade do diagrama.",
                                "Capacidade de gerar código compilável."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos para modelar relacionamentos.",
                                "Design de Software: Padrões de projeto como Adapter para herança.",
                                "Lógica Computacional: Abstrações e polimorfismo.",
                                "Gestão de Projetos: Diagramas para comunicação em equipes ágeis.",
                                "Engenharia de Software: Validação de modelos contra requisitos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software empresarial, diagramas UML de Pilha/Fila modelam sistemas de filas de mensagens (ex: RabbitMQ), caches LIFO em editores de texto ou listas de espera em apps de delivery, garantindo escalabilidade e reutilização de código OO."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.2",
                    "name": "Implementação de Listas Encadeadas em OO",
                    "description": "Criação de classes para nós e listas encadeadas com métodos de inserção, remoção e travessia.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.2.1",
                        "name": "Classe Nó para Lista Encadeada",
                        "description": "Definição da classe Node que encapsula os dados de um elemento e a referência ao próximo nó, promovendo abstração e encapsulamento em programação orientada a objetos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.1.1",
                            "name": "Definir atributos da classe Nó",
                            "description": "Criar atributos privados para armazenar o dado genérico (usando tipos genéricos) e a referência ao próximo nó, garantindo encapsulamento com modificadores de acesso.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Declarar a classe Nó com suporte a tipos genéricos",
                                  "subSteps": [
                                    "Abra sua IDE preferida (ex: IntelliJ, Eclipse ou VS Code com extensão Java).",
                                    "Crie um novo arquivo Java chamado Node.java.",
                                    "Declare a classe pública com genérico: public class No<T> {",
                                    "Adicione comentários explicando o propósito da classe.",
                                    "Compile e verifique se não há erros de sintaxe básica."
                                  ],
                                  "verification": "A classe compila sem erros e exibe 'public class No<T>' no código fonte.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "IDE Java (IntelliJ/Eclipse/VS Code)",
                                    "JDK 8 ou superior",
                                    "Documentação Oracle sobre Generics"
                                  ],
                                  "tips": "Use 'T' como placeholder para o tipo genérico; evite tipos concretos aqui para manter a generalidade.",
                                  "learningObjective": "Compreender a sintaxe de genéricos na declaração de classes para reutilização de código.",
                                  "commonMistakes": [
                                    "Esquecer o '<T>' após o nome da classe",
                                    "Declarar como final ou abstract sem necessidade",
                                    "Usar tipo concreto como String em vez de T"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o atributo privado para o dado genérico",
                                  "subSteps": [
                                    "Dentro da classe No<T>, declare: private T dado;",
                                    "Adicione um comentário Javadoc: /** Armazena o valor genérico do nó. */",
                                    "Teste acessando 'dado' de fora da classe para confirmar erro de encapsulamento.",
                                    "Compile o código para validar a declaração.",
                                    "Crie um construtor básico que receba T e inicialize dado."
                                  ],
                                  "verification": "Atributo 'dado' é private T e não acessível diretamente de instâncias externas; construtor inicializa corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE com autocomplete",
                                    "Referência Java Language Specification sobre fields"
                                  ],
                                  "tips": "Sempre inicialize em construtores para evitar null pointers; use T para flexibilidade.",
                                  "learningObjective": "Aplicar encapsulamento com atributos privados e tipos genéricos para dados.",
                                  "commonMistakes": [
                                    "Declarar como public",
                                    "Esquecer o tipo genérico T",
                                    "Não adicionar construtor de inicialização"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir o atributo privado para a referência ao próximo nó",
                                  "subSteps": [
                                    "Declare dentro da classe: private No<T> proximo;",
                                    "Adicione Javadoc: /** Referência ao próximo nó na cadeia. */",
                                    "Atualize o construtor para aceitar No<T> e inicializar proximo (pode ser null).",
                                    "Teste criando dois nós e linkando via construtor.",
                                    "Compile e execute um teste simples de ligação."
                                  ],
                                  "verification": "Atributo 'proximo' é private No<T>; instâncias podem ser linkadas sem erros de compilação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE",
                                    "Exemplos de código de listas encadeadas"
                                  ],
                                  "tips": "Inicialize proximo como null para nós finais; isso simula o fim da lista.",
                                  "learningObjective": "Implementar referências auto-referenciadas com genéricos para estruturas encadeadas.",
                                  "commonMistakes": [
                                    "Usar tipo concreto em vez de No<T>",
                                    "Ciclo infinito no construtor",
                                    "Esquecer private"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar getters e setters para garantir encapsulamento",
                                  "subSteps": [
                                    "Crie getter para dado: public T getDado() { return dado; }",
                                    "Crie setter para dado: public void setDado(T dado) { this.dado = dado; }",
                                    "Crie getter para proximo: public No<T> getProximo() { return proximo; }",
                                    "Crie setter para proximo: public void setProximo(No<T> proximo) { this.proximo = proximo; }",
                                    "Teste os métodos com uma classe main simples, acessando e modificando atributos indiretamente."
                                  ],
                                  "verification": "Atributos privados só acessíveis via getters/setters; testes rodam sem erros e alteram valores corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE com debugger",
                                    "JUnit para testes unitários opcionais"
                                  ],
                                  "tips": "Siga convenções JavaBeans para nomes de métodos; valide entradas nos setters se aplicável.",
                                  "learningObjective": "Garantir encapsulamento total com modificadores de acesso e métodos públicos de interface.",
                                  "commonMistakes": [
                                    "Getters retornando void",
                                    "Setters sem 'this.'",
                                    "Expor tipos errados nos retornos"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma lista encadeada de strings: No<String> cabeca = new No<>(\"Primeiro\"); No<String> segundo = new No<>(\"Segundo\"); cabeca.setProximo(segundo); System.out.println(cabeca.getDado() + \" -> \" + cabeca.getProximo().getDado()); // Saída: Primeiro -> Segundo",
                              "finalVerifications": [
                                "Classe No<T> compila sem warnings de genéricos ou acesso.",
                                "Atributos dado e proximo são private e do tipo correto (T e No<T>).",
                                "Getters e setters funcionam corretamente em testes.",
                                "Encapsulamento impede acesso direto aos atributos de fora da classe.",
                                "Construtores inicializam atributos adequadamente (null para proximo).",
                                "Código suporta tipos genéricos como String, Integer ou classes customizadas."
                              ],
                              "assessmentCriteria": [
                                "Uso correto de genéricos <T> em declaração de classe e atributos.",
                                "Encapsulamento rigoroso com private e métodos públicos de acesso.",
                                "Sintaxe impecável sem erros de compilação ou warnings.",
                                "Comentários Javadoc presentes e descritivos.",
                                "Testes demonstram funcionalidade de ligação de nós.",
                                "Adesão a princípios OO: abstração e modularidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de grafos direcionados (nós e arestas).",
                                "Algoritmos: Fundamento para traversais em árvores e listas.",
                                "Design de Software: Aplicação de princípios SOLID (Single Responsibility).",
                                "Banco de Dados: Estruturas semelhantes a registros linkados em índices.",
                                "Engenharia de Software: Padrões de projeto como Singleton para nós raiz."
                              ],
                              "realWorldApplication": "A classe Nó é base para implementações de LinkedList na Java Collections Framework, usada em caches (LRU Cache), filas de mensagens (RabbitMQ), editores de texto (listas de linhas) e garbage collectors da JVM para rastrear objetos referenciados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.2",
                            "name": "Implementar construtor da classe Nó",
                            "description": "Desenvolver o construtor que inicializa o dado e define o próximo nó como null, permitindo instanciação flexível para listas encadeadas em linguagens como Python ou C++.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes essenciais da classe Nó",
                                  "subSteps": [
                                    "Identifique os atributos necessários: 'data' para armazenar o valor e 'next' para apontar ao próximo nó.",
                                    "Analise o papel do construtor: inicializar 'data' com um valor fornecido e 'next' como null.",
                                    "Estude exemplos de listas encadeadas para visualizar o uso do nó.",
                                    "Defina o tipo de dados flexível (genérico ou qualquer tipo suportado pela linguagem).",
                                    "Esboce um diagrama simples da estrutura do nó."
                                  ],
                                  "verification": "Crie um esboço escrito ou diagrama confirmando os atributos e inicializações corretas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagramação como Draw.io",
                                    "Documentação de Python/C++ sobre classes"
                                  ],
                                  "tips": "Sempre priorize null/None para 'next' em novos nós para evitar ciclos acidentais.",
                                  "learningObjective": "Entender a estrutura básica e o propósito do construtor na classe Nó.",
                                  "commonMistakes": [
                                    "Confundir 'data' com 'next'",
                                    "Esquecer de tornar 'next' null",
                                    "Não considerar tipos genéricos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a classe Nó em Python",
                                  "subSteps": [
                                    "Abra um editor de código como VS Code ou PyCharm.",
                                    "Escreva a declaração da classe: class No:",
                                    "Defina os atributos como self.data e self.next dentro do método __init__.",
                                    "Implemente o construtor __init__(self, data): self.data = data; self.next = None.",
                                    "Adicione docstring explicando o propósito."
                                  ],
                                  "verification": "Execute o código sem erros de sintaxe e imprima um nó para verificar atributos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor Python (VS Code, PyCharm)",
                                    "Interpretador Python 3.x"
                                  ],
                                  "tips": "Use type hints como def __init__(self, data: Any) -> None: para clareza.",
                                  "learningObjective": "Implementar a classe Nó com construtor em Python de forma funcional.",
                                  "commonMistakes": [
                                    "Esquecer 'self.' nos atributos",
                                    "Não inicializar next como None",
                                    "Erro de indentação no método"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a classe Nó em C++",
                                  "subSteps": [
                                    "Crie um arquivo .h ou .cpp para a classe.",
                                    "Declare a classe: class No { private: T data; No* next; public: No(T d); };",
                                    "Implemente o construtor: No::No(T d) : data(d), next(nullptr) {}",
                                    "Use template para genérico: template<typename T> class No.",
                                    "Compile e verifique sem warnings."
                                  ],
                                  "verification": "Compile o código com g++ e crie uma instância para inspecionar valores.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador C++ (g++)",
                                    "Editor como CLion ou VS Code com C++ extension"
                                  ],
                                  "tips": "Prefira lista de inicialização no construtor para eficiência em C++.",
                                  "learningObjective": "Adaptar o construtor para C++ com suporte a tipos genéricos.",
                                  "commonMistakes": [
                                    "Usar NULL em vez de nullptr",
                                    "Esquecer template<typename T>",
                                    "Acessar membros privados sem getters"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar o construtor",
                                  "subSteps": [
                                    "Crie uma instância: no1 = No('A') em Python ou No<int> no1(10) em C++.",
                                    "Imprima ou acesse data e next para confirmar valores.",
                                    "Teste com diferentes tipos de data (int, string, etc.).",
                                    "Adicione unit tests simples usando assert ou cout.",
                                    "Debugue qualquer falha na inicialização."
                                  ],
                                  "verification": "Todos os testes passam, confirmando data correta e next null.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Bibliotecas de teste (unittest em Python, Google Test em C++)"
                                  ],
                                  "tips": "Sempre teste edge cases como data null.",
                                  "learningObjective": "Validar a funcionalidade do construtor através de testes práticos.",
                                  "commonMistakes": [
                                    "Não testar next == null",
                                    "Ignorar leaks de memória em C++",
                                    "Testes insuficientes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: class No: def __init__(self, data): self.data = data; self.next = None; nó = No('Olá'); print(nó.data)  # Saída: Olá; print(nó.next)  # Saída: None. Em C++: template<typename T> class No { T data; No* next; public: No(T d): data(d), next(nullptr) {} }; No<int> nó(42); cout << nó.data << endl;  // 42",
                              "finalVerifications": [
                                "O construtor inicializa 'data' com o valor passado corretamente.",
                                "'next' é sempre definido como null/None/nullptr.",
                                "Funciona com múltiplos tipos de dados (int, string, etc.).",
                                "Não há erros de compilação/execução ao instanciar.",
                                "Instância pode ser usada em uma lista encadeada simples.",
                                "Documentação/docstring está presente e clara."
                              ],
                              "assessmentCriteria": [
                                "Código limpo, legível e comentado.",
                                "Uso correto de inicialização (lista em C++, self em Python).",
                                "Suporte a genéricos/templates.",
                                "Testes unitários cobrem casos principais.",
                                "Eficiência e ausência de vazamentos/memória.",
                                "Flexibilidade para instanciação variada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação de grafos e nós em estruturas discretas.",
                                "Engenharia de Software: Princípios de encapsulamento e abstração OO.",
                                "Algoritmos: Base para implementações de pilhas, filas e árvores.",
                                "Lógica Computacional: Gerenciamento de ponteiros e referências."
                              ],
                              "realWorldApplication": "Construtores de nós são fundamentais em linked lists usadas em sistemas operacionais (filas de processos), navegadores web (histórico de páginas), editores de texto (undo/redo) e bancos de dados (índices encadeados), permitindo alocação dinâmica de memória sem redimensionamentos fixos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.3",
                            "name": "Criar getters e setters para o Nó",
                            "description": "Implementar métodos de acesso para ler e modificar o dado e o próximo nó, respeitando princípios de encapsulamento e utilizando tipos genéricos para flexibilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar a classe Nó com tipos genéricos e campos privados",
                                  "subSteps": [
                                    "Declarar a classe como genérica: `public class No<T> {`",
                                    "Adicionar o campo privado para o dado: `private T dado;`",
                                    "Adicionar o campo privado para o próximo nó: `private No<T> proximo;`",
                                    "Fechar a declaração da classe com chaves",
                                    "Verificar se não há erros de sintaxe no esqueleto da classe"
                                  ],
                                  "verification": "Compilar a classe e confirmar que os campos são privados e genéricos, sem erros de tipo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "IDE como IntelliJ IDEA ou Eclipse",
                                    "Documentação oficial do Java sobre genéricos (docs.oracle.com)"
                                  ],
                                  "tips": "Use `private` sempre para campos de instância para garantir encapsulamento desde o início.",
                                  "learningObjective": "Entender como aplicar tipos genéricos e encapsulamento básico na classe Nó.",
                                  "commonMistakes": [
                                    "Esquecer o `<T>` na declaração da classe ou campos",
                                    "Declarar campos como `public` em vez de `private`",
                                    "Usar tipo concreto como `String` em vez de `T`"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar os métodos getter para dado e próximo",
                                  "subSteps": [
                                    "Criar o método `public T getDado() { return dado; }` dentro da classe",
                                    "Criar o método `public No<T> getProximo() { return proximo; }`",
                                    "Garantir que os métodos sejam públicos e retornem o tipo correto",
                                    "Adicionar comentários Javadoc opcionais: `@return o dado armazenado` e `@return o próximo nó`",
                                    "Compilar e testar com um main simples para ler valores"
                                  ],
                                  "verification": "Instanciar um No<String> e chamar getDado() para confirmar retorno correto do valor.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE com suporte a Java",
                                    "Exemplo de código de teste unitário básico"
                                  ],
                                  "tips": "Mantenha os getters simples e imutáveis; nunca adicione lógica extra desnecessária.",
                                  "learningObjective": "Dominar a criação de getters que fornecem acesso de leitura seguro aos campos encapsulados.",
                                  "commonMistakes": [
                                    "Retornar `this.dado` desnecessariamente",
                                    "Esquecer o tipo genérico no retorno",
                                    "Tornar getter private"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar os métodos setter para dado e próximo",
                                  "subSteps": [
                                    "Criar `public void setDado(T dado) { this.dado = dado; }`",
                                    "Criar `public void setProximo(No<T> proximo) { this.proximo = proximo; }`",
                                    "Usar `this.` para diferenciar parâmetro do campo de instância",
                                    "Adicionar validações básicas opcionais, como `if (proximo != null)` para evitar ciclos",
                                    "Compilar e testar alterando valores via setters"
                                  ],
                                  "verification": "Chamar setter e depois getter para confirmar que o valor foi alterado corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE",
                                    "JUnit para testes unitários (opcional)"
                                  ],
                                  "tips": "Sempre use `this.` em setters para clareza e evitar shadowing de variáveis.",
                                  "learningObjective": "Implementar setters que permitam modificação controlada, respeitando genéricos.",
                                  "commonMistakes": [
                                    "Esquecer `this.` e atribuir parâmetro a si mesmo",
                                    "Não usar void no retorno",
                                    "Ignorar null checks em setProximo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar a implementação completa",
                                  "subSteps": [
                                    "Criar um método main para instanciar dois nós e encadeá-los",
                                    "Testar getters e setters sequencialmente: set, get, verify",
                                    "Verificar encapsulamento tentando acessar `no.dado` diretamente (deve falhar)",
                                    "Executar testes com diferentes tipos genéricos (String, Integer)",
                                    "Refatorar se necessário para corrigir bugs encontrados"
                                  ],
                                  "verification": "Todos os testes passam sem exceções e comportamentos esperados confirmados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE com debugger",
                                    "Ferramenta de teste como JUnit"
                                  ],
                                  "tips": "Use debugger para inspecionar campos privados e confirmar encapsulamento.",
                                  "learningObjective": "Validar que getters e setters funcionam em conjunto com encapsulamento.",
                                  "commonMistakes": [
                                    "Não testar com genéricos diferentes",
                                    "Acessar campos diretamente nos testes",
                                    "Ignorar casos de null"
                                  ]
                                }
                              ],
                              "practicalExample": "```java\npublic class No<T> {\n    private T dado;\n    private No<T> proximo;\n\n    public T getDado() { return dado; }\n    public No<T> getProximo() { return proximo; }\n\n    public void setDado(T dado) { this.dado = dado; }\n    public void setProximo(No<T> proximo) { this.proximo = proximo; }\n}\n// Teste: No<String> no1 = new No<>(); no1.setDado(\"teste\"); System.out.println(no1.getDado()); // Saída: teste\n```",
                              "finalVerifications": [
                                "Getters retornam valores corretos após setters.",
                                "Campos privados não são acessíveis diretamente de fora da classe.",
                                "Código compila e executa com tipos genéricos variados (ex: String, Integer).",
                                "SetProximo permite encadeamento sem erros de null pointer.",
                                "Encapsulamento impede modificações diretas nos campos.",
                                "Métodos seguem convenções de nomenclatura Java (camelCase)."
                              ],
                              "assessmentCriteria": [
                                "Uso correto e consistente de tipos genéricos <T>.",
                                "Todos os campos são declarados como private.",
                                "Getters são públicos, sem parâmetros e retornam o tipo correto.",
                                "Setters são públicos, void, com parâmetro this. e validações básicas.",
                                "Código é limpo, comentado e testável.",
                                "Princípios de encapsulamento são respeitados integralmente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica booleana e relações de encadeamento (funções injetoras).",
                                "Língua Portuguesa/Inglês: Convenções de nomenclatura em programação (camelCase, Javadoc).",
                                "Física/Engenharia: Modelagem de estruturas ligadas, similar a cadeias moleculares.",
                                "Segurança da Informação: Encapsulamento como boa prática de segurança de dados."
                              ],
                              "realWorldApplication": "Getters e setters são fundamentais em listas encadeadas usadas em caches LRU (ex: browsers), filas de tarefas em sistemas operacionais, undo/redo em editores de texto e implementações de grafos em redes sociais ou jogos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.2",
                        "name": "Classe Lista Encadeada Básica",
                        "description": "Criação da classe LinkedList que gerencia o cabeçalho (head) da lista e suporta operações iniciais de inserção, utilizando herança e polimorfismo se aplicável.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.2.1",
                            "name": "Inicializar a lista encadeada",
                            "description": "Definir atributo privado para o nó head como null e construtor que inicializa a lista vazia, com suporte a tipos genéricos para qualquer tipo de dado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a classe ListaEncadeada com suporte a genéricos",
                                  "subSteps": [
                                    "Estude a sintaxe de tipos genéricos em Java (public class Nome<T>).",
                                    "Crie um novo arquivo Java chamado ListaEncadeada.java.",
                                    "Declare a classe como public class ListaEncadeada<T> { }.",
                                    "Adicione comentários Javadoc explicando o propósito da classe.",
                                    "Compile o arquivo para verificar erros de sintaxe básica."
                                  ],
                                  "verification": "A classe compila sem erros e aceita parâmetros genéricos como String ou Integer.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "IDE (IntelliJ ou Eclipse), JDK 8+",
                                  "tips": "Use <T> para representar qualquer tipo de dado, permitindo reutilização.",
                                  "learningObjective": "Compreender e aplicar genéricos para criar classes flexíveis.",
                                  "commonMistakes": [
                                    "Esquecer o <T> na declaração da classe",
                                    "Usar tipos concretos em vez de genéricos",
                                    "Não compilar antes de prosseguir"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar o atributo privado head",
                                  "subSteps": [
                                    "Dentro da classe, declare private Node<T> head; (assumindo classe Node interna ou externa).",
                                    "Defina a classe Node interna se necessário: private static class Node<T> { T data; Node<T> next; }.",
                                    "Inicialize head como null implicitamente ou explicitamente.",
                                    "Adicione getter privado se necessário para testes internos.",
                                    "Atualize comentários para documentar o papel de head como ponteiro para o primeiro nó."
                                  ],
                                  "verification": "Inspecione o código: head deve ser private Node<T> head = null;",
                                  "estimatedTime": "10 minutos",
                                  "materials": "IDE com suporte a autocompletar",
                                  "tips": "Mantenha head privado para encapsulamento OO.",
                                  "learningObjective": "Implementar encapsulamento com atributos privados em estruturas de dados.",
                                  "commonMistakes": [
                                    "Declarar head como public",
                                    "Usar tipo errado como Node em vez de Node<T>",
                                    "Esquecer importações se Node for externa"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o construtor padrão para lista vazia",
                                  "subSteps": [
                                    "Adicione public ListaEncadeada() { this.head = null; }.",
                                    "Teste o construtor criando uma instância em um método main temporário.",
                                    "Verifique que head permanece null após instanciação.",
                                    "Adicione um método auxiliar isEmpty() { return head == null; } para validação.",
                                    "Refatore comentários para incluir exemplos de uso."
                                  ],
                                  "verification": "Instancie a classe e confirme que head == null e isEmpty() retorna true.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Compilador Java, classe de teste simples",
                                  "tips": "Sempre inicialize explicitamente no construtor para evitar estados indefinidos.",
                                  "learningObjective": "Criar construtores que garantam inicialização consistente.",
                                  "commonMistakes": [
                                    "Não atribuir null a head no construtor",
                                    "Tornar construtor privado acidentalmente",
                                    "Confundir this.head com head"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar a inicialização completa",
                                  "subSteps": [
                                    "Crie um programa de teste com main() instanciando ListaEncadeada<Integer> e <String>.",
                                    "Adicione prints para verificar head == null e tamanho == 0.",
                                    "Compile e execute os testes para diferentes tipos genéricos.",
                                    "Corrija erros e refatore o código para clareza.",
                                    "Documente o teste em um README ou comentário."
                                  ],
                                  "verification": "Testes passam: lista vazia para múltiplos tipos sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "JUnit para testes unitários (opcional), terminal para execução",
                                  "tips": "Use TDD: escreva teste antes do código se possível.",
                                  "learningObjective": "Validar implementação através de testes práticos.",
                                  "commonMistakes": [
                                    "Não testar com genéricos diferentes",
                                    "Ignorar warnings de compilador",
                                    "Esquecer de executar o main"
                                  ]
                                }
                              ],
                              "practicalExample": "public class Teste { public static void main(String[] args) { ListaEncadeada<String> lista = new ListaEncadeada<>(); System.out.println(lista.isEmpty()); // true System.out.println(lista.head == null); // true } } // Saída esperada: true true",
                              "finalVerifications": [
                                "head é null após instanciação",
                                "Construtor funciona com qualquer tipo genérico (ex: Integer, String)",
                                "Não há vazamentos de memória ou referências nulas inesperadas",
                                "Código compila sem warnings de genéricos",
                                "Método isEmpty() confirma lista vazia",
                                "Encapsulamento: head não acessível externamente"
                              ],
                              "assessmentCriteria": [
                                "Correta declaração da classe genérica ListaEncadeada<T>",
                                "Atributo head privado e tipado corretamente como Node<T>",
                                "Construtor inicializa head = null explicitamente",
                                "Testes demonstram funcionalidade para múltiplos tipos",
                                "Código limpo com comentários e sem erros de compilação",
                                "Uso adequado de encapsulamento OO"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estruturas discretas e teoria de grafos (nós encadeados)",
                                "Lógica: Condicionais e ponteiros como em algoritmos recursivos",
                                "Design de Software: Princípios SOLID (especialmente Single Responsibility)",
                                "Banco de Dados: Listas como índices encadeados em B-trees"
                              ],
                              "realWorldApplication": "Inicializar listas encadeadas vazias é essencial em sistemas como gerenciadores de tarefas (to-do lists dinâmicas), playlists de música em apps (Spotify-like), filas de jobs em servidores web e coleções personalizadas em frameworks como Spring Boot, permitindo crescimento dinâmico sem alocação fixa de memória."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.2.2",
                            "name": "Implementar inserção no início",
                            "description": "Desenvolver método insertAtBeginning que cria um novo nó, atualiza o head e gerencia referências, incluindo tratamento de exceções para casos inválidos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e preparar a estrutura da Lista Encadeada e Node",
                                  "subSteps": [
                                    "Revise a classe LinkedList com atributo head do tipo Node<T>.",
                                    "Defina ou confirme a classe Node<T> com campos data (T) e next (Node<T>).",
                                    "Implemente construtor vazio para LinkedList (head = null).",
                                    "Crie construtor para Node que recebe data e define next como null.",
                                    "Documente as classes com Javadoc explicando propósitos."
                                  ],
                                  "verification": "Compilar as classes sem erros e visualizar diagrama UML da estrutura.",
                                  "estimatedTime": "20 min",
                                  "materials": [
                                    "IDE (Eclipse/IntelliJ)",
                                    "Diagrama UML tool (Draw.io)"
                                  ],
                                  "tips": "Use genéricos <T> para flexibilidade em qualquer tipo de dado.",
                                  "learningObjective": "Compreender componentes fundamentais de listas encadeadas singly-linked.",
                                  "commonMistakes": [
                                    "Esquecer genéricos",
                                    "Definir next como self-reference no construtor"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar inserção básica no início sem exceções",
                                  "subSteps": [
                                    "Crie método público insertAtBeginning(T data) na LinkedList.",
                                    "Dentro do método: instancie novo Node<T>(data).",
                                    "Defina next do novo nó como o head atual.",
                                    "Atualize head para apontar ao novo nó.",
                                    "Retorne true ou void confirmando inserção."
                                  ],
                                  "verification": "Inserir elemento em lista vazia e não-vazia; imprimir lista para ver ordem correta.",
                                  "estimatedTime": "25 min",
                                  "materials": [
                                    "IDE com debugger",
                                    "Método toString() para Node e List"
                                  ],
                                  "tips": "Sempre desenhe no papel: head -> node1 -> node2 vira newNode -> head -> node1 -> node2.",
                                  "learningObjective": "Manipular ponteiros para inserir no head de lista encadeada.",
                                  "commonMistakes": [
                                    "Não atualizar head",
                                    "Perder referência da lista original ao setar next"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar validação de entrada e tratamento de exceções",
                                  "subSteps": [
                                    "No início do método, verifique se data == null; lance IllegalArgumentException se true.",
                                    "Opcionalmente, limite tamanho da lista se houver capacidade máxima.",
                                    "Use try-catch para capturar exceções de memória (OutOfMemoryError) e logar.",
                                    "Retorne false em falhas não excepcionais ou re-lance exceções customizadas.",
                                    "Adicione Javadoc ao método descrevendo exceções possíveis."
                                  ],
                                  "verification": "Teste com data null (deve lançar exceção); teste com dados válidos.",
                                  "estimatedTime": "20 min",
                                  "materials": [
                                    "JUnit para testes unitários",
                                    "Logger (java.util.logging)"
                                  ],
                                  "tips": "Exceções devem ser específicas; IllegalArgumentException para params inválidos.",
                                  "learningObjective": "Implementar robustez com validação e exception handling em OO.",
                                  "commonMistakes": [
                                    "Não checar null",
                                    "Capturar exceções muito amplas como Exception"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e depurar a implementação completa",
                                  "subSteps": [
                                    "Crie testes unitários: lista vazia, uma elemento, múltiplos.",
                                    "Teste cenários edge: inserir null, inserir após remoções.",
                                    "Use debugger para inspecionar ponteiros antes/depois da inserção.",
                                    "Meça performance com 1000 inserções (deve ser O(1)).",
                                    "Refatore código para seguir princípios SOLID (ex: single responsibility)."
                                  ],
                                  "verification": "Todos testes passam (100% coverage); sem memory leaks.",
                                  "estimatedTime": "30 min",
                                  "materials": [
                                    "JUnit 5",
                                    "Profiler (VisualVM)",
                                    "Cobertura de código tool"
                                  ],
                                  "tips": "Sempre teste lista vazia primeiro, pois head=null é comum.",
                                  "learningObjective": "Validar implementação via TDD e debugging.",
                                  "commonMistakes": [
                                    "Ignorar testes vazios",
                                    "Não verificar vazamentos de memória"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma lista de tarefas pendentes (LinkedList<Task>), insira 'Ler email urgente' no início: novo nó com essa task aponta para head anterior, head atualizado. Imprima: [Ler email urgente, Comprar leite, Estudar].",
                              "finalVerifications": [
                                "Head aponta para o novo nó inserido.",
                                "Novo nó.next == antigo head.",
                                "Lista vazia torna head não-null após inserção.",
                                "Múltiplas inserções mantêm ordem LIFO no início.",
                                "Exceção lançada corretamente para data null.",
                                "Sem ciclos na lista (next não aponta para si)."
                              ],
                              "assessmentCriteria": [
                                "Correção: Inserção atualiza head e referências sem perda de dados (90%).",
                                "Robustez: Trata null e exceções adequadamente (80%).",
                                "Eficiência: O(1) tempo constante, sem loops desnecessários.",
                                "Código limpo: Bem documentado, genérico, segue convenções Java.",
                                "Testes: Cobertura completa de casos normais e edge.",
                                "Manutenibilidade: Fácil estender para outras operações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Manipulação de ponteiros como funções injetoras em grafos direcionados.",
                                "Inglês: Redação de Javadoc e comentários em inglês técnico.",
                                "Física: Analogia com colisões de partículas (inserção sem perda de momentum).",
                                "Gestão: FIFO/LIFO em gerenciamento de filas de produção."
                              ],
                              "realWorldApplication": "Implementado em editores de texto para 'undo' (inserir ação reversa no topo da stack), playlists de música (adicionar faixa no início), ou caches LRU (least recently used) em sistemas web para priorizar acessos recentes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.2.3",
                            "name": "Implementar inserção no final",
                            "description": "Criar método insertAtEnd que percorre a lista até o último nó para adicionar novo elemento, otimizando com ponteiro tail se necessário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura da lista encadeada e o papel do ponteiro tail",
                                  "subSteps": [
                                    "Analise a classe Node com dados e ponteiro next.",
                                    "Identifique os atributos head e tail na classe ListaEncadeada.",
                                    "Desenhe um diagrama de uma lista com 3 nós, destacando head e tail.",
                                    "Explique verbalmente ou por escrito como o tail otimiza inserções no final.",
                                    "Compare listas sem e com tail em termos de eficiência."
                                  ],
                                  "verification": "Diagrama desenhado corretamente e explicação escrita de pelo menos 100 palavras.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código fonte da classe ListaEncadeada e Node",
                                    "Papel/caneta ou ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Sempre visualize a memória como setas entre nós para evitar confusões com arrays.",
                                  "learningObjective": "Dominar os componentes fundamentais da lista encadeada e o benefício do tail para O(1) inserções.",
                                  "commonMistakes": [
                                    "Confundir head (início) com tail (fim)",
                                    "Ignorar o caso de lista vazia onde head e tail são null"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar insertAtEnd básico percorrendo até o final (sem tail)",
                                  "subSteps": [
                                    "Crie o método público insertAtEnd(T data) na classe ListaEncadeada.",
                                    "Crie um novo Node com a data fornecida.",
                                    "Se head for null, defina head como o novo nó.",
                                    "Caso contrário, percorra do head até encontrar nó.next == null.",
                                    "Defina nó.next como o novo nó."
                                  ],
                                  "verification": "Código compila e insere corretamente em lista não vazia (teste manual com print).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE como IntelliJ ou VS Code",
                                    "Código da classe ListaEncadeada"
                                  ],
                                  "tips": "Use um loop while (atual = atual.next) != null para percorrer com segurança.",
                                  "learningObjective": "Implementar inserção O(n) percorrendo linearmente a lista.",
                                  "commonMistakes": [
                                    "Loop infinito por não checar next == null",
                                    "Não criar novo Node antes de inserir"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Tratar casos especiais e adicionar verificações",
                                  "subSteps": [
                                    "Adicione tratamento explícito para lista vazia: head = tail = novo nó.",
                                    "Implemente toString() ou print() para visualizar a lista após inserção.",
                                    "Teste inserção em lista vazia, com 1 elemento e múltiplos elementos.",
                                    "Verifique se não há vazamentos de memória ou ciclos.",
                                    "Adicione comentários explicando cada linha crítica."
                                  ],
                                  "verification": "Testes manuais passam: lista vazia vira [novo], não vazia adiciona no fim.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE com debugger",
                                    "JUnit ou testes unitários básicos"
                                  ],
                                  "tips": "Use debugger para pausar no loop e inspecionar ponteiros next.",
                                  "learningObjective": "Garantir robustez do método para todos os cenários iniciais da lista.",
                                  "commonMistakes": [
                                    "Esquecer de setar tail em lista vazia",
                                    "Não atualizar tail após inserção em não vazia"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimizar com ponteiro tail e validar eficiência",
                                  "subSteps": [
                                    "Atualize o atributo tail na classe ListaEncadeada.",
                                    "Modifique insertAtEnd: se tail != null, tail.next = novo nó; tail = novo nó.",
                                    "Para lista vazia, head = tail = novo nó.",
                                    "Meça tempo de inserção com 1000 elementos (sem vs com tail).",
                                    "Refatore código para clareza e adicione Javadoc."
                                  ],
                                  "verification": "Inserção em final é O(1): teste com cronômetro mostra diferença.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE",
                                    "Código atualizado",
                                    "Ferramenta de benchmark simples como System.nanoTime()"
                                  ],
                                  "tips": "Sempre atualize tail após qualquer inserção no final para manter consistência.",
                                  "learningObjective": "Otimizar de O(n) para O(1) usando tail, compreendendo trade-offs.",
                                  "commonMistakes": [
                                    "Atualizar tail incorretamente em listas não vazias",
                                    "Não inicializar tail como null"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e refinar o método completo",
                                  "subSteps": [
                                    "Crie suite de testes: vazio, um elemento, múltiplos, grandes listas.",
                                    "Use JUnit para assert size, conteúdo e ordem após inserções.",
                                    "Debug falhas comuns como perda de nós.",
                                    "Otimize código removendo redundâncias.",
                                    "Documente lições aprendidas em um README."
                                  ],
                                  "verification": "100% de testes passam, incluindo edge cases.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "JUnit ou framework de testes",
                                    "IDE com coverage"
                                  ],
                                  "tips": "Teste primeiro o que falha mais: listas vazias e grandes.",
                                  "learningObjective": "Validar implementação com testes automatizados para qualidade profissional.",
                                  "commonMistakes": [
                                    "Testes insuficientes para edge cases",
                                    "Ignorar NullPointerException"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma lista encadeada representando uma playlist de músicas: head -> 'Música A' -> 'Música B' -> null (tail em 'B'). Chame insertAtEnd('Música C'): resulta em head -> 'A' -> 'B' -> 'C' -> null (tail em 'C'), mantendo ordem de reprodução FIFO.",
                              "finalVerifications": [
                                "Método insere corretamente em lista vazia (head e tail apontam para novo nó).",
                                "Adiciona no final de listas não vazias sem alterar ordem existente.",
                                "Tail é atualizado corretamente para O(1) acessos futuros.",
                                "Não há ciclos ou perda de nós (verificar com toString()).",
                                "Complexidade é O(1) com tail ou O(n) sem, comprovado por testes.",
                                "Código compila e executa sem exceções em cenários variados."
                              ],
                              "assessmentCriteria": [
                                "Código limpo, legível com comentários e Javadoc.",
                                "Tratamento completo de casos edge (vazia, um nó, múltiplos).",
                                "Eficiência otimizada com tail (O(1) inserção final).",
                                "Encapsulamento OO respeitado (método público, private nodes).",
                                "Testes unitários cobrindo >90% do código.",
                                "Ausência de vazamentos de memória ou NullPointerExceptions."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de complexidade Big O e recorrência linear.",
                                "Algoritmos: Comparação com arrays e queues (FIFO).",
                                "Lógica e Debug: Rastreamento de ponteiros e detecção de ciclos.",
                                "Engenharia de Software: Testes unitários e refatoração.",
                                "Física/Realidade: Modelagem de cadeias ou filas reais (ex: trens encadeados)."
                              ],
                              "realWorldApplication": "Em sistemas de filas de impressão (print queues), logs de eventos em servidores (append no final sem reescrever tudo), playlists de streaming ou histórico de navegação em browsers, onde novos itens são eficientemente adicionados ao final sem acessar o início."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.3",
                        "name": "Métodos de Remoção e Travessia",
                        "description": "Adição de funcionalidades avançadas para remoção de elementos e travessia da lista, integrando padrões de projeto e UML para modelagem.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.3.1",
                            "name": "Implementar remoção por valor",
                            "description": "Desenvolver método removeByValue que busca o nó com o dado especificado, atualiza referências e libera memória, com tratamento de exceções para lista vazia ou não encontrada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir assinatura do método e tratar lista vazia",
                                  "subSteps": [
                                    "Analise a classe ListaEncadeada e Node (com campos data genérico e next).",
                                    "Defina a assinatura: public boolean removeByValue(T value) throws Exception.",
                                    "Implemente verificação inicial: if (head == null) throw new Exception(\"Lista vazia\");",
                                    "Retorne false se não encontrar, true se remover.",
                                    "Adicione comentário Javadoc explicando parâmetros e exceções."
                                  ],
                                  "verification": "Compilar código sem erros e testar com lista vazia lançando exceção correta.",
                                  "estimatedTime": "20 min",
                                  "materials": [
                                    "Editor de código (Eclipse/IntelliJ)",
                                    "Classe ListaEncadeada base"
                                  ],
                                  "tips": "Use genéricos <T> para flexibilidade em qualquer tipo de dado.",
                                  "learningObjective": "Entender tratamento de pré-condições e exceções básicas em métodos de lista.",
                                  "commonMistakes": [
                                    "Esquecer genéricos, causando erros de tipo.",
                                    "Não lançar exceção para lista vazia.",
                                    "Retornar void em vez de boolean."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar busca pelo nó com o valor especificado",
                                  "subSteps": [
                                    "Crie referência Node<T> current = head; e Node<T> previous = null;",
                                    "Inicie loop while (current != null && !current.data.equals(value)) { previous = current; current = current.next; }",
                                    "Use equals() para comparação de valor, considerando null safety.",
                                    "Pare o loop quando encontrar ou chegar ao fim.",
                                    "Registre posição: se previous == null, é o head."
                                  ],
                                  "verification": "Adicione prints ou debug para confirmar que o nó correto é localizado em testes manuais.",
                                  "estimatedTime": "25 min",
                                  "materials": [
                                    "Debugger do IDE",
                                    "Lista de teste com 5-10 nós"
                                  ],
                                  "tips": "Sempre avance previous junto com current para manter track do anterior.",
                                  "learningObjective": "Dominar travessia unidirecional em listas encadeadas com rastreamento de ponteiros.",
                                  "commonMistakes": [
                                    "Comparar com == em vez de equals() para objetos.",
                                    "Loop infinito por não avançar current.",
                                    "Perder track do previous, impossibilitando remoção."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Atualizar referências para remover o nó",
                                  "subSteps": [
                                    "Se current == null, retorne false (não encontrado).",
                                    "Caso 1: Remover head (previous == null): head = current.next; current.next = null;",
                                    "Caso 2: Nó intermediário: previous.next = current.next; current.next = null;",
                                    "Atualize size-- se houver campo size na lista.",
                                    "Libere memória: current = null; (em Java, GC cuida, mas boa prática).",
                                    "Retorne true."
                                  ],
                                  "verification": "Execute remoção e itere a lista para confirmar ausência do valor e links corretos.",
                                  "estimatedTime": "30 min",
                                  "materials": [
                                    "JUnit para testes unitários",
                                    "Casos de teste: head, meio, fim"
                                  ],
                                  "tips": "Sempre isole o nó removido setando next = null para evitar vazamentos.",
                                  "learningObjective": "Manipular ponteiros dinamicamente para remoção segura em estruturas encadeadas.",
                                  "commonMistakes": [
                                    "Não tratar remoção de head corretamente, perdendo lista inteira.",
                                    "Criar ciclos acidentais ao não setar next = null.",
                                    "Esquecer decrementar size."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar tratamento de exceções avançado e testes",
                                  "subSteps": [
                                    "Lance custom Exception se não encontrado: throw new Exception(\"Valor não encontrado\"); opcional.",
                                    "Teste casos edge: lista com 1 nó, duplicados (remover primeiro), null value.",
                                    "Implemente toString() na lista para visualização.",
                                    "Escreva 5+ testes JUnit cobrindo todos cenários.",
                                    "Meça performance com listas grandes (n=1000)."
                                  ],
                                  "verification": "Todos testes passam (100% cobertura) sem vazamentos ou crashes.",
                                  "estimatedTime": "35 min",
                                  "materials": [
                                    "JUnit 5",
                                    "Ferramenta de cobertura como JaCoCo"
                                  ],
                                  "tips": "Priorize testes antes de refatorar código principal.",
                                  "learningObjective": "Garantir robustez com TDD e tratamento exhaustivo de exceções.",
                                  "commonMistakes": [
                                    "Não testar duplicados, removendo múltiplos acidentalmente.",
                                    "Ignorar null pointers em equals().",
                                    "Exceções não documentadas."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma lista de tarefas: LinkedList<Task> tasks = new LinkedList<>(); tasks.add(new Task(\"Comprar leite\")); tasks.add(new Task(\"Estudar Java\")); tasks.removeByValue(\"Comprar leite\"); // Agora lista tem só \"Estudar Java\", sem vazamentos.",
                              "finalVerifications": [
                                "Método retorna true/false corretamente.",
                                "Valor removido não aparece mais em iterações.",
                                "Links da lista permanecem intactos (sem ciclos ou perdas).",
                                "Memória liberada (sem referências pendentes).",
                                "Exceções lançadas para vazia/não-encontrado.",
                                "Size atualizado se aplicável."
                              ],
                              "assessmentCriteria": [
                                "Código limpo, indentado e comentado.",
                                "Tratamento completo de casos edge (vazia, head, fim, duplicados).",
                                "Eficiência O(n) sem otimizações desnecessárias.",
                                "Uso correto de genéricos e equals().",
                                "Testes unitários com >90% cobertura.",
                                "Exceções bem definidas e documentadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica de grafos e traversais (árvores/listas como subgrafos).",
                                "Inglês: Documentação Javadoc e leitura de specs de exceções.",
                                "Física/Engenharia: Gerenciamento de recursos finitos (memória como energia).",
                                "Ética em Computação: Prevenir vazamentos para sustentabilidade."
                              ],
                              "realWorldApplication": "Em editores de texto (remover palavras específicas), gerenciadores de cache (evitar duplicatas), playlists de música (remover faixa por nome) ou sistemas de banco de dados em memória para deleções rápidas sem índices."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.3.2",
                            "name": "Implementar método de travessia",
                            "description": "Criar método traverse ou print que itera pelos nós do head ao final, exibindo dados via console ou coletando em estrutura auxiliar, suportando genéricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e Diagramar a Estrutura da Lista Encadeada Genérica",
                                  "subSteps": [
                                    "Examine a classe Node<T> com campos data (T) e next (Node<T> ou null)",
                                    "Identifique o atributo head na classe LinkedList<T> e seu papel como ponto de entrada",
                                    "Desenhe um diagrama manual de uma lista com 3-4 nós, incluindo head e ponteiros next",
                                    "Considere casos especiais: lista vazia (head == null) e lista com um nó",
                                    "Anote como genéricos <T> permitem qualquer tipo de dado (ex: Integer, String)"
                                  ],
                                  "verification": "Diagrama completo desenhado e casos especiais anotados corretamente",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código fonte das classes Node<T> e LinkedList<T>",
                                    "Papel/caneta ou ferramenta de diagrama como Draw.io"
                                  ],
                                  "tips": "Use setas para representar ponteiros next e marque null explicitamente",
                                  "learningObjective": "Compreender visualmente a topologia da lista para preparar iteração segura",
                                  "commonMistakes": [
                                    "Ignorar genéricos e usar tipos concretos prematuramente",
                                    "Confundir head com o primeiro nó de dados",
                                    "Não considerar ponteiro null no final"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar a Assinatura e Lógica do Método Traverse",
                                  "subSteps": [
                                    "Defina a assinatura: public void traverse() ou public <T> List<T> traverse() para coleta auxiliar",
                                    "Planeje loop while: inicie com current = head; while(current != null)",
                                    "Decida saída: console.log(data) ou add to auxiliar List<T>",
                                    "Inclua tratamento para lista vazia: mensagem ou lista vazia retornada",
                                    "Esboce pseudocódigo em papel: current = current.next no final de cada iteração"
                                  ],
                                  "verification": "Pseudocódigo escrito e assinatura anotada com exemplos de uso",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para pseudocódigo",
                                    "Editor de texto para assinatura"
                                  ],
                                  "tips": "Prefira void para simplicidade inicial; evolua para retorno de List<T> depois",
                                  "learningObjective": "Planejar método genérico que itera sem modificar a estrutura",
                                  "commonMistakes": [
                                    "Loop infinito por esquecer current = current.next",
                                    "Não usar genéricos na assinatura",
                                    "Ignorar retorno de null em listas vazias"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Método Traverse no Código",
                                  "subSteps": [
                                    "Adicione o método na classe LinkedList<T>: public void traverse() { ... }",
                                    "Inicialize Node<T> current = head;",
                                    "Use while(current != null) { System.out.print(current.data + \" -> \"); current = current.next; }",
                                    "Adicione System.out.println(\"null\"); após o loop para final visual",
                                    "Compile e corrija erros de genéricos ou null pointers iniciais"
                                  ],
                                  "verification": "Código compila sem erros e método é adicionado corretamente",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE como IntelliJ ou Eclipse",
                                    "Código base da LinkedList<T>"
                                  ],
                                  "tips": "Use toString() se T não tiver print direto; teste com System.out",
                                  "learningObjective": "Codificar iteração linear segura com genéricos em OO",
                                  "commonMistakes": [
                                    "NullPointerException por não checar current != null",
                                    "Modificar next durante iteração",
                                    "Perder genéricos com cast desnecessário"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Refinar o Método com Casos Diversos",
                                  "subSteps": [
                                    "Crie instância vazia: new LinkedList<T>() e chame traverse()",
                                    "Adicione 1, 3 e 5 nós com dados variados (Integer, String) e teste",
                                    "Verifique saída: lista vazia imprime 'null', cheia imprime 'data -> ... -> null'",
                                    "Implemente versão alternativa coletando em ArrayList<T> e imprima",
                                    "Refatore para robustez: adicione logs ou exceções se necessário"
                                  ],
                                  "verification": "Todos testes passam com saídas esperadas documentadas",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Main class para testes",
                                    "JUnit para testes unitários opcionais"
                                  ],
                                  "tips": "Use assert ou prints para validar; teste ordem de inserção",
                                  "learningObjective": "Validar implementação em cenários reais e iterar melhorias",
                                  "commonMistakes": [
                                    "Não testar lista vazia",
                                    "Saída incorreta em ordem reversa",
                                    "Falhar em genéricos com tipos primitivos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma LinkedList<Integer>, adicione 10, 20, 30. Chame traverse(): saída '10 -> 20 -> 30 -> null'. Para String: 'Alice -> Bob -> null'. Colete em List<String> para processar nomes de usuários.",
                              "finalVerifications": [
                                "Método itera todos os nós do head ao final sem pular ou repetir",
                                "Trata corretamente lista vazia sem crash ou saída errada",
                                "Suporta genéricos com múltiplos tipos (Integer, String, custom objects)",
                                "Saída via console ou estrutura auxiliar é precisa e formatada",
                                "Não modifica a lista original durante travessia",
                                "Compila e executa sem NullPointerException ou erros de tipo"
                              ],
                              "assessmentCriteria": [
                                "Código usa loop while seguro com current != null (peso: alto)",
                                "Genéricos <T> aplicados corretamente em Node e método",
                                "Tratamento explícito de edge cases (vazia, um nó)",
                                "Saída legível e consistente (ex: 'data -> null')",
                                "Eficiência O(n) sem recursão desnecessária",
                                "Código limpo, comentado e indentado corretamente"
                              ],
                              "crossCurricularConnections": [
                                "Algoritmos: Introduz iteração linear similar a arrays e árvores",
                                "Matemática Discreta: Modela grafos direcionados acíclicos (DAGs)",
                                "Análise de Dados: Base para processamento de sequências e streams",
                                "Desenvolvimento Web: Percorre DOM nodes ou JSON arrays",
                                "Engenharia de Software: Padrão Iterator para coleções"
                              ],
                              "realWorldApplication": "Em sistemas de gerenciamento de estoque, percorrer lista de produtos para gerar relatórios; em apps de rede social, iterar posts de um feed de usuário; processar logs de servidor em filas encadeadas para monitoramento em tempo real."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.3.3",
                            "name": "Adicionar verificação de lista vazia",
                            "description": "Implementar método isEmpty que retorna se head é null, usado em todos os métodos para evitar exceções e melhorar robustez da implementação OO.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a necessidade de verificação de lista vazia",
                                  "subSteps": [
                                    "Revise o código atual da classe de lista encadeada e identifique métodos como remove, size ou traverse que acessam 'head' sem verificação.",
                                    "Explique por que acessar 'head' em uma lista vazia causa NullPointerException em linguagens como Java.",
                                    "Discuta benefícios: robustez, prevenção de exceções e promoção de programação defensiva em OO.",
                                    "Desenhe um diagrama simples de lista vazia (head = null) vs. lista com nós.",
                                    "Liste cenários reais onde listas podem estar vazias (inicialização, após remoções totais)."
                                  ],
                                  "verification": "Documento ou comentário no código explicando pelo menos 3 riscos de não verificar e 2 benefícios.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Código fonte da lista encadeada, editor de texto ou IDE (ex: IntelliJ, VS Code), papel para diagrama.",
                                  "tips": "Pense em exceções passadas no seu código para motivar a mudança.",
                                  "learningObjective": "Compreender o impacto de listas vazias na robustez de estruturas de dados OO.",
                                  "commonMistakes": "Ignorar cenários de uso real; confundir 'head == null' com 'size == 0' sem implementação de size."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar o método isEmpty",
                                  "subSteps": [
                                    "Defina a assinatura: public boolean isEmpty() { ... } na classe LinkedList<T>.",
                                    "Decida a lógica: return head == null; (simples e eficiente O(1)).",
                                    "Considere genéricos: certifique-se de que funciona com qualquer tipo T.",
                                    "Adicione Javadoc comentando propósito, pré-condições (nenhuma) e pós-condições (true se vazia).",
                                    "Compare com alternativas como size() == 0, justificando por que isEmpty é preferível (lazy evaluation)."
                                  ],
                                  "verification": "Método projetado com assinatura, lógica e comentário Javadoc visíveis no código.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "IDE com suporte a Java/linguagem OO, template de Javadoc.",
                                  "tips": "Mantenha O(1) tempo; evite percorrer a lista.",
                                  "learningObjective": "Projetar métodos utilitários simples e eficientes em classes OO genéricas.",
                                  "commonMistakes": "Retornar void em vez de boolean; esquecer genéricos na assinatura."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e integrar isEmpty em métodos existentes",
                                  "subSteps": [
                                    "Implemente o método isEmpty no código da classe.",
                                    "Refatore pelo menos 3 métodos (ex: removeFirst, traverse, getSize) para chamar if (isEmpty()) { throw new EmptyListException(); ou return; } antes de acessar head.",
                                    "Crie uma exceção customizada EmptyListException se não existir.",
                                    "Garanta que a integração mantenha contratos pré-existentes (ex: não altera comportamento sem lista vazia).",
                                    "Compile o código para verificar erros de sintaxe."
                                  ],
                                  "verification": "Código compila sem erros e isEmpty é usado em pelo menos 3 métodos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "IDE com compilador Java, código fonte atualizado.",
                                  "tips": "Use 'extract method' refactor na IDE para consistência.",
                                  "learningObjective": "Aplicar programação defensiva integrando verificações em código OO legado.",
                                  "commonMistakes": "Não tratar exceções adequadamente; quebrar métodos que já lidavam com vazias."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar a verificação de lista vazia",
                                  "subSteps": [
                                    "Escreva testes unitários: teste isEmpty() em lista nova (true), após add (false), após clear (true).",
                                    "Teste métodos refatorados: chame remove em vazia e verifique exceção ou retorno correto.",
                                    "Use JUnit ou framework similar para automação; cubra edge cases como múltiplas remoções.",
                                    "Execute testes e registre cobertura (almeje 100% para isEmpty).",
                                    "Debug qualquer falha e ajuste."
                                  ],
                                  "verification": "Todos os testes passam com relatório de cobertura.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Framework de testes (JUnit), IDE com runner de testes.",
                                  "tips": "Teste-first: escreva testes antes de refatorar para TDD.",
                                  "learningObjective": "Validar robustez através de testes unitários em estruturas de dados.",
                                  "commonMistakes": "Esquecer testes para lista não-vazia; não mockar dependências."
                                }
                              ],
                              "practicalExample": "Em uma LinkedList<String> lista = new LinkedList<>(); lista.removeFirst(); // Antes: NullPointerException. Depois: if (lista.isEmpty()) throw new EmptyListException(); // Lança exceção customizada sem crash.",
                              "finalVerifications": [
                                "isEmpty() retorna true para head == null e false caso contrário.",
                                "Métodos refatorados não acessam head sem verificação via isEmpty().",
                                "Testes unitários passam para cenários vazios e não-vazios.",
                                "Código compila e roda sem exceções inesperadas.",
                                "Javadoc está presente e preciso.",
                                "Performance permanece O(1) para isEmpty()."
                              ],
                              "assessmentCriteria": [
                                "Lógica de isEmpty correta e eficiente (O(1)).",
                                "Integração em múltiplos métodos com tratamento defensivo.",
                                "Cobertura de testes >= 90% para funcionalidades relacionadas.",
                                "Código limpo: sem warnings, boa nomenclatura.",
                                "Documentação completa (comentários e Javadoc).",
                                "Tratamento de exceções consistente e customizado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica booleana e condições if-then-else.",
                                "Algoritmos: Complexidade temporal O(1) vs. O(n).",
                                "Design de Software: Princípios SOLID (Single Responsibility para isEmpty).",
                                "Testes: Metodologia TDD e cobertura de código."
                              ],
                              "realWorldApplication": "Em apps como editores de texto (listas de linhas vazias), jogos (inventários vazios) ou bancos (contas sem transações), previne crashes e melhora UX com mensagens claras em vez de stack traces."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.3",
                    "name": "Tipos Genéricos em Linguagens OO",
                    "description": "Definição e sintaxe de genéricos para parametrização de tipos em classes e métodos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.3.1",
                        "name": "Definição de Tipos Genéricos",
                        "description": "Conceito fundamental de tipos genéricos como mecanismo para parametrizar classes e métodos com tipos de dados específicos, promovendo reutilização de código, segurança de tipos e abstração em linguagens OO como Java, C# e C++.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.1.1",
                            "name": "Identificar a necessidade de tipos genéricos",
                            "description": "Reconhecer cenários onde genéricos evitam duplicação de código, como listas ou pilhas para diferentes tipos de dados, comparando com implementações não genéricas em linguagens OO.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito de Duplicação de Código em Estruturas de Dados",
                                  "subSteps": [
                                    "Defina duplicação de código como a repetição desnecessária de lógica similar em múltiplas classes ou métodos.",
                                    "Identifique exemplos comuns em estruturas de dados OO, como listas ou pilhas específicas para int, String ou double.",
                                    "Compare com o princípio DRY (Don't Repeat Yourself) em programação.",
                                    "Analise o impacto da duplicação: manutenção difícil, bugs propagados e código inchado.",
                                    "Discuta cenários iniciais onde tipos fixos levam a classes separadas."
                                  ],
                                  "verification": "Escreva uma definição clara de duplicação de código e liste 2 exemplos de estruturas de dados afetadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação de linguagens OO (Java/C#), editor de código simples.",
                                  "tips": "Use diagramas de classes para visualizar a repetição antes de codificar.",
                                  "learningObjective": "Compreender por que duplicação ocorre em implementações não-genéricas.",
                                  "commonMistakes": "Confundir duplicação com sobrecarga de métodos; focar apenas em cópia literal de código."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Estruturas Não-Genéricas para Diferentes Tipos",
                                  "subSteps": [
                                    "Crie uma classe StackInt para pilha de inteiros com push, pop e isEmpty.",
                                    "Duplique o código para criar StackString para strings, alterando apenas o tipo.",
                                    "Teste ambas as classes com dados de exemplo (ex: push 1,2,3; pop verifica).",
                                    "Repita para um terceiro tipo, como StackDouble, destacando a repetição.",
                                    "Meça o tamanho total do código e note a similaridade (>90% idêntico)."
                                  ],
                                  "verification": "Execute testes em todas as stacks e confirme que funcionam, mas gere um relatório de linhas duplicadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "IDE com Java ou C# (Eclipse/Visual Studio), JUnit para testes.",
                                  "tips": "Copie e cole o código intencionalmente para simular duplicação real; use git diff para comparar.",
                                  "learningObjective": "Demonstrar na prática como tipos fixos forçam duplicação.",
                                  "commonMistakes": "Implementar lógica diferente por tipo; ignorar métodos auxiliares duplicados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Problemas da Duplicação e Identificar Necessidade de Genéricos",
                                  "subSteps": [
                                    "Liste problemas: adicionar novo tipo requer nova classe inteira.",
                                    "Compare código não-genérico vs genérico conceitual (ex: Stack<T>).",
                                    "Identifique cenários: coleções reutilizáveis (listas, maps) para user-defined types.",
                                    "Discuta type safety: não-genéricos usam Object e casting, propensos a erros.",
                                    "Avalie trade-offs: genéricos adicionam complexidade sintática mas reduzem duplicação."
                                  ],
                                  "verification": "Crie uma tabela comparativa (não-genérico vs genérico) com colunas: código, manutenção, type safety.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha ou Markdown para tabela, exemplos de código das stacks.",
                                  "tips": "Pense em bibliotecas reais como ArrayList em Java para motivação.",
                                  "learningObjective": "Reconhecer cenários onde genéricos resolvem duplicação e melhoram segurança.",
                                  "commonMistakes": "Subestimar riscos de casting em não-genéricos; achar que herança resolve tudo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Refatorar para Genéricos e Validar Benefícios",
                                  "subSteps": [
                                    "Implemente uma Stack<T> genérica unificando as classes anteriores.",
                                    "Teste com Integer, String e Double para provar reutilização.",
                                    "Meça redução de código (ex: de 300 para 80 linhas).",
                                    "Verifique type safety: compile erros se push errado tipo.",
                                    "Documente 3 cenários reais onde isso é necessário (ex: pilha de objetos custom)."
                                  ],
                                  "verification": "Rode testes para múltiplos tipos na Stack<T> sem erros ou casts.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Mesma IDE, exemplos de código refatorados.",
                                  "tips": "Use <?> ou wildcards se aplicável, mas foque em <T> simples.",
                                  "learningObjective": "Aplicar genéricos para eliminar duplicação e identificar sua necessidade.",
                                  "commonMistakes": "Esquecer bounds em T (ex: T extends Number); não testar type mismatches."
                                }
                              ],
                              "practicalExample": "Em um sistema de gerenciamento de estoque, crie StackInt para IDs de produtos inteiros e StackString para nomes; duplique para StackDouble (preços). Refatore para Stack<T> permitindo Stack<Product> sem duplicação, evitando 100+ linhas extras.",
                              "finalVerifications": [
                                "Explica corretamente 3 cenários onde genéricos evitam duplicação (ex: listas, queues, maps).",
                                "Compara código não-genérico vs genérico, destacando redução de duplicação.",
                                "Identifica riscos de type erasure ou casting em não-genéricos.",
                                "Implementa e testa uma estrutura genérica simples sem erros.",
                                "Lista benefícios: reusabilidade, type safety, manutenção.",
                                "Distingue genéricos de herança ou templates em C++."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de duplicação (90% dos casos corretos).",
                                "Qualidade da comparação código (tabelas/diagramas claros).",
                                "Correção na implementação genérica (compila e testa OK).",
                                "Profundidade na análise de cenários (mínimo 3 exemplos reais).",
                                "Clareza na explicação de type safety vs Object casting.",
                                "Criatividade em exemplos práticos além dos básicos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstração e parametrização similar a funções genéricas.",
                                "Design de Software: Princípios SOLID (Single Responsibility via genéricos).",
                                "Algoritmos: Estruturas de dados reutilizáveis em DS&A.",
                                "Lógica: Reconhecimento de padrões de repetição como em provas matemáticas."
                              ],
                              "realWorldApplication": "Bibliotecas padrão como Java Collections (ArrayList<T>) ou .NET Generics evitam duplicação em apps empresariais, permitindo stacks de transações financeiras ou queues de mensagens sem recriar classes por tipo de dado."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.2",
                            "name": "Explicar benefícios e limitações dos genéricos",
                            "description": "Descrever vantagens como type safety em tempo de compilação, reusabilidade e performance, além de limitações como erasure em Java ou restrições em Python com typing.Generic.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os benefícios principais dos tipos genéricos",
                                  "subSteps": [
                                    "Revise a definição de tipos genéricos em linguagens como Java e C#.",
                                    "Liste os três benefícios chave: type safety, reusabilidade e performance.",
                                    "Compare com código não-genérico para destacar diferenças iniciais.",
                                    "Anote exemplos conceituais para cada benefício.",
                                    "Pesquise documentação oficial de Java Generics ou C# Generics."
                                  ],
                                  "verification": "Crie uma tabela comparativa listando benefícios com breves descrições.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Java Generics (Oracle Docs)",
                                    "Editor de código como IntelliJ ou VS Code",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Comece com exemplos simples como List<T> vs ArrayList raw para visualizar benefícios.",
                                  "learningObjective": "Compreender os benefícios fundamentais dos genéricos de forma conceitual.",
                                  "commonMistakes": [
                                    "Confundir type safety com runtime checks",
                                    "Ignorar que reusabilidade reduz duplicação de código"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar type safety e reusabilidade em profundidade",
                                  "subSteps": [
                                    "Implemente um exemplo de classe genérica com type safety (ex: Stack<T>).",
                                    "Teste cenários de erro de tipo em tempo de compilação vs runtime sem genéricos.",
                                    "Refatore código duplicado (ex: Stack para Inteiros e Strings) usando genéricos.",
                                    "Analise como genéricos promovem código reutilizável em projetos maiores.",
                                    "Compile e execute testes para validar type safety."
                                  ],
                                  "verification": "Execute código com e sem genéricos, mostrando erros de compilação resolvidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "JDK ou .NET SDK",
                                    "Editor de código com suporte a Java/C#",
                                    "Exemplos de código de repositórios GitHub sobre genéricos"
                                  ],
                                  "tips": "Use <? extends T> para bounded types para demonstrar type safety avançada.",
                                  "learningObjective": "Aplicar type safety e reusabilidade através de exemplos práticos.",
                                  "commonMistakes": [
                                    "Usar tipos raw acidentalmente",
                                    "Esquecer de lidar com wildcards em type safety"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar ganhos de performance e limitações iniciais",
                                  "subSteps": [
                                    "Meça performance de coleções genéricas vs não-genéricas com benchmarks simples.",
                                    "Explique como genéricos evitam boxing/unboxing em linguagens como Java.",
                                    "Introduza limitações: type erasure em Java (genéricos só em compile-time).",
                                    "Teste reflexão em código genérico para mostrar impactos de erasure.",
                                    "Compare performance em loops com List<Integer> vs List raw."
                                  ],
                                  "verification": "Gere relatório de benchmark mostrando diferenças de tempo de execução.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de benchmark como JMH para Java",
                                    "Timer no código",
                                    "Documentação sobre Type Erasure"
                                  ],
                                  "tips": "Foquem em cenários reais como iterações em grandes listas para performance.",
                                  "learningObjective": "Quantificar performance e introduzir limitações técnicas.",
                                  "commonMistakes": [
                                    "Atribuir performance só a genéricos sem considerar boxing",
                                    "Confundir erasure com perda total de tipos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Profundizar limitações em linguagens específicas e síntese",
                                  "subSteps": [
                                    "Estude restrições em Python (typing.Generic não é enforced em runtime).",
                                    "Exemplo de falha: instanceof com genéricos em Java devido a erasure.",
                                    "Liste limitações adicionais: complexidade em herança, restrições em primitives.",
                                    "Crie um resumo comparativo Java vs Python vs C#.",
                                    "Discuta trade-offs em design de APIs."
                                  ],
                                  "verification": "Escreva um ensaio curto (200 palavras) resumindo benefícios vs limitações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "PEP 484 para Python typing",
                                    "Livro 'Effective Java' capítulo sobre genéricos",
                                    "Fórum Stack Overflow exemplos de limitações"
                                  ],
                                  "tips": "Use diagramas para ilustrar type erasure (tipo vira Object em bytecode).",
                                  "learningObjective": "Sintetizar limitações cross-language e equilibrar visão.",
                                  "commonMistakes": [
                                    "Superestimar enforcement em Python",
                                    "Ignorar soluções como @SuppressWarnings para erasure"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Java, crie uma classe genérica Queue<T>: sem genéricos, você duplicaria código para Queue<Integer> e Queue<String>, perdendo type safety (adiciona String em fila de ints em runtime). Com genéricos, compile-time erro previne isso. Limitação: não pode usar 'if (obj instanceof Queue<Integer>)' devido a erasure, que transforma para Queue em bytecode.",
                              "finalVerifications": [
                                "Explicar type safety sem olhar notas.",
                                "Identificar 3 limitações de genéricos em Java.",
                                "Refatorar código não-genérico para genérico corretamente.",
                                "Comparar performance em benchmark simples.",
                                "Discutir diferença entre Java erasure e Python typing.",
                                "Listar 2 cenários onde genéricos não são ideais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de type safety (compile-time vs runtime).",
                                "Exemplos concretos de reusabilidade sem duplicação.",
                                "Análise equilibrada de performance com evidências.",
                                "Cobertura de limitações específicas por linguagem.",
                                "Clareza na comunicação de trade-offs.",
                                "Uso correto de terminologia (erasure, bounded types)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstrações paramétricas semelhantes a polimorfismo em funções genéricas.",
                                "Design de Software: Princípios SOLID (abstração e dependência inversa via genéricos).",
                                "Ciência da Computação: Teoria de Tipos e sistemas type-safe.",
                                "Lógica e Raciocínio: Análise de trade-offs em otimização."
                              ],
                              "realWorldApplication": "Bibliotecas como Java Collections Framework usam genéricos para type-safe containers em apps empresariais, evitando erros caros em produção; em machine learning com Python, typing.Generic melhora IDE support e refatoração em grandes projetos como TensorFlow."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.3",
                            "name": "Diferenciar genéricos de outros mecanismos OO",
                            "description": "Comparar genéricos com herança, polimorfismo e templates em C++, destacando como genéricos parametrizam tipos em vez de estender comportamentos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Herança e Polimorfismo",
                                  "subSteps": [
                                    "Defina herança: mecanismo para criar classes derivadas que herdam propriedades e comportamentos de uma classe base.",
                                    "Explique polimorfismo: capacidade de objetos de diferentes classes serem tratados como instâncias de uma classe base, via sobrescrita de métodos virtuais.",
                                    "Escreva um exemplo simples em C++ de uma hierarquia de classes Animal -> Dog -> Cat com método virtual speak().",
                                    "Compile e execute o código para observar o polimorfismo em ação.",
                                    "Anote limitações: acoplamento forte e necessidade de conhecer tipos em tempo de compilação."
                                  ],
                                  "verification": "Código compila e executa corretamente demonstrando polimorfismo; anotações listam pelo menos 3 limitações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Compilador C++ (g++), IDE como Visual Studio Code ou CLion, documentação C++ oficial.",
                                  "tips": "Use ponteiros para a classe base para testar polimorfismo dinâmico.",
                                  "learningObjective": "Entender como herança e polimorfismo estendem comportamentos específicos de classes.",
                                  "commonMistakes": "Confundir herança com composição; esquecer modificador virtual em métodos polimórficos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Templates como Mecanismo Genérico em C++",
                                  "subSteps": [
                                    "Defina templates: funções ou classes parametrizadas por tipos, compiladas para tipos específicos em tempo de compilação.",
                                    "Escreva uma função template simples: template<typename T> T max(T a, T b).",
                                    "Crie uma classe template: template<typename T> class Stack { ... } com push e pop.",
                                    "Instancie Stack<int> e Stack<string> e teste operações.",
                                    "Compare com funções não-template: note reutilização sem duplicação de código."
                                  ],
                                  "verification": "Código com Stack<int> e Stack<string> compila e funciona; explique instanciação em 1 parágrafo.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Compilador C++, exemplos de código da STL (vector, list), livro 'C++ Templates' de Vandevoorde.",
                                  "tips": "Use typename em loops de template para evitar erros de dependência.",
                                  "learningObjective": "Dominar sintaxe e benefícios de templates para parametrização de tipos.",
                                  "commonMistakes": "Esquecer template<> em especializações; usar tipos não-copiáveis em containers template."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Genéricos/Templates com Herança e Polimorfismo",
                                  "subSteps": [
                                    "Liste diferenças chave: genéricos parametrizam tipos (estático), herança estende hierarquia (dinâmico).",
                                    "Refatore exemplo de Stack de Animal para herança vs template: compare código fonte e binário.",
                                    "Analise performance: templates geram código especializado (zero overhead virtual), herança usa vtables.",
                                    "Discuta flexibilidade: genéricos funcionam com qualquer tipo, herança requer hierarquia comum.",
                                    "Crie tabela comparativa: colunas para Genéricos, Herança, Polimorfismo (linhas: tipo, performance, reutilização)."
                                  ],
                                  "verification": "Tabela comparativa completa com pelo menos 5 linhas; código refatorado testado.",
                                  "estimatedTime": "1 hora 15 minutos",
                                  "materials": "Ferramenta de análise binária como objdump, exemplos STL (std::vector<T>).",
                                  "tips": "Meça tamanho do executável com nm ou size para comparar overhead.",
                                  "learningObjective": "Identificar quando usar genéricos vs herança/polimorfismo baseado em cenários.",
                                  "commonMistakes": "Achar templates 'dinâmicos' como polimorfismo; ignorar code bloat em templates."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Aplicar Diferenças em Cenários Práticos",
                                  "subSteps": [
                                    "Resuma: genéricos para algoritmos independentes de tipo, OO para comportamentos compartilhados.",
                                    "Escolha cenário errado: tente usar herança para Stack de ints/strings (falha), corrija com templates.",
                                    "Debata trade-offs: genéricos evitam slicing mas requerem SFINAE para constraints.",
                                    "Implemente exemplo híbrido: classe template com polimorfismo interno.",
                                    "Escreva ensaio curto (200 palavras) diferenciando os mecanismos."
                                  ],
                                  "verification": "Ensaio cobre 3 diferenças principais com exemplos; código híbrido funcional.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel/notas ou Markdown para tabela/ensaio, debugger GDB.",
                                  "tips": "Use concepts em C++20 para constraints modernos em templates.",
                                  "learningObjective": "Aplicar conhecimentos para escolher mecanismo OO correto.",
                                  "commonMistakes": "Confundir templates C++ com genéricos Java (erasure); superestimar polimorfismo para performance."
                                }
                              ],
                              "practicalExample": "Implemente uma pilha (Stack) para processar números inteiros e strings. Versão 1: Use herança com classe base Item (falha para tipos diferentes). Versão 2: Use template<typename T> class Stack<T>. Compare: herança acopla tipos e tem overhead virtual; template é flexível, type-safe e otimizado.",
                              "finalVerifications": [
                                "Explique verbalmente 3 diferenças chave entre genéricos e herança.",
                                "Forneça código template que falharia com herança pura.",
                                "Identifique overhead de performance em exemplo polimórfico vs genérico.",
                                "Crie tabela comparativa precisa.",
                                "Aplique em novo cenário: queue para shapes vs primitives.",
                                "Debata por que STL usa templates extensivamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas sem confusões (80%).",
                                "Exemplos funcionais e compiláveis (100%).",
                                "Análise comparativa profunda (performance, flexibilidade, type-safety).",
                                "Identificação correta de use cases para cada mecanismo.",
                                "Ausência de erros comuns como confundir static/dinamic dispatch.",
                                "Clareza na síntese final e tabela."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Genéricos como funções polimórficas parametrizadas por tipos (análogos a funções genéricas).",
                                "Design de Software: Padrões como Strategy vs Template Method.",
                                "Algoritmos: Abstração de estruturas de dados independentes de tipo (STL).",
                                "Lógica: Raciocínio sobre tempo de compilação vs execução.",
                                "Física/Engenharia: Modelagem genérica de simulações (partículas de tipos variados)."
                              ],
                              "realWorldApplication": "Na biblioteca STL do C++, containers como std::vector<T> usam templates para eficiência e reutilização em apps como jogos (Unity plugins), finanças (arrays de doubles genéricos) e ML (tensores template), evitando overhead de herança para performance crítica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.2",
                        "name": "Sintaxe de Classes Genéricas",
                        "description": "Declaração e uso de classes parametrizadas por tipos genéricos, incluindo type parameters, bounds e instanciação em linguagens OO.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.2.1",
                            "name": "Declarar uma classe genérica simples",
                            "description": "Escrever sintaxe para classe genérica como 'class Caixa<T> { private T valor; }' em Java ou equivalente em C# e C++ (template<typename T> class Caixa).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Fundamentais de Tipos Genéricos",
                                  "subSteps": [
                                    "Estude o que são tipos genéricos: estruturas que operam com tipos desconhecidos em tempo de compilação, resolvidos em tempo de uso.",
                                    "Compare genéricos com tipos concretos: genéricos evitam duplicação de código e aumentam type-safety.",
                                    "Revise exemplos não-genéricos vs. genéricos, como uma classe Stack para int vs. Stack<T>.",
                                    "Identifique benefícios: reusabilidade, segurança de tipos e performance (sem boxing em Java/C#).",
                                    "Anote diferenças entre linguagens: Java usa erasure, C# reified, C++ templates completos."
                                  ],
                                  "verification": "Resuma em 3 frases os benefícios e diferenças de genéricos nas três linguagens; confira com documentação oficial.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Java Generics (Oracle)",
                                    "C# Generics (Microsoft Docs)",
                                    "C++ Templates (cppreference.com)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use analogias como 'caixas que se adaptam ao conteúdo' para fixar o conceito.",
                                  "learningObjective": "Compreender o propósito e vantagens de classes genéricas para preparar a declaração prática.",
                                  "commonMistakes": [
                                    "Confundir genéricos com herança",
                                    "Ignorar limitações como type erasure em Java",
                                    "Achar que genéricos são só para coleções"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar uma Classe Genérica Simples em Java",
                                  "subSteps": [
                                    "Crie um arquivo .java novo em uma IDE como IntelliJ.",
                                    "Escreva: public class Caixa<T> { private T valor; public Caixa(T valor) { this.valor = valor; } public T getValor() { return valor; } }",
                                    "Compile com javac Caixa.java e teste instanciando: Caixa<String> c = new Caixa<>('teste');",
                                    "Adicione um método genérico bounded se possível: public <U extends Number> void process(U u) {}.",
                                    "Verifique erros de compilação relacionados a tipos inválidos."
                                  ],
                                  "verification": "Código compila sem warnings e instanciação Caixa<Integer> funciona sem erros em runtime.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE Java (IntelliJ ou Eclipse)",
                                    "JDK 8+",
                                    "Terminal para javac"
                                  ],
                                  "tips": "Use <> para diamond operator em Java 7+ para inferência de tipos.",
                                  "learningObjective": "Dominar a sintaxe Java para classes genéricas com campos e métodos básicos.",
                                  "commonMistakes": [
                                    "Esquecer 'public' ou '<T>' após o nome da classe",
                                    "Usar tipos primitivos diretamente (use wrappers)",
                                    "Acessar T em static contexts"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Declarar uma Classe Genérica Simples em C#",
                                  "subSteps": [
                                    "Crie um projeto Console App no Visual Studio.",
                                    "Escreva: public class Caixa<T> { private T valor; public Caixa(T valor) { this.valor = valor; } public T GetValor() { return valor; } }",
                                    "Instancie no Main: Caixa<string> c = new('teste'); Console.WriteLine(c.GetValor());",
                                    "Adicione constraints: where T : class, new() para novos objetos.",
                                    "Build o projeto e execute para verificar type-safety."
                                  ],
                                  "verification": "Projeto builda sem erros e output correto ao rodar.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Visual Studio Community",
                                    ".NET SDK",
                                    "Projeto Console App"
                                  ],
                                  "tips": "C# preserva informações de genéricos em runtime, permitindo reflection avançada.",
                                  "learningObjective": "Implementar sintaxe C# para genéricos, incluindo constraints opcionais.",
                                  "commonMistakes": [
                                    "Usar 'class' sem 'where' para constraints",
                                    "Confundir case-sensitivity em propriedades",
                                    "Ignorar nullability em C# 8+"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Declarar uma Classe Genérica Simples em C++",
                                  "subSteps": [
                                    "Crie um arquivo .cpp com g++ ou IDE como CLion.",
                                    "Escreva: template<typename T> class Caixa { private: T valor; public: Caixa(T v) : valor(v) {} T getValor() { return valor; } };",
                                    "Instancie no main: Caixa<int> c(42); cout << c.getValor();",
                                    "Adicione template parameters múltiplos: template<typename T, typename U> class Par {}.",
                                    "Compile com g++ -std=c++11 arquivo.cpp e execute."
                                  ],
                                  "verification": "Executável roda sem erros de link ou runtime crashes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "g++ compiler",
                                    "IDE como CLion ou VS Code com C++ extension",
                                    "iostream header"
                                  ],
                                  "tips": "Use typename em template<typename T> para diferenciar de static.",
                                  "learningObjective": "Aplicar templates C++ para classes genéricas com construtores e acesso.",
                                  "commonMistakes": [
                                    "Esquecer template<> em especializações",
                                    "Usar T em non-template functions sem qualificadores",
                                    "Problemas com tipos não-default-constructible"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Comparar Implementações Genéricas",
                                  "subSteps": [
                                    "Crie um programa unificado testando Caixa<T> em cada linguagem com mesmo tipo (ex: String/int).",
                                    "Compare código-fonte: destaque similaridades ( <T> ) e diferenças (where vs template).",
                                    "Teste erros intencionais: passe tipo inválido e observe mensagens de compilador.",
                                    "Documente em um README as diferenças chave (erasure, reification, instantiation).",
                                    "Refatore para adicionar um método comum como toString/print."
                                  ],
                                  "verification": "Todos os três códigos compilam/executam corretamente com testes idênticos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Todos os ambientes das steps anteriores",
                                    "Git para versionar códigos"
                                  ],
                                  "tips": "Use diff tools para comparar snippets entre linguagens.",
                                  "learningObjective": "Consolidar conhecimento comparando genéricos cross-language.",
                                  "commonMistakes": [
                                    "Não testar com múltiplos tipos",
                                    "Ignorar warnings de compiler",
                                    "Confundir sintaxes entre linguagens"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe Caixa<T> em Java/C#/C++ que armazene um valor genérico e forneça getValor(). Teste com Caixa<String> c = new Caixa<>(\"Olá Genéricos!\"); System.out.println(c.getValor()); (equivalente nas outras linguagens). Isso simula uma wrapper genérica como em bibliotecas padrão.",
                              "finalVerifications": [
                                "Código Java compila e roda sem ClassCastException.",
                                "C# build sem erros e type-safety em IntelliSense.",
                                "C++ compila com c++11+ e sem linker errors.",
                                "Todas instâncias respeitam tipos (não aceitam int em String box).",
                                "Métodos acessam corretamente o valor genérico.",
                                "Documentação pessoal compara as três sintaxes."
                              ],
                              "assessmentCriteria": [
                                "Correção sintática: <T> ou template<typename T> usado adequadamente (40%).",
                                "Funcionalidade: Construtor e getter funcionam com múltiplos tipos (30%).",
                                "Type-safety: Compiler rejeita usos inválidos (15%).",
                                "Clareza: Código limpo com comentários (10%).",
                                "Comparação: Notas sobre diferenças linguísticas (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstrações paramétricas semelhantes a funções genéricas.",
                                "Design de Software: Princípios SOLID (reusabilidade via genéricos).",
                                "Algoritmos: Genéricos em estruturas como árvores/binárias balanceadas.",
                                "Lógica: Raciocínio deductivo em constraints/bounds."
                              ],
                              "realWorldApplication": "Genéricos são fundamentais em bibliotecas como Java Collections (ArrayList<T>), .NET LINQ (List<T>), e STL C++ (vector<T>), permitindo código reutilizável em apps empresariais, jogos e sistemas embedded sem duplicação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.3.2.2",
                            "name": "Instanciar classes genéricas com tipos específicos",
                            "description": "Criar instâncias como 'Caixa<String> caixa = new Caixa<>();' e demonstrar type safety ao inserir e recuperar valores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir uma Classe Genérica Simples como Base",
                                  "subSteps": [
                                    "Crie uma classe pública chamada 'Caixa' com um parâmetro de tipo genérico 'T'.",
                                    "Adicione um campo privado 'T conteudo' para armazenar o item.",
                                    "Implemente um construtor vazio.",
                                    "Adicione métodos 'setConteudo(T item)' e 'getConteudo()' para inserir e recuperar valores.",
                                    "Compile a classe para garantir que não há erros de sintaxe."
                                  ],
                                  "verification": "A classe compila sem erros e pode ser usada em outro arquivo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE Java (IntelliJ ou Eclipse)",
                                    "JDK 8 ou superior"
                                  ],
                                  "tips": "Use convenções de nomenclatura claras para o tipo genérico, como 'T' para 'Type'. Evite campos públicos para encapsulamento.",
                                  "learningObjective": "Compreender a estrutura básica de uma classe genérica e seus componentes essenciais.",
                                  "commonMistakes": [
                                    "Esquecer o '<T>' na declaração da classe.",
                                    "Tornar o campo 'conteudo' público.",
                                    "Não importar java.util se necessário."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Instanciar a Classe Genérica com Tipo Específico",
                                  "subSteps": [
                                    "No método main de uma classe de teste, declare uma variável: 'Caixa<String> caixaString = new Caixa<>();'.",
                                    "Repita para outro tipo: 'Caixa<Integer> caixaInt = new Caixa<>();'.",
                                    "Note o uso do 'diamond operator' ('<>') para inferência de tipo.",
                                    "Compile e execute para verificar instanciação bem-sucedida.",
                                    "Adicione prints para confirmar que as instâncias foram criadas."
                                  ],
                                  "verification": "Código compila sem warnings de tipo e imprime confirmações de instanciação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Mesma IDE e JDK do passo anterior",
                                    "Arquivo de teste Main.java"
                                  ],
                                  "tips": "Sempre especifique o tipo à esquerda para clareza; o diamond à direita economiza código em Java 7+.",
                                  "learningObjective": "Dominar a sintaxe de instanciamento de genéricos com tipos concretos e inferência.",
                                  "commonMistakes": [
                                    "Usar raw types como 'new Caixa()' sem '<>' ou tipo.",
                                    "Especificar tipo duplicado como 'new Caixa<String>()' (legado).",
                                    "Confundir com não-genéricos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inserir e Recuperar Valores com Type Safety",
                                  "subSteps": [
                                    "Use 'caixaString.setConteudo(\"Olá Genéricos\");'.",
                                    "Recupere com 'String valor = caixaString.getConteudo();' e imprima.",
                                    "Repita para 'caixaInt.setConteudo(42);' e recupere como Integer.",
                                    "Tente inserir tipo errado (ex: int em String) e observe erro de compilação.",
                                    "Execute e verifique saídas corretas sem casts."
                                  ],
                                  "verification": "Programa executa corretamente, tipos são preservados em runtime sem erros ou casts.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código do passo anterior expandido"
                                  ],
                                  "tips": "Type safety previne erros em compile-time; teste intencionalmente violações para aprender.",
                                  "learningObjective": "Aplicar operações em instâncias genéricas e verificar segurança de tipos.",
                                  "commonMistakes": [
                                    "Ignorar warnings de unchecked types.",
                                    "Fazer cast manual desnecessário.",
                                    "Usar tipos primitivos diretamente (use wrappers como Integer)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar Benefícios e Comparar com Raw Types",
                                  "subSteps": [
                                    "Crie uma 'Caixa' raw: 'Caixa caixaRaw = new Caixa();' e insira misto (String e Integer).",
                                    "Recupere e faça cast, observando warnings.",
                                    "Compare erros: genérico vs raw.",
                                    "Refatore raw para genérico e elimine warnings.",
                                    "Documente diferenças em comentários."
                                  ],
                                  "verification": "Código genérico compila limpo; raw gera warnings comprovados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código expandido com seções raw e genérica"
                                  ],
                                  "tips": "Compile com '-Xlint:unchecked' para ver warnings explicitamente.",
                                  "learningObjective": "Contrastar genéricos com raw types para apreciar type safety.",
                                  "commonMistakes": [
                                    "Não perceber warnings como erros.",
                                    "Misturar tipos em raw sem casts.",
                                    "Esquecer importações."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie Caixa<String> nomes = new Caixa<>(); nomes.setConteudo(\"João\"); String nome = nomes.getConteudo(); System.out.println(nome.toUpperCase()); // Compila e roda: JOÃO. Tente nomes.setConteudo(123); // Erro de compilação!",
                              "finalVerifications": [
                                "Código com genéricos compila sem warnings de tipo.",
                                "Inserção de tipo incompatível gera erro de compilação.",
                                "Recuperação de valor preserva tipo original sem cast.",
                                "Diamond operator é usado corretamente em todas instâncias.",
                                "Comparação com raw types destaca warnings ausentes em genéricos.",
                                "Programa executa e produz saídas esperadas para múltiplos tipos."
                              ],
                              "assessmentCriteria": [
                                "Correta sintaxe de declaração e instanciamento genérico (100%).",
                                "Demonstração explícita de type safety via tentativas falhas (obrigatório).",
                                "Uso apropriado de diamond operator sem duplicação de tipos.",
                                "Código limpo, compilável e executável sem runtime errors.",
                                "Explicação escrita das diferenças raw vs genérico.",
                                "Eficiência: tempo de execução e legibilidade do código."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstrações paramétricas semelhantes a funções genéricas.",
                                "Lógica: Verificação de tipos como validação de premissas.",
                                "Banco de Dados: Tipagem forte em schemas relacionais.",
                                "Design de Software: Padrões como Template Method."
                              ],
                              "realWorldApplication": "Em bibliotecas Java como ArrayList<String> ou HashMap<String, Integer>, garante type safety em apps empresariais, prevenindo erros como NumberFormatException em coleções mistas, comum em processamento de dados e APIs REST."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.3.2.3",
                            "name": "Aplicar bounds em parâmetros genéricos",
                            "description": "Usar extends/super para restringir tipos, como 'class Comparavel<T extends Comparable<T>>', garantindo compatibilidade com interfaces em linguagens OO.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de bounds em parâmetros genéricos",
                                  "subSteps": [
                                    "Estude a definição de bounds: restrições em type parameters para garantir que implementem interfaces ou estendam classes específicas.",
                                    "Analise exemplos básicos de genéricos sem bounds e identifique limitações, como incapacidade de chamar métodos de interfaces não garantidas.",
                                    "Revise interfaces comuns como Comparable<T> em Java, focando em seu papel para ordenação.",
                                    "Compare genéricos ilimitados vs. bounded, notando benefícios como type safety e acesso a métodos.",
                                    "Leia documentação oficial (Java Generics Tutorial) sobre <? extends T> e <? super T>."
                                  ],
                                  "verification": "Explique em suas palavras o que são upper bounds e lower bounds, com um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Java Generics (Oracle Docs)",
                                    "IDE como IntelliJ ou Eclipse",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use diagramas de herança para visualizar restrições de tipo.",
                                  "learningObjective": "Entender o propósito e benefícios de bounds para type safety em genéricos.",
                                  "commonMistakes": [
                                    "Confundir extends com implements",
                                    "Ignorar recursividade em bounds como T extends Comparable<T>"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar a sintaxe de upper bounds com extends",
                                  "subSteps": [
                                    "Escreva a sintaxe básica: <T extends Interface> ou <T extends Classe>.",
                                    "Pratique com exemplo: class Caixa<T extends Number> { } e teste com Integer e String.",
                                    "Implemente bound recursivo: class Comparavel<T extends Comparable<T>>.",
                                    "Explore wildcards: List<? extends Number> e teste atribuições.",
                                    "Compile códigos de teste para observar erros de tipo."
                                  ],
                                  "verification": "Crie um snippet que compila apenas com tipos que estendem Comparable.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador Java (JDK 8+)",
                                    "Online Java Compiler (Repl.it)",
                                    "Exemplos de código de genéricos"
                                  ],
                                  "tips": "Sempre teste com tipos inválidos para ver erros de compilação.",
                                  "learningObjective": "Aplicar corretamente a sintaxe de upper bounds em declarações de classes genéricas.",
                                  "commonMistakes": [
                                    "Usar 'implements' em vez de 'extends' para interfaces",
                                    "Esquecer o tipo recursivo em Comparable<T>"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar lower bounds com super e classes completas",
                                  "subSteps": [
                                    "Estude sintaxe de lower bounds: <T super Tipo> para flexibilidade em Producers.",
                                    "Crie classe com múltiplos bounds: <T extends Comparable<T> & Serializable>.",
                                    "Desenvolva uma classe utilitária como Max<T extends Comparable<T>> com método compareTo.",
                                    "Integre em estrutura de dados, como uma lista genérica ordenada.",
                                    "Teste herança: subclasse que herda a genérica bounded."
                                  ],
                                  "verification": "Implemente e execute Max.max(5, 10) retornando 10, falhando com String.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "JDK instalado",
                                    "JUnit para testes unitários",
                                    "Referência API Comparable"
                                  ],
                                  "tips": "Comece com bounds simples antes de múltiplos.",
                                  "learningObjective": "Construir classes genéricas com bounds upper e lower para cenários reais.",
                                  "commonMistakes": [
                                    "Confundir producer/consumer: extends para leitura, super para escrita",
                                    "Bounds cíclicos incorretos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar compatibilidade e refatorar código",
                                  "subSteps": [
                                    "Crie testes unitários verificando type safety com bounds.",
                                    "Refatore código legado adicionando bounds para melhorar segurança.",
                                    "Analise warnings de compilador e corrija com @SuppressWarnings se necessário.",
                                    "Compare performance e legibilidade com/ sem bounds.",
                                    "Documente o código com Javadoc explicando os bounds."
                                  ],
                                  "verification": "Execute suíte de testes: passa com tipos válidos, falha em compilação com inválidos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "JUnit 5",
                                    "IDE com debugger",
                                    "Exemplos de repositórios GitHub de genéricos"
                                  ],
                                  "tips": "Use generics erasure para entender limitações em runtime.",
                                  "learningObjective": "Validar e otimizar genéricos bounded em aplicações práticas.",
                                  "commonMistakes": [
                                    "Ignorar type erasure levando a erros runtime",
                                    "Overuse de raw types"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie a classe Max<T extends Comparable<T>> com método static T max(T a, T b) { return a.compareTo(b) > 0 ? a : b; }. Teste com Integer e Double (funciona), String (funciona), mas falhe ao tentar com custom class sem Comparable.",
                              "finalVerifications": [
                                "Código compila sem erros de tipo para classes que atendem bounds.",
                                "Tentativa de usar tipo incompatível gera erro de compilação.",
                                "Métodos de interface bounded (ex: compareTo) são acessíveis sem cast.",
                                "Testes unitários passam para múltiplos tipos válidos.",
                                "Documentação explica restrições de tipo.",
                                "Nenhum warning de unchecked generics."
                              ],
                              "assessmentCriteria": [
                                "Correta sintaxe de extends/super em todos parâmetros genéricos.",
                                "Uso efetivo de bounds para type safety demonstrado em testes.",
                                "Exemplo prático funcional e testado.",
                                "Explicação clara de benefícios vs. genéricos ilimitados.",
                                "Tratamento de erros comuns evitado.",
                                "Integração coerente com interfaces OO padrão."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Relações de ordem e partial orders (Comparable como <=).",
                                "Algoritmos: Pré-requisito para sorting genérico (ex: Collections.sort).",
                                "Design de Software: Princípios SOLID (Dependency Inversion via bounds).",
                                "Banco de Dados: Genéricos em ORMs para queries tipadas.",
                                "Segurança: Type safety previne injeções de tipo inválido."
                              ],
                              "realWorldApplication": "Em frameworks como Spring Data (repositories genéricos <T extends Entity>), bibliotecas de sorting (TreeSet<T extends Comparable>), e APIs financeiras para comparações seguras de valores monetários genéricos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.3",
                        "name": "Sintaxe de Métodos Genéricos",
                        "description": "Definição de métodos parametrizados por tipos independentes da classe, incluindo genéricos em classes não genéricas e múltiplos parâmetros.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.3.1",
                            "name": "Declarar método genérico em classe não genérica",
                            "description": "Escrever método como 'public static <T> T max(T a, T b)' em Java, demonstrando inferência de tipo e uso em contextos OO.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos de tipos genéricos em Java",
                                  "subSteps": [
                                    "Leia a documentação oficial do Java sobre genéricos (Trail: Generics).",
                                    "Identifique a diferença entre classe genérica e método genérico.",
                                    "Estude exemplos de inferência de tipo em métodos genéricos.",
                                    "Anote restrições comuns como extends Comparable<T>.",
                                    "Compile um exemplo simples de método genérico para observar erros."
                                  ],
                                  "verification": "Responda corretamente a 5 perguntas sobre diferenças entre genéricos em classes vs métodos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "JDK 8+, IDE como IntelliJ ou Eclipse",
                                    "Documentação Oracle Java Generics"
                                  ],
                                  "tips": "Foquem em '<T>' como placeholder para qualquer tipo; inferência ocorre no momento da chamada.",
                                  "learningObjective": "Compreender quando e por que usar métodos genéricos em classes não genéricas.",
                                  "commonMistakes": [
                                    "Confundir com classes genéricas",
                                    "Esquecer de declarar <T> antes do tipo de retorno",
                                    "Ignorar bounds como Comparable"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar a assinatura do método genérico",
                                  "subSteps": [
                                    "Crie uma classe não genérica, ex: public class Utilitarios {}.",
                                    "Adicione modificadores: public static <T> dentro da classe.",
                                    "Defina o tipo de retorno T e parâmetros T a, T b.",
                                    "Adicione bound: <T extends Comparable<T>> para permitir comparações.",
                                    "Salve e compile para verificar sintaxe."
                                  ],
                                  "verification": "O código compila sem erros de sintaxe na assinatura.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "IDE com autocompletar",
                                    "Exemplo de código base"
                                  ],
                                  "tips": "Coloque <T> logo após os modificadores static, antes do tipo de retorno.",
                                  "learningObjective": "Escrever corretamente a assinatura de um método genérico estático.",
                                  "commonMistakes": [
                                    "Colocar <T> nos parâmetros em vez da declaração",
                                    "Esquecer 'static' para método utilitário",
                                    "Não usar bound para comparações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a lógica do método max",
                                  "subSteps": [
                                    "No corpo do método, use if (a.compareTo(b) > 0) return a; else return b;.",
                                    "Trate exceções potenciais se não usar Comparable.",
                                    "Adicione comentários explicando inferência de tipo.",
                                    "Teste compilação com chamadas mock.",
                                    "Refatore para lidar com nulls opcionalmente."
                                  ],
                                  "verification": "Método retorna o maior valor em testes manuais simulados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Classe Utilitarios.java",
                                    "JUnit para testes unitários opcionais"
                                  ],
                                  "tips": "Sempre use compareTo de Comparable para genéricos seguros.",
                                  "learningObjective": "Implementar funcionalidade reutilizável com genéricos.",
                                  "commonMistakes": [
                                    "Usar == ou > diretamente em T (não primitivos)",
                                    "Retornar Object em vez de T",
                                    "Ignorar casos de igualdade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e demonstrar inferência de tipo",
                                  "subSteps": [
                                    "Crie main() chamando max(5, 3) e max(\"Z\", \"A\").",
                                    "Observe que o compilador infere Integer e String automaticamente.",
                                    "Use System.out.println para verificar resultados.",
                                    "Teste com tipos customizados que implementem Comparable.",
                                    "Analise warnings ou erros de tipo para depuração."
                                  ],
                                  "verification": "Chamadas compilam e executam corretamente com inferência automática.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Main class para testes",
                                    "Tipos como String e Integer"
                                  ],
                                  "tips": "Evite casts explícitos; genéricos eliminam necessidade.",
                                  "learningObjective": "Verificar uso prático e inferência em contextos OO.",
                                  "commonMistakes": [
                                    "Forçar casts manuais",
                                    "Não testar múltiplos tipos",
                                    "Esquecer import java.lang.Comparable"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma classe Utilitarios não genérica:\npublic static <T extends Comparable<T>> T max(T a, T b) {\n    return a.compareTo(b) > 0 ? a : b;\n}\nUso: String maior = Utilitarios.max(\"abc\", \"def\"); // Infere String",
                              "finalVerifications": [
                                "Método compila sem erros de tipo.",
                                "Inferência funciona para pelo menos 3 tipos diferentes (int, String, custom).",
                                "Retorna valor correto em testes com compareTo.",
                                "Nenhum cast explícito necessário nas chamadas.",
                                "Bound Comparable<T> é usado corretamente.",
                                "Executa sem NullPointerException em casos básicos."
                              ],
                              "assessmentCriteria": [
                                "Assinatura exata: public static <T extends Comparable<T>> T max(T a, T b).",
                                "Lógica usa compareTo corretamente sem comparações inválidas.",
                                "Demonstração de inferência sem parâmetros de tipo explícitos.",
                                "Integração em classe OO não genérica.",
                                "Tratamento de edge cases como a.equals(b).",
                                "Código limpo com comentários."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de ordem total e funções máximas genéricas.",
                                "Algoritmos: Reutilização de padrões como max em estruturas de dados.",
                                "Design de Software: Princípios de abstração e polimorfismo paramétrico.",
                                "Lógica Computacional: Inferência de tipos e type safety.",
                                "Engenharia de Software: Desenvolvimento de utilitários reutilizáveis."
                              ],
                              "realWorldApplication": "Usado em bibliotecas como Collections.max() ou Apache Commons Lang para funções utilitárias genéricas, permitindo comparações seguras em APIs de sorting, validação de dados e processamento de coleções heterogêneas em aplicações empresariais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.3.3.2",
                            "name": "Usar métodos genéricos em classes genéricas",
                            "description": "Implementar método genérico dentro de classe genérica, como 'public <U> void copia(Caixa<U> origem)', explorando relações entre parâmetros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Classes Genéricas",
                                  "subSteps": [
                                    "Defina uma classe genérica simples, como 'public class Caixa<T> { private T conteudo; ... }'.",
                                    "Implemente construtores e métodos getter/setter para o tipo genérico T.",
                                    "Crie instâncias com tipos concretos, como Caixa<String> e Caixa<Integer>, e demonstre seu uso.",
                                    "Explore limitações: explique por que não é possível atribuir Caixa<String> a Caixa<Object>.",
                                    "Discuta covariância e contravariância em genéricos."
                                  ],
                                  "verification": "Compilar e executar código com instâncias de Caixa<T> sem erros, imprimindo conteúdos corretos.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "IDE como IntelliJ ou Eclipse",
                                    "Documentação Java Generics (Oracle Docs)"
                                  ],
                                  "tips": [
                                    "Use System.out.println para depuração rápida.",
                                    "Sempre especifique o tipo ao instanciar para evitar warnings."
                                  ],
                                  "learningObjective": "Compreender a declaração e uso básico de classes parametrizadas por tipo.",
                                  "commonMistakes": [
                                    "Esquecer o tipo genérico nos construtores.",
                                    "Tentar usar tipos primitivos diretamente (use wrappers como Integer)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Sintaxe de Métodos Genéricos em Classes Genéricas",
                                  "subSteps": [
                                    "Analise a sintaxe: 'public <U> void copia(Caixa<U> origem)' dentro de classe Caixa<T>.",
                                    "Explique diferenças: U é um novo parâmetro de tipo, independente de T.",
                                    "Estude type inference: como o compilador infere U do argumento origem.",
                                    "Compare com métodos não-genéricos: por que genéricos permitem flexibilidade?",
                                    "Declare múltiplos parâmetros de tipo, como <U, V>, e discuta bounds (extends)."
                                  ],
                                  "verification": "Escreva pseudocódigo comentado explicando a sintaxe e relações entre T e U.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Referência Java Language Specification - Generics",
                                    "Exemplos de código de tutoriais como Baeldung"
                                  ],
                                  "tips": [
                                    "Lembre-se: <U> declara o tipo antes do tipo de retorno.",
                                    "Teste type erasure mentalmente para entender limites em runtime."
                                  ],
                                  "learningObjective": "Dominar a sintaxe e semântica de métodos genéricos aninhados em classes genéricas.",
                                  "commonMistakes": [
                                    "Confundir T da classe com U do método.",
                                    "Omitir <U> antes do modificador de acesso."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Método Genérico 'copia'",
                                  "subSteps": [
                                    "Adicione o método 'public <U> void copia(Caixa<U> origem)' à classe Caixa<T>.",
                                    "Implemente a lógica: this.conteudo = origem.getConteudo(); (com cast se necessário, mas evite).",
                                    "Ajuste para compatibilidade: discuta se U deve se relacionar com T (ex: <U extends T>).",
                                    "Crie um método de teste: Caixa<String> c1 = new Caixa<>(\"teste\"); Caixa<String> c2 = new Caixa<>(); c2.copia(c1);",
                                    "Teste com tipos diferentes: copie de Caixa<Integer> para Caixa<Object> se bound permitir."
                                  ],
                                  "verification": "Executar testes unitários onde copia transfere conteúdo corretamente sem erros de tipo.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "JUnit para testes",
                                    "Classe Caixa<T> pré-definida"
                                  ],
                                  "tips": [
                                    "Use @SuppressWarnings(\"unchecked\") apenas se inevitável.",
                                    "Sempre priorize segurança de tipo sobre casts."
                                  ],
                                  "learningObjective": "Implementar funcionalidade genérica flexível explorando relações paramétricas.",
                                  "commonMistakes": [
                                    "Cast explícito desnecessário levando a ClassCastException.",
                                    "Ignorar bounds, causando erros de compilação."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Explorar Relações entre Parâmetros",
                                  "subSteps": [
                                    "Crie cenários: copie entre Caixas de tipos relacionados (String extends Object).",
                                    "Experimente bounds: mude para '<U super T> void copia(Caixa<U> origem)' e teste PECS.",
                                    "Analise erros comuns: tente copier tipos incompatíveis e corrija com wildcards (? extends T).",
                                    "Meça performance: compare com métodos não-genéricos em loops.",
                                    "Refatore: adicione overloads ou defaults para maior usabilidade."
                                  ],
                                  "verification": "Relatório de testes mostrando sucessos/falhas em 5 cenários diferentes, com código funcional.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Ferramentas de profiling como VisualVM",
                                    "Exemplos avançados de Effective Java (Item 26)"
                                  ],
                                  "tips": [
                                    "Use wildcards quando genéricos puros falham.",
                                    "Documente bounds nos Javadocs."
                                  ],
                                  "learningObjective": "Explorar e debugar interações complexas entre parâmetros genéricos.",
                                  "commonMistakes": [
                                    "Violar hierarquia de tipos sem bounds apropriados.",
                                    "Confundir super/extends em contravariância."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma classe Caixa<T>, implemente public <U> void copia(Caixa<U> origem) { this.conteudo = origem.getConteudo(); }. Teste: Caixa<Integer> orig = new Caixa<>(42); Caixa<Object> dest = new Caixa<>(); dest.copia(orig); // Funciona se U compatível com T via bounds.",
                              "finalVerifications": [
                                "Compilar código sem warnings de genéricos.",
                                "Executar testes com tipos primitivos/wrappers e objetos customizados.",
                                "Verificar type safety: tentativas inválidas falham em compile-time.",
                                "Demonstrar cópia entre tipos relacionados (ex: Number para Integer).",
                                "Explicar verbalmente relações T/U e type erasure.",
                                "Refatorar método com bounds e testar diferenças."
                              ],
                              "assessmentCriteria": [
                                "Correção sintática: <U> posicionado corretamente.",
                                "Segurança de tipo: sem casts inseguros ou warnings.",
                                "Flexibilidade: método funciona com múltiplos tipos via parâmetros independentes.",
                                "Testes abrangentes: cobertura de cenários positivos/negativos.",
                                "Documentação: comentários explicando bounds e relações.",
                                "Eficiência: sem overhead desnecessário em runtime."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstrações paramétricas semelhantes a funções genéricas em teoria de categorias.",
                                "Design de Software: Padrões como Template Method com genéricos.",
                                "Algoritmos: Genéricos em estruturas como List<T> para sorting genérico.",
                                "Lógica: Inferência de tipos como em lambdas/prolog.",
                                "Banco de Dados: Tipos genéricos em ORMs como Hibernate entities."
                              ],
                              "realWorldApplication": "Bibliotecas como Java Collections (ArrayList<T>.addAll(Collection<? extends T>)) usam isso para operações flexíveis e type-safe em frameworks empresariais, APIs REST genéricas e processadores de dados em big data (ex: Stream<T> em Java Streams)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.2.1",
                              "10.1.6.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.3.3.3",
                            "name": "Aplicar wildcards em métodos genéricos",
                            "description": "Utilizar '? extends T' ou '? super T' em assinaturas de métodos para flexibilidade, como em coleções genéricas para operações de leitura/escrita.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos de Wildcards em Generics",
                                  "subSteps": [
                                    "Estude a sintaxe de wildcards: '?' sozinho, '? extends T' (upper bounded wildcard) e '? super T' (lower bounded wildcard).",
                                    "Aprenda o princípio PECS (Producer Extends, Consumer Super): use 'extends' para produtores (leitura) e 'super' para consumidores (escrita).",
                                    "Revise exemplos simples de coleções: List<? extends Number> permite leitura mas não escrita de elementos específicos.",
                                    "Compare com tipos genéricos sem wildcards para entender a flexibilidade ganha.",
                                    "Leia a documentação oficial da Oracle sobre wildcards em generics."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre '? extends T' e '? super T' e forneça um exemplo de uso inadequado que causa erro de compilação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação Java Generics (Oracle), IDE como IntelliJ ou Eclipse, um caderno para anotações.",
                                  "tips": "Desenhe diagramas de herança para visualizar bounds (ex: Number -> Integer -> List<Integer>).",
                                  "learningObjective": "Compreender quando e por que usar wildcards para aumentar a flexibilidade de métodos genéricos.",
                                  "commonMistakes": "Confundir 'extends' com herança direta (é bound, não substituição); tentar escrever em listas com '? extends T'."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Métodos com Upper Bounded Wildcard (? extends T)",
                                  "subSteps": [
                                    "Crie uma classe Animal com subclasses Dog e Cat.",
                                    "Escreva um método genérico printAnimals(List<? extends Animal> list) que itera e imprime nomes.",
                                    "Teste chamando com List<Dog>, List<Cat> e List<Animal> para verificar flexibilidade.",
                                    "Tente adicionar elementos à lista dentro do método e observe o erro de compilação.",
                                    "Refatore para demonstrar leitura segura (producer)."
                                  ],
                                  "verification": "O método compila e executa corretamente com subtipos diferentes de Animal, mas falha ao tentar escrever.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "IDE Java com JDK 8+, exemplos de código em um repositório Git local.",
                                  "tips": "Use System.out.println para testes rápidos; compile com javac para ver erros de tipo explicitamente.",
                                  "learningObjective": "Aplicar '? extends T' em métodos para operações de leitura em coleções heterogêneas.",
                                  "commonMistakes": "Esquecer o wildcard, resultando em métodos rígidos; ignorar que escrita não é permitida."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Métodos com Lower Bounded Wildcard (? super T)",
                                  "subSteps": [
                                    "Crie um método copyList(List<? super Integer> dest, List<Integer> src) similar ao Collections.copy.",
                                    "Teste adicionando Integers e subclasses (ex: List<Number> como destino).",
                                    "Experimente ler elementos específicos do destino e observe limitações.",
                                    "Compare com versão sem wildcard para ver a restrição de tipo.",
                                    "Implemente um método addNumbers(List<? super Number> list, Number... nums)."
                                  ],
                                  "verification": "O método permite escrever elementos de T em destinos supertipos, mas não lê tipos específicos com segurança.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "IDE, JUnit para testes unitários, código fonte de Collections.copy como referência.",
                                  "tips": "Pense em 'super' como 'aceita supertipos maiores'; use varargs para flexibilidade.",
                                  "learningObjective": "Usar '? super T' para operações de escrita em coleções que aceitam supertipos.",
                                  "commonMistakes": "Tentar ler e castear elementos do destino; confundir ordem de parâmetros."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar Wildcards em Cenários Práticos e Refatorar Código",
                                  "subSteps": [
                                    "Crie uma classe utilitária com métodos mistos: um para somar elementos (extends Number), outro para popular lista (super Comparable).",
                                    "Refatore código existente sem wildcards para usar wildcards e meça a melhoria em reutilização.",
                                    "Teste edge cases: listas vazias, nulls, tipos primitivos wrapper.",
                                    "Adicione Javadoc explicando escolhas de wildcards.",
                                    "Execute testes com diferentes hierarquias de classes."
                                  ],
                                  "verification": "Código refatorado compila, passa em testes e é mais flexível que a versão original.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "JUnit 5, Git para versionamento, exemplos de bibliotecas como Apache Commons.",
                                  "tips": "Use @SafeVarargs para métodos varargs; priorize imutabilidade onde possível.",
                                  "learningObjective": "Integrar wildcards em métodos genéricos reais para máxima flexibilidade.",
                                  "commonMistakes": "Overusing wildcards desnecessariamente; ignorar captura de wildcard em inferência de tipo."
                                }
                              ],
                              "practicalExample": "Em um sistema de zoológico, crie um método feedAnimals(List<? super Animal> hungryAnimals, List<? extends Food> availableFood) que alimenta animais com comida compatível, permitindo List<Mammal> como hungryAnimals e List<Meat> como availableFood.",
                              "finalVerifications": [
                                "Compilar e executar métodos com wildcards sem warnings de tipo.",
                                "Chamar métodos com subtipos e supertipos corretamente sem casts.",
                                "Identificar e corrigir erros de compilação relacionados a bounds errados.",
                                "Explicar PECS em um exemplo dado.",
                                "Refatorar um método genérico simples para usar wildcards adequadamente.",
                                "Passar em testes unitários cobrindo leitura/escrita com diferentes bounds."
                              ],
                              "assessmentCriteria": [
                                "Correta aplicação de '? extends T' para cenários de leitura (sem erros de compilação).",
                                "Uso preciso de '? super T' para escrita em supertipos.",
                                "Flexibilidade demonstrada: métodos aceitam múltiplos tipos relacionados.",
                                "Código limpo com Javadoc e sem warnings unchecked.",
                                "Compreensão conceitual via explicação ou quiz sobre PECS.",
                                "Eficiência: refatoração melhora reutilização sem perda de segurança de tipo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos e subconjuntos (análoga a bounds).",
                                "Design de Software: Princípios SOLID (Liskov Substitution com generics).",
                                "Algoritmos: Otimização de coleções em estruturas de dados.",
                                "Lógica Computacional: Inferência de tipos e polimorfismo paramétrico."
                              ],
                              "realWorldApplication": "Bibliotecas padrão Java como Collections.max/min usam '? extends Comparable' para máxima entrada; frameworks como Spring usam wildcards em repositórios genéricos para operações CRUD flexíveis em heranças de entidades."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.4",
                    "name": "Aplicação de Genéricos em Estruturas de Dados",
                    "description": "Uso de tipos genéricos para criar coleções flexíveis e seguras em estruturas OO como listas e mapas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.4.1",
                        "name": "Genéricos em Listas",
                        "description": "Aplicação de tipos genéricos em estruturas de listas para garantir flexibilidade e segurança de tipos em coleções orientadas a objetos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.1.1",
                            "name": "Declarar uma lista genérica",
                            "description": "Criar e declarar uma lista genérica utilizando sintaxe de genéricos, como List<T> em Java ou List[T] em Python com typing, especificando o tipo de elemento para evitar erros em tempo de compilação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito e Propósito dos Genéricos em Listas",
                                  "subSteps": [
                                    "Estude a definição de genéricos: mecanismos que permitem tipagem parametrizada em estruturas de dados.",
                                    "Compare listas não-genéricas (raw types) com genéricas: identifique riscos como erros em tempo de execução.",
                                    "Analise exemplos de problemas sem genéricos, como misturar tipos em uma lista.",
                                    "Revise documentação oficial: Java Collections Framework e Python typing module.",
                                    "Discuta benefícios: segurança de tipo, legibilidade e detecção precoce de erros."
                                  ],
                                  "verification": "Resuma em 3 pontos os benefícios dos genéricos e liste 2 riscos de listas não-tipadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Java: oracle.com/java/technologies/javase/generics",
                                    "Python typing: docs.python.org/3/library/typing.html",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Pense em genéricos como 'molde' para tipos, evitando surpresas em runtime.",
                                  "learningObjective": "Entender por que genéricos são essenciais para listas seguras e tipadas.",
                                  "commonMistakes": [
                                    "Confundir genéricos com herança; ignorar que genéricos evitam casts manuais."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender Sintaxe de Declaração em Java (List<T>)",
                                  "subSteps": [
                                    "Importe as classes necessárias: import java.util.List; import java.util.ArrayList;",
                                    "Declare uma lista genérica: List<String> nomes = new ArrayList<>();",
                                    "Experimente diferentes tipos: List<Integer> numeros = new ArrayList<>();",
                                    "Use o diamond operator (Java 7+): new ArrayList<>() para inferência de tipo.",
                                    "Teste declaração sem inicialização: List<Double> valores;"
                                  ],
                                  "verification": "Compile um código simples com List<String> e confirme ausência de warnings de raw types.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE como IntelliJ ou Eclipse",
                                    "Compilador Java JDK 8+"
                                  ],
                                  "tips": "Sempre especifique o tipo entre < > para parametrização; use <> para inferência.",
                                  "learningObjective": "Dominar a sintaxe exata List<T> em Java para declaração segura.",
                                  "commonMistakes": [
                                    "Esquecer importações; usar List em vez de ArrayList para inicialização; raw types como List sem <T>."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aprender Sintaxe de Declaração em Python (List[T] com typing)",
                                  "subSteps": [
                                    "Instale typing se necessário (Python 3.9+ tem built-in, mas use from typing import List para compatibilidade).",
                                    "Declare com anotação: from typing import List; nomes: List[str] = []",
                                    "Use tipos built-in: numeros: List[int] = []",
                                    "Entenda que é hint estático: mypy nomes: List[float] = [1.0, 'erro']  # Detecta erro.",
                                    "Compare com listas dinâmicas: sem typing, Python permite misturar tipos em runtime."
                                  ],
                                  "verification": "Execute mypy em um script com declaração List[str] e adicione item errado para ver erro.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "VS Code ou PyCharm",
                                    "mypy instalado: pip install mypy",
                                    "Python 3.8+"
                                  ],
                                  "tips": "Use List[str] em vez de list[str] para clareza; typing é para ferramentas estáticas como IDEs.",
                                  "learningObjective": "Aplicar anotações de tipo List[T] em Python para simular genéricos estáticos.",
                                  "commonMistakes": [
                                    "Esquecer from typing import List; usar aspas simples em vez de aspas duplas para str; ignorar que Python ignora em runtime."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Declaração, Inicialização e Verificação",
                                  "subSteps": [
                                    "Crie um programa Java declarando List<Employee> equipe = new ArrayList<>();",
                                    "Em Python: equipe: List[Employee] = [] (assumindo classe Employee).",
                                    "Inicialize com elementos tipados e tente adicionar tipo errado para ver erros.",
                                    "Compile/executar ambos e compare outputs/erros.",
                                    "Refatore código não-genérico para genérico e meça melhorias em legibilidade."
                                  ],
                                  "verification": "Código compila/executa sem erros de tipo e IDE destaca violações corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE com suporte a Java/Python",
                                    "Classes de exemplo como Employee"
                                  ],
                                  "tips": "Teste com IDE inspections para warnings instantâneos.",
                                  "learningObjective": "Declarar listas genéricas funcionais em ambas linguagens.",
                                  "commonMistakes": [
                                    "Inicializar com new ArrayList<T>() em vez de <>; misturar tipos em testes."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Explorar Boas Práticas e Casos Avançados",
                                  "subSteps": [
                                    "Aprenda wildcards em Java: List<? extends Number> para leitura.",
                                    "Use List[dict[str, Any]] em Python para estruturas complexas.",
                                    "Discuta bounded types: List<? extends Animal> em Java.",
                                    "Analise código open-source com genéricos (GitHub).",
                                    "Crie um checklist pessoal para declarações futuras."
                                  ],
                                  "verification": "Adapte um exemplo avançado e verifique compilação sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos GitHub: busca 'generics list java/python'",
                                    "Documentação avançada"
                                  ],
                                  "tips": "Prefira interfaces como List<T> sobre implementações como ArrayList<T>.",
                                  "learningObjective": "Aplicar genéricos de forma robusta e escalável.",
                                  "commonMistakes": [
                                    "Overuse de wildcards desnecessários; ignorar covariância/contravariância."
                                  ]
                                }
                              ],
                              "practicalExample": "Em Java: import java.util.*; public class Exemplo { public static void main(String[] args) { List<String> frutas = new ArrayList<>(); frutas.add(\"maçã\"); // OK frutas.add(123); // Erro de compilação! } } Em Python: from typing import List; frutas: List[str] = []; frutas.append(\"maçã\"); # OK, mas mypy detecta frutas.append(123).",
                              "finalVerifications": [
                                "Declaração usa sintaxe correta List<T> ou List[T] em ambos idiomas.",
                                "Compilação/execução sem warnings de raw types ou type mismatches.",
                                "IDE/mypy destaca erros ao tentar adicionar tipo incompatível.",
                                "Lista é inicializada corretamente com elementos tipados.",
                                "Código é legível e segue convenções de nomenclatura.",
                                "Teste unitário simples passa sem falhas de tipo."
                              ],
                              "assessmentCriteria": [
                                "Correção sintática: 100% uso de <T> ou [T].",
                                "Segurança de tipo: Detecta violações em compile-time/static check.",
                                "Clareza: Títulos de variáveis descritivos e tipos apropriados.",
                                "Versatilidade: Exemplos em Java e Python funcionais.",
                                "Boas práticas: Uso de interfaces, inferência e imports corretos.",
                                "Completude: Inclui inicialização e teste básico."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstrações paramétricas semelhantes a funções genéricas.",
                                "Lógica: Raciocínio sobre tipos e invariants para evitar erros.",
                                "Inglês Técnico: Leitura de docs oficiais em inglês.",
                                "Design de Software: Princípios SOLID (especialmente Dependency Inversion)."
                              ],
                              "realWorldApplication": "Em e-commerces, declarar List<Product> para carrinho de compras garante que apenas produtos sejam adicionados, evitando crashes; em apps de dados, List<User> para perfis sociais previne mistura de tipos e facilita queries tipadas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.2",
                            "name": "Adicionar e recuperar elementos em listas genéricas",
                            "description": "Implementar operações de inserção, remoção e acesso a elementos em uma lista genérica, demonstrando a verificação automática de tipos pelo compilador.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os conceitos básicos de genéricos em listas",
                                  "subSteps": [
                                    "Estude a sintaxe de genéricos em Java: <T> para tipos parametrizados.",
                                    "Revise diferenças entre listas raw (sem genéricos) e genéricas (ex: List<String>).",
                                    "Analise exemplos de código que demonstram verificação de tipos pelo compilador.",
                                    "Identifique benefícios: segurança de tipos em tempo de compilação e evitar casts.",
                                    "Pratique lendo documentação oficial da Oracle sobre ArrayList genérica."
                                  ],
                                  "verification": "Responda corretamente a 5 perguntas sobre genéricos em um quiz simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Java Generics",
                                    "IDE como IntelliJ ou Eclipse",
                                    "Exemplos de código em ArrayList"
                                  ],
                                  "tips": "Sempre use <T> para representar o tipo genérico e evite tipos raw.",
                                  "learningObjective": "Compreender o papel dos genéricos na segurança de tipos.",
                                  "commonMistakes": [
                                    "Confundir genéricos com arrays primitivos",
                                    "Esquecer o diamante <> em inicializações"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar e inicializar uma lista genérica",
                                  "subSteps": [
                                    "Importe as classes necessárias: import java.util.List; import java.util.ArrayList;",
                                    "Declare uma lista genérica: List<String> minhaLista = new ArrayList<>();",
                                    "Teste a inicialização compilando um código simples sem adicionar elementos.",
                                    "Experimente inicializações com outros tipos como Integer ou custom objects.",
                                    "Verifique erros de compilação ao tentar usar tipos incompatíveis."
                                  ],
                                  "verification": "Código compila sem warnings de genéricos e lista é instanciada corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "IDE com suporte a Java",
                                    "JRE 8 ou superior"
                                  ],
                                  "tips": "Use o operador diamante <> para inferência de tipos na inicialização.",
                                  "learningObjective": "Criar listas genéricas parametrizadas com segurança.",
                                  "commonMistakes": [
                                    "Usar new ArrayList() sem <>",
                                    "Misturar tipos na declaração"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar inserção de elementos na lista genérica",
                                  "subSteps": [
                                    "Use o método add(elemento) para inserir no final: minhaLista.add(\"João\");",
                                    "Use add(index, elemento) para inserção em posição específica.",
                                    "Adicione múltiplos elementos e imprima o tamanho com size().",
                                    "Teste inserção de tipos corretos e observe erros ao inserir tipos errados.",
                                    "Itere a lista com for-each para visualizar os elementos adicionados."
                                  ],
                                  "verification": "Lista contém os elementos inseridos e size() retorna o número correto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código base da lista genérica",
                                    "Console para output"
                                  ],
                                  "tips": "Sempre verifique o tipo do elemento antes de adicionar para evitar casts desnecessários.",
                                  "learningObjective": "Dominar operações de inserção com verificação de tipos.",
                                  "commonMistakes": [
                                    "Inserir Object em vez do tipo genérico",
                                    "Índices fora de bounds"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Recuperar e acessar elementos da lista genérica",
                                  "subSteps": [
                                    "Use get(index) para acessar: String nome = minhaLista.get(0);",
                                    "Implemente iteração com for loop tradicional e for-each.",
                                    "Acesse elementos aleatórios e exiba-os sem necessidade de cast.",
                                    "Teste contains(elemento) e indexOf(elemento) para buscas.",
                                    "Compare com listas raw para ver a diferença na segurança de tipos."
                                  ],
                                  "verification": "Elementos são recuperados sem erros de compilação ou runtime casts.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista populada com elementos",
                                    "Métodos de iteração"
                                  ],
                                  "tips": "Prefira for-each para simplicidade e evite get() em loops grandes por performance.",
                                  "learningObjective": "Realizar acessos seguros e eficientes a elementos.",
                                  "commonMistakes": [
                                    "Usar get() com índice inválido",
                                    "Esquecer verificação de tamanho"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Implementar remoção de elementos e verificações finais",
                                  "subSteps": [
                                    "Use remove(index) para remover por posição: minhaLista.remove(0);",
                                    "Use remove(elemento) para remover por valor exato.",
                                    "Verifique o tamanho após remoções e itere para confirmar.",
                                    "Teste remoção em listas com tipos misturados (deve falhar em compilação).",
                                    "Compile o código completo e execute testes unitários simples."
                                  ],
                                  "verification": "Elementos são removidos corretamente e lista mantém integridade de tipos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "JUnit para testes opcionais",
                                    "Lista com dados de teste"
                                  ],
                                  "tips": "remove(elemento) remove a primeira ocorrência; use clear() para esvaziar toda lista.",
                                  "learningObjective": "Executar remoções seguras com genéricos.",
                                  "commonMistakes": [
                                    "Remover durante iteração sem Iterator",
                                    "Tipos incompatíveis em remove"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma lista genérica List<Estudante> para gerenciar alunos de uma turma. Adicione Estudante(\"João\", 18), recupere o nome do primeiro com get(0).getNome(), remova o aluno com ID específico e imprima a lista final sem erros de tipo.",
                              "finalVerifications": [
                                "Código compila sem warnings de unchecked ou raw types.",
                                "Tentativa de adicionar tipo incompatível gera erro de compilação.",
                                "Recuperação de elementos não requer casts explícitos.",
                                "Remoções alteram size() corretamente.",
                                "Execução em runtime sem ClassCastException.",
                                "Impressão da lista mostra apenas elementos do tipo genérico."
                              ],
                              "assessmentCriteria": [
                                "Uso correto de <T> em declarações e inicializações (100%).",
                                "Implementação completa de add, get e remove sem erros (90%).",
                                "Demonstração de verificação de tipos pelo compilador (80%).",
                                "Código limpo, comentado e com testes de verificação (70%).",
                                "Eficiência nas operações (sem loops desnecessários).",
                                "Explicação oral ou escrita dos benefícios dos genéricos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências e índices como em vetores matemáticos.",
                                "Lógica Computacional: Verificação de tipos como validação de pré-condições.",
                                "Banco de Dados: Listas genéricas semelhantes a tabelas com tipos fortes.",
                                "Inglês Técnico: Leitura de docs Java em inglês."
                              ],
                              "realWorldApplication": "Em sistemas de e-commerce, gerenciar carrinhos de compra com List<Produto> para adicionar itens, recuperar totais e remover produtos, garantindo que apenas objetos Produto sejam manipulados sem erros de tipo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.3",
                            "name": "Iterar sobre listas genéricas com polimorfismo",
                            "description": "Utilizar loops e iteradores em listas genéricas para processar elementos de tipos derivados, explorando o polimorfismo em coleções OO.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos de Polimorfismo e Genéricos em Listas",
                                  "subSteps": [
                                    "Estude a definição de polimorfismo: capacidade de objetos de tipos derivados serem tratados como o tipo base.",
                                    "Revise genéricos em listas (ex: List<Shape> em Java), garantindo que aceite subclasses de Shape.",
                                    "Analise exemplos simples de herança: crie uma classe base Animal com método makeSound().",
                                    "Compile e execute um código básico de lista genérica sem iteração para verificar compatibilidade de tipos.",
                                    "Documente diferenças entre List<Animal> e List<Dog> em termos de polimorfismo."
                                  ],
                                  "verification": "Responda corretamente a 5 perguntas sobre polimorfismo e genéricos em um quiz autoavaliativo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE como IntelliJ ou Eclipse",
                                    "Documentação Java sobre Generics e Collections",
                                    "Exemplos de código de herança básica"
                                  ],
                                  "tips": "Use diagramas UML para visualizar a hierarquia de classes antes de codificar.",
                                  "learningObjective": "Compreender como genéricos preservam polimorfismo em coleções heterogêneas.",
                                  "commonMistakes": [
                                    "Confundir genéricos com arrays não-genéricos",
                                    "Usar tipos concretos na declaração da lista limitando polimorfismo",
                                    "Ignorar covariância em genéricos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Hierarquia de Classes com Métodos Polimórficos",
                                  "subSteps": [
                                    "Crie uma classe base abstrata Shape com método abstrato draw().",
                                    "Implemente subclasses Circle e Rectangle que sobrescrevam draw() com comportamentos específicos.",
                                    "Adicione construtores e atributos relevantes (raio para Circle, largura/altura para Rectangle).",
                                    "Teste instâncias individuais chamando draw() para verificar polimorfismo.",
                                    "Refatore para garantir que todas as subclasses sejam instanciáveis e serializáveis."
                                  ],
                                  "verification": "Execute testes unitários onde objetos de subclasses produzem saídas distintas via método base.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE com suporte a JUnit",
                                    "Papel e lápis para esboçar hierarquia UML"
                                  ],
                                  "tips": "Sempre use @Override na sobrescrita para evitar erros de assinatura.",
                                  "learningObjective": "Construir uma hierarquia OO que suporte polimorfismo essencial para iteração genérica.",
                                  "commonMistakes": [
                                    "Esquecer de tornar o método base abstrato",
                                    "Não inicializar atributos nas subclasses",
                                    "Usar final em métodos que precisam ser sobrescritos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar e Popular Lista Genérica com Objetos Polimórficos",
                                  "subSteps": [
                                    "Importe java.util.List e ArrayList; declare List<Shape> shapes = new ArrayList<>();",
                                    "Crie instâncias de Circle e Rectangle e adicione à lista usando add().",
                                    "Verifique o tamanho da lista e imprima tipos via toString() para confirmar heterogeneidade.",
                                    "Tente adicionar um objeto incompatível (ex: String) e observe erro de compilação.",
                                    "Use um loop simples for-each para imprimir referências, sem chamar métodos ainda."
                                  ],
                                  "verification": "A lista contém objetos de tipos derivados sem erros de tipo e size() retorna o número correto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador Java JDK 8+",
                                    "Exemplos de código ArrayList"
                                  ],
                                  "tips": "Use generics wildcard <? extends Shape> se necessário para leitura segura.",
                                  "learningObjective": "Manipular coleções genéricas que armazenam referências polimórficas.",
                                  "commonMistakes": [
                                    "Declarar List<Circle> em vez de List<Shape>",
                                    "Adicionar null sem verificação",
                                    "Misturar tipos não relacionados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Iteração sobre a Lista com Chamadas Polimórficas",
                                  "subSteps": [
                                    "Use for-each loop: for(Shape s : shapes) { s.draw(); }",
                                    "Implemente iteração com Iterator para controle avançado (hasNext(), next()).",
                                    "Adicione contadores ou logs para rastrear ordem de execução polimórfica.",
                                    "Teste com diferentes tamanhos de lista e proporções de subclasses.",
                                    "Refatore para um método processShapes() que encapsule a iteração."
                                  ],
                                  "verification": "Execução produz saídas específicas de cada subclasse, demonstrando polimorfismo em runtime.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "IDE debugger",
                                    "JUnit para testes automatizados"
                                  ],
                                  "tips": "Ative logging no draw() para visualizar chamadas dinâmicas.",
                                  "learningObjective": "Aplicar loops e iteradores para invocar comportamento polimórfico em coleções.",
                                  "commonMistakes": [
                                    "Usar instanceof desnecessariamente quebrando polimorfismo",
                                    "Loop infinito em Iterator",
                                    "Ignorar exceções em iteração"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Java, crie List<Shape> shapes = new ArrayList<>(); shapes.add(new Circle(5)); shapes.add(new Rectangle(4,6)); for(Shape s : shapes) { s.draw(); } // Saída: 'Desenhando círculo de raio 5' seguido de 'Desenhando retângulo 4x6'.",
                              "finalVerifications": [
                                "Código compila sem warnings de tipo genérico.",
                                "Lista aceita e armazena múltiplas subclasses sem casting.",
                                "Iteração chama métodos sobrescritos corretamente em runtime.",
                                "Saída varia conforme o tipo real do objeto, não o tipo da referência.",
                                "Performance de iteração é O(n) com tempo linear confirmado.",
                                "Nenhuma ClassCastException ocorre durante execução."
                              ],
                              "assessmentCriteria": [
                                "Correção: Polimorfismo funciona sem casts explícitos.",
                                "Eficiência: Uso apropriado de for-each vs Iterator.",
                                "Robustez: Tratamento de listas vazias ou nulas.",
                                "Clareza: Código legível com comentários em métodos chave.",
                                "Extensibilidade: Fácil adicionar nova subclasse sem alterar iteração.",
                                "Testabilidade: Pelo menos 80% cobertura de testes unitários."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstrações de conjuntos e funções polimórficas semelhantes a funções genéricas.",
                                "Algoritmos: Processamento de coleções em Big O, relacionando a traversals em grafos.",
                                "Design de Software: Princípios SOLID, especialmente Liskov Substitution.",
                                "Banco de Dados: Herança em modelagem relacional vs NoSQL polimórfico."
                              ],
                              "realWorldApplication": "Em um sistema de RH, iterar sobre List<Employee> contendo SalariedEmployee e HourlyEmployee para calcular folha de pagamento polimórfica, processando milhares de registros de forma eficiente e extensível."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.2",
                        "name": "Genéricos em Mapas",
                        "description": "Uso de tipos genéricos em estruturas de mapas para associar chaves e valores de forma type-safe, promovendo coleções flexíveis em programação OO.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.2.1",
                            "name": "Declarar um mapa genérico",
                            "description": "Definir um mapa genérico como Map<K, V> em Java ou Dict[K, V] em Python typing, especificando tipos para chaves e valores para segurança em runtime e compile-time.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de Genéricos e Mapas",
                                  "subSteps": [
                                    "Revise o conceito de genéricos: estruturas que aceitam tipos parametrizados para segurança de tipo.",
                                    "Estude mapas como estruturas chave-valor associativas (ex: HashMap em Java, dict em Python).",
                                    "Identifique benefícios: type-safety em compile-time (Java) ou runtime hints (Python typing).",
                                    "Compare Map<K,V> em Java vs Dict[K,V] em Python do módulo typing.",
                                    "Anote diferenças: Java é enforced em runtime/compile, Python é optional via mypy."
                                  ],
                                  "verification": "Resuma em 3 bullet points os benefícios dos genéricos em mapas; confira com documentação oficial.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação Java (docs.oracle.com/javase/8/docs/api/java/util/Map.html), Python typing docs (docs.python.org/3/library/typing.html#typing.Dict), IDE como IntelliJ ou VSCode.",
                                  "tips": "Use diagramas para visualizar K->V mappings.",
                                  "learningObjective": "Compreender por que genéricos melhoram mapas com type-safety.",
                                  "commonMistakes": "Confundir genéricos com arrays; ignorar que Python typing não é enforced nativamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar Map Genérico em Java",
                                  "subSteps": [
                                    "Importe java.util.Map e java.util.HashMap.",
                                    "Declare: Map<String, Integer> meuMapa = new HashMap<>();",
                                    "Especifique tipos concretos para K e V (ex: String para chave, List<Integer> para valor).",
                                    "Compile o código para verificar erros de tipo.",
                                    "Adicione um put() para testar: meuMapa.put(\"chave\", 42);"
                                  ],
                                  "verification": "Código compila sem warnings de tipo e put() não gera erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "JDK 8+, IDE Java (Eclipse/IntelliJ), snippet de código base.",
                                  "tips": "Use <> diamond operator para inferência de tipo em Java 7+.",
                                  "learningObjective": "Declarar corretamente Map<K,V> com tipos específicos em Java.",
                                  "commonMistakes": "Esquecer importações; usar raw types como Map sem <K,V>."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Declarar Dict Genérico em Python com Typing",
                                  "subSteps": [
                                    "Importe from typing import Dict.",
                                    "Declare: meu_dict: Dict[str, int] = {}",
                                    "Use tipos como Dict[str, List[int]] para valores complexos.",
                                    "Execute com mypy para checar type hints.",
                                    "Adicione itens: meu_dict[\"chave\"] = 42 e verifique isinstance."
                                  ],
                                  "verification": "mypy passa sem erros e código roda sem TypeError em runtime.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python 3.9+, mypy instalado (pip install mypy), VSCode com Pylance.",
                                  "tips": "Para Python 3.9+, use built-in dict[str, int] sem typing.",
                                  "learningObjective": "Aplicar Dict[K,V] para type hints em Python.",
                                  "commonMistakes": "Usar dict sem colons (:) para hints; ignorar mypy."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Comparar Declarações Genéricas",
                                  "subSteps": [
                                    "Crie um programa unificado comparando Java e Python declarações lado a lado.",
                                    "Teste violações de tipo: tente put/inserir tipo errado e observe erros.",
                                    "Refatore para genéricos mais complexos (ex: Map<String, List<Integer>>).",
                                    "Documente diferenças em um README.",
                                    "Rode testes unitários para ambas linguagens."
                                  ],
                                  "verification": "Todos testes passam; README explica diferenças com exemplos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "JUnit para Java, pytest para Python, GitHub para README.",
                                  "tips": "Use IDE refactoring para alterar tipos e ver propagação.",
                                  "learningObjective": "Validar e comparar declarações genéricas entre Java e Python.",
                                  "commonMistakes": "Não testar runtime em Java raw types; pular mypy em Python."
                                }
                              ],
                              "practicalExample": "Em Java: Map<String, List<Employee>> employeeByDept = new HashMap<>(); employeeByDept.put(\"IT\", Arrays.asList(new Employee(\"Alice\", 50000))); Em Python: from typing import Dict, List; employee_by_dept: Dict[str, List[Employee]] = {}; employee_by_dept[\"IT\"] = [Employee(\"Alice\", 50000)] – garante que chaves sejam str e valores listas de Employee.",
                              "finalVerifications": [
                                "Declaração compila/roda sem erros de tipo em Java/Python.",
                                "mypy ou compiler flags detectam violações intencionalmente inseridas.",
                                "Código aceita apenas tipos corretos para K/V.",
                                "Exemplo prático com put/inserção funciona.",
                                "Documentação pessoal resume sintaxe e benefícios.",
                                "Testes unitários cobrem declaração e uso básico."
                              ],
                              "assessmentCriteria": [
                                "Correção da sintaxe genérica (100% match com docs oficiais).",
                                "Uso apropriado de tipos concretos para K/V (não Object/Any).",
                                "Evidência de verificação (screenshots de compile/mypy).",
                                "Explicação clara de benefícios type-safety.",
                                "Comparação Java vs Python com exemplos funcionais.",
                                "Ausência de raw types ou type hints omitidos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Mapas como funções injetoras (chave única -> valor).",
                                "Banco de Dados: Relacionamentos chave-valor como índices/hashes.",
                                "Algoritmos: Hash tables para O(1) lookup médio.",
                                "Design de Software: Abstrações parametrizadas para reutilização."
                              ],
                              "realWorldApplication": "Em apps web, caches de sessão (Map<UserId, SessionData>); em ML, dicionários de features (Dict[str, float]); em games, inventários (Map<ItemId, Quantity>) – previne bugs de tipo em escala."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.2",
                            "name": "Inserir e consultar pares chave-valor",
                            "description": "Realizar operações de put/get em mapas genéricos, garantindo que apenas tipos compatíveis sejam usados, evitando casts desnecessários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Declarar e Inicializar um Map Genérico",
                                  "subSteps": [
                                    "Importar as classes necessárias: import java.util.Map; import java.util.HashMap;",
                                    "Declarar uma variável do tipo Map<K, V>, substituindo K e V por tipos compatíveis, como Map<String, Integer>.",
                                    "Inicializar o Map com new HashMap<>() ou HashMap.newInstance() em versões recentes do Java.",
                                    "Compilar um código simples para testar a declaração sem erros de tipo.",
                                    "Explorar inicialização com valores iniciais usando métodos como of() em Java 9+."
                                  ],
                                  "verification": "O código compila sem erros ou warnings de tipos raw e o Map é instanciado com toString() mostrando estrutura vazia.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "IDE (IntelliJ/Eclipse), JDK 8+, documentação Java Map API",
                                  "tips": "Use o diamond operator <> para inferência automática de tipos e evite tipos raw.",
                                  "learningObjective": "Dominar a declaração de Maps genéricos com tipos chave-valor específicos para type-safety.",
                                  "commonMistakes": "Esquecer genéricos (Map em vez de Map<String, Integer>), gerando warnings unchecked."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inserir Pares Chave-Valor com put()",
                                  "subSteps": [
                                    "Chamar o método put(chave, valor), garantindo que chave seja tipo K e valor tipo V.",
                                    "Inserir múltiplos pares chave-valor em sequência.",
                                    "Observar o retorno de put(): valor anterior se chave existia, null caso contrário.",
                                    "Testar sobrescrita de chaves duplicadas.",
                                    "Capturar o valor retornado por put() em uma variável para verificação."
                                  ],
                                  "verification": "Imprimir o Map ou usar size() para confirmar inserções; valores sobrescritos corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "IDE com console, exemplos de código Java",
                                  "tips": "put() é idempotente para novas chaves; use computeIfAbsent() para lógica condicional.",
                                  "learningObjective": "Executar inserções seguras em Maps genéricos, entendendo o comportamento de sobrescrita.",
                                  "commonMistakes": "Passar tipos incompatíveis como Integer para chave String, causando erro de compilação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Consultar Valores com get()",
                                  "subSteps": [
                                    "Chamar map.get(chave) para recuperar o valor associado.",
                                    "Testar get() com chave inexistente, esperando null.",
                                    "Usar getOrDefault(chave, valorPadrao) para evitar null checks.",
                                    "Iterar sobre o Map com entrySet() para consultar múltiplos pares.",
                                    "Armazenar o resultado de get() em variável tipada corretamente."
                                  ],
                                  "verification": "Valores consultados correspondem aos inseridos; getOrDefault() retorna padrão para ausentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "IDE, Javadoc para Map.get() e getOrDefault()",
                                  "tips": "Sempre verifique null após get() ou prefira getOrDefault() em produção.",
                                  "learningObjective": "Realizar consultas eficientes e type-safe em Maps genéricos.",
                                  "commonMistakes": "Cast desnecessário como (Integer) map.get('chave'), ignorando benefícios dos genéricos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Garantir Compatibilidade de Tipos e Evitar Casts Desnecessários",
                                  "subSteps": [
                                    "Verificar compatibilidade: chaves/valores devem ser exatamente K/V ou subclasses se bounded.",
                                    "Refatorar código legado removendo casts explícitos graças aos genéricos.",
                                    "Testar com null: put(null, valor) ou get(null) conforme permitido pelo tipo.",
                                    "Usar métodos como containsKey() antes de get() para edge cases.",
                                    "Analisar warnings do compilador e corrigi-los com tipos precisos."
                                  ],
                                  "verification": "Código compila sem casts ou warnings; tipos inferidos corretamente em IDE.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Compilador javac com -Xlint:unchecked, exemplos de código com erros comuns",
                                  "tips": "Genéricos eliminam casts em runtime; priorize type parameters para segurança.",
                                  "learningObjective": "Aplicar boas práticas de type-safety em operações de Map para código robusto.",
                                  "commonMistakes": "Usar wildcards (?) incorretamente ou ignorar bounds genéricos como <? extends Number>."
                                }
                              ],
                              "practicalExample": "Crie um Map<String, Integer> notasAlunos = new HashMap<>(); notasAlunos.put(\"João\", 85); notasAlunos.put(\"Maria\", 92); System.out.println(notasAlunos.get(\"João\")); // Saída: 85 (tipo Integer, sem cast). Teste get(\"Pedro\") retornando null e use getOrDefault(\"Pedro\", 0) para 0.",
                              "finalVerifications": [
                                "Mapa declara com genéricos corretos e compila sem warnings.",
                                "put() insere e sobrescreve pares chave-valor adequadamente.",
                                "get() retorna valores tipados sem necessidade de cast.",
                                "Tratamento de chaves inexistentes e nulls funciona.",
                                "size(), containsKey() e iteração confirmam integridade.",
                                "Código é type-safe em runtime sem ClassCastException."
                              ],
                              "assessmentCriteria": [
                                "Uso consistente de genéricos em declaração e operações.",
                                "Ausência total de casts desnecessários.",
                                "Correto handling de edge cases (null, duplicatas).",
                                "Eficiência: O(1) médio para put/get comprovado em testes simples.",
                                "Código limpo, comentado e legível.",
                                "Compreensão demonstrada em refatoração de exemplo legado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Relações função (chave -> valor único).",
                                "Banco de Dados: Estruturas chave-valor como em Redis ou JSON stores.",
                                "Algoritmos: Tabelas hash e colisões.",
                                "Design de Software: Padrões como Dictionary em linguagens variadas."
                              ],
                              "realWorldApplication": "Desenvolvimento de caches de sessão em apps web (ex: usuário ID -> dados de perfil), configurações dinâmicas por chave em microsserviços, índices rápidos para buscas em e-commerces, ou mapeamento de enums a valores em jogos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.3",
                            "name": "Remover e verificar existência em mapas genéricos",
                            "description": "Implementar remoção de entradas e verificação de chaves em mapas genéricos, destacando benefícios da tipagem estática para detecção de erros precoces.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar e Inicializar um Mapa Genérico",
                                  "subSteps": [
                                    "Importe as classes necessárias: java.util.HashMap e java.util.Map.",
                                    "Declare um mapa genérico com tipos específicos, ex: Map<String, Integer> studentGrades = new HashMap<>();",
                                    "Adicione algumas entradas de exemplo usando put(key, value).",
                                    "Imprima o mapa inicial para visualização."
                                  ],
                                  "verification": "Mapa inicializado e populado corretamente, sem erros de compilação; saída no console mostra entradas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "IDE (Eclipse/IntelliJ), documentação Java Map API",
                                  "tips": "Use tipos genéricos explícitos para evitar warnings de type erasure.",
                                  "learningObjective": "Compreender declaração e inicialização de mapas genéricos com tipagem estática.",
                                  "commonMistakes": "Usar raw types como Map em vez de Map<K,V>, levando a perda de benefícios de tipagem."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Verificação de Existência de Chave",
                                  "subSteps": [
                                    "Declare uma chave de teste, ex: String studentId = 'student123';",
                                    "Use o método containsKey(studentId) para verificar existência.",
                                    "Armazene o resultado em uma boolean e imprima: 'Existe: ' + exists.",
                                    "Teste com chaves existentes e inexistentes.",
                                    "Adicione um if-else para demonstrar uso condicional."
                                  ],
                                  "verification": "Método containsKey retorna true/false corretamente para chaves testadas; lógica condicional executa sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "IDE com código do Step 1, JUnit para testes opcionais",
                                  "tips": "containsKey é O(1) em HashMap; prefira sobre get() != null para evitar NullPointerException.",
                                  "learningObjective": "Aplicar containsKey em mapas genéricos para verificações seguras.",
                                  "commonMistakes": "Confundir containsKey com containsValue; usar get(key) == null sem verificar null values."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Remoção de Entrada",
                                  "subSteps": [
                                    "Selecione uma chave existente confirmada pelo Step 2.",
                                    "Use o método remove(key) e capture o valor retornado: Integer removedGrade = studentGrades.remove(studentId);",
                                    "Verifique se a remoção ocorreu comparando tamanhos antes/depois com size().",
                                    "Imprima o valor removido e o mapa atualizado.",
                                    "Teste remoção de chave inexistente (deve retornar null)."
                                  ],
                                  "verification": "Entrada removida corretamente; size() diminui em 1; valor retornado é o esperado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "IDE, código anterior",
                                  "tips": "remove(key) retorna o valor associado ou null; use para chaining se necessário.",
                                  "learningObjective": "Executar remoções seguras em mapas genéricos com retorno de valor.",
                                  "commonMistakes": "Não capturar o retorno de remove(); ignorar que remove inexistente retorna null."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Melhores Práticas e Benefícios da Tipagem Estática",
                                  "subSteps": [
                                    "Refatore código para método reutilizável: boolean safeRemove(Map<String, Integer> map, String key).",
                                    "Combine containsKey e remove em uma transação lógica.",
                                    "Compile e identifique erros de tipo intencionalmente (ex: passar Integer como String).",
                                    "Adicione comentários destacando detecção precoce de erros pela tipagem.",
                                    "Execute testes unitários para cenários edge (null keys, empty map)."
                                  ],
                                  "verification": "Código refatorado compila sem warnings; testes passam; erros de tipo detectados em compile-time.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "IDE, JUnit/TestNG",
                                  "tips": "Sempre valide chaves antes de remover para logs/auditoria.",
                                  "learningObjective": "Destacar vantagens da tipagem estática em genéricos para prevenção de runtime errors.",
                                  "commonMistakes": "Passar tipos incompatíveis sem genéricos (ex: raw Map aceita qualquer coisa em runtime)."
                                }
                              ],
                              "practicalExample": "Em um sistema de gerenciamento de notas de alunos, use Map<String, Integer> studentGrades para verificar se 'alice123' existe com containsKey, e remover sua nota com remove se aprovada para exclusão, garantindo tipagem para evitar inserir String como nota.",
                              "finalVerifications": [
                                "Mapa genérico manipulado sem erros de compilação ou runtime.",
                                "containsKey retorna boolean correto para todas chaves testadas.",
                                "remove(key) altera size() e retorna valor esperado/null.",
                                "Código usa tipagem estática sem warnings.",
                                "Testes unitários cobrem casos existentes/inexistentes/null.",
                                "Refatoração em métodos reutilizáveis funciona."
                              ],
                              "assessmentCriteria": [
                                "Correção: Operações produzem resultados esperados.",
                                "Uso preciso de genéricos (sem raw types).",
                                "Eficiência: Métodos O(1) adequados.",
                                "Tratamento de edge cases (null, inexistente).",
                                "Clareza: Código legível com comentários.",
                                "Detecção de benefícios da tipagem via exemplos de erro."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Mapas como funções parciais domínio->imagem.",
                                "Banco de Dados: Operações CRUD em tabelas chave-valor (SELECT EXISTS, DELETE).",
                                "Algoritmos: Hash tables e colisões em estruturas de dados.",
                                "Design de Software: Princípios SOLID com interfaces genéricas."
                              ],
                              "realWorldApplication": "Desenvolvimento de caches em aplicações web (ex: Redis-like em memória), gerenciamento de sessões de usuário em servidores, ou inventários em e-commerces onde remover itens e verificar estoque previne erros de venda de produtos indisponíveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.3",
                        "name": "Estruturas de Dados Customizadas com Genéricos",
                        "description": "Criação de classes OO personalizadas utilizando genéricos para estender coleções flexíveis e reutilizáveis, aplicando princípios de abstração e encapsulamento.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.3.1",
                            "name": "Definir uma classe genérica customizada",
                            "description": "Criar uma classe genérica simples, como uma fila ou pilha parametrizada por T, definindo construtores e métodos com restrições de tipo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Genéricos",
                                  "subSteps": [
                                    "Estude a sintaxe básica de genéricos em Java, como <T> para tipo parametrizado",
                                    "Revise exemplos built-in como ArrayList<T> e Stack<T> da biblioteca padrão",
                                    "Identifique benefícios: type-safety, eliminação de casts e reutilização de código",
                                    "Analise limitações: erasure em runtime e necessidade de bounds como <T extends Comparable<T>>",
                                    "Pratique declarando variáveis genéricas simples como Stack<String> minhaPilha;"
                                  ],
                                  "verification": "Explique em voz alta ou anote os 3 principais benefícios e 2 limitações dos genéricos",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial Java Generics (Oracle Docs)",
                                    "Exemplos de código de ArrayList e Stack",
                                    "Editor de código como IntelliJ ou VS Code"
                                  ],
                                  "tips": "Comece com exemplos simples para fixar a sintaxe antes de criar sua própria classe",
                                  "learningObjective": "Dominar os fundamentos teóricos e sintáticos de genéricos para aplicação prática",
                                  "commonMistakes": [
                                    "Confundir genéricos Java com templates C++ (sem especialização)",
                                    "Esquecer que type erasure ocorre em runtime",
                                    "Usar tipos primitivos diretamente (use wrappers como Integer)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Planejar e Declarar a Classe Genérica Customizada",
                                  "subSteps": [
                                    "Defina os requisitos da classe: escolha uma estrutura como Stack<T> com push, pop, peek e isEmpty",
                                    "Declare a classe: public class Stack<T> { ... }",
                                    "Adicione um campo interno genérico: private T[] elements = (T[]) new Object[10]; e private int size = 0;",
                                    "Considere bounds iniciais: public class Stack<T extends Comparable<T>> para ordenação futura",
                                    "Compile uma declaração vazia para verificar sintaxe"
                                  ],
                                  "verification": "A classe declara corretamente <T> e compila sem erros de sintaxe genérica",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor IDE com suporte a Java (IntelliJ IDEA Community)",
                                    "Papel e caneta para esboço da classe",
                                    "Referência de API Java Collections"
                                  ],
                                  "tips": "Use array de Object[] cast para T[] devido a type erasure; dimensione inicialmente pequeno",
                                  "learningObjective": "Criar a declaração base de uma classe genérica com parâmetros de tipo apropriados",
                                  "commonMistakes": [
                                    "Declarar T[] diretamente sem cast (gera erro de generic array creation)",
                                    "Esquecer modificador private nos campos internos",
                                    "Não planejar redimensionamento do array"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Construtor e Métodos Básicos",
                                  "subSteps": [
                                    "Crie construtor padrão: public Stack() { this.elements = (T[]) new Object[INITIAL_CAPACITY]; }",
                                    "Implemente push(T item): verifique capacidade, adicione elements[size++] = item;",
                                    "Implemente pop(): if (size == 0) throw new EmptyStackException(); T item = elements[--size]; elements[size] = null; return item;",
                                    "Adicione isEmpty(): return size == 0;",
                                    "Adicione peek(): similar a pop mas sem remover"
                                  ],
                                  "verification": "Teste unitário simples: crie Stack<String>, push/pop 3 itens e verifique isEmpty",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "JUnit ou framework de testes simples",
                                    "IDE com debugger",
                                    "Exemplos de Stack da java.util"
                                  ],
                                  "tips": "Sempre nullifique slots removidos para evitar memory leaks em coleções genéricas",
                                  "learningObjective": "Desenvolver funcionalidade core de uma estrutura de dados genérica com type-safety",
                                  "commonMistakes": [
                                    "Não tratar overflow de array (redimensione dinamicamente)",
                                    "Retornar null em pop sem exceção",
                                    "Esquecer casts em retornos de métodos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar Restrições de Tipo, Testes e Refinamentos",
                                  "subSteps": [
                                    "Aplique bound: mude para <T extends Comparable<T>> e adicione método sort() usando T.compareTo",
                                    "Implemente redimensionamento: em push, if (size >= elements.length) resize(2 * size);",
                                    "Crie testes com múltiplos tipos: Stack<Integer>, Stack<String>, verifique type-safety (ex: não compile push(String) em Stack<Integer>)",
                                    "Adicione documentação Javadoc para todos métodos",
                                    "Refatore para eficiência: O(1) amortizado para push/pop"
                                  ],
                                  "verification": "Código compila, testes passam com diferentes tipos T, e bound é enforced pelo compilador",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "JUnit 5 para testes automatizados",
                                    "Ferramenta de análise estática como Checkstyle",
                                    "Documentação Javadoc"
                                  ],
                                  "tips": "Use ? extends T para wildcards em métodos se necessário, mas foque em bounds simples aqui",
                                  "learningObjective": "Incorporar restrições avançadas e validar a classe genérica completa",
                                  "commonMistakes": [
                                    "Bounds incorretos como T extends T (inútil)",
                                    "Ignorar warnings de unchecked casts",
                                    "Testar só com um tipo, perdendo type-safety demo"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente uma Stack<T> genérica:\npublic class Stack<T> {\n  private T[] elements;\n  private int size;\n  public Stack() { elements = (T[]) new Object[10]; }\n  public void push(T item) { /* impl */ }\n  public T pop() { /* impl com exceção */ }\n  // etc.\n}\nTeste: Stack<Integer> stack = new Stack<>(); stack.push(1); assert stack.pop() == 1;",
                              "finalVerifications": [
                                "A classe compila sem warnings de genéricos ou unchecked casts",
                                "Testes com Stack<String> e Stack<Integer> funcionam sem casts explícitos",
                                "Tentativa de push(String) em Stack<Integer> gera erro de compilação",
                                "Métodos respeitam bounds (ex: compareTo funciona se T extends Comparable)",
                                "Performance: push/pop em loop de 1000 itens sem erros",
                                "Javadoc cobre todos métodos públicos"
                              ],
                              "assessmentCriteria": [
                                "Type-safety total: nenhum cast necessário no uso da classe",
                                "Funcionalidade completa: push, pop, peek, isEmpty implementados corretamente",
                                "Tratamento de edge cases: empty stack, overflow redimensionado",
                                "Eficiência: O(1) amortizado para operações principais",
                                "Código limpo: bounds apropriados, null-safety, documentado",
                                "Reutilizável: funciona com qualquer T (ou bounded T)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstrações de estruturas algébricas como monoides em teoria de categorias",
                                "Design de Software: Princípios SOLID (abstração e dependência inversion via genéricos)",
                                "Ciência da Computação: Análise de complexidade em coleções parametrizadas",
                                "Engenharia de Software: Padrões de projeto como Adapter para integrar com coleções existentes"
                              ],
                              "realWorldApplication": "Classes genéricas customizadas são usadas em frameworks como Spring (genéricos em repositories), editores de texto (undo/redo stacks), navegadores web (histórico de navegação) e simuladores (pilhas de estados em jogos ou parsers XML/JSON para evitar casts e erros de tipo em produção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.2",
                            "name": "Implementar métodos genéricos em classes OO",
                            "description": "Desenvolver métodos como push/pop em uma stack genérica, utilizando herança e polimorfismo para suportar múltiplos tipos de dados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de genéricos, herança e polimorfismo",
                                  "subSteps": [
                                    "Estude a documentação oficial de genéricos em Java (Trail sobre Generics)",
                                    "Revise exemplos de herança com classes pai e filhas",
                                    "Analise polimorfismo através de interfaces e sobrescrita de métodos",
                                    "Identifique como genéricos suportam múltiplos tipos sem perda de type-safety",
                                    "Crie um diagrama UML simples de uma stack genérica"
                                  ],
                                  "verification": "Responda a um quiz com 5 perguntas sobre os conceitos ou anote definições corretas em um documento",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Java Generics (Oracle Docs)",
                                    "IDE como IntelliJ ou Eclipse",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": [
                                    "Comece com exemplos simples como List<T> antes de customizar",
                                    "Foquem em bounded types se necessário para herança"
                                  ],
                                  "learningObjective": "Compreender como genéricos integram herança e polimorfismo para flexibilidade tipada",
                                  "commonMistakes": [
                                    "Confundir genéricos com casting manual",
                                    "Ignorar warnings de type erasure"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a estrutura da classe Stack genérica",
                                  "subSteps": [
                                    "Declare a classe pública como 'public class Stack<T>'",
                                    "Adicione campos privados: um array dinâmico Object[] data ou ArrayList<T> para armazenamento",
                                    "Defina variáveis para size e capacity",
                                    "Crie construtor que inicialize o array com capacidade inicial (ex: 10)",
                                    "Adicione métodos auxiliares como resize() para expansão dinâmica"
                                  ],
                                  "verification": "A classe compila sem erros e o construtor instancia corretamente uma Stack<String>",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "IDE Java com JDK 8+",
                                    "Exemplos de ArrayList source code"
                                  ],
                                  "tips": [
                                    "Use ArrayList<T> internamente para simplicidade inicial",
                                    "Defina T extends Object implicitamente"
                                  ],
                                  "learningObjective": "Criar uma classe genérica base com suporte a herança futura",
                                  "commonMistakes": [
                                    "Declarar como Stack sem <T>",
                                    "Usar tipos concretos no lugar de T"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar métodos principais push e pop",
                                  "subSteps": [
                                    "Implemente push(T item): verifique capacidade, adicione ao topo (data[size++] = item)",
                                    "Implemente pop(): verifique se não vazia, retorne e remova topo (T item = (T) data[--size])",
                                    "Adicione suporte a polimorfismo definindo uma interface IStack<T> com esses métodos",
                                    "Faça a classe Stack implementar IStack<T> e use herança se criar subclasses",
                                    "Trate exceções como StackOverflowException ou EmptyStackException customizadas"
                                  ],
                                  "verification": "Teste unitário: push 3 itens e pop 3, verificando ordem LIFO",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": [
                                    "JUnit para testes",
                                    "Exemplos de Stack em bibliotecas Java"
                                  ],
                                  "tips": [
                                    "Sempre cast para T em pop devido a type erasure",
                                    "Use generics wildcards se polimorfismo em coleções"
                                  ],
                                  "learningObjective": "Desenvolver métodos genéricos funcionais com operações LIFO",
                                  "commonMistakes": [
                                    "Não tratar underflow/overflow",
                                    "Perder type-safety no pop"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar métodos auxiliares, testar e refatorar",
                                  "subSteps": [
                                    "Implemente isEmpty(), size(), peek() (topo sem remover)",
                                    "Crie testes com múltiplos tipos: Stack<Integer>, Stack<String>, Stack<CustomObject>",
                                    "Demonstre polimorfismo: use herança com subclass BoundedStack<T extends Number>",
                                    "Refatore para usar herança: Stack<T> extends AbstractStack<T>",
                                    "Execute testes e profile performance com 1000 pushes/pops"
                                  ],
                                  "verification": "Todos testes passam (cobertura >80%) e código suporta herança sem erros",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "JUnit 5",
                                    "Ferramenta de coverage como JaCoCo"
                                  ],
                                  "tips": [
                                    "Herde de uma classe abstrata para encapsular lógica comum",
                                    "Evite raw types em testes"
                                  ],
                                  "learningObjective": "Integrar herança e polimorfismo em estrutura genérica completa",
                                  "commonMistakes": [
                                    "Usar instanceof com genéricos",
                                    "Ignorar covariância em herança"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma Stack<Livro> para gerenciar pilha de livros em uma biblioteca virtual. Implemente push(Livro novoLivro), pop() para retirar o mais recente, e teste com polimorfismo usando LivroFiction extends Livro.",
                              "finalVerifications": [
                                "A Stack<T> compila e executa sem warnings de generics",
                                "Push/pop mantém ordem LIFO para qualquer T",
                                "Herança funciona: subclass herda e sobrescreve métodos",
                                "Polimorfismo: métodos aceitam IStack<? extends Number>",
                                "Testes com 3 tipos diferentes passam 100%",
                                "Nenhuma perda de type-safety (sem casts desnecessários)"
                              ],
                              "assessmentCriteria": [
                                "Uso correto de <T> em declarações e métodos",
                                "Implementação eficiente de resize e exceções",
                                "Integração clara de herança e polimorfismo",
                                "Código limpo com comentários e Javadoc",
                                "Testes unitários abrangentes",
                                "Tratamento de edge cases (vazia, cheia)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstrações de pilhas em teoria dos grafos e recursão",
                                "Algoritmos: Complexidade O(1) amortizado para push/pop",
                                "Design de Software: Princípios SOLID com genéricos",
                                "Banco de Dados: Pilhas em transações e undo logs"
                              ],
                              "realWorldApplication": "Implementação de pilhas genéricas em editores de texto para histórico de undo/redo, compiladores para avaliação de expressões postfix, e servidores web para gerenciamento de sessões de usuário com tipos variados."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.3",
                            "name": "Aplicar bounds e wildcards em genéricos customizados",
                            "description": "Usar bounded types (ex: T extends Number) e wildcards (? extends T) em estruturas customizadas para maior flexibilidade e segurança em cenários polimórficos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e implementar parâmetros de tipo limitados (bounded type parameters)",
                                  "subSteps": [
                                    "Estude a sintaxe básica: T extends ClasseBase para limitar T a subclasses de ClasseBase.",
                                    "Analise exemplos com Number: class Caixa<T extends Number> { ... }.",
                                    "Implemente uma classe simples como NumerosBox<T extends Number> com métodos add e get.",
                                    "Teste compilação adicionando tipos inválidos (ex: String) para ver erros.",
                                    "Explore múltiplos bounds: T extends Number & Comparable<T>."
                                  ],
                                  "verification": "Compilar código sem erros e verificar que apenas tipos permitidos são aceitos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE Java (Eclipse/IntelliJ)",
                                    "Documentação Oracle: Generic Types"
                                  ],
                                  "tips": "Comece com bounds simples como Number para visualizar restrições de tipo imediatamente.",
                                  "learningObjective": "Dominar a sintaxe e aplicação de bounded type parameters para restringir tipos genéricos.",
                                  "commonMistakes": [
                                    "Esquecer o 'extends' ou usar 'super' incorretamente",
                                    "Não testar com tipos inválidos",
                                    "Confundir bounds com wildcards"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar wildcards com limite superior (? extends T)",
                                  "subSteps": [
                                    "Entenda o conceito: ? extends Number permite leitura polimórfica de qualquer subtipos de Number.",
                                    "Crie um método como imprimirCaixas(List<? extends Number> caixas) que itera e imprime.",
                                    "Teste com List<Integer>, List<Double> e verifique flexibilidade.",
                                    "Tente adicionar elementos ao método e observe erro de compilação (somente leitura).",
                                    "Compare com genérico não-bounded para ver diferenças em segurança."
                                  ],
                                  "verification": "Método compila e executa corretamente com múltiplos subtipos sem warnings de tipo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE Java",
                                    "Tutorial Baeldung: Bounded Wildcards"
                                  ],
                                  "tips": "Lembre-se: upper bound é para 'leitura segura' (PECS: Producer Extends).",
                                  "learningObjective": "Aplicar upper bounded wildcards para cenários de consumo polimórfico.",
                                  "commonMistakes": [
                                    "Tentar escrever (add) em upper bound",
                                    "Usar wildcard sem necessidade",
                                    "Ignorar warnings de raw types"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar wildcards com limite inferior (? super T)",
                                  "subSteps": [
                                    "Estude sintaxe: ? super Integer permite escrita para superclasses como Number ou Object.",
                                    "Crie método como adicionarMaiores(List<? super Integer> destino, List<Integer> origem).",
                                    "Teste adicionando Integers a List<Number> e List<Object>.",
                                    "Verifique limitação: leitura retorna apenas Object (captura segura).",
                                    "Compare com upper bound para entender dualidade."
                                  ],
                                  "verification": "Método permite adições corretas e compila sem erros em cenários hierárquicos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE Java",
                                    "Effective Java - Item 28: Wildcards"
                                  ],
                                  "tips": "Lower bound é para 'escrita segura' (PECS: Consumer Super).",
                                  "learningObjective": "Usar lower bounded wildcards para produção polimórfica flexível.",
                                  "commonMistakes": [
                                    "Confundir super/extends",
                                    "Esperar tipagem precisa na leitura",
                                    "Não testar hierarquia de classes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar bounds e wildcards em estrutura customizada e validar",
                                  "subSteps": [
                                    "Crie classe customizada StackCustom<T extends Comparable<T>> com push/pop usando bound.",
                                    "Adicione métodos utilitários com wildcards: copiarStack(List<? extends T> origem, StackCustom<? super T> destino).",
                                    "Implemente ordenacao polimorfica usando compareTo do bound.",
                                    "Teste cenários: Stack de Integers/Doubles, cópia entre listas heterogêneas.",
                                    "Refatore para eliminar casts e warnings de tipo."
                                  ],
                                  "verification": "Estrutura completa compila, executa testes unitários e mantém segurança de tipos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "JUnit para testes",
                                    "IDE com debugger"
                                  ],
                                  "tips": "Use PECS heuristic para decidir wildcard: extends para input, super para output.",
                                  "learningObjective": "Combinar bounds e wildcards em genéricos customizados para flexibilidade e segurança.",
                                  "commonMistakes": [
                                    "Violar bounds em recursão",
                                    "Ignorar captura de wildcard",
                                    "Sobre-generalizar sem necessidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe CaixaNumeros<T extends Number> com método somarTodos(List<? extends Number> listaExtras). Teste: CaixaNumeros<Integer> c1 = new CaixaNumeros<>(); c1.add(10); somarTodos(List.of(1.5, 2)); // Funciona polimorficamente sem casts.",
                              "finalVerifications": [
                                "Código compila sem erros ou warnings de genéricos.",
                                "Bounds restringem tipos inválidos corretamente.",
                                "Wildcards permitem operações polimórficas flexíveis.",
                                "Testes unitários passam para cenários upper e lower bound.",
                                "Nenhum cast desnecessário ou perda de segurança de tipo.",
                                "Estrutura customizada suporta hierarquias de classes."
                              ],
                              "assessmentCriteria": [
                                "Correta sintaxe de bounds e wildcards (100% compilável).",
                                "Flexibilidade polimórfica demonstrada em exemplos múltiplos.",
                                "Segurança de tipos mantida (sem runtime ClassCastException).",
                                "Eficiência: sem casts ou boxing desnecessários.",
                                "Clareza: código legível com comentários explicativos.",
                                "Cobertura: upper/lower bounds e integração em custom class."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Bounds como subconjuntos e hierarquias de tipos (teoria de conjuntos).",
                                "Design de Software: Princípios SOLID (Liskov Substitution com genéricos).",
                                "Algoritmos: Polimorfismo em sorting/searching com Comparable bounds.",
                                "Banco de Dados: Tipagem forte em queries genéricas (JPA/Hibernate).",
                                "Segurança da Informação: Restrições de tipo para prevenir injeções."
                              ],
                              "realWorldApplication": "Em bibliotecas como Apache Commons Collections ou Spring Data, bounds/wildcards garantem coleções tipadas seguras para processar dados heterogêneos (ex: relatórios financeiros somando Integers/Doubles sem erros de tipo), melhorando manutenibilidade em apps empresariais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.5",
                    "name": "Vantagens da Flexibilidade com Genéricos",
                    "description": "Benefícios como reutilização de código, type safety e suporte a tipagem estática ou dinâmica.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.5.1",
                        "name": "Reutilização de Código com Genéricos",
                        "description": "Os genéricos permitem criar estruturas de dados e algoritmos reutilizáveis para diferentes tipos de dados, evitando duplicação de código e promovendo manutenção eficiente em programação orientada a objetos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.1.1",
                            "name": "Identificar problemas de duplicação sem genéricos",
                            "description": "Analisar exemplos de classes ou métodos duplicados para diferentes tipos de dados, como listas para inteiros e strings, e reconhecer a necessidade de genéricos para unificar o código.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de duplicação de código",
                                  "subSteps": [
                                    "Defina duplicação de código como a repetição de lógica similar para tipos de dados diferentes, como métodos idênticos para inteiros e strings.",
                                    "Identifique características comuns: estruturas de loop, condições e operações semelhantes em classes separadas.",
                                    "Discuta impactos: dificuldade de manutenção, bugs inconsistentes e violação do princípio DRY (Don't Repeat Yourself).",
                                    "Compare com código único para múltiplos tipos usando exemplos não-programáticos, como receitas duplicadas para pratos semelhantes.",
                                    "Liste 3 exemplos cotidianos de duplicação para fixar o conceito."
                                  ],
                                  "verification": "Escreva uma definição pessoal de duplicação e cite 2 impactos negativos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Notebook para anotações, artigo sobre princípio DRY (buscar online).",
                                  "tips": "Use analogias reais para memorizar: pense em copiar-colar código como fotocopiar páginas de um livro com pequenas mudanças.",
                                  "learningObjective": "Reconhecer duplicação de código como problema de reutilização e manutenção.",
                                  "commonMistakes": "Confundir duplicação com sobrecarga de métodos; foque em lógica idêntica, não apenas nomes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar exemplos concretos de código duplicado",
                                  "subSteps": [
                                    "Examine código Java com classe IntList (métodos add, remove, size para int[]) e StringList similar para String[].",
                                    "Compare linha por linha: destaque loops for, verificações de bounds e retornos idênticos exceto pelo tipo.",
                                    "Crie uma tabela comparativa: colunas para IntList e StringList, linhas para métodos comuns.",
                                    "Simule adição de nova funcionalidade (ex: clear()): note como precisaria duplicar em ambas classes.",
                                    "Teste o código em um IDE para observar comportamento similar."
                                  ],
                                  "verification": "Marque em código impresso as seções duplicadas e explique semelhanças em voz alta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "IDE como IntelliJ ou Eclipse, exemplos de código IntList e StringList fornecidos.",
                                  "tips": "Use diff tools (como Beyond Compare) ou highlight syntax para visualizar duplicatas visualmente.",
                                  "learningObjective": "Detectar padrões de duplicação em classes para tipos primitivos e objetos.",
                                  "commonMistakes": "Ignorar diferenças sutis de tipo; foque na lógica subjacente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar com solução genérica e identificar necessidade",
                                  "subSteps": [
                                    "Refatore IntList e StringList para GenericList<T> usando <T> em declaração de classe e métodos.",
                                    "Analise mudanças: substituição de int[] por T[], casts removidos e type safety ganha.",
                                    "Teste GenericList<Integer> e GenericList<String> para confirmar unificação sem perda de funcionalidade.",
                                    "Discuta vantagens: uma classe mantém código para múltiplos tipos, facilita extensões futuras.",
                                    "Identifique cenários onde genéricos são essenciais: coleções, utilitários de dados."
                                  ],
                                  "verification": "Execute testes unitários em GenericList para ints e strings, confirmando resultados corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "IDE com JUnit, código refatorado para GenericList<T>.",
                                  "tips": "Compile sem warnings de tipo para validar type safety dos genéricos.",
                                  "learningObjective": "Reconhecer genéricos como solução para eliminar duplicação mantendo segurança de tipos.",
                                  "commonMistakes": "Esquecer bounds em genéricos (ex: <? extends>); comece com <T> simples."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação em novos cenários",
                                  "subSteps": [
                                    "Receba códigos aleatórios com duplicação (ex: StackInt vs StackString, ou processadores de arrays).",
                                    "Identifique duplicatas, proponha refatoração genérica e justifique.",
                                    "Crie seu próprio exemplo duplicado (ex: Queue para double e char) e resolva.",
                                    "Avalie trade-offs: quando NÃO usar genéricos (ex: tipos muito diferentes).",
                                    "Registre 3 casos reais de bibliotecas (ArrayList, HashMap) que usam genéricos."
                                  ],
                                  "verification": "Submeta 2 exemplos resolvidos com antes/depois e explicação da duplicação eliminada.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Exercícios impressos ou online (LeetCode-like), IDE para testes.",
                                  "tips": "Procure por 'código boilerplate' como sinal de duplicação iminente.",
                                  "learningObjective": "Aplicar detecção de duplicação independentemente em diversos contextos OO.",
                                  "commonMistakes": "Sobre-generalizar: nem toda similaridade precisa de genéricos; avalie custo-benefício."
                                }
                              ],
                              "practicalExample": "Considere duas classes duplicadas em Java:\n\nclass IntList {\n  private int[] data;\n  public void add(int item) { /* loop para adicionar */ }\n  public int get(int index) { /* bounds check e return */ }\n}\n\nclass StringList {\n  private String[] data;\n  public void add(String item) { /* loop idêntico exceto tipo */ }\n  public String get(int index) { /* bounds check idêntico */ }\n}\n\nProblema: Lógica de add/get repetida. Solução genérica:\n\nclass GenericList<T> {\n  private T[] data;\n  public void add(T item) { /* lógica única */ }\n  public T get(int index) { /* única */ }\n}\n\nUso: GenericList<Integer> ints = new GenericList<>();",
                              "finalVerifications": [
                                "Dado código duplicado, aponta corretamente as seções repetidas.",
                                "Explica por que genéricos unificam sem perda de type safety.",
                                "Identifica 3 impactos negativos da duplicação em manutenção.",
                                "Refatora exemplo simples para genérico sem erros de compilação.",
                                "Distingue duplicação real de variações legítimas de tipo.",
                                "Cita exemplo real de biblioteca (ex: ArrayList<T>)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de duplicação (90%+ acurácia).",
                                "Clareza na explicação da necessidade de genéricos.",
                                "Qualidade da refatoração proposta (compila e testa corretamente).",
                                "Profundidade na análise de impactos (manutenção, bugs).",
                                "Criatividade em exemplos práticos fornecidos.",
                                "Uso correto de terminologia OO e genéricos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstração e parametrização de funções genéricas.",
                                "Design de Software: Princípio DRY e SOLID (Single Responsibility).",
                                "Lógica Computacional: Reconhecimento de padrões e refatoração.",
                                "Inglês Técnico: Leitura de docs Java sobre generics."
                              ],
                              "realWorldApplication": "Em desenvolvimento de APIs e bibliotecas como Java Collections Framework (ArrayList<T>, HashMap<K,V>), genéricos eliminam duplicação para bilhões de linhas de código reutilizáveis, reduzindo erros em apps empresariais como bancos ou e-commerces."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.2",
                            "name": "Implementar classe genérica básica",
                            "description": "Criar uma classe genérica simples, como uma Stack<T> em linguagens como Java ou C#, ou usar TypeVar em Python, demonstrando reutilização para múltiplos tipos sem reescrita.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Genéricos",
                                  "subSteps": [
                                    "Estude a sintaxe básica de genéricos em Java (usando <T>) ou Python (usando TypeVar).",
                                    "Analise exemplos simples de classes não-genéricas vs. genéricas para entender reutilização.",
                                    "Identifique vantagens como type safety e eliminação de casting.",
                                    "Revise bounded types e wildcards se aplicável para genéricos básicos.",
                                    "Pratique declarando variáveis genéricas em um playground."
                                  ],
                                  "verification": "Explique em suas palavras o que é um genérico e por que ele promove reutilização, com um exemplo escrito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial do Java Generics (Oracle Docs)",
                                    "Editor de código como IntelliJ IDEA ou VS Code com extensão Java",
                                    "Playground online como JDoodle"
                                  ],
                                  "tips": "Comece com Java para clareza sintática; foque em <T> como placeholder para qualquer tipo.",
                                  "learningObjective": "Entender o conceito de genéricos e sua sintaxe básica para preparar a implementação.",
                                  "commonMistakes": [
                                    "Confundir genéricos com herança; lembrar que genéricos são para parametrização de tipos.",
                                    "Ignorar type erasure em Java (não afeta básicos)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a Estrutura da Classe Genérica",
                                  "subSteps": [
                                    "Crie uma nova classe chamada Stack<T>.",
                                    "Declare o tipo genérico <T> na assinatura da classe.",
                                    "Adicione campos privados como um ArrayList<T> para armazenar elementos.",
                                    "Defina um construtor vazio que inicialize a lista.",
                                    "Adicione getters básicos se necessário para inspeção."
                                  ],
                                  "verification": "Compile a classe sem erros e verifique se o IDE não reporta warnings de tipo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "JDK 8 ou superior",
                                    "IDE com suporte a Java (Eclipse ou IntelliJ)"
                                  ],
                                  "tips": "Use ArrayList<T> internamente para simplicidade; evite arrays crus devido a problemas de tipo.",
                                  "learningObjective": "Criar a declaração básica de uma classe genérica com campos tipados.",
                                  "commonMistakes": [
                                    "Esquecer o <T> na declaração da classe.",
                                    "Usar tipos concretos no campo em vez de T."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Métodos Básicos da Stack Genérica",
                                  "subSteps": [
                                    "Implemente o método push(T item) que adiciona à lista.",
                                    "Crie pop() que remove e retorna o topo como T (use isEmpty() check).",
                                    "Adicione peek() para ver o topo sem remover.",
                                    "Implemente isEmpty() e size() para utilitários.",
                                    "Garanta que todos os métodos usem T consistentemente."
                                  ],
                                  "verification": "Execute testes unitários simples para push/pop sem erros de compilação ou runtime.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "JUnit para testes (opcional, mas recomendado)",
                                    "Exemplo de código base de Stack não-genérica para comparação"
                                  ],
                                  "tips": "Sempre declare retornos e parâmetros com T; use generics no ArrayList methods.",
                                  "learningObjective": "Desenvolver funcionalidades principais mantendo type safety com genéricos.",
                                  "commonMistakes": [
                                    "Retornar Object em vez de T, exigindo cast.",
                                    "Não lidar com empty stack em pop() (lançar exceção ou retornar null)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar a Classe Genérica",
                                  "subSteps": [
                                    "Crie uma classe de teste com Stack<String> e Stack<Integer>.",
                                    "Execute operações push/pop/peek em ambos e imprima resultados.",
                                    "Verifique type safety: tente push de tipo errado e confirme erro de compilação.",
                                    "Teste edge cases como stack vazia e múltiplos elementos.",
                                    "Refatore se necessário para corrigir bugs."
                                  ],
                                  "verification": "Todos os testes passam, e o código compila sem warnings de unchecked generics.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Main class para demo",
                                    "JUnit ou main method para assertions manuais"
                                  ],
                                  "tips": "Use System.out.println para debug rápido; depois migre para asserts.",
                                  "learningObjective": "Demonstrar reutilização da classe com múltiplos tipos e validar type safety.",
                                  "commonMistakes": [
                                    "Ignorar erros de compilação em testes mistos.",
                                    "Usar raw types acidentalmente (Stack sem <T>)."
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente uma Stack<String> para gerenciar histórico de comandos em um editor de texto simples, e uma Stack<Integer> para simular pilha de chamadas em um interpretador de expressões matemáticas. Push 'undo', 'save'; pop verifica 'undo' como String. Para Integer: push 5, 3; pop retorna 3 sem casting.",
                              "finalVerifications": [
                                "A classe compila e executa sem erros para pelo menos dois tipos diferentes (ex: String e Integer).",
                                "Type safety é mantida: compilador rejeita push de tipo incompatível.",
                                "Métodos push/pop/peek funcionam corretamente em testes unitários.",
                                "Não há casts explícitos ou uso de Object/raw types.",
                                "A classe pode ser reutilizada sem duplicação de código para novos tipos.",
                                "Edge cases como empty stack são tratados adequadamente."
                              ],
                              "assessmentCriteria": [
                                "Correta declaração de genéricos na classe e métodos (type parameters consistentes).",
                                "Implementação funcional de Stack com operações básicas sem vazamentos de tipo.",
                                "Demonstração de reutilização com exemplos de múltiplos tipos.",
                                "Código limpo, com verificações de estado (ex: empty) e sem warnings.",
                                "Explicação clara da type safety alcançada.",
                                "Eficiência básica: O(1) para push/pop usando ArrayList."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstração de tipos semelhantes a variáveis em álgebra.",
                                "Design de Software: Introdução a padrões como Template Method via genéricos.",
                                "Lógica e Algoritmos: Estruturas de dados parametrizadas para algoritmos genéricos.",
                                "Inglês Técnico: Leitura de docs oficiais de linguagens para sintaxe precisa.",
                                "Física/Engenharia: Modelagem de pilhas em simulações (ex: pilha de placas tectônicas)."
                              ],
                              "realWorldApplication": "Bibliotecas padrão como java.util.Stack ou Collections usam genéricos para stacks, queues e maps reutilizáveis em apps empresariais, jogos (pilhas de estados), e frameworks web (gerenciamento de sessões), reduzindo bugs de tipo e código boilerplate."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.3",
                            "name": "Avaliar benefícios em manutenção",
                            "description": "Comparar o impacto na manutenção de código genérico versus não genérico, destacando redução de bugs e facilidade de extensão para novos tipos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar código não genérico e seus problemas de manutenção",
                                  "subSteps": [
                                    "Selecione um exemplo simples de estrutura de dados não genérica, como uma pilha (Stack) para inteiros.",
                                    "Identifique duplicações necessárias para outros tipos (ex: Stack para strings ou floats).",
                                    "Liste problemas comuns: erros de type casting, bugs por conversões manuais e dificuldade de extensão.",
                                    "Documente o número estimado de linhas de código duplicadas e potenciais pontos de falha.",
                                    "Registre cenários de manutenção, como correção de bug em um tipo afetando outros."
                                  ],
                                  "verification": "Lista completa de problemas de manutenção documentada com exemplos de código.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código (ex: IntelliJ ou VS Code), compilador Java ou equivalente.",
                                  "tips": "Comece com um exemplo minimalista para focar nos problemas essenciais.",
                                  "learningObjective": "Identificar os impactos negativos na manutenibilidade de código não genérico.",
                                  "commonMistakes": "Subestimar a duplicação de código ou ignorar erros sutis de type casting."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e analisar código genérico equivalente",
                                  "subSteps": [
                                    "Refatore o código não genérico para uma versão genérica usando tipos parametrizados (ex: Stack<T>).",
                                    "Teste a implementação com múltiplos tipos (int, String, Double) sem duplicação.",
                                    "Verifique a compilação e execução para garantir tipagem estática segura.",
                                    "Documente as mudanças: linhas removidas por eliminação de duplicatas.",
                                    "Simule uma pequena correção de bug na classe genérica e observe o impacto global."
                                  ],
                                  "verification": "Código genérico funcional testado com pelo menos 3 tipos diferentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de código, compilador Java, ferramenta de testes unitários (JUnit).",
                                  "tips": "Use generics bounded se necessário para restringir tipos e evitar erros.",
                                  "learningObjective": "Compreender como generics eliminam duplicação e melhoram a robustez.",
                                  "commonMistakes": "Esquecer verificações de tipo em runtime ou usar raw types acidentalmente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular cenários de extensão e manutenção comparativa",
                                  "subSteps": [
                                    "Adicione suporte a um novo tipo (ex: custom class User) no código não genérico e meça esforço (tempo/linhas).",
                                    "Faça o mesmo no código genérico e compare o esforço.",
                                    "Identifique redução de bugs: conte pontos potenciais de erro (casting, validações).",
                                    "Meça facilidade de extensão: tempo para adicionar suporte a 2 novos tipos.",
                                    "Registre métricas qualitativas: legibilidade e escalabilidade."
                                  ],
                                  "verification": "Relatório comparativo com métricas de tempo, linhas e bugs potenciais.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Cronômetro, planilha para métricas, editor de código.",
                                  "tips": "Use um timer real para medir esforço e anote observações imediatas.",
                                  "learningObjective": "Quantificar a facilidade de extensão e redução de bugs com generics.",
                                  "commonMistakes": "Não simular bugs reais ou superestimar simplicidade no não genérico."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e sintetizar benefícios globais",
                                  "subSteps": [
                                    "Compile métricas: % de redução em linhas de código, bugs e tempo de manutenção.",
                                    "Crie uma tabela comparativa destacando vantagens em cenários reais.",
                                    "Discuta trade-offs: complexidade inicial vs ganhos a longo prazo.",
                                    "Formule uma conclusão pessoal sobre quando usar generics para manutenção.",
                                    "Prepare um resumo executivo com recomendações."
                                  ],
                                  "verification": "Tabela comparativa e conclusão escrita com métricas quantitativas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha (Google Sheets ou Excel), exemplos de código finalizados.",
                                  "tips": "Use gráficos simples para visualizar reduções percentuais.",
                                  "learningObjective": "Sintetizar avaliação de benefícios em manutenção de forma estruturada.",
                                  "commonMistakes": "Focar só em qualitativo sem números ou ignorar custos iniciais de refatoração."
                                }
                              ],
                              "practicalExample": "Considere uma classe StackInt para inteiros: para suportar strings, crie StackString duplicando código (200 linhas totais, propenso a bugs em casting). Com Stack<T>, use Stack<String> diretamente (50 linhas únicas, sem duplicação, extensão instantânea e type-safe).",
                              "finalVerifications": [
                                "Explica com precisão a redução de bugs devido à eliminação de type casting manual.",
                                "Demonstra extensão para novo tipo em <5 minutos no genérico vs >15 no não genérico.",
                                "Apresenta tabela comparativa com métricas reais de linhas/bugs/tempo.",
                                "Identifica pelo menos 3 cenários onde manutenção genérica economiza esforço.",
                                "Conclui corretamente que generics reduzem custo de manutenção em 40-70%.",
                                "Verifica código genérico compilando sem warnings de raw types."
                              ],
                              "assessmentCriteria": [
                                "Precisão e profundidade na comparação de impactos (40%)",
                                "Uso correto de métricas quantitativas e qualitativas (25%)",
                                "Clareza na documentação e exemplos práticos (15%)",
                                "Identificação precisa de erros comuns e soluções (10%)",
                                "Síntese coerente de benefícios com trade-offs (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstração e parametrização semelhantes a funções genéricas em álgebra.",
                                "Gestão de Projetos: Análise de custo-benefício em manutenção de software.",
                                "Inglês Técnico: Leitura de documentação de APIs genéricas (Java Collections).",
                                "Design de Sistemas: Princípios de reutilização e escalabilidade em engenharia."
                              ],
                              "realWorldApplication": "Em bibliotecas enterprise como Java Collections Framework ou Spring Data, generics reduzem bugs em 50% e facilitam extensões para novos data types em aplicações de e-commerce, evitando recodificação para novos produtos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.2",
                        "name": "Type Safety com Genéricos",
                        "description": "Genéricos proporcionam verificação de tipos em tempo de compilação, prevenindo erros de tipo em runtime e garantindo robustez em estruturas de dados orientadas a objetos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.2.1",
                            "name": "Explicar detecção de erros em compile-time",
                            "description": "Descrever como genéricos evitam erros como inserção de tipo incompatível em uma coleção, usando exemplos de compilação falhando em Java ou C# antes da execução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Problemas de Type Safety em Coleções Não-Genéricas",
                                  "subSteps": [
                                    "Explique o conceito de coleções como ArrayList em Java sem genéricos (raw types).",
                                    "Crie um exemplo de código adicionando Strings e Integers à mesma lista.",
                                    "Compile e execute o código para observar ClassCastException em runtime ao recuperar elementos.",
                                    "Discuta por que o erro só é detectado durante a execução, não na compilação.",
                                    "Registre o stack trace do erro para análise."
                                  ],
                                  "verification": "Código compila sem erros, mas falha em runtime com ClassCastException ao iterar ou fazer cast.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE Java (IntelliJ ou Eclipse)",
                                    "JDK 8 ou superior"
                                  ],
                                  "tips": "Use System.out.println para imprimir elementos durante iteração e destacar o erro.",
                                  "learningObjective": "Identificar riscos de erros de tipo detectados apenas em runtime em coleções não-genéricas.",
                                  "commonMistakes": [
                                    "Assumir que o compilador detecta todos os erros de tipo.",
                                    "Não executar o código para ver o runtime error.",
                                    "Confundir ArrayList com arrays primitivos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Genéricos e Seu Papel em Type Safety",
                                  "subSteps": [
                                    "Defina genéricos como tipos parametrizados (ex: List<String>).",
                                    "Explique como o compilador usa inferência de tipos para verificar compatibilidade em compile-time.",
                                    "Compare raw types vs genéricos: mostre sintaxe List<String> lista = new ArrayList<>();.",
                                    "Discuta type erasure (em Java, genéricos são apagados em runtime, mas verificados antes).",
                                    "Refatore o código do Step 1 para usar genéricos e observe compilação bem-sucedida."
                                  ],
                                  "verification": "Código com genéricos compila sem warnings e executa sem erros de cast.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Mesma IDE e JDK do Step 1",
                                    "Documentação Oracle Java Generics"
                                  ],
                                  "tips": "Use <T> para entender parametrização; ative warnings de unchecked generics no IDE.",
                                  "learningObjective": "Entender como genéricos fornecem type safety verificado pelo compilador.",
                                  "commonMistakes": [
                                    "Ignorar type erasure e achar que tipos persistem em runtime.",
                                    "Usar tipos wildcards (*) prematuramente.",
                                    "Não refatorar código existente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar Detecção de Erros em Compile-Time com Exemplos",
                                  "subSteps": [
                                    "Tente adicionar Integer a uma List<String>: List<String> lista = new ArrayList<>(); lista.add(123);",
                                    "Observe erro de compilação: 'incompatible types: int cannot be converted to String'.",
                                    "Crie exemplo com métodos genéricos: void addToList(List<String> list, Object obj) – falha em compile se obj não for String.",
                                    "Teste em C#: List<string> list = new(); list.Add(123); – erro similar 'cannot convert int to string'.",
                                    "Analise mensagens de erro do compilador para mapear ao problema de tipo incompatível."
                                  ],
                                  "verification": "Código com tipo incompatível falha na compilação com erro claro de type mismatch.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE com suporte a Java e C# (VS Code com extensões)",
                                    "Compiladores javac ou dotnet build"
                                  ],
                                  "tips": "Copie erros de compilação exatos para discutir; use hover no IDE para type info.",
                                  "learningObjective": "Aplicar genéricos para forçar detecção precoce de erros de inserção incompatível.",
                                  "commonMistakes": [
                                    "Forçar casts para burlar o compilador (ex: lista.add((String)123)).",
                                    "Confundir erros de compilação com warnings.",
                                    "Não testar múltiplas linguagens para generalização."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Benefícios e Sintetizar Conceitos",
                                  "subSteps": [
                                    "Compare timelines: compile-time vs runtime errors em tabelas ou diagramas.",
                                    "Liste vantagens: prevenção de bugs, refatoração segura, IDE autocompletion melhor.",
                                    "Crie um exemplo híbrido: código que mistura raw e genéricos para mostrar warnings.",
                                    "Discuta limitações (ex: type erasure permite casts em runtime, mas previne comuns).",
                                    "Resuma em um diagrama: fluxo de verificação do compilador com genéricos."
                                  ],
                                  "verification": "Criar tabela ou diagrama explicando diferenças e benefícios corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama (Draw.io ou papel)",
                                    "Exemplos de código salvos"
                                  ],
                                  "tips": "Use @SuppressWarnings apenas como último recurso e justifique.",
                                  "learningObjective": "Sintetizar como genéricos shiftam detecção de erros para compile-time, melhorando robustez.",
                                  "commonMistakes": [
                                    "Superestimar genéricos como infalíveis em runtime.",
                                    "Ignorar legibilidade de código genérico complexo.",
                                    "Não mencionar cenários onde raw types ainda são usados."
                                  ]
                                }
                              ],
                              "practicalExample": "Java sem genéricos (runtime error):\nArrayList lista = new ArrayList();\nlista.add(\"Texto\");\nlista.add(123);\nfor(Object obj : lista) {\n  String s = (String) obj; // ClassCastException!\n}\n\nCom genéricos (compile error):\nList<String> lista = new ArrayList<>();\nlista.add(\"Texto\");\nlista.add(123); // Erro: incompatible types!\n\nC# similar: List<string> list = new(); list.Add(123); // Compile error.",
                              "finalVerifications": [
                                "Explica corretamente ClassCastException em raw types vs type mismatch em genéricos.",
                                "Fornece e executa exemplos de código que falham em compile-time.",
                                "Descreve mecanismo de verificação do compilador com genéricos.",
                                "Compara Java e C# em type safety.",
                                "Identifica pelo menos 3 benefícios da detecção em compile-time.",
                                "Cria diagrama ou tabela resumindo diferenças."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: explica type safety e compile-time detection (alto se sem erros).",
                                "Qualidade de exemplos: códigos executáveis e relevantes (completo com erros reais).",
                                "Profundidade de análise: cobre limitações como type erasure.",
                                "Clareza de comunicação: usa termos corretos e analogias simples.",
                                "Aplicação prática: demonstra refatoração de raw para genéricos.",
                                "Criatividade: inclui comparações cross-language ou diagramas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Tipos e Inferência Automática.",
                                "Engenharia de Software: Práticas de Debugging e Testes Unitários.",
                                "Lógica Computacional: Verificação Estática vs Dinâmica.",
                                "Design de Sistemas: Robustez e Manutenibilidade de Código."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software empresarial (ex: apps bancários em Java/Spring), genéricos previnem inserções erradas em coleções de transações ou usuários, evitando crashes em produção, reduzindo custos de debug e melhorando confiabilidade em sistemas de alta escala como e-commerces ou ERPs."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.2",
                            "name": "Comparar com casts não seguros",
                            "description": "Contrastar o uso de genéricos com coleções raw ou casts manuais, mostrando como type safety elimina ClassCastException em runtime.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Coleções Raw e Casts Manuais",
                                  "subSteps": [
                                    "Revise a sintaxe de coleções raw em Java, como List sem tipo (ex: List lista = new ArrayList();)",
                                    "Estude casts manuais: (String) obj para converter objetos em runtime",
                                    "Analise o contrato de type erasure em genéricos e como raw types ignoram tipos em runtime",
                                    "Leia documentação oficial da Oracle sobre raw types e warnings de compilador",
                                    "Identifique cenários comuns onde raw types são usados em código legado"
                                  ],
                                  "verification": "Resuma em 3 frases as diferenças entre raw types e genéricos; sem erros conceituais",
                                  "estimatedTime": "45 minutos",
                                  "materials": "JDK 8+, IDE (IntelliJ/Eclipse), JavaDoc para Collections",
                                  "tips": "Sempre compile com -Xlint:unchecked para ver warnings cedo",
                                  "learningObjective": "Compreender os riscos de type erasure em coleções raw",
                                  "commonMistakes": "Confundir compile-time safety com runtime checks; ignorar warnings de unchecked"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Demonstrar ClassCastException com Raw Types",
                                  "subSteps": [
                                    "Crie uma classe simples TestRaw com List raw: adicione String e Integer",
                                    "Implemente um método que itera e faz cast manual para String",
                                    "Execute o código e capture a ClassCastException em runtime",
                                    "Adicione try-catch para logar o stack trace e analisar o erro",
                                    "Teste com diferentes tipos para reproduzir falhas inconsistentes"
                                  ],
                                  "verification": "Código roda e gera ClassCastException; stack trace mostra linha exata do cast falho",
                                  "estimatedTime": "60 minutos",
                                  "materials": "IDE com debugger, JUnit para testes unitários",
                                  "tips": "Use debugger para pausar no momento do cast e inspecionar tipos reais",
                                  "learningObjective": "Reproduzir e diagnosticar erros runtime causados por falta de type safety",
                                  "commonMistakes": "Adicionar só tipos compatíveis acidentalmente; não rodar múltiplas vezes para inconsistências"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Genéricos para Type Safety",
                                  "subSteps": [
                                    "Refatore o código raw para List<String> e ArrayList<String>",
                                    "Remova todos os casts manuais; compile e verifique ausência de warnings",
                                    "Tente inserir Integer em List<String> e observe erro em compile-time",
                                    "Crie um teste JUnit que valida type safety em cenários de inserção/remoção",
                                    "Compare o bytecode com javap para ver type erasure, mas sem perda de safety"
                                  ],
                                  "verification": "Código com genéricos compila sem erros/warnings e rejeita tipos errados em compile-time",
                                  "estimatedTime": "50 minutos",
                                  "materials": "JUnit 5, javap tool do JDK",
                                  "tips": "Use <? extends String> para wildcards se aplicável, mas foque em bounded types simples",
                                  "learningObjective": "Aplicar genéricos para prevenir ClassCastException via compile-time checks",
                                  "commonMistakes": "Esquecer de parametrizar métodos genéricos; usar raw types em loops de iteração"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Analisar Diferenças",
                                  "subSteps": [
                                    "Crie side-by-side: código raw vs genérico em um documento ou IDE split-view",
                                    "Meça performance (negligível) e legibilidade com métricas simples (linhas de código)",
                                    "Discuta trade-offs: flexibilidade raw vs safety genéricos em cenários legacy",
                                    "Refatore um exemplo real de código open-source (ex: GitHub repo antigo)",
                                    "Documente lições em um relatório curto com prós/contras"
                                  ],
                                  "verification": "Relatório compara 3 exemplos: tempo de detecção de erro, linhas salvas, robustez",
                                  "estimatedTime": "40 minutos",
                                  "materials": "GitHub para exemplos reais, Markdown editor",
                                  "tips": "Use diff tools como Beyond Compare para visualização clara de mudanças",
                                  "learningObjective": "Contrastar benefícios de type safety genéricos vs riscos de casts raw",
                                  "commonMistakes": "Ignorar legibilidade; superestimar performance de raw types"
                                }
                              ],
                              "practicalExample": "Crie List raw: lista.add(\"Hello\"); lista.add(123); for(Object o : lista) { String s = (String)o; } // Boom! ClassCastException. Refatore para List<String>: lista.add(123); // Compile error! Safety ganha.",
                              "finalVerifications": [
                                "Explica type erasure sem erros",
                                "Reproduz ClassCastException em <2 min",
                                "Refatora raw para genérico sem warnings",
                                "Identifica 3 riscos de raw types",
                                "Compara safety em cenários mistos",
                                "Testa com JUnit passando todos"
                              ],
                              "assessmentCriteria": [
                                "Código raw gera runtime exception corretamente (100%)",
                                "Genérico compila sem warnings e rejeita tipos errados (100%)",
                                "Análise side-by-side cobre safety, legibilidade, erros (80%+)",
                                "Relatório tem exemplos concretos e lições aprendidas (90%+)",
                                "Tempo de refatoração <30% do tempo raw debugging",
                                "Uso correto de termos: type safety, erasure, unchecked"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Tipos (type theory em lógica)",
                                "Segurança da Informação: Prevenção de injeções via type checks",
                                "Engenharia de Software: Refatoração e debt técnico",
                                "Algoritmos: Estruturas de dados seguras em DS&A"
                              ],
                              "realWorldApplication": "Em sistemas bancários, genéricos previnem erros em listas de transações (String IDs vs Integers), evitando perdas financeiras por ClassCastExceptions em processamento batch de milhões de registros."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.3",
                            "name": "Aplicar type safety em exemplos práticos",
                            "description": "Implementar e testar uma estrutura genérica com tipos incorretos para observar falhas em compile-time, reforçando a segurança.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e criar classe genérica básica",
                                  "subSteps": [
                                    "Instale o TypeScript globalmente via npm: npm install -g typescript.",
                                    "Crie um novo diretório de projeto e inicialize um arquivo stack.ts.",
                                    "Defina uma classe genérica Stack<T> com um array privado para armazenar elementos e construtor vazio.",
                                    "Adicione método push(T item): void que adiciona ao array.",
                                    "Adicione método pop(): T | undefined que remove e retorna o último elemento."
                                  ],
                                  "verification": "Compile o arquivo com tsc stack.ts e verifique se não há erros de sintaxe.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Node.js, npm, editor de código (VS Code), terminal.",
                                  "tips": "Use <T> logo após o nome da classe para declarar o genérico.",
                                  "learningObjective": "Entender a sintaxe básica de genéricos em TypeScript.",
                                  "commonMistakes": "Esquecer o <T> na declaração da classe ou nos métodos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e testar uso correto com tipos específicos",
                                  "subSteps": [
                                    "Instancie Stack<string> e faça push de strings como 'apple', 'banana'.",
                                    "Implemente um método size(): number que retorna o comprimento do array.",
                                    "Teste pop() e console.log o resultado para verificar saída correta.",
                                    "Compile e execute com ts-node stack.ts para ver funcionamento.",
                                    "Adicione tipo Number: Stack<number> com pushes de 1, 2, 3 e teste pop()."
                                  ],
                                  "verification": "Execução sem erros de runtime e saídas corretas no console.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "ts-node (instale via npm install -g ts-node), stack.ts atualizado.",
                                  "tips": "Sempre especifique o tipo ao instanciar: new Stack<string>().",
                                  "learningObjective": "Demonstrar flexibilidade dos genéricos com tipos corretos.",
                                  "commonMistakes": "Misturar tipos na mesma instância, como push string em Stack<number>."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir erros de tipo para observar falhas em compile-time",
                                  "subSteps": [
                                    "Em Stack<string>, tente push(123) e compile com tsc.",
                                    "Observe o erro de type mismatch no editor ou terminal.",
                                    "Tente pop() em Stack<number> e atribuir a string: const s: string = stackNum.pop().",
                                    "Corrija removendo os erros e recompile para confirmar.",
                                    "Adicione comentário explicando cada erro observado."
                                  ],
                                  "verification": "TypeScript reporta erros de tipo antes da execução, sem runtime crashes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Mesmos do passo anterior, foco em tsc para compilação.",
                                  "tips": "Use o hover no VS Code para ver dicas de tipo em tempo real.",
                                  "learningObjective": "Visualizar como type safety previne erros em compile-time.",
                                  "commonMistakes": "Ignorar warnings do TypeScript ou forçar com any."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reforçar com exemplo complexo e reflexão",
                                  "subSteps": [
                                    "Crie Stack<Pair<string, number>> onde Pair é uma interface {first: string, second: number}.",
                                    "Implemente push de pares e teste violações como push({first: 123}).",
                                    "Adicione método peek(): T para ver topo sem remover.",
                                    "Compile, teste correto e incorreto, documente diferenças.",
                                    "Escreva um resumo de 3-5 linhas sobre benefícios observados."
                                  ],
                                  "verification": "Código complexo compila só com tipos corretos; resumo salvo em arquivo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "stack.ts expandido, interface Pair.",
                                  "tips": "Genéricos compostos aumentam reutilização sem sacrificar safety.",
                                  "learningObjective": "Aplicar type safety em cenários mais avançados.",
                                  "commonMistakes": "Definir genéricos aninhados incorretamente, como Stack<T<U>> sem necessidade."
                                }
                              ],
                              "practicalExample": "Implemente uma Stack<string> para palavras e tente push(42); o TypeScript impedirá em compile-time, evitando erro runtime como '42' + 'apple' = '42apple'.",
                              "finalVerifications": [
                                "Código compila sem erros apenas com tipos corretos.",
                                "Tentativas de push/pop com tipos errados geram erros de compilação claros.",
                                "Execução de casos corretos produz saídas esperadas no console.",
                                "Resumo reflete compreensão de type safety vs. runtime errors.",
                                "Estrutura genérica é reutilizável para múltiplos tipos.",
                                "Nenhum uso de 'any' ou supressão de erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na declaração e uso de genéricos <T>.",
                                "Identificação e explicação de pelo menos 3 erros de tipo.",
                                "Funcionalidade completa da Stack (push, pop, size, peek).",
                                "Testes cobrem casos corretos e incorretos.",
                                "Reflexão demonstra benefícios da type safety.",
                                "Código limpo, comentado e compilável."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstrações genéricas semelhantes a funções polimórficas.",
                                "Lógica e Algoritmos: Estruturas de dados seguras para pilhas/filas.",
                                "Design de Software: Princípios SOLID (abstração e reutilização).",
                                "Segurança da Informação: Prevenção de injeções de tipo inválido."
                              ],
                              "realWorldApplication": "Em frameworks como React (genéricos em hooks como useState<T>) ou APIs REST (respostas tipadas com Axios<T>), previne bugs caros em produção, como dados incorretos em bancos ou UIs quebradas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.3",
                        "name": "Suporte a Tipagem Estática e Dinâmica",
                        "description": "Genéricos oferecem flexibilidade em linguagens de tipagem estática (como Java/C++) e dinâmica (como Python com type hints), adaptando-se a diferentes paradigmas de verificação de tipos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.3.1",
                            "name": "Diferenciar genéricos em tipagem estática",
                            "description": "Explorar genéricos em linguagens estáticas como templates em C++ ou generics em Java, enfatizando verificação rigorosa em compile-time.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Tipagem Estática e Genéricos",
                                  "subSteps": [
                                    "Defina tipagem estática: verificação de tipos durante a compilação, antes da execução.",
                                    "Explique genéricos como parâmetros de tipo que permitem código reutilizável sem perda de segurança de tipos.",
                                    "Compare com tipagem dinâmica: em linguagens como Python, verificação ocorre em runtime.",
                                    "Identifique exemplos iniciais: <T> em Java ou template<typename T> em C++.",
                                    "Discuta erasure em Java (type erasure) vs metaprogramação em C++."
                                  ],
                                  "verification": "Escreva uma definição curta e explique a diferença entre genéricos estáticos e dinâmicos em 2 frases.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial Java Generics (Oracle)",
                                    "Documentação C++ Templates (cppreference.com)",
                                    "Editor de código como IntelliJ ou VS Code"
                                  ],
                                  "tips": "Use diagramas para visualizar parâmetros de tipo como placeholders resolvidos em compile-time.",
                                  "learningObjective": "Dominar conceitos básicos de genéricos em tipagem estática versus dinâmica.",
                                  "commonMistakes": [
                                    "Confundir genéricos com herança de classes.",
                                    "Acreditar que genéricos em Java mantêm tipos em runtime após erasure.",
                                    "Ignorar diferenças entre templates C++ (expansão completa) e generics Java."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Genéricos em Java",
                                  "subSteps": [
                                    "Crie uma classe genérica simples: public class Box<T> { private T value; }.",
                                    "Implemente métodos genéricos com bounded types: <T extends Number> para restrições.",
                                    "Compile código com erros de tipo intencionalmente (ex: Box<String> box = new Box<Integer>()) e observe falhas em compile-time.",
                                    "Analise wildcards: ? extends T e ? super T para flexibilidade.",
                                    "Teste com coleções: List<String> vs raw List para ver warnings de tipo."
                                  ],
                                  "verification": "Compile um programa Java com genéricos e corrija um erro de tipo reportado pelo compilador.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "JDK instalado",
                                    "IDE com suporte Java (Eclipse/IntelliJ)",
                                    "Exemplos de código de generics de baeldung.com"
                                  ],
                                  "tips": "Sempre declare tipos explícitos para evitar raw types e warnings.",
                                  "learningObjective": "Aplicar genéricos Java e entender verificação rigorosa em compile-time.",
                                  "commonMistakes": [
                                    "Usar raw types em vez de parametrizados.",
                                    "Esquecer type erasure leva a supor verificação runtime.",
                                    "Confundir bounded wildcards com generics simples."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Templates em C++",
                                  "subSteps": [
                                    "Defina template function: template<typename T> T max(T a, T b) { return a > b ? a : b; }.",
                                    "Crie template class: template<class T> class Vector { ... };.",
                                    "Observe expansão de templates: múltiplas instâncias geradas em compile-time para cada tipo.",
                                    "Experimente SFINAE (Substitution Failure Is Not An Error) para metaprogramação condicional.",
                                    "Compile código com mismatch de tipos e veja erros detalhados de template."
                                  ],
                                  "verification": "Escreva e compile uma função template C++ para diferentes tipos, confirmando zero erros de tipo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Compilador GCC/Clang",
                                    "VS Code com C++ extension",
                                    "Livro 'C++ Templates' de Vandevoorde (capítulos iniciais)"
                                  ],
                                  "tips": "Use typename vs class em templates; teste com tipos não-pod para depuração.",
                                  "learningObjective": "Implementar e diferenciar templates C++ de genéricos Java pela expansão completa.",
                                  "commonMistakes": [
                                    "Esquecer template keyword em especializações.",
                                    "Confundir templates com macros (templates são type-safe).",
                                    "Ignorar overhead de compilação por expansão."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar e Sintetizar Vantagens da Verificação Compile-Time",
                                  "subSteps": [
                                    "Compare Java generics (erasure, verificação parcial runtime) vs C++ templates (full type info, zero runtime cost).",
                                    "Liste vantagens: catch erros cedo, performance (no boxing), polimorfismo paramétrico.",
                                    "Crie tabela comparativa: compile-time checks, duck typing absence, expressividade.",
                                    "Discuta limitações: Java heap pollution vs C++ code bloat.",
                                    "Aplique em código híbrido conceitual: refatore função genérica para estática."
                                  ],
                                  "verification": "Crie uma tabela ou parágrafo resumindo 5 diferenças chave entre genéricos Java/C++.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou Markdown para tabela",
                                    "Exemplos comparativos de stackoverflow"
                                  ],
                                  "tips": "Foco em compile-time: 'se não compila, não roda com erros de tipo'.",
                                  "learningObjective": "Diferenciar precisamente genéricos em tipagem estática e suas vantagens.",
                                  "commonMistakes": [
                                    "Subestimar type erasure em Java como 'menos poderoso'.",
                                    "Confundir genéricos com templates como idênticos.",
                                    "Ignorar contextos de uso: Java para JVM, C++ para performance."
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente uma pilha genérica em Java: public class Stack<T> { private java.util.ArrayList<T> elements = new java.util.ArrayList<>(); public void push(T item) { elements.add(item); } public T pop() { return elements.remove(elements.size()-1); } }. Tente push('a') em Stack<Integer> – erro em compile-time. Em C++: template<typename T> class Stack { std::vector<T> elements; public: void push(const T& item) { elements.push_back(item); } T pop() { T top = elements.back(); elements.pop_back(); return top; } }; – expansão garante type-safety total.",
                              "finalVerifications": [
                                "Explique type erasure em Java e ausência em C++ templates.",
                                "Identifique e corrija 3 erros comuns de genéricos em código fornecido.",
                                "Compare compile-time vs runtime type checks com exemplos.",
                                "Liste 3 vantagens de genéricos estáticos sobre dinâmicos.",
                                "Crie um snippet genérico funcional em Java e C++.",
                                "Discuta quando usar bounded types ou SFINAE."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas sem confusões com dinâmica.",
                                "Exemplos práticos: código compilável e demonstrando verificação compile-time.",
                                "Diferenciação clara: tabela ou lista comparando Java vs C++.",
                                "Profundidade: menção a erasure, expansão, wildcards/SFINAE.",
                                "Aplicação: refatoração de código não-genérico para genérico.",
                                "Análise de erros: identificação de common mistakes em cenários reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Tipos e Abstração Paramétrica (como polimorfismo em álgebra).",
                                "Design de Software: Padrões de Projeto Genéricos (ex: Iterator em STL).",
                                "Segurança da Informação: Verificação Estática previne injeções de tipo inválido.",
                                "Engenharia de Software: Otimização de Performance via Compile-Time Resolution.",
                                "Lógica Computacional: Metaprogramação como Prova em Compile-Time."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software de alto desempenho, como engines de jogos (Unreal em C++ templates para containers otimizados) ou aplicações empresariais (Spring Boot Java generics para DI e coleções type-safe), genéricos estáticos garantem código reutilizável, erros detectados cedo e zero overhead runtime, reduzindo bugs em produção em bibliotecas como Java Collections Framework ou C++ STL."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.3.2",
                            "name": "Usar genéricos em tipagem dinâmica",
                            "description": "Implementar genéricos com TypeVar e type hints em Python, demonstrando suporte opcional a type safety via ferramentas como mypy.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender TypeVar e Conceitos Básicos de Genéricos",
                                  "subSteps": [
                                    "Leia a documentação oficial do módulo typing sobre TypeVar e Generic.",
                                    "Estude exemplos simples de TypeVar em funções, como def identity[T](arg: T) -> T.",
                                    "Compare genéricos com funções sem type hints para entender a flexibilidade.",
                                    "Experimente inferência de tipos em um REPL Python com type hints genéricos.",
                                    "Anote as diferenças entre tipagem estática (mypy) e dinâmica (runtime Python)."
                                  ],
                                  "verification": "Você pode explicar verbalmente ou por escrito o que TypeVar faz e dar um exemplo simples.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Python 3.10+ instalado",
                                    "Documentação typing: https://docs.python.org/3/library/typing.html#typevar"
                                  ],
                                  "tips": "Comece com exemplos curtos para evitar sobrecarga; foque na abstração de tipos.",
                                  "learningObjective": "Compreender como TypeVar permite definir tipos parametrizados para maior flexibilidade.",
                                  "commonMistakes": "Confundir TypeVar com variáveis reais; esquecer que é apenas para type hints, não runtime."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Função Genérica com Type Hints",
                                  "subSteps": [
                                    "Crie uma função identity que usa TypeVar: from typing import TypeVar; T = TypeVar('T'); def identity(arg: T) -> T: return arg.",
                                    "Teste a função com diferentes tipos (int, str, list) no runtime.",
                                    "Adicione mais type hints a uma função como first_element(lista: list[T]) -> T.",
                                    "Execute o código sem erros de runtime e observe a inferência de tipos no IDE.",
                                    "Salve o código em um arquivo .py para testes futuros."
                                  ],
                                  "verification": "A função aceita e retorna valores de tipos diferentes sem erros em runtime.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Python REPL ou Jupyter Notebook"
                                  ],
                                  "tips": "Use print(type(arg)) para depurar inferência; evite casts desnecessários.",
                                  "learningObjective": "Aplicar TypeVar em funções para suportar tipagem dinâmica com hints opcionais.",
                                  "commonMistakes": "Esquecer de importar TypeVar; usar TypeVar sem atribuir a uma variável como T."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Genéricos em Classes e Estruturas de Dados",
                                  "subSteps": [
                                    "Defina uma classe genérica simples: class Stack[T]: def __init__(self): self.items: list[T] = [].",
                                    "Implemente métodos push e pop com type hints: def push(self, item: T) -> None; def pop(self) -> T.",
                                    "Instancie a classe com tipos específicos: int_stack = Stack[int](); str_stack = Stack[str]()",
                                    "Teste push/pop com valores mistos para demonstrar flexibilidade dinâmica.",
                                    "Adicione docstrings explicando o uso genérico."
                                  ],
                                  "verification": "Classes instanciadas com diferentes tipos funcionam corretamente no runtime.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Mesmo ambiente do step anterior",
                                    "Exemplos de código de stacks genéricos"
                                  ],
                                  "tips": "Mantenha a classe minimalista primeiro; expanda só após testes básicos.",
                                  "learningObjective": "Estender genéricos para classes, simulando estruturas de dados OO flexíveis.",
                                  "commonMistakes": "Não herdar de Generic[T]; atribuir lista sem type hint genérico."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Type Safety com mypy e Demonstração Dinâmica",
                                  "subSteps": [
                                    "Instale mypy: pip install mypy.",
                                    "Execute mypy no seu código: mypy seu_arquivo.py --strict.",
                                    "Introduza um erro intencional (ex: pop() -> int em Stack[str]) e corrija após falha.",
                                    "Compare output com/ sem type hints para mostrar suporte opcional.",
                                    "Documente um relatório curto: 'Runtime OK, mypy flags type errors'."
                                  ],
                                  "verification": "mypy passa sem erros no código correto e detecta violações intencionais.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "mypy instalado",
                                    "Terminal para rodar mypy"
                                  ],
                                  "tips": "Use --strict para rigor; ignore erros de bibliotecas com # type: ignore se necessário.",
                                  "learningObjective": "Demonstrar como genéricos adicionam type safety opcional via mypy em tipagem dinâmica.",
                                  "commonMistakes": "Executar mypy sem salvar arquivo; confundir warnings runtime com type checkers."
                                }
                              ],
                              "practicalExample": "Crie uma função genérica get_first_item(container: Sequence[T]) -> T que retorna o primeiro item de qualquer sequência (list, tuple, etc.). Teste com lista de ints e strings: mypy verifica tipos, mas Python roda dinamicamente com qualquer iterable.",
                              "finalVerifications": [
                                "Código executa sem erros de runtime em múltiplos tipos.",
                                "mypy --strict passa sem erros de tipagem.",
                                "Inferência de tipos funciona em IDE (ex: autocomplete para T).",
                                "Exemplo prático demonstra flexibilidade dinâmica.",
                                "Relatório documenta diferenças entre runtime e static check."
                              ],
                              "assessmentCriteria": [
                                "Correto uso de TypeVar e Generic em funções/classes (100% dos exemplos).",
                                "Sem erros mypy em código válido; detecção em inválido.",
                                "Submissão inclui testes com 3+ tipos diferentes.",
                                "Explicação clara de type safety opcional.",
                                "Código limpo, com docstrings e type hints completos.",
                                "Tempo total respeitado com eficiência."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstrações genéricas semelhantes a funções polimórficas ou tipos parametrizados.",
                                "Design de Software: Padrões como Template Method para flexibilidade.",
                                "Lógica e Algoritmos: Genéricos em estruturas como árvores/binárias.",
                                "Inglês Técnico: Leitura de docs Python/typing."
                              ],
                              "realWorldApplication": "Em bibliotecas como FastAPI ou Pydantic, genéricos com TypeVar permitem APIs flexíveis que aceitam qualquer tipo serializável, com mypy garantindo safety em desenvolvimento, enquanto Python roda dinamicamente em produção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.3.3",
                            "name": "Avaliar trade-offs entre tipagens",
                            "description": "Discutir vantagens de flexibilidade em cenários mistos, como projetos multiplataforma, comparando performance e legibilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de tipagem estática e dinâmica",
                                  "subSteps": [
                                    "Defina tipagem estática (ex: TypeScript, Java) e tipagem dinâmica (ex: JavaScript, Python).",
                                    "Liste características principais: verificação em compile-time vs runtime.",
                                    "Identifique exemplos de linguagens híbridas com genéricos (ex: TypeScript com any/unknown).",
                                    "Compare sintaxe básica em um editor de código.",
                                    "Registre prós e contras iniciais em uma tabela."
                                  ],
                                  "verification": "Criar uma tabela comparativa com pelo menos 5 características de cada tipo de tipagem.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Documentação oficial de TypeScript e JavaScript; editor de código como VS Code.",
                                  "tips": "Use diagramas visuais para diferenciar compile-time e runtime.",
                                  "learningObjective": "Diferenciar tipagem estática e dinâmica, entendendo seus mecanismos de verificação.",
                                  "commonMistakes": "Confundir tipagem fraca (JS) com dinâmica; ignorar overhead de runtime em dinâmica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar flexibilidade em cenários mistos multiplataforma",
                                  "subSteps": [
                                    "Identifique cenários mistos: apps web/mobile compartilhando código (React Native com TS/JS).",
                                    "Implemente um genérico simples em TypeScript para uma lista heterogênea.",
                                    "Teste migração de código JS puro para TS parcial em um projeto React.",
                                    "Analise como genéricos suportam bibliotecas de terceiros sem tipagem.",
                                    "Documente cenários onde flexibilidade é essencial (ex: plugins dinâmicos)."
                                  ],
                                  "verification": "Desenvolver um snippet de código multiplataforma usando genéricos que compile em TS e rode em JS.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Ambiente Node.js; repositório GitHub com boilerplate React Native; TypeScript playground.",
                                  "tips": "Comece com 'any' e refine para genéricos para ver ganhos graduais.",
                                  "learningObjective": "Aplicar genéricos para habilitar flexibilidade em projetos multiplataforma mistos.",
                                  "commonMistakes": "Sobrecarregar genéricos desnecessariamente, perdendo benefícios da tipagem estática."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar impacto na performance",
                                  "subSteps": [
                                    "Meça tempo de compilação em TS vs JS para um módulo médio.",
                                    "Benchmark execução runtime: loops com arrays tipados vs untilpados (use Node.js perf).",
                                    "Analise overhead de genéricos em alocação de memória.",
                                    "Teste em cenários multiplataforma: build para web vs mobile.",
                                    "Grave métricas em gráfico comparativo."
                                  ],
                                  "verification": "Gerar relatório com benchmarks mostrando diferenças de performance em pelo menos 3 testes.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Ferramentas de benchmark como Benchmark.js; Node.js; Chrome DevTools para profiling.",
                                  "tips": "Repita testes 10x para médias confiáveis; isole variáveis.",
                                  "learningObjective": "Quantificar trade-offs de performance entre tipagens estática/dinâmica.",
                                  "commonMistakes": "Ignorar otimizações JIT em JS moderno; testar apenas casos pequenos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar legibilidade, manutenção e trade-offs finais",
                                  "subSteps": [
                                    "Revise código de steps anteriores com um peer review simulado.",
                                    "Meça legibilidade: tempo para entender funções tipadas vs untilpadas.",
                                    "Discuta manutenção: refatoração em TS vs JS para mudanças de API.",
                                    "Sintetize trade-offs em uma matriz decisão (performance x legibilidade x flexibilidade).",
                                    "Aplique a um caso real: decida tipagem para um app compartilhado."
                                  ],
                                  "verification": "Produzir uma matriz de trade-offs com recomendações para 2 cenários hipotéticos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Ferramentas de linting (ESLint + TS); planilha Google Sheets para matriz.",
                                  "tips": "Use métricas subjetivas como 'linhas de erro por refatoração'.",
                                  "learningObjective": "Balancear legibilidade e flexibilidade contra performance em decisões de tipagem.",
                                  "commonMistakes": "Priorizar performance absoluta ignorando contexto de equipe/projeto."
                                }
                              ],
                              "practicalExample": "Em um app React Native multiplataforma (iOS/Android/Web), use genéricos em TypeScript para um hook de dados que aceita API responses variadas (JSON/XML). Compare: versão JS roda 10% mais rápido em runtime mas gera 50% mais erros de tipo em refatorações; TS adiciona 20s ao build mas previne bugs em integrações cross-platform.",
                              "finalVerifications": [
                                "Explicar verbalmente trade-offs para um projeto multiplataforma específico.",
                                "Modificar código existente trocando tipagem sem quebrar funcionalidade.",
                                "Identificar 3 cenários onde dinâmica é preferível apesar de perda de performance.",
                                "Benchmark reproduzível mostrando diferenças mensuráveis.",
                                "Matriz de decisão preenchida com pesos personalizados.",
                                "Relatório escrito de 300 palavras sintetizando aprendizados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção de impactos em performance (métricas quantitativas).",
                                "Profundidade na análise de legibilidade com exemplos código.",
                                "Relevância de cenários mistos multiplataforma.",
                                "Equilíbrio nos trade-offs, sem viés para uma tipagem.",
                                "Criatividade em conexões com flexibilidade via genéricos.",
                                "Clareza na matriz de decisão e verificações finais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização e análise de complexidade (Big O em genéricos).",
                                "Economia: Trade-offs custo-benefício em decisões de design.",
                                "Língua Portuguesa: Argumentação clara em discussões técnicas.",
                                "Física/Engenharia: Analogia com materiais flexíveis vs rígidos em estruturas."
                              ],
                              "realWorldApplication": "Em equipes de desenvolvimento ágil para apps como e-commerces multiplataforma (ex: Shopify apps), avaliar tipagem permite adotar TS híbrido: flexibilidade para integrações rápidas de vendors dinâmicos, mantendo legibilidade para equipes grandes e performance otimizada via tree-shaking."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.7",
                "name": "Tratamento de Exceções",
                "description": "Mecanismos para capturar e tratar exceções em programas OO.",
                "totalSkills": 49,
                "atomicTopics": [
                  {
                    "id": "10.1.7.1",
                    "name": "Conceito de Exceções",
                    "description": "Definição de exceções como objetos que representam erros em programas orientados a objetos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.1.1.1",
                        "name": "Definição Fundamental de Exceção",
                        "description": "Compreensão da exceção como um objeto que representa condições de erro inesperadas durante a execução de um programa orientado a objetos, interrompendo o fluxo normal e permitindo recuperação ou propagação.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.1.1.1",
                            "name": "Definir o conceito de exceção",
                            "description": "Explicar que uma exceção é um objeto instanciado de uma classe específica que encapsula detalhes sobre um erro runtime, como mensagem, tipo e stack trace, em linguagens OO como Python ou C++.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender erros runtime em programação",
                                  "subSteps": [
                                    "Identifique a diferença entre erros de sintaxe (compile-time) e erros runtime.",
                                    "Execute um programa simples que falhe em runtime, como divisão por zero.",
                                    "Observe o que acontece quando um erro runtime ocorre sem tratamento.",
                                    "Registre o output padrão de um erro não tratado em Python ou C++.",
                                    "Discuta por que erros runtime precisam ser gerenciados para robustez."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre compile-time e runtime errors, com um exemplo executado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de código (VS Code ou IDLE), Python instalado",
                                  "tips": "Sempre rode o código em um ambiente de teste para observar falhas reais.",
                                  "learningObjective": "Diferenciar erros runtime de outros tipos e reconhecer sua natureza imprevisível.",
                                  "commonMistakes": "Confundir exceções com erros de sintaxe; ignorar que runtime errors param a execução."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir exceção como objeto em programação OO",
                                  "subSteps": [
                                    "Leia a definição oficial de exceção em documentação Python (built-in exceptions).",
                                    "Entenda que exceções são instâncias de classes derivadas de Exception base.",
                                    "Compare com C++: exceções derivam de std::exception.",
                                    "Crie um diagrama mental: Exceção = Objeto com dados sobre erro.",
                                    "Explique por que usar objetos permite herança e polimorfismo no tratamento."
                                  ],
                                  "verification": "Desenhe ou descreva um diagrama de classes simples para exceções em OO.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação Python (docs.python.org), papel/caneta para diagrama",
                                  "tips": "Pense em exceções como 'pacotes de erro' enviados pelo runtime.",
                                  "learningObjective": "Reconhecer exceções como objetos instanciados de classes específicas em linguagens OO.",
                                  "commonMistakes": "Pensar em exceções como apenas strings ou números; ignorar o aspecto orientado a objetos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar componentes principais de uma exceção",
                                  "subSteps": [
                                    "Identifique os atributos: tipo (classe), mensagem (str), stack trace (trajeto de chamadas).",
                                    "Em Python, capture uma exceção com try/except e inspecione seus atributos (e.g., exc.type, exc.args).",
                                    "Em C++ , use what() para mensagem e examine stack via debugger.",
                                    "Liste exemplos: ValueError (tipo), 'invalid literal' (msg), traceback (stack).",
                                    "Pratique printando detalhes completos de uma exceção capturada."
                                  ],
                                  "verification": "Capture e imprima detalhes de uma exceção em código funcional, mostrando tipo, msg e stack.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código, Python/C++ compiler, debugger opcional (pdb ou gdb)",
                                  "tips": "Use print(exc.__class__.__name__), exc.args e traceback.print_exc().",
                                  "learningObjective": "Listar e descrever os detalhes encapsulados: mensagem, tipo e stack trace.",
                                  "commonMistakes": "Confundir stack trace com código fonte; achar que todas exceções têm os mesmos atributos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar o conceito completo de exceção",
                                  "subSteps": [
                                    "Resuma: Exceção = objeto de classe que encapsula erro runtime (tipo + msg + stack).",
                                    "Compare exceções built-in vs custom em Python/C++.",
                                    "Crie uma definição pessoal em 1 parágrafo.",
                                    "Discuta vantagens: padronização, propagação via throw/raise.",
                                    "Teste conhecimento respondendo a 3 perguntas sobre exceções."
                                  ],
                                  "verification": "Escreva uma definição precisa e responda corretamente a perguntas de auto-teste.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Folha de anotações, exemplos de código dos steps anteriores",
                                  "tips": "Inclua 'runtime' e 'OO' na definição para precisão.",
                                  "learningObjective": "Formular uma definição holística e acionável do conceito de exceção.",
                                  "commonMistakes": "Omitir 'objeto instanciado' ou 'encapsula detalhes'; generalizar demais."
                                }
                              ],
                              "practicalExample": "Em Python: try: x = int('abc') except ValueError as e: print(type(e))  # <class 'ValueError'> print(e)  # invalid literal for int() print(e.__traceback__)  # stack trace. Isso demonstra exceção como objeto com tipo, msg e stack.",
                              "finalVerifications": [
                                "Pode definir exceção em suas palavras, incluindo 'objeto de classe' e 'runtime'?",
                                "Identifica corretamente tipo, mensagem e stack trace em um exemplo real?",
                                "Diferencia exceção de erro simples ou return code?",
                                "Explica por que exceções são usadas em linguagens OO?",
                                "Reconstrói um exemplo básico de exceção capturada?",
                                "Lista 3 exceções built-in comuns em Python/C++?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição: menciona objeto, classe, runtime, componentes chave (20%)",
                                "Compreensão de OO: relaciona herança e instância (20%)",
                                "Exemplos concretos: usa código ou output real (20%)",
                                "Diferenciação: distingue de outros mecanismos de erro (15%)",
                                "Clareza e completude: cobre todos elementos sem omissões (15%)",
                                "Aplicação: liga a tratamento de exceções (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Debugging e análise de stack traces (Computação > Debugging)",
                                "Design de classes e herança (Programação OO > Herança)",
                                "Lógica e fluxogramas de controle de erros (Algoritmos > Controle de Fluxo)",
                                "Gestão de riscos em software (Engenharia de Software > Qualidade)"
                              ],
                              "realWorldApplication": "Em aplicações web (ex: Flask/Django), exceções capturam erros como input inválido, logando stack trace para devs diagnosticarem falhas em produção sem crashar o serviço, garantindo apps robustos como sites de e-commerce."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.1.2",
                            "name": "Diferenciar exceções de erros comuns",
                            "description": "Distinguir exceções (objetos tratáveis e propagáveis) de erros de sintaxe ou lógicos que impedem a compilação/execução, destacando o papel das exceções em cenários runtime.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender erros de sintaxe e lógicos",
                                  "subSteps": [
                                    "Estude a definição de erro de sintaxe: violações das regras gramaticais da linguagem que impedem a compilação.",
                                    "Analise erros lógicos: código compila e executa, mas produz resultados incorretos devido a falhas no raciocínio.",
                                    "Identifique exemplos comuns: falta de ponto e vírgula, variáveis não declaradas ou loops infinitos.",
                                    "Compile e execute códigos com esses erros para observar mensagens de falha.",
                                    "Registre as diferenças entre falhas de compilação e execução inicial."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito 3 exemplos de erros de sintaxe e lógicos, incluindo mensagens de erro típicas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Documentação oficial da linguagem (Python/Java)"
                                  ],
                                  "tips": "Sempre leia a mensagem de erro completa; ela indica linha e tipo de problema.",
                                  "learningObjective": "Identificar e classificar erros que impedem compilação ou causam resultados errados sem runtime exceptions.",
                                  "commonMistakes": [
                                    "Confundir erro lógico com exceção runtime",
                                    "Ignorar warnings do compilador"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o conceito de exceções em runtime",
                                  "subSteps": [
                                    "Defina exceção: evento runtime recuperável, como divisão por zero ou arquivo não encontrado.",
                                    "Estude hierarquia de exceções (ex: Exception em Java/Python como classe base).",
                                    "Observe que exceções são objetos propagáveis via stack trace.",
                                    "Execute código que gera exceções sem tratamento para ver o comportamento padrão.",
                                    "Compare com erros não exceções: exceções permitem continuidade via try-catch."
                                  ],
                                  "verification": "Gere uma exceção intencional e descreva seu stack trace, confirmando que é runtime.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Referência de exceções da linguagem (docs.python.org ou oracle.com/java)"
                                  ],
                                  "tips": "Use print ou debugger para inspecionar o tipo da exceção antes de tratá-la.",
                                  "learningObjective": "Reconhecer exceções como objetos tratáveis que ocorrem durante execução normal.",
                                  "commonMistakes": [
                                    "Tratar exceções como bugs irrecuperáveis",
                                    "Confundir checked com unchecked exceptions"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar diferenças fundamentais entre exceções e erros comuns",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: compilação (erros sim/não), propagação, tratabilidade.",
                                    "Analise cenários: sintaxe impede execução total; exceção permite recuperação parcial.",
                                    "Estude papel das exceções: sinalizar condições esperadas mas anormais (ex: input inválido).",
                                    "Discuta quando usar assert para erros lógicos vs throw para exceções.",
                                    "Teste códigos mistos para diferenciar na prática."
                                  ],
                                  "verification": "Preencha uma tabela comparativa com 5 cenários, justificando classificações.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Exemplos de código preparados"
                                  ],
                                  "tips": "Lembre: exceções são para runtime; erros de sintaxe/lógica são para fase de desenvolvimento.",
                                  "learningObjective": "Diferenciar precisamente exceções propagáveis de erros bloqueantes.",
                                  "commonMistakes": [
                                    "Classificar todas falhas runtime como exceções",
                                    "Ignorar contexto de compilação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar diferenciação em exemplos reais de código",
                                  "subSteps": [
                                    "Escreva código com erro de sintaxe e corrija-o.",
                                    "Implemente código com erro lógico e depure-o.",
                                    "Crie código que lança exceção e adicione try-catch básico.",
                                    "Analise logs de um app real com mix de erros e exceções.",
                                    "Crie um quiz pessoal: classifique 10 snippets de código."
                                  ],
                                  "verification": "Submeta 3 códigos corrigidos/classificados com explicações.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Snippets de exemplo online (GitHub)"
                                  ],
                                  "tips": "Use debugger stepwise para ver onde o fluxo para (compilação vs runtime).",
                                  "learningObjective": "Aplicar diferenciação em cenários práticos de programação OOP.",
                                  "commonMistakes": [
                                    "Usar try-catch para erros de sintaxe",
                                    "Não propagar exceções quando necessário"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: Erro de sintaxe: `print('Olá mundo'` (faltando parêntese) -> SyntaxError na compilação. Exceção: `resultado = 10 / 0` -> ZeroDivisionError em runtime, capturável por `try: ... except ZeroDivisionError: print('Divisão inválida')`.",
                              "finalVerifications": [
                                "Classifique corretamente 5 tipos de falhas como exceção ou erro comum.",
                                "Explique o stack trace de uma exceção vs mensagem de compilação.",
                                "Identifique cenários onde exceções são preferíveis a asserts.",
                                "Diferencie checked vs unchecked exceptions em linguagens como Java.",
                                "Crie um diagrama de fluxo para tratamento vs correção de erros.",
                                "Descreva o impacto de não tratar exceções em um app."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção: 90% acerto em classificações.",
                                "Uso correto de terminologia (runtime, compilação, propagável).",
                                "Exemplos relevantes e códigos funcionais.",
                                "Análise de stack trace e mensagens de erro.",
                                "Conexão com conceitos OOP (exceções como objetos).",
                                "Criatividade em cenários práticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Tratamento de indefinidos como divisão por zero.",
                                "Lógica e Filosofia: Distinção entre erros irrecuperáveis e condições contingentes.",
                                "Engenharia de Software: Práticas de debugging e resiliência.",
                                "Ciência de Dados: Análise de logs de exceções em pipelines."
                              ],
                              "realWorldApplication": "Em aplicativos bancários, diferenciar erro de sintaxe (corrigir no deploy) de exceção como 'saldo insuficiente' (tratar com mensagem amigável, evitando crash e melhorando UX)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.1.3",
                            "name": "Identificar cenários de exceções",
                            "description": "Reconhecer situações comuns que geram exceções, como divisão por zero, acesso a índice inválido ou falha de I/O, representadas como objetos em programas OO.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Fundamental de Exceções em Programação OO",
                                  "subSteps": [
                                    "Defina exceção como um evento que interrompe o fluxo normal de execução devido a erros previsíveis.",
                                    "Explique que em OO, exceções são objetos derivados de classes base como Exception.",
                                    "Diferencie exceções de erros fatais, focando em situações recuperáveis.",
                                    "Estude a hierarquia de classes de exceções em linguagens como Java ou Python.",
                                    "Identifique que exceções encapsulam informações como mensagem, causa e stack trace."
                                  ],
                                  "verification": "Resuma em suas palavras o que é uma exceção OO e liste 3 características principais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial de exceções (Java/Python)",
                                    "Diagrama de hierarquia de classes Exception"
                                  ],
                                  "tips": "Use analogias como 'exceções são como alarmes de segurança em um prédio'.",
                                  "learningObjective": "Entender exceções como objetos que representam erros em OO.",
                                  "commonMistakes": [
                                    "Confundir exceções com bugs irrecuperáveis",
                                    "Ignorar que exceções são instâncias de classes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Cenários Comuns que Geram Exceções",
                                  "subSteps": [
                                    "Liste cenários matemáticos: divisão por zero (ArithmeticException).",
                                    "Analise acessos inválidos: índice fora de bounds em arrays/listas (IndexOutOfBoundsException).",
                                    "Explore falhas de I/O: arquivo não encontrado (FileNotFoundException) ou falha de leitura.",
                                    "Considere entradas inválidas: conversão de string para número inválida (NumberFormatException).",
                                    "Registre outros: NullPointerException ao acessar objeto nulo."
                                  ],
                                  "verification": "Crie uma tabela com 5 cenários comuns, exceções associadas e exemplos breves.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de exceções comuns da linguagem escolhida",
                                    "Exemplos de código snippet"
                                  ],
                                  "tips": "Agrupe cenários por categoria: aritmética, coleção, I/O, entrada usuário.",
                                  "learningObjective": "Reconhecer padrões de situações que tipicamente lançam exceções.",
                                  "commonMistakes": [
                                    "Focar só em uma linguagem, ignorar generalidades",
                                    "Listar erros raros em vez de comuns"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Representação de Exceções como Objetos em Código",
                                  "subSteps": [
                                    "Examine código que lança exceções intencionalmente, como 10 / 0.",
                                    "Observe como capturar e inspecionar o objeto exceção: print(exception.message).",
                                    "Compare stack traces de diferentes exceções para ver padrões.",
                                    "Pratique modificando código para forçar exceções específicas.",
                                    "Discuta como exceções propagam na pilha de chamadas."
                                  ],
                                  "verification": "Execute 3 códigos que lancem exceções diferentes e descreva o objeto gerado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE com debugger (VS Code, IntelliJ)",
                                    "Códigos de exemplo prontos"
                                  ],
                                  "tips": "Use try-catch para capturar e logar detalhes do objeto exceção.",
                                  "learningObjective": "Visualizar exceções como objetos manipuláveis em runtime.",
                                  "commonMistakes": [
                                    "Não executar o código, só ler",
                                    "Ignorar detalhes do stack trace"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação de Cenários de Exceções em Programas Reais",
                                  "subSteps": [
                                    "Revise um código existente e marque linhas propensas a exceções.",
                                    "Simule cenários: forneça entradas inválidas e observe exceções.",
                                    "Crie fluxogramas mostrando onde exceções podem ocorrer.",
                                    "Debata com pares: 'Essa linha pode lançar exceção? Por quê?'",
                                    "Documente 5 potenciais exceções em um programa simples."
                                  ],
                                  "verification": "Submeta um relatório com 5 identificações corretas em código fornecido.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código de exemplo complexo (app de console com I/O e listas)",
                                    "Ferramenta de linting"
                                  ],
                                  "tips": "Pense em 'o que se der errado?' para cada operação crítica.",
                                  "learningObjective": "Aplicar conhecimento para prever exceções em código OO.",
                                  "commonMistakes": [
                                    "Sobrestimar robustez de código",
                                    "Marcar linhas seguras como perigosas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: lista = [1,2,3]; print(lista[5])  # Lança IndexError (objeto com msg 'list index out of range'). Ou: resultado = 10 / 0  # ZeroDivisionError. Capturar: try: ... except ZeroDivisionError as e: print(e)  # Mostra objeto exceção.",
                              "finalVerifications": [
                                "Lista corretamente 5 cenários comuns de exceções com exemplos.",
                                "Explica como exceções são objetos em OO com hierarquia de classes.",
                                "Identifica exceções em código fornecido sem erros.",
                                "Diferencia exceções recuperáveis de erros fatais.",
                                "Descreve stack trace de uma exceção executada.",
                                "Propõe prevenções básicas para 3 cenários."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de cenários (90%+ acerto).",
                                "Profundidade na descrição de exceções como objetos.",
                                "Qualidade dos exemplos práticos e verificações.",
                                "Completude dos steps com subSteps detalhados.",
                                "Criatividade em conexões e aplicações reais.",
                                "Clareza e estruturação lógica do raciocínio."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Divisão por zero e domínios de funções.",
                                "Lógica: Análise de casos edge em algoritmos.",
                                "Física/Engenharia: Modelagem de falhas em sistemas (fault tolerance).",
                                "Inglês: Leitura de documentação de APIs de exceções."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, identificar cenários de exceções previne crashes em apps bancários (evita divisão por zero em cálculos financeiros), jogos (índice inválido em levels) ou servidores web (falhas I/O em uploads), garantindo robustez e experiência usuário fluida."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.1.1.2",
                        "name": "Exceções como Objetos Orientados a Objetos",
                        "description": "Análise das exceções como instâncias de classes que herdam de uma hierarquia base (ex: Exception em Python ou std::exception em C++), explorando encapsulamento, herança e polimorfismo.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.1.2.1",
                            "name": "Reconhecer exceções como instâncias de classes",
                            "description": "Identificar que exceções são objetos com atributos (mensagem, causa) e métodos (toString, getMessage), permitindo tratamento polimórfico via herança em POO.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de exceções como objetos",
                                  "subSteps": [
                                    "Leia a documentação oficial sobre a hierarquia de exceções em Java (Throwable, Exception e RuntimeException).",
                                    "Identifique que todas as exceções são subclasses da classe Throwable.",
                                    "Observe que exceções são instâncias de classes, criadas com 'new'.",
                                    "Compare com objetos comuns, como String ou ArrayList.",
                                    "Anote a diferença entre exceções checked e unchecked."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito que exceções são objetos instanciados de classes específicas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Java (java.lang.Throwable)",
                                    "IDE com console (Eclipse ou IntelliJ)"
                                  ],
                                  "tips": "Use diagramas de herança para visualizar melhor a estrutura.",
                                  "learningObjective": "Reconhecer que exceções herdam de Throwable e são objetos orientados a objetos.",
                                  "commonMistakes": [
                                    "Pensar que exceções são apenas 'erros' primitivos sem estrutura de classe.",
                                    "Confundir com funções de throw sem instância."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar atributos comuns das exceções",
                                  "subSteps": [
                                    "Crie uma instância de NullPointerException e acesse seu atributo 'message' via getMessage().",
                                    "Investigue o atributo 'cause' em exceções encadeadas.",
                                    "Use debug em uma IDE para inspecionar o estado interno de uma exceção.",
                                    "Compare atributos de diferentes exceções (ex: IOException vs ArithmeticException).",
                                    "Registre os valores dos atributos em um log simples."
                                  ],
                                  "verification": "Capture uma exceção e imprima seus atributos (message e cause) corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE com debugger",
                                    "Código de exemplo com throw new NullPointerException()"
                                  ],
                                  "tips": "Sempre use try-catch para capturar e inspecionar sem crashar o programa.",
                                  "learningObjective": "Identificar e acessar atributos como message e cause em objetos de exceção.",
                                  "commonMistakes": [
                                    "Ignorar que atributos podem ser nulos.",
                                    "Acessar atributos diretamente sem getters (violando encapsulamento)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar métodos disponíveis em exceções",
                                  "subSteps": [
                                    "Chame métodos como getMessage(), toString() e printStackTrace() em uma exceção capturada.",
                                    "Compare a saída de toString() com getMessage().",
                                    "Crie uma exceção customizada e sobrescreva toString().",
                                    "Teste getCause() em exceções com causa encadeada (initCause()).",
                                    "Documente o polimorfismo ao tratar diferentes exceções com o mesmo catch."
                                  ],
                                  "verification": "Implemente um bloco try-catch que demonstre o uso de pelo menos 3 métodos de exceção.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação de Exception (getMessage, toString)",
                                    "Código fonte de exceções built-in"
                                  ],
                                  "tips": "Use System.out.println(e) para ver toString() automático.",
                                  "learningObjective": "Utilizar métodos padrão de exceções e entender seu comportamento polimórfico.",
                                  "commonMistakes": [
                                    "Confundir getMessage() com printStackTrace().",
                                    "Não tratar null em getCause()."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reconhecer herança e tratamento polimórfico",
                                  "subSteps": [
                                    "Crie uma hierarquia customizada: MinhaExcecao extends Exception.",
                                    "Lance e capture polimorficamente com catch(Exception e).",
                                    "Demonstre que subclasses compartilham métodos da superclasse.",
                                    "Teste instanceof para verificar tipo de exceção em runtime.",
                                    "Refatore código para usar catch genérico com casting se necessário."
                                  ],
                                  "verification": "Escreva código que trate uma exceção customizada e built-in de forma polimórfica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE para compilação",
                                    "Exemplo de código com herança de Exception"
                                  ],
                                  "tips": "Sempre prefira catch mais específicos antes do genérico.",
                                  "learningObjective": "Aplicar conceitos de herança POO no tratamento de exceções.",
                                  "commonMistakes": [
                                    "Usar catch(Object) em vez de Exception.",
                                    "Esquecer de chamar super() no construtor customizado."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe Calculadora que lança NullPointerException ao dividir por zero (simulando). Capture em try-catch, acesse e.getMessage(), e.toString() e e.printStackTrace(). Estenda com MinhaDivisaoZeroException extends ArithmeticException, sobrescreva getMessage() para mensagem customizada, e trate polimorficamente.",
                              "finalVerifications": [
                                "Explicar que exceções são instâncias de classes filhas de Throwable.",
                                "Listar e demonstrar 3 atributos/métodos comuns.",
                                "Criar e tratar uma exceção customizada via herança.",
                                "Identificar polimorfismo em catch(Exception e).",
                                "Debugar e inspecionar estado de uma exceção.",
                                "Diferenciar exceções checked de unchecked."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de exceções como objetos com herança.",
                                "Correta listagem e uso de atributos (message, cause).",
                                "Demonstração funcional de métodos (getMessage, toString).",
                                "Implementação de código polimórfico sem erros.",
                                "Explicação clara de tratamento via POO.",
                                "Ausência de confusões com primitivos ou funções."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica de conjuntos e hierarquias (herança como subconjuntos).",
                                "Língua Portuguesa: Análise de estruturas textuais (mensagens de erro como strings).",
                                "Física/Engenharia: Modelagem de falhas em sistemas (exceções como eventos de erro).",
                                "Lógica Computacional: Árvores de decisão para tratamento de exceções."
                              ],
                              "realWorldApplication": "Em aplicações empresariais como bancos ou e-commerces, permite capturar erros genéricos (catch(Exception)) e logs detalhados via getMessage/printStackTrace, facilitando debug e manutenção escalável de software robusto."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.1.1.2.2",
                            "name": "Descrever a hierarquia de classes de exceções",
                            "description": "Explicar a estrutura hierárquica de exceções, com classes base como Throwable (Java) ou Exception (Python/C++), subclasses como IOException ou ValueError, usando UML para modelagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar as Classes Base das Exceções",
                                  "subSteps": [
                                    "Pesquise a documentação oficial de Java (Throwable), Python (BaseException) e C++ (std::exception).",
                                    "Anote as classes raiz: Throwable (Java) herda de Object; BaseException (Python); exception (C++).",
                                    "Registre que Throwable se divide em Error e Exception.",
                                    "Compare como Python usa Exception como principal, com subclasses como ValueError.",
                                    "Liste 3 exemplos de exceções derivadas em cada linguagem."
                                  ],
                                  "verification": "Crie uma tabela comparativa das classes base com pelo menos 3 linguagens, confirmando herança via código ou docs.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Oracle Java",
                                    "Python docs exceptions",
                                    "C++ std::exception reference",
                                    "Bloco de notas ou Google Docs"
                                  ],
                                  "tips": "Use Ctrl+F nas docs para buscar 'hierarchy' ou 'inheritance tree'.",
                                  "learningObjective": "Compreender as raízes comuns da hierarquia de exceções em OOP.",
                                  "commonMistakes": [
                                    "Confundir Throwable com Exception como base única",
                                    "Ignorar diferenças entre linguagens",
                                    "Não verificar herança oficial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear a Hierarquia Principal: Checked vs Unchecked",
                                  "subSteps": [
                                    "Desenhe um diagrama simples: Throwable > Exception > IOException (checked) e RuntimeException (unchecked).",
                                    "Identifique subclasses: em Java, checked (IOException, SQLException); unchecked (NullPointerException).",
                                    "Em Python, note ValueError (checked-like) vs KeyboardInterrupt (unchecked-like).",
                                    "Em C++, explore std::runtime_error vs std::logic_error.",
                                    "Classifique 5 exceções comuns em cada categoria."
                                  ],
                                  "verification": "Desenhe um fluxograma ou árvore textual mostrando checked/unchecked com 4 exemplos por ramo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama como draw.io ou papel/lápis",
                                    "Código IDE para herança (Eclipse/VSCode)",
                                    "Referências de API"
                                  ],
                                  "tips": "Lembre: checked exigem try-catch/compilação; unchecked são runtime.",
                                  "learningObjective": "Diferenciar e hierarquizar exceções gerenciadas vs não gerenciadas.",
                                  "commonMistakes": [
                                    "Misturar checked/unchecked",
                                    "Omitir RuntimeException como subclasse de Exception",
                                    "Aplicar regras Java a Python diretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Subclasses Específicas e Herança Profunda",
                                  "subSteps": [
                                    "Escolha uma exceção como IOException: trace herança completa (Exception > IOException > FileNotFoundException).",
                                    "Repita para Python: Exception > ValueError > UnicodeError.",
                                    "Para C++: std::exception > std::ios_base::failure > std::ofstream::failure.",
                                    "Compile uma lista de 10 exceções com profundidade de herança (níveis).",
                                    "Teste em código: instancie e capture para validar hierarquia."
                                  ],
                                  "verification": "Execute código que lança/captura exceções em cadeia, imprimindo getClass().getSuperclass().",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "IDE com Java/Python/C++",
                                    "Snippets de código de teste",
                                    "Javadoc/Pydoc"
                                  ],
                                  "tips": "Use instanceof em loops para printar hierarquia real em runtime.",
                                  "learningObjective": "Traçar caminhos completos de herança em exceções específicas.",
                                  "commonMistakes": [
                                    "Parar na superficialidade (ex: só IOException sem pais)",
                                    "Confundir nomes semelhantes entre linguagens",
                                    "Não testar com código"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Modelar a Hierarquia com UML",
                                  "subSteps": [
                                    "Crie um diagrama de classes UML mostrando Throwable como raiz, com setas de herança.",
                                    "Inclua generalização (triângulo branco) para subclasses como Exception, Error.",
                                    "Adicione estereótipos: <<checked>>, <<unchecked>>.",
                                    "Compare UML para Python/C++ em diagramas separados.",
                                    "Valide o diagrama gerando código skeleton de uma hierarquia custom."
                                  ],
                                  "verification": "Compartilhe o UML e gere código compilável de uma exceção custom herdando corretamente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "draw.io, Lucidchart ou PlantUML",
                                    "PlantUML online editor",
                                    "IDE para gerar código de diagrama"
                                  ],
                                  "tips": "Use notação UML padrão: classe retangular, seta com triângulo para herança.",
                                  "learningObjective": "Representar visualmente a hierarquia OOP de exceções.",
                                  "commonMistakes": [
                                    "Usar seta errada (composição vs herança)",
                                    "Esquecer multiplicidade ou visibilidade",
                                    "Ignorar pacotes/namespaces"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app Java de leitura de arquivo: modelar hierarquia UML de IOException > FileNotFoundException. Código: try { new FileInputStream(nonExistentFile); } catch (FileNotFoundException e) { System.out.println(e.getClass().getSuperclass()); // IOException } catch (IOException e) { ... } – demonstre capturando em níveis hierárquicos.",
                              "finalVerifications": [
                                "Lista completa da hierarquia Throwable/Exception com 5+ subclasses corretas.",
                                "Diagrama UML validado com herança precisa.",
                                "Código funcional testando instanceof em cadeia de exceções.",
                                "Tabela comparativa Java/Python/C++ sem erros.",
                                "Explicação oral ou escrita de checked vs unchecked.",
                                "Custom exception herdando corretamente e lançada/caçada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na herança (100% match com docs oficiais).",
                                "Completude: cobre base, principal e subclasses profundas.",
                                "Clareza visual no UML (notação padrão, legível).",
                                "Validação prática via código (compila e executa).",
                                "Comparação multi-linguagem relevante.",
                                "Detalhes em substeps acionáveis e verificáveis."
                              ],
                              "crossCurricularConnections": [
                                "Modelagem UML: Design de Software e Engenharia.",
                                "Herança OOP: Programação Orientada a Objetos geral.",
                                "Árvores hierárquicas: Estruturas de Dados (árvores).",
                                "Classificação taxonômica: Biologia (reinos, filos).",
                                "Debugging e logging: Manutenção de Sistemas."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software enterprise, entender hierarquia permite handlers genéricos (catch Exception captura tudo checked), otimiza debugging (trace stack hierárquico), e custom exceptions em APIs robustas como Spring Boot ou Django, reduzindo crashes em produção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.1.1.2.3",
                            "name": "Exemplificar criação de exceção customizada",
                            "description": "Demonstrar a criação de uma classe de exceção personalizada herdando de uma base, adicionando atributos encapsulados, em contextos como Python ou C++.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a hierarquia de exceções em Python",
                                  "subSteps": [
                                    "Leia a documentação oficial do Python sobre exceções built-in (https://docs.python.org/3/tutorial/errors.html).",
                                    "Identifique a classe base Exception e suas subclasses comuns como ValueError e TypeError.",
                                    "Desenhe um diagrama simples da hierarquia de exceções para visualizar herança.",
                                    "Crie um script simples que levante uma exceção built-in para observar o comportamento.",
                                    "Analise o código fonte de uma exceção built-in usando inspect module."
                                  ],
                                  "verification": "Capacidade de explicar verbalmente ou por escrito a hierarquia de exceções e listar 3 subclasses de Exception.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Python oficial",
                                    "Editor de código como VS Code ou PyCharm",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use o módulo inspect.getmro(Exception) para ver a ordem de resolução de métodos.",
                                  "learningObjective": "Compreender a estrutura OOP das exceções em Python para herdar corretamente.",
                                  "commonMistakes": [
                                    "Confundir Exception com BaseException",
                                    "Ignorar que nem todas as exceções são subclasses de Exception"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a classe de exceção customizada básica",
                                  "subSteps": [
                                    "Crie um arquivo novo chamado custom_exception.py.",
                                    "Defina uma classe MinhaExcecao que herde de Exception: class MinhaExcecao(Exception): pass",
                                    "Salve e execute um teste simples: raise MinhaExcecao('Erro customizado')",
                                    "Capture a exceção com try-except para confirmar que funciona.",
                                    "Adicione uma mensagem padrão no __str__ method para personalização básica."
                                  ],
                                  "verification": "Código roda sem erros e levanta a exceção customizada corretamente ao ser instanciada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Interpretador Python 3.8+"
                                  ],
                                  "tips": "Sempre passe uma mensagem na super().__init__ para herdar comportamento padrão.",
                                  "learningObjective": "Criar uma exceção mínima herdada que se comporte como as built-in.",
                                  "commonMistakes": [
                                    "Esquecer de chamar super().__init__()",
                                    "Não importar Exception explicitamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar atributos encapsulados e construtor personalizado",
                                  "subSteps": [
                                    "Adicione atributos privados como self._codigo_erro e self._detalhes.",
                                    "Implemente __init__(self, mensagem, codigo_erro, detalhes): super().__init__(mensagem); self._codigo_erro = codigo_erro; etc.",
                                    "Crie getters como @property def codigo_erro(self): return self._codigo_erro",
                                    "Sobrescreva __str__ para incluir todos os atributos: return f'{super().__str__()} - Código: {self._codigo_erro}'",
                                    "Teste instanciando com argumentos: MinhaExcecao('Erro', 404, 'Recurso não encontrado')"
                                  ],
                                  "verification": "Instância da exceção acessa atributos via getters e exibe informações completas ao ser impressa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Python REPL para testes rápidos"
                                  ],
                                  "tips": "Use propriedades (@property) para encapsulamento sem quebrar compatibilidade com except.",
                                  "learningObjective": "Implementar encapsulamento OOP em exceções com atributos customizados.",
                                  "commonMistakes": [
                                    "Expor atributos públicos sem getters",
                                    "Não inicializar super().__init__() no construtor"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e testar a exceção em um contexto prático",
                                  "subSteps": [
                                    "Crie um script de exemplo: função validar_idade(idade) que levanta MinhaExcecao se idade < 18.",
                                    "Use os atributos: MinhaExcecao('Idade inválida', 'VAL001', f'Idade {idade} abaixo do mínimo')",
                                    "Implemente try-except para capturar, logar atributos e re-levar se necessário.",
                                    "Adicione unit tests com unittest: test_raise_custom(), test_attributes_access().",
                                    "Execute todos os testes e verifique saídas esperadas."
                                  ],
                                  "verification": "Todos os testes passam e o programa trata a exceção mostrando atributos corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Biblioteca unittest (built-in)",
                                    "Editor com suporte a testes"
                                  ],
                                  "tips": "Log exceções com logging module para rastreabilidade em produção.",
                                  "learningObjective": "Aplicar a exceção customizada em cenários reais de validação.",
                                  "commonMistakes": [
                                    "Não testar com valores de borda",
                                    "Capturar Exception em vez da customizada específica"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Refinar e documentar a exceção customizada",
                                  "subSteps": [
                                    "Adicione docstrings à classe e métodos: '''Exceção para validações customizadas.'''",
                                    "Crie um exemplo de uso comentado no topo do arquivo.",
                                    "Compare com exceções em C++ (throw std::runtime_error) para insights cross-language.",
                                    "Refatore para múltiplos níveis de herança se aplicável (ex: ValidacaoExcecao(MinhaExcecao)).",
                                    "Publique o código em um gist ou repo para revisão."
                                  ],
                                  "verification": "Código está documentado, roda sem warnings e é reutilizável.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramentas de linting como pylint",
                                    "Git para versionamento"
                                  ],
                                  "tips": "Siga PEP 8 para naming e PEP 257 para docstrings.",
                                  "learningObjective": "Produzir código de exceção customizada production-ready e documentado.",
                                  "commonMistakes": [
                                    "Docstrings vagas",
                                    "Não considerar herança múltipla desnecessária"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de gerenciamento de biblioteca, crie InvalidBookException('Livro inválido', 'BK001', 'ISBN duplicado') ao tentar cadastrar um livro com ISBN existente. No try-except, logue o código e detalhes, e retorne mensagem amigável ao usuário.",
                              "finalVerifications": [
                                "Pode criar e levantar exceção customizada com atributos extras.",
                                "Acessa atributos encapsulados via getters sem quebrar except blocks.",
                                "Testes unitários cobrem raise, catch e atributos.",
                                "Exceção herda e estende comportamento de Exception built-in.",
                                "Código é legível, documentado e segue boas práticas OOP.",
                                "Funciona em contextos reais como validação de input."
                              ],
                              "assessmentCriteria": [
                                "Correção na herança e inicialização do construtor (30%)",
                                "Encapsulamento adequado de atributos com getters/setters (25%)",
                                "Integração e testes práticos funcionais (20%)",
                                "Documentação e tratamento de erros comuns (15%)",
                                "Eficiência e reusabilidade do código (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Design de Software: Padrões como Exception Handling em camadas de aplicação.",
                                "Debugging e Testing: Uso em TDD com pytest/unittest.",
                                "Segurança da Informação: Exceções seguras sem vazamento de dados sensíveis.",
                                "Lógica e Estruturas de Dados: Tratamento de erros em algoritmos.",
                                "Inglês Técnico: Leitura de docs Python e padrões OOP internacionais."
                              ],
                              "realWorldApplication": "Bibliotecas como Django/Flask usam exceções customizadas (ex: ValidationError) para validações de formulários; em APIs REST, para erros HTTP 4xx com payloads customizados; em jogos, para estados inválidos como PlayerOutOfLivesException."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.1.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.1.1.3",
                        "name": "Propósito e Características das Exceções",
                        "description": "Entendimento do objetivo das exceções em promover código robusto, com características como propagação na pilha de chamadas e informações diagnósticas detalhadas.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.1.3.1",
                            "name": "Explicar o propósito das exceções em POO",
                            "description": "Descrever como exceções permitem separação de lógica de erro do fluxo principal, melhorando manutenibilidade e reutilização em aplicações OO robustas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o tratamento tradicional de erros em código",
                                  "subSteps": [
                                    "Analise um exemplo de código sem exceções, usando estruturas if-else para verificar erros como divisão por zero ou arquivo inexistente.",
                                    "Identifique como a lógica de erro se mistura com o fluxo principal do programa.",
                                    "Execute o código e observe o emaranhamento que dificulta a leitura e manutenção.",
                                    "Registre as desvantagens: código verboso, difícil de reutilizar e propenso a falhas.",
                                    "Compare com fluxos normais sem erros para destacar o impacto."
                                  ],
                                  "verification": "Criar um diagrama de fluxo mostrando o emaranhamento de ifs e confirmar com autoavaliação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código (ex: VS Code), exemplos de código em Java ou Python sem exceções.",
                                  "tips": "Use print statements para visualizar caminhos de erro durante execução.",
                                  "learningObjective": "Reconhecer como o tratamento tradicional polui o código principal.",
                                  "commonMistakes": "Subestimar o impacto na legibilidade, focando apenas em funcionalidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o conceito básico de exceções em POO",
                                  "subSteps": [
                                    "Defina exceção como um evento que interrompe o fluxo normal para sinalizar erro.",
                                    "Estude hierarquia de exceções em uma linguagem OO (ex: Exception em Java/Python).",
                                    "Examine sintaxe básica: throw para lançar e try-catch para capturar.",
                                    "Execute um código simples que lança e captura uma exceção.",
                                    "Explique verbalmente o desvio do fluxo principal para bloco de tratamento."
                                  ],
                                  "verification": "Escrever e executar um código que lança uma exceção personalizada e capturar corretamente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Documentação oficial da linguagem (ex: Oracle Java Docs), compilador/interpreter.",
                                  "tips": "Comece com exceções built-in como ArithmeticException para simplicidade.",
                                  "learningObjective": "Entender exceções como mecanismo de sinalização de erros em POO.",
                                  "commonMistakes": "Confundir exceções com retornos de erro (ex: códigos de status)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a separação de lógica de erro do fluxo principal",
                                  "subSteps": [
                                    "Refatore o código do Step 1 usando try-catch para isolar tratamento de erros.",
                                    "Compare visualmente os dois códigos: destaque a clareza no fluxo principal.",
                                    "Trace a execução: observe como exceções propagam até serem tratadas.",
                                    "Discuta princípio SOLID relacionado (Single Responsibility Principle).",
                                    "Teste cenários de erro e normal para validar isolamento."
                                  ],
                                  "verification": "Apresentar side-by-side os códigos refatorados e não-refatorados com anotações.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Dois arquivos de código comparativos, debugger do IDE.",
                                  "tips": "Use comentários para marcar seções de lógica principal vs. erro.",
                                  "learningObjective": "Demonstrar como exceções separam responsabilidades no código.",
                                  "commonMistakes": "Capturar exceções muito genericamente, perdendo especificidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar benefícios para manutenibilidade e reutilização",
                                  "subSteps": [
                                    "Modifique o código refatorado: adicione nova funcionalidade sem alterar tratamentos de erro.",
                                    "Crie uma função reutilizável que lança exceções para outros módulos.",
                                    "Avalie cenários: depuração mais fácil, escalabilidade em apps grandes.",
                                    "Pesquise cases reais de falhas por falta de exceções (ex: bugs famosos).",
                                    "Resuma em bullet points os ganhos em robustez OO."
                                  ],
                                  "verification": "Reutilizar a função em um novo contexto e documentar mudanças mínimas necessárias.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Exemplos de código modular, artigos sobre boas práticas em POO.",
                                  "tips": "Pense em exceções como 'contratos' entre métodos.",
                                  "learningObjective": "Identificar como exceções melhoram qualidade de software OO.",
                                  "commonMistakes": "Ignorar propagação de exceções, tratando tudo localmente."
                                }
                              ],
                              "practicalExample": "Em uma função de divisão segura: sem exceções, use if (divisor == 0) return -1; Com exceções: try { return a / b; } catch (ArithmeticException e) { logErro(e); } – o fluxo principal permanece limpo e reutilizável em calculadoras ou sistemas financeiros.",
                              "finalVerifications": [
                                "Explicar em 3 frases o propósito das exceções.",
                                "Refatorar um código fornecido sem exceções usando try-catch.",
                                "Identificar 3 benefícios em um diagrama comparativo.",
                                "Criar uma exceção customizada para um erro específico.",
                                "Discutir desvantagens de não usar exceções em grupo.",
                                "Executar e debugar um app com exceções propagadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de exceções e seu papel em POO (30%).",
                                "Qualidade da comparação entre abordagens com/sem exceções (25%).",
                                "Demonstração prática com códigos funcionais (20%).",
                                "Identificação clara de benefícios como manutenibilidade (15%).",
                                "Uso correto de terminologia OO e exemplos relevantes (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica condicional e fluxogramas para modelar exceções.",
                                "Inglês Técnico: Leitura de documentação de APIs de exceções.",
                                "Design de Software: Princípios SOLID e padrões de projeto.",
                                "Ética em Computação: Tratamento robusto de erros para segurança."
                              ],
                              "realWorldApplication": "Em aplicativos bancários, exceções tratam transações inválidas (ex: saldo insuficiente) sem poluir lógica de transferência, permitindo reutilização em apps mobile/web e facilitando auditorias de segurança."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.1.1.3.2",
                            "name": "Listar componentes de um objeto exceção",
                            "description": "Identificar e descrever elementos como mensagem de erro, stack trace, causa raiz e tipo, acessíveis via métodos getters em objetos de exceção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura básica de um objeto exceção",
                                  "subSteps": [
                                    "Ler a documentação oficial da classe Exception ou Throwable na linguagem escolhida (ex: JavaDoc).",
                                    "Identificar que um objeto exceção herda de Throwable e possui componentes principais: tipo, mensagem, stack trace e causa raiz.",
                                    "Anotar em um diagrama simples os relacionamentos entre esses componentes.",
                                    "Explicar verbalmente o propósito de cada componente em um contexto de erro de runtime.",
                                    "Comparar com um exemplo de exceção real de um código simples."
                                  ],
                                  "verification": "Capaz de listar e descrever os 4 componentes principais sem consultar notas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial (Java API ou equivalente)",
                                    "Bloco de notas ou ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Use analogia: exceção como um relatório de acidente (tipo=veículo, mensagem=descrição, stack=sequência de eventos, causa=origem).",
                                  "learningObjective": "Reconhecer os componentes fundamentais de um objeto exceção e sua hierarquia.",
                                  "commonMistakes": [
                                    "Confundir componentes de exceção com variáveis locais.",
                                    "Ignorar herança de Throwable."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Acessar o tipo e a mensagem de erro",
                                  "subSteps": [
                                    "Criar um código simples que lança uma exceção (ex: NullPointerException).",
                                    "Implementar bloco try-catch para capturar a exceção.",
                                    "Chamar métodos getClass().getSimpleName() para tipo e getMessage() para mensagem, imprimindo-os.",
                                    "Testar com diferentes exceções (ex: ArithmeticException) e registrar saídas.",
                                    "Modificar o código para lançar exceção customizada com mensagem personalizada."
                                  ],
                                  "verification": "Código executa e imprime corretamente tipo e mensagem para pelo menos 2 exceções diferentes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE como IntelliJ ou Eclipse",
                                    "Compilador Java ou equivalente"
                                  ],
                                  "tips": "Sempre use e.printStackTrace() inicialmente para overview rápido.",
                                  "learningObjective": "Dominar acesso ao tipo e mensagem via getters.",
                                  "commonMistakes": [
                                    "Esquecer de importar classes necessárias.",
                                    "Não tratar NullPointerException na mensagem."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o stack trace da exceção",
                                  "subSteps": [
                                    "No bloco catch, chamar getStackTrace() e iterar sobre os elementos do array StackTraceElement.",
                                    "Imprimir detalhes como método, linha e classe para cada frame do stack.",
                                    "Comparar saída de printStackTrace() com iteração manual.",
                                    "Identificar o frame raiz (primeiro elemento) como ponto de lançamento.",
                                    "Simular stack trace profundo com chamadas aninhadas e analisar."
                                  ],
                                  "verification": "Extrair e listar manualmente 3 frames de um stack trace de exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE com debugger",
                                    "Código de teste com exceções aninhadas"
                                  ],
                                  "tips": "Stack trace é LIFO: leia de baixo para cima para fluxo de execução.",
                                  "learningObjective": "Interpretar e acessar o stack trace para rastrear origem do erro.",
                                  "commonMistakes": [
                                    "Confundir ordem dos frames.",
                                    "Ignorar frames de bibliotecas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Investigar a causa raiz e compilar lista completa",
                                  "subSteps": [
                                    "Lançar exceção encadeada usando initCause() ou construtor com causa.",
                                    "Chamar recursivamente getCause() até null para percorrer cadeia de causas.",
                                    "Criar função que lista todos componentes: tipo, mensagem, stack trace resumido e causas.",
                                    "Testar em cenário real: divisão por zero propagada.",
                                    "Documentar lista em formato JSON ou tabela para um exemplo completo."
                                  ],
                                  "verification": "Função produz lista completa e correta para exceção encadeada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE",
                                    "Exemplos de código com exceções encadeadas"
                                  ],
                                  "tips": "Use loop while(ex.getCause() != null) para causas múltiplas.",
                                  "learningObjective": "Listar todos componentes incluindo causas raiz de forma estruturada.",
                                  "commonMistakes": [
                                    "Loop infinito em getCause().",
                                    "Não tratar exceções sem causa."
                                  ]
                                }
                              ],
                              "practicalExample": "Em Java: try { int x = 1/0; } catch(ArithmeticException e) { System.out.println('Tipo: ' + e.getClass().getSimpleName()); System.out.println('Mensagem: ' + e.getMessage()); e.printStackTrace(); System.out.println('Causa: ' + (e.getCause() != null ? e.getCause().getMessage() : 'N/A')); } Saída: Tipo: ArithmeticException, Mensagem: / by zero, Stack trace completo, Causa: N/A.",
                              "finalVerifications": [
                                "Listar corretamente os 4 componentes sem hesitação.",
                                "Escrever código que acessa e imprime todos componentes.",
                                "Interpretar stack trace de um log real.",
                                "Explicar diferença entre getMessage() e printStackTrace().",
                                "Aplicar em exceção encadeada com causa raiz.",
                                "Criar lista formatada para debugging."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de componentes (100% dos 4).",
                                "Correção no uso de getters (sem erros de compilação).",
                                "Profundidade na análise de stack trace (pelo menos 3 frames).",
                                "Tratamento adequado de causas encadeadas.",
                                "Clareza na documentação da lista final.",
                                "Eficiência temporal (dentro dos estimates)."
                              ],
                              "crossCurricularConnections": [
                                "Análise de logs em Administração de Sistemas.",
                                "Debugging lógico em Matemática Computacional.",
                                "Relatórios de erro em Engenharia de Software.",
                                "Rastreamento de falhas em Análise de Dados.",
                                "Documentação técnica em Comunicação Técnica."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software empresarial, permite debug rápido de falhas em produção, como análise de logs em servidores web para identificar NullPointerExceptions causadas por dados inválidos de usuários, reduzindo tempo de downtime."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.7.1.1.3.3",
                            "name": "Analisar propagação de exceções",
                            "description": "Compreender como exceções se propagam pela pilha de chamadas até serem tratadas ou finalizarem o programa, ilustrando com diagramas UML de fluxo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura da pilha de chamadas (Stack Trace)",
                                  "subSteps": [
                                    "Explique o que é uma pilha de chamadas em programação orientada a objetos.",
                                    "Identifique os frames da pilha em um exemplo simples de chamadas de métodos aninhados.",
                                    "Descreva como a pilha cresce e diminui durante a execução de métodos.",
                                    "Analise um stack trace de exemplo sem exceções para entender o fluxo normal.",
                                    "Registre manualmente um stack trace fictício para um programa com 3 níveis de chamadas."
                                  ],
                                  "verification": "Desenhe um diagrama simples da pilha de chamadas para um programa com métodos A chamando B chamando C.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE (ex: IntelliJ, VS Code)",
                                    "Documentação Java sobre StackTraceElement"
                                  ],
                                  "tips": [
                                    "Visualize a pilha como uma pilha de pratos: o último método chamado está no topo."
                                  ],
                                  "learningObjective": "Entender como a pilha de chamadas organiza as invocações de métodos.",
                                  "commonMistakes": [
                                    "Confundir pilha com fila (LIFO vs FIFO)",
                                    "Ignorar que métodos terminam removendo seu frame da pilha"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Simular o lançamento de uma exceção em código",
                                  "subSteps": [
                                    "Escreva um programa com métodos aninhados onde uma exceção é lançada no método mais profundo.",
                                    "Compile e execute o código sem blocos try-catch.",
                                    "Observe o stack trace impresso no console ao final da execução.",
                                    "Identifique no stack trace o ponto exato onde a exceção foi lançada.",
                                    "Modifique o código para lançar diferentes tipos de exceções (ex: NullPointerException, ArithmeticException)."
                                  ],
                                  "verification": "Execute o código e capture o stack trace completo, explicando cada linha.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE com Java (ex: Eclipse)",
                                    "Terminal para execução"
                                  ],
                                  "tips": [
                                    "Use System.out.println para marcar entradas e saídas de métodos e ver o fluxo."
                                  ],
                                  "learningObjective": "Simular e observar o comportamento inicial de uma exceção não tratada.",
                                  "commonMistakes": [
                                    "Esquecer de importar classes de exceção",
                                    "Não notar que o programa termina abruptamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a propagação da exceção pela pilha",
                                  "subSteps": [
                                    "Trace o caminho da exceção do método de lançamento até o topo da pilha.",
                                    "Explique por que a exceção 'sobe' método por método até ser tratada ou o programa encerrar.",
                                    "Adicione try-catch em um método intermediário e observe como a propagação para.",
                                    "Compare stack traces com e sem tratamento para visualizar diferenças.",
                                    "Descreva verbalmente ou por escrito o fluxo de propagação em um exemplo dado."
                                  ],
                                  "verification": "Preveja e valide o stack trace para um novo código com exceção propagando 3 níveis.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código fonte do passo anterior",
                                    "Ferramenta de debug do IDE"
                                  ],
                                  "tips": [
                                    "Pense na propagação como uma 'bola de neve' rolando para cima na pilha."
                                  ],
                                  "learningObjective": "Mapear o caminho exato de propagação de uma exceção através da stack trace.",
                                  "commonMistakes": [
                                    "Achar que exceções param no primeiro método pai",
                                    "Confundir lançamento com captura"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Criar diagrama UML de fluxo para ilustrar a propagação",
                                  "subSteps": [
                                    "Desenhe um diagrama de sequência UML mostrando chamadas normais e propagação de exceção.",
                                    "Inclua setas de exceção (dashed lines com <<throw>>) do ponto de lançamento para cima.",
                                    "Adicione blocos try-catch no diagrama e mostre como param a propagação.",
                                    "Valide o diagrama executando o código correspondente e comparando com o stack trace.",
                                    "Refine o diagrama para cenários com múltiplas exceções ou re-lançamentos."
                                  ],
                                  "verification": "Produza um diagrama UML que corresponda exatamente a um stack trace real de teste.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ferramenta UML (ex: Lucidchart, PlantUML, Draw.io)",
                                    "Exemplos de código dos passos anteriores"
                                  ],
                                  "tips": [
                                    "Use PlantUML para gerar diagramas a partir de código texto rapidamente."
                                  ],
                                  "learningObjective": "Visualizar graficamente a propagação de exceções usando UML.",
                                  "commonMistakes": [
                                    "Usar setas sólidas para exceções em vez de tracejadas",
                                    "Omitir frames intermediários na pilha"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema bancário Java, o método processarSaque() chama validarSaldo() que chama calcularTaxa(). Se calcularTaxa() lança ArithmeticException por divisão por zero, a exceção propaga: calcularTaxa() -> validarSaldo() -> processarSaque(). Sem try-catch, o stack trace mostra: at Banco.calcularTaxa(...) [linha 15], at Banco.validarSaldo(...) [linha 22], etc., terminando o programa. Diagrama UML: [processarSaque] -> [validarSaldo] -> [calcularTaxa] <<throw>> ArithmeticException -> [validarSaldo] <<catch>> ou para cima.",
                              "finalVerifications": [
                                "Explicar verbalmente a propagação de uma exceção em um stack trace de 4 níveis.",
                                "Prever corretamente o stack trace para um código fornecido com exceção não tratada.",
                                "Criar um diagrama UML preciso para um cenário de propagação com try-catch parcial.",
                                "Identificar e corrigir um stack trace onde a exceção foi re-lançada.",
                                "Diferenciar propagação de exceções checked vs unchecked em exemplos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do fluxo de propagação (100% dos frames corretos).",
                                "Qualidade do diagrama UML: setas de exceção corretas e legíveis.",
                                "Capacidade de simular e analisar stack traces reais.",
                                "Identificação correta de pontos de parada (try-catch).",
                                "Explicação clara de consequências de exceções não tratadas.",
                                "Integração de conceitos em exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Análise de grafos em Matemática (pilha como árvore de chamadas).",
                                "Depuração e análise de logs em Engenharia de Software.",
                                "Fluxo de controle em Lógica e Algoritmos.",
                                "Modelagem de sistemas dinâmicos em Ciências da Computação.",
                                "Gestão de riscos e falhas em Administração de Projetos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de aplicativos empresariais, analisar stack traces de crashes em produção permite identificar bugs profundos, como em e-commerces onde exceções em camadas de banco propagam para a UI, evitando downtime e melhorando robustez do software."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.1.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.2",
                    "name": "Hierarquia de Classes de Exceções",
                    "description": "Estrutura de herança de classes base para exceções em linguagens OO.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.2.1",
                        "name": "Classe Base das Exceções",
                        "description": "A classe raiz na hierarquia de herança para exceções em linguagens orientadas a objetos, como Throwable em Java ou Exception em Python e C++, que serve como superclasse para todas as exceções e erros.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.1.1",
                            "name": "Identificar a classe base das exceções",
                            "description": "Reconhecer e nomear a classe superclasse raiz para exceções em linguagens OO específicas, como Throwable (Java), Exception (Python/C++), e descrever seu papel fundamental na captura de erros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Hierarquia de Classes de Exceções",
                                  "subSteps": [
                                    "Leia a documentação oficial sobre exceções em linguagens OO, focando na importância da captura de erros.",
                                    "Estude o diagrama UML básico de hierarquia de exceções (raiz -> subclasses).",
                                    "Identifique o papel da classe base: ponto comum para todas as exceções, permitindo captura genérica com 'catch (Throwable)' ou similar.",
                                    "Anote diferenças entre exceções checked e unchecked (Java)."
                                  ],
                                  "verification": "Desenhe um diagrama simples da hierarquia raiz e explique verbalmente o fluxo de herança.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação Java (Oracle), Python (docs.python.org), C++ (cppreference.com)",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Use analogia de família: classe base é o ancestral comum.",
                                  "learningObjective": "Entender o papel fundamental da classe raiz na hierarquia de exceções.",
                                  "commonMistakes": "Confundir classe base com subclasses específicas como IOException."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a Classe Base em Java: Throwable",
                                  "subSteps": [
                                    "Abra o código fonte ou Javadoc de Throwable.",
                                    "Verifique que Throwable é a superclasse de Exception e Error.",
                                    "Teste em código: crie um try-catch genérico com Throwable.",
                                    "Compile e execute um programa que lança RuntimeException e captura com Throwable."
                                  ],
                                  "verification": "Código compila e captura exceções corretamente usando Throwable.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "JDK instalado, IDE como IntelliJ ou Eclipse",
                                    "Exemplo de código Java básico"
                                  ],
                                  "tips": "Throwable inclui métodos como getMessage() e printStackTrace().",
                                  "learningObjective": "Reconhecer Throwable como raiz em Java e seu uso em catch-all.",
                                  "commonMistakes": "Achar que Exception é a raiz (é subclass de Throwable)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Classes Base em Python e C++",
                                  "subSteps": [
                                    "Em Python: Consulte docs para BaseException (raiz) e Exception (comum). Teste except Exception.",
                                    "Em C++: Verifique std::exception como base comum; teste catch (std::exception&).",
                                    "Compare com Java: execute snippets em cada linguagem.",
                                    "Registre o nome exato e herança em um quadro comparativo."
                                  ],
                                  "verification": "Quadro comparativo preenchido corretamente: Java-Throwable, Python-Exception/BaseException, C++-std::exception.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python interpreter, g++ compiler",
                                    "Snippets de código prontos"
                                  ],
                                  "tips": "Em Python, use 'except Exception' para maioria dos casos.",
                                  "learningObjective": "Nomear e diferenciar classes base por linguagem.",
                                  "commonMistakes": "Ignorar BaseException em Python, focando só em Exception."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação e Sintetizar Conhecimento",
                                  "subSteps": [
                                    "Crie exceções customizadas herdando da classe base em cada linguagem.",
                                    "Resolva quiz: 'Qual é a classe base em Java?' e explique.",
                                    "Discuta cenários: quando usar catch na base vs. específicas.",
                                    "Revise erros comuns em um log de prática."
                                  ],
                                  "verification": "Exceções customizadas funcionam e quiz respondido 100% correto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE para cada linguagem",
                                    "Quiz impresso ou digital com 5 perguntas"
                                  ],
                                  "tips": "Sempre herde da classe apropriada para compatibilidade.",
                                  "learningObjective": "Aplicar identificação em código real e sintetizar diferenças.",
                                  "commonMistakes": "Herdar de classes erradas, quebrando catch genéricos."
                                }
                              ],
                              "practicalExample": "Em Java, defina 'class MinhaExcecao extends Throwable { }' e lance-a; capture com 'catch (Throwable t) { t.printStackTrace(); }'. Isso demonstra Throwable como raiz, permitindo captura de qualquer erro ou exceção.",
                              "finalVerifications": [
                                "Nomeia corretamente Throwable (Java), Exception/BaseException (Python), std::exception (C++).",
                                "Explica o papel: superclasse para captura genérica de erros.",
                                "Cria código funcional herdando da classe base.",
                                "Diferencia hierarquias entre linguagens em um diagrama.",
                                "Identifica uso em try-catch genérico sem erros.",
                                "Descreve métodos comuns da classe base (ex: getMessage())."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação das classes base (100% correto).",
                                "Profundidade na explicação do papel hierárquico (detalhes sobre herança).",
                                "Qualidade do código prático (compila e executa corretamente).",
                                "Completude do diagrama comparativo (todas linguagens cobertas).",
                                "Capacidade de discutir cenários reais (ex: catch-all vs. específico).",
                                "Identificação de pelo menos 3 erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Design de Software: Modelagem de herança em UML.",
                                "Depuração e Lógica: Análise de stack traces como árvores.",
                                "Ciência da Computação: Teoria de grafos em hierarquias de classes.",
                                "Matemática: Conceitos de conjuntos e subconjuntos em herança."
                              ],
                              "realWorldApplication": "Em desenvolvimento de APIs robustas, identificar a classe base permite implementar handlers globais de erros (ex: em servidores web Java/Spring capturando Throwable para logs centralizados), evitando crashes não tratados e melhorando resiliência de apps como e-commerces ou microsserviços."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.1.2",
                            "name": "Explicar atributos e métodos da classe base",
                            "description": "Descrever os principais atributos (como mensagem de erro e causa) e métodos (como getMessage(), printStackTrace()) disponíveis na classe base das exceções e sua herança.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a classe base Throwable e sua posição na hierarquia",
                                  "subSteps": [
                                    "Pesquise a documentação oficial da classe Throwable no JavaDoc.",
                                    "Identifique que Throwable é a superclasse de todas as exceções e erros.",
                                    "Desenhe um diagrama simples da hierarquia: Throwable > Exception > RuntimeException, e Throwable > Error.",
                                    "Note que Exception e Error herdam diretamente de Throwable.",
                                    "Compile um código simples que lança uma Throwable para observar o comportamento base."
                                  ],
                                  "verification": "Crie um diagrama da hierarquia e execute um código que lança Throwable, confirmando a herança via instanceof.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "JavaDoc de Throwable (https://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html), IDE (IntelliJ ou Eclipse), editor de texto para diagramas.",
                                  "tips": "Use o atalho Ctrl+Q no IntelliJ para abrir JavaDoc rapidamente.",
                                  "learningObjective": "Compreender o papel fundamental de Throwable como raiz da hierarquia de exceções.",
                                  "commonMistakes": "Confundir Throwable com Exception; lembre-se que Throwable inclui Errors também."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar os principais atributos da classe Throwable",
                                  "subSteps": [
                                    "Identifique o atributo 'detailMessage' (String) para mensagem de erro personalizada.",
                                    "Estude o atributo 'cause' (Throwable) para encadeamento de exceções.",
                                    "Analise 'suppressed' (array de Throwable) para exceções suprimidas em try-with-resources.",
                                    "Acesse o stack trace via getStackTrace() que retorna StackTraceElement[].",
                                    "Crie um código que define e acessa esses atributos em uma exceção customizada."
                                  ],
                                  "verification": "Escreva um código que imprime detailMessage, cause e stackTrace de uma exceção, confirmando valores corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "JavaDoc de Throwable, código fonte de exemplo com exceções, debugger da IDE.",
                                  "tips": "Use o debugger para inspecionar campos privados refletidos publicamente via métodos.",
                                  "learningObjective": "Listar e descrever os atributos chave: detailMessage, cause, suppressed e stackTrace.",
                                  "commonMistakes": "Ignorar 'cause' em initCause(); sempre use o construtor com causa para encadeamento."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar os métodos principais da classe Throwable",
                                  "subSteps": [
                                    "Estude getMessage() que retorna detailMessage ou 'null'.",
                                    "Implemente printStackTrace() para imprimir stack trace no stderr.",
                                    "Explore getCause() para obter a causa raiz da exceção.",
                                    "Teste addSuppressed() e getSuppressed() em cenários de múltiplas exceções.",
                                    "Compare toString() que inclui classe e mensagem."
                                  ],
                                  "verification": "Crie um programa que lança uma exceção com causa, chama todos os métodos e verifica saídas no console.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "IDE com console, exemplos de código de exceções encadeadas, JavaDoc.",
                                  "tips": "Redirecione printStackTrace() para um StringWriter para capturar e analisar a saída.",
                                  "learningObjective": "Explicar o propósito e uso de getMessage(), printStackTrace(), getCause() e relacionados.",
                                  "commonMistakes": "Chamar printStackTrace() sem tratar; prefira logging em produção."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar herança e uso prático em subclasses",
                                  "subSteps": [
                                    "Crie uma exceção customizada que estende Exception e sobrescreva métodos de Throwable.",
                                    "Demonstre como atributos e métodos são herdados em RuntimeException e IOException.",
                                    "Teste cenários onde subclasses acessam métodos da base como fillInStackTrace().",
                                    "Analise o impacto da herança em catch blocks genéricos (catch Throwable).",
                                    "Documente diferenças sutis entre Exception e Error na herança."
                                  ],
                                  "verification": "Execute código com exceção customizada, confirmando que métodos da base funcionam e herança é respeitada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "IDE, código template para exceções customizadas, JUnit para testes unitários.",
                                  "tips": "Use JUnit @Test(expected = Throwable.class) para validar herança.",
                                  "learningObjective": "Demonstrar como subclasses herdam e utilizam atributos/métodos de Throwable.",
                                  "commonMistakes": "Sobrescrever métodos sem chamar super; sempre invoque super.getMessage()."
                                }
                              ],
                              "practicalExample": "Em um aplicativo de banco, lance uma SQLException com causa como uma conexão falha (IOException). Use getCause() para logar a raiz, printStackTrace() para debug e getMessage() para mensagem amigável ao usuário: try { ... } catch (SQLException e) { logger.error(e.getMessage() + \": \" + e.getCause()); e.printStackTrace(); }",
                              "finalVerifications": [
                                "Liste corretamente os 4 atributos principais de Throwable.",
                                "Explique e demonstre 5 métodos chave com código funcional.",
                                "Desenhe a hierarquia mostrando herança de Exception e Error.",
                                "Crie uma exceção customizada usando construtores com causa.",
                                "Diferencie uso de printStackTrace() vs logging estruturado.",
                                "Valide encadeamento de exceções em um teste unitário."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de atributos (detailMessage, cause, etc.) - 20%.",
                                "Correta explicação de métodos com exemplos de código - 25%.",
                                "Compreensão da herança demonstrada em diagrama/código - 20%.",
                                "Identificação de erros comuns e como evitá-los - 15%.",
                                "Aplicação prática em exemplo realista - 10%.",
                                "Clareza e estrutura na explicação oral/escrita - 10%."
                              ],
                              "crossCurricularConnections": [
                                "Debugging e análise de logs em Desenvolvimento de Software.",
                                "Design de APIs robustas em Engenharia de Software.",
                                "Gestão de riscos e falhas em Sistemas Distribuídos.",
                                "Estruturas de dados para stack traces em Ciência da Computação."
                              ],
                              "realWorldApplication": "Em sistemas empresariais como e-commerce, use getCause() e printStackTrace() para diagnosticar falhas de banco de dados em logs do Splunk ou ELK Stack, permitindo recuperação rápida e alertas automáticos sem expor detalhes sensíveis aos usuários."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.1.3",
                            "name": "Diferenciar exceções de erros na hierarquia",
                            "description": "Distinguir exceções recuperáveis (subclasses de Exception) de erros irrecuperáveis (subclasses de Error), usando exemplos de hierarquias em Java/Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Hierarquia Base de Throwable",
                                  "subSteps": [
                                    "Estude a classe base Throwable em Java (ou BaseException em Python).",
                                    "Desenhe ou visualize o diagrama da hierarquia: Throwable → Error e Exception.",
                                    "Leia a documentação oficial da Oracle para Java Throwable ou Python docs para BaseException.",
                                    "Identifique que Throwable é o ancestral comum de todos os erros e exceções.",
                                    "Note que em Python, a distinção é conceitual, mas hierarquia similar via Exception."
                                  ],
                                  "verification": "Crie um diagrama simples da hierarquia e explique verbalmente ou por escrito as relações pai-filho.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Documentação Java Throwable (docs.oracle.com)",
                                    "Documentação Python BaseException (docs.python.org)",
                                    "Ferramenta de diagrama como draw.io ou papel e caneta"
                                  ],
                                  "tips": "Use cores diferentes para Error (vermelho/irrecuperável) e Exception (azul/recuperável).",
                                  "learningObjective": "Compreender que Throwable é a superclasse raiz para todos os problemas lançáveis.",
                                  "commonMistakes": [
                                    "Confundir Throwable com Exception como sinônimos.",
                                    "Ignorar que Error e Exception são subclasses diretas de Throwable."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Subclasses de Error (Irrecuperáveis)",
                                  "subSteps": [
                                    "Liste subclasses comuns de Error: VirtualMachineError, OutOfMemoryError, StackOverflowError.",
                                    "Pesquise exemplos de código que geram esses erros (ex: loop infinito para StackOverflow).",
                                    "Execute código em IDE para observar StackOverflowError.",
                                    "Leia por que esses erros são irrecuperáveis: problemas no JVM ou sistema.",
                                    "Compare com Python: MemoryError, RecursionError (subclasses de Exception, mas conceitualmente similares)."
                                  ],
                                  "verification": "Escreva e execute um código que lance um OutOfMemoryError e capture o stack trace.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "IDE como IntelliJ ou Eclipse para Java",
                                    "Python IDLE ou Jupyter",
                                    "Exemplos de código de StackOverflowError"
                                  ],
                                  "tips": "Não tente recuperar Errors em produção; foque em prevenção via design.",
                                  "learningObjective": "Reconhecer Errors como condições fatais do sistema, não para tratamento rutinário.",
                                  "commonMistakes": [
                                    "Tentar catch em Errors desnecessariamente.",
                                    "Confundir StackOverflowError com exceções lógicas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Subclasses de Exception (Recuperáveis)",
                                  "subSteps": [
                                    "Liste subclasses: RuntimeException (unchecked) como NullPointerException, IOException (checked).",
                                    "Crie exemplos de código: divida por zero para ArithmeticException.",
                                    "Diferencie checked vs unchecked: compile-time vs runtime.",
                                    "Em Python, todas são unchecked, mas exemplos como ValueError, KeyError.",
                                    "Pratique lançando e capturando uma Exception com try-catch."
                                  ],
                                  "verification": "Implemente um try-catch para IOException em leitura de arquivo e valide recuperação.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "IDE com suporte a Java/Python",
                                    "Arquivos de teste para IO",
                                    "Documentação de Exception subclasses"
                                  ],
                                  "tips": "Sempre prefira exceções específicas em catch para granularidade.",
                                  "learningObjective": "Identificar Exceptions como condições esperadas que o código pode e deve tratar.",
                                  "commonMistakes": [
                                    "Catch genérico Exception em vez de específicas.",
                                    "Tratar RuntimeException como irrecuperáveis."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Diferenciação e Aplicação",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: Error vs Exception (causa, tratamento, exemplos).",
                                    "Refatore código misturando ambos: logue Errors sem catch, trate Exceptions.",
                                    "Simule cenários: app web com OutOfMemoryError vs FileNotFoundException.",
                                    "Teste em ambos Java e Python para reforçar conceitos.",
                                    "Discuta quando logar vs propagar."
                                  ],
                                  "verification": "Desenvolva um programa que diferencie e trate corretamente 3 exemplos de cada.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "IDE",
                                    "Exemplos de código comparativos Java/Python"
                                  ],
                                  "tips": "Regra: catch Exceptions, log Errors e saia graciosamente.",
                                  "learningObjective": "Aplicar a distinção em código real, melhorando robustez.",
                                  "commonMistakes": [
                                    "Usar catch-all Throwable.",
                                    "Ignorar hierarquia ao estender classes."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um servidor web Java: catch IOException (Exception) para retry de conexão de banco, mas logue OutOfMemoryError (Error) e shutdown graceful sem tentar recuperar, evitando crash pior.",
                              "finalVerifications": [
                                "Explicar verbalmente a diferença entre Error e Exception com 2 exemplos cada.",
                                "Desenhar hierarquia correta sem erros.",
                                "Identificar em stack trace se é Error ou Exception.",
                                "Refatorar código dado para tratar adequadamente.",
                                "Comparar Java vs Python hierarquias.",
                                "Listar 3 razões para não catch Errors rotineiramente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na hierarquia (100% correta).",
                                "Exemplos concretos e executáveis fornecidos.",
                                "Diferenciação clara: recuperável vs irrecuperável.",
                                "Código demonstra try-catch seletivo.",
                                "Tabela comparativa completa.",
                                "Aplicação em cenários reais sem confusões."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Design de fault-tolerance e logging.",
                                "Ciência da Computação: Análise de complexidade e limites de máquina (ex: StackOverflow).",
                                "Sistemas Operacionais: Gerenciamento de memória e recursos (OutOfMemory).",
                                "Debugging e Testing: Estratégias de teste para exceções vs erros."
                              ],
                              "realWorldApplication": "Desenvolvedores usam isso para criar apps resilientes: tratar falhas de rede (Exception) com retry, mas detectar vazamentos de memória (Error) cedo via monitoramento, prevenindo downtimes em produção como em e-commerces ou bancos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.2",
                        "name": "Hierarquia de Exceções Específicas",
                        "description": "Estrutura hierárquica derivada da classe base, incluindo exceções runtime (unchecked) e verificadas (checked), com exemplos como NullPointerException, IndexError e IOException.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.2.1",
                            "name": "Mapear a hierarquia de exceções runtime",
                            "description": "Traçar a árvore de herança para exceções unchecked como RuntimeException (Java), Exception (Python para a maioria), incluindo ArithmeticException e NullPointerException.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a hierarquia básica de exceções em Java",
                                  "subSteps": [
                                    "Acesse a documentação oficial da Oracle para Throwable e estude suas subclasses principais: Error e Exception.",
                                    "Identifique a divisão de Exception em checked exceptions e unchecked exceptions (RuntimeException e subclasses).",
                                    "Anote que unchecked exceptions não precisam ser declaradas ou tratadas obrigatoriamente.",
                                    "Use uma IDE como IntelliJ ou Eclipse para visualizar a hierarquia de classes com atalhos como Ctrl+H.",
                                    "Liste 3 exemplos de cada ramo: Error, checked Exception e RuntimeException."
                                  ],
                                  "verification": "Explique em uma frase a cadeia completa: Throwable > Exception > RuntimeException.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Documentação Java Throwable: https://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html",
                                    "IDE com suporte a Java (IntelliJ, Eclipse)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Comece pela superclasse Throwable para contextualizar toda a árvore.",
                                  "learningObjective": "Compreender a estrutura raiz da hierarquia de exceções em Java e a distinção checked/unchecked.",
                                  "commonMistakes": "Confundir Error (problemas irrecuperáveis) com Exception; assumir que RuntimeException é checked."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear herança específica de exceções runtime unchecked em Java",
                                  "subSteps": [
                                    "Trace a herança de RuntimeException: herda diretamente de Exception > Throwable.",
                                    "Liste e trace subclasses chave: ArithmeticException (RuntimeException > Exception > Throwable) e NullPointerException (mesma cadeia).",
                                    "Consulte Javadoc para subclasses indiretas e anote pelo menos 5 exemplos adicionais como IllegalArgumentException.",
                                    "Crie um diagrama manual simples mostrando a árvore de RuntimeException com setas para ArithmeticException e NullPointerException.",
                                    "Teste em código: lance uma ArithmeticException e capture para imprimir getClass().getSuperclass()."
                                  ],
                                  "verification": "Desenhe e rotule corretamente o caminho de herança para ArithmeticException e NullPointerException.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Javadoc para RuntimeException: https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimeException.html",
                                    "Editor de código Java com compilador",
                                    "Ferramenta de diagrama como draw.io ou papel"
                                  ],
                                  "tips": "Use o método getSuperclass() em código para validar a herança dinamicamente.",
                                  "learningObjective": "Mapear precisamente a árvore de herança para exceções unchecked como ArithmeticException e NullPointerException.",
                                  "commonMistakes": "Parar na RuntimeException sem traçar até Throwable; confundir com checked exceptions como IOException."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar a hierarquia de exceções em Python, focando em análogos runtime",
                                  "subSteps": [
                                    "Acesse docs.python.org/library/exceptions.html e estude BaseException como raiz.",
                                    "Identifique Exception como superclasse principal para a maioria das exceções runtime, sem distinção checked/unchecked.",
                                    "Trace análogos: ArithmeticError (Exception > BaseException) com ZeroDivisionError; AttributeError (direto de Exception) como similar a NullPointerException.",
                                    "Use dir(Exception) no interpretador Python para listar subclasses.",
                                    "Anote pelo menos 5 exceções comuns sob Exception e suas heranças.",
                                    "Teste com isinstance(obj, ArithmeticError) em código para validar."
                                  ],
                                  "verification": "Liste a cadeia: BaseException > Exception > ArithmeticError > ZeroDivisionError.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Documentação Python Exceptions: https://docs.python.org/3/library/exceptions.html",
                                    "Interpretador Python 3",
                                    "Notebook Jupyter ou REPL"
                                  ],
                                  "tips": "Python não tem checked/unchecked; foque em herança built-in via issubclass().",
                                  "learningObjective": "Compreender a hierarquia Python e mapear exceções como ArithmeticError e AttributeError.",
                                  "commonMistakes": "Assumir hierarquia idêntica a Java; ignorar que AttributeError não está sob ArithmeticError."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar hierarquias Java/Python e criar mapa unificado",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: Java (Throwable > Exception > RuntimeException > ArithmeticException/NullPointer) vs Python (BaseException > Exception > ArithmeticError/AttributeError).",
                                    "Desenhe um diagrama side-by-side ou unificado destacando similaridades e diferenças.",
                                    "Teste código híbrido: em Java/Python, lance exceções e print stack trace para observar classes.",
                                    "Identifique padrões OOP comuns como polimorfismo em catches.",
                                    "Resuma em bullet points: 3 diferenças chave entre as linguagens."
                                  ],
                                  "verification": "Apresente o diagrama comparativo e explique uma diferença chave verbalmente.",
                                  "estimatedTime": "35 minutes",
                                  "materials": [
                                    "Ferramenta de diagrama (draw.io, Lucidchart)",
                                    "Código de teste Java e Python",
                                    "Papel para tabela comparativa"
                                  ],
                                  "tips": "Use cores diferentes para Java (azul) e Python (verde) no diagrama para clareza.",
                                  "learningObjective": "Traçar e comparar árvores de herança runtime entre Java e Python.",
                                  "commonMistakes": "Forçar equivalências perfeitas (ex: NullPointer = AttributeError, mas não exato); omitir BaseException em Python."
                                }
                              ],
                              "practicalExample": "Crie um diagrama em draw.io: Java - Throwable (topo) → Exception → RuntimeException → ArithmeticException e → NullPointerException. Python (lado): BaseException → Exception → ArithmeticError → ZeroDivisionError e → AttributeError. Teste código: em Java, int x = 1/0; catch(ArithmeticException e) { System.out.println(e.getClass().getSuperclass()); } – imprime RuntimeException. Em Python: 1/0 → ZeroDivisionError, print(issubclass(ZeroDivisionError, ArithmeticError)) → True.",
                              "finalVerifications": [
                                "Lista corretamente a herança completa de RuntimeException até Throwable.",
                                "Identifica ArithmeticException e NullPointerException como unchecked em Java.",
                                "Traça ArithmeticError/AttributeError sob Exception em Python.",
                                "Explica pelo menos uma diferença chave entre Java e Python.",
                                "Desenha diagrama preciso sem erros de herança.",
                                "Valida com código de teste (getSuperclass ou issubclass)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na traçagem de herança (100% correta para exemplos chave).",
                                "Profundidade dos substeps completados (mínimo 80% por step).",
                                "Clareza e completude do diagrama comparativo.",
                                "Validação prática via código em ambas linguagens.",
                                "Identificação correta de 5+ subclasses relevantes.",
                                "Explicação concisa de implicações OOP."
                              ],
                              "crossCurricularConnections": [
                                "Programação Orientada a Objetos: Conceitos de herança e polimorfismo.",
                                "Debugging e Análise de Erros: Leitura de stack traces.",
                                "Design de Software: Escolha de catches específicos vs genéricos.",
                                "Linguagens de Programação: Comparação Java vs Python."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software enterprise, mapear hierarquias permite handlers de exceções precisos (catch ArithmeticException em vez de Exception), reduzindo bugs mascarados e melhorando logs/debugging em apps Java/Spring ou Python/Django."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.1"
                            ]
                          },
                          {
                            "id": "10.1.7.2.2.2",
                            "name": "Identificar exceções checked vs unchecked",
                            "description": "Explicar a diferença entre exceções que devem ser tratadas no momento da compilação (checked, ex: IOException) e as que não (unchecked, ex: RuntimeException), com exemplos em linguagens OO.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a hierarquia básica de exceções em linguagens OO como Java",
                                  "subSteps": [
                                    "Estude a classe base Throwable e suas subclasses principais: Exception e Error.",
                                    "Identifique que Exception é dividida em checked (ex: IOException) e unchecked (RuntimeException).",
                                    "Consulte a documentação oficial da linguagem para visualizar o diagrama de herança.",
                                    "Anote exemplos de cada categoria na hierarquia.",
                                    "Compare com linguagens semelhantes como C#."
                                  ],
                                  "verification": "Criar um diagrama simples da hierarquia e listar 3 exemplos de cada tipo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação Java Exceptions (docs.oracle.com)",
                                    "Ferramenta de diagrama como Draw.io",
                                    "IDE com suporte a Java (Eclipse ou IntelliJ)"
                                  ],
                                  "tips": "Use cores diferentes no diagrama para checked (azul) e unchecked (vermelho) para facilitar a visualização.",
                                  "learningObjective": "Compreender a estrutura hierárquica de exceções para basear a identificação de tipos.",
                                  "commonMistakes": [
                                    "Confundir Error com Exception; achar que todas as Exceptions são checked."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar exceções checked em profundidade",
                                  "subSteps": [
                                    "Defina checked exceptions: devem ser tratadas no momento da compilação (try-catch ou throws).",
                                    "Analise exemplo: IOException – lançada em operações de arquivo.",
                                    "Escreva um código simples que compile apenas com tratamento explícito.",
                                    "Teste removendo o tratamento e observe erro de compilação.",
                                    "Liste 3 outras checked comuns: SQLException, ParseException."
                                  ],
                                  "verification": "Compilar com sucesso um código com IOException tratada e falhar sem tratamento.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE Java",
                                    "Exemplos de código em arquivos .java",
                                    "Compilador javac"
                                  ],
                                  "tips": "Sempre verifique o erro de compilação: 'unreported exception' indica checked.",
                                  "learningObjective": "Reconhecer características e obrigatoriedade de tratamento de checked exceptions.",
                                  "commonMistakes": [
                                    "Tratar checked como unchecked, ignorando declaração throws."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar exceções unchecked em profundidade",
                                  "subSteps": [
                                    "Defina unchecked: herdam de RuntimeException ou Error, não exigem tratamento obrigatório.",
                                    "Analise exemplo: NullPointerException – erro de programação em tempo de execução.",
                                    "Escreva código que lança unchecked sem tratamento e compile normalmente.",
                                    "Teste execução e observe stack trace em runtime.",
                                    "Liste 3 outras: ArrayIndexOutOfBoundsException, IllegalArgumentException."
                                  ],
                                  "verification": "Executar código com NullPointerException sem try-catch e analisar o stack trace.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE Java",
                                    "Console para execução",
                                    "Documentação RuntimeException"
                                  ],
                                  "tips": "Unchecked são para erros lógicos do programador; foque em prevenção via código defensivo.",
                                  "learningObjective": "Diferenciar unchecked por sua natureza runtime e ausência de obrigatoriedade.",
                                  "commonMistakes": [
                                    "Achar que unchecked não precisam de tratamento algum; ignorar boas práticas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação e comparação entre checked e unchecked",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: colunas para tipo, exemplo, tratamento obrigatório, quando ocorre.",
                                    "Classifique 10 exceções mistas (5 checked, 5 unchecked) usando herança.",
                                    "Refatore um código com exceções mistas, tratando apenas as checked.",
                                    "Simule cenários: I/O (checked) vs divisão por zero (unchecked).",
                                    "Debata prós/contras de cada tipo em design de API."
                                  ],
                                  "verification": "Classificar corretamente todas as 10 exceções em um quiz autoavaliado.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha ou tabela Markdown",
                                    "Lista de exceções para classificação",
                                    "IDE para refatoração"
                                  ],
                                  "tips": "Regra rápida: se herda de RuntimeException ou Error → unchecked; senão, checked.",
                                  "learningObjective": "Identificar rapidamente qualquer exceção como checked ou unchecked com exemplos.",
                                  "commonMistakes": [
                                    "Classificar por nome ao invés de herança; confundir com exceções customizadas."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app de leitura de arquivos: método readFile() declara 'throws IOException' (checked, tratado com try-catch). Já getUserAge(String input) pode lançar NumberFormatException (unchecked) sem declaração, pois é erro de input inválido em runtime.",
                              "finalVerifications": [
                                "Classificar corretamente 10 exceções aleatórias como checked ou unchecked.",
                                "Explicar verbalmente a diferença com exemplos de IOException e NullPointerException.",
                                "Compilar e executar código com mistura de exceções, identificando comportamentos.",
                                "Criar uma exceção customizada e determinar seu tipo.",
                                "Analisar stack trace de um erro real e identificar se é checked/unchecked.",
                                "Discutir em grupo: quando usar checked vs unchecked em design."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação baseada em herança (90%+ correto).",
                                "Uso correto de try-catch/throws em exemplos práticos.",
                                "Explicação clara da diferença em compilação vs runtime.",
                                "Identificação de erros comuns e como evitá-los.",
                                "Aplicação em cenários reais com exemplos relevantes.",
                                "Completude da tabela comparativa e diagrama."
                              ],
                              "crossCurricularConnections": [
                                "Lógica de programação: fluxos condicionais em tratamento de erros.",
                                "Design de software: princípios de robustez e API seguras.",
                                "Manutenção de código: debugging e análise de stack traces.",
                                "Matemática discreta: hierarquias e árvores de classes.",
                                "Ética em TI: responsabilidade em tratamento de falhas críticas."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software empresarial, checked exceptions forçam tratamento de falhas previsíveis como falhas de rede (ex: apps bancários), enquanto unchecked capturam bugs lógicos (ex: apps mobile), garantindo apps robustos e manuteníveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.1"
                            ]
                          },
                          {
                            "id": "10.1.7.2.2.3",
                            "name": "Visualizar hierarquia usando UML",
                            "description": "Representar a hierarquia de classes de exceções em um diagrama de classes UML, destacando setas de herança e relacionamentos entre Throwable/Exception e subclasses.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Hierarquia de Classes de Exceções em Java",
                                  "subSteps": [
                                    "Acesse a documentação oficial da API Java para a classe Throwable.",
                                    "Identifique as subclasses diretas: Error e Exception.",
                                    "Liste subclasses chave de Exception: RuntimeException (ex.: NullPointerException, ArithmeticException) e exceções checked (ex.: IOException, SQLException).",
                                    "Anote pelo menos 8 classes específicas e suas relações pai-filho.",
                                    "Crie um outline textual da hierarquia usando indentação para representar herança."
                                  ],
                                  "verification": "Capaz de recitar verbalmente ou por escrito a hierarquia com pelo menos 5 níveis corretos sem consultar materiais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação Oracle Java API (Throwable, Exception)",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Comece pelo topo (Throwable) e desça recursivamente; foque em exemplos comuns primeiro.",
                                  "learningObjective": "Dominar a estrutura hierárquica exata das classes de exceções para basear o diagrama UML.",
                                  "commonMistakes": [
                                    "Confundir Error (não recuperável) com Exception",
                                    "Omitir distinção checked vs unchecked",
                                    "Listar classes não existentes na hierarquia padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender Notação UML para Diagramas de Classes e Herança",
                                  "subSteps": [
                                    "Estude os elementos básicos: retângulos para classes (nome, atributos opcionais), setas triangulares abertas para herança (generalização).",
                                    "Pratique desenhar uma seta de herança de uma subclasse para superclasse.",
                                    "Revise notação para pacotes (retângulos com aba) e estereótipos como <<exception>>.",
                                    "Desenhe exemplos simples: Animal -> Mamifero -> Cachorro.",
                                    "Identifique convenções específicas para exceções em UML (ex.: destacar Throwable como raiz)."
                                  ],
                                  "verification": "Desenhar manualmente um diagrama UML simples de herança com 3 classes corretamente anotado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Guia UML 2.5 oficial (OMG)",
                                    "Ferramenta online como draw.io ou Lucidchart (gratuita)"
                                  ],
                                  "tips": "Use setas sólidas com triângulo vazio para herança; evite setas tracejadas (que são para dependências).",
                                  "learningObjective": "Aplicar corretamente a notação UML para representar relacionamentos de herança em hierarquias de classes.",
                                  "commonMistakes": [
                                    "Usar seta errada (ex.: seta de associação em vez de herança)",
                                    "Esquecer o triângulo na seta",
                                    "Sobrecarregar o diagrama com atributos desnecessários"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o Diagrama UML da Hierarquia de Exceções",
                                  "subSteps": [
                                    "Coloque Throwable no topo como classe raiz.",
                                    "Adicione setas de herança para Error e Exception logo abaixo.",
                                    "Expanda Exception: adicione RuntimeException e pelo menos 3 checked exceptions (ex.: IOException, FileNotFoundException).",
                                    "Inclua 4-6 subclasses de RuntimeException (ex.: NullPointerException, IndexOutOfBoundsException).",
                                    "Agrupe em pacotes se aplicável (java.lang, java.io) e adicione rótulos para checked/unchecked."
                                  ],
                                  "verification": "O diagrama renderizado mostra todas as setas de herança conectando classes corretamente sem erros visuais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação UML (draw.io, PlantUML, Visual Paradigm)",
                                    "Referência da hierarquia do Step 1"
                                  ],
                                  "tips": "Mantenha o diagrama limpo: use layout hierárquico automático; destaque Throwable com cor ou negrito.",
                                  "learningObjective": "Construir um diagrama UML preciso e visualmente claro da hierarquia de exceções.",
                                  "commonMistakes": [
                                    "Posicionar subclasses acima das superclasses",
                                    "Cruzar setas desnecessariamente",
                                    "Incluir classes irrelevantes como personalizadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar, Refinar e Documentar o Diagrama",
                                  "subSteps": [
                                    "Compare o diagrama com a documentação Java para verificar heranças.",
                                    "Adicione legendas explicando setas, checked/unchecked e exemplos de uso.",
                                    "Teste legibilidade: imprima ou compartilhe e peça feedback simulado.",
                                    "Otimize layout para fluxo visual descendente.",
                                    "Exporte em formato PNG/SVG e anote observações em um README."
                                  ],
                                  "verification": "Uma revisão por pares ou auto-revisão confirma 100% de precisão nas relações.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagrama gerado do Step 3",
                                    "Checklist de validação hierarquia Java"
                                  ],
                                  "tips": "Use zoom out para checar proporções; inclua versão textual (PlantUML code) para versionamento.",
                                  "learningObjective": "Garantir que o diagrama seja preciso, legível e pronto para uso profissional.",
                                  "commonMistakes": [
                                    "Ignorar validação factual",
                                    "Diagrama muito denso sem legendas",
                                    "Exportar em resolução baixa"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando draw.io, crie um diagrama com Throwable no topo (retângulo azul), seta para Exception (verde, com nota 'Checked & Unchecked'), sub-seta para RuntimeException (vermelha, 'Unchecked') com filhas NullPointerException e ArrayIndexOutOfBoundsException, e para IOException sob Exception. Adicione legenda: 'Seta triangular = extends'.",
                              "finalVerifications": [
                                "Todas as setas de herança apontam corretamente da subclasse para superclasse.",
                                "Pelo menos 10 classes da hierarquia Java estão representadas com nomes exatos.",
                                "Distinção visual entre checked e unchecked exceptions.",
                                "Diagrama é legível em tamanho A4 sem zoom.",
                                "Legenda explica símbolos usados.",
                                "Exportado em formato compartilhável (PNG/SVG)."
                              ],
                              "assessmentCriteria": [
                                "Precisão factual da hierarquia (100% match com Java API).",
                                "Correta aplicação de notação UML (setas, classes).",
                                "Clareza visual e organização hierárquica.",
                                "Cobertura de subclasses chave (mínimo 8).",
                                "Inclusão de legendas e anotações explicativas.",
                                "Profissionalismo no layout e exportação."
                              ],
                              "crossCurricularConnections": [
                                "Design de Software: Modelagem de sistemas OO.",
                                "Análise de Sistemas: Visualização de fluxos de erro.",
                                "Engenharia de Software: Documentação de APIs.",
                                "Banco de Dados: Hierarquias semelhantes em schemas relacionais."
                              ],
                              "realWorldApplication": "Em equipes de desenvolvimento Java, esse diagrama é usado em treinamentos, documentação de projetos enterprise e auditorias de código para mapear estratégias de tratamento de exceções, reduzindo bugs em aplicações como servidores web ou apps Android."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.3",
                        "name": "Exceções Customizadas via Herança",
                        "description": "Criação de novas classes de exceções personalizadas herdando da hierarquia existente, promovendo reutilização e especificidade em aplicações OO.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.3.1",
                            "name": "Criar exceção customizada herdando da base",
                            "description": "Implementar uma classe de exceção personalizada estendendo Exception ou RuntimeException, adicionando construtores e mensagens específicas, em Python ou C++.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a hierarquia de exceções e planejar a customizada",
                                  "subSteps": [
                                    "Revise a documentação oficial de exceções em Python (built-in exceptions).",
                                    "Identifique se deve herdar de Exception (para exceções checked-like) ou RuntimeException equivalente (ValueError ou Exception base).",
                                    "Defina o propósito da exceção: e.g., InvalidAgeException para idades negativas.",
                                    "Esboce os construtores necessários: init com mensagem, super().__init__.",
                                    "Planeje cenários de uso: validação de input em função de cadastro."
                                  ],
                                  "verification": "Crie um diagrama simples ou nota textual confirmando a escolha da classe base e propósitos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação Python (docs.python.org), editor de texto ou IDE como VS Code.",
                                  "tips": "Prefira herdar de Exception para exceções personalizadas que precisam ser tratadas explicitamente.",
                                  "learningObjective": "Compreender a hierarquia de exceções e decidir adequadamente a classe base para herança.",
                                  "commonMistakes": "Herdar diretamente de BaseException (reservado para built-ins); ignorar RuntimeError para erros não recuperáveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a classe de exceção básica herdando da base",
                                  "subSteps": [
                                    "Crie um novo arquivo Python: custom_exceptions.py.",
                                    "Defina class InvalidAgeException(Exception): pass",
                                    "Adicione __init__(self, message='Invalid age provided'): super().__init__(message)",
                                    "Teste instanciação básica: exc = InvalidAgeException('Age -5')",
                                    "Imprima exc para verificar mensagem."
                                  ],
                                  "verification": "Instancie a exceção e confirme que str(exc) retorna a mensagem customizada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python 3.x instalado, IDE (PyCharm ou VS Code com Python extension).",
                                  "tips": "Sempre chame super().__init__() para preservar comportamento da base.",
                                  "learningObjective": "Implementar herança básica de Exception com passagem de mensagem.",
                                  "commonMistakes": "Esquecer super().__init__() resultando em mensagens vazias; usar print em vez de raise."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar construtores avançados e atributos customizados",
                                  "subSteps": [
                                    "Expanda __init__ para aceitar idade inválida: def __init__(self, age, message='Invalid age'): self.age = age; super().__init__(f'{message}: {age}')",
                                    "Adicione método str(self): return f'InvalidAgeException: age {self.age} is invalid'",
                                    "Crie construtor sem args e com args variádicos para flexibilidade.",
                                    "Teste múltiplas instanciações: exc1 = InvalidAgeException(-5); exc2 = InvalidAgeException(150, 'Age too high')",
                                    "Verifique atributos: print(exc1.age, str(exc1))"
                                  ],
                                  "verification": "Execute testes unitários simples confirmando atributos e mensagens corretas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesmo IDE; módulo unittest para testes opcionais.",
                                  "tips": "Armazene contexto (como age) para logging/debugging posterior.",
                                  "learningObjective": "Estender construtores com dados customizados e sobrescrever métodos como __str__.",
                                  "commonMistakes": "Não validar tipos em __init__; sobrescrever __str__ sem chamar super().__str__ se necessário."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar, levantar e tratar a exceção em código real",
                                  "subSteps": [
                                    "Crie função register_user(age): if age < 0 or age > 150: raise InvalidAgeException(age)",
                                    "No main: try: register_user(-5); except InvalidAgeException as e: print(f'Error: {e}')",
                                    "Adicione finally para cleanup simulado.",
                                    "Teste cenários: input válido, inválido baixo, alto.",
                                    "Registre em log: import logging; logging.error(str(e))"
                                  ],
                                  "verification": "Execute o código com inputs variados e confirme que exceção é levantada e tratada corretamente sem crash.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python runtime, logging module.",
                                  "tips": "Use raise MyException() sem 'raise ... from' inicialmente para simplicidade.",
                                  "learningObjective": "Aplicar a exceção em fluxo real com try-except-finally.",
                                  "commonMistakes": "Usar print em vez de raise; capturar Exception genérica em vez de específica."
                                }
                              ],
                              "practicalExample": "Em um sistema de cadastro de usuários, defina InvalidAgeException. Na função register_user(age): if not 0 <= age <= 120: raise InvalidAgeException(age, 'Age out of range'). No caller: try: register_user(-10) except InvalidAgeException as e: print(f'Cadastro falhou: {e.age} é inválido').",
                              "finalVerifications": [
                                "A classe herda corretamente de Exception e instancia sem erros.",
                                "Construtores propagam mensagens e armazenam atributos customizados.",
                                "Exceção é levantada em condições específicas e capturada seletivamente.",
                                "Método __str__ retorna mensagem informativa com contexto.",
                                "Código roda sem crashes e logs erros adequadamente.",
                                "Testes com múltiplos cenários confirmam robustez."
                              ],
                              "assessmentCriteria": [
                                "Correta herança e chamada de super().__init__() (obrigatório).",
                                "Construtores flexíveis com pelo menos 2 overloads implícitos.",
                                "Integração em função com raise condicional lógico.",
                                "Tratamento específico via except MinhaExcecao.",
                                "Atributos customizados acessíveis e úteis.",
                                "Sem vazamentos de exceções não tratadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica condicional e validação de intervalos numéricos.",
                                "Design de Software: Princípios SOLID (Single Responsibility para exceções).",
                                "Banco de Dados: Exceções em validações de integridade referencial.",
                                "Segurança da Informação: Tratamento de inputs maliciosos."
                              ],
                              "realWorldApplication": "Em APIs web (Flask/Django), lançar InvalidInputException para validações de formulários, permitindo respostas HTTP 400 com detalhes; em jogos, PlayerDiedException para estados inválidos, facilitando restarts graceful."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.1",
                              "10.1.7.2.2"
                            ]
                          },
                          {
                            "id": "10.1.7.2.3.2",
                            "name": "Integrar exceção customizada em código OO",
                            "description": "Lançar e capturar uma exceção customizada em um programa OO, demonstrando polimorfismo na captura via blocos try-catch/except.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Projetar e criar a classe de exceção customizada",
                                  "subSteps": [
                                    "Analise o contexto da aplicação para definir o tipo de exceção necessária (ex: validação de dados inválidos).",
                                    "Crie uma nova classe que herde de Exception ou RuntimeException, dependendo se é checked ou unchecked.",
                                    "Adicione construtores personalizados: um padrão e outro com mensagem e causa.",
                                    "Implemente o método getMessage() se necessário para mensagens customizadas.",
                                    "Teste a compilação da classe isoladamente."
                                  ],
                                  "verification": "Compilar a classe sem erros e instanciar um objeto dela em um teste simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (Eclipse/IntelliJ/VS Code)",
                                    "JDK 8 ou superior"
                                  ],
                                  "tips": "Prefira herdar de Exception para exceções checked, forçando tratamento explícito.",
                                  "learningObjective": "Entender herança em exceções OO e criar classes customizadas funcionais.",
                                  "commonMistakes": [
                                    "Esquecer de chamar super() nos construtores",
                                    "Não importar java.lang.Exception",
                                    "Criar classe final, impedindo extensão futura"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o lançamento da exceção no código principal",
                                  "subSteps": [
                                    "Identifique pontos no código OO onde a exceção deve ser lançada (ex: método de validação).",
                                    "Adicione lógica condicional que detecte o erro e use 'throw new MinhaExcecao(...)'",
                                    "Integre em uma classe existente, como um serviço ou método de negócio.",
                                    "Garanta que o lançamento ocorra apenas em cenários inválidos, com mensagem clara.",
                                    "Compile e execute para verificar se lança ao acionar a condição."
                                  ],
                                  "verification": "Executar o código com input inválido e confirmar que a exceção é lançada com stack trace correto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "JDK",
                                    "Terminal para execução"
                                  ],
                                  "tips": "Use 'throw' em vez de 'return' para cenários excepcionais, preservando fluxo normal.",
                                  "learningObjective": "Aplicar lançamento de exceções customizadas em fluxos de controle OO.",
                                  "commonMistakes": [
                                    "Lançar exceção em casos normais (use return)",
                                    "Mensagens vagas sem detalhes do erro",
                                    "Não encapsular em métodos apropriados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Capturar a exceção demonstrando polimorfismo com try-catch",
                                  "subSteps": [
                                    "Envolva o código que lança a exceção em um bloco try.",
                                    "Adicione múltiplos catch: um específico para a customizada e um genérico (Exception) para polimorfismo.",
                                    "No catch específico, trate o erro (ex: log + ação corretiva).",
                                    "No catch genérico, capture exceções pais para demonstração de hierarquia.",
                                    "Adicione finally para cleanup, se aplicável."
                                  ],
                                  "verification": "Executar cenários: input válido (sem exceção), inválido (catch específico), e erro genérico (catch pai).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "JDK"
                                  ],
                                  "tips": "Ordem dos catch importa: específicos primeiro, genéricos por último para polimorfismo.",
                                  "learningObjective": "Dominar captura polimórfica de exceções via hierarquia de classes.",
                                  "commonMistakes": [
                                    "Catch genérico antes do específico (nunca captura o customizado)",
                                    "Esquecer finally para recursos",
                                    "Ignorar a exceção sem tratamento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar integralmente e refinar o tratamento",
                                  "subSteps": [
                                    "Crie casos de teste unitários com JUnit para lançamento e captura.",
                                    "Simule inputs variados: válidos, inválidos e edge cases.",
                                    "Analise stack traces e ajuste mensagens para clareza.",
                                    "Refatore código para melhor legibilidade e performance.",
                                    "Documente o uso da exceção com Javadoc."
                                  ],
                                  "verification": "Todos os testes passam, com 100% cobertura de cenários de exceção.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "JUnit 5",
                                    "Editor com suporte a testes"
                                  ],
                                  "tips": "Use assertions em testes para verificar mensagens e tipos de exceção.",
                                  "learningObjective": "Garantir robustez do código OO com tratamento de exceções testado.",
                                  "commonMistakes": [
                                    "Não testar edge cases",
                                    "Ignorar performance de catch desnecessários",
                                    "Falta de documentação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de cadastro de usuário, crie InvalidEmailException herdando de Exception. No método validarEmail(), lance se formato inválido. No main(), use try-catch específico para InvalidEmailException (mostra 'Email inválido') e catch Exception (polimorfismo para outros erros). Teste com 'user@exemplo' (válido) e 'user@' (inválido).",
                              "finalVerifications": [
                                "A classe customizada compila e herda corretamente de Exception.",
                                "Exceção é lançada apenas em condições inválidas com mensagem precisa.",
                                "Try-catch captura especificamente a customizada e genérica via polimorfismo.",
                                "Testes unitários cobrem 100% dos cenários.",
                                "Stack trace mostra hierarquia correta.",
                                "Código é legível e documentado."
                              ],
                              "assessmentCriteria": [
                                "Correta herança e construtores na classe de exceção (30%)",
                                "Lançamento condicional preciso (20%)",
                                "Captura polimórfica funcional (25%)",
                                "Testes completos e robustos (15%)",
                                "Código limpo, com tips aplicados (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Design de Software: Padrões como Template Method para validações.",
                                "Debugging e Testing: Uso de JUnit para exceções.",
                                "Algoritmos: Validação de expressões regulares em emails.",
                                "Banco de Dados: Exceções em transações SQL."
                              ],
                              "realWorldApplication": "Em aplicações web como e-commerces, lançar CustomValidationException em formulários de pagamento inválidos, capturando para exibir mensagens amigáveis ao usuário, evitando crashes e melhorando UX."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.7.2.3.3",
                            "name": "Analisar vantagens da herança em exceções",
                            "description": "Discutir benefícios como extensibilidade, polimorfismo e manutenção de código ao usar herança para exceções customizadas em projetos OO.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos da herança em exceções",
                                  "subSteps": [
                                    "Revise a hierarquia padrão de exceções em linguagens OO como Java ou C#.",
                                    "Identifique classes base como Exception e RuntimeException.",
                                    "Crie uma exceção customizada simples herdando de Exception.",
                                    "Compile e teste o lançamento dessa exceção em um código básico.",
                                    "Analise o código fonte da classe base para entender métodos herdados."
                                  ],
                                  "verification": "Consegue criar e lançar uma exceção customizada sem erros de compilação?",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE (Eclipse ou IntelliJ)",
                                    "Documentação oficial de exceções (Java Docs)"
                                  ],
                                  "tips": "Sempre herde de Exception para checked exceptions ou RuntimeException para unchecked, conforme necessidade.",
                                  "learningObjective": "Entender a base conceitual da herança em exceções para análise posterior.",
                                  "commonMistakes": [
                                    "Herdar diretamente de Throwable em vez de Exception",
                                    "Não importar a classe base corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a vantagem de extensibilidade",
                                  "subSteps": [
                                    "Crie uma hierarquia com superclasse CustomException e subclasses como DatabaseException e NetworkException.",
                                    "Adicione campos e métodos específicos em cada subclasse.",
                                    "Estenda a hierarquia adicionando uma nova subclasse sem alterar código existente.",
                                    "Teste o lançamento e captura de exceções em diferentes níveis.",
                                    "Documente como novas exceções podem ser adicionadas facilmente."
                                  ],
                                  "verification": "Pode adicionar uma nova subclasse à hierarquia sem modificar classes existentes?",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE com suporte a Java/C#",
                                    "Exemplo de código base fornecido"
                                  ],
                                  "tips": "Use construtores protegidos na superclasse para padronizar inicialização.",
                                  "learningObjective": "Identificar como a herança permite adicionar funcionalidades sem quebrar código legado.",
                                  "commonMistakes": [
                                    "Modificar superclasse para adicionar subclasses",
                                    "Não usar 'super()' nos construtores"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o polimorfismo em exceções herdadas",
                                  "subSteps": [
                                    "Implemente um bloco try-catch que capture a superclasse e trate subclasses diferentemente.",
                                    "Use instanceof ou getClass() para polimorfismo em handlers.",
                                    "Crie um método genérico que lance exceções polimórficas baseado em condições.",
                                    "Teste o comportamento polimórfico em cenários reais de erro.",
                                    "Compare com exceções não herdadas para destacar a flexibilidade."
                                  ],
                                  "verification": "O código captura e trata corretamente exceções específicas via superclasse?",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE",
                                    "JUnit para testes automatizados"
                                  ],
                                  "tips": "Prefira catching específico antes do genérico para granularidade.",
                                  "learningObjective": "Demonstrar como polimorfismo simplifica o tratamento de exceções variadas.",
                                  "commonMistakes": [
                                    "Capturar Throwable em vez de exceções específicas",
                                    "Ignorar ordem de catch blocks"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar o impacto na manutenção de código",
                                  "subSteps": [
                                    "Refatore um código com exceções flatas para usar herança.",
                                    "Meça a redução em duplicação de código de tratamento.",
                                    "Simule mudanças em requisitos e avalie facilidade de manutenção.",
                                    "Analise métricas como linhas de código e cyclomatic complexity antes/depois.",
                                    "Discuta cenários onde manutenção seria difícil sem herança."
                                  ],
                                  "verification": "Pode listar pelo menos 3 melhorias na manutenibilidade após refatoração?",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramentas de análise estática (SonarQube)",
                                    "Código legado de exemplo"
                                  ],
                                  "tips": "Centralize logging e mensagens na superclasse para DRY principle.",
                                  "learningObjective": "Compreender como herança reduz custos de manutenção em projetos OO.",
                                  "commonMistakes": [
                                    "Excesso de herança levando a deep hierarchies",
                                    "Não documentar exceções customizadas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de banco online, crie BankingException como superclasse, com subclasses InsufficientFundsException e InvalidAccountException. Lance InsufficientFundsException em transferências falhas e capture BankingException para logging genérico, permitindo extensões futuras como FraudException sem alterar handlers existentes.",
                              "finalVerifications": [
                                "Explica corretamente extensibilidade com exemplo de nova subclasse.",
                                "Demonstra polimorfismo em um try-catch hierárquico.",
                                "Lista 3 benefícios na manutenção de código.",
                                "Compara herança vs. exceções independentes.",
                                "Identifica cenários reais onde herança é vantajosa.",
                                "Cria hierarquia funcional sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de pelo menos 3 vantagens principais.",
                                "Uso correto de conceitos OO (herança, polimorfismo).",
                                "Exemplos práticos relevantes e testáveis.",
                                "Análise comparativa clara com alternativas.",
                                "Profundidade nos impactos de manutenção.",
                                "Clareza e estrutura na explicação escrita/oral."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Princípios SOLID (Open-Closed Principle).",
                                "Design Patterns: Template Method em handlers de exceções.",
                                "Análise de Sistemas: Modelagem de erros em UML.",
                                "Banco de Dados: Exceções customizadas para SQL errors."
                              ],
                              "realWorldApplication": "Em frameworks como Spring Boot ou .NET, hierarquias de exceções customizadas (ex: DataAccessException) permitem tratamento unificado, extensibilidade para novos módulos e manutenção facilitada em equipes grandes, reduzindo tempo de debugging em produção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.3",
                    "name": "Bloco Try-Catch/Except",
                    "description": "Mecanismo para capturar e tratar exceções específicas ou genéricas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.3.1",
                        "name": "Bloco Try-Except em Python",
                        "description": "Mecanismo em Python para envolver código suscetível a exceções no bloco try e capturá-las no bloco except, permitindo tratamento específico ou genérico.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.1.1",
                            "name": "Implementar bloco try-except básico",
                            "description": "Escrever um bloco try-except simples em Python para capturar uma exceção genérica, como uma divisão por zero, e exibir uma mensagem de erro personalizada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender conceitos básicos de exceções e sintaxe do try-except",
                                  "subSteps": [
                                    "Leia a documentação oficial do Python sobre exceções (busque 'Python exceptions' no Google).",
                                    "Identifique o que acontece em um erro como divisão por zero (ZeroDivisionError).",
                                    "Estude a sintaxe básica: try: ... except: ...",
                                    "Anote diferenças entre exceções específicas e genéricas (use 'except Exception' para genérica).",
                                    "Visualize um fluxograma simples do fluxo try-except."
                                  ],
                                  "verification": "Explique em voz alta ou anote: 'O que o try-except faz quando uma exceção ocorre?'",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Navegador web",
                                    "Editor de notas",
                                    "Documentação Python (docs.python.org)"
                                  ],
                                  "tips": "Comece com exemplos simples; evite pular para código sem entender o porquê.",
                                  "learningObjective": "Compreender o propósito e a estrutura do bloco try-except para tratamento de erros.",
                                  "commonMistakes": [
                                    "Confundir 'except' com 'if-else'",
                                    "Ignorar a hierarquia de exceções",
                                    "Esquecer indentação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e executar código com erro intencional sem tratamento",
                                  "subSteps": [
                                    "Abra um editor Python (IDLE, VS Code ou Jupyter).",
                                    "Escreva um script simples: num1 = 10; num2 = 0; resultado = num1 / num2; print(resultado).",
                                    "Execute o código e observe o traceback de erro (ZeroDivisionError).",
                                    "Copie o erro para um arquivo de notas para referência.",
                                    "Teste com num2 = 2 para ver execução normal."
                                  ],
                                  "verification": "Confirme que o programa crasha com divisão por zero e exibe traceback.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Python instalado (versão 3.x)",
                                    "Editor de código (VS Code recomendado)"
                                  ],
                                  "tips": "Use print() antes da divisão para debugar valores de variáveis.",
                                  "learningObjective": "Reproduzir um erro comum para motivar o uso de try-except.",
                                  "commonMistakes": [
                                    "Não salvar o arquivo antes de executar",
                                    "Usar divisão inteira (//) que não gera exceção",
                                    "Ignorar o traceback completo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o bloco try-except básico com exceção genérica",
                                  "subSteps": [
                                    "Modifique o código: envolva a divisão em try: resultado = num1 / num2.",
                                    "Adicione except Exception: print('Erro: Divisão por zero não permitida!').",
                                    "Mantenha o print(resultado) fora do try para casos normais.",
                                    "Salve e execute com num2 = 0 (deve mostrar mensagem customizada).",
                                    "Teste com num2 = 2 (deve mostrar resultado normal)."
                                  ],
                                  "verification": "O programa executa sem crash, mostra mensagem de erro em falha e resultado em sucesso.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Mesmo editor e Python do step anterior"
                                  ],
                                  "tips": "Use 'except Exception as e: print(f\"Erro: {e}\")' para mais detalhes inicialmente.",
                                  "learningObjective": "Escrever sintaxe correta de try-except para capturar exceções genéricas.",
                                  "commonMistakes": [
                                    "Indentação errada no except",
                                    "Usar 'except ZeroDivisionError' em vez de genérica inicialmente",
                                    "Colocar print(resultado) dentro do except"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, refinar e verificar robustez do bloco",
                                  "subSteps": [
                                    "Adicione input() para num1 e num2: num1 = float(input('Número 1: ')).",
                                    "Teste casos: divisão por zero, números negativos, não-números (ValueError).",
                                    "Ajuste para capturar múltiplas exceções se necessário (adicione outro except).",
                                    "Registre saídas em um log simples (use print com timestamp).",
                                    "Compare com versão sem try-except."
                                  ],
                                  "verification": "Todos testes passam: erros capturados com mensagens claras, sucessos computados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor Python",
                                    "Papel para anotar testes"
                                  ],
                                  "tips": "Sempre teste edge cases como input inválido para robustez.",
                                  "learningObjective": "Garantir que o try-except funcione em cenários reais variados.",
                                  "commonMistakes": [
                                    "Não testar input não-numérico",
                                    "Expor variáveis não definidas em except",
                                    "Sobre-escrever resultado em except"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um programa de calculadora simples de divisão:\n\nnum1 = float(input('Digite o dividendo: '))\nnum2 = float(input('Digite o divisor: '))\n\ntry:\n    resultado = num1 / num2\n    print(f'Resultado: {resultado}')\nexcept Exception:\n    print('Erro: Operação inválida! Verifique os números.')\n\nSaída esperada para 10/0: 'Erro: Operação inválida! Verifique os números.'",
                              "finalVerifications": [
                                "O código executa sem crashar ao dividir por zero.",
                                "Mensagem de erro personalizada é exibida corretamente.",
                                "Divisões válidas produzem resultados precisos.",
                                "Input inválido (letras) é capturado pela exceção genérica.",
                                "Comparação com versão sem try-except confirma prevenção de crash.",
                                "Código mantém indentação e sintaxe Python válida."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe try-except correta e indentada adequadamente.",
                                "Captura exceção genérica (Exception ou bare except) efetivamente.",
                                "Mensagem de erro clara e personalizada.",
                                "Fluxo lógico: sucesso imprime resultado, falha imprime erro.",
                                "Testes cobrem casos normais e de erro.",
                                "Código é legível com comentários explicativos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Reforça operações aritméticas e compreensão de indefinidos (divisão por zero).",
                                "Lógica e Algoritmos: Similar a estruturas condicionais para fluxo de controle.",
                                "Segurança Computacional: Introduz conceitos de robustez e prevenção de falhas.",
                                "Inglês Técnico: Vocabulário de programação (exception, try, catch).",
                                "Design de Software: Boas práticas de user-friendly error handling."
                              ],
                              "realWorldApplication": "Em aplicativos como calculadoras online, jogos (evitar crashes por inputs inválidos), scripts de automação (processamento de arquivos com erros de leitura) ou APIs web (retornar erros HTTP 500 sem quebrar o servidor), o try-except básico previne falhas catastróficas e melhora a experiência do usuário."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.1.2",
                            "name": "Capturar exceções específicas em Python",
                            "description": "Utilizar except seguido de uma exceção específica (ex: ZeroDivisionError, ValueError) para tratar erros direcionados, evitando captura desnecessária de outras exceções.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender exceções específicas comuns em Python",
                                  "subSteps": [
                                    "Acesse a documentação oficial do Python (docs.python.org) e navegue para a seção de exceções integradas.",
                                    "Liste pelo menos 5 exceções específicas comuns, como ZeroDivisionError, ValueError, TypeError, IndexError e KeyError, anotando cenários onde ocorrem.",
                                    "Crie um glossário pessoal com definições breves e exemplos de triggers para cada uma.",
                                    "Compare exceções específicas com a exceção base Exception para entender por que capturar específicas é preferível.",
                                    "Teste manualmente uma exceção em um interpretador Python para observá-la em ação."
                                  ],
                                  "verification": "Glossário completo com 5 exceções listadas e um teste que gera uma exceção específica sem tratamento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Python (docs.python.org/3/library/exceptions.html)",
                                    "Interpretador Python (IDLE ou terminal)"
                                  ],
                                  "tips": "Priorize exceções que você espera no seu código; hierarquia de exceções importa (ex: ValueError herda de Exception).",
                                  "learningObjective": "Identificar e diferenciar exceções específicas de genéricas para tratamento direcionado.",
                                  "commonMistakes": [
                                    "Confundir exceções built-in com custom; listar apenas genéricas como Exception."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar a sintaxe do bloco try-except com exceção específica",
                                  "subSteps": [
                                    "Escreva a sintaxe básica: try: <código> except ZeroDivisionError: <tratamento>.",
                                    "Crie um script simples que tente dividir dois números e capture ZeroDivisionError com uma mensagem personalizada.",
                                    "Adicione um print para confirmar que o tratamento foi ativado apenas para divisão por zero.",
                                    "Execute o código com inputs válidos e inválidos (divisão por zero) para validar seletividade.",
                                    "Modifique para capturar ValueError em uma conversão int(input()) falha."
                                  ],
                                  "verification": "Código executável que captura apenas a exceção específica e ignora outras (ex: TypeError passa sem capturar).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, PyCharm)",
                                    "Interpretador Python"
                                  ],
                                  "tips": "Use 'as e' para capturar a exceção e acessá-la: except ZeroDivisionError as e: print(e).",
                                  "learningObjective": "Construir sintaxe correta para capturar uma única exceção específica sem broadcatching.",
                                  "commonMistakes": [
                                    "Escrever except: sem especificar exceção; indentação errada no bloco try-except."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar captura de múltiplas exceções específicas",
                                  "subSteps": [
                                    "Expanda o código para capturar ValueError e ZeroDivisionError em uma função de cálculo.",
                                    "Use tuplas: except (ValueError, ZeroDivisionError): para múltiplas no mesmo bloco.",
                                    "Adicione excepts separados para tratamentos diferentes por exceção.",
                                    "Inclua um else: para código que roda só se não houver exceção.",
                                    "Teste com cenários: input inválido (ValueError), divisão por zero, e input válido."
                                  ],
                                  "verification": "Função que trata exceções específicas corretamente, executa else em sucesso, e loga erros apropriados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Python 3.x instalado"
                                  ],
                                  "tips": "Ordem importa: exceções mais específicas primeiro; evite except Exception como último recurso.",
                                  "learningObjective": "Gerenciar múltiplas exceções específicas de forma seletiva e eficiente.",
                                  "commonMistakes": [
                                    "Capturar exceções broad antes de específicas; esquecer else para fluxo normal."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e depurar captura de exceções em um programa realista",
                                  "subSteps": [
                                    "Crie um programa que leia números de um arquivo ou input e calcule médias, capturando exceções específicas.",
                                    "Adicione finally: para cleanup (ex: fechar arquivo).",
                                    "Introduza erros propositalmente e depure usando print ou debugger.",
                                    "Refatore para propagar exceções não tratadas com raise.",
                                    "Valide que o programa continua rodando apesar de erros isolados."
                                  ],
                                  "verification": "Programa completo que roda sem crash, trata exceções específicas e usa finally corretamente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Arquivo de teste com dados (ex: numbers.txt)"
                                  ],
                                  "tips": "Use logging em vez de print para tratamentos profissionais; teste edge cases como inputs vazios.",
                                  "learningObjective": "Aplicar captura específica em contexto maior, garantindo robustez.",
                                  "commonMistakes": [
                                    "Tratar todas exceções no finally; não testar cenários sem erro."
                                  ]
                                }
                              ],
                              "practicalExample": "Defina uma função calc_divisao(a, b):\ntry:\n    resultado = a / b\nexcept ZeroDivisionError:\n    print('Erro: Divisão por zero!')\n    return None\nexcept ValueError:\n    print('Erro: Valores inválidos!')\n    return None\nelse:\n    print('Resultado:', resultado)\n    return resultado\nfinally:\n    print('Cálculo finalizado.')\nTeste com calc_divisao(10, 0) e calc_divisao('a', 2).",
                              "finalVerifications": [
                                "Escreva código que captura apenas ZeroDivisionError e ValueError, ignorando outras.",
                                "Demonstre seletividade: exceções não listadas propagam sem tratamento.",
                                "Inclua else e finally corretamente em um bloco try-except.",
                                "Programa roda até o fim apesar de exceções tratadas.",
                                "Explique verbalmente por que except Exception: é evitado.",
                                "Teste com 3 cenários diferentes gera outputs esperados."
                              ],
                              "assessmentCriteria": [
                                "Código usa except com exceções específicas, não genéricas.",
                                "Tratamentos são direcionados e informativos por exceção.",
                                "Seletividade comprovada: outras exceções não são capturadas.",
                                "Estrutura inclui try, except(s), else e finally quando aplicável.",
                                "Código é limpo, indentado corretamente e sem erros de sintaxe.",
                                "Comentários explicam escolhas de exceções."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Tratamento de erros em operações aritméticas como divisão.",
                                "Lógica e Algoritmos: Fluxo condicional robusto para cenários de falha.",
                                "Ciência da Computação: Princípios de depuração e resiliência de software.",
                                "Inglês Técnico: Leitura de documentação oficial de exceções.",
                                "Design de Sistemas: Melhoria de UX evitando crashes em apps."
                              ],
                              "realWorldApplication": "Em aplicativos web (ex: Flask/Django), capturar ValueError em formulários de input para validar dados sem crashar a página; em scripts de automação de dados, tratar FileNotFoundError ou KeyError em processamentos de CSV/JSON para continuidade operacional em produção."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.1.3",
                            "name": "Usar blocos else e finally",
                            "description": "Incorporar else (executado se não houver exceção) e finally (sempre executado) em um bloco try-except para limpeza de recursos e lógica condicional em Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar estrutura básica do try-except e introduzir else e finally",
                                  "subSteps": [
                                    "Execute um bloco try-except simples capturando uma exceção como ZeroDivisionError.",
                                    "Leia a documentação oficial do Python sobre try, except, else e finally (docs.python.org).",
                                    "Identifique que 'else' executa apenas se não houver exceção no try, e 'finally' sempre executa.",
                                    "Escreva um pseudocódigo anotado explicando a sequência de execução.",
                                    "Teste a sequência com prints em cada bloco para visualizar a ordem."
                                  ],
                                  "verification": "Confirme que prints mostram: try -> else -> finally (sem exceção) e try -> except -> finally (com exceção).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código (VS Code ou IDLE), interpretador Python 3.x, documentação Python online.",
                                  "tips": "Use print statements generosamente para depurar a ordem de execução.",
                                  "learningObjective": "Compreender a sequência exata de execução dos blocos try, except, else e finally.",
                                  "commonMistakes": "Confundir else com código que sempre executa (ele só roda sem exceção); esquecer que finally roda mesmo com return."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e testar o bloco else",
                                  "subSteps": [
                                    "Crie um função que divida números; use try-except para divisão por zero, e else para processar resultado se sucesso.",
                                    "No else, realize uma operação adicional como multiplicar o resultado por 2.",
                                    "Teste com valores válidos (ativa else) e inválidos (pula else).",
                                    "Adicione logging ou print para confirmar execução do else.",
                                    "Refatore para usar else em um loop simples com múltiplas tentativas."
                                  ],
                                  "verification": "Verifique logs: else executa só em casos sem exceção; código continua corretamente após else.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Mesmo do step 1; notebook Jupyter para testes interativos.",
                                  "tips": "Pense no else como 'sucesso handler' para código que só faz sentido sem erros.",
                                  "learningObjective": "Aplicar else para lógica condicional pós-try bem-sucedido.",
                                  "commonMistakes": "Colocar código no else que poderia levantar exceções (isso vai para except); indentação errada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e testar o bloco finally para limpeza",
                                  "subSteps": [
                                    "Simule abertura de um arquivo com open() em try; except para FileNotFoundError; finally para fechar o arquivo.",
                                    "Use try-finally sem except para cenários onde sempre limpa, independentemente de erro.",
                                    "Teste com arquivo existente e inexistente, confirmando fechamento sempre.",
                                    "Estenda para context managers (with statement) como alternativa, mas foque em finally.",
                                    "Meça tempo de execução com finally contendo print de cleanup."
                                  ],
                                  "verification": "Arquivo sempre fecha (verifique com try-except em finally ou logs); sem vazamentos de recursos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor Python, arquivos de teste locais (crie um txt simples).",
                                  "tips": "Finally é ideal para desalocar recursos como arquivos, conexões DB ou locks.",
                                  "learningObjective": "Usar finally para garantir limpeza de recursos em todos os cenários.",
                                  "commonMistakes": "Esquecer finally e causar vazamento de recursos; exceções em finally não capturadas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar try-except-else-finally em um exemplo completo",
                                  "subSteps": [
                                    "Crie função que abre arquivo, lê conteúdo (try), trata erros de arquivo/leitura (except), processa se sucesso (else), fecha sempre (finally).",
                                    "Adicione exceções múltiplas (ValueError na processamento).",
                                    "Teste todos caminhos: sucesso total, erro arquivo, erro processamento.",
                                    "Refatore para uma classe com método que usa esses blocos.",
                                    "Documente o código com comentários explicando cada bloco."
                                  ],
                                  "verification": "Todos caminhos testados rodam corretamente; finally sempre executa; else só em sucesso.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Todos anteriores; git para versionar testes.",
                                  "tips": "Estruture como: try (operação arriscada) -> except (recuperação) -> else (pós-sucesso) -> finally (limpeza).",
                                  "learningObjective": "Integrar todos blocos em código robusto para tratamento completo de exceções.",
                                  "commonMistakes": "Return no try pulando else/finally (finally ainda roda); ordem errada dos blocos."
                                }
                              ],
                              "practicalExample": "```python\ndef process_file(filename):\n    try:\n        f = open(filename, 'r')\n    except FileNotFoundError:\n        print('Arquivo não encontrado!')\n        return None\n    else:\n        content = f.read().strip()\n        result = len(content) * 2  # Processamento só se sucesso\n        print(f'Resultado: {result}')\n    finally:\n        f.close()\n        print('Arquivo fechado.')\n\nprocess_file('exists.txt')  # Sucesso: try-else-finally\nprocess_file('missing.txt') # Except-finally```",
                              "finalVerifications": [
                                "Código executa todos caminhos sem crashes inesperados.",
                                "Else roda apenas sem exceções no try.",
                                "Finally executa em todos cenários, incluindo returns ou breaks.",
                                "Recursos (arquivos, conexões simuladas) são limpos corretamente.",
                                "Logs ou prints confirmam sequência exata de execução.",
                                "Múltiplas exceções são tratadas seletivamente."
                              ],
                              "assessmentCriteria": [
                                "Correta colocação e indentação de else e finally.",
                                "Lógica condicional no else é apropriada e executa só pós-sucesso.",
                                "Finally garante cleanup incondicional sem exceções próprias.",
                                "Código é legível com comentários explicando blocos.",
                                "Testes cobrem sucesso, falhas e edge cases.",
                                "Uso eficiente evita duplicação de código."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica condicional similar a if-else em fluxogramas.",
                                "Língua Portuguesa/Inglês: Documentação clara de código e erros.",
                                "Ciências da Computação: Princípios de programação defensiva e RAII.",
                                "Gestão de Projetos: Gerenciamento de recursos e tratamento de falhas."
                              ],
                              "realWorldApplication": "Em aplicações web (Flask/Django), usar try-except-else-finally para conexões banco de dados: try (query), except (rollback), else (commit), finally (close conexão), evitando vazamentos e garantindo transações atômicas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.3.2",
                        "name": "Bloco Try-Catch em C++",
                        "description": "Mecanismo em C++ para detectar exceções no bloco try e tratá-las no bloco catch, suportando exceções específicas ou genéricas em contextos orientados a objetos.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.2.1",
                            "name": "Implementar bloco try-catch básico",
                            "description": "Criar um bloco try-catch em C++ para lançar e capturar uma exceção padrão (ex: std::runtime_error) gerada por código como divisão por zero.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de desenvolvimento",
                                  "subSteps": [
                                    "Instale ou verifique um compilador C++ como g++ (via MinGW no Windows ou nativo no Linux/Mac).",
                                    "Crie um novo arquivo com extensão .cpp, por exemplo 'try_catch.cpp'.",
                                    "Inclua as bibliotecas necessárias: #include <iostream> e #include <stdexcept>.",
                                    "Adicione 'using namespace std;' e a estrutura básica int main() { return 0; }.",
                                    "Compile o arquivo vazio com 'g++ try_catch.cpp -o try_catch' para testar."
                                  ],
                                  "verification": "O programa compila e executa sem erros, exibindo saída vazia.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Compilador g++",
                                    "Editor de texto ou IDE (VS Code, Code::Blocks)"
                                  ],
                                  "tips": "Use um IDE com destaque de sintaxe para identificar erros rapidamente.",
                                  "learningObjective": "Preparar um ambiente funcional para experimentação com exceções.",
                                  "commonMistakes": [
                                    "Esquecer de instalar o compilador",
                                    "Omitir 'using namespace std;' causando erros de escopo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar código propenso a exceção",
                                  "subSteps": [
                                    "Crie uma função double dividir(double a, double b) { if (b == 0) throw std::runtime_error(\"Divisão por zero!\"); return a / b; }.",
                                    "No main(), leia dois números double do usuário com cin >> num1 >> num2.",
                                    "Chame dividir(num1, num2) e imprima o resultado com cout.",
                                    "Compile e execute com entrada que cause divisão por zero (ex: 10 0)."
                                  ],
                                  "verification": "O programa crasha com mensagem de erro de runtime ao dividir por zero.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Mesmo ambiente do step 1"
                                  ],
                                  "tips": "Teste com valores válidos primeiro para confirmar a função normal.",
                                  "learningObjective": "Gerar uma exceção controlada para simular erro comum.",
                                  "commonMistakes": [
                                    "Não usar throw com std::runtime_error",
                                    "Verificar b==0 sem double precisão (use b == 0.0)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar bloco try-catch",
                                  "subSteps": [
                                    "Envolva a chamada dividir(num1, num2) em um bloco try { ... }.",
                                    "Adicione catch (std::runtime_error& e) { cout << \"Erro capturado: \" << e.what() << endl; } após o try.",
                                    "Adicione um catch genérico catch (...) { cout << \"Erro desconhecido!\" << endl; } para exceções não tratadas.",
                                    "Mantenha o return 0; no final do main().",
                                    "Compile novamente para verificar sintaxe."
                                  ],
                                  "verification": "Compilação bem-sucedida sem warnings sobre exceções.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código do step anterior"
                                  ],
                                  "tips": "Use & na referência do catch para evitar cópia desnecessária da exceção.",
                                  "learningObjective": "Capturar e tratar exceções específicas de forma hierárquica.",
                                  "commonMistakes": [
                                    "Fechar try sem catch correspondente",
                                    "Não incluir <stdexcept> causando erro de compilação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar o tratamento de exceções",
                                  "subSteps": [
                                    "Execute com divisão por zero: verifique se imprime mensagem sem crash.",
                                    "Teste com valores válidos: confirme cálculo correto.",
                                    "Teste com input inválido (letras): observe comportamento do cin.",
                                    "Adicione mais testes: divida por número muito pequeno para overflow.",
                                    "Analise saída e ajuste mensagens se necessário."
                                  ],
                                  "verification": "Programa lida graciosamente com erros, sem terminação abrupta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Executável compilado"
                                  ],
                                  "tips": "Use debugger (gdb) para pausar em throw e inspecionar variáveis.",
                                  "learningObjective": "Garantir robustez do código através de testes variados.",
                                  "commonMistakes": [
                                    "Ignorar cenários edge como input não-numérico",
                                    "Catch muito genérico sem especificidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo completo:\n#include <iostream>\n#include <stdexcept>\nusing namespace std;\ndouble dividir(double a, double b) {\n  if (b == 0.0) throw runtime_error(\"Divisão por zero!\");\n  return a / b;\n}\nint main() {\n  double num1, num2;\n  cin >> num1 >> num2;\n  try {\n    cout << \"Resultado: \" << dividir(num1, num2) << endl;\n  } catch (runtime_error& e) {\n    cout << \"Erro: \" << e.what() << endl;\n  } catch (...) {\n    cout << \"Erro desconhecido!\" << endl;\n  }\n  return 0;\n}",
                              "finalVerifications": [
                                "Programa compila sem erros ou warnings.",
                                "Captura e exibe mensagem de std::runtime_error em divisão por zero.",
                                "Executa corretamente com entradas válidas.",
                                "Não crasha o terminal ou IDE em erros.",
                                "Catch genérico lida com exceções inesperadas.",
                                "Mensagens de erro são claras e em português."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe correta do try-catch com throw runtime_error.",
                                "Função lança exceção apenas em condição inválida (b==0).",
                                "Tratamento hierárquico: específico primeiro, genérico depois.",
                                "Leitura de input e saída formatada adequadamente.",
                                "Código limpo, indentado e comentado.",
                                "Testes cobrem casos válidos e inválidos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Compreensão de operações aritméticas e divisibilidade.",
                                "Lógica e Algoritmos: Controle de fluxo condicional e hierarquia.",
                                "Inglês Técnico: Leitura de documentação std::runtime_error.",
                                "Desenvolvimento de Software: Boas práticas de robustez.",
                                "Ética em Computação: Prevenção de falhas que afetam usuários."
                              ],
                              "realWorldApplication": "Em aplicativos bancários para validar transações sem crash (ex: divisão inválida em cálculos financeiros), jogos para lidar com inputs inválidos de jogadores, ou servidores web que processam dados usuário sem interrupções."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.2.2",
                            "name": "Capturar exceções específicas em C++",
                            "description": "Especificar tipos de exceções personalizadas ou padrões (ex: std::exception&) no catch para tratamento seletivo, propagando exceções não tratadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender exceções específicas versus genéricas em C++",
                                  "subSteps": [
                                    "Estude a hierarquia de exceções em C++ (std::exception como base).",
                                    "Compare catch(...) (genérico) com catch(std::exception& e) (específico).",
                                    "Analise exemplos de código onde catch genérico mascara erros específicos.",
                                    "Identifique cenários onde tratamento seletivo é essencial (ex: logging vs rethrow).",
                                    "Revise a documentação oficial da std::exception no cppreference."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre catch genérico e específico, com um exemplo escrito.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Compilador C++ (g++ ou clang++)",
                                    "cppreference.com para std::exception",
                                    "IDE como VS Code ou CLion"
                                  ],
                                  "tips": "Sempre priorize catches específicos antes do genérico para evitar swallowing de erros.",
                                  "learningObjective": "Diferenciar exceções específicas de genéricas e justificar seu uso seletivo.",
                                  "commonMistakes": [
                                    "Usar apenas catch(...) sem ordem correta",
                                    "Confundir referências (&) com valores por cópia"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir classes de exceção personalizadas",
                                  "subSteps": [
                                    "Crie uma classe derivada de std::exception (ex: class DivisaoPorZero : public std::exception).",
                                    "Implemente o construtor com mensagem personalizada usando what() const noexcept.",
                                    "Teste a compilação da classe isoladamente com um throw simples.",
                                    "Crie pelo menos duas exceções customizadas (ex: ArquivoNaoEncontrado, ValorInvalido).",
                                    "Verifique herança virtual para evitar problemas de diamante."
                                  ],
                                  "verification": "Compile e execute um código que throw sua exceção customizada e imprima what().",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Compilador C++ com suporte C++11+",
                                    "Exemplos de código de exceção no GitHub ou livros como 'C++ Primer'"
                                  ],
                                  "tips": "Use std::string para mensagens dinâmicas no construtor para flexibilidade.",
                                  "learningObjective": "Criar exceções personalizadas herdando de std::exception com mensagens úteis.",
                                  "commonMistakes": [
                                    "Esquecer noexcept em what()",
                                    "Não incluir <stdexcept> ou <exception>"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar blocos try-catch com capturas específicas",
                                  "subSteps": [
                                    "Escreva um bloco try com múltiplos throws de exceções diferentes.",
                                    "Adicione catches na ordem correta: específicas primeiro, genéricas por último.",
                                    "Use referências (ex: catch(DivisaoPorZero& e)) para evitar cópias desnecessárias.",
                                    "Inclua ações seletivas: log, rethrow ou recuperação por exceção.",
                                    "Compile e teste com inputs que triggerem cada catch."
                                  ],
                                  "verification": "Execute o código com cenários variados e confirme que apenas o catch correto é acionado.",
                                  "estimatedTime": "40-50 minutos",
                                  "materials": [
                                    "Terminal para compilar e rodar (g++ -std=c++17 arquivo.cpp)",
                                    "Debugger como gdb"
                                  ],
                                  "tips": "Ordem dos catches importa: mais derivadas primeiro para matching correto.",
                                  "learningObjective": "Estruturar try-catch para tratamento seletivo de exceções específicas e personalizadas.",
                                  "commonMistakes": [
                                    "Ordem errada de catches levando a matching inesperado",
                                    "Não usar & em catch causando slicing"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar propagação e verificação de exceções não tratadas",
                                  "subSteps": [
                                    "Adicione um catch genérico no final para capturar e logar exceções não tratadas.",
                                    "Implemente rethrow seletivo com throw; em catches específicos.",
                                    "Crie testes unitários simulando falhas (ex: divisão por zero, arquivo inválido).",
                                    "Use assert ou if para verificar se exceções propagam corretamente para chamadores.",
                                    "Analise stack trace com debugger para entender fluxo."
                                  ],
                                  "verification": "Gere relatório de testes mostrando catches seletivos e propagação correta.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Framework de testes como Google Test (opcional)",
                                    "Debugger integrado na IDE"
                                  ],
                                  "tips": "Rethrow preserva stack trace original; evite throw ex nova para não perder contexto.",
                                  "learningObjective": "Gerenciar propagação de exceções não tratadas e validar o fluxo completo.",
                                  "commonMistakes": [
                                    "Swallow exceções com empty catch",
                                    "Perder stack trace com throw new"
                                  ]
                                }
                              ],
                              "practicalExample": "#include <iostream>\n#include <stdexcept>\n#include <string>\nclass DivisaoPorZero : public std::exception {\npublic:\n    DivisaoPorZero() : msg(\"Divisão por zero!\") {}\n    const char* what() const noexcept override { return msg.c_str(); }\nprivate:\n    std::string msg;\n};\nint main() {\n    try {\n        int a = 10, b = 0;\n        if (b == 0) throw DivisaoPorZero();\n        std::cout << a / b << std::endl;\n    } catch (DivisaoPorZero& e) {\n        std::cerr << \"Capturada específica: \" << e.what() << std::endl;\n        throw; // Rethrow\n    } catch (std::exception& e) {\n        std::cerr << \"Genérica: \" << e.what() << std::endl;\n    }\n    return 0;\n}",
                              "finalVerifications": [
                                "Código compila sem warnings com -Wall -Wextra.",
                                "Exceções específicas são capturadas sem ativar catches genéricos.",
                                "Mensagens what() são impressas corretamente para custom exceptions.",
                                "Exceções não tratadas propagam para chamadores externos.",
                                "Nenhum crash ou undefined behavior em testes variados.",
                                "Stack trace preserva contexto original com rethrow."
                              ],
                              "assessmentCriteria": [
                                "Precisão na hierarquia e matching de exceções (100% seletivo).",
                                "Sintaxe correta de catch com referências e noexcept.",
                                "Tratamento robusto: log, recover ou rethrow apropriado.",
                                "Cobertura de pelo menos 3 tipos de exceções (std + 2 custom).",
                                "Eficiência: sem cópias desnecessárias ou overhead.",
                                "Documentação inline explicando escolhas de catch."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Princípios de robustez e fault-tolerance.",
                                "Matemática/Algoritmos: Tratamento de erros em computação numérica.",
                                "Design de Sistemas: Padrões Observer para logging de exceções.",
                                "Segurança da Informação: Prevenção de crashes exploráveis."
                              ],
                              "realWorldApplication": "Em aplicações críticas como servidores web (ex: Nginx com C++), onde capturar exceções específicas como 'conexão timeout' permite recuperação seletiva sem derrubar o serviço inteiro, garantindo alta disponibilidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.2.3",
                            "name": "Capturar exceções genéricas com catch(...)",
                            "description": "Usar catch(...) para capturar qualquer exceção não tratada anteriormente, permitindo logging ou re-lançamento em aplicações orientadas a objetos em C++.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito de Catch Genérico em C++",
                                  "subSteps": [
                                    "Revise o funcionamento de blocos try-catch em C++ para exceções específicas.",
                                    "Leia a documentação oficial do C++ sobre elipses (...) em catch para capturar exceções de qualquer tipo.",
                                    "Identifique cenários onde exceções não tratadas podem ocorrer, como erros de runtime inesperados.",
                                    "Compare catch específico (ex: catch(int e)) com catch(...) para entender a hierarquia.",
                                    "Anote diferenças entre exceções derivadas de std::exception e tipos desconhecidos."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que catch(...) é usado como último recurso em um bloco try-catch.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação C++ (cppreference.com sobre exceptions)",
                                    "Editor de código como VS Code ou CLion"
                                  ],
                                  "tips": "Sempre coloque catch(...) no final da lista de catches para evitar mascarar exceções específicas.",
                                  "learningObjective": "Compreender o papel do catch genérico como fallback para exceções não previstas.",
                                  "commonMistakes": [
                                    "Usar catch(...) como primeiro handler, ignorando exceções específicas.",
                                    "Confundir com catch(std::exception&), que não captura tipos não-derivados."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Sintaxe Básica de Catch Genérico",
                                  "subSteps": [
                                    "Escreva um bloco try simples que lance uma exceção int (ex: throw 42;).",
                                    "Adicione um catch específico para int.",
                                    "Inclua catch(...) após o catch específico para capturar qualquer outra exceção.",
                                    "Compile e execute o código para testar se exceções int são capturadas especificamente.",
                                    "Modifique para lançar std::runtime_error e verifique se catch(...) não interfere."
                                  ],
                                  "verification": "O código compila e executa sem capturar exceções específicas no handler errado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador C++ (g++ ou clang++)",
                                    "Terminal para compilar e rodar"
                                  ],
                                  "tips": "Use -Wall -Wextra nas flags de compilação para detectar problemas de exceções.",
                                  "learningObjective": "Dominar a sintaxe correta de catch(...) em sequência com outros handlers.",
                                  "commonMistakes": [
                                    "Esquecer o ponto-e-vírgula após catch(...){}",
                                    "Não incluir #include <iostream> para output."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar Logging e Re-lançamento",
                                  "subSteps": [
                                    "No corpo de catch(...), adicione std::cerr para logar uma mensagem genérica como 'Exceção desconhecida capturada'.",
                                    "Inclua throw; para re-lançar a exceção original após logging.",
                                    "Teste com uma exceção não tratada previamente, como divisão por zero via std::stoi inválido.",
                                    "Verifique logs no console e propagação da exceção para handlers externos.",
                                    "Adicione timestamp ao log usando <chrono> para realismo."
                                  ],
                                  "verification": "Exceções são logadas corretamente e re-lançadas, propagando para chamadas superiores.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Biblioteca <iostream>, <stdexcept>, <chrono>",
                                    "Exemplo de código base com funções aninhadas"
                                  ],
                                  "tips": "Use std::current_exception() se precisar de mais detalhes sem capturar argumentos.",
                                  "learningObjective": "Implementar logging seguro e re-lançamento para depuração sem perder stack trace.",
                                  "commonMistakes": [
                                    "Usar throw nova_excecao() em vez de throw;, perdendo contexto original.",
                                    "Ignorar exceções no catch(...), violando robustez."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Integrar em Aplicação OOP",
                                  "subSteps": [
                                    "Crie uma classe simples com método que pode falhar (ex: divisão em Calculator).",
                                    "Envolva chamadas em try-catch com catch(...) no main ou classe wrapper.",
                                    "Simule falhas múltiplas e verifique captura seletiva e logging.",
                                    "Refatore para usar RAII com std::unique_ptr para gerenciar exceções indiretamente.",
                                    "Execute com Valgrind ou debugger para inspecionar vazamentos pós-exceção."
                                  ],
                                  "verification": "Aplicação lida com exceções genéricas sem crash, logs corretos e cleanup adequado.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Debugger (gdb ou IDE integrado)",
                                    "Valgrind para análise de memória"
                                  ],
                                  "tips": "Em OOP, prefira exceções específicas em métodos de classe; genéricas só em boundaries.",
                                  "learningObjective": "Integrar catch(...) em contextos orientados a objetos para aplicações robustas.",
                                  "commonMistakes": [
                                    "Não limpar recursos em destructors durante unwind de exceções.",
                                    "Sobre-usar catch(...) em detrimento de análise de falhas específicas."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma classe Calculator: try { result = divide(a, 0); } catch (const std::invalid_argument& e) { /* específico */ } catch (...) { std::cerr << \"Erro inesperado em divisão: \" << std::endl; throw; } Isso loga falhas como divisão por zero não prevista e propaga.",
                              "finalVerifications": [
                                "Código compila sem warnings de exceções.",
                                "Exceções específicas são tratadas antes do genérico.",
                                "Logs aparecem no console para exceções desconhecidas.",
                                "Exceções são re-lançadas corretamente (stack trace preservado).",
                                "Aplicação não crasha e limpa recursos via RAII.",
                                "Testes com múltiplos tipos de exceções passam seletivamente."
                              ],
                              "assessmentCriteria": [
                                "Correta colocação de catch(...) como último handler (100% seletividade).",
                                "Logging informativo sem expor detalhes sensíveis (segurança).",
                                "Re-lançamento preserva contexto original (depuração intacta).",
                                "Integração OOP com classes e RAII (boas práticas).",
                                "Cobertura de testes para cenários edge-case (robustez).",
                                "Tempo de execução e cleanup eficientes pós-exceção."
                              ],
                              "crossCurricularConnections": [
                                "Debugging e Logging: Conecta com práticas de monitoramento em DevOps.",
                                "Design de Software: Reforça princípios de robustez e fault-tolerance.",
                                "Análise de Algoritmos: Relaciona com complexidade em handling de erros.",
                                "Segurança da Informação: Evita vazamento de stack traces sensíveis."
                              ],
                              "realWorldApplication": "Em servidores web C++ (ex: Nginx plugins) ou jogos (Unreal Engine), catch(...) captura crashes inesperados, loga para Sentry/New Relic e re-lança para graceful shutdown, evitando perda de dados em produção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.4",
                    "name": "Bloco Finally",
                    "description": "Execução garantida de código após try-catch, independentemente de exceções.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.4.1",
                        "name": "Propósito do Bloco Finally",
                        "description": "O bloco finally garante a execução de código após os blocos try e catch, independentemente de uma exceção ter sido lançada, capturada ou não, sendo ideal para limpeza de recursos como fechamento de arquivos ou conexões.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.1.1",
                            "name": "Identificar o propósito principal do finally",
                            "description": "Reconhecer que o finally executa sempre, mesmo sem exceções ou com exceções não capturadas, diferenciando-o de blocos catch que dependem de exceções específicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a estrutura básica do bloco try-catch-finally",
                                  "subSteps": [
                                    "Estude a sintaxe: try { código } catch (Exception e) { tratamento } finally { sempre executa }",
                                    "Identifique que try contém código potencialmente excepcionável, catch trata exceções específicas e finally executa independentemente",
                                    "Compile um exemplo simples sem exceções usando um IDE Java",
                                    "Execute e observe a ordem de execução: try → finally",
                                    "Anote a definição oficial do finally na documentação Oracle Java"
                                  ],
                                  "verification": "Código compila e executa sem erros, com logs confirmando ordem try-finally",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE Java (Eclipse ou IntelliJ)",
                                    "Documentação Java SE sobre exceções"
                                  ],
                                  "tips": "Sempre inclua System.out.println() para visualizar a execução",
                                  "learningObjective": "Compreender a sintaxe e a garantia de execução do finally",
                                  "commonMistakes": [
                                    "Confundir finally com catch; esquecer que finally é opcional mas sempre roda se presente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar execução sem exceções",
                                  "subSteps": [
                                    "Crie código com try-finally sem catch: try { print('try'); } finally { print('finally'); }",
                                    "Execute e confirme que finally roda após try sem exceções",
                                    "Adicione variáveis ou operações simples no try para simular fluxo normal",
                                    "Compare com código sem finally para notar a diferença em limpeza de recursos",
                                    "Registre o tempo de execução para verificar consistência"
                                  ],
                                  "verification": "Logs mostram 'try' seguido de 'finally' em execução normal",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Compilador Java (javac ou IDE)",
                                    "Terminal para execução"
                                  ],
                                  "tips": "Use throws para simular cenários controlados sem exceções reais",
                                  "learningObjective": "Reconhecer que finally executa mesmo em fluxo sem erros",
                                  "commonMistakes": [
                                    "Achar que finally só roda com exceções; não testar execução normal"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Testar execução com exceções capturadas e não capturadas",
                                  "subSteps": [
                                    "Implemente try-catch-finally com exceção capturada: throw new Exception() no try",
                                    "Execute e observe: try → catch → finally",
                                    "Remova catch e execute: try → exceção → finally (antes de stack trace)",
                                    "Teste com RuntimeException não capturada para ver finally antes do término",
                                    "Use debugger para pausar e inspecionar pilha de chamadas"
                                  ],
                                  "verification": "Em todos os casos, finally executa; confirme com logs e debugger",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE com debugger",
                                    "Código fonte Java de exemplo"
                                  ],
                                  "tips": "Comece com checked exceptions para forçar compilação explícita",
                                  "learningObjective": "Diferenciar cenários onde catch pode ou não rodar, mas finally sempre roda",
                                  "commonMistakes": [
                                    "Ignorar que finally roda mesmo se catch não capturar; não testar uncaught"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar finally de catch e sintetizar propósito principal",
                                  "subSteps": [
                                    "Crie tabela comparativa: Catch (depende de match de exceção) vs Finally (sempre)",
                                    "Refatore código de passos anteriores removendo finally e observe falhas em cleanup",
                                    "Escreva parágrafo explicando: 'Finally garante execução para cleanup independente de exceções'",
                                    "Teste em método com return no try: confirme finally roda antes do return",
                                    "Resuma em quiz pessoal: 3 perguntas sobre cenários de execução"
                                  ],
                                  "verification": "Tabela e explicação escrita corretamente; quiz com 100% acerto",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha ou documento para tabela",
                                    "Quiz online como Quizlet"
                                  ],
                                  "tips": "Pense em finally como 'garantia de cleanup' como fechar arquivos",
                                  "learningObjective": "Identificar propósito principal: execução sempre para ações críticas",
                                  "commonMistakes": [
                                    "Confundir com finally como 'else'; esquecer return/break no try"
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo em Java:\npublic class TestFinally {\n  public static void main(String[] args) {\n    try {\n      System.out.println(\"Try executando\");\n      // throw new RuntimeException(\"Erro!\");\n    } catch (RuntimeException e) {\n      System.out.println(\"Catch: \" + e.getMessage());\n    } finally {\n      System.out.println(\"Finally sempre roda!\");\n    }\n  }\n}\nSaída sem exceção: Try executando → Finally sempre roda!\nCom exceção capturada: Try → Catch → Finally\nSem catch: Try → Finally → Stack trace",
                              "finalVerifications": [
                                "Explicar verbalmente por que finally executa em 4 cenários: sem exceção, com catch, sem catch, com return",
                                "Executar código modificado e prever saída corretamente antes de rodar",
                                "Identificar em código alheio onde finally é essencial para cleanup",
                                "Diferenciar finally de catch em diagrama de fluxo",
                                "Resolver mini-exercício: adicionar finally a código com file I/O"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de execução sempre do finally (100%)",
                                "Correta diferenciação de catch (dependente de exceção específica)",
                                "Uso correto de exemplos práticos com logs/debugger",
                                "Compreensão de cenários edge (return, uncaught, nested)",
                                "Síntese clara do propósito: garantia de ações pós-try independentemente",
                                "Aplicação em refatoração de código legado"
                              ],
                              "crossCurricularConnections": [
                                "Lógica e Fluxo de Controle: Diagramas de decisão semelhantes a if-else",
                                "Gerenciamento de Recursos: Paralelo com boas práticas em BD e arquivos",
                                "Debugging e Testes: Uso de breakpoints para verificação de fluxo",
                                "Engenharia de Software: Princípios de robustez e cleanup idempotente"
                              ],
                              "realWorldApplication": "No desenvolvimento de apps, finally garante fechamento de conexões de banco de dados, streams de arquivo ou locks de thread, evitando vazamentos de memória mesmo se exceções ocorrerem durante operações críticas, como em servidores web ou apps mobile."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.1.2",
                            "name": "Diferenciar finally de outros blocos de tratamento",
                            "description": "Comparar o comportamento do finally com try e catch, entendendo que finally não captura exceções, mas executa código de finalização garantida.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar sintaxe e propósitos básicos de try, catch e finally",
                                  "subSteps": [
                                    "Leia a documentação oficial sobre blocos try-catch-finally em Java.",
                                    "Identifique que try contém código potencialmente excepcionável.",
                                    "Note que catch captura e trata exceções específicas.",
                                    "Entenda que finally executa código de limpeza independentemente do resultado.",
                                    "Anote as diferenças em uma tabela comparativa."
                                  ],
                                  "verification": "Criar uma tabela resumindo propósitos de cada bloco e confirmar com um colega ou autoavaliação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação Java (Oracle Docs), editor de texto ou bloco de notas.",
                                  "tips": "Use diagramas de fluxo para visualizar a estrutura hierárquica.",
                                  "learningObjective": "Compreender os papéis distintos de try, catch e finally na estrutura de tratamento de exceções.",
                                  "commonMistakes": "Confundir finally como capturador de exceções, em vez de bloco de finalização."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar fluxo de execução sem exceções",
                                  "subSteps": [
                                    "Escreva um código simples com try-catch-finally sem lançar exceção.",
                                    "Execute e observe a ordem: try → finally (catch é pulado).",
                                    "Adicione prints em cada bloco para rastrear execução.",
                                    "Modifique o código removendo finally e compare saídas.",
                                    "Registre observações sobre execução garantida do finally."
                                  ],
                                  "verification": "Comparar logs de console com diagrama esperado de fluxo sem exceção.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "IDE como IntelliJ ou Eclipse, JDK instalado.",
                                  "tips": "Use System.out.println() com timestamps para precisão na ordem de execução.",
                                  "learningObjective": "Diferenciar que finally sempre executa, mesmo sem exceções, ao contrário de catch.",
                                  "commonMistakes": "Esquecer que catch não roda sem exceção, confundindo com finally."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar fluxo de execução com exceções",
                                  "subSteps": [
                                    "Modifique o código para lançar uma exceção no try.",
                                    "Execute e observe: try (até exceção) → catch → finally.",
                                    "Teste lançando exceção no catch e veja finally ainda executar.",
                                    "Compare com versão sem finally para notar limpeza perdida.",
                                    "Documente cenários onde finally é crucial (ex: return em try/catch)."
                                  ],
                                  "verification": "Verificar via console que finally executa após catch, mesmo com exceções em catch.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "IDE, JDK, debugger para pausar execução.",
                                  "tips": "Use debugger para step-through e visualizar pilha de chamadas.",
                                  "learningObjective": "Reconhecer que finally não captura exceções, mas garante execução pós-try/catch.",
                                  "commonMistakes": "Acreditar que finally é pulado se catch falha; ele não é."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar diferenciação através de exercícios comparativos",
                                  "subSteps": [
                                    "Crie 3 cenários: sem exceção, com exceção tratada, exceção não tratada.",
                                    "Implemente cada um com e sem finally, analisando diferenças.",
                                    "Responda quiz: 'O que roda se return em try?' (finally ainda roda).",
                                    "Refatore código real para usar finally corretamente.",
                                    "Explique diferenças em pseudocódigo para outro aluno."
                                  ],
                                  "verification": "Resolver 5 perguntas de múltipla escolha sobre fluxos e compartilhar respostas corretas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "IDE, exemplos de código online (GeeksforGeeks), quiz impresso ou digital.",
                                  "tips": "Teste edge cases como System.exit() (finally pode não rodar).",
                                  "learningObjective": "Aplicar conhecimento para distinguir finally de try/catch em diversos cenários.",
                                  "commonMistakes": "Ignorar que finally roda mesmo com return ou continue/break."
                                }
                              ],
                              "practicalExample": "Considere este código Java:\npublic class Test {\n  public static void main(String[] args) {\n    try {\n      System.out.println(\"Try: Iniciando\");\n      throw new RuntimeException(\"Erro!\");\n    } catch (RuntimeException e) {\n      System.out.println(\"Catch: \" + e.getMessage());\n    } finally {\n      System.out.println(\"Finally: Sempre executa\");\n    }\n  }\n}\nSaída: Try: Iniciando → Catch: Erro! → Finally: Sempre executa.\nSem finally, limpeza (ex: fechar arquivo) seria perdida se exceção ocorrer.",
                              "finalVerifications": [
                                "Explicar verbalmente por que finally executa após try bem-sucedido.",
                                "Demonstrar código onde exceção em catch ainda permite finally rodar.",
                                "Identificar que finally não é usado para captura de exceções.",
                                "Comparar fluxos com/ sem finally em diagrama.",
                                "Prever saída de código com return em try (finally roda antes).",
                                "Refatorar snippet sem finally para incluir e justificar."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de fluxos de execução (90% correto).",
                                "Identificação correta de 4+ diferenças chave entre finally e outros blocos.",
                                "Códigos de exemplo compilam e demonstram comportamentos esperados.",
                                "Explicação clara de cenários edge-case (return, System.exit).",
                                "Uso apropriado de finally para limpeza em exemplos práticos.",
                                "Diagrama ou tabela comparativa completa e precisa."
                              ],
                              "crossCurricularConnections": [
                                "Lógica de controle de fluxo em algoritmos (matemática discreta).",
                                "Gerenciamento de recursos em sistemas operacionais (fechamento de handles).",
                                "Debugging e testes unitários em engenharia de software.",
                                "Padrões de design como RAII em C++ (análogos a try-with-resources)."
                              ],
                              "realWorldApplication": "Em aplicações empresariais, finally garante fechamento de conexões de banco de dados, streams de arquivo ou locks de thread, evitando vazamentos de memória mesmo se exceções ocorrerem durante processamento de transações financeiras ou uploads de dados."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.1.3",
                            "name": "Explicar a ordem de execução try-catch-finally",
                            "description": "Descrever a sequência: código try executa, se exceção vai para catch correspondente, finally sempre ao final, mesmo com return ou break.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Sintaxe e Propósito Básico do Try-Catch-Finally",
                                  "subSteps": [
                                    "Analise a sintaxe padrão: try { código suspeito } catch (ExceptionType e) { tratamento } finally { cleanup sempre }",
                                    "Identifique o propósito: try executa código potencialmente excepcionável, catch captura exceções específicas, finally executa incondicionalmente",
                                    "Compare com fluxogramas: visualize try como principal, catch como desvio condicional, finally como retorno final",
                                    "Leia documentação oficial sobre exceções em Java para reforçar conceitos",
                                    "Anote diferenças entre exceções checked e unchecked"
                                  ],
                                  "verification": "Escreva a sintaxe correta de um bloco try-catch-finally simples e explique cada parte em voz alta",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Documentação Java Exceptions (Oracle Docs)",
                                    "Editor de código (IntelliJ ou VSCode)"
                                  ],
                                  "tips": "Use comentários no código para mapear o fluxo esperado de execução",
                                  "learningObjective": "Dominar a estrutura sintática e os papéis fundamentais de cada bloco",
                                  "commonMistakes": "Esquecer que finally é opcional mas recomendado para cleanup; confundir catch com múltiplos tipos de exceções"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Simular Execução Normal (Sem Exceção)",
                                  "subSteps": [
                                    "Escreva um código simples com prints em try, catch e finally (ex: System.out.println('Try executado') )",
                                    "Execute o código sem forçar exceção e observe a saída: try completo -> finally",
                                    "Adicione um return no try e verifique se finally ainda executa antes do retorno",
                                    "Registre a ordem exata de prints na console",
                                    "Teste com break ou continue dentro de loop no try"
                                  ],
                                  "verification": "Confirme que a saída mostra 'try -> finally' e explique por quê catch é pulado",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "JDK instalado",
                                    "Editor de código com console",
                                    "Exemplo base de código Java"
                                  ],
                                  "tips": "Use System.out.println com timestamps ou números sequenciais para rastrear ordem precisamente",
                                  "learningObjective": "Compreender que finally executa sempre após try bem-sucedido, independentemente de returns",
                                  "commonMistakes": "Achar que return no try impede finally; ignorar que catch é skipped sem exceção"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular Execução com Exceção",
                                  "subSteps": [
                                    "Modifique o código para lançar uma exceção no try (ex: throw new RuntimeException())",
                                    "Execute e observe: try parcial -> catch correspondente -> finally",
                                    "Teste com exceção não capturada para ver finally ainda executar",
                                    "Adicione múltiplos catch e force exceções diferentes para ver matching",
                                    "Registre prints confirmando ordem: try (até exceção) -> catch -> finally"
                                  ],
                                  "verification": "Verifique saída console mostrando catch ativado e finally após, sem pular finally",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "JDK instalado",
                                    "Editor de código",
                                    "Código do step anterior"
                                  ],
                                  "tips": "Comece com RuntimeException para simplicidade; use try-catch em IDE para autocomplete",
                                  "learningObjective": "Entender desvio para catch na exceção e execução garantida do finally",
                                  "commonMistakes": "Pensar que finally não roda se exceção não é tratada; matching errado de catch"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Casos Especiais e Praticar Integração",
                                  "subSteps": [
                                    "Teste return em catch: observe try -> exceção -> catch (return) -> finally ainda executa",
                                    "Experimente finally com cleanup simulado (ex: fechar arquivo ou conexão)",
                                    "Crie um fluxograma manual da ordem em todos cenários",
                                    "Refatore código para um cenário real como divisão por zero com cleanup",
                                    "Debugue código com breakpoints em try, catch, finally para visualizar passo a passo"
                                  ],
                                  "verification": "Crie e execute código com return em try/catch e confirme finally sempre último via console/debugger",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Debugger da IDE",
                                    "Exemplos de código com recursos (File ou Socket simulados)"
                                  ],
                                  "tips": "Priorize debugger stepwise para visualizar pilha de execução real",
                                  "learningObjective": "Mestre comportamento invariante do finally em retornos, breaks e exceções",
                                  "commonMistakes": "Acreditar que finally é skipped por return/break; não testar cenários edge"
                                }
                              ],
                              "practicalExample": "Em Java:\npublic class OrdemExecucao {\n  public static int metodo() {\n    try {\n      System.out.println(\"1. Try inicia\");\n      if (true) throw new RuntimeException(\"Erro!\");\n      return 1; // Não alcançado\n    } catch (RuntimeException e) {\n      System.out.println(\"2. Catch: \" + e.getMessage());\n      return 2;\n    } finally {\n      System.out.println(\"3. Finally sempre!\");\n    }\n  }\n  public static void main(String[] args) {\n    System.out.println(metodo()); // Saída: 1.Try, 2.Catch, 3.Finally, 2\n  }\n}\nDemonstra: try -> catch -> finally -> return efetivo.",
                              "finalVerifications": [
                                "Explicar verbalmente ordem sem exceção: try completo -> finally",
                                "Descrever desvio com exceção: try até erro -> catch matching -> finally",
                                "Confirmar via código/debug que return em try/catch não pula finally",
                                "Identificar que finally roda mesmo em System.exit() (exceto casos extremos)",
                                "Aplicar em código próprio: prever saída correta antes de executar",
                                "Diferenciar execução nested try-catch-finally"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da sequência try-catch-finally em todos cenários (100% correto)",
                                "Correta previsão de saídas em códigos com return/break/exceções",
                                "Uso adequado de finally para cleanup em exemplos práticos",
                                "Identificação de erros comuns como skipping finally",
                                "Capacidade de debugar e explicar fluxos via fluxogramas ou prints",
                                "Integração em contextos OOP maiores sem confusões"
                              ],
                              "crossCurricularConnections": [
                                "Lógica e Algoritmos: Fluxo condicional similar a if-else com garantia de finally",
                                "Matemática: Sequências e fluxogramas para modelar ordem de execução",
                                "Desenvolvimento de Software: Debugging e análise de pilha de chamadas",
                                "Gestão de Recursos: Conceitos de cleanup como em administração de sistemas"
                              ],
                              "realWorldApplication": "Em aplicações empresariais Java, use try-catch-finally para garantir fechamento de conexões de banco de dados, streams de arquivos ou locks de threads, evitando vazamentos de recursos mesmo se exceções ocorrerem ou métodos retornarem prematuramente, essencial para escalabilidade e estabilidade em servidores web."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.2",
                        "name": "Sintaxe e Implementação do Bloco Finally",
                        "description": "Estrutura sintática do bloco try-catch-finally em linguagens OO como Python e C++, permitindo adicionar finally após catch para execução obrigatória.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.2.1",
                            "name": "Escrever sintaxe básica try-catch-finally",
                            "description": "Construir estrutura try: código arriscado; except/catch: tratamento; finally: limpeza, exemplificando em Python com 'try: ... except: ... finally: ...'.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes do bloco try-except-finally",
                                  "subSteps": [
                                    "Leia a documentação oficial do Python sobre exceções em docs.python.org/3/tutorial/errors.html.",
                                    "Identifique o papel de cada bloco: try executa código arriscado, except captura e trata exceções, finally executa sempre para limpeza.",
                                    "Analise um diagrama de fluxo mostrando execução: try -> sucesso ou except -> finally.",
                                    "Anote exemplos de exceções comuns como ZeroDivisionError, FileNotFoundError e ValueError.",
                                    "Discuta com um colega ou anote por que finally é útil para recursos como arquivos ou conexões."
                                  ],
                                  "verification": "Crie um fluxograma simples no papel ou ferramenta como Draw.io confirmando a sequência de execução.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Python online",
                                    "Papel e caneta ou Draw.io",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Lembre-se: finally executa mesmo se houver return no try ou except.",
                                  "learningObjective": "Entender a estrutura e fluxo de execução do bloco try-except-finally.",
                                  "commonMistakes": [
                                    "Confundir except com finally",
                                    "Achar que finally só roda em erro",
                                    "Ignorar exceções específicas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever o bloco try com código potencialmente arriscado",
                                  "subSteps": [
                                    "Abra um editor de código como VS Code ou IDLE.",
                                    "Escreva a estrutura básica: try: seguido de código que pode gerar exceção, como 10 / 0.",
                                    "Adicione print para visualizar execução, ex: print('Código try executado').",
                                    "Salve o arquivo como try_basic.py e execute para observar o erro.",
                                    "Registre o tipo de exceção gerada no terminal."
                                  ],
                                  "verification": "Execute o código e confirme que uma exceção é levantada sem tratamento.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, PyCharm)",
                                    "Python 3 instalado",
                                    "Terminal ou console"
                                  ],
                                  "tips": "Use código simples para isolar o problema; evite exceções compostas inicialmente.",
                                  "learningObjective": "Implementar corretamente o bloco try com código suscetível a falhas.",
                                  "commonMistakes": [
                                    "Esquecer os dois pontos após try:",
                                    "Indentação inconsistente",
                                    "Código try que nunca falha"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o bloco except para tratamento de exceções",
                                  "subSteps": [
                                    "Adicione 'except ZeroDivisionError:' abaixo do try, com print('Erro de divisão por zero!').",
                                    "Teste executando o código: confirme que except captura e imprime mensagem.",
                                    "Experimente uma exceção diferente (ex: int('abc')) e adicione except ValueError.",
                                    "Use 'except Exception as e:' para captura genérica e imprima str(e).",
                                    "Remova except e reexecute para comparar comportamentos."
                                  ],
                                  "verification": "Execute cenários de erro e sucesso; except deve tratar sem crash.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Python instalado"
                                  ],
                                  "tips": "Sempre especifique o tipo de exceção para precisão; evite except: genérico.",
                                  "learningObjective": "Capturar e tratar exceções específicas no bloco except.",
                                  "commonMistakes": [
                                    "except sem tipo de exceção",
                                    "Não indentar bloco except",
                                    "Tratar exceções erradas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar o bloco finally para limpeza e testar a estrutura completa",
                                  "subSteps": [
                                    "Adicione 'finally:' após except, com print('Limpeza sempre executada.').",
                                    "Teste três cenários: 1) Erro no try (div/0), 2) Sucesso (10/2), 3) return no try.",
                                    "Inclua cleanup real: abra um arquivo no try, feche no finally.",
                                    "Execute e verifique logs: finally sempre roda.",
                                    "Refatore para múltiplas exceções com finally compartilhado."
                                  ],
                                  "verification": "Logs mostram finally executando em todos os cenários, sem vazamentos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Arquivo de teste.txt para simular recurso"
                                  ],
                                  "tips": "Finally é ideal para close(), disconnect() ou del variáveis.",
                                  "learningObjective": "Garantir execução incondicional de código de limpeza no finally.",
                                  "commonMistakes": [
                                    "Colocar finally antes de except",
                                    "Esquecer indentação no finally",
                                    "Achar que finally pula em return"
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo completo em Python:\n```python\ntry:\n    resultado = 10 / 0\n    print('Resultado:', resultado)\nexcept ZeroDivisionError:\n    print('Não é possível dividir por zero!')\nfinally:\n    print('Recursos liberados e limpeza concluída.')\n```\nSaída esperada: 'Não é possível dividir por zero!' seguido de 'Recursos liberados...'.",
                              "finalVerifications": [
                                "Código executa sem erros de sintaxe ou indentação.",
                                "Bloco try roda código arriscado corretamente.",
                                "Except captura exceção específica e trata sem crash.",
                                "Finally executa em cenários de sucesso, erro e return.",
                                "Não há vazamento de recursos simulados (ex: arquivo fechado).",
                                "Múltiplas exceções são tratadas adequadamente."
                              ],
                              "assessmentCriteria": [
                                "Estrutura sintática exata: try:, except TipoError:, finally: com indentação 4 espaços.",
                                "Uso de exceções específicas em vez de genéricas.",
                                "Código de exemplo demonstra fluxo completo (sucesso/erro/cleanup).",
                                "Verificações de execução em pelo menos 3 cenários.",
                                "Comentários explicando cada bloco.",
                                "Ausência de erros comuns como falta de dois pontos ou indentação errada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Tratamento de erros em cálculos numéricos (divisão, overflow).",
                                "Lógica e Algoritmos: Fluxogramas de controle de exceções.",
                                "Desenvolvimento de Software: Boas práticas em programação defensiva.",
                                "Análise de Dados: Tratamento de exceções em scripts de processamento de dados.",
                                "Segurança da Informação: Prevenção de crashes exploráveis."
                              ],
                              "realWorldApplication": "Em aplicações web (Flask/Django), use try-except-finally para lidar com erros de banco de dados: try para query, except para logar erro, finally para commit/rollback. Em scripts de automação, abra arquivos no try, trate FileNotFoundError no except, feche sempre no finally para evitar vazamentos de handles."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.2.2",
                            "name": "Implementar finally sem bloco catch",
                            "description": "Criar estrutura try-finally diretamente, sem catch, para cenários onde exceções propagam mas limpeza é necessária.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Propósito do Try-Finally sem Catch",
                                  "subSteps": [
                                    "Estude a documentação oficial do Java sobre blocos try-finally, focando em cenários onde exceções devem propagar sem tratamento local.",
                                    "Identifique casos de uso: limpeza de recursos (ex.: fechar streams, conexões) independentemente de exceções ocorrerem.",
                                    "Compare com try-catch-finally: note que sem catch, exceções não são capturadas e propagam para chamadores superiores.",
                                    "Analise um diagrama de fluxo: try executa, exceções pulam para finally, depois propagam.",
                                    "Registre em anotações: quando usar (limpeza garantida) vs. evitar (se tratamento local necessário)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que exceções propagam e como finally garante execução pós-try.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Java SE (Oracle Docs: try-finally)",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Pense em 'finally sempre roda, catch é opcional para tratamento'.",
                                  "learningObjective": "Entender o fluxo de execução e cenários ideais para try-finally sem catch.",
                                  "commonMistakes": [
                                    "Confundir com try-catch obrigatório",
                                    "Achar que finally só roda sem exceções"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar a Sintaxe Correta",
                                  "subSteps": [
                                    "Escreva a estrutura básica: 'try { } finally { }' em um editor.",
                                    "Valide sintaxe no IDE (ex.: IntelliJ ou Eclipse) para erros de compilação.",
                                    "Adicione código try simples (ex.: divisão por zero) e cleanup no finally (ex.: imprimir 'Cleanup').",
                                    "Compile o código via terminal: 'javac Exemplo.java'.",
                                    "Identifique erros comuns: chaves faltando, finally sem try."
                                  ],
                                  "verification": "Código compila sem erros e exibe mensagem de cleanup ao executar.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "IDE Java (Eclipse/IntelliJ)",
                                    "JDK instalado",
                                    "Terminal/Command Prompt"
                                  ],
                                  "tips": "Use Auto-complete do IDE para evitar erros de sintaxe.",
                                  "learningObjective": "Reproduzir a sintaxe exata sem erros de compilação.",
                                  "commonMistakes": [
                                    "Esquecer chaves de bloco",
                                    "Colocar catch acidentalmente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Exemplo Prático com Recurso Gerenciável",
                                  "subSteps": [
                                    "Crie classe com método usando FileInputStream: abra arquivo no try.",
                                    "No finally, feche o stream com if (stream != null) stream.close().",
                                    "Adicione código que lance exceção (ex.: arquivo inexistente).",
                                    "Execute e observe: exceção propaga, mas finally executa cleanup.",
                                    "Refatore para usar try-with-resources se aplicável, mas foque em finally manual."
                                  ],
                                  "verification": "Execute código: confirma cleanup no console apesar da exceção propagada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "JDK",
                                    "IDE",
                                    "Arquivo de teste (ex.: test.txt)"
                                  ],
                                  "tips": "Sempre cheque null antes de close() para evitar NullPointerException.",
                                  "learningObjective": "Aplicar try-finally em gerenciamento de recursos reais.",
                                  "commonMistakes": [
                                    "Não checar null no finally",
                                    "Não propagar exceção corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Depurar Comportamentos Edge-Case",
                                  "subSteps": [
                                    "Teste sem exceção: verifique finally roda.",
                                    "Teste com exceção no try: confirme cleanup e propagação.",
                                    "Teste exceção no finally: note que é adicionada à stack original.",
                                    "Use debugger: breakpoints em try e finally para inspecionar fluxo.",
                                    "Registre logs com System.out para rastrear execução."
                                  ],
                                  "verification": "Todos testes passam: cleanup sempre ocorre, exceções propagam corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE com debugger",
                                    "JUnit para testes unitários opcionais"
                                  ],
                                  "tips": "Exceções no finally são 'suprimidas' e encadeadas na original.",
                                  "learningObjective": "Validar robustez em cenários variados.",
                                  "commonMistakes": [
                                    "Ignorar exceções no finally",
                                    "Achar que finally previne propagação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app de processamento de arquivos: try { FileInputStream fis = new FileInputStream('dados.txt'); // processar } finally { if (fis != null) fis.close(); } // Exceção por arquivo ausente propaga, mas stream fecha sempre.",
                              "finalVerifications": [
                                "Código compila e executa sem erros de sintaxe.",
                                "Finally executa em casos com e sem exceção.",
                                "Exceções propagam para chamador sem supressão.",
                                "Cleanup de recursos ocorre consistentemente.",
                                "Debugger confirma fluxo: try -> finally -> propagate.",
                                "Logs mostram ordem correta de execução."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe precisa sem catch (100% compilável).",
                                "Uso correto em cleanup de recursos (null-check presente).",
                                "Compreensão de propagação de exceções demonstrada.",
                                "Testes cobrem edge-cases (exceção em try/finally).",
                                "Explicação clara do porquê sem catch.",
                                "Código limpo e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica de fluxogramas e fluxos incondicionais (finally como 'sempre').",
                                "Física/Engenharia: Gerenciamento de recursos finitos (ex.: energia, memória como entropia).",
                                "Gestão de Projetos: Planejamento de 'limpeza' em falhas (lessons learned).",
                                "Segurança da Informação: Garantia de fechamento de conexões para evitar vazamentos."
                              ],
                              "realWorldApplication": "Em servidores web Java (ex.: Spring Boot), use try-finally para fechar conexões JDBC manualmente em transações críticas onde exceções devem alertar admins, garantindo liberação de pools de conexão e evitando vazamentos de memória em produção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.2.3",
                            "name": "Aninhar blocos try-catch-finally",
                            "description": "Combinar múltiplos níveis de try-catch-finally, entendendo a execução sequencial dos finallies internos e externos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar sintaxe básica de try-catch-finally e introduzir aninhamento simples",
                                  "subSteps": [
                                    "Estude a sintaxe básica: try { } catch (Exception e) { } finally { }",
                                    "Escreva um try-catch-finally simples sem aninhamento para uma operação como divisão por zero",
                                    "Aninhe um try-catch-finally interno dentro do bloco try externo",
                                    "Compile e execute o código sem exceções para observar a ordem de execução",
                                    "Adicione um print em cada bloco para rastrear a execução"
                                  ],
                                  "verification": "O código compila sem erros e imprime a sequência correta: try externo, try interno, finally interno, finally externo",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (IDE como IntelliJ ou VS Code)",
                                    "Compilador Java",
                                    "Documentação oficial Java sobre exceções"
                                  ],
                                  "tips": "Use System.out.println() em pontos chave para visualizar o fluxo de execução",
                                  "learningObjective": "Compreender a estrutura sintática de blocos aninhados e sua execução sequencial sem exceções",
                                  "commonMistakes": [
                                    "Esquecer chaves de abertura/fechamento",
                                    "Colocar finally dentro de catch incorretamente",
                                    "Não indentar corretamente para visualização"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar aninhamento com exceção no nível interno",
                                  "subSteps": [
                                    "No try interno, adicione código que lance uma exceção (ex: divisão por zero)",
                                    "Configure um catch interno para capturar ArithmeticException",
                                    "Mantenha finally interno com cleanup (ex: fechar recurso simulado)",
                                    "Execute e observe: catch interno executa, finally interno e externo executam",
                                    "Modifique para que o catch interno relance a exceção (throw e)"
                                  ],
                                  "verification": "Ao executar, o catch interno captura, finallies executam em ordem interna > externa, e se relançada, catch externo captura",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE com debugger",
                                    "Exemplos de código Java com exceções"
                                  ],
                                  "tips": "Use debugger para pausar em breakpoints nos finallies e confirmar ordem",
                                  "learningObjective": "Dominar o comportamento de exceções propagadas de blocos internos",
                                  "commonMistakes": [
                                    "Não relançar exceção no catch interno quando necessário",
                                    "Confundir ordem de finallies",
                                    "Ignorar propagação para externo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar exceções no nível externo e testar múltiplas exceções",
                                  "subSteps": [
                                    "No try externo, adicione código que possa lançar NullPointerException após o interno",
                                    "Configure catch externo para múltiplos tipos (ArithmeticException e NullPointerException)",
                                    "Teste cenários: exceção só interna, só externa, ambas",
                                    "Observe sempre que finallies executam independentemente da exceção",
                                    "Adicione logs para registrar a pilha de exceções"
                                  ],
                                  "verification": "Em todos os testes, finallies internos e externos executam na ordem correta, mesmo com exceções em múltiplos níveis",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Debugger Java",
                                    "Ferramenta de logging como SLF4J"
                                  ],
                                  "tips": "Teste isolando exceções com variáveis de controle para simular falhas seletivas",
                                  "learningObjective": "Entender propagação de exceções através de níveis aninhados e execução garantida de finallies",
                                  "commonMistakes": [
                                    "Achar que finally externo não executa se interno falha",
                                    "Catch externo capturando exceções erradas",
                                    "Não testar cenários combinados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar aninhamento complexo e otimizar para cenários reais",
                                  "subSteps": [
                                    "Crie aninhamento de 3 níveis com exceções em níveis diferentes",
                                    "Implemente cleanup hierárquico nos finallies (ex: fechar streams internos/externos)",
                                    "Refatore para usar try-with-resources onde possível, mas mantenha finally manual",
                                    "Teste com exceções customizadas e verifique stack trace",
                                    "Documente o fluxo de execução em um diagrama"
                                  ],
                                  "verification": "Código lida corretamente com exceções em qualquer nível, todos finallies executam em ordem LIFO (último interno primeiro), sem vazamentos de recursos",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "IDE com suporte a diagramas (ex: PlantUML)",
                                    "Exemplos de exceções customizadas"
                                  ],
                                  "tips": "Desenhe o fluxo antes de codificar para visualizar ordem de finallies",
                                  "learningObjective": "Aplicar aninhamento em cenários multi-camadas com gerenciamento robusto de recursos",
                                  "commonMistakes": [
                                    "Ordem errada de cleanup em finallies",
                                    "Exceções customizadas não estendendo Exception",
                                    "Sobre-aninhar desnecessariamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de banco de dados: try externo para conexão BD { try interno para leitura de arquivo config { } catch (IOException e) { log e; } finally { fechar arquivo; } } catch (SQLException e) { rollback; } finally { desconectar BD; }. Se arquivo falha, finally arquivo e BD executam; se BD falha após, ainda cleanup.",
                              "finalVerifications": [
                                "Explicar verbalmente ou por escrito a ordem exata de execução de finallies aninhados",
                                "Executar código com exceções em 3 cenários diferentes e prever saídas corretamente",
                                "Identificar e corrigir bug em código aninhado fornecido (ex: finally não executando)",
                                "Implementar cleanup correto em exemplo com 2 níveis de recursos",
                                "Comparar stack trace de exceções propagadas vs capturadas localmente",
                                "Criar diagrama de fluxo para aninhamento de 3 níveis"
                              ],
                              "assessmentCriteria": [
                                "Correção na ordem de execução de todos os blocos (100% precisão em testes)",
                                "Gerenciamento completo de recursos sem vazamentos em finallies",
                                "Captura apropriada de exceções específicas vs genéricas",
                                "Código legível com indentação e comentários explicativos",
                                "Robustez: lida com exceções inesperadas sem crash",
                                "Eficiência: evita aninhamento excessivo quando possível"
                              ],
                              "crossCurricularConnections": [
                                "Depuração e Debugging: Uso de breakpoints para rastrear fluxos aninhados",
                                "Design de Software: Princípios de robustez e fail-safe em camadas",
                                "Lógica e Algoritmos: Entender fluxos condicionais e garantidos (finally)",
                                "Gestão de Recursos: Conceitos de alocação/liberação em sistemas operacionais",
                                "Testes de Software: Criação de unit tests para cenários de exceções aninhadas"
                              ],
                              "realWorldApplication": "Em aplicações empresariais como e-commerce: aninhar try para transação BD (externo) com leitura de arquivo de estoque (interno), garantindo que finallies fechem conexões e arquivos mesmo em falhas parciais, evitando vazamentos de memória ou locks persistentes."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.3",
                        "name": "Comportamentos Especiais e Melhores Práticas",
                        "description": "Analisar casos como finally com return, exceções em finally e uso para gerenciamento de recursos, seguindo boas práticas em programação OO.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.3.1",
                            "name": "Compreender finally com instruções return",
                            "description": "Explicar que finally executa mesmo antes de return em try ou catch, podendo alterar o valor retornado se houver atribuição.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a ordem de execução básica de try-catch-finally",
                                  "subSteps": [
                                    "Escreva um código simples com try-catch-finally sem returns.",
                                    "Execute o código e observe a saída no console.",
                                    "Adicione prints em try, catch e finally para rastrear a execução.",
                                    "Anote a sequência exata de execução.",
                                    "Compare com documentação oficial do Java sobre blocos try-catch-finally."
                                  ],
                                  "verification": "Presença de prints na ordem correta: try -> catch (se exceção) -> finally.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "IDE (Eclipse/IntelliJ), JDK instalado, console para output.",
                                  "tips": "Use System.out.println() com timestamps para precisão na ordem.",
                                  "learningObjective": "Identificar que finally sempre executa após try/catch, independentemente de exceções.",
                                  "commonMistakes": "Achar que finally só executa se não há exceção; ignorar que finally roda mesmo em return."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar comportamento de return no try sem finally",
                                  "subSteps": [
                                    "Crie um método com return no try que retorne um valor fixo (ex: 42).",
                                    "Execute e confirme o valor retornado.",
                                    "Adicione uma exceção no try e mova return para catch.",
                                    "Teste cenários: sem exceção e com exceção.",
                                    "Registre os valores retornados em cada caso."
                                  ],
                                  "verification": "Método retorna 42 sem exceção e valor do catch com exceção.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Mesma IDE e JDK do step anterior.",
                                  "tips": "Use um método main para chamar e imprimir o resultado.",
                                  "learningObjective": "Entender que return sai imediatamente do método quando executado.",
                                  "commonMistakes": "Esquecer de testar com e sem exceção; confundir return com break."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Observar execução de finally antes do return no try/catch",
                                  "subSteps": [
                                    "Adicione finally ao código do step 2 com um print.",
                                    "Execute sem exceção: observe print no finally antes do return.",
                                    "Execute com exceção: verifique print no finally após catch, antes do return.",
                                    "Use debugger para pausar e inspecionar pilha de chamadas.",
                                    "Documente o fluxo: try -> finally -> return efetivo."
                                  ],
                                  "verification": "Print do finally aparece antes do valor retornado ser efetivado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "IDE com debugger ativado.",
                                  "tips": "No debugger, defina breakpoints em return e finally para ver ordem.",
                                  "learningObjective": "Reconhecer que bytecode JVM coloca código de finally antes do return.",
                                  "commonMistakes": "Acreditar que return impede finally; não usar debugger para prova visual."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar atribuição e return no finally alterando o resultado",
                                  "subSteps": [
                                    "No try, prepare uma variável e return ela (ex: return x = 1).",
                                    "No finally, altere a variável (x = 2) e teste sem return no finally.",
                                    "Adicione return no finally (return 99) e execute.",
                                    "Compare outputs: sem alteração, com atribuição, com return no finally.",
                                    "Refatore para boas práticas, evitando returns no finally."
                                  ],
                                  "verification": "Com atribuição no finally: retorna 2; com return no finally: retorna 99.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "IDE, debugger.",
                                  "tips": "Evite returns no finally em código real; use para cleanup apenas.",
                                  "learningObjective": "Compreender como finally pode modificar ou sobrescrever valores de return.",
                                  "commonMistakes": "Atribuir no try achando que finally não afeta; usar return no finally sem necessidade."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar conhecimento em cenários complexos e debugar",
                                  "subSteps": [
                                    "Crie código com return em try e catch, finally com atribuição condicional.",
                                    "Introduza exceções aninhadas e teste fluxos.",
                                    "Use ferramentas como JUnit para testes automatizados de outputs.",
                                    "Debugue um código buggy onde finally altera return inesperadamente.",
                                    "Escreva um resumo das regras de finally com return."
                                  ],
                                  "verification": "Testes JUnit passam prevendo outputs corretos em todos fluxos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "JUnit ou framework de testes, IDE.",
                                  "tips": "Sempre priorize legibilidade: evite lógica complexa no finally.",
                                  "learningObjective": "Dominar interações finally-return para evitar bugs sutis.",
                                  "commonMistakes": "Ignorar propagação de exceções após finally; lógica condicional mal colocada."
                                }
                              ],
                              "practicalExample": "Considere este código Java:\npublic class TestFinally {\n  public static int metodo() {\n    try {\n      System.out.println(\"Try: \" + 1);\n      return 1;  // Return preparado\n    } catch (Exception e) {\n      return 2;\n    } finally {\n      System.out.println(\"Finally executa antes!\");\n      // Se adicionar: return 99; sobrescreve tudo.\n    }\n  }\n  public static void main(String[] args) {\n    System.out.println(metodo());  // Output: Try: 1, Finally..., 1\n  }\n}\nOutput sem return no finally: Try: 1\\nFinally executa antes!\\n1",
                              "finalVerifications": [
                                "Explicar verbalmente ou por escrito a ordem exata de execução com return no try.",
                                "Prever corretamente o output de um código com atribuição no finally.",
                                "Identificar e corrigir um bug onde return no finally causa comportamento inesperado.",
                                "Debugar passo a passo um método try-catch-finally com prints.",
                                "Escrever um teste JUnit que falha se finally não executar antes do return.",
                                "Diferenciar comportamento com e sem finally em cenários de return."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da ordem: finally antes do return efetivo (100%).",
                                "Capacidade de prever outputs em 5 exemplos variados (90% acerto).",
                                "Uso correto de debugger para demonstrar fluxo (visual).",
                                "Identificação de riscos de finally alterando returns (explicação clara).",
                                "Proposta de melhores práticas: evitar return/atribuições desnecessárias no finally.",
                                "Criação de código teste que valida o conceito (funcional e limpo)."
                              ],
                              "crossCurricularConnections": [
                                "Lógica de programação: Controle de fluxo e precedência de instruções.",
                                "Depuração e testes: Uso de breakpoints e unit tests para validação.",
                                "Engenharia de software: Boas práticas em gerenciamento de recursos (RAII-like).",
                                "Análise de bytecode: Entender JVM internals para performance.",
                                "Pensamento computacional: Decomposição de fluxos complexos em passos atômicos."
                              ],
                              "realWorldApplication": "Em aplicações empresariais, como métodos de acesso a BD: try { query; return result; } finally { connection.close(); } garante fechamento mesmo com early return por validação ou erro, evitando vazamentos de recursos e melhorando escalabilidade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.3.2",
                            "name": "Tratar exceções lançadas no finally",
                            "description": "Identificar que exceções no finally interrompem o fluxo e propagam, anulando tratamentos anteriores se não capturadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o fluxo padrão de execução do try-catch-finally",
                                  "subSteps": [
                                    "Estude a documentação oficial do Java sobre blocos try-catch-finally.",
                                    "Analise diagramas de fluxo de execução: try sempre executa, catch se exceção ocorrer, finally sempre.",
                                    "Escreva e execute um código simples sem exceções para observar a ordem de execução.",
                                    "Teste com exceção no try capturada no catch, verificando que finally executa após.",
                                    "Registre saídas no console para mapear a sequência exata."
                                  ],
                                  "verification": "Execute o código e confirme no console que finally sempre roda, independentemente de exceções capturadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "JDK 8 ou superior",
                                    "IDE como IntelliJ ou Eclipse",
                                    "Console para logs"
                                  ],
                                  "tips": "Use System.out.println em cada bloco para visualizar o fluxo.",
                                  "learningObjective": "Dominar a sequência de execução padrão sem exceções no finally.",
                                  "commonMistakes": [
                                    "Acreditar que finally só executa se não houver exceções",
                                    "Ignorar que finally roda mesmo após return no try ou catch"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o impacto de exceções lançadas no bloco finally",
                                  "subSteps": [
                                    "Escreva código com exceção no try não capturada e outra no finally.",
                                    "Execute e observe que a exceção do finally é propagada, suprimindo a anterior.",
                                    "Use getSuppressed() para verificar exceções suprimidas na JVM moderna.",
                                    "Teste cenários: exceção no try capturada, mas lançada no finally (propaga nova).",
                                    "Analise stack traces para confirmar qual exceção é reportada."
                                  ],
                                  "verification": "Stack trace mostra apenas a exceção do finally; use loop em getSuppressed() para ver a original.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "JDK 7+ para getSuppressed()",
                                    "IDE com debugger",
                                    "Documentação Oracle sobre exceções suprimidas"
                                  ],
                                  "tips": "Ative verbose exceptions com -XX:+PrintSuppressions para mais detalhes.",
                                  "learningObjective": "Reconhecer que exceções no finally anulam tratamentos anteriores se não gerenciadas.",
                                  "commonMistakes": [
                                    "Subestimar propagação, achando que catch anterior previne",
                                    "Não checar suppressed exceptions"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar tratamento correto de exceções lançadas no finally",
                                  "subSteps": [
                                    "Crie um try-catch-finally com catch adicional para exceções do finally.",
                                    "Use Throwable.addSuppressed() manualmente para preservar exceções originais.",
                                    "Refatore código para evitar lançamentos desnecessários no finally (ex: checks condicionais).",
                                    "Teste com múltiplas exceções e valide propagação correta.",
                                    "Integre com try-with-resources para minimizar riscos no finally."
                                  ],
                                  "verification": "Execute cenários falhos; confirme que ambas exceções são reportadas via suppressed ou logs.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de código Java",
                                    "Debugger da IDE",
                                    "JUnit para testes automatizados"
                                  ],
                                  "tips": "Prefira try-with-resources para cleanup automático sem finally manual.",
                                  "learningObjective": "Aplicar técnicas para capturar e preservar exceções múltiplas.",
                                  "commonMistakes": [
                                    "Lançar RuntimeException genérica no finally sem contexto",
                                    "Esquecer de re-lançar exceções tratadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adotar melhores práticas e validar em cenários reais",
                                  "subSteps": [
                                    "Revise padrões como 'exceções guardadas' com variáveis locais.",
                                    "Implemente logging detalhado para exceções suprimidas.",
                                    "Crie testes unitários cobrindo exceções no finally.",
                                    "Analise código legado para refatorar finallys problemáticos.",
                                    "Discuta em fóruns ou documente lições aprendidas."
                                  ],
                                  "verification": "Testes JUnit passam em 100% dos cenários; código refatorado não suprime exceções.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "JUnit 5",
                                    "Framework de logging como SLF4J",
                                    "Repositório Git para versionamento"
                                  ],
                                  "tips": "Sempre pergunte: 'Essa operação no finally pode falhar?' e proteja.",
                                  "learningObjective": "Incorporar práticas robustas para tratamento de exceções em finally.",
                                  "commonMistakes": [
                                    "Overuse de finally para lógica complexa",
                                    "Ignorar exceções em cleanup de recursos"
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo em Java:\n```java\ntry {\n    throw new IOException(\"Erro de arquivo\");\n} catch (IOException e) {\n    System.out.println(\"Capturada: \" + e);\n} finally {\n    throw new RuntimeException(\"Erro no finally\");  // Esta propaga, suprimindo a anterior\n}\n```\nSaída: RuntimeException propagada. Use e.addSuppressed(original) no finally para preservar.",
                              "finalVerifications": [
                                "Escreva e execute código demonstrando supressão de exceção.",
                                "Refatore para preservar ambas exceções usando addSuppressed().",
                                "Crie teste JUnit que falha se finally suprimir exceção original.",
                                "Explique em 3 frases por que exceções no finally anulam catches anteriores.",
                                "Analise stack trace de um exemplo com suppressed exceptions.",
                                "Implemente try-with-resources como alternativa segura."
                              ],
                              "assessmentCriteria": [
                                "Correção técnica: Código compila e comporta-se como esperado (30%).",
                                "Compreensão conceitual: Explicações claras sobre fluxo e supressão (25%).",
                                "Prática robusta: Uso de addSuppressed() ou try-with-resources (20%).",
                                "Testes e verificação: Cobertura de cenários falhos (15%).",
                                "Clareza e documentação: Comentários e logs adequados (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Debugging e análise de stack traces em desenvolvimento de software.",
                                "Gerenciamento de recursos e padrões RAII em linguagens como C++.",
                                "Lógica de controle de fluxo em algoritmos e estruturas de dados.",
                                "Testes unitários e TDD em engenharia de software.",
                                "Segurança e resiliência em sistemas distribuídos."
                              ],
                              "realWorldApplication": "Em aplicações empresariais, como serviços web que abrem conexões de banco no try e fecham no finally: uma falha no close() (ex: rede) não deve mascarar a exceção original de query, permitindo diagnósticos precisos e evitando perda de dados críticos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.3.3",
                            "name": "Aplicar finally para limpeza de recursos",
                            "description": "Implementar finally para fechar arquivos, desconectar bancos de dados ou liberar locks, evitando vazamentos de memória em aplicações OO.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de finally e sua importância para limpeza de recursos",
                                  "subSteps": [
                                    "Estude a sintaxe básica de try-catch-finally em Java.",
                                    "Analise cenários onde recursos como arquivos ou conexões precisam ser liberados independentemente de exceções.",
                                    "Identifique problemas comuns como vazamentos de memória causados pela ausência de finally.",
                                    "Compare try-finally com try-with-resources (mencione como complemento)."
                                  ],
                                  "verification": "Resuma em 3 frases o que é finally e por que usá-lo; teste com pseudocódigo simples.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Documentação Java (Oracle Docs), IDE com Java (IntelliJ ou Eclipse), JDK 8+",
                                  "tips": "Lembre-se: finally executa SEMPRE, exceto em System.exit() ou JVM crash.",
                                  "learningObjective": "Entender o ciclo de vida de recursos em OO e o papel do finally na garantia de liberação.",
                                  "commonMistakes": "Confundir finally com catch (finally não captura exceções, apenas limpa)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar finally para fechamento de arquivos",
                                  "subSteps": [
                                    "Crie um método que abra um FileInputStream em try.",
                                    "Adicione código de leitura no try e trate IOException no catch.",
                                    "Insira no finally o chamada para inputStream.close().",
                                    "Teste com arquivo existente e inexistente para validar execução do finally."
                                  ],
                                  "verification": "Execute o código com exceção simulada; verifique via logs se close() foi chamado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "IDE, arquivo de teste (ex: teste.txt), JDK",
                                  "tips": "Use try-with-resources se disponível, mas foque em finally para compatibilidade legacy.",
                                  "learningObjective": "Implementar estrutura try-catch-finally para gerenciar streams de arquivo de forma segura.",
                                  "commonMistakes": "Chamar close() sem null-check (use if (stream != null) stream.close())."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar finally para desconexão de banco de dados e liberação de locks",
                                  "subSteps": [
                                    "Configure uma conexão JDBC simples com DriverManager.",
                                    "Execute uma query no try, trate SQLException no catch.",
                                    "No finally, chame connection.close() e libere locks se aplicável.",
                                    "Simule falhas (query inválida) e verifique liberação via logs ou profiler."
                                  ],
                                  "verification": "Monitore conexões ativas no banco (ex: SHOW PROCESSLIST no MySQL); confirme zero vazamentos após múltiplas execuções.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "IDE, banco de dados local (H2 ou MySQL), driver JDBC, propriedades de conexão",
                                  "tips": "Sempre feche Statement e ResultSet ANTES da Connection no finally.",
                                  "learningObjective": "Estender o uso de finally para recursos de rede/persistência como DB connections.",
                                  "commonMistakes": "Esquecer de fechar recursos aninhados (ResultSet > Statement > Connection)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Refatorar código existente e realizar testes abrangentes",
                                  "subSteps": [
                                    "Pegue um código sem finally (ex: leitor de arquivo sem cleanup).",
                                    "Refatore adicionando try-catch-finally em todos os pontos de recurso.",
                                    "Adicione testes unitários com JUnit para cenários normais e excepcionais.",
                                    "Use profiler (VisualVM) para validar ausência de vazamentos de memória."
                                  ],
                                  "verification": "Tests passam 100%; profiler mostra zero handles abertos após execução.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "JUnit 5, VisualVM ou YourKit profiler, código legado de exemplo",
                                  "tips": "Priorize RAII-like pattern com finally para escalabilidade em apps multi-thread.",
                                  "learningObjective": "Aplicar refatoração com finally em código real, garantindo robustez.",
                                  "commonMistakes": "Não testar cenários de exceção no finally (ex: close() lançando exceção secundária)."
                                }
                              ],
                              "practicalExample": "Exemplo em Java:\npublic void lerArquivoESalvarDB(String arquivoPath) {\n  FileInputStream fis = null;\n  Connection conn = null;\n  try {\n    fis = new FileInputStream(arquivoPath);\n    // Ler arquivo...\n    conn = DriverManager.getConnection(url);\n    // Executar query...\n  } catch (IOException | SQLException e) {\n    // Log erro\n  } finally {\n    if (fis != null) try { fis.close(); } catch (IOException ignored) {}\n    if (conn != null) try { conn.close(); } catch (SQLException ignored) {}\n  }\n}",
                              "finalVerifications": [
                                "Finally executa em todos os fluxos: sucesso, exceção, retorno early.",
                                "Recursos (arquivos, conexões) são fechados sem vazamentos detectados.",
                                "Código compila sem warnings de recursos não gerenciados.",
                                "Testes unitários cobrem 100% dos cenários de exceção.",
                                "Profiler confirma zero alocações persistentes de recursos."
                              ],
                              "assessmentCriteria": [
                                "Estrutura try-catch-finally corretamente implementada em todos os recursos.",
                                "Null-checks e tratamento de exceções secundárias no finally.",
                                "Código legível com comentários explicando cleanup.",
                                "Testes demonstram liberação independente de exceções.",
                                "Eficiência: tempo de execução sem overhead desnecessário.",
                                "Compatibilidade com boas práticas (ex: ordem de fechamento correta)."
                              ],
                              "crossCurricularConnections": [
                                "Gerenciamento de memória em Sistemas Operacionais (alocação/liberação).",
                                "Engenharia de Software: padrões de design para resource management.",
                                "Segurança da Informação: prevenção de DoS por vazamentos de recursos.",
                                "Desenvolvimento de Banco de Dados: boas práticas JDBC."
                              ],
                              "realWorldApplication": "Em aplicações web (Spring Boot) para gerenciar pools de conexões DB sem vazamentos, evitando downtime em produção; em microsserviços para liberar locks distribuídos (Redis) e prevenir deadlocks."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.3.4",
                            "name": "Adotar melhores práticas com finally",
                            "description": "Evitar lógica complexa no finally, preferir context managers em Python (with) quando possível, e documentar usos para manutenção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o propósito e limitações do bloco finally",
                                  "subSteps": [
                                    "Leia a documentação oficial do Python sobre try-except-finally (PEP 0342).",
                                    "Analise exemplos onde finally garante execução incondicional, como fechar arquivos.",
                                    "Identifique cenários onde lógica complexa no finally causa problemas, como exceções aninhadas.",
                                    "Compare finally com outras estruturas de controle de fluxo.",
                                    "Anote 3 limitações principais do finally em um documento pessoal."
                                  ],
                                  "verification": "Resuma em 3-5 pontos as limitações do finally e forneça um exemplo de código problemático.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação Python oficial",
                                    "Editor de código como VS Code",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Foquem em casos reais de uso, como gerenciamento de recursos.",
                                  "learningObjective": "Entender quando e por que evitar complexidade no finally.",
                                  "commonMistakes": "Confundir finally com cleanup condicional; ignorar exceções geradas no finally."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar context managers como alternativa preferida",
                                  "subSteps": [
                                    "Estude a sintaxe do 'with' statement e como ele usa __enter__ e __exit__.",
                                    "Implemente um context manager simples usando contextlib para abrir arquivos.",
                                    "Compare código com finally vs. with em termos de legibilidade e robustez.",
                                    "Teste cenários de exceção com ambos os approaches.",
                                    "Liste 5 bibliotecas Python que usam context managers (ex: open(), requests)."
                                  ],
                                  "verification": "Escreva e execute um script comparando try-finally e with para leitura de arquivo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python REPL ou Jupyter Notebook",
                                    "Documentação contextlib",
                                    "Exemplos de código online"
                                  ],
                                  "tips": "Sempre prefira 'with' para recursos que precisam de setup/teardown.",
                                  "learningObjective": "Dominar context managers para substituir finally desnecessário.",
                                  "commonMistakes": "Esquecer de definir __exit__ corretamente; usar with em loops desnecessariamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar finally simples com documentação adequada",
                                  "subSteps": [
                                    "Crie um código com try-except-finally onde finally só faz cleanup simples (ex: print ou log).",
                                    "Adicione docstrings explicando o uso do finally.",
                                    "Teste o código com exceções normais e no finally.",
                                    "Use type hints e comentários inline para clareza.",
                                    "Valide com pylint ou black para padrões de código."
                                  ],
                                  "verification": "O código roda sem erros e docstring explica o finally claramente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de código com linter",
                                    "Ferramentas como pylint/black"
                                  ],
                                  "tips": "Mantenha finally com 1-2 linhas no máximo.",
                                  "learningObjective": "Aplicar finally de forma limpa e documentada.",
                                  "commonMistakes": "Colocar lógica condicional ou loops no finally; falta de documentação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Refatorar código existente para melhores práticas",
                                  "subSteps": [
                                    "Encontre ou crie um código com finally complexo (ex: múltiplas operações).",
                                    "Refatore para usar context manager onde possível.",
                                    "Para casos restantes, simplifique finally e adicione docs.",
                                    "Compare métricas: linhas de código, legibilidade (Cyclomatic Complexity).",
                                    "Teste refatoração com unit tests."
                                  ],
                                  "verification": "Código refatorado passa em testes e pylint sem warnings.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código de exemplo com finally ruim",
                                    "pytest para testes",
                                    "radon para complexidade"
                                  ],
                                  "tips": "Use @contextmanager para refatorações rápidas.",
                                  "learningObjective": "Refatorar código legado seguindo melhores práticas.",
                                  "commonMistakes": "Não testar exceções após refatoração; ignorar performance."
                                }
                              ],
                              "practicalExample": "Código ruim: try: f = open('file.txt'); ... finally: f.close(); if error: log(); Código bom: with open('file.txt') as f: ... (docstring: 'Usa context manager para auto-close, finally só para log simples se necessário').",
                              "finalVerifications": [
                                "Nenhum finally contém mais de 2 linhas de lógica.",
                                "Context managers são usados para todos os recursos gerenciáveis.",
                                "Todo finally tem docstring explicando seu uso.",
                                "Código passa em linters sem warnings sobre exceções.",
                                "Testes cobrem cenários com/ sem exceções.",
                                "Complexidade ciclomática reduzida em 20% pós-refatoração."
                              ],
                              "assessmentCriteria": [
                                "Uso correto e preferencial de context managers (80% dos casos).",
                                "Finally limitado a cleanup incondicional simples.",
                                "Documentação completa em todos os blocos finally.",
                                "Código testado e robusto contra exceções aninhadas.",
                                "Melhoria mensurável em legibilidade e manutenibilidade.",
                                "Ausência de erros comuns identificados."
                              ],
                              "crossCurricularConnections": [
                                "Design de Software: Princípios SOLID (Single Responsibility).",
                                "Manutenção de Código: Refatoração e legibilidade.",
                                "Testes de Software: Cobertura de exceções.",
                                "Engenharia de Software: Gerenciamento de recursos e RAII."
                              ],
                              "realWorldApplication": "Em aplicações web (Flask/Django), usar context managers para conexões de banco de dados garante fechamento mesmo em falhas, evitando vazamentos de memória em produção; documentação facilita onboarding de novos devs."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.5",
                    "name": "Lançamento de Exceções",
                    "description": "Uso de throw/raise para lançar exceções manualmente em métodos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.5.1",
                        "name": "Lançamento de Exceções Pré-definidas",
                        "description": "Compreender o propósito e a sintaxe para lançar manualmente exceções já disponíveis na linguagem de programação, como ValueError em Python ou std::invalid_argument em C++, dentro de métodos de classes orientadas a objetos, para sinalizar condições de erro específicas.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.1.1",
                            "name": "Aplicar sintaxe raise em Python",
                            "description": "Utilizar a instrução 'raise NomeDaExcecao(mensagem)' em um método de classe Python para lançar exceções pré-definidas, como ValueError ou TypeError, quando condições inválidas são detectadas, por exemplo, em validações de parâmetros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender exceções pré-definidas em Python",
                                  "subSteps": [
                                    "Pesquise a documentação oficial do Python sobre exceções built-in como ValueError e TypeError.",
                                    "Leia exemplos de quando cada exceção é usada: ValueError para valores inválidos, TypeError para tipos incorretos.",
                                    "Anote 3 cenários comuns onde essas exceções são apropriadas em validações.",
                                    "Compare com exceções personalizadas para entender a diferença.",
                                    "Execute exemplos simples no interpretador Python para ver mensagens de erro."
                                  ],
                                  "verification": "Liste corretamente pelo menos 3 exceções pré-definidas com seus usos e forneça um exemplo de código que as gera naturalmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Python: https://docs.python.org/3/library/exceptions.html",
                                    "Interpretador Python (REPL)"
                                  ],
                                  "tips": "Use o REPL para testar rapidamente sem escrever arquivos completos.",
                                  "learningObjective": "Identificar e descrever exceções pré-definidas adequadas para validações de parâmetros.",
                                  "commonMistakes": [
                                    "Confundir ValueError com TypeError",
                                    "Ignorar que exceções built-in já têm mensagens padrão úteis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar a sintaxe básica do raise",
                                  "subSteps": [
                                    "Escreva um script simples fora de classe: raise ValueError('Mensagem de erro').",
                                    "Teste variações: raise ValueError(), raise TypeError('Tipo inválido').",
                                    "Analise o traceback gerado no console para entender a estrutura.",
                                    "Adicione raise dentro de uma função simples com if condição inválida.",
                                    "Experimente raise sem mensagem para comparar saídas."
                                  ],
                                  "verification": "Código simples levanta exceção com mensagem customizada e traceback correto é exibido.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Python 3.x instalado"
                                  ],
                                  "tips": "Sempre inclua uma mensagem descritiva para facilitar depuração.",
                                  "learningObjective": "Aplicar sintaxe raise corretamente em contextos isolados.",
                                  "commonMistakes": [
                                    "Esquecer parênteses em raise NomeExcecao()",
                                    "Usar aspas simples/duplas inconsistentes na mensagem"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar raise em métodos de classe para validação",
                                  "subSteps": [
                                    "Crie uma classe simples, ex: Calculadora, com método que recebe parâmetros.",
                                    "Adicione validação no método: if not isinstance(param, int): raise TypeError('Parâmetro deve ser inteiro').",
                                    "Inclua ValueError para valores fora de range, ex: if valor < 0: raise ValueError('Valor não pode ser negativo').",
                                    "Instancie a classe e chame o método com inputs válidos e inválidos.",
                                    "Refatore para múltiplas validações sequenciais."
                                  ],
                                  "verification": "Método de classe lança exceções específicas para condições inválidas sem prosseguir execução.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Jupyter Notebook para testes interativos"
                                  ],
                                  "tips": "Valide parâmetros no início do método para falhar rápido (fail-fast).",
                                  "learningObjective": "Implementar raise em métodos de classe para validações robustas de parâmetros.",
                                  "commonMistakes": [
                                    "Não usar self corretamente",
                                    "Prosseguir execução após raise (impossível, mas confundir com return)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e depurar o uso de raise",
                                  "subSteps": [
                                    "Escreva testes unitários com unittest ou pytest para cenários inválidos.",
                                    "Verifique se exceções são levantadas com mensagens corretas usando assertRaises.",
                                    "Simule inputs do usuário e capture exceções para mensagens amigáveis.",
                                    "Analise coverage de testes para garantir todas validações cobertas.",
                                    "Otimize mensagens de erro baseadas em testes falhos."
                                  ],
                                  "verification": "Testes passam: exceções corretas são levantadas em casos inválidos e método funciona em válidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Biblioteca pytest ou unittest",
                                    "Ferramenta de coverage como coverage.py"
                                  ],
                                  "tips": "Use pytest.raises(ValueError, match='mensagem esperada') para validação precisa.",
                                  "learningObjective": "Validar funcionalidade de raise através de testes automatizados.",
                                  "commonMistakes": [
                                    "Não testar casos edge como None ou strings vazias",
                                    "Ignorar match na mensagem de exceção"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma classe ContaBancaria:\ndef depositar(self, valor):\n    if not isinstance(valor, (int, float)):\n        raise TypeError('Valor deve ser numérico')\n    if valor <= 0:\n        raise ValueError('Valor deve ser positivo')\n    self.saldo += valor\nTeste: conta.depositar(-10) levanta ValueError('Valor deve ser positivo').",
                              "finalVerifications": [
                                "Código lança exceções pré-definidas corretas com mensagens customizadas.",
                                "Validações ocorrem no início do método sem side-effects indesejados.",
                                "Testes unitários cobrem 100% dos cenários de exceção.",
                                "Traceback aponta corretamente para a linha do raise.",
                                "Integração com try-except não quebra o fluxo.",
                                "Mensagens são claras e úteis para depuração."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe raise NomeExcecao('mensagem') é precisa e sem erros.",
                                "Exceções escolhidas (ValueError/TypeError) são apropriadas ao contexto.",
                                "Validações cobrem tipos e valores inválidos adequadamente.",
                                "Código é limpo, com raise no local correto (início do método).",
                                "Testes demonstram lançamento correto de exceções.",
                                "Mensagens de erro são descritivas e em português/inglês consistente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Validação de domínios numéricos e tipos em cálculos.",
                                "Lógica: Condicionais if para detecção de pré-condições inválidas.",
                                "Desenvolvimento de Software: Boas práticas de error handling em OOP.",
                                "Segurança da Informação: Prevenção de injeções via validação rigorosa."
                              ],
                              "realWorldApplication": "Em sistemas bancários, validar depósitos negativos levanta ValueError para prevenir fraudes; em APIs web, TypeError em parâmetros JSON incorretos garante robustez e logs úteis para monitoramento."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.1.2",
                            "name": "Aplicar sintaxe throw em C++",
                            "description": "Implementar 'throw std::runtime_error(\"mensagem\")' ou outras exceções padrão como std::invalid_argument dentro de métodos de classes C++, garantindo que o lançamento ocorra em cenários de erro, como divisão por zero ou entrada inválida.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e revisar conceitos de exceções em C++",
                                  "subSteps": [
                                    "Inclua os headers necessários: <stdexcept> para exceções padrão e <iostream> para testes.",
                                    "Revise a sintaxe básica: throw std::runtime_error(\"mensagem\"); e throw std::invalid_argument(\"mensagem\");.",
                                    "Compile um programa simples com throw fora de função para entender erro de compilação (não permitido).",
                                    "Estude documentação oficial do C++ para std::runtime_error e std::invalid_argument.",
                                    "Crie um arquivo main.cpp vazio para testes."
                                  ],
                                  "verification": "Compilação bem-sucedida de um snippet simples com throw dentro de main() e saída de mensagem de erro ao executar.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Compilador C++ (g++), editor de código (VS Code ou CLion), documentação cppreference.com para stdexcept.",
                                  "tips": "Sempre use namespace std; para simplificar, mas evite em produção.",
                                  "learningObjective": "Compreender os headers e sintaxe básica de throw com exceções padrão.",
                                  "commonMistakes": "Esquecer #include <stdexcept>; usar throw sem std::; lançar throw fora de contexto válido."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e definir cenários de erro em uma classe C++",
                                  "subSteps": [
                                    "Crie uma classe simples, como Calculadora, com método público double dividir(double numerador, double denominador).",
                                    "Defina condições de erro: denominador == 0 para runtime_error; argumentos NaN ou inf para invalid_argument.",
                                    "Adicione construtor padrão e outros métodos auxiliares se necessário.",
                                    "Declare o método como void ou double, mas planeje retorno após throw.",
                                    "Compile a classe sem throw para verificar estrutura."
                                  ],
                                  "verification": "Classe compila sem erros e instanciação bem-sucedida em main().",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Mesmo compilador e editor; referência OOP C++.",
                                  "tips": "Use private members para estado interno da classe.",
                                  "learningObjective": "Definir contextos de erro realistas em métodos de classe.",
                                  "commonMistakes": "Método sem parâmetros ou classe sem métodos públicos; esquecer ponto-e-vírgula em declarações."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar sintaxe throw dentro do método da classe",
                                  "subSteps": [
                                    "No método dividir, adicione if (denominador == 0.0) { throw std::runtime_error(\"Divisão por zero!\"); }.",
                                    "Adicione outro if (std::isnan(numerador) || std::isinf(denominador)) { throw std::invalid_argument(\"Argumentos inválidos!\"); } (inclua <cmath>).",
                                    "Retorne numerador / denominador após as verificações.",
                                    "Instancie a classe em main() e chame o método com valores válidos e inválidos.",
                                    "Compile e execute para observar lançamento."
                                  ],
                                  "verification": "Programa compila e lança exceção correta com input inválido (ver what() na captura ou terminate).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Compilador, <cmath> header adicionado.",
                                  "tips": "Use mensagens descritivas para facilitar debug.",
                                  "learningObjective": "Aplicar throw com exceções padrão em cenários específicos de erro em classes.",
                                  "commonMistakes": "Throw sem std::; esquecer return após ifs; não incluir headers corretos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, capturar e refinar o lançamento de exceções",
                                  "subSteps": [
                                    "Adicione try-catch em main(): try { calc.dividir(10,0); } catch (const std::exception& e) { std::cout << e.what(); }.",
                                    "Teste múltiplos cenários: divisão por zero, args inválidos, valores válidos.",
                                    "Refatore para mais exceções se aplicável (ex: std::out_of_range para vetores).",
                                    "Meça performance com throw (não deve ser usado em loops apertados).",
                                    "Documente o código com comentários sobre quando/por quê lançar."
                                  ],
                                  "verification": "Exceções são lançadas e capturadas corretamente, com mensagens exibidas; casos válidos funcionam.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Compilador com flags -Wall -Wextra para warnings.",
                                  "tips": "Catch por referência const para eficiência.",
                                  "learningObjective": "Integrar throw com try-catch para tratamento robusto.",
                                  "commonMistakes": "Catch errado (não std::exception&); throw em caminhos não-erro; vazamento de recursos."
                                }
                              ],
                              "practicalExample": "Classe Calculadora:\nclass Calculadora {\npublic:\n    double dividir(double a, double b) {\n        if (b == 0.0) throw std::runtime_error(\"Divisão por zero!\");\n        if (std::isnan(a) || std::isinf(b)) throw std::invalid_argument(\"Args inválidos!\");\n        return a / b;\n    }\n};\nint main() {\n    Calculadora c;\n    try { std::cout << c.dividir(10, 0); } catch (const std::exception& e) { std::cout << e.what(); }\n    return 0;\n}",
                              "finalVerifications": [
                                "Código compila sem warnings com g++ -std=c++17 -Wall.",
                                "Execução com input inválido lança exceção correta sem crash.",
                                "Mensagens de erro são claras e específicas.",
                                "Casos válidos retornam resultado correto.",
                                "Try-catch captura e exibe e.what() adequadamente.",
                                "Nenhum vazamento de memória detectado com valgrind."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe throw usa std::runtime_error ou std::invalid_argument corretamente.",
                                "Throw ocorre apenas em cenários de erro definidos (ex: /0, input inválido).",
                                "Integração em método de classe OOP.",
                                "Headers incluídos corretamente (<stdexcept>, <cmath>).",
                                "Testes cobrem lançamento e captura.",
                                "Código limpo, comentado e eficiente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de divisão, NaN e infinito.",
                                "Design de Software: Princípios de programação defensiva e robustez.",
                                "Lógica e Algoritmos: Condicionais if para validação de entrada.",
                                "Inglês Técnico: Mensagens de erro em inglês padrão."
                              ],
                              "realWorldApplication": "Em aplicações bancárias, lançar runtime_error em divisão por zero em cálculos financeiros previne crashes e logs erros; em editores de imagem, invalid_argument para dimensões inválidas garante estabilidade do software."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.1.3",
                            "name": "Identificar cenários para lançamento manual",
                            "description": "Determinar momentos apropriados para lançar exceções pré-definidas em métodos OO, como validação de argumentos em construtores ou setters, promovendo o encapsulamento e a robustez do código.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender exceções pré-definidas comuns em OO",
                                  "subSteps": [
                                    "Estude a documentação oficial da linguagem (ex: Java API) para exceções como IllegalArgumentException, NullPointerException, IllegalStateException e IndexOutOfBoundsException.",
                                    "Liste 5 exceções pré-definidas e seus cenários típicos de uso.",
                                    "Compare exceções checked vs unchecked e identifique quais são adequadas para lançamento manual.",
                                    "Crie um glossário pessoal com definições e mensagens de erro padrão.",
                                    "Revise exemplos de código da documentação oficial."
                                  ],
                                  "verification": "Crie uma tabela resumindo 5 exceções com cenários e verifique se cobre construtores/setters.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação da linguagem (JavaDoc/Python docs), editor de texto.",
                                  "tips": "Foquem em exceções RuntimeException para validações, pois são unchecked e não exigem try-catch obrigatório.",
                                  "learningObjective": "Identificar e descrever exceções pré-definidas adequadas para lançamento manual em contextos OO.",
                                  "commonMistakes": "Confundir exceções checked com unchecked; usar exceções genéricas como Exception em vez de específicas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar violações em construtores e setters",
                                  "subSteps": [
                                    "Analise um construtor de exemplo: valide argumentos como null, negativos ou fora de range.",
                                    "Simule cenários inválidos: passe null para um campo obrigatório e decida qual exceção lançar.",
                                    "Examine setters: verifique se o valor viola invariantes da classe (ex: idade < 0).",
                                    "Escreva pseudocódigo para 3 construtores e 2 setters com pontos de lançamento.",
                                    "Teste mentalmente: o que acontece se não lançar exceção?"
                                  ],
                                  "verification": "Anote 4 cenários de construtor/setter inválidos com a exceção apropriada e justifique.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "IDE com exemplos de classes simples, papel para diagramas.",
                                  "tips": "Sempre pergunte: 'Isso viola o contrato da classe?' Se sim, lance exceção antes de prosseguir.",
                                  "learningObjective": "Reconhecer cenários de validação em construtores e setters que demandam lançamento manual.",
                                  "commonMistakes": "Permitir estados inválidos da classe em vez de falhar rápido; ignorar null checks."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar cenários em métodos de instância e utilitários",
                                  "subSteps": [
                                    "Revise métodos que assumem pré-condições: ex: método add() em lista que rejeita duplicatas.",
                                    "Identifique pontos de entrada de dados externos: parâmetros, campos mutáveis.",
                                    "Crie fluxogramas para 2 métodos mostrando onde validar e lançar exceções.",
                                    "Diferencie lançamento manual de exceções automáticas (ex: ArrayList.get(-1)).",
                                    "Pratique refatorando código sem exceções para adicionar lançamentos apropriados."
                                  ],
                                  "verification": "Refatore um método de exemplo adicionando 2 lançamentos e execute testes unitários.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Código-fonte de bibliotecas padrão, ferramenta de fluxograma online.",
                                  "tips": "Use 'fail-fast' principle: valide no início do método para evitar processamento desnecessário.",
                                  "learningObjective": "Detectar pré-condições violadas em métodos OO que requerem exceções manuais.",
                                  "commonMistakes": "Lançar exceções em cenários de uso normal; sobrecarregar com validações desnecessárias."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar princípios de encapsulamento e robustez",
                                  "subSteps": [
                                    "Estude como exceções promovem encapsulamento: classe não expõe estado inválido.",
                                    "Avalie trade-offs: performance vs robustez em cenários críticos.",
                                    "Crie uma checklist para decidir lançamento: viola invariante? Dados inválidos? Estado inconsistente?",
                                    "Revise código peer: identifique 3 oportunidades de lançamento em código alheio.",
                                    "Documente mensagens de exceção claras e informativas."
                                  ],
                                  "verification": "Aplique checklist em um código completo e liste melhorias propostas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Exemplos de código open-source (GitHub), checklist template.",
                                  "tips": "Mensagens de exceção devem guiar o debug: inclua valores inválidos, ex: 'Idade não pode ser negativa: -5'.",
                                  "learningObjective": "Integrar identificação de cenários com boas práticas de design OO.",
                                  "commonMistakes": "Expor detalhes internos na mensagem; lançar exceções em bibliotecas públicas sem documentação."
                                }
                              ],
                              "practicalExample": "Em uma classe ContaBancaria, no construtor: if (saldoInicial < 0) throw new IllegalArgumentException('Saldo inicial não pode ser negativo: ' + saldoInicial); No setter setLimite(): if (novoLimite > 10000) throw new IllegalStateException('Limite excede máximo permitido.'); Isso garante encapsulamento e previne contas inválidas.",
                              "finalVerifications": [
                                "Liste corretamente 5 exceções pré-definidas com cenários OO.",
                                "Identifique lançamentos necessários em 80% dos cenários de construtores/setters fornecidos.",
                                "Justifique decisões de lançamento usando termos como 'invariante' e 'pré-condição'.",
                                "Refatore código simples adicionando exceções sem quebrar funcionalidade válida.",
                                "Crie mensagens de exceção claras e debug-friendly.",
                                "Explique como lançamentos melhoram robustez em um diagrama."
                              ],
                              "assessmentCriteria": [
                                "Precisão na seleção de exceções pré-definidas (90% acerto).",
                                "Cobertura completa de cenários em construtores, setters e métodos (mínimo 4 identificados).",
                                "Justificativas alinhadas a encapsulamento e fail-fast.",
                                "Ausência de lançamentos inadequados em fluxos normais.",
                                "Qualidade das mensagens e verificações (claras e acionáveis).",
                                "Integração com princípios OO em exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Design de Software: Princípios SOLID (especialmente Interface Segregation e Dependency Inversion).",
                                "Testes de Software: Testes unitários para cobrir cenários de exceção.",
                                "Segurança da Informação: Prevenção de injeções e validações de entrada.",
                                "Matemática Discreta: Lógica de pré-condições e invariantes.",
                                "Ética em Computação: Robustez para usuários finais."
                              ],
                              "realWorldApplication": "Em sistemas bancários ou e-commerce, lançar IllegalArgumentException em validações de pagamento previne transações inválidas, garante conformidade regulatória (ex: PCI-DSS) e melhora depuração em produção, evitando crashes silenciosos ou dados corrompidos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.5.2",
                        "name": "Criação e Lançamento de Exceções Personalizadas",
                        "description": "Definir classes de exceção personalizadas por herança de Exception (Python) ou std::exception (C++), instanciá-las e lançá-las com raise/throw em métodos de objetos, permitindo tratamento de erros específicos do domínio da aplicação.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.2.1",
                            "name": "Definir classe de exceção customizada em Python",
                            "description": "Criar uma classe derivada de Exception ou ValueError, com construtor personalizado para mensagens de erro, exemplificando herança em programação orientada a objetos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a hierarquia de exceções em Python",
                                  "subSteps": [
                                    "Acessar a documentação oficial de exceções do Python.",
                                    "Estudar a classe base Exception e suas subclasses como ValueError e TypeError.",
                                    "Visualizar a árvore de herança de exceções usando diagramas ou código.",
                                    "Identificar quando usar Exception como base para customizações.",
                                    "Anotar diferenças entre exceções built-in e customizadas."
                                  ],
                                  "verification": "Escrever um resumo de 5 linhas explicando por que herdar de Exception é apropriado para exceções personalizadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Python: https://docs.python.org/pt-br/3/tutorial/errors.html",
                                    "Editor de texto ou IDE como VS Code",
                                    "Navegador web"
                                  ],
                                  "tips": "Use o comando `python -m pydoc exceptions` no terminal para explorar localmente.",
                                  "learningObjective": "Entender a estrutura hierárquica das exceções para escolher a base correta.",
                                  "commonMistakes": [
                                    "Herdar diretamente de BaseException em vez de Exception.",
                                    "Confundir exceções de runtime com syntax errors.",
                                    "Ignorar que ValueError é para valores inválidos específicos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a classe de exceção customizada básica",
                                  "subSteps": [
                                    "Criar um novo arquivo Python (ex: custom_exception.py).",
                                    "Definir a classe: class MinhaExcecao(Exception):",
                                    "Adicionar o corpo básico com 'pass'.",
                                    "Salvar e executar o arquivo para verificar sintaxe.",
                                    "Instanciar a classe manualmente: excecao = MinhaExcecao()."
                                  ],
                                  "verification": "Executar o código e confirmar que a classe é instanciada sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python 3.x instalado",
                                    "Editor de código (PyCharm ou VS Code)",
                                    "Terminal para execução"
                                  ],
                                  "tips": "Nomeie a classe com sufixo 'Error' para seguir convenções PEP 8.",
                                  "learningObjective": "Criar uma subclasse básica de Exception demonstrando herança.",
                                  "commonMistakes": [
                                    "Esquecer os dois pontos após o nome da classe.",
                                    "Não indentar corretamente o corpo da classe.",
                                    "Usar 'class' em minúscula."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o construtor personalizado",
                                  "subSteps": [
                                    "Adicionar o método __init__ na classe: def __init__(self, mensagem='Erro padrão'):",
                                    "Chamar o construtor da superclasse: super().__init__(mensagem)",
                                    "Opcionalmente, adicionar atributos extras como código de erro: self.codigo = codigo",
                                    "Testar instanciação: excecao = MinhaExcecao('Mensagem customizada')",
                                    "Imprimir str(excecao) para verificar a mensagem."
                                  ],
                                  "verification": "Instanciar com mensagem personalizada e printar para confirmar exibição correta.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmo arquivo custom_exception.py",
                                    "Console Python interativo (python -i)"
                                  ],
                                  "tips": "Sempre chame super().__init__() para preservar comportamento padrão.",
                                  "learningObjective": "Personalizar o inicializador para suportar mensagens e atributos customizados.",
                                  "commonMistakes": [
                                    "Esquecer super().__init__() levando a mensagens vazias.",
                                    "Não tratar mensagem como parâmetro opcional.",
                                    "Usar self.message em vez de super().__init__()."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e lançar a exceção customizada",
                                  "subSteps": [
                                    "Criar uma função que valide input e levante a exceção: raise MinhaExcecao('Input inválido')",
                                    "Envolver em bloco try-except: try: ... except MinhaExcecao as e: print(e)",
                                    "Executar o código com cenários válidos e inválidos.",
                                    "Adicionar logging ou tratamento avançado opcional.",
                                    "Refatorar para múltiplas mensagens de erro."
                                  ],
                                  "verification": "Rodar testes e confirmar que a exceção é lançada, capturada e mensagem exibida corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Arquivo de teste (test_exception.py)",
                                    "Unittest ou pytest para automação opcional"
                                  ],
                                  "tips": "Use assert para testes unitários simples no final.",
                                  "learningObjective": "Integrar e validar a exceção em um fluxo de código real.",
                                  "commonMistakes": [
                                    "Lançar exceção sem raise.",
                                    "Capturar Exception em vez da customizada, mascarando erros.",
                                    "Não testar com try-except."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe InvalidAgeError(Exception) para um sistema de cadastro de usuários. No construtor, passe a idade inválida: def __init__(self, idade): super().__init__(f'Idade {idade} inválida (deve ser entre 0 e 120)'); self.idade = idade. Em uma função register_user(idade): if not 0 <= idade <= 120: raise InvalidAgeError(idade). Teste com idade=-5 e capture para imprimir mensagem amigável.",
                              "finalVerifications": [
                                "A classe herda corretamente de Exception ou ValueError.",
                                "O construtor aceita e armazena mensagem personalizada.",
                                "Instanciação imprime mensagem correta via str() ou print().",
                                "Exceção é lançada com raise e capturada especificamente em except.",
                                "Código completo executa sem erros de sintaxe ou herança.",
                                "Atributos customizados (se adicionados) são acessíveis."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe Python válida e herança funcional.",
                                "Construtor personalizado com super().__init__() usado corretamente.",
                                "Mensagens de erro claras e informativas.",
                                "Testes demonstram lançamento e captura efetivos.",
                                "Código segue PEP 8 (nomes, indentação).",
                                "Exemplo prático integrado e funcional."
                              ],
                              "crossCurricularConnections": [
                                "Lógica e condicionais (Matemática: estruturas de decisão).",
                                "Escrita técnica e documentação (Língua Portuguesa: redação clara de mensagens).",
                                "Design de sistemas (Artes: modelagem orientada a objetos).",
                                "Resolução de problemas (Física: modelagem de erros em simulações)."
                              ],
                              "realWorldApplication": "Em validações de formulários web (ex: Django/Flask para erros de input), bibliotecas científicas (NumPy para dados inválidos), jogos (Unity com Python para cheats inválidos) e APIs REST (erros 4xx customizados com payloads detalhados), garantindo tratamento robusto e mensagens user-friendly."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.2.2",
                            "name": "Lançar exceção customizada em método",
                            "description": "Instanciar e lançar uma exceção personalizada usando 'raise MinhaExcecao(\"detalhes\")' dentro de um método de classe Python ou 'throw MinhaExcecao(\"detalhes\")' em C++, como em verificações de negócio em métodos de instância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a classe de exceção customizada",
                                  "subSteps": [
                                    "Escolha a linguagem: em Python, herde de Exception; em C++, herde de std::exception.",
                                    "Defina o construtor para aceitar uma mensagem de erro personalizada.",
                                    "Adicione atributos opcionais como código de erro ou detalhes adicionais.",
                                    "Implemente o método __str__() em Python ou what() em C++ para retornar a mensagem.",
                                    "Teste a criação da classe isoladamente."
                                  ],
                                  "verification": "Instancie a exceção e imprima sua mensagem para confirmar que exibe corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código (VS Code, PyCharm), interpretador Python 3+ ou compilador C++ (g++)",
                                  "tips": "Mantenha a classe simples no início; evite herança profunda para exceções customizadas.",
                                  "learningObjective": "Compreender como criar exceções personalizadas que herdam das bases nativas.",
                                  "commonMistakes": [
                                    "Esquecer de chamar o construtor da superclasse.",
                                    "Não definir a mensagem de erro no construtor."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o método de classe com lógica de verificação de negócio",
                                  "subSteps": [
                                    "Crie uma classe de exemplo, como ContaBancaria, com um método como depositar(valor).",
                                    "Adicione condições de negócio, ex: if valor <= 0: condição para exceção.",
                                    "Defina claramente os critérios de falha da validação.",
                                    "Estruture o método para retornar um valor de sucesso se passar na validação.",
                                    "Documente o método com docstring ou comentários explicando quando exceções são lançadas."
                                  ],
                                  "verification": "Execute o método com entrada válida e confirme que não lança exceção e retorna sucesso.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesmo editor e ambiente de execução; exemplos de código de classes OOP.",
                                  "tips": "Use asserts iniciais para testar condições inválidas durante desenvolvimento.",
                                  "learningObjective": "Integrar verificações de negócio em métodos de instância de forma defensiva.",
                                  "commonMistakes": [
                                    "Colocar toda lógica em um if-else gigante.",
                                    "Ignorar casos edge como valores zero ou nulos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Instanciar e lançar a exceção customizada no método",
                                  "subSteps": [
                                    "Dentro da condição de falha, instancie a exceção: MinhaExcecao('Valor inválido: {:.2f}'.format(valor)).",
                                    "Em Python: use raise minha_excecao; em C++: throw MinhaExcecao(msg).",
                                    "Personalize a mensagem com detalhes contextuais do erro.",
                                    "Garanta que o lançamento interrompa a execução do método imediatamente.",
                                    "Adicione logging opcional antes do raise/throw para depuração."
                                  ],
                                  "verification": "Chame o método com entrada inválida e capture a exceção para verificar tipo e mensagem.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Terminal para execução; bibliotecas std::exception em C++ ou built-in Exception em Python.",
                                  "tips": "Use f-strings em Python 3.6+ para mensagens dinâmicas mais legíveis.",
                                  "learningObjective": "Dominar a sintaxe precisa de raise/throw com instâncias customizadas.",
                                  "commonMistakes": [
                                    "Lançar string em vez de objeto exceção.",
                                    "Esquecer parênteses no raise/throw."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar o lançamento da exceção em cenários reais",
                                  "subSteps": [
                                    "Escreva testes unitários: um para sucesso, um para falha lançando exceção específica.",
                                    "Use try-except em Python ou try-catch em C++ para capturar e assertar a exceção.",
                                    "Teste múltiplos cenários: valores negativos, zero, não-numéricos.",
                                    "Meça cobertura de código para garantir que o caminho de exceção é executado.",
                                    "Refatore se necessário para melhorar legibilidade."
                                  ],
                                  "verification": "Todos os testes passam: exceção correta lançada com mensagem esperada em casos inválidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Framework de testes (unittest/pytest para Python, GoogleTest para C++).",
                                  "tips": "Sempre teste exceções em isolamento para evitar dependências externas.",
                                  "learningObjective": "Garantir robustez através de testes automatizados de exceções.",
                                  "commonMistakes": [
                                    "Não testar o tipo exato da exceção.",
                                    "Ignorar mensagens de erro nos asserts."
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python:\nclass InvalidAmountError(Exception):\n    def __init__(self, amount):\n        super().__init__(f'Valor inválido: {amount}')\n\nclass ContaBancaria:\n    def depositar(self, valor):\n        if valor <= 0:\n            raise InvalidAmountError(valor)\n        self.saldo += valor\n\n# Teste: conta = ContaBancaria(); conta.depositar(-10)  # Lança InvalidAmountError\n\nEm C++:\nclass InvalidAmountError : public std::exception {\npublic:\n    InvalidAmountError(double amount) : msg(\"Valor inválido: \" + std::to_string(amount)) {}\n    const char* what() const noexcept override { return msg.c_str(); }\nprivate:\n    std::string msg;\n};\n\nclass ContaBancaria {\npublic:\n    void depositar(double valor) {\n        if (valor <= 0) throw InvalidAmountError(valor);\n        saldo += valor;\n    }\nprivate:\n    double saldo = 0;\n};",
                              "finalVerifications": [
                                "A exceção customizada é instanciada com mensagem personalizada correta.",
                                "O método lança a exceção exatamente nas condições de negócio inválidas.",
                                "Testes unitários cobrem caminhos de sucesso e falha com 100% de assertions passando.",
                                "A mensagem da exceção inclui detalhes contextuais relevantes.",
                                "Não há vazamentos de memória ou comportamentos indefinidos em C++.",
                                "O código é legível e documentado adequadamente."
                              ],
                              "assessmentCriteria": [
                                "Presença de herança correta da classe de exceção (Exception/std::exception).",
                                "Uso preciso de raise/throw com instância customizada no método.",
                                "Lógica de verificação de negócio clara e sem side-effects indesejados.",
                                "Cobertura de testes para lançamento de exceção >= 80%.",
                                "Mensagens de erro informativas e não vazias.",
                                "Integração seamless em método de instância OOP."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Validações numéricas e condições lógicas (if/else).",
                                "Design de Software: Princípios de programação defensiva e SOLID (Single Responsibility).",
                                "Testes e QA: Escrita de testes unitários para exceções.",
                                "Lógica e Algoritmos: Fluxo de controle com interrupções excepcionais."
                              ],
                              "realWorldApplication": "Em aplicações bancárias/financeiras, lançar InvalidTransactionError em métodos de transferência para prevenir fraudes ou erros de entrada, garantindo integridade de dados e logs auditáveis para compliance regulatório como GDPR ou PCI-DSS."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.2.3",
                            "name": "Integrar lançamento em fluxos OO",
                            "description": "Incorporar lançamento de exceções customizadas em métodos de classes que utilizam encapsulamento, como setters que validam atributos, garantindo propagação correta para tratamento superior.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Criar classe de exceção personalizada",
                                  "subSteps": [
                                    "Estenda a classe Exception ou RuntimeException conforme necessidade (checked ou unchecked).",
                                    "Defina construtores: padrão, com mensagem e com causa.",
                                    "Adicione campos personalizados se necessário (ex: código de erro).",
                                    "Implemente toString() para mensagem clara.",
                                    "Compile e teste instanciação básica."
                                  ],
                                  "verification": "Instancie a exceção e verifique se mensagem e stack trace são exibidos corretamente via System.out.println.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE (Eclipse/IntelliJ/VSCode)",
                                    "JDK 8+",
                                    "Exemplo de código base de classe OO"
                                  ],
                                  "tips": "Use RuntimeException para exceções unchecked em validações simples; prefira Exception para checked em fluxos críticos.",
                                  "learningObjective": "Compreender herança de exceções e customização de mensagens.",
                                  "commonMistakes": [
                                    "Esquecer de chamar super() nos construtores.",
                                    "Não serializar campos personalizados.",
                                    "Usar Exception genérica em vez de customizada."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar lançamento em setter com encapsulamento",
                                  "subSteps": [
                                    "Identifique atributo privado a validar (ex: idade em classe Pessoa).",
                                    "No setter, adicione if condicional para validação (ex: idade < 0 || idade > 150).",
                                    "Crie e lance new InvalidAgeException('Idade inválida: ' + idade).",
                                    "Garanta que setter retorne void ou this (para fluência).",
                                    "Teste setter isoladamente."
                                  ],
                                  "verification": "Chame setter com valor inválido e confirme que exceção é lançada sem prosseguir.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Classe Pessoa com atributos encapsulados",
                                    "Exceção customizada do step 1"
                                  ],
                                  "tips": "Use String.format() para mensagens dinâmicas; logue contexto antes de lançar.",
                                  "learningObjective": "Aplicar encapsulamento com validação robusta via exceções.",
                                  "commonMistakes": [
                                    "Lançar exceção sem mensagem informativa.",
                                    "Não validar todos os casos de borda (null, extremos).",
                                    "Retornar valor inválido em vez de lançar."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar lançamento em fluxo principal de método da classe",
                                  "subSteps": [
                                    "Crie método de fluxo (ex: cadastrar() que chama múltiplos setters).",
                                    "Inclua chamadas a setters que podem lançar exceções.",
                                    "Adicione try-catch local se tratamento parcial for necessário, senão propague.",
                                    "Teste fluxo completo com cenários válidos e inválidos.",
                                    "Refatore para consistência em múltiplos pontos."
                                  ],
                                  "verification": "Execute método e verifique se exceção propaga corretamente de setter para método.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Classe com setter do step 2",
                                    "Método de fluxo esboçado"
                                  ],
                                  "tips": "Evite try-catch desnecessário no setter; propague para camadas superiores.",
                                  "learningObjective": "Incorporar exceções em fluxos OO compostos mantendo propagação.",
                                  "commonMistakes": [
                                    "Capturar e ignorar exceções prematuramente.",
                                    "Não propagar exceções customizadas.",
                                    "Fluxo continua após exceção (use return após throw)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Garantir propagação e tratamento em chamadas superiores",
                                  "subSteps": [
                                    "Crie método chamador (ex: main ou serviço) que invoque o fluxo da classe.",
                                    "Adicione try-catch no chamador para tratar exceções propagadas.",
                                    "Implemente recuperação ou log (ex: imprimir stack trace e mensagem amigável).",
                                    "Teste cenários: válido (sucesso), inválido (tratamento).",
                                    "Verifique ausência de vazamento de exceções não tratadas."
                                  ],
                                  "verification": "Rode programa completo; confirme lançamento, propagação e tratamento sem crash.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Classe completa dos steps anteriores",
                                    "Método main ou test"
                                  ],
                                  "tips": "Use multi-catch para múltiplas exceções; prefira finally para cleanup.",
                                  "learningObjective": "Gerenciar hierarquia de propagação em OO.",
                                  "commonMistakes": [
                                    "Não tratar exceções no topo (uncaught exception).",
                                    "Perder contexto na propagação.",
                                    "Try-catch engolindo exceções sem ação."
                                  ]
                                }
                              ],
                              "practicalExample": "Na classe ContaBancaria, crie InvalidSaldoException. No setter setSaldo(double valor), lance se valor < 0. No método depositar(double valor), chame setSaldo(saldo + valor). No main, ao tentar ContaBancaria cb = new(); cb.setSaldo(-100); capture e exiba 'Saldo negativo inválido'.",
                              "finalVerifications": [
                                "Exceção customizada compila e instancia corretamente.",
                                "Setter lança exceção em input inválido sem setar atributo.",
                                "Fluxo de método propaga exceção para chamador.",
                                "Tratamento superior captura, loga e recupera graciosamente.",
                                "Testes unitários (JUnit) cobrem cenários válidos/inválidos.",
                                "Stack trace mostra origem correta no setter."
                              ],
                              "assessmentCriteria": [
                                "Código segue princípios OO (encapsulamento, herança).",
                                "Exceções propagam corretamente sem vazamentos.",
                                "Mensagens de erro são claras e contextuais.",
                                "Cobertura de testes > 80% para fluxos excepcionais.",
                                "Performance não degradada por validações.",
                                "Refatorável e extensível para novas validações."
                              ],
                              "crossCurricularConnections": [
                                "Design de Software: Princípios SOLID (Single Responsibility para validações).",
                                "Testes de Software: JUnit para exceções esperadas (@Test(expected=...)).",
                                "Banco de Dados: Validações em DAOs propagando SQLException customizadas.",
                                "Engenharia de Software: Logging com SLF4J para auditoria de erros."
                              ],
                              "realWorldApplication": "Em sistemas bancários, validar transferências negativas lança InvalidTransactionException em serviços OO, propagando para controllers web que retornam HTTP 400 com JSON de erro, evitando inconsistências de dados e fraudes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.6",
                    "name": "Exceções Personalizadas",
                    "description": "Criação de subclasses de exceções para erros específicos da aplicação.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.6.1",
                        "name": "Criação de Exceção Personalizada Básica",
                        "description": "Criação de uma subclasse simples da classe Exception para representar erros específicos da aplicação, utilizando herança da POO.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.6.1.1",
                            "name": "Definir classe herdeira de Exception",
                            "description": "Criar uma nova classe que herda diretamente da classe base Exception em Python, definindo-a com a sintaxe class MinhaExcecao(Exception):.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e compreender a classe base Exception",
                                  "subSteps": [
                                    "Abra um editor de código Python como VS Code ou IDLE.",
                                    "Importe a classe Exception do módulo builtins (não necessário explicitamente, pois é built-in).",
                                    "Consulte a documentação oficial do Python sobre exceções em python.org para entender a hierarquia.",
                                    "Crie um arquivo novo chamado excecoes_personalizadas.py.",
                                    "Escreva um comentário explicando o propósito: definir uma exceção personalizada."
                                  ],
                                  "verification": "Ambiente pronto sem erros de importação e arquivo criado com comentários iniciais.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código Python",
                                    "Documentação Python (docs.python.org/3/tutorial/errors.html)"
                                  ],
                                  "tips": "Use print(dir(Exception)) para explorar atributos da classe base.",
                                  "learningObjective": "Compreender o papel da classe Exception como base para herança personalizada.",
                                  "commonMistakes": [
                                    "Confundir Exception com BaseException (use Exception para exceções definidas pelo usuário)",
                                    "Não consultar docs e assumir conhecimento prévio"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a classe herdeira básica com sintaxe de herança",
                                  "subSteps": [
                                    "Escreva a linha: class MinhaExcecao(Exception):",
                                    "Adicione pass ou um docstring simples dentro da classe.",
                                    "Salve o arquivo e execute python excecoes_personalizadas.py para verificar sintaxe.",
                                    "Use isinstance para testar herança em um bloco de teste: print(issubclass(MinhaExcecao, Exception)) deve retornar True.",
                                    "Adicione um print('Classe definida com sucesso') após a definição."
                                  ],
                                  "verification": "Código executa sem SyntaxError e issubclass confirma herança.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Arquivo excecoes_personalizadas.py",
                                    "Interpretador Python 3.8+"
                                  ],
                                  "tips": "Sempre use dois pontos (:) após o nome da classe e parênteses para herança.",
                                  "learningObjective": "Dominar a sintaxe básica de definição de classe herdeira em Python.",
                                  "commonMistakes": [
                                    "Esquecer parênteses em class MinhaExcecao(Exception)",
                                    "Indentação incorreta no corpo da classe",
                                    "Usar Exception sem importação (é built-in)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Personalizar o construtor __init__ da exceção",
                                  "subSteps": [
                                    "Dentro da classe, defina def __init__(self, mensagem='Erro padrão'):",
                                    "Chame super().__init__(mensagem) para propagar a mensagem à classe base.",
                                    "Adicione self.mensagem = mensagem se quiser atributo customizado (opcional).",
                                    "Salve e execute novamente para testar definição.",
                                    "Teste criando uma instância: ex = MinhaExcecao('Teste') e print(ex) para ver mensagem."
                                  ],
                                  "verification": "Instância da exceção imprime mensagem corretamente sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Mesmo arquivo Python",
                                    "Console interativo (python -i excecoes_personalizadas.py)"
                                  ],
                                  "tips": "super().__init__() garante compatibilidade com a classe base.",
                                  "learningObjective": "Implementar inicializador personalizado herdando comportamento da superclasse.",
                                  "commonMistakes": [
                                    "Não chamar super().__init__(), causando perda de mensagem",
                                    "Argumentos errados em super()",
                                    "Confundir self.args com mensagem customizada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar a exceção completa com raise e try-except",
                                  "subSteps": [
                                    "Adicione um bloco try: raise MinhaExcecao('Erro de teste')",
                                    "No except MinhaExcecao as e: print(f'Capturado: {e}')",
                                    "Execute o script e verifique se a exceção é levantada e capturada corretamente.",
                                    "Verifique excepcionais com print(e.__class__.__bases__) para confirmar herança.",
                                    "Refatore se necessário e documente o teste com comentários."
                                  ],
                                  "verification": "Exceção é levantada, capturada e herança confirmada nos logs.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Arquivo atualizado",
                                    "Terminal para execução"
                                  ],
                                  "tips": "Use except MinhaExcecao para captura específica, não except Exception.",
                                  "learningObjective": "Validar funcionalidade da exceção personalizada em contexto real.",
                                  "commonMistakes": [
                                    "Raise sem argumentos, usando mensagem padrão incorreta",
                                    "Captura genérica que mascara erros",
                                    "Não testar herança explicitamente"
                                  ]
                                }
                              ],
                              "practicalExample": "```python\nclass SaldoInsuficienteError(Exception):\n    def __init__(self, saldo_atual, valor_saque):\n        mensagem = f'Saldo insuficiente: R${saldo_atual:.2f} < R${valor_saque:.2f}'\n        super().__init__(mensagem)\n\n# Teste:\ntry:\n    raise SaldoInsuficienteError(50.0, 100.0)\nexcept SaldoInsuficienteError as e:\n    print(e)\n```\nSaída: Saldo insuficiente: R$50.00 < R$100.00",
                              "finalVerifications": [
                                "issubclass(MinhaExcecao, Exception) retorna True",
                                "Instância da classe imprime mensagem personalizada corretamente",
                                "Exceção é levantada com raise MinhaExcecao() sem SyntaxError ou TypeError",
                                "Captura específica com except MinhaExcecao funciona",
                                "Código completo executa em Python 3 sem warnings de depreciação",
                                "Docstring ou comentários explicam o propósito da classe"
                              ],
                              "assessmentCriteria": [
                                "Sintaxe de herança correta com (Exception)",
                                "Método __init__ chama super().__init__ adequadamente",
                                "Tratamento de mensagem personalizada funcional",
                                "Testes de verificação incluídos e passam",
                                "Código limpo com indentação PEP8 e comentários",
                                "Sem erros comuns como herança de BaseException"
                              ],
                              "crossCurricularConnections": [
                                "Lógica e Estruturas Condicionais (Matemática/Algoritmos)",
                                "Escrita Técnica e Documentação (Língua Portuguesa)",
                                "Design de Sistemas e Engenharia de Software",
                                "Análise de Erros e Debugging (Estatística)"
                              ],
                              "realWorldApplication": "Em aplicações financeiras como apps de banco para criar SaldoInsuficienteError, validando saques e fornecendo mensagens claras para usuários, melhorando robustez e UX em sistemas produtivos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.6.1.2",
                            "name": "Implementar construtor com mensagem personalizada",
                            "description": "Sobrescrever o método __init__ na subclasse para aceitar e armazenar uma mensagem de erro personalizada, utilizando super().__init__(msg) para inicializar a exceção base.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e preparar a classe base Exception",
                                  "subSteps": [
                                    "Revise a documentação da classe Exception no Python.",
                                    "Crie um arquivo Python novo para o exercício.",
                                    "Instancie uma Exception padrão e observe sua mensagem padrão.",
                                    "Levante a exceção com raise Exception('Mensagem teste') e capture com try-except para ver o output.",
                                    "Anote as características do construtor padrão da Exception."
                                  ],
                                  "verification": "Você consegue levantar e capturar uma Exception padrão exibindo sua mensagem corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Python 3.8+ instalado",
                                    "Terminal para executar scripts"
                                  ],
                                  "tips": "Use print(exception) dentro do except para visualizar a mensagem.",
                                  "learningObjective": "Compreender o comportamento padrão do construtor de Exception.",
                                  "commonMistakes": [
                                    "Não capturar a exceção corretamente",
                                    "Confundir Exception com subclasses como ValueError"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a subclasse com herança de Exception",
                                  "subSteps": [
                                    "Defina uma nova classe, ex: class MinhaExcecao(Exception):",
                                    "Adicione pass no corpo da classe inicialmente.",
                                    "Instancie a subclasse sem argumentos: MinhaExcecao() e verifique se herda corretamente.",
                                    "Teste raise MinhaExcecao() em um try-except.",
                                    "Adicione um parâmetro msg ao __init__ sem implementar ainda."
                                  ],
                                  "verification": "A subclasse é instanciada sem erros e herda de Exception (verifique com isinstance).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Mesmo arquivo Python do step 1",
                                    "Documentação Python: https://docs.python.org/3/library/exceptions.html"
                                  ],
                                  "tips": "Use issubclass(MinhaExcecao, Exception) para confirmar herança.",
                                  "learningObjective": "Criar uma subclasse básica de Exception.",
                                  "commonMistakes": [
                                    "Esquecer os dois underscores em __init__",
                                    "Não indentar corretamente a classe"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o construtor __init__ com super().__init__(msg)",
                                  "subSteps": [
                                    "No __init__(self, msg), armazene self.msg = msg.",
                                    "Adicione a linha super().__init__(msg) logo após.",
                                    "Teste instanciação: excecao = MinhaExcecao('Erro personalizado').",
                                    "Levante com raise MinhaExcecao('Teste') e capture para ver a mensagem.",
                                    "Ajuste se necessário para self.message = msg se quiser compatibilidade extra."
                                  ],
                                  "verification": "Ao imprimir ou str() da exceção, a mensagem personalizada aparece corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "IPython ou REPL para testes rápidos"
                                  ],
                                  "tips": "super() deve ser chamado antes de qualquer outra inicialização para evitar erros.",
                                  "learningObjective": "Sobrescrever __init__ corretamente usando super() para inicializar a base.",
                                  "commonMistakes": [
                                    "Chamar Exception(msg) em vez de super().__init__(msg)",
                                    "Não passar self implicitamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar a exceção personalizada em contexto",
                                  "subSteps": [
                                    "Crie uma função que levante a exceção com base em condição, ex: validação de input.",
                                    "Use try-except para capturar e imprimir a mensagem.",
                                    "Teste com diferentes mensagens e sem msg para ver comportamento.",
                                    "Verifique args da exceção com excecao.args.",
                                    "Refatore para garantir que funcione em múltiplos cenários."
                                  ],
                                  "verification": "A exceção é levantada, capturada e exibe msg personalizada em todos os testes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Script de teste completo",
                                    "Unittest ou pytest opcional"
                                  ],
                                  "tips": "Sempre teste edge cases como msg vazia ou None.",
                                  "learningObjective": "Aplicar a exceção personalizada em um fluxo real de código.",
                                  "commonMistakes": [
                                    "Não tratar msg=None causando TypeError",
                                    "Esquecer de propagar args para super()"
                                  ]
                                }
                              ],
                              "practicalExample": "class InvalidInputError(Exception):\n    def __init__(self, msg):\n        self.msg = msg\n        super().__init__(msg)\n\n# Uso:\ndef validar_idade(idade):\n    if idade < 0:\n        raise InvalidInputError('Idade não pode ser negativa')\n\ntry:\n    validar_idade(-5)\nexcept InvalidInputError as e:\n    print(e)  # Output: Idade não pode ser negativa",
                              "finalVerifications": [
                                "A subclasse herda corretamente de Exception (issubclass confirma).",
                                "Instanciação com msg personalizada não gera erros.",
                                "super().__init__(msg) inicializa a mensagem base corretamente.",
                                "Ao levantar e capturar, str(e) ou print(e) mostra a msg personalizada.",
                                "Exceção funciona em try-except sem perda de funcionalidades da base.",
                                "Testes com msg vazia ou múltiplos args propagam adequadamente."
                              ],
                              "assessmentCriteria": [
                                "Uso correto de herança com (Exception).",
                                "Definição precisa de __init__(self, msg).",
                                "Chamada exata de super().__init__(msg).",
                                "Armazenamento opcional de self.msg ou uso de self.message.",
                                "Testes demonstram funcionalidade completa.",
                                "Código limpo, indentado e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Lógica e Estruturas de Controle (condições para raise).",
                                "Design de Software (padrões de exceções customizadas).",
                                "Comunicação (criação de mensagens claras e úteis).",
                                "Testes e Depuração (validação de comportamento)."
                              ],
                              "realWorldApplication": "Em validações de formulários web (ex: Flask/Django), APIs REST para erros HTTP customizados, jogos para feedback de input inválido, ou scripts de automação para alertas personalizados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.6.1.3",
                            "name": "Levantar exceção personalizada",
                            "description": "Utilizar a instrução raise MinhaExcecao('mensagem') em pontos específicos do código onde o erro customizado deve ser sinalizado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a classe de exceção personalizada",
                                  "subSteps": [
                                    "Crie uma nova classe que herde de Exception.",
                                    "Nomeie a classe de forma descritiva, como MinhaExcecao.",
                                    "Adicione um método __init__ para personalizar a mensagem de erro.",
                                    "Teste a criação da classe importando-a em um script simples.",
                                    "Verifique se a classe pode ser instanciada com raise MinhaExcecao('teste')"
                                  ],
                                  "verification": "Execute um script que instancia e levanta a exceção; confirme que a mensagem aparece sem erros de sintaxe.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Interpretador Python 3.x",
                                    "Documentação oficial de exceções Python"
                                  ],
                                  "tips": "Use nomes de classes em CamelCase para exceções personalizadas, seguindo convenções PEP 8.",
                                  "learningObjective": "Compreender como criar uma exceção customizada herdando de Exception para uso posterior.",
                                  "commonMistakes": [
                                    "Esquecer de herdar de Exception",
                                    "Não definir __init__ corretamente",
                                    "Usar print em vez de raise"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar pontos de levantamento de exceção no código",
                                  "subSteps": [
                                    "Analise o fluxo do programa e identifique condições inválidas (ex: input negativo, string vazia).",
                                    "Defina critérios claros para quando a exceção deve ser levantada.",
                                    "Marque os pontos no código com comentários explicativos.",
                                    "Considere o contexto: validação de entrada, estado inválido de objeto, etc.",
                                    "Discuta com um par ou anote por que esses pontos são apropriados."
                                  ],
                                  "verification": "Revise o código comentado e confirme que há pelo menos 2-3 pontos lógicos identificados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código base do programa",
                                    "Papel ou ferramenta de diagramação (ex: draw.io)"
                                  ],
                                  "tips": "Priorize exceções para erros recuperáveis ou de validação, não para fluxo normal.",
                                  "learningObjective": "Desenvolver habilidade para detectar cenários que justificam exceções personalizadas.",
                                  "commonMistakes": [
                                    "Levantar exceções em condições normais",
                                    "Ignorar exceções built-in existentes",
                                    "Sobrepor exceções desnecessariamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a instrução raise no código",
                                  "subSteps": [
                                    "Insira 'raise MinhaExcecao(\"mensagem descritiva\")' nos pontos identificados.",
                                    "Personalize a mensagem com detalhes contextuais (ex: valor inválido).",
                                    "Use estruturas condicionais (if) para acionar o raise.",
                                    "Certifique-se de que o raise interrompe a execução corretamente.",
                                    "Salve e execute o código para testar sintaxe."
                                  ],
                                  "verification": "Execute o código com input que acione o raise; verifique se a exceção é levantada com a mensagem correta.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código do Step 2",
                                    "Terminal Python para testes interativos"
                                  ],
                                  "tips": "Mensagens devem ser claras e incluir valores variáveis para debugging (ex: f'Idade {idade} inválida').",
                                  "learningObjective": "Aplicar corretamente a sintaxe raise para sinalizar erros customizados.",
                                  "commonMistakes": [
                                    "Esquecer aspas na mensagem",
                                    "Usar return em vez de raise",
                                    "Não importar a classe exceção"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e refinar o levantamento de exceção",
                                  "subSteps": [
                                    "Crie testes unitários com pytest ou asserts manuais para cenários válidos e inválidos.",
                                    "Simule inputs que acionem o raise e verifique stack trace.",
                                    "Adicione try-except em pontos superiores para capturar e logar.",
                                    "Refine mensagens baseadas em testes falhos.",
                                    "Documente o uso da exceção no código."
                                  ],
                                  "verification": "Todos os testes passam: exceções levantadas corretamente em casos inválidos, fluxo normal prossegue.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Biblioteca pytest (pip install pytest)",
                                    "Scripts de teste"
                                  ],
                                  "tips": "Use pytest.raises(MinhaExcecao) para testes assertivos de exceções.",
                                  "learningObjective": "Validar o comportamento do raise em cenários reais e iterar melhorias.",
                                  "commonMistakes": [
                                    "Não testar casos edge (valores limite)",
                                    "Ignorar stack trace para debugging",
                                    "Exceções não capturadas crashando o programa"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um validador de idade para um sistema de reservas: def validar_idade(idade): if idade < 0 or idade > 150: raise IdadeInvalida(f'Idade {idade} fora do intervalo válido (0-150).') return True. Chame validar_idade(-5) para levantar IdadeInvalida.",
                              "finalVerifications": [
                                "O código levanta MinhaExcecao com mensagem personalizada em condições inválidas.",
                                "Execução normal prossegue sem exceções desnecessárias.",
                                "Stack trace mostra origem correta do raise.",
                                "Testes unitários cobrem 100% dos cenários de raise.",
                                "Mensagens de erro são claras e úteis para debugging.",
                                "Exceção é tratável com try-except."
                              ],
                              "assessmentCriteria": [
                                "Correção da sintaxe raise (100% funcional).",
                                "Pontos de raise logicamente apropriados (sem overuse/underuse).",
                                "Mensagens personalizadas e informativas.",
                                "Cobertura de testes para raise (mínimo 80%).",
                                "Integração limpa no fluxo do programa.",
                                "Adesão a boas práticas OOP e PEP 8."
                              ],
                              "crossCurricularConnections": [
                                "Lógica condicional e estruturas de controle (if/else).",
                                "Programação Orientada a Objetos (herança e classes).",
                                "Testes e TDD (Test-Driven Development).",
                                "Design de software (defensive programming).",
                                "Depuração e análise de erros."
                              ],
                              "realWorldApplication": "Em aplicações web (ex: Flask/Django) para validar inputs de formulários, em APIs para erros de autenticação customizados, ou em jogos para estados inválidos de jogador, garantindo robustez e feedback claro ao usuário."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.6.2",
                        "name": "Exceções Personalizadas com Atributos Adicionais",
                        "description": "Extensão de exceções personalizadas incluindo atributos extras para fornecer contexto detalhado sobre o erro, promovendo encapsulamento e abstração.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.6.2.1",
                            "name": "Adicionar atributos customizados",
                            "description": "No método __init__, incluir parâmetros adicionais como código de erro ou dados contextuais, armazenando-os como atributos de instância (self.codigo_erro = codigo).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a estrutura básica de exceções personalizadas",
                                  "subSteps": [
                                    "Revise a classe base Exception do Python e como classes personalizadas herdam dela.",
                                    "Identifique o método __init__ padrão da Exception, que aceita uma mensagem.",
                                    "Planeje os atributos customizados necessários, como codigo_erro e dados contextuais.",
                                    "Esboce a assinatura do __init__ da sua classe: def __init__(self, mensagem, codigo_erro, dados_contextuais=None).",
                                    "Discuta por que atributos extras melhoram o tratamento de erros em aplicações reais."
                                  ],
                                  "verification": "Confirme que você pode listar verbalmente ou por escrito os componentes essenciais de uma exceção personalizada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial do Python sobre exceções (docs.python.org/3/tutorial/errors.html)",
                                    "Editor de código como VS Code ou PyCharm"
                                  ],
                                  "tips": "Sempre chame super().__init__(mensagem) para preservar o comportamento padrão.",
                                  "learningObjective": "Compreender como estender a classe Exception para incluir dados adicionais.",
                                  "commonMistakes": [
                                    "Esquecer de herdar de Exception",
                                    "Não chamar o __init__ da superclasse"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o método __init__ com parâmetros adicionais",
                                  "subSteps": [
                                    "Crie a classe personalizada, ex: class MinhaExcecao(Exception):",
                                    "Defina o __init__ com super().__init__(mensagem) e atribua self.codigo_erro = codigo_erro.",
                                    "Adicione outros atributos como self.dados_contextuais = dados_contextuais ou None.",
                                    "Teste a instanciação básica: excecao = MinhaExcecao('Erro!', 404, {'user_id': 123}).",
                                    "Acesse os atributos: print(excecao.codigo_erro) deve retornar 404."
                                  ],
                                  "verification": "Instancie a exceção e imprima self.codigo_erro e self.dados_contextuais sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python REPL ou Jupyter Notebook",
                                    "Exemplos de código de exceções personalizadas"
                                  ],
                                  "tips": "Use type hints nos parâmetros para melhor legibilidade: def __init__(self, mensagem: str, codigo_erro: int).",
                                  "learningObjective": "Criar um construtor que capture e armazene atributos customizados de forma segura.",
                                  "commonMistakes": [
                                    "Não validar tipos de entrada nos parâmetros",
                                    "Esquecer de inicializar atributos opcionais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Sobrescrever métodos de representação para exibir atributos customizados",
                                  "subSteps": [
                                    "Implemente __str__ para incluir codigo_erro na mensagem: return f'{super().__str__()} [Código: {self.codigo_erro}]'.",
                                    "Opcionalmente, adicione __repr__ para depuração detalhada com dados_contextuais.",
                                    "Teste a representação: print(excecao) deve mostrar mensagem e código.",
                                    "Levante a exceção com raise MinhaExcecao('Teste', 500) e capture com try-except para verificar.",
                                    "Registre o erro em um log simples usando logging para simular uso real."
                                  ],
                                  "verification": "Execute print(excecao) e confirme que atributos customizados aparecem na saída.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Módulo logging do Python",
                                    "Terminal para execução de scripts"
                                  ],
                                  "tips": "Mantenha __str__ conciso para logs de usuário, use __repr__ para desenvolvedores.",
                                  "learningObjective": "Melhorar a usabilidade da exceção exibindo informações customizadas.",
                                  "commonMistakes": [
                                    "Retornar dict em __str__ em vez de string",
                                    "Não chamar super().__str__()"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar a exceção personalizada em um cenário completo",
                                  "subSteps": [
                                    "Crie uma função que levante a exceção condicionalmente, ex: validação de input.",
                                    "Use try-except para capturar, acessar self.codigo_erro e tratar adequadamente.",
                                    "Escreva testes unitários com unittest ou pytest para instanciação e atributos.",
                                    "Simule diferentes cenários: código_erro válido/inválido, dados_contextuais presentes/ausentes.",
                                    "Refatore o código para garantir que todos os atributos sejam acessíveis via getattr."
                                  ],
                                  "verification": "Todos os testes passam e atributos são corretamente armazenados e acessados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Biblioteca pytest ou unittest",
                                    "Script de teste completo"
                                  ],
                                  "tips": "Use assert excecao.codigo_erro == 404 nos testes para verificação precisa.",
                                  "learningObjective": "Garantir robustez da exceção através de testes automatizados.",
                                  "commonMistakes": [
                                    "Não testar casos edge como None em dados_contextuais",
                                    "Ignorar exceções sem acessar atributos"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe ValidacaoErro(Exception): def __init__(self, mensagem, codigo_erro, campo_invalido): super().__init__(mensagem); self.codigo_erro = codigo_erro; self.campo_invalido = campo_invalido. Em uma função de login: if not email_valido(email): raise ValidacaoErro('Email inválido', 400, 'email'). No except: print(f'Erro {e.codigo_erro} no campo {e.campo_invalido}').",
                              "finalVerifications": [
                                "A exceção é instanciada sem erros e atributos customizados são atribuídos corretamente.",
                                "Ao imprimir a exceção, mensagem e código de erro são exibidos claramente.",
                                "Atributos extras podem ser acessados via self.codigo_erro e self.dados_contextuais.",
                                "A exceção é levantada e capturada corretamente em try-except.",
                                "Testes unitários confirmam comportamento em múltiplos cenários.",
                                "Não há erros de TypeError ou AttributeError ao acessar atributos."
                              ],
                              "assessmentCriteria": [
                                "Código herda corretamente de Exception e chama super().__init__().",
                                "Todos os parâmetros adicionais são armazenados como atributos de instância.",
                                "__str__ ou __repr__ inclui informações customizadas de forma legível.",
                                "Exemplo prático demonstra uso real com raise e except.",
                                "Testes cobrem pelo menos 80% dos casos, incluindo edge cases.",
                                "Código é limpo, com type hints e comentários explicativos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Uso de códigos numéricos de erro para categorização sistemática.",
                                "Design de Software: Princípios de encapsulamento e extensão de classes.",
                                "Banco de Dados: Armazenamento de erros com metadados para logs persistentes.",
                                "Segurança da Informação: Tratamento detalhado de falhas de validação."
                              ],
                              "realWorldApplication": "Em APIs web (ex: Flask/Django), exceções personalizadas com códigos HTTP e dados contextuais permitem respostas JSON detalhadas como {'error': 'Invalid input', 'code': 400, 'field': 'email'}, facilitando debugging e integração com front-ends ou sistemas de monitoramento como Sentry."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.6.2.2",
                            "name": "Sobrescrever método __str__",
                            "description": "Implementar o método __str__ para retornar uma representação legível da exceção, incorporando atributos personalizados à mensagem de erro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o papel do método __str__ em exceções Python",
                                  "subSteps": [
                                    "Estude a documentação oficial do Python sobre exceções e o método __str__.",
                                    "Analise exemplos de exceções built-in como ValueError e como elas formatam mensagens.",
                                    "Compare __str__ com __repr__ para entender diferenças em representações legíveis vs depuração."
                                  ],
                                  "verification": "Explique em comentários no código por que __str__ é usado para mensagens de erro legíveis.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Documentação Python: https://docs.python.org/3/reference/datamodel.html#object.__str__",
                                    "Editor de código como VS Code ou PyCharm"
                                  ],
                                  "tips": "Sempre priorize mensagens claras para usuários finais, não apenas desenvolvedores.",
                                  "learningObjective": "Identificar quando e por que sobrescrever __str__ em classes de exceção personalizadas.",
                                  "commonMistakes": "Confundir __str__ com __repr__, resultando em saídas não legíveis para usuários."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a classe de exceção personalizada com atributos adicionais",
                                  "subSteps": [
                                    "Crie uma classe que herde de Exception.",
                                    "Adicione atributos personalizados no __init__, como 'codigo_erro' e 'detalhes'.",
                                    "Inicialize os atributos com super().__init__ para mensagem base."
                                  ],
                                  "verification": "Instancie a exceção e acesse os atributos via getattr para confirmar armazenamento.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python 3.x instalado",
                                    "Notebook Jupyter para testes rápidos"
                                  ],
                                  "tips": "Use validações nos atributos no __init__ para evitar valores inválidos.",
                                  "learningObjective": "Criar uma exceção que armazene dados contextuais além da mensagem padrão.",
                                  "commonMistakes": "Esquecer de chamar super().__init__(), causando perda da herança de Exception."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e customizar o método __str__",
                                  "subSteps": [
                                    "Defina def __str__(self): na classe.",
                                    "Construa uma string que inclua self.msg, self.codigo_erro e self.detalhes.",
                                    "Retorne a string formatada de forma legível, ex: f'Erro {codigo}: {detalhes}'."
                                  ],
                                  "verification": "Imprima uma instância da exceção e verifique se a mensagem incorpora todos os atributos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos de código de exceções personalizadas online (Stack Overflow)"
                                  ],
                                  "tips": "Use f-strings para formatação dinâmica e evite quebras de linha desnecessárias.",
                                  "learningObjective": "Sobrescrever __str__ para gerar mensagens de erro ricas em contexto.",
                                  "commonMistakes": "Retornar None ou não string, causando TypeError ao imprimir."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar a exceção personalizada em um cenário prático",
                                  "subSteps": [
                                    "Levante a exceção em uma função de teste com try-except.",
                                    "Capture e imprima a exceção para validar __str__.",
                                    "Adicione asserts para verificar conteúdo da mensagem gerada."
                                  ],
                                  "verification": "Execute o teste e confirme que print(exc) mostra mensagem customizada com atributos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Biblioteca unittest ou pytest para automação"
                                  ],
                                  "tips": "Teste edge cases como atributos vazios para robustez.",
                                  "learningObjective": "Validar o funcionamento integrado da exceção com __str__ customizado.",
                                  "commonMistakes": "Não testar com raise sem mensagem base, expondo falhas no __str__."
                                }
                              ],
                              "practicalExample": "Crie InvalidAccountBalanceError('Saldo insuficiente', codigo='INS001', saldo_atual=50.0, valor_solicitado=100.0). Ao imprimir: 'Erro INS001: Saldo insuficiente. Saldo atual: 50.0, Solicitado: 100.0'.",
                              "finalVerifications": [
                                "A mensagem impressa inclui todos os atributos personalizados.",
                                "Instanciação não gera erros de herança.",
                                "Teste com print(exc) produz string legível e formatada.",
                                "Exceção é levantada corretamente em try-except.",
                                "Atributos permanecem acessíveis pós-instanciação."
                              ],
                              "assessmentCriteria": [
                                "Código usa herança correta de Exception.",
                                "__str__ retorna string incorporando atributos dinamicamente.",
                                "Mensagem é clara, concisa e user-friendly.",
                                "Testes cobrem cenários normais e edge cases.",
                                "Sem erros de sintaxe ou TypeError em print."
                              ],
                              "crossCurricularConnections": [
                                "Design de Software: Melhora logging e debugging.",
                                "UX/UI: Mensagens de erro amigáveis para usuários finais.",
                                "Matemática: Formatação de números em mensagens (ex: floats).",
                                "Linguagem Natural: Redação clara de strings descritivas."
                              ],
                              "realWorldApplication": "Em sistemas bancários, exceções como InvalidTransactionError usam __str__ para logs auditáveis e alertas ao usuário mostrando saldo exato e motivo da falha, facilitando suporte e conformidade regulatória."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.6.2.3",
                            "name": "Acessar atributos na exceção capturada",
                            "description": "Em um bloco except MinhaExcecao as e:, acessar e.codigo_erro ou outros atributos para log ou tratamento específico baseado no contexto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar ou definir a classe de exceção personalizada com atributos adicionais",
                                  "subSteps": [
                                    "Crie ou abra o código da classe MinhaExcecao que herda de Exception e inclui atributos como self.codigo_erro e self.mensagem_detalhe no __init__.",
                                    "No método __init__, defina self.codigo_erro = codigo_erro e self.mensagem_detalhe = mensagem_detalhe, chamando super().__init__(msg_base).",
                                    "Use print(dir(MinhaExcecao())) ou help(MinhaExcecao) para listar atributos disponíveis.",
                                    "Teste instanciando: erro = MinhaExcecao(404, 'Recurso não encontrado') e acesse erro.codigo_erro.",
                                    "Confirme que os atributos são acessíveis fora do contexto de exceção."
                                  ],
                                  "verification": "Execute dir(erro) e confirme que 'codigo_erro' e 'mensagem_detalhe' aparecem na lista de atributos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Console Python interativo"
                                  ],
                                  "tips": "Sempre inicialize atributos no __init__ para evitar AttributeError ao acessar.",
                                  "learningObjective": "Compreender como atributos personalizados são definidos e acessíveis em exceções customizadas.",
                                  "commonMistakes": [
                                    "Esquecer de chamar super().__init__()",
                                    "Definir atributos como locals em vez de self.",
                                    "Não passar argumentos no __init__ ao instanciar."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o bloco try-except para capturar a exceção",
                                  "subSteps": [
                                    "Escreva um bloco try com código que levanta MinhaExcecao(codigo_erro=404, mensagem_detalhe='Detalhes aqui').",
                                    "No except MinhaExcecao as e:, acesse imediatamente e.codigo_erro e imprima seu valor.",
                                    "Adicione um print(e.mensagem_detalhe) para verificar múltiplos atributos.",
                                    "Garanta que o bloco except capture apenas MinhaExcecao, usando isinstance(e, MinhaExcecao) se necessário.",
                                    "Execute o código e confirme que a exceção é capturada sem crash."
                                  ],
                                  "verification": "O programa captura a exceção e imprime o valor de e.codigo_erro corretamente sem AttributeError.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código da classe MinhaExcecao",
                                    "Terminal para rodar python arquivo.py"
                                  ],
                                  "tips": "Use 'as e' para alias curto; evite nomes genéricos como 'ex' para clareza.",
                                  "learningObjective": "Capturar exceções personalizadas e acessar seus atributos básicos na cláusula except.",
                                  "commonMistakes": [
                                    "Esquecer 'as e' e tentar acessar atributos sem referência.",
                                    "Capturar Exception genérica em vez de específica.",
                                    "Tentar acessar atributos antes de capturar."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Utilizar atributos para tratamento específico ou logging",
                                  "subSteps": [
                                    "No except, use if e.codigo_erro == 404: print('Tratamento para não encontrado') else: print('Outro erro').",
                                    "Implemente logging: import logging; logging.error(f'Erro {e.codigo_erro}: {e.mensagem_detalhe}').",
                                    "Adicione tratamento condicional baseado no código, como retry para 500 ou abortar para 403.",
                                    "Registre o erro em um arquivo ou dicionário para análise posterior.",
                                    "Teste com diferentes valores de codigo_erro (ex: 404, 500) levantando exceções variadas."
                                  ],
                                  "verification": "Execute com códigos diferentes e confirme que o tratamento condicional e logging funcionam como esperado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Módulo logging do Python",
                                    "Arquivo de log de teste"
                                  ],
                                  "tips": "Use logging em vez de print para produção; configure logging.basicConfig(level=logging.ERROR).",
                                  "learningObjective": "Aplicar lógica condicional e logging baseados em atributos da exceção capturada.",
                                  "commonMistakes": [
                                    "Comparar strings em vez de ints para codigo_erro.",
                                    "Não importar logging.",
                                    "Ignorar o contexto da mensagem_detalhe."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e depurar o acesso a atributos em cenários reais",
                                  "subSteps": [
                                    "Crie uma função que levante MinhaExcecao em contextos variados (ex: função de login, API simulada).",
                                    "Adicione try-except ao redor e verifique acesso a atributos em loop ou recursão.",
                                    "Use debugger (pdb ou IDE) para pausar no except e inspecionar e.__dict__.",
                                    "Teste casos edge: atributo não setado, subclasses de exceção.",
                                    "Refatore para um handler genérico que acessa atributos dinamicamente."
                                  ],
                                  "verification": "Todos os testes passam, acessando atributos sem erros e aplicando tratamentos corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Unittest ou pytest para testes automatizados",
                                    "Debugger integrado no IDE"
                                  ],
                                  "tips": "Use assert hasattr(e, 'codigo_erro') antes de acessar para robustez.",
                                  "learningObjective": "Validar o acesso a atributos em fluxos completos e depurar problemas comuns.",
                                  "commonMistakes": [
                                    "Não testar com valores None ou inválidos.",
                                    "Depender de atributos não garantidos.",
                                    "Ignorar exceções filhas."
                                  ]
                                }
                              ],
                              "practicalExample": "```python\nclass MinhaExcecao(Exception):\n    def __init__(self, codigo_erro, mensagem_detalhe):\n        self.codigo_erro = codigo_erro\n        self.mensagem_detalhe = mensagem_detalhe\n        super().__init__(f'Erro {codigo_erro}: {mensagem_detalhe}')\n\ndef funcao_riskosa():\n    raise MinhaExcecao(404, 'Recurso nao encontrado')\n\ntry:\n    funcao_riskosa()\nexcept MinhaExcecao as e:\n    print(f'Codigo: {e.codigo_erro}')\n    if e.codigo_erro == 404:\n        print('Tratamento especifico: recarregar')\n    import logging\n    logging.error(f'Detalhes: {e.mensagem_detalhe}')\n``` Saída esperada: Codigo: 404, Tratamento especifico, log com detalhes.",
                              "finalVerifications": [
                                "Acesso a e.codigo_erro e e.mensagem_detalhe sem AttributeError.",
                                "Tratamento condicional executa corretamente para códigos diferentes.",
                                "Logging registra erro com atributos corretos.",
                                "Exceção é capturada especificamente, sem vazar para handlers genéricos.",
                                "Testes com múltiplas raises funcionam em loop.",
                                "Uso de hasattr(e, 'atributo') previne falhas em casos edge."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe correta do except MinhaExcecao as e:.",
                                "Acesso direto e correto aos atributos personalizados.",
                                "Lógica condicional ou logging baseada nos atributos.",
                                "Tratamento robusto com verificações de existência de atributos.",
                                "Código limpo, legível e comentado.",
                                "Testes cobrem cenários positivos e negativos."
                              ],
                              "crossCurricularConnections": [
                                "Lógica e Algoritmos: Uso de condicionais (if/else) baseadas em valores numéricos.",
                                "Matemática: Manipulação de códigos de erro como inteiros para comparações.",
                                "Inglês Técnico: Mensagens de erro em inglês padrão (ex: 'Not Found').",
                                "Engenharia de Software: Práticas de logging e error handling.",
                                "Banco de Dados: Tratamento de erros de integridade com códigos específicos."
                              ],
                              "realWorldApplication": "Em aplicações web como APIs Flask/Django, acessar códigos de erro personalizados (ex: 404 para recurso ausente) permite respostas HTTP customizadas, logging estruturado para monitoramento (Sentry/ELK), e retry automático para erros transitórios (500), melhorando robustez e experiência do usuário em sistemas empresariais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.6.3",
                        "name": "Integração e Hierarquia de Exceções Personalizadas",
                        "description": "Criação de hierarquias de exceções personalizadas e sua integração em aplicações para tratamento granular de erros específicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.6.3.1",
                            "name": "Criar hierarquia de exceções",
                            "description": "Definir exceções filhas de uma exceção personalizada base, como class ErroValidacao(ExcecaoApp):, para categorizar erros relacionados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a Exceção Base Personalizada",
                                  "subSteps": [
                                    "Analise o contexto da aplicação para identificar erros comuns que precisam de categorização.",
                                    "Crie uma classe base herdando de Exception: class ExcecaoApp(Exception):",
                                    "Adicione atributos personalizados, como codigo_erro e detalhes.",
                                    "Implemente o método __init__ usando super().__init__ para mensagem e atributos extras.",
                                    "Adicione um método str ou repr para formatação de mensagem legível."
                                  ],
                                  "verification": "Instancie ExcecaoApp('teste') e confirme que mensagem e atributos são acessíveis sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Python 3.8+ instalado",
                                    "Console interativo (REPL)"
                                  ],
                                  "tips": "Sempre chame super().__init__(msg) para preservar comportamento padrão da Exception.",
                                  "learningObjective": "Implementar uma exceção base com herança e atributos customizados.",
                                  "commonMistakes": [
                                    "Esquecer de herdar de Exception",
                                    "Não chamar super().__init__()",
                                    "Definir atributos sem __init__"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Planejar a Hierarquia de Exceções Filhas",
                                  "subSteps": [
                                    "Liste erros específicos relacionados à base (ex: validação de email, senha fraca).",
                                    "Desenhe um diagrama simples de herança (base -> filhas).",
                                    "Defina atributos e mensagens únicas para cada filha.",
                                    "Decida sobre herança múltipla se necessário (evite se possível).",
                                    "Priorize 3-5 filhas iniciais para o exemplo prático."
                                  ],
                                  "verification": "Crie um diagrama ou comentário no código descrevendo a hierarquia planejada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagrama (Draw.io)",
                                    "Editor de texto para notas"
                                  ],
                                  "tips": "Use nomes descritivos como ErroEmailInvalido para clareza semântica.",
                                  "learningObjective": "Planejar uma hierarquia lógica de exceções para categorização de erros.",
                                  "commonMistakes": [
                                    "Hierarquia achatada sem níveis",
                                    "Filhas não relacionadas à base",
                                    "Nomes genéricos ou inconsistentes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar as Classes de Exceções Filhas",
                                  "subSteps": [
                                    "Crie a primeira filha: class ErroValidacao(ExcecaoApp): com __init__ customizado.",
                                    "Implemente 2-3 filhas adicionais, como ErroEmailInvalido(ErroValidacao): e ErroSenhaFraca(ErroValidacao):.",
                                    "Adicione lógica específica em cada __init__, como validações extras ou códigos de erro únicos.",
                                    "Teste instanciação individual de cada filha.",
                                    "Verifique herança com issubclass(ErroEmailInvalido, ExcecaoApp)."
                                  ],
                                  "verification": "Execute issubclass() e isinstance() para confirmar relações de herança.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Python REPL para testes rápidos"
                                  ],
                                  "tips": "Reutilize atributos da base nas filhas para consistência.",
                                  "learningObjective": "Criar exceções filhas que estendem funcionalmente a base.",
                                  "commonMistakes": [
                                    "Herança incorreta (ex: herdar de str em vez de Exception)",
                                    "Duplicar código da base",
                                    "__init__ sem super()"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e Testar a Hierarquia Completa",
                                  "subSteps": [
                                    "Escreva funções que levantem exceções filhas em cenários reais (ex: validação de usuário).",
                                    "Implemente blocos try-except capturando base e filhas seletivamente.",
                                    "Teste captura hierárquica: except ErroValidacao captura filhas, mas except ErroEmailInvalido é específico.",
                                    "Adicione logs ou prints para verificar mensagens e atributos.",
                                    "Execute testes unitários com pytest ou unittest para cobertura completa."
                                  ],
                                  "verification": "Todos os testes passam, com captura correta e mensagens exibidas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Biblioteca pytest (pip install pytest)",
                                    "Editor com suporte a testes"
                                  ],
                                  "tips": "Use raise ErroEmailInvalido('Email inválido') em funções de validação.",
                                  "learningObjective": "Integrar e validar o funcionamento prático da hierarquia de exceções.",
                                  "commonMistakes": [
                                    "Except genérico capturando tudo",
                                    "Não testar herança seletiva",
                                    "Ignorar propagação de exceções"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de cadastro de usuários, defina class ExcecaoApp(Exception): com codigo_erro. Crie class ErroValidacao(ExcecaoApp):, class ErroEmailInvalido(ErroValidacao): e class ErroSenhaFraca(ErroValidacao):. Na função validar_usuario(email, senha):, se email inválido, raise ErroEmailInvalido('Formato inválido', codigo=101). Capture com try: ... except ErroEmailInvalido: log_especifico(); except ErroValidacao: log_geral().",
                              "finalVerifications": [
                                "issubclass(ErroEmailInvalido, ExcecaoApp) retorna True.",
                                "Instâncias de filhas acessam atributos da base corretamente.",
                                "Blocos except seletivos capturam hierarquia sem vazamentos.",
                                "Mensagens customizadas são exibidas adequadamente em str().",
                                "Testes unitários cobrem 100% das exceções definidas.",
                                "Nenhuma exceção filha quebra herança ao ser instanciada."
                              ],
                              "assessmentCriteria": [
                                "Hierarquia implementada corretamente com herança múltiplos níveis.",
                                "Cada exceção tem __init__ funcional com super() e atributos únicos.",
                                "Integração em código real com raise e except seletivos.",
                                "Testes demonstram captura hierárquica e mensagens claras.",
                                "Código limpo, com documentação e nomes semânticos.",
                                "Tratamento evita vazamento de informações sensíveis."
                              ],
                              "crossCurricularConnections": [
                                "Programação Orientada a Objetos: Herança e polimorfismo em exceções.",
                                "Design de Software: Padrões de exceções e SOLID principles.",
                                "Banco de Dados: Mapeamento de erros de integridade para exceções customizadas.",
                                "Segurança: Tratamento seguro de erros para evitar disclosure de stack traces.",
                                "Testes de Software: Unit testing de fluxos de exceção."
                              ],
                              "realWorldApplication": "Em frameworks como Django/Flask, hierarquias de exceções personalizadas categorizam erros de API (ex: ValidationError base com subtipos), permitindo respostas HTTP granulares (400 Bad Request com detalhes), logs estruturados e monitoramento em ferramentas como Sentry, melhorando manutenibilidade e experiência do usuário."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.6.3.2",
                            "name": "Capturar exceções em blocos específicos",
                            "description": "Usar try-except com tipos exatos de exceções personalizadas para tratamentos diferenciados, como except MinhaExcecao: log_erro(e).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir classes de exceções personalizadas",
                                  "subSteps": [
                                    "Crie uma classe base personalizada herdando de Exception.",
                                    "Defina pelo menos duas subclasses específicas, como ValidacaoErro e ConexaoErro.",
                                    "Implemente o método __init__ para capturar mensagens de erro com super().__init__(msg).",
                                    "Teste o raise de cada exceção em um bloco simples para verificar herança.",
                                    "Adicione atributos personalizados, como código de erro."
                                  ],
                                  "verification": "Execute raise MinhaExcecao('teste') e confirme que a mensagem e atributos são exibidos corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código Python (VS Code ou PyCharm)",
                                    "Documentação oficial Python sobre exceções (docs.python.org/3/tutorial/errors.html)"
                                  ],
                                  "tips": "Sempre herde de Exception ou subclasses como ValueError para semântica correta.",
                                  "learningObjective": "Compreender e implementar herança de exceções personalizadas com atributos customizados.",
                                  "commonMistakes": [
                                    "Não chamar super().__init__() levando a mensagens vazias",
                                    "Herdar diretamente de BaseException em vez de Exception"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender hierarquia e ordem de captura de exceções",
                                  "subSteps": [
                                    "Estude a hierarquia: Exception é pai de TypeError, ValueError, etc., e suas customizadas.",
                                    "Escreva um diagrama simples da hierarquia das suas exceções personalizadas.",
                                    "Teste um try-except genérico (except Exception:) para capturar todas.",
                                    "Observe como except mais específicas devem vir antes das genéricas.",
                                    "Experimente ordem invertida para ver o comportamento inesperado."
                                  ],
                                  "verification": "Altere ordem dos except e confirme que exceções específicas são capturadas primeiro via prints de debug.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python REPL ou Jupyter Notebook",
                                    "Diagrama de herança (papel ou draw.io)"
                                  ],
                                  "tips": "Lembre-se: Python verifica except de cima para baixo; específicas primeiro!",
                                  "learningObjective": "Dominar a ordem de matching na hierarquia de exceções para evitar capturas erradas.",
                                  "commonMistakes": [
                                    "Colocar except Exception: antes de específicas, 'engolindo' erros",
                                    "Ignorar herança, causando matching incorreto"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar blocos try-except com tipos exatos",
                                  "subSteps": [
                                    "Estruture um try com código que possa levantar múltiplas exceções personalizadas.",
                                    "Adicione múltiplos except com tipos exatos: except ValidacaoErro:, except ConexaoErro:.",
                                    "Inclua um except genérico no final para exceções não esperadas.",
                                    "Use 'as e' para capturar a instância da exceção em cada bloco.",
                                    "Adicione finally para cleanup comum, como fechar arquivos."
                                  ],
                                  "verification": "Execute cenários que levantem cada exceção e verifique se o bloco correto é acionado via logs.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor Python",
                                    "Biblioteca logging (import logging)"
                                  ],
                                  "tips": "Use 'e' para acessar detalhes da exceção, como e.msg ou e.codigo.",
                                  "learningObjective": "Construir blocos try-except hierárquicos com captura precisa por tipo.",
                                  "commonMistakes": [
                                    "Esquecer 'as e' limitando acesso aos detalhes",
                                    "Não incluir finally para recursos não liberados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar tratamentos diferenciados e testar",
                                  "subSteps": [
                                    "Em cada except, implemente ações específicas: log para ValidacaoErro, retry para ConexaoErro.",
                                    "Configure logging básico com logging.error(f'Erro: {e}').",
                                    "Crie testes unitários com unittest para simular raises.",
                                    "Execute testes cobrindo todos os caminhos e verifique logs/saídas.",
                                    "Refatore para melhorar legibilidade, como funções de handler."
                                  ],
                                  "verification": "Rode suíte de testes e confirme 100% de cobertura com tratamentos corretos nos logs.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Módulo unittest (import unittest)",
                                    "Ferramenta de logging Python"
                                  ],
                                  "tips": "Use context managers (with) para auto-cleanup em vez de finally quando possível.",
                                  "learningObjective": "Integrar logging e ações customizadas baseadas em tipos de exceção.",
                                  "commonMistakes": [
                                    "Logs genéricos sem detalhes de 'e'",
                                    "Não testar caminhos raros levando a bugs ocultos"
                                  ]
                                }
                              ],
                              "practicalExample": "```python\nimport logging\n\nclass ErroValidacao(Exception):\n    def __init__(self, msg): super().__init__(msg)\n\nclass ErroConexao(Exception):\n    def __init__(self, msg): super().__init__(msg)\n\nlogging.basicConfig(level=logging.ERROR)\n\ndef funcao_riskosa(tipo):\n    if tipo == 'val': raise ErroValidacao('Dados inválidos')\n    if tipo == 'conn': raise ErroConexao('Falha na conexão')\n\ntry:\n    funcao_riskosa('val')\nexcept ErroValidacao as e:\n    logging.error(f'Validação falhou: {e}')\nexcept ErroConexao as e:\n    logging.error(f'Reconectando: {e}')\nexcept Exception as e:\n    logging.error(f'Erro inesperado: {e}')\nelse:\n    print('Sucesso')\nfinally:\n    print('Cleanup executado')\n``` Saída esperada para 'val': log de validação + cleanup.",
                              "finalVerifications": [
                                "Exceções personalizadas são levantadas e capturadas por tipo exato.",
                                "Ordem de except respeita hierarquia sem 'engolir' erros.",
                                "Logs mostram tratamentos diferenciados com detalhes da exceção.",
                                "Bloco finally executa em todos os cenários.",
                                "Testes unitários passam com cobertura total.",
                                "Código lida com exceções inesperadas sem crash."
                              ],
                              "assessmentCriteria": [
                                "Uso correto de herança e __init__ em exceções customizadas.",
                                "Blocos except com tipos exatos e ordem hierárquica precisa.",
                                "Tratamentos diferenciados acionados corretamente (ex: log específico).",
                                "Acesso à instância 'as e' para detalhes em todos os handlers.",
                                "Cobertura de testes para todos os caminhos de exceção.",
                                "Código limpo, legível e sem vazamentos de recursos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica condicional e fluxogramas de decisão.",
                                "Língua Portuguesa: Redação clara de mensagens de erro e logs.",
                                "Inglês: Leitura de documentação oficial Python sobre exceptions.",
                                "Design de Sistemas: Modelagem de erros em fluxos de software."
                              ],
                              "realWorldApplication": "Em aplicações web (ex: Flask/Django), capturar DatabaseError para retry automático vs ValidationError para feedback ao usuário; em APIs, logar autenticação falha diferentemente de erros de rede para debugging eficiente e resiliência."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.6.3.3",
                            "name": "Aplicar em cenários de aplicação real",
                            "description": "Implementar exceções personalizadas em um exemplo prático, como validação de entrada de usuário ou operações de banco de dados simuladas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o cenário prático e mapear exceções personalizadas necessárias",
                                  "subSteps": [
                                    "Escolha um cenário realista, como validação de cadastro de usuário em um sistema de login.",
                                    "Liste entradas possíveis: email, senha, idade.",
                                    "Defina exceções: InvalidEmailException, WeakPasswordException, UnderageUserException.",
                                    "Especifique condições de lançamento para cada uma.",
                                    "Desenhe um diagrama simples de herança (herda de Exception ou RuntimeException)."
                                  ],
                                  "verification": "Diagrama ou lista de exceções mapeadas e condições documentadas em um arquivo de notas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Referência à documentação de Java Exceptions"
                                  ],
                                  "tips": "Priorize exceções que herdem de RuntimeException para cenários não recuperáveis.",
                                  "learningObjective": "Mapear problemas reais a exceções customizadas de forma estruturada.",
                                  "commonMistakes": [
                                    "Ignorar herança adequada",
                                    "Definir exceções muito genéricas",
                                    "Não considerar casos edge"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar as classes de exceções personalizadas",
                                  "subSteps": [
                                    "Crie a classe InvalidEmailException estendendo Exception, com construtor que aceita mensagem.",
                                    "Implemente WeakPasswordException com método para verificar força da senha (ex: comprimento < 8).",
                                    "Crie UnderageUserException com validação de idade < 18.",
                                    "Adicione serialVersionUID e mensagens personalizadas em cada construtor.",
                                    "Teste compilação das classes isoladamente."
                                  ],
                                  "verification": "Classes compilam e instâncias podem ser criadas via código de teste simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE como IntelliJ ou Eclipse",
                                    "JDK instalado"
                                  ],
                                  "tips": "Use super(message) no construtor para herdar comportamento padrão.",
                                  "learningObjective": "Criar exceções robustas com herança e construtores apropriados.",
                                  "commonMistakes": [
                                    "Esquecer import java.lang.Exception",
                                    "Não override toString() para mensagens claras",
                                    "Construtores vazios sem mensagem"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar exceções no código do cenário prático",
                                  "subSteps": [
                                    "Crie uma classe UserValidator com método validateUser(String email, String password, int age).",
                                    "No método, use if/else para checar condições e throw respectivas exceções.",
                                    "No main ou teste, simule chamadas com dados válidos e inválidos.",
                                    "Use try-catch para capturar e imprimir stack trace ou mensagens customizadas.",
                                    "Garanta hierarquia: exceções personalizadas sobrepõem genéricas."
                                  ],
                                  "verification": "Código executa e lança exceções corretas para inputs inválidos, sem crashes inesperados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "IDE com console",
                                    "Exemplos de código de validação básica"
                                  ],
                                  "tips": "Sempre valide inputs no início do método para fail-fast.",
                                  "learningObjective": "Aplicar exceções em fluxo de código real, respeitando hierarquia.",
                                  "commonMistakes": [
                                    "Throw em locais errados",
                                    "Catch muito amplo capturando tudo",
                                    "Não logar detalhes da exceção"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, depurar e refinar o tratamento de exceções",
                                  "subSteps": [
                                    "Crie testes unitários com JUnit para cada exceção (inputs válidos/inválidos).",
                                    "Simule cenários edge: email vazio, senha nula, idade negativa.",
                                    "Adicione logs ou mensagens user-friendly no catch.",
                                    "Refatore para múltiplos níveis de try-catch se necessário.",
                                    "Documente o comportamento em comentários ou README."
                                  ],
                                  "verification": "Todos os testes passam e cobertura de exceções > 80%.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "JUnit ou framework de testes",
                                    "Ferramenta de coverage como JaCoCo"
                                  ],
                                  "tips": "Use assertThrows() no JUnit para verificar exceções específicas.",
                                  "learningObjective": "Garantir robustez através de testes e refinamento.",
                                  "commonMistakes": [
                                    "Testes insuficientes para edge cases",
                                    "Ignorar NullPointerException derivadas",
                                    "Tratamento genérico sem especificidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de cadastro de usuário: Crie UserValidator com método validateUser. Se email não contém '@', throw new InvalidEmailException('Email inválido: ' + email). Para senha < 8 chars, throw WeakPasswordException. Para idade < 18, throw UnderageUserException. No main: try { validateUser('user@ex.com', 'senha123', 20); } catch (InvalidEmailException e) { System.out.println('Erro: ' + e.getMessage()); }",
                              "finalVerifications": [
                                "Exceções personalizadas são lançadas corretamente em todos os casos testados.",
                                "Hierarquia de exceções é respeitada (custom > built-in).",
                                "Mensagens de erro são claras e informativas.",
                                "Código lida graciosamente com exceções sem crash.",
                                "Testes unitários cobrem 100% dos cenários de exceção.",
                                "Stack traces mostram origem correta nas exceções."
                              ],
                              "assessmentCriteria": [
                                "Classes de exceção herdam corretamente e têm construtores adequados (peso 20%).",
                                "Integração no código principal é fluida e usa throw/try-catch apropriados (peso 25%).",
                                "Tratamento de exceções é específico e não genérico (peso 20%).",
                                "Testes abrangentes com edge cases (peso 20%).",
                                "Código é legível, comentado e com mensagens user-friendly (peso 15%)."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Validação de inputs previne injeções SQL/XSS.",
                                "Matemática: Lógica condicional e expressões regulares para validações.",
                                "Design de Software: Princípios SOLID, especialmente Single Responsibility em exceções.",
                                "Inglês Técnico: Leitura de docs Java e stack traces.",
                                "Ética em TI: Tratamento de dados sensíveis como idade/senha."
                              ],
                              "realWorldApplication": "Em aplicações web como e-commerces (validação de carrinho), bancos (transações seguras), APIs REST (erros HTTP 400 customizados) ou apps mobile (formulários de usuário), garantindo robustez, logs auditáveis e UX melhorada sem crashes."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.8",
                "name": "UML, Padrões de Projeto e Interfaces GUI",
                "description": "Linguagem Unificada de Modelagem (UML), padrões básicos de projeto e programação de interfaces gráficas de usuário.",
                "totalSkills": 61,
                "atomicTopics": [
                  {
                    "id": "10.1.8.1",
                    "name": "Diagramas de Classes UML",
                    "description": "Representação de classes, atributos, métodos, herança, associações e multiplicidades em UML.",
                    "individualConcepts": [
                      {
                        "id": "10.1.8.1.1",
                        "name": "Representação de Classes e Seus Membros",
                        "description": "Elementos fundamentais para representar uma classe em diagramas de classes UML, incluindo os compartimentos para nome da classe, atributos e métodos, com notação de visibilidade e tipos.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.1.1.1",
                            "name": "Desenhar o retângulo de uma classe UML",
                            "description": "Criar o retângulo dividido em três compartimentos: superior para o nome da classe, médio para atributos e inferior para métodos, seguindo a notação padrão UML 2.x.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o canvas e desenhar o retângulo exterior com divisão em compartimentos",
                                  "subSteps": [
                                    "Escolha uma ferramenta: papel e lápis ou software como Draw.io ou Lucidchart.",
                                    "Desenhe um retângulo com largura aproximadamente 3 vezes a altura para acomodar listas.",
                                    "Trace duas linhas horizontais paralelas dentro do retângulo, dividindo-o em três compartimentos iguais.",
                                    "Ajuste as linhas para que fiquem retas e simétricas, separando claramente superior, médio e inferior.",
                                    "Verifique se os compartimentos têm proporções equilibradas (cerca de 1/3 cada)."
                                  ],
                                  "verification": "O retângulo possui exatamente três compartimentos horizontais visíveis e bem definidos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel sulfite",
                                    "Lápis ou caneta",
                                    "Borracha",
                                    "Software de diagramação (opcional: Draw.io)"
                                  ],
                                  "tips": "Use uma régua para linhas retas e mantenha margens internas de pelo menos 0,5 cm.",
                                  "learningObjective": "Dominar a estrutura geométrica básica do retângulo de classe UML.",
                                  "commonMistakes": [
                                    "Dividir em mais ou menos de três compartimentos",
                                    "Linhas tortas ou assimétricas",
                                    "Proporções desequilibradas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preencher o compartimento superior com o nome da classe",
                                  "subSteps": [
                                    "Escreva o nome da classe em negrito ou com fonte maior no centro do compartimento superior.",
                                    "Use notação UML: nome da classe começando com maiúscula, sem aspas.",
                                    "Centralize o texto horizontalmente e verticalmente no compartimento.",
                                    "Adicione bordas sublinhadas se for uma classe abstrata (opcional para este exercício).",
                                    "Garanta legibilidade com espaçamento adequado."
                                  ],
                                  "verification": "O nome da classe está centralizado no compartimento superior, legível e formatado corretamente.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Mesmos do step 1"
                                  ],
                                  "tips": "Teste a centralização medindo distâncias das bordas ao texto.",
                                  "learningObjective": "Aplicar a convenção de nomenclatura e posicionamento do nome da classe em UML 2.x.",
                                  "commonMistakes": [
                                    "Nome não centralizado",
                                    "Minúscula inicial",
                                    "Texto desalinhado ou ilegível"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar atributos no compartimento médio",
                                  "subSteps": [
                                    "Liste atributos um por linha: visibilidade (ex: + ou -) + nome + tipo (ex: +nome: String).",
                                    "Use símbolos de visibilidade: + público, - privado, # protegido, ~ pacote.",
                                    "Alinhe à esquerda, com indentação consistente para modificadores.",
                                    "Inclua pelo menos 2-3 atributos de exemplo relevantes à classe.",
                                    "Evite misturar com métodos; mantenha apenas atributos."
                                  ],
                                  "verification": "Compartimento médio contém atributos com notação correta de visibilidade, nome e tipo.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Mesmos do step 1"
                                  ],
                                  "tips": "Comece com visibilidade para praticar a sintaxe padrão UML.",
                                  "learningObjective": "Representar propriedades de classe com notação precisa de atributos UML.",
                                  "commonMistakes": [
                                    "Omitir visibilidade ou tipo",
                                    "Confundir com métodos",
                                    "Alinhamento irregular"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar métodos no compartimento inferior",
                                  "subSteps": [
                                    "Liste métodos um por linha: visibilidade + nome + (parâmetros): tipoRetorno (ex: +acelerar(velocidade: int): void).",
                                    "Inclua parênteses para parâmetros, mesmo se vazios; especifique tipos.",
                                    "Use símbolos de visibilidade idênticos aos atributos.",
                                    "Adicione 2-3 métodos típicos da classe.",
                                    "Separe claramente do compartimento de atributos."
                                  ],
                                  "verification": "Compartimento inferior lista métodos com sintaxe completa: visibilidade, nome, parâmetros e retorno.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Mesmos do step 1"
                                  ],
                                  "tips": "Pratique com métodos sobrecarregados para complexidade futura.",
                                  "learningObjective": "Modelar comportamentos de classe usando notação de operações UML.",
                                  "commonMistakes": [
                                    "Esquecer parênteses ou tipos de parâmetro/retorno",
                                    "Misturar ordem com atributos",
                                    "Visibilidade incorreta"
                                  ]
                                }
                              ],
                              "practicalExample": "Classe 'Carro': Superior: 'Carro'; Médio: '+cor: String', '-ano: int', '+velocidade: double'; Inferior: '+acelerar(vel: int): void', '-frear(): void', '+getVelocidade(): double'. Desenhe em papel ou Draw.io seguindo exatamente esta notação.",
                              "finalVerifications": [
                                "Retângulo dividido em exatamente três compartimentos horizontais.",
                                "Nome da classe centralizado e em negrito no topo.",
                                "Atributos no médio com visibilidade, nome e tipo corretos.",
                                "Métodos no inferior com parâmetros e retorno especificados.",
                                "Linhas retas, legível e proporcional.",
                                "Conformidade com UML 2.x (sem adornos extras)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da divisão em compartimentos (100% correto).",
                                "Correta aplicação de símbolos de visibilidade (+, -, etc.).",
                                "Sintaxe exata de atributos e métodos (tipos, parênteses).",
                                "Legibilidade e alinhamento visual.",
                                "Proporções e estética do diagrama.",
                                "Ausência de erros comuns como mistura de seções."
                              ],
                              "crossCurricularConnections": [
                                "Design Gráfico: Uso de formas retangulares e layout hierárquico.",
                                "Lógica e Matemática: Organização sequencial e divisão proporcional.",
                                "Língua Portuguesa/Inglês: Nomenclatura técnica padronizada.",
                                "Artes Visuais: Composição equilibrada e tipografia.",
                                "Física/Engenharia: Modelagem conceitual de objetos reais."
                              ],
                              "realWorldApplication": "Diagramas de classes UML são essenciais em desenvolvimento de software para planejar sistemas orientados a objetos, como apps de e-commerce ou jogos, permitindo comunicação clara entre desenvolvedores, analistas e stakeholders antes da codificação."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.1.1.2",
                            "name": "Especificar atributos em uma classe UML",
                            "description": "Listar atributos no compartimento médio com sintaxe [visibilidade] nome : tipo [= valor_padrão], como +nome: String ou -idade: int = 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes básicos de um atributo em UML",
                                  "subSteps": [
                                    "Identifique os elementos principais: visibilidade, nome, tipo, valor padrão e propriedades.",
                                    "Estude exemplos de atributos simples como +nome: String.",
                                    "Revise o compartimento médio da classe UML onde os atributos são listados.",
                                    "Diferencie atributos de operações (métodos).",
                                    "Anote definições de cada componente em suas próprias palavras."
                                  ],
                                  "verification": "Liste corretamente os 5 componentes principais de um atributo UML sem consultar materiais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação UML oficial (PDF ou site OMG)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Comece com atributos simples antes de adicionar complexidades como valores padrão.",
                                  "learningObjective": "Entender a estrutura fundamental de atributos para construção precisa.",
                                  "commonMistakes": [
                                    "Confundir atributos com métodos.",
                                    "Ignorar a ordem dos componentes na sintaxe."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar a notação de visibilidade para atributos",
                                  "subSteps": [
                                    "Memorize os símbolos: + (público), - (privado), # (protegido), ~ (de pacote).",
                                    "Pratique atribuindo visibilidade a 5 atributos fictícios.",
                                    "Analise exemplos de classes com diferentes visibilidades.",
                                    "Discuta quando usar cada tipo em cenários reais.",
                                    "Crie uma tabela comparativa das visibilidades."
                                  ],
                                  "verification": "Especifique corretamente a visibilidade para 10 atributos em uma lista aleatória.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta online de UML como draw.io ou PlantUML",
                                    "Exemplos de diagramas de classes"
                                  ],
                                  "tips": "Use + para propriedades acessíveis externamente e - para dados sensíveis.",
                                  "learningObjective": "Aplicar visibilidade corretamente para encapsulamento.",
                                  "commonMistakes": [
                                    "Usar letras minúsculas para visibilidade.",
                                    "Esquecer o símbolo de visibilidade."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Especificar nome, tipo e valor padrão em atributos",
                                  "subSteps": [
                                    "Defina regras para nomenclatura: camelCase ou snake_case, descritivo.",
                                    "Pratique tipos de dados: String, int, double, boolean, etc.",
                                    "Adicione valores padrão com '=' após o tipo, ex: -idade: int = 0.",
                                    "Inclua propriedades como {readOnly} ou {unique} entre chaves.",
                                    "Construa 8 atributos variados com esses elementos."
                                  ],
                                  "verification": "Crie atributos com nome, tipo e valor padrão sem erros de sintaxe.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto para listar atributos",
                                    "Referência de tipos de dados em linguagens como Java"
                                  ],
                                  "tips": "Sempre especifique o tipo para evitar ambiguidades.",
                                  "learningObjective": "Construir atributos completos e semanticamente corretos.",
                                  "commonMistakes": [
                                    "Omitir o tipo de dado.",
                                    "Usar aspas em valores padrão numéricos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e validar atributos em uma classe UML",
                                  "subSteps": [
                                    "Desenhe uma classe vazia e liste 5-7 atributos no compartimento médio.",
                                    "Verifique alinhamento vertical e separação por quebras de linha.",
                                    "Compare com diagramas UML padrão para validação.",
                                    "Teste exportando para imagem ou código gerado.",
                                    "Refine com base em feedback autoavaliado."
                                  ],
                                  "verification": "Gere um diagrama de classe com atributos corretos e sem erros visuais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação UML gratuita como Lucidchart ou Visual Paradigm Community"
                                  ],
                                  "tips": "Mantenha atributos ordenados logicamente (ex: identificadores primeiro).",
                                  "learningObjective": "Produzir representações UML profissionais e válidas.",
                                  "commonMistakes": [
                                    "Colocar atributos no compartimento errado.",
                                    "Ignorar multiplicidade se aplicável."
                                  ]
                                }
                              ],
                              "practicalExample": "Classe 'ContaBancaria': +numero: String {unique}; -saldo: double = 0.0; #taxaJuros: double = 0.05; -dataAbertura: Date; ~status: boolean = true.",
                              "finalVerifications": [
                                "Todos os atributos usam sintaxe correta: [visibilidade] nome : tipo [= valor].",
                                "Visibilidades são apropriadas ao contexto da classe.",
                                "Tipos de dados são precisos e consistentes.",
                                "Valores padrão são opcionais mas usados quando faz sentido.",
                                "Atributos estão listados no compartimento médio da classe.",
                                "Diagrama é legível e sem erros ortográficos."
                              ],
                              "assessmentCriteria": [
                                "Precisão da sintaxe UML (40%)",
                                "Correta aplicação de visibilidade (20%)",
                                "Diversidade e relevância dos atributos (15%)",
                                "Uso adequado de tipos e valores padrão (15%)",
                                "Clareza e organização visual (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Definição de tipos numéricos e precisão decimal.",
                                "Língua Portuguesa: Nomenclatura clara e descritiva de atributos.",
                                "Design Gráfico: Layout e legibilidade em diagramas.",
                                "Banco de Dados: Mapeamento de atributos para colunas de tabelas."
                              ],
                              "realWorldApplication": "Na modelagem de sistemas de software, como aplicativos bancários ou e-commerces, especificar atributos UML define o estado dos objetos, facilitando a geração de código, integração com bancos de dados e colaboração em equipes de desenvolvimento."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.8.1.1.3",
                            "name": "Representar métodos em uma classe UML",
                            "description": "Definir métodos no compartimento inferior com sintaxe [visibilidade] nome(parametros) : tipo_retorno, incluindo métodos abstratos com itálico ou {abstract}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura básica de um método em UML",
                                  "subSteps": [
                                    "Identifique os três compartimentos de uma classe UML: nome, atributos e métodos.",
                                    "Localize o compartimento inferior onde os métodos são representados.",
                                    "Revise exemplos simples de métodos como 'public void metodo()'."
                                  ],
                                  "verification": "Desenhe uma classe vazia com o compartimento de métodos destacado e rotulado corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor UML online (ex: Lucidchart ou Draw.io)"
                                  ],
                                  "tips": "Sempre comece visualizando a classe como uma caixa retangular dividida em três partes.",
                                  "learningObjective": "Entender onde e como métodos são posicionados em um diagrama de classes UML.",
                                  "commonMistakes": [
                                    "Colocar métodos no compartimento de atributos.",
                                    "Esquecer de separar os compartimentos com linhas horizontais."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir visibilidade e nome do método",
                                  "subSteps": [
                                    "Aprenda os símbolos de visibilidade: + (público), - (privado), # (protegido), ~ (de pacote).",
                                    "Escreva o nome do método imediatamente após a visibilidade, sem espaços.",
                                    "Pratique com exemplos: '+calcularArea()' e '-validarDados() : boolean'."
                                  ],
                                  "verification": "Crie 5 métodos com diferentes visibilidades e nomes corretos em uma classe UML.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software UML",
                                    "Folha de referência de símbolos UML"
                                  ],
                                  "tips": "Use chaves quadradas [] para visibilidade se preferir notação alternativa.",
                                  "learningObjective": "Dominar a sintaxe de visibilidade e nomeação de métodos em UML.",
                                  "commonMistakes": [
                                    "Confundir símbolos: usar + para privado.",
                                    "Adicionar espaços entre visibilidade e nome."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Especificar parâmetros e tipo de retorno",
                                  "subSteps": [
                                    "Liste parâmetros no formato: direção nome : tipo (ex: in x : int).",
                                    "Adicione o tipo de retorno após dois pontos (: tipo_retorno).",
                                    "Inclua múltiplos parâmetros separados por vírgulas, ex: '+somar(in a : int, in b : int) : int'."
                                  ],
                                  "verification": "Construa um método completo com 2 parâmetros e retorno, verificando sintaxe.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de código fonte para mapear para UML",
                                    "Editor UML"
                                  ],
                                  "tips": "Omita direção 'in' se for o padrão para parâmetros de entrada.",
                                  "learningObjective": "Representar corretamente parâmetros e retornos em métodos UML.",
                                  "commonMistakes": [
                                    "Esquecer o tipo de retorno.",
                                    "Usar parênteses errados ou vírgulas faltantes em parâmetros."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Representar métodos abstratos e modificadores especiais",
                                  "subSteps": [
                                    "Use itálico para métodos abstratos ou adicione {abstract} após a assinatura.",
                                    "Aplique modificadores como {query}, {static} entre chaves.",
                                    "Integre em uma classe com métodos concretos e abstratos."
                                  ],
                                  "verification": "Desenhe uma classe com pelo menos um método abstrato e um concreto, validando formatação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Referência UML 2.5 oficial",
                                    "Software UML"
                                  ],
                                  "tips": "Itálico é preferível para abstratos em ferramentas digitais; {abstract} para texto puro.",
                                  "learningObjective": "Diferenciar e representar métodos abstratos de concretos em UML.",
                                  "commonMistakes": [
                                    "Esquecer itálico ou {abstract} em métodos de classes abstratas.",
                                    "Colocar modificadores fora das chaves {}."
                                  ]
                                }
                              ],
                              "practicalExample": "Classe 'Calculadora': Compartimento métodos: +somar(in a: int, in b: int): int | -dividir(a: double, b: double): double {query} | calcularRaiz(valor: double): double (em itálico, abstrato).",
                              "finalVerifications": [
                                "Construir uma classe UML completa com 4 métodos variados sem erros de sintaxe.",
                                "Explicar verbalmente a função de cada símbolo usado.",
                                "Comparar diagrama com referência UML oficial.",
                                "Converter um snippet de código Java para representação UML correta.",
                                "Identificar erros em um diagrama UML fornecido."
                              ],
                              "assessmentCriteria": [
                                "Correção da sintaxe de visibilidade, parâmetros e retorno (100%).",
                                "Uso apropriado de itálico ou {abstract} para métodos abstratos.",
                                "Clareza e legibilidade do diagrama.",
                                "Inclusão de pelo menos 3 tipos diferentes de métodos.",
                                "Alinhamento com convenções UML 2.x.",
                                "Ausência de erros comuns como espaços ou símbolos trocados."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Mapeamento direto para assinaturas de métodos em linguagens OOP como Java/C++.",
                                "Matemática: Representação de funções com parâmetros e retornos.",
                                "Design Gráfico: Uso de símbolos e formatação visual em diagramas.",
                                "Lógica: Abstração de comportamentos de classes."
                              ],
                              "realWorldApplication": "Em equipes de desenvolvimento de software, diagramas UML de classes com métodos precisos facilitam a comunicação entre analistas, programadores e stakeholders, reduzindo erros na implementação de sistemas como apps bancários ou e-commerces."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.8.1.1.4",
                            "name": "Aplicar notação de visibilidade",
                            "description": "Usar símbolos + (público), - (privado), # (protegido) e ~ (de pacote) para atributos e métodos, garantindo encapsulamento visual no diagrama.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os símbolos de visibilidade em UML",
                                  "subSteps": [
                                    "Estude o símbolo '+' para visibilidade pública (acessível de qualquer lugar)",
                                    "Analise o símbolo '-' para visibilidade privada (acessível apenas dentro da classe)",
                                    "Revise o símbolo '#' para visibilidade protegida (acessível na classe e subclasses)",
                                    "Examine o símbolo '~' para visibilidade de pacote (acessível dentro do mesmo pacote)",
                                    "Compare os quatro símbolos em uma tabela de referência"
                                  ],
                                  "verification": "Crie uma tabela resumindo cada símbolo, seu significado e exemplos de uso",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Guia de referência UML (PDF ou site oficial OMG)",
                                    "Papel e caneta ou editor de diagramas como Lucidchart"
                                  ],
                                  "tips": "Use mnemônicos: '+' como 'plus todos', '-' como 'menos ninguém', '#' como 'hash herança', '~' como 'til pacote'",
                                  "learningObjective": "Dominar o significado exato de cada símbolo de visibilidade para aplicação correta",
                                  "commonMistakes": [
                                    "Confundir '#' (protegido) com '-' (privado)",
                                    "Esquecer '~' para pacote",
                                    "Achar que '+' é apenas para métodos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar visibilidade em atributos e métodos de uma classe",
                                  "subSteps": [
                                    "Leia a especificação de uma classe exemplo e identifique atributos privados (dados sensíveis)",
                                    "Classifique métodos públicos (interfaces de uso) versus privados (helpers internos)",
                                    "Marque protegidos para herança e de pacote para módulos relacionados",
                                    "Liste 5 atributos e 5 métodos de uma classe real com sua visibilidade proposta",
                                    "Justifique cada escolha com base em princípios de encapsulamento"
                                  ],
                                  "verification": "Apresente uma lista de 10 membros com justificativa de visibilidade escolhida",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo de código Java ou código fonte de biblioteca open-source",
                                    "Folha de exercício em branco"
                                  ],
                                  "tips": "Pergunte: 'Quem precisa acessar isso?' Público: todos; Privado: só a classe",
                                  "learningObjective": "Capacitar a análise de membros de classe para decisão de visibilidade",
                                  "commonMistakes": [
                                    "Tornar tudo público por simplicidade",
                                    "Ignorar herança ao usar protegido",
                                    "Confundir pacote com público"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar notação de visibilidade no diagrama de classes UML",
                                  "subSteps": [
                                    "Desenhe a caixa da classe com seções (nome, atributos, métodos)",
                                    "Posicione o símbolo de visibilidade imediatamente antes de cada atributo (ex: -nome: String)",
                                    "Adicione símbolos antes de métodos (ex: +getNome(): String)",
                                    "Ajuste para subclasses ou pacotes se aplicável",
                                    "Use ferramenta digital para renderizar o diagrama"
                                  ],
                                  "verification": "Gere um diagrama UML completo com pelo menos 3 classes e visibilidades variadas",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta UML gratuita como Draw.io ou PlantUML",
                                    "Exemplo de classe para praticar"
                                  ],
                                  "tips": "Sempre prefixe o símbolo sem espaço: +método(), não ' + método()'",
                                  "learningObjective": "Executar a notação gráfica correta para atributos e métodos",
                                  "commonMistakes": [
                                    "Colocar símbolo após o nome",
                                    "Usar texto em vez de símbolos",
                                    "Esquecer em alguns membros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e refinar o encapsulamento visual no diagrama",
                                  "subSteps": [
                                    "Revise o diagrama: públicos expostos logicamente? Privados protegidos?",
                                    "Simule acessos: pode uma subclasse ver protegidos? Um pacote ver ~?",
                                    "Corrija inconsistências e adicione notas de encapsulamento",
                                    "Compare com diagrama de referência oficial",
                                    "Teste exportando para imagem e revisando com colega"
                                  ],
                                  "verification": "Produza um diagrama final validado com checklist de encapsulamento",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagrama gerado no step 3",
                                    "Checklist de verificação UML"
                                  ],
                                  "tips": "Encapsulamento bom: minimize públicos, maximize privados/protegidos",
                                  "learningObjective": "Garantir que o diagrama reflita princípios de encapsulamento OOP",
                                  "commonMistakes": [
                                    "Expor dados privados como públicos",
                                    "Não testar cenários de herança/pacote",
                                    "Ignorar legibilidade visual"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um diagrama UML para a classe 'ContaBancaria': atributos -saldo: double, +numero: String; métodos +depositar(valor: double): void, -validarSaldo(): boolean, #herdarLimite(): double. Isso garante que saldo seja privado, numero público para identificação, e limite protegido para subclasses como ContaPremium.",
                              "finalVerifications": [
                                "Liste corretamente os 4 símbolos e seus significados sem erros",
                                "Aplique visibilidade em um diagrama com 5 atributos e 5 métodos variados",
                                "Explique como '#' afeta herança em um exemplo",
                                "Identifique erros em um diagrama UML fornecido",
                                "Gere um diagrama que demonstre encapsulamento (poucos públicos)",
                                "Diferencie '~' de '-' em contexto de pacotes"
                              ],
                              "assessmentCriteria": [
                                "Precisão na colocação dos símbolos (100% correto)",
                                "Adequação da visibilidade ao encapsulamento (lógica OOP)",
                                "Clareza visual e legibilidade do diagrama",
                                "Justificativa coerente para escolhas de visibilidade",
                                "Ausência de erros comuns como confusão de símbolos",
                                "Integração correta em diagramas com múltiplas classes"
                              ],
                              "crossCurricularConnections": [
                                "Programação OOP (Java/C#: modificadores public/private/protected)",
                                "Design de Software (princípios SOLID e encapsulamento)",
                                "Banco de Dados (visibilidade em esquemas relacionais)",
                                "Segurança da Informação (controle de acesso e permissões)",
                                "Engenharia de Software (modelagem em equipes ágeis)"
                              ],
                              "realWorldApplication": "Em projetos de software empresariais, diagramas UML com notação de visibilidade correta facilitam a comunicação em equipes, previnem acessos indevidos em APIs (ex: bibliotecas como Spring Boot) e aceleram revisões de código, reduzindo bugs de encapsulamento em sistemas bancários ou e-commerce."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.1.1.2",
                              "10.1.8.1.1.3"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.1.2",
                        "name": "Herança e Generalização",
                        "description": "Representação de relacionamentos de herança (generalização) entre classes, utilizando setas abertas para indicar hierarquia de classes.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.1.2.1",
                            "name": "Desenhar relacionamento de herança",
                            "description": "Conectar uma subclasse a uma superclasse com uma linha reta terminando em seta triangular vazia apontando para a superclasse.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e preparar as classes no diagrama",
                                  "subSteps": [
                                    "Analise o contexto do diagrama UML e identifique a superclasse (classe pai) e a subclasse (classe filha).",
                                    "Desenhe ou posicione os retângulos das classes no canvas, rotulando-os corretamente com nome da classe.",
                                    "Certifique-se de que as classes estejam visíveis e espaçadas adequadamente para evitar sobreposições.",
                                    "Verifique se a superclasse representa características gerais e a subclasse especializadas.",
                                    "Anote atributos e métodos básicos em cada classe para contextualizar a herança."
                                  ],
                                  "verification": "Classes desenhadas corretamente com rótulos visíveis e posicionadas sem sobreposição.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel milimetrado ou software de diagramação como Draw.io, Lucidchart ou papel e lápis"
                                  ],
                                  "tips": "Use cores diferentes para superclasse (azul) e subclasse (verde) para facilitar a visualização.",
                                  "learningObjective": "Compreender a relação hierárquica entre superclasse e subclasse em UML.",
                                  "commonMistakes": [
                                    "Confundir superclasse com subclasse.",
                                    "Omitir rótulos das classes.",
                                    "Posicionar classes muito próximas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Posicionar as classes e planejar a conexão",
                                  "subSteps": [
                                    "Coloque a superclasse acima ou à esquerda da subclasse para indicar direção hierárquica.",
                                    "Meça a distância aproximada entre as classes para uma linha reta limpa (cerca de 5-10 cm).",
                                    "Marque pontos de conexão: borda inferior da superclasse e borda superior da subclasse.",
                                    "Desenhe linhas guia leves para simular a trajetória da seta de herança.",
                                    "Confirme que a direção será da subclasse para a superclasse."
                                  ],
                                  "verification": "Classes posicionadas hierarquicamente com marcas de conexão visíveis.",
                                  "estimatedTime": "8 minutos",
                                  "materials": [
                                    "Régua ou ferramenta de alinhamento no software",
                                    "Borracha para ajustes"
                                  ],
                                  "tips": "Mantenha alinhamento horizontal ou vertical para simplicidade visual.",
                                  "learningObjective": "Planejar visualmente a direção e o posicionamento da herança.",
                                  "commonMistakes": [
                                    "Invertir a direção hierárquica.",
                                    "Usar curvas na linha inicial.",
                                    "Espaçamento irregular."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenhar a linha reta de conexão",
                                  "subSteps": [
                                    "Inicie a linha na borda da subclasse (próximo ao nome da classe).",
                                    "Trace uma linha reta contínua até a borda da superclasse usando régua.",
                                    "Mantenha a linha grossura uniforme (1-2 pt) e sem interrupções.",
                                    "Apague linhas guia leves após confirmar retidão.",
                                    "Teste a perpendicularidade com as bordas das classes."
                                  ],
                                  "verification": "Linha reta conecta exatamente as bordas das classes sem desvios.",
                                  "estimatedTime": "7 minutos",
                                  "materials": [
                                    "Régua ou snap-to-grid no software"
                                  ],
                                  "tips": "Zoom no software para precisão; pratique traços leves primeiro.",
                                  "learningObjective": "Executar desenho preciso de linhas retas em diagramas.",
                                  "commonMistakes": [
                                    "Linha curva ou irregular.",
                                    "Conexão fora das bordas.",
                                    "Linha muito fina ou grossa."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar a seta triangular vazia apontando para a superclasse",
                                  "subSteps": [
                                    "No final da linha (próximo à superclasse), desenhe um triângulo isósceles vazio (contorno apenas).",
                                    "A ponta do triângulo deve tocar exatamente a borda da superclasse.",
                                    "Ajuste o ângulo da seta para 30-45 graus em relação à linha para naturalidade.",
                                    "Preencha o triângulo como vazio (sem cor interna) e alinhe simetricamente.",
                                    "Verifique o apontamento: seta indica 'é um tipo de' da subclasse para superclasse."
                                  ],
                                  "verification": "Seta triangular vazia presente, apontando corretamente para superclasse.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Compasso ou ferramenta de formas no software"
                                  ],
                                  "tips": "Use 'generalization arrow' pré-definida em ferramentas UML para exatidão.",
                                  "learningObjective": "Aplicar notação padrão UML para herança (seta aberta triangular).",
                                  "commonMistakes": [
                                    "Seta cheia em vez de vazia.",
                                    "Triângulo invertido.",
                                    "Ponta desalinhada."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um diagrama de classes para sistema de transporte, conecte 'Carro' (subclasse) a 'Veiculo' (superclasse): trace linha reta da borda inferior de 'Carro' até borda superior de 'Veiculo', terminando em seta triangular vazia apontando para 'Veiculo'.",
                              "finalVerifications": [
                                "Linha é perfeitamente reta e conecta bordas das classes.",
                                "Seta é triangular, vazia e aponta exclusivamente para a superclasse.",
                                "Não há setas ou linhas adicionais interferindo.",
                                "Diagrama mantém legibilidade geral.",
                                "Direção indica herança correta (subclasse herda de superclasse).",
                                "Estilo segue convenção UML padrão."
                              ],
                              "assessmentCriteria": [
                                "Precisão geométrica da linha e seta (reta, alinhada).",
                                "Correção da notação UML (triangular vazia, direção certa).",
                                "Clareza visual e ausência de erros gráficos.",
                                "Compreensão conceitual da herança demonstrada.",
                                "Eficiência no uso de tempo e materiais.",
                                "Criatividade no exemplo contextualizado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Geometria (linhas retas, triângulos, ângulos).",
                                "Biologia: Hierarquias taxonômicas (espécies e gêneros).",
                                "Língua Portuguesa: Relações semânticas de hiperonímia.",
                                "Artes: Desenho técnico e proporções.",
                                "Filosofia: Conceitos de generalização e especialização."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software OOP, como no Java ou C++, modelar classes como 'Animal' (super) e 'Cachorro' (sub) para reutilizar código, reduzir duplicação e facilitar manutenção em sistemas empresariais como bancos ou e-commerces."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.1.1"
                            ]
                          },
                          {
                            "id": "10.1.8.1.2.2",
                            "name": "Representar classes abstratas na herança",
                            "description": "Indicar classes abstratas em itálico ou com {abstract} no nome, e métodos abstratos de forma similar na hierarquia de herança.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de classes abstratas e sua importância na herança",
                                  "subSteps": [
                                    "Defina o que é uma classe abstrata: uma classe que não pode ser instanciada diretamente e serve como base para subclasses.",
                                    "Explique a diferença entre classes concretas e abstratas, destacando que abstratas contêm métodos abstratos sem implementação.",
                                    "Identifique cenários onde classes abstratas são úteis, como em hierarquias de herança para definir interfaces comuns.",
                                    "Revise exemplos simples, como uma classe 'Animal' abstrata com método 'fazerSom()' abstrato.",
                                    "Discuta o papel na polimorfismo e reutilização de código."
                                  ],
                                  "verification": "Resuma em suas palavras o que é uma classe abstrata e dê um exemplo de uso na herança.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação UML básica",
                                    "Editor de diagramas como Lucidchart ou Draw.io"
                                  ],
                                  "tips": "Use analogias do mundo real, como 'Veículo' abstrato que não pode ser 'dirigido' sem especificar o tipo.",
                                  "learningObjective": "Entender o propósito e benefícios de classes abstratas em diagramas UML de herança.",
                                  "commonMistakes": [
                                    "Confundir classes abstratas com interfaces.",
                                    "Achar que classes abstratas podem ser instanciadas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a notação UML para representar classes abstratas",
                                  "subSteps": [
                                    "Estude a convenção principal: nome da classe em itálico.",
                                    "Aprenda a notação alternativa: adicionar {abstract} após o nome da classe.",
                                    "Pratique desenhando uma classe simples com nome 'Animal' em itálico.",
                                    "Identifique no diagrama o compartimento de nome da classe e aplique a formatação.",
                                    "Compare diagramas com e sem notação para reforçar a diferença visual."
                                  ],
                                  "verification": "Desenhe uma classe abstrata 'Forma' usando itálico e verifique se está visualmente distinta de uma classe concreta.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de desenho UML (Draw.io, PlantUML)",
                                    "Referência UML 2.5 oficial"
                                  ],
                                  "tips": "No PlantUML, use 'abstract class Nome { }' para automação da notação.",
                                  "learningObjective": "Dominar as convenções visuais UML para classes abstratas.",
                                  "commonMistakes": [
                                    "Usar itálico apenas no nome sem consistência.",
                                    "Esquecer de aplicar em toda a hierarquia."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Representar métodos abstratos dentro de classes abstratas",
                                  "subSteps": [
                                    "Aprenda a notação: nome do método em itálico ou com {abstract} após o nome.",
                                    "Liste parâmetros e tipo de retorno mantendo a formatação apenas no nome.",
                                    "Desenhe uma classe abstrata com pelo menos dois métodos abstratos, como 'calcularArea()' e 'calcularPerimetro()'.",
                                    "Diferencie métodos abstratos de métodos concretos no mesmo compartimento.",
                                    "Pratique adicionando visibilidade (public, abstract)."
                                  ],
                                  "verification": "Crie uma classe 'Veículo' abstrata com método abstrato 'acelerar()' em itálico e confirme a notação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de diagramas UML prontos",
                                    "Editor gráfico vetorial"
                                  ],
                                  "tips": "Mantenha itálico apenas no nome do método, não nos parâmetros.",
                                  "learningObjective": "Aplicar corretamente a notação para métodos abstratos em UML.",
                                  "commonMistakes": [
                                    "Aplicar itálico a toda a linha do método.",
                                    "Omitir visibilidade nos métodos abstratos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar classes abstratas em uma hierarquia de herança completa",
                                  "subSteps": [
                                    "Desenhe uma hierarquia: classe abstrata base com setas de generalização para subclasses concretas.",
                                    "Implemente herança múltipla se aplicável, mantendo notação consistente.",
                                    "Adicione métodos concretos nas subclasses que implementam os abstratos.",
                                    "Valide a diagrama: verifique setas, multiplicidades e consistência de notação.",
                                    "Exporte ou imprima o diagrama para revisão."
                                  ],
                                  "verification": "Construa um diagrama completo de 'Veículo' abstrato -> 'Carro' e 'Moto' concretas, com métodos herdados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Templates UML de herança",
                                    "Ferramentas como Visual Paradigm ou StarUML"
                                  ],
                                  "tips": "Use setas abertas com triângulo vazio para generalização.",
                                  "learningObjective": "Construir diagramas UML funcionais com herança envolvendo classes abstratas.",
                                  "commonMistakes": [
                                    "Setas erradas (usar composição em vez de herança).",
                                    "Subclasses ainda abstratas sem necessidade."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um diagrama UML para sistema de veículos: classe abstrata *Veículo* {abstract} com métodos abstratos *acelerar()* e *frear()*. Subclasses Carro e Moto herdam, implementando os métodos como concretos.",
                              "finalVerifications": [
                                "Classes abstratas estão em itálico ou com {abstract}?",
                                "Métodos abstratos usam itálico ou {abstract} corretamente?",
                                "Hierarquia de herança mostra setas de generalização adequadas?",
                                "Subclasses são concretas e implementam métodos abstratos?",
                                "Diagrama é legível e consistente em notação?",
                                "Não há instâncias diretas de classes abstratas?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação UML para classes e métodos abstratos (40%)",
                                "Correção lógica da hierarquia de herança (30%)",
                                "Clareza visual e legibilidade do diagrama (15%)",
                                "Consistência em convenções (itálico vs. {abstract}) (10%)",
                                "Uso apropriado de visibilidade e multiplicidades (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstração e generalização em conjuntos e hierarquias.",
                                "Design Gráfico: Convenções visuais e tipografia em diagramas.",
                                "Engenharia: Padrões de projeto como Template Method.",
                                "Lógica Computacional: Polimorfismo e contratos de interface."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, como no framework Java Swing, classes abstratas como AbstractButton definem comportamentos base para JButton e JToggleButton, permitindo herança personalizada em GUIs empresariais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.1.2.1",
                              "10.1.8.1.1.3"
                            ]
                          },
                          {
                            "id": "10.1.8.1.2.3",
                            "name": "Interpretar hierarquias múltiplas",
                            "description": "Modelar herança múltipla com setas de múltiplas superclasses apontando para uma subclasse, considerando limitações em linguagens como Java.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Fundamentais de Herança Múltipla",
                                  "subSteps": [
                                    "Defina herança simples: uma subclasse herda de uma única superclasse.",
                                    "Defina herança múltipla: uma subclasse herda de duas ou mais superclasses.",
                                    "Identifique o problema do 'diamante' na herança múltipla (conflitos de herança ambígua).",
                                    "Compare com herança simples em UML: uma seta de generalização.",
                                    "Discuta interfaces como solução em linguagens sem suporte nativo."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre herança simples e múltipla, incluindo um exemplo do problema do diamante.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de UML ou documentação online (ex: UML.org)",
                                    "Papel e caneta para esboços"
                                  ],
                                  "tips": [
                                    "Use analogias reais, como um carro que herda de 'Veículo' e 'Elétrico'.",
                                    "Desenhe árvores simples para visualizar."
                                  ],
                                  "learningObjective": "Compreender os conceitos teóricos de herança múltipla e suas implicações.",
                                  "commonMistakes": [
                                    "Confundir herança múltipla com composição.",
                                    "Ignorar o problema do diamante desde o início."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer a Representação em Diagramas de Classes UML",
                                  "subSteps": [
                                    "Identifique setas de generalização (triângulo vazio apontando para superclasse).",
                                    "Observe hierarquias múltiplas: múltiplas setas convergindo para uma subclasse.",
                                    "Pratique lendo diagramas: trace herança de uma classe para suas superclasses.",
                                    "Anote multiplicidade e visibilidade nas setas.",
                                    "Diferencie de agregação/composição (setas abertas/rombo)."
                                  ],
                                  "verification": "Desenhe um diagrama UML simples com herança múltipla e label as setas corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta UML online (ex: Lucidchart, Draw.io)",
                                    "Exemplos de diagramas UML impressos"
                                  ],
                                  "tips": [
                                    "Comece com setas grossas para superclasses diretas.",
                                    "Verifique direção das setas: subclasse aponta para superclasse."
                                  ],
                                  "learningObjective": "Identificar visualmente hierarquias múltiplas em diagramas UML.",
                                  "commonMistakes": [
                                    "Invertendo direção das setas.",
                                    "Confundindo generalização com dependência."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar Hierarquias Múltiplas em Contextos Práticos",
                                  "subSteps": [
                                    "Analise um diagrama exemplo: subclasse 'AnfíbioVoador' herda de 'Mamífero' e 'Voador'.",
                                    "Trace caminhos de herança e identifique métodos herdados.",
                                    "Resolva ambiguidades: priorize ou use interfaces.",
                                    "Simule implementação em pseudocódigo.",
                                    "Questione: 'Essa subclasse acessa atributos de ambas superclasses?'"
                                  ],
                                  "verification": "Interprete um diagrama fornecido, listando todos os ancestrais e potenciais conflitos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagramas UML de exemplo (Bat herdando Mammal e Flyer)",
                                    "Pseudocódigo editor (ex: Notepad++)"
                                  ],
                                  "tips": [
                                    "Liste superclasses em uma tabela para rastrear herança.",
                                    "Pense em 'é-um' relacionamento para validar."
                                  ],
                                  "learningObjective": "Analisar e interpretar fluxos de herança em diagramas complexos.",
                                  "commonMistakes": [
                                    "Ignorar herança indireta.",
                                    "Assumir herança sem verificar setas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Considerar Limitações em Linguagens como Java e Alternativas",
                                  "subSteps": [
                                    "Explique por que Java não suporta herança múltipla de classes (problema do diamante).",
                                    "Aprenda a usar interfaces para simular herança múltipla.",
                                    "Compare com C++ que suporta nativamente.",
                                    "Converta um diagrama UML múltiplo para código Java válido.",
                                    "Discuta trade-offs: flexibilidade vs complexidade."
                                  ],
                                  "verification": "Converta um diagrama de herança múltipla em código Java usando interfaces e execute sem erros.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "IDE Java (ex: IntelliJ, Eclipse)",
                                    "Documentação Java Interfaces"
                                  ],
                                  "tips": [
                                    "Use 'implements' para múltiplas interfaces.",
                                    "Teste com compilação para validar."
                                  ],
                                  "learningObjective": "Aplicar conhecimentos considerando restrições reais de implementação.",
                                  "commonMistakes": [
                                    "Tentar estender múltiplas classes em Java.",
                                    "Esquecer 'default' methods em interfaces."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de zoo, crie um diagrama UML onde 'Morcego' herda de 'Mamífero' (atributos: amamenta, viveEmTerra) e 'Voador' (atributos: asas, voa). Interprete: Morcego amamenta E voa. Em Java: class Morcego extends Mamifero implements Voador.",
                              "finalVerifications": [
                                "Desenhar corretamente um diagrama UML com 3 superclasses convergindo.",
                                "Identificar e explicar um conflito de herança em um diagrama dado.",
                                "Converter diagrama múltiplo para código Java sem erros de compilação.",
                                "Explicar problema do diamante com exemplo.",
                                "Listar 3 linguagens que suportam herança múltipla nativa.",
                                "Interpretar herança em um diagrama complexo sem ambiguidades."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de setas de generalização múltiplas (90%+).",
                                "Correta resolução de ambiguidades e limitações linguísticas.",
                                "Qualidade dos diagramas desenhados (clareza, notação UML padrão).",
                                "Profundidade na interpretação de herança (caminhos completos).",
                                "Criatividade em exemplos práticos e conversões para código.",
                                "Compreensão de trade-offs (ex: interfaces vs classes abstratas)."
                              ],
                              "crossCurricularConnections": [
                                "Biologia: Hierarquias taxonômicas (ex: classes animais com traços múltiplos).",
                                "Matemática: Teoria de grafos (árvores de herança como DAGs direcionados).",
                                "Filosofia: Relações ontológicas 'é-um' vs 'tem-um'.",
                                "Design de Sistemas: Padrões como Mixins em frameworks web."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, modelar entidades complexas como 'VeículoElétricoHíbrido' herdando de 'Veículo' e 'Elétrico' em diagramas UML para jogos ou apps de simulação, usando interfaces em Java para evitar conflitos e promover código reutilizável em equipes ágeis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.1.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.1.3",
                        "name": "Associações e Multiplicidades",
                        "description": "Representação de relacionamentos entre classes, incluindo associações simples, agregação, composição e especificação de multiplicidades.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.1.3.1",
                            "name": "Desenhar associações entre classes",
                            "description": "Conectar classes com linhas sólidas, adicionando nomes de papéis, navegabilidade com setas e rótulos nos extremos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar classes e preparar o diagrama",
                                  "subSteps": [
                                    "Liste as classes envolvidas no relacionamento (ex: 'Carro' e 'Motor').",
                                    "Desenhe os retângulos das classes com atributos e métodos básicos.",
                                    "Posicione as classes logicamente no canvas para evitar cruzamentos de linhas.",
                                    "Revise o contexto do relacionamento (ex: um carro tem um motor).",
                                    "Anote multiplicidades pretendidas nos extremos (ex: 1..1 para motor)."
                                  ],
                                  "verification": "Classes desenhadas corretamente posicionadas com anotações iniciais de multiplicidades.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação (draw.io, Lucidchart ou papel/lápis)",
                                    "Referência UML básica"
                                  ],
                                  "tips": "Posicione classes próximas se o relacionamento for forte para melhorar legibilidade.",
                                  "learningObjective": "Compreender a importância da preparação para associações claras em UML.",
                                  "commonMistakes": [
                                    "Posicionar classes aleatoriamente levando a linhas cruzadas.",
                                    "Esquecer de anotar multiplicidades iniciais."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenhar a linha de associação básica",
                                  "subSteps": [
                                    "Conecte os retângulos das classes com uma linha reta sólida.",
                                    "Garanta que a linha não cruze outras elementos do diagrama.",
                                    "Ajuste a linha para ser perpendicular aos lados das classes.",
                                    "Confirme que a linha é sólida (não tracejada ou pontilhada).",
                                    "Teste movendo classes para validar flexibilidade da conexão."
                                  ],
                                  "verification": "Linha sólida conecta exatamente as duas classes sem interrupções.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação ativa"
                                  ],
                                  "tips": "Use snap-to-grid na ferramenta para alinhamento preciso.",
                                  "learningObjective": "Dominar o traçado básico de associações em diagramas de classes UML.",
                                  "commonMistakes": [
                                    "Usar linha tracejada (que indica dependência).",
                                    "Linhas curvas desnecessárias."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar multiplicidades e rótulos nos extremos",
                                  "subSteps": [
                                    "No extremo de cada classe, adicione multiplicidade (ex: 1..1, 0..*).",
                                    "Coloque rótulos descritivos perto dos extremos (ex: 'possui').",
                                    "Alinhe multiplicidades próximas ao final da linha.",
                                    "Valide semântica: multiplicidade reflete cardinalidade real do relacionamento.",
                                    "Ajuste fonte e tamanho para legibilidade."
                                  ],
                                  "verification": "Multiplicidades e rótulos visíveis e semanticamente corretos em ambos os extremos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Referência de notação UML para multiplicidades"
                                  ],
                                  "tips": "Use '*' para 'muitos' e especifique bounds como 0..1 para opcionais.",
                                  "learningObjective": "Aplicar corretamente multiplicidades e rótulos para expressar cardinalidade.",
                                  "commonMistakes": [
                                    "Confundir multiplicidade com tipo de linha.",
                                    "Rótulos ambíguos ou ausentes."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar nomes de papéis e navegabilidade",
                                  "subSteps": [
                                    "Adicione nomes de papéis nos extremos (ex: 'motor' perto de Carro).",
                                    "Determine direção de navegabilidade baseada no design (ex: Carro conhece Motor).",
                                    "Desenhe seta aberta no extremo navegável (triângulo vazio).",
                                    "Sem seta indica bidirecional; seta em um lado indica unidirecional.",
                                    "Revise e ajuste posições para evitar sobreposições."
                                  ],
                                  "verification": "Nomes de papéis presentes e setas de navegabilidade corretas conforme especificação.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Referência UML para associações avançadas"
                                  ],
                                  "tips": "Nomes de papéis em itálico ou minúscula para distinção.",
                                  "learningObjective": "Incorporar papéis e navegabilidade para modelar dependências direcionais.",
                                  "commonMistakes": [
                                    "Setas cheias (para herança).",
                                    "Papéis duplicados ou inexistentes."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Revisar e refinar o diagrama completo",
                                  "subSteps": [
                                    "Verifique todos elementos: linha sólida, multiplicidades, rótulos, papéis, setas.",
                                    "Teste legibilidade imprimindo ou exportando o diagrama.",
                                    "Simule explicação: descreva o relacionamento verbalmente.",
                                    "Ajuste espaçamentos e alinhamentos finais.",
                                    "Salve versão final com legenda se necessário."
                                  ],
                                  "verification": "Diagrama completo atende a todos os critérios UML para associações.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação",
                                    "Checklist UML"
                                  ],
                                  "tips": "Peça feedback de um par para validação externa.",
                                  "learningObjective": "Garantir qualidade e conformidade do diagrama final.",
                                  "commonMistakes": [
                                    "Ignorar revisão levando a erros sutis.",
                                    "Sobrecarregar o diagrama com texto excessivo."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de gerenciamento de frota, associe 'Carro' a 'Motor': linha sólida conectando os retângulos, multiplicidade '1..1' no lado Carro e '1..*' no lado Motor (um motor em múltiplos carros? Não: ajuste para 1..1 ambos), role 'motor' no extremo Carro, seta de navegabilidade de Carro → Motor, rótulo 'equipado com' no extremo Motor.",
                              "finalVerifications": [
                                "Linha de associação é sólida e conecta corretamente as classes.",
                                "Multiplicidades estão presentes e corretas em ambos os extremos.",
                                "Nomes de papéis são claros e posicionados adequadamente.",
                                "Setas de navegabilidade refletem a direção pretendida.",
                                "Rótulos nos extremos melhoram a compreensão semântica.",
                                "Diagrama é legível sem cruzamentos ou sobreposições."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação UML (100% conformidade).",
                                "Clareza visual e layout profissional.",
                                "Correção semântica das multiplicidades e navegabilidade.",
                                "Uso efetivo de rótulos e papéis para comunicação.",
                                "Ausência de erros comuns como linhas erradas.",
                                "Capacidade de explicar o relacionamento verbalmente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Multiplicidades como cardinalidades em conjuntos e relações.",
                                "Língua Portuguesa: Nomenclatura precisa em papéis e rótulos.",
                                "Design Gráfico: Princípios de layout e hierarquia visual.",
                                "Banco de Dados: Relacionamentos semelhantes a chaves estrangeiras."
                              ],
                              "realWorldApplication": "Diagramas de classes UML com associações são essenciais no design de software orientado a objetos, como em sistemas empresariais (ERP), onde modelam relacionamentos entre entidades como 'Cliente' e 'Pedido', guiando implementação de código, geração de bancos de dados e comunicação em equipes de desenvolvimento."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.1.1"
                            ]
                          },
                          {
                            "id": "10.1.8.1.3.2",
                            "name": "Especificar multiplicidades",
                            "description": "Anotar extremidades de associações com valores como 1, 0..1, *, 1..* ou intervalos exatos, indicando quantas instâncias podem se relacionar.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Multiplicidade em UML",
                                  "subSteps": [
                                    "Defina multiplicidade como a indicação do número de instâncias permitidas em cada extremidade de uma associação.",
                                    "Estude os tipos básicos: '1' (exatamente uma), '0..1' (zero ou uma), '*' ou '0..*' (zero ou mais), '1..*' (uma ou mais).",
                                    "Analise exemplos simples de associações unidirecionais e bidirecionais.",
                                    "Diferencie multiplicidade de outros elementos como agregação ou composição.",
                                    "Revise a notação UML oficial para extremidades de associações."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os quatro tipos principais de multiplicidade com exemplos corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação UML oficial (seção de associações)",
                                    "Diagrama de classes exemplo simples"
                                  ],
                                  "tips": "Use diagramas visuais para memorizar; associe cada notação a cenários reais como 'um usuário tem zero ou mais posts'.",
                                  "learningObjective": "Identificar e definir corretamente os tipos fundamentais de multiplicidade em associações UML.",
                                  "commonMistakes": [
                                    "Confundir multiplicidade com cardinalidade de banco de dados.",
                                    "Ignorar a direção da associação ao aplicar multiplicidades.",
                                    "Usar '*' sem especificar o limite inferior."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Extremidades de Associações em Diagramas UML",
                                  "subSteps": [
                                    "Localize associações em um diagrama de classes existente (linhas conectando classes).",
                                    "Identifique as duas extremidades de cada associação: origem e destino.",
                                    "Marque cada extremidade com um retângulo pequeno para multiplicidade.",
                                    "Analise requisitos do domínio para determinar o número de instâncias possíveis em cada extremidade.",
                                    "Pratique em pelo menos três associações diferentes."
                                  ],
                                  "verification": "Anote corretamente as extremidades vazias em um diagrama fornecido, sem erros de identificação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de modelagem UML como Lucidchart ou Draw.io",
                                    "Diagrama de classes de exemplo com associações sem multiplicidades"
                                  ],
                                  "tips": "Sempre leia os requisitos do negócio primeiro para guiar a identificação.",
                                  "learningObjective": "Localizar e preparar extremidades de associações para especificação de multiplicidades.",
                                  "commonMistakes": [
                                    "Confundir associações com herança ou dependências.",
                                    "Esquecer de considerar ambas as extremidades.",
                                    "Aplicar multiplicidade sem contexto de requisitos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Especificar Multiplicidades Baseadas em Requisitos do Domínio",
                                  "subSteps": [
                                    "Para cada extremidade, pergunte: 'Quantas instâncias da classe B podem se relacionar com uma instância da classe A?'",
                                    "Escolha a notação apropriada: exato (1), opcional (0..1), ilimitado (*), mínimo um (1..*).",
                                    "Aplique em um diagrama: Cliente (1) -- (0..*) Pedidos.",
                                    "Teste cenários: 'Pode um cliente ter zero pedidos? Sim → 0..*'.",
                                    "Documente a justificativa para cada escolha."
                                  ],
                                  "verification": "Crie multiplicidades para 5 associações em um diagrama, justificando cada uma corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Requisitos de caso de uso simples",
                                    "Ferramenta UML",
                                    "Folha de justificativas"
                                  ],
                                  "tips": "Use intervalos exatos quando possível para maior precisão, como 1..10 para limites reais.",
                                  "learningObjective": "Aplicar notações de multiplicidade de forma precisa com base em cenários de negócio.",
                                  "commonMistakes": [
                                    "Usar sempre '*' por padrão.",
                                    "Inverter extremidades.",
                                    "Ignorar restrições de integridade referencial."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Refinar Multiplicidades no Diagrama Completo",
                                  "subSteps": [
                                    "Revise todas as multiplicidades quanto a consistência lógica (ex: se A tem 1 B, B deve refletir isso).",
                                    "Simule instâncias: crie 3-5 objetos e verifique se atendem as multiplicidades.",
                                    "Consulte padrões UML para casos avançados como intervalos personalizados (2..5).",
                                    "Peça feedback ou compare com diagramas profissionais.",
                                    "Atualize o diagrama final e exporte."
                                  ],
                                  "verification": "Diagrama validado sem inconsistências lógicas, comprovado por simulação de instâncias.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama completo editado",
                                    "Lista de verificação UML"
                                  ],
                                  "tips": "Ferramentas como PlantUML podem validar sintaxe automaticamente.",
                                  "learningObjective": "Garantir que multiplicidades sejam consistentes e realistas em um diagrama inteiro.",
                                  "commonMistakes": [
                                    "Deixar multiplicidades inconsistentes entre extremidades.",
                                    "Não testar com cenários edge-case (zero, máximo).",
                                    "Esquecer de documentar mudanças."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema bancário: Classe 'Banco' associada a 'Conta'. Multiplicidade: Banco (1) -- (1..*) Conta (uma conta pertence a exatamente um banco, um banco tem pelo menos uma conta). Simule: Crie BancoX com 3 contas; tente criar conta sem banco (inválido).",
                              "finalVerifications": [
                                "Lista corretamente 6+ notações de multiplicidade com exemplos.",
                                "Especifica multiplicidades em um diagrama de 4 classes sem erros.",
                                "Justifica escolhas baseadas em requisitos de negócio.",
                                "Valida consistência entre extremidades opostas.",
                                "Simula instâncias que atendem/não atendem as regras.",
                                "Identifica e corrige erros comuns em diagramas fornecidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação UML (100% correto).",
                                "Justificativas lógicas e alinhadas a requisitos (claras e concisas).",
                                "Consistência em ambas extremidades de associações.",
                                "Uso variado de tipos de multiplicidade (não só '*').",
                                "Ausência de erros comuns como inversão ou inconsistências.",
                                "Capacidade de simular e validar cenários reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos e cardinalidade.",
                                "Banco de Dados: Relacionamentos e chaves estrangeiras.",
                                "Lógica: Condições booleanas para validação de regras.",
                                "Análise de Requisitos: Modelagem de negócios.",
                                "Programação: Implementação de associações em código OO."
                              ],
                              "realWorldApplication": "No design de software empresarial, como ERPs, especificar multiplicidades garante integridade de dados em bancos relacionais (ex: um 'Funcionário' tem 0..1 'Gerente', evitando orphans); essencial em equipes ágeis para comunicação clara de regras de negócio via UML."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.8.1.3.3",
                            "name": "Representar agregação e composição",
                            "description": "Usar losango vazio para agregação (parte-todo fraco) e losango preenchido para composição (parte-todo forte, ciclo de vida ligado).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos de Agregação e Composição",
                                  "subSteps": [
                                    "Defina agregação como uma relação parte-todo fraca, onde as partes podem existir independentemente do todo.",
                                    "Defina composição como uma relação parte-todo forte, onde o ciclo de vida das partes está ligado ao todo (partes são destruídas quando o todo é).",
                                    "Compare com associação simples: agregação/composição são especializações com conotação de 'parte-todo'.",
                                    "Estude exemplos: uma equipe (agregação de jogadores) vs. um carro e seu motor (composição).",
                                    "Crie um mapa mental destacando diferenças chave como independência e ciclo de vida."
                                  ],
                                  "verification": "Produza um quadro comparativo com pelo menos 4 diferenças entre agregação, composição e associação simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta digital como Draw.io",
                                    "Documentação UML oficial (UML 2.5 spec)"
                                  ],
                                  "tips": "Use analogias cotidianas para visualizar: 'aluguel de carro' (agregação) vs. 'corpo humano' (composição).",
                                  "learningObjective": "Diferenciar conceitualmente agregação e composição de outros relacionamentos UML.",
                                  "commonMistakes": [
                                    "Confundir com herança (que é 'é-um'),",
                                    "Ignorar o ciclo de vida na composição.",
                                    "Misturar com dependência."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar e Praticar a Notação Visual UML",
                                  "subSteps": [
                                    "Identifique o losango vazio (diamante aberto) como símbolo para agregação.",
                                    "Identifique o losango preenchido (diamante cheio) como símbolo para composição.",
                                    "Aprenda posicionamento: o losango fica no lado da classe 'todo', conectado à classe 'parte'.",
                                    "Desenhe os símbolos isolados 10 vezes cada, rotulando-os corretamente.",
                                    "Compare desenhos lado a lado em um papel, adicionando setas e nomes de classes fictícias."
                                  ],
                                  "verification": "Desenhe ambos os símbolos corretamente em um diagrama de teste com classes exemplo, sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado e marcadores",
                                    "Ferramenta online como Lucidchart ou PlantUML"
                                  ],
                                  "tips": "Pratique com tamanhos consistentes para evitar erros de proporção no diagrama final.",
                                  "learningObjective": "Reproduzir com precisão os símbolos UML para agregação e composição.",
                                  "commonMistakes": [
                                    "Desenhar losango no lado errado (deve ser no 'todo').",
                                    "Confundir preenchido com herança (triângulo).",
                                    "Esquecer multiplicidades nas extremidades."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Agregação em um Diagrama de Classes Simples",
                                  "subSteps": [
                                    "Escolha classes exemplo: Biblioteca (todo) e Livro (parte).",
                                    "Desenhe classe Biblioteca e Livro.",
                                    "Adicione losango vazio na Biblioteca, conectando a Livro com linha.",
                                    "Inclua multiplicidades: 1 Biblioteca para * Livros.",
                                    "Adicione atributos básicos e valide independência (Livros podem existir sem Biblioteca)."
                                  ],
                                  "verification": "Crie e rotule um diagrama completo de agregação, explicando verbalmente por que é agregação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação UML (Draw.io ou Visual Paradigm)",
                                    "Referências de exemplos UML"
                                  ],
                                  "tips": "Sempre valide: 'As partes sobrevivem sem o todo?' Se sim, é agregação.",
                                  "learningObjective": "Construir um diagrama UML representando corretamente agregação com notação e multiplicidades.",
                                  "commonMistakes": [
                                    "Usar losango preenchido por engano.",
                                    "Omitir multiplicidades, perdendo clareza.",
                                    "Colocar losango na classe parte."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Composição e Integrar em Diagrama Completo",
                                  "subSteps": [
                                    "Escolha exemplo: Casa (todo) e Quarto (parte).",
                                    "Desenhe classes Casa e Quarto.",
                                    "Adicione losango preenchido na Casa, conectando a Quarto.",
                                    "Defina multiplicidades: 1 Casa para 3..5 Quartos.",
                                    "Combine com agregação anterior em um diagrama misto e valide ciclo de vida."
                                  ],
                                  "verification": "Produza um diagrama misto (agregação + composição) com explicação das escolhas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Mesma ferramenta de diagramação",
                                    "Exemplos de diagramas UML prontos para referência"
                                  ],
                                  "tips": "Teste mentalmente: 'Se o todo morre, as partes morrem?' Para composição, sim.",
                                  "learningObjective": "Integrar agregação e composição em diagramas complexos, validando conceitos.",
                                  "commonMistakes": [
                                    "Reutilizar losango vazio para composição.",
                                    "Ignorar forte ligação de ciclo de vida na explicação.",
                                    "Exagerar multiplicidades sem justificativa."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de gerenciamento de frota veicular: a classe 'Frota' agrega 'Veículos' (losango vazio, veículos podem ser transferidos para outra frota). Já a classe 'Veículo' compõe 'Rodas' (losango preenchido, rodas são destruídas/desmontadas se o veículo for). Desenhe o diagrama com multiplicidades 1..* para Veículos e 4 para Rodas.",
                              "finalVerifications": [
                                "Distingue corretamente losango vazio (agregação) de preenchido (composição).",
                                "Explica o ciclo de vida: partes independentes em agregação vs. dependentes em composição.",
                                "Desenha diagramas com losango posicionado no lado do 'todo'.",
                                "Inclui multiplicidades apropriadas em ambos os relacionamentos.",
                                "Valida exemplos reais sem confundir com associação ou herança.",
                                "Produz diagrama misto sem erros de notação.",
                                "Justifica escolhas conceituais em linguagem clara."
                              ],
                              "assessmentCriteria": [
                                "Precisão da notação: losango vazio/preenchido correto (100%).",
                                "Posicionamento e conexão adequados no diagrama.",
                                "Uso correto de multiplicidades (ex: 1 para todo, * para partes).",
                                "Explicação conceitual completa, incluindo ciclo de vida.",
                                "Ausência de confusões com herança, dependência ou associação simples.",
                                "Clareza e legibilidade do diagrama final.",
                                "Aplicação coerente em exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Relações hierárquicas em teoria de conjuntos (subconjuntos independentes vs. exclusivos).",
                                "Biologia: Composição em estruturas orgânicas (células em tecidos) vs. agregação em ecossistemas.",
                                "Administração: Agregação de departamentos em empresas vs. composição de equipes fixas.",
                                "Física: Componentes em sistemas mecânicos (partes agregadas vs. integradas permanentemente).",
                                "Artes: Composição em designs gráficos (elementos fixos) vs. agregação em coleções."
                              ],
                              "realWorldApplication": "No desenvolvimento de software orientado a objetos, como em sistemas ERP, modela relacionamentos como 'Empresa agrega Funcionários' (agregação, funcionários podem mudar de empresa) ou 'Pedido compõe Itens' (composição, itens inexistem sem pedido), garantindo designs robustos, reutilizáveis e fáceis de manter em aplicações como e-commerce ou jogos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.1.3.1",
                              "10.1.8.1.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.8.2",
                    "name": "Diagramas de Sequência UML",
                    "description": "Modelagem de interações dinâmicas entre objetos, mensagens e fluxos de controle.",
                    "individualConcepts": [
                      {
                        "id": "10.1.8.2.1",
                        "name": "Componentes Básicos dos Diagramas de Sequência",
                        "description": "Elementos fundamentais que representam objetos, instâncias e suas interações temporais em diagramas de sequência UML, incluindo lifelines e cabeçalhos de objetos.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.2.1.1",
                            "name": "Identificar e representar Lifelines",
                            "description": "Reconhecer e desenhar lifelines como retas verticais que representam a linha de vida de um objeto ou ator ao longo do tempo, indicando sua existência e destruição no diagrama.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Lifeline",
                                  "subSteps": [
                                    "Leia a definição oficial de Lifeline na especificação UML: retas verticais que representam a existência temporal de um ator ou objeto.",
                                    "Estude exemplos visuais de Lifelines em diagramas de sequência, notando a cabeça (nome do objeto) e o corpo tracejado.",
                                    "Identifique os símbolos: caixa na parte superior para o nome (ex: :Cliente) e linha tracejada vertical descendente.",
                                    "Diferencie Lifeline de outros elementos como mensagens ou frames.",
                                    "Anote as propriedades: indica criação (topo) e destruição (X no final)."
                                  ],
                                  "verification": "Resuma em suas palavras o que é uma Lifeline e desenhe um esboço simples sem olhar referências.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação UML oficial (PDF ou site OMG)",
                                    "Papel e caneta",
                                    "Acesso a exemplos online de diagramas UML"
                                  ],
                                  "tips": "Use analogia: imagine a Lifeline como a 'biografia vertical' de um objeto no tempo.",
                                  "learningObjective": "Definir precisamente o que é uma Lifeline e suas características principais.",
                                  "commonMistakes": [
                                    "Confundir com linhas de mensagem (que são horizontais)",
                                    "Esquecer a notação tracejada",
                                    "Omitir o nome do objeto na cabeça"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Lifelines em Diagramas Existentes",
                                  "subSteps": [
                                    "Abra 3-5 diagramas de sequência UML de exemplos reais (ex: login system, ATM).",
                                    "Marque todas as Lifelines com um highlighter, anotando o nome do ator/objeto.",
                                    "Verifique se cada Lifeline inicia no topo (criação implícita) e continua verticalmente.",
                                    "Identifique pontos de destruição (X) e anote quando ocorrem.",
                                    "Compare com a legenda do diagrama para validar sua identificação."
                                  ],
                                  "verification": "Liste corretamente todas as Lifelines de um diagrama fornecido, com nomes e durações aproximadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de diagramas UML (impressos ou digitais)",
                                    "Marcadores ou software de anotação como Draw.io"
                                  ],
                                  "tips": "Procure sempre pela caixa superior nomeada – é o ponto de partida infalível.",
                                  "learningObjective": "Reconhecer Lifelines em contextos reais de diagramas de sequência.",
                                  "commonMistakes": [
                                    "Ignorar Lifelines de atores vs. objetos",
                                    "Confundir com retas de ativação (finas e retas sólidas)",
                                    "Não notar destruições"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenhar Lifelines Básicas",
                                  "subSteps": [
                                    "Crie uma nova Lifeline para um ator simples (ex: :Usuário) com nome na caixa superior.",
                                    "Desenhe a linha tracejada vertical de comprimento médio (representando tempo).",
                                    "Adicione pelo menos duas outras Lifelines paralelas para simular um diagrama.",
                                    "Use notação correta: texto em itálico para objetos, underline para instâncias.",
                                    "Teste alinhamento vertical perfeito entre Lifelines."
                                  ],
                                  "verification": "Seu desenho deve ter Lifelines paralelas, nomeadas corretamente e tracejadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado ou software UML (PlantUML, Lucidchart)",
                                    "Referência visual de Lifelines"
                                  ],
                                  "tips": "Mantenha linhas perfeitamente verticais usando régua ou grid no software.",
                                  "learningObjective": "Produzir Lifelines visualmente corretas em um diagrama básico.",
                                  "commonMistakes": [
                                    "Linhas sólidas em vez de tracejadas",
                                    "Nomes sem dois-pontos (:Objeto)",
                                    "Alinhamento irregular"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Representar Criação e Destruição em Lifelines",
                                  "subSteps": [
                                    "Adicione um ponto de criação (seta para cima ou início no topo) em uma Lifeline.",
                                    "Desenhe um 'X' no final de uma Lifeline para indicar destruição.",
                                    "Integre em um diagrama com mensagens entre Lifelines, marcando lifespan.",
                                    "Valide contra regras UML: destruição só após mensagens recebidas.",
                                    "Crie variação: Lifeline infinita (sem X) para objetos persistentes."
                                  ],
                                  "verification": "Desenhe um diagrama com pelo menos uma criação e uma destruição corretas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software UML para edição",
                                    "Exemplos avançados de diagramas"
                                  ],
                                  "tips": "Use 'X' pequeno e centralizado no final da linha para destruição.",
                                  "learningObjective": "Incorporar lifespan completo (criação a destruição) em Lifelines.",
                                  "commonMistakes": [
                                    "Colocar X antes de mensagens",
                                    "Esquecer tracejado na linha inteira",
                                    "Criação sem seta apropriada"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um diagrama de login: Lifeline ':Usuário' (ator, linha longa sem X), ':Servidor' (objeto criado por new(), destruído com X após logout), ':BancoDados' (persistente, linha infinita). Mensagens como login() fluem horizontalmente entre elas.",
                              "finalVerifications": [
                                "Desenhar uma Lifeline completa com nome, tracejado e alinhamento correto.",
                                "Identificar todas as Lifelines em um diagrama fornecido sem erros.",
                                "Explicar diferença entre lifeline de ator e objeto.",
                                "Representar destruição com 'X' em contexto apropriado.",
                                "Validar um diagrama peer-reviewado por precisão UML.",
                                "Gerar código PlantUML para Lifelines básicas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação (tracejado, nomes com :, X para destruição): 30%",
                                "Alinhamento e proporções visuais corretas: 20%",
                                "Compreensão conceitual demonstrada em explicações: 20%",
                                "Integração com outros elementos (mensagens): 15%",
                                "Criatividade em exemplos práticos: 10%",
                                "Ausência de erros comuns: 5%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação de eixos temporais (linhas cartesianas verticais).",
                                "Design Gráfico: Uso de linhas tracejadas e alinhamento em wireframes.",
                                "Lógica e Programação: Modelagem de estados de objetos em tempo.",
                                "História da Computação: Evolução de notações UML desde Booch/OMT."
                              ],
                              "realWorldApplication": "Em equipes de desenvolvimento de software, Lifelines em diagramas UML de sequência ajudam a visualizar fluxos de interações em apps como e-commerce (ex: carrinho de compras), prevendo problemas de concorrência e otimizando código orientado a objetos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.1.2",
                            "name": "Representar Objetos e Instâncias nos Cabeçalhos",
                            "description": "Construir cabeçalhos de lifelines com notação [instância]:Classe para objetos anônimos ou nome[instância]:Classe para instâncias específicas, diferenciando atores e objetos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Notação Básica para Objetos Anônimos",
                                  "subSteps": [
                                    "Estude a sintaxe [instância]:Classe para representar objetos anônimos em lifelines.",
                                    "Identifique que colchetes [] indicam anonimato, sem nome específico.",
                                    "Revise exemplos em diagramas UML onde objetos genéricos são usados.",
                                    "Pratique desenhando um lifeline simples com :Classe apenas.",
                                    "Compare com notações inválidas para reforçar o padrão."
                                  ],
                                  "verification": "Desenhe um lifeline com [obj1]:Carro e confirme que segue a sintaxe UML padrão consultando uma referência UML.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou ferramenta UML como Lucidchart/PlantUML; referência UML Sequence Diagram.",
                                  "tips": "Sempre use colchetes para anonimato; evite nomes sem colchetes em objetos anônimos.",
                                  "learningObjective": "Dominar a representação de objetos genéricos sem identidade nomeada.",
                                  "commonMistakes": "Usar nome:Classe sem colchetes para anônimos; esquecer os dois pontos (:)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Notação para Instâncias Específicas",
                                  "subSteps": [
                                    "Aprenda a sintaxe nome[instância]:Classe para objetos nomeados.",
                                    "Escolha um nome descritivo como 'user' ou 'dbConnection'.",
                                    "Desenhe lifelines com exemplos: alice[1]:User, server[2]:Server.",
                                    "Diferencie instância (número ou string) do nome do objeto.",
                                    "Valide múltiplas instâncias da mesma classe no mesmo diagrama."
                                  ],
                                  "verification": "Crie dois lifelines nomeados corretamente e verifique se a notação permite rastrear instâncias únicas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramenta de diagramação UML; exemplos de código OOP para inspiração de classes.",
                                  "tips": "Use nomes curtos e significativos; números de instância ajudam em interações complexas.",
                                  "learningObjective": "Construir cabeçalhos que identifiquem instâncias únicas em cenários multi-objeto.",
                                  "commonMistakes": "Confundir nome com classe (ex: User:User); omitir colchetes em instâncias nomeadas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar Atores de Objetos em Lifelines",
                                  "subSteps": [
                                    "Identifique atores como entidades externas (ex: :User ou customer).",
                                    "Note que atores usam :Nome ou simplesmente Nome sem :Classe.",
                                    "Compare com objetos que sempre têm :Classe.",
                                    "Desenhe um diagrama com ator e objetos interagindo.",
                                    "Ajuste notação para evitar confusão visual."
                                  ],
                                  "verification": "Em um diagrama misto, confirme que atores não têm :Classe e objetos sim.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Referência UML oficial (OMG specs); software de modelagem.",
                                  "tips": "Atores ficam à esquerda; use ícone de stickman para atores.",
                                  "learningObjective": "Distinguir semanticamente atores (externos) de objetos (sistema).",
                                  "commonMistakes": "Tratar atores como objetos com :Classe; inverter posições em diagramas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e Integrar Cabeçalhos em um Diagrama Completo",
                                  "subSteps": [
                                    "Monte um diagrama de sequência simples com atores e objetos.",
                                    "Aplique todas as notações aprendidas em lifelines múltiplas.",
                                    "Adicione mensagens entre eles para contexto.",
                                    "Revise o diagrama inteiro por consistência.",
                                    "Exporte ou fotografe para portfólio."
                                  ],
                                  "verification": "O diagrama renderiza corretamente em uma ferramenta UML sem erros de sintaxe.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "PlantUML ou Draw.io; template de diagrama de sequência.",
                                  "tips": "Comece com esboço no papel antes de digitalizar.",
                                  "learningObjective": "Integrar cabeçalhos corretos em diagramas funcionais de sequência UML.",
                                  "commonMistakes": "Inconsistência entre notações; alinhamento ruim de lifelines."
                                }
                              ],
                              "practicalExample": "Em um diagrama de login: ator :User envia login() para user[1]:UserAccount, que chama verify() em db[1]:Database. Cabeçalhos: :User | user[1]:UserAccount | db[1]:Database.",
                              "finalVerifications": [
                                "Todos os cabeçalhos usam notação correta: [instância]:Classe ou nome[instância]:Classe.",
                                "Atores são distinguidos sem :Classe.",
                                "Nenhuma lifeline anônima tem nome sem colchetes.",
                                "Instâncias são únicas e rastreáveis.",
                                "Diagrama compila/renderiza sem erros em ferramenta UML.",
                                "Semelhanças visuais entre atores e objetos são mínimas."
                              ],
                              "assessmentCriteria": [
                                "Precisão da sintaxe UML em 100% dos cabeçalhos.",
                                "Correta diferenciação entre atores e objetos.",
                                "Uso apropriado de anonimato vs. instâncias nomeadas.",
                                "Clareza e legibilidade dos lifelines.",
                                "Consistência em diagramas multi-lifeline.",
                                "Ausência de erros comuns como inversão de notação."
                              ],
                              "crossCurricularConnections": [
                                "Programação Orientada a Objetos: Mapeia classes e instâncias reais em código.",
                                "Modelagem de Software: Base para ferramentas como Enterprise Architect.",
                                "Design de Sistemas: Documenta interações em arquiteturas distribuídas.",
                                "Lógica e Semântica: Reforça conceitos de identidade e tipagem."
                              ],
                              "realWorldApplication": "Desenvolvedores usam isso para documentar fluxos de API em equipes ágeis, facilitando revisões de código e depuração em projetos como e-commerces ou apps bancários."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.1.3",
                            "name": "Marcar Criação e Destruição de Objetos",
                            "description": "Utilizar setas tracejadas com <<create>> e <<destroy>> para indicar a criação e destruição de objetos durante a sequência de interações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos de Criação e Destruição de Objetos",
                                  "subSteps": [
                                    "Estude o que representa a criação de um objeto em um diagrama de sequência UML: o início da linha de vida (lifeline).",
                                    "Analise a destruição: o fim da linha de vida, indicando desalocação de recursos.",
                                    "Revise exemplos de lifelines em diagramas de sequência básicos.",
                                    "Identifique cenários onde criação e destruição são essenciais, como alocação dinâmica de objetos.",
                                    "Compare com conceitos OOP reais, como 'new' e 'delete' em linguagens como Java ou C++."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre criação e destruição, com um esboço simples de lifeline.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação UML 2.5 (seção de Interaction Diagrams)",
                                    "Vídeo tutorial sobre Sequence Diagrams",
                                    "Papel e lápis para esboços"
                                  ],
                                  "tips": "Sempre pense no ciclo de vida do objeto: nascimento, vida útil e morte.",
                                  "learningObjective": "Dominar os fundamentos conceituais de criação e destruição para aplicação correta em diagramas.",
                                  "commonMistakes": [
                                    "Confundir criação com mensagens síncronas.",
                                    "Ignorar que a linha de vida começa vazia na criação.",
                                    "Não associar à gestão de memória em programação."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar a Notação de Criação com <<create>>",
                                  "subSteps": [
                                    "Desenhe uma lifeline vazia para o objeto a ser criado.",
                                    "Adicione uma seta tracejada (dashed arrow) apontando para o cabeçalho da lifeline.",
                                    "Rotule a seta com o estereótipo <<create>> acima da linha.",
                                    "Conecte a seta a partir de um ator ou outro objeto existente.",
                                    "Teste em um diagrama simples: ator cria objeto User."
                                  ],
                                  "verification": "Crie um diagrama parcial com <<create>> e confirme que a lifeline inicia corretamente após a seta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação UML (ex: Draw.io, Lucidchart)",
                                    "Templates de Sequence Diagram",
                                    "Referência UML oficial"
                                  ],
                                  "tips": "Use setas tracejadas abertas (sem ponta de seta cheia) para indicar fluxo de criação.",
                                  "learningObjective": "Aplicar precisamente a notação <<create>> em diagramas de sequência.",
                                  "commonMistakes": [
                                    "Usar seta sólida em vez de tracejada.",
                                    "Colocar <<create>> após mensagens no objeto.",
                                    "Esquecer de deixar a lifeline vazia antes da criação."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar a Notação de Destruição com <<destroy>>",
                                  "subSteps": [
                                    "Desenhe uma seta tracejada saindo do cabeçalho da lifeline do objeto.",
                                    "Rotule com <<create>> acima da seta, apontando para fora (geralmente para um coletor de lixo ou ator).",
                                    "Marque o fim da linha de vida com um 'X' no cabeçalho após a seta.",
                                    "Integre após uma sequência de interações no objeto.",
                                    "Pratique em exemplo: objeto Session é destruído após logout."
                                  ],
                                  "verification": "Desenhe um diagrama onde um objeto é destruído e verifique o 'X' no fim da lifeline.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Mesma ferramenta do passo anterior",
                                    "Exemplos de diagramas UML com destruição",
                                    "Papel para rascunhos"
                                  ],
                                  "tips": "A destruição deve ocorrer após todas as interações relevantes do objeto.",
                                  "learningObjective": "Implementar corretamente a notação <<destroy>> para modelar fim de ciclo de vida.",
                                  "commonMistakes": [
                                    "Destruir objeto antes de suas mensagens.",
                                    "Não usar 'X' no cabeçalho.",
                                    "Confundir com retorno de método."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Criação e Destruição em Diagramas Completos",
                                  "subSteps": [
                                    "Crie um diagrama completo com pelo menos um <<create>> e um <<destroy>>.",
                                    "Adicione interações entre objetos criados e destruídos.",
                                    "Valide a sequência temporal: criação primeiro, destruição por último.",
                                    "Revise o diagrama com uma checklist UML.",
                                    "Exporte ou imprima para revisão final."
                                  ],
                                  "verification": "Produza um diagrama funcional de um fluxo como 'Login e Logout' com marcações corretas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ferramenta UML completa",
                                    "Exemplo de caso de uso real",
                                    "Checklist de validação UML"
                                  ],
                                  "tips": "Garanta que todos os objetos tenham ciclo de vida coerente.",
                                  "learningObjective": "Construir diagramas de sequência profissionais com marcações de criação/destruição.",
                                  "commonMistakes": [
                                    "Lifelines sobrepostas incorretamente.",
                                    "Falta de sincronia entre criação e uso.",
                                    "Excesso de objetos sem destruição."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um diagrama de 'Login de Usuário': 1) Ator 'Cliente' envia <<create>> para lifeline 'User' (linha vazia inicia). 2) User processa autenticação. 3) Após sucesso, User envia <<destroy>> para si mesmo com 'X' no fim da lifeline, liberando sessão.",
                              "finalVerifications": [
                                "Identificar todas as setas <<create>> e <<destroy>> em um diagrama dado.",
                                "Desenhar corretamente uma lifeline vazia iniciando com <<create>>.",
                                "Marcar 'X' preciso no fim de lifeline com <<destroy>>.",
                                "Explicar o impacto de omitir <<destroy>> em termos de recursos.",
                                "Validar um diagrama completo sem erros de ciclo de vida.",
                                "Comparar diagrama com UML oficial para conformidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação: setas tracejadas com estereótipos corretos (100%).",
                                "Coerência temporal: criação antes de uso, destruição após (90%).",
                                "Completude das lifelines: vazia no início, 'X' no fim (95%).",
                                "Clareza visual: labels legíveis e posicionamento adequado.",
                                "Aplicação contextual: uso apropriado em cenários reais.",
                                "Ausência de erros comuns: sem setas sólidas ou marcações prematuras."
                              ],
                              "crossCurricularConnections": [
                                "Programação OOP: Equivalente a 'new'/'delete' ou garbage collection.",
                                "Gestão de Recursos em Sistemas: Modelagem de alocação/desalocação de memória.",
                                "Design de Software: Integração com padrões como Factory e Singleton.",
                                "Matemática Discreta: Representação de estados finitos e transições.",
                                "Análise de Sistemas: Fluxo de lifecycle em engenharia de software."
                              ],
                              "realWorldApplication": "Em desenvolvimento de aplicativos web/mobile, modela criação de sessões de usuário (<<create>> no login) e destruição (<<destroy>> no logout), otimizando uso de memória e prevenindo vazamentos em sistemas escaláveis como e-commerces ou bancos online."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.2.2",
                        "name": "Mensagens e Fluxos de Comunicação",
                        "description": "Tipos de mensagens síncronas, assíncronas e de retorno que modelam as interações dinâmicas entre objetos em diagramas de sequência UML.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.2.2.1",
                            "name": "Diferenciar Mensagens Síncronas e Assíncronas",
                            "description": "Desenhar setas cheias com ponta triangular para mensagens síncronas (chamadas bloqueantes) e setas abertas para assíncronas (não bloqueantes), especificando argumentos e sequência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Mensagens Síncronas e Assíncronas",
                                  "subSteps": [
                                    "Defina mensagem síncrona como uma chamada bloqueante onde o remetente espera resposta imediata.",
                                    "Defina mensagem assíncrona como não bloqueante, onde o remetente continua sem esperar resposta.",
                                    "Identifique exemplos: síncrona em método Java direto; assíncrona em callback ou Promise.",
                                    "Compare diferenças em termos de fluxo de controle e performance.",
                                    "Anote as representações UML: seta cheia com ponta triangular para síncrona; seta aberta para assíncrona."
                                  ],
                                  "verification": "Resuma as diferenças em um parágrafo curto e liste 2 exemplos de cada tipo corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Documentação UML básica (impressa ou online)"
                                  ],
                                  "tips": "Use analogias como telefone (síncrono) vs. email (assíncrono) para fixar conceitos.",
                                  "learningObjective": "Distinguir conceitualmente mensagens síncronas de assíncronas em contextos de programação.",
                                  "commonMistakes": "Confundir bloqueante com lento; ignorar impacto no fluxo de sequência."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a Desenhar as Setas Corretas em Diagramas de Sequência UML",
                                  "subSteps": [
                                    "Desenhe uma linha de vida vertical para dois objetos (ex: Cliente e Servidor).",
                                    "Pratique seta síncrona: linha cheia horizontal com ponta triangular no destino.",
                                    "Pratique seta assíncrona: linha tracejada ou cheia com ponta aberta (círculo aberto).",
                                    "Adicione seta de retorno para síncrona (seta tracejada com ponta aberta).",
                                    "Rotule as setas com nomes de mensagens simples (ex: 'requestData()' )."
                                  ],
                                  "verification": "Desenhe 4 setas corretas (2 síncronas, 2 assíncronas) em linhas de vida e identifique cada uma.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Ferramenta UML online como draw.io ou PlantUML"
                                  ],
                                  "tips": "Comece com setas simples sem rótulos para focar na forma; use régua para precisão.",
                                  "learningObjective": "Reproduzir visualmente as notações UML padrão para cada tipo de mensagem.",
                                  "commonMistakes": "Usar ponta errada (triangular para assíncrona); esquecer linha de vida reta."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Especificar Argumentos, Sequência e Fluxo de Comunicação",
                                  "subSteps": [
                                    "Adicione argumentos às mensagens (ex: syncMessage(param1, param2)).",
                                    "Numere a sequência das mensagens (1, 1.1, 2) para mostrar ordem.",
                                    "Desenhe fluxo síncrono: barra de ativação alta no receptor até retorno.",
                                    "Desenhe fluxo assíncrono: sem barra de ativação bloqueante no remetente.",
                                    "Combine em um diagrama com 3-4 mensagens mistas (síncronas e assíncronas)."
                                  ],
                                  "verification": "Crie um diagrama com sequência numerada, argumentos e fluxos corretos sem erros de notação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de diagramação UML (draw.io)",
                                    "Exemplos de diagramas UML impressos"
                                  ],
                                  "tips": "Use parênteses para argumentos; alinhe setas horizontalmente para clareza.",
                                  "learningObjective": "Incorporar argumentos e numeração sequencial em diagramas precisos.",
                                  "commonMistakes": "Omitir argumentos; numerar fora de ordem lógica; ignorar barras de ativação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Diferenciação em Cenários Complexos e Validar",
                                  "subSteps": [
                                    "Analise um diagrama dado e identifique/corrigir mensagens erradas.",
                                    "Crie diagrama original com cenário misto (ex: app login com chamada DB síncrona e notificação assíncrona).",
                                    "Compare seu diagrama com referência UML oficial.",
                                    "Explique verbalmente ou por escrito por que cada mensagem é síncrona/assíncrona.",
                                    "Itere melhorias baseadas em auto-revisão."
                                  ],
                                  "verification": "Produza um diagrama completo validado contra checklist UML (notações, sequência, argumentos).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exemplos de diagramas UML avançados",
                                    "Checklist UML impresso"
                                  ],
                                  "tips": "Teste com cenários reais de código para validar escolhas.",
                                  "learningObjective": "Aplicar diferenciação em diagramas completos e autônomos.",
                                  "commonMistakes": "Misturar notações; subestimar impacto assíncrono no fluxo geral."
                                }
                              ],
                              "practicalExample": "Em um diagrama de login de app: Cliente envia 'login(username, password)' síncrona (seta cheia triangular) para Servidor (bloqueia até resposta); Servidor envia 'notifyUser(email)' assíncrona (seta aberta) para EmailService (não bloqueia login). Sequência: 1=síncrona, 1.1=assíncrona.",
                              "finalVerifications": [
                                "Todas as setas síncronas usam ponta triangular cheia e barras de ativação bloqueantes.",
                                "Setas assíncronas usam ponta aberta e sem bloqueio no remetente.",
                                "Argumentos estão corretamente rotulados em parênteses.",
                                "Sequência numerada reflete ordem lógica de execução.",
                                "Linhas de vida e retornos estão consistentes.",
                                "Diagrama explica diferenças em legenda ou nota."
                              ],
                              "assessmentCriteria": [
                                "Precisão notacional (100% correto: 4/4 pontos).",
                                "Clareza na sequência e argumentos (detalhado e legível: 3/3).",
                                "Correta diferenciação conceitual (explicação precisa: 3/3).",
                                "Criatividade no exemplo prático (relevante e realista: 2/2).",
                                "Ausência de erros comuns (zero falhas: 2/2).",
                                "Completude do diagrama (todos elementos presentes: 3/3)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Relaciona com threads e async/await em linguagens como JavaScript ou C#.",
                                "Redes: Similar a requests HTTP bloqueantes vs. WebSockets não bloqueantes.",
                                "Engenharia de Software: Essencial para design de APIs REST vs. message queues.",
                                "Matemática: Fluxos sequenciais como grafos direcionados."
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps web/microservices, use síncrona para validações críticas (ex: autenticação DB) e assíncrona para tarefas paralelas (ex: envio de emails ou logs), otimizando performance e escalabilidade em sistemas como e-commerce."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.2.2",
                            "name": "Representar Mensagens de Retorno",
                            "description": "Usar linhas tracejadas com ponta aberta para mensagens de retorno, indicando o fluxo de controle de volta ao chamador após execução do método.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de mensagens de retorno",
                                  "subSteps": [
                                    "Estude a definição de mensagem de retorno em diagramas de sequência UML.",
                                    "Analise exemplos de fluxos onde um método retorna um valor ou objeto ao chamador.",
                                    "Diferencie mensagens síncronas de retornos assíncronos.",
                                    "Revise a notação padrão: linha tracejada com ponta aberta."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que é uma mensagem de retorno e sua notação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação UML oficial (OMG UML 2.5)",
                                    "Exemplos de diagramas de sequência online"
                                  ],
                                  "tips": "Sempre associe o retorno ao fluxo de controle reverso para fixar o conceito.",
                                  "learningObjective": "Entender o propósito e a notação das mensagens de retorno em UML.",
                                  "commonMistakes": "Confundir com mensagens de ativação sólidas; usar setas cheias em retornos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar cenários de uso",
                                  "subSteps": [
                                    "Examine um diagrama de sequência simples sem retornos.",
                                    "Identifique pontos onde um objeto retorna dados (ex: getName() retorna String).",
                                    "Marque no diagrama os chamadores e receptores potenciais de retornos.",
                                    "Liste 3 cenários reais de software onde retornos ocorrem (ex: login retorna token)."
                                  ],
                                  "verification": "Liste 3 exemplos corretos de cenários com retornos identificados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ferramenta de desenho UML (Draw.io, Lucidchart)",
                                    "Diagrama de sequência exemplo prévio"
                                  ],
                                  "tips": "Pense no fluxo reverso: toda chamada que espera resposta precisa de retorno.",
                                  "learningObjective": "Reconhecer quando e onde inserir mensagens de retorno.",
                                  "commonMistakes": "Omitir retornos em métodos que modificam estado sem retorno explícito."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenhar a mensagem de retorno",
                                  "subSteps": [
                                    "Desenhe a linha tracejada partindo do objeto receptor de volta ao chamador.",
                                    "Adicione a ponta aberta (sem seta fechada) no final da linha.",
                                    "Rotule o retorno com o nome do valor ou tipo retornado (ex: <<return>> nome: String).",
                                    "Ajuste a posição temporal abaixo da mensagem de chamada correspondente."
                                  ],
                                  "verification": "Desenhe um retorno isolado e compare com referência UML padrão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel milimetrado ou software UML (PlantUML, Visual Paradigm)",
                                    "Referência de notação UML"
                                  ],
                                  "tips": "Use linha tracejada fina e ponta aberta para distinguir de ativações.",
                                  "learningObjective": "Dominar a notação visual exata da mensagem de retorno.",
                                  "commonMistakes": "Usar seta sólida ou ponta fechada; posicionar acima da chamada."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e validar no diagrama completo",
                                  "subSteps": [
                                    "Inclua múltiplas mensagens de retorno em um diagrama de sequência existente.",
                                    "Verifique alinhamento temporal e conexões corretas.",
                                    "Teste legibilidade adicionando rótulos claros.",
                                    "Simule o fluxo lendo o diagrama do início ao fim."
                                  ],
                                  "verification": "Apresente o diagrama completo e explique o fluxo com retornos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software UML completo",
                                    "Diagrama base com chamadas"
                                  ],
                                  "tips": "Garanta que retornos não se cruzem com outras linhas para clareza.",
                                  "learningObjective": "Aplicar mensagens de retorno em contextos complexos.",
                                  "commonMistakes": "Ignorar retornos void; superlotar o diagrama sem espaçamento."
                                }
                              ],
                              "practicalExample": "Em um diagrama de login: Objeto 'Cliente' envia 'login(usuario, senha)' para 'Servidor'. Servidor processa e retorna 'token: String' com linha tracejada ponta aberta de Servidor para Cliente.",
                              "finalVerifications": [
                                "Linha é tracejada?",
                                "Ponta é aberta (sem preenchimento)?",
                                "Rótulo indica o valor retornado?",
                                "Posição temporal está abaixo da chamada?",
                                "Fluxo reverso conecta corretamente chamador e receptor?",
                                "Diagrama permanece legível?"
                              ],
                              "assessmentCriteria": [
                                "Precisão da notação (tracejada, ponta aberta): 30%",
                                "Correta identificação de cenários: 20%",
                                "Integração fluida no diagrama: 20%",
                                "Rótulos claros e concisos: 15%",
                                "Ausência de erros comuns: 15%"
                              ],
                              "crossCurricularConnections": [
                                "Lógica de Programação: Fluxo de controle e chamadas de métodos.",
                                "Design de Software: Documentação de APIs e interações.",
                                "Matemática: Representação gráfica de funções e retornos.",
                                "Comunicação: Diagramas como ferramenta visual de explicação."
                              ],
                              "realWorldApplication": "Em equipes de desenvolvimento ágil, diagramas de sequência com retornos claros facilitam revisão de código, depuração de fluxos e integração de microserviços, como em apps bancários onde autenticação retorna tokens seguros."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.2.3",
                            "name": "Incluir Mensagens de Auto-Referência",
                            "description": "Modelar loops internos ou ações locais com mensagens de auto-chamada em uma lifeline, usando setas curvas para representar métodos internos do objeto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Mensagens de Auto-Referência",
                                  "subSteps": [
                                    "Ler a definição oficial UML: mensagem de um objeto para si mesmo representando chamadas internas de métodos.",
                                    "Estudar casos de uso como loops internos, validações locais ou ações recursivas.",
                                    "Diferenciar de mensagens síncronas/assíncronas entre objetos distintos e mensagens de retorno.",
                                    "Revisar notação visual: seta curva na lifeline.",
                                    "Anotar exemplos reais de código OOP que mapeiam para isso."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito o conceito e fornecer um exemplo simples.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação UML 2.5 (seção de diagramas de interação)",
                                    "Vídeos tutoriais sobre UML Sequence Diagrams"
                                  ],
                                  "tips": [
                                    "Visualize como um método privado chamado pelo próprio objeto.",
                                    "Compare com setas retas para interações externas."
                                  ],
                                  "learningObjective": "Definir mensagens de auto-referência e identificar sua representação visual em UML.",
                                  "commonMistakes": [
                                    "Confundir com frames de loop (alt/loop)",
                                    "Usar setas retas em vez de curvas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Cenários Adequados para Auto-Referência",
                                  "subSteps": [
                                    "Analisar um fluxograma ou pseudocódigo de um processo OOP.",
                                    "Identificar ações locais: ex., validação interna, cálculos ou atualizações de estado.",
                                    "Mapear loops internos ou recursões que não envolvem outros objetos.",
                                    "Listar 3 cenários potenciais em contextos como GUI ou padrões de projeto.",
                                    "Validar se a auto-referência simplifica o diagrama sem perda de clareza."
                                  ],
                                  "verification": "Criar uma lista de 3 cenários com justificativa para uso de auto-referência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos de diagramas de sequência prontos",
                                    "Pseudocódigo de classes OOP simples"
                                  ],
                                  "tips": [
                                    "Pergunte: 'Essa ação é interna ao objeto?'",
                                    "Evite overuse em interações multi-objeto."
                                  ],
                                  "learningObjective": "Reconhecer quando e por que usar auto-referência em fluxos de comunicação.",
                                  "commonMistakes": [
                                    "Aplicar em comunicações entre objetos",
                                    "Ignorar contexto temporal no diagrama"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenhar Mensagens de Auto-Referência Corretamente",
                                  "subSteps": [
                                    "Desenhar a lifeline vertical do objeto envolvido.",
                                    "Posicionar o ponto de ativação na lifeline.",
                                    "Traçar seta curva da cabeça de ativação de volta para a mesma lifeline.",
                                    "Adicionar rótulo com nome do método, parâmetros e [stereotype] se aplicável.",
                                    "Ajustar para legibilidade, evitando sobreposições."
                                  ],
                                  "verification": "Desenhar e rotular um diagrama isolado com uma auto-referência válida.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de modelagem UML (Draw.io, Lucidchart ou PlantUML)",
                                    "Papel e lápis para rascunho"
                                  ],
                                  "tips": [
                                    "A curva deve ser suave e não atravessar lifelines alheias.",
                                    "Use seta aberta para assíncrono se necessário."
                                  ],
                                  "learningObjective": "Executar a notação precisa de setas curvas em lifelines.",
                                  "commonMistakes": [
                                    "Seta reta ou linear",
                                    "Posição errada no tempo (antes de ativação)",
                                    "Falta de rótulo claro"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e Validar Auto-Referência em Diagrama Completo",
                                  "subSteps": [
                                    "Selecionar ou criar um diagrama de sequência existente com múltiplas lifelines.",
                                    "Inserir a auto-referência no ponto apropriado do fluxo.",
                                    "Verificar consistência: ativação, retorno e duração.",
                                    "Simular o fluxo passo a passo para detectar anomalias.",
                                    "Refinar layout para clareza geral do diagrama."
                                  ],
                                  "verification": "Apresentar o diagrama completo e explicar o papel da auto-referência no fluxo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama base de sequência UML",
                                    "Ferramenta de edição UML"
                                  ],
                                  "tips": [
                                    "Mantenha o diagrama 'limpo': auto-referência não deve dominar.",
                                    "Teste com 'walkthrough' verbal."
                                  ],
                                  "learningObjective": "Incorporar auto-referência de forma integrada e sem erros em diagramas complexos.",
                                  "commonMistakes": [
                                    "Desalinhamento temporal com outras mensagens",
                                    "Excesso de detalhes internos, violando abstração"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Refinar o Diagrama com Auto-Referência",
                                  "subSteps": [
                                    "Gerar código skeleton a partir do diagrama para validar lógica.",
                                    "Compartilhar diagrama para feedback peer-review.",
                                    "Corrigir erros identificados na notação ou lógica.",
                                    "Documentar decisões de modelagem (por quê auto-referência?).",
                                    "Arquivar versão final com legendas."
                                  ],
                                  "verification": "Produzir diagrama final validado por auto-revisão ou par.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gerador PlantUML para código",
                                    "Checklist UML Sequence Diagram"
                                  ],
                                  "tips": [
                                    "Use frames combinados (ex. loop com auto-ref) se complexo.",
                                    "Priorize legibilidade sobre completude."
                                  ],
                                  "learningObjective": "Garantir robustez e usabilidade prática do diagrama modelado.",
                                  "commonMistakes": [
                                    "Ignorar retornos implícitos",
                                    "Falta de documentação no diagrama"
                                  ]
                                }
                              ],
                              "practicalExample": "No diagrama de login de um sistema bancário, a lifeline 'Account' recebe uma mensagem 'debit(amount)' de 'Bank' e responde com uma auto-referência curva 'Account -> Account: validateBalance()' para checar saldo interno antes de prosseguir, evitando chamadas externas desnecessárias.",
                              "finalVerifications": [
                                "A seta é curva e conecta exclusivamente à mesma lifeline.",
                                "Rótulo inclui nome do método e parâmetros relevantes.",
                                "Posição temporal respeita ordem de ativação e fluxo.",
                                "Não há sobreposição visual com outras mensagens.",
                                "Ativação da lifeline é corretamente estendida durante a auto-referência.",
                                "Diagrama permanece legível após inserção.",
                                "Lógica interna mapeia para possível implementação OOP."
                              ],
                              "assessmentCriteria": [
                                "Precisão absoluta na notação UML (seta curva, posicionamento).",
                                "Correta identificação e justificativa de cenários de uso.",
                                "Integração seamless em diagramas maiores sem perda de clareza.",
                                "Ausência de erros comuns como setas retas ou desalinhamento.",
                                "Exemplos práticos demonstram compreensão conceitual.",
                                "Refinamento iterativo evidenciado em versões.",
                                "Conexão clara com conceitos OOP reais."
                              ],
                              "crossCurricularConnections": [
                                "Programação OOP: Equivale a chamadas de métodos privados ou recursivos em classes.",
                                "Design Patterns: Útil em Singleton (métodos internos) ou Strategy (validações locais).",
                                "Lógica e Algoritmos: Modela iterações ou recursão sem loops explícitos.",
                                "Desenvolvimento Ágil: Facilita refinamento de user stories em diagramas colaborativos.",
                                "Engenharia de Software: Abstrai detalhes de implementação em modelagem comportamental."
                              ],
                              "realWorldApplication": "Em equipes de desenvolvimento de apps mobile ou web, modelar um objeto 'ShoppingCart' que chama internamente 'updateTotal()' via auto-referência durante adição de itens, permitindo visualização rápida de fluxos internos em revisões de código e reduzindo ambiguidades em sprints, comum em e-commerces como Amazon ou sistemas ERP."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.2.3",
                        "name": "Fragmentos de Interação e Fluxos de Controle",
                        "description": "Estruturas combinadas para representar condicionais, loops e paralelismo em interações dinâmicas nos diagramas de sequência UML.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.2.3.1",
                            "name": "Aplicar Fragmento 'alt' para Condicionais",
                            "description": "Usar o operador 'alt' em retângulos com compartimentos para modelar alternativas condicionais baseadas em guards [condição], separando fluxos if-else.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito do Fragmento 'alt' em Diagramas de Sequência UML",
                                  "subSteps": [
                                    "Estude a definição oficial do fragmento 'alt' na especificação UML 2.x, focando em seu uso para modelar fluxos condicionais if-else.",
                                    "Revise exemplos básicos de diagramas de sequência sem fragmentos e identifique pontos onde condicionais seriam úteis.",
                                    "Compare 'alt' com outros fragmentos como 'opt' e 'loop' para diferenciar seu propósito exclusivo de alternativas mutuamente exclusivas.",
                                    "Anote as regras sintáticas: barra vertical inicial, 'alt', linhas separadoras para cada alternativa, e barra final.",
                                    "Pratique identificando guards como [condição] em cenários reais de software."
                                  ],
                                  "verification": "Crie um resumo de 1 parágrafo explicando quando e por que usar 'alt', e liste 3 diferenças para 'opt'.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Especificação UML 2.5 (seção 17.5), ferramenta de diagramação UML como Lucidchart ou PlantUML"
                                  ],
                                  "tips": "Use diagramas visuais para mapear conceitos; memorize que 'alt' sempre requer pelo menos duas alternativas.",
                                  "learningObjective": "Dominar a definição e sintaxe do fragmento 'alt' para reconhecimento imediato em diagramas.",
                                  "commonMistakes": [
                                    "Confundir 'alt' com 'opt' (opcional vs. condicional), omitir a barra final do fragmento, usar guards sem colchetes []"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Oportunidades de Uso do Fragmento 'alt' em um Diagrama Existente",
                                  "subSteps": [
                                    "Selecione um diagrama de sequência simples sem condicionais, como um fluxo de login.",
                                    "Analise a sequência de mensagens e destaque pontos de decisão (ex: validar credenciais).",
                                    "Defina guards booleanos claros para cada ramo, como [usuário válido] e [senão].",
                                    "Esboce no papel os fluxos alternativos, garantindo que cubram todos os cenários possíveis.",
                                    "Valide logicamente se as alternativas são mutuamente exclusivas e exaustivas."
                                  ],
                                  "verification": "Marque no diagrama original os pontos condicionais com setas e liste guards propostos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama de sequência exemplo (login system), papel e caneta ou ferramenta digital"
                                  ],
                                  "tips": "Sempre inclua um ramo 'else' [senão] para cobrir casos não especificados.",
                                  "learningObjective": "Desenvolver habilidade para detectar e planejar condicionais em fluxos de interação.",
                                  "commonMistakes": [
                                    "Ignorar casos edge (ex: timeout), criar guards ambíguos, não garantir exclusividade das condições"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o Fragmento 'alt' com Guards e Compartimentos Corretos",
                                  "subSteps": [
                                    "Abra uma ferramenta UML e desenhe a barra vertical inicial do fragmento 'alt' sobre os lifelines relevantes.",
                                    "Adicione o rótulo 'alt' no topo e divida em compartimentos com linhas horizontais.",
                                    "Insira guards [condição] alinhados à esquerda de cada compartimento e desenhe mensagens condicionais dentro.",
                                    "Conecte fluxos com linhas de mensagem dashed para retornos, se aplicável.",
                                    "Finalize com a barra vertical de fechamento, garantindo alinhamento perfeito."
                                  ],
                                  "verification": "Exporte o diagrama e verifique se compila sem erros em ferramentas como PlantUML.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta UML (PlantUML, Draw.io, Visual Paradigm), template de diagrama de sequência"
                                  ],
                                  "tips": "Mantenha guards concisos (uma expressão booleana); use cores para diferenciar ramos.",
                                  "learningObjective": "Executar a construção precisa do fragmento 'alt' seguindo sintaxe UML padrão.",
                                  "commonMistakes": [
                                    "Misalignar barras verticais, esquecer guards em um ramo, usar retângulos sem compartimentos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Refinar o Diagrama com Fragmento 'alt'",
                                  "subSteps": [
                                    "Revise o diagrama quanto a cobertura de cenários: todos os caminhos levam a estados finais válidos?",
                                    "Simule execuções manuais para cada ramo, rastreando mensagens e respostas.",
                                    "Peça feedback de um par ou use linter UML para erros sintáticos.",
                                    "Otimize guards para clareza e adicione notas se necessário.",
                                    "Documente o diagrama com legenda explicando os condicionais."
                                  ],
                                  "verification": "Crie um relatório de 5 pontos confirmando validade lógica e sintática.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama construído, checklist UML Sequence Diagram"
                                  ],
                                  "tips": "Teste com dados de exemplo: valide se [senha correta] flui corretamente.",
                                  "learningObjective": "Garantir que o modelo condicional seja robusto e livre de ambiguidades.",
                                  "commonMistakes": [
                                    "Deixar caminhos mortos, guards sobrepostos, não simular fluxos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um diagrama de login: Fragmento 'alt' com [credenciais válidas] levando a 'autenticar()' e sessão aberta; [senão] enviando 'erroLogin()' e redirecionando para retry.",
                              "finalVerifications": [
                                "Guards estão em colchetes e expressam condições booleanas claras?",
                                "Todos os ramos têm fluxos completos sem caminhos pendentes?",
                                "O fragmento está corretamente delimitado por barras verticais?",
                                "Mensagens condicionais estão confinadas aos compartimentos corretos?",
                                "Diagrama compila/ renderiza sem erros em ferramentas UML?",
                                "Simulação manual confirma lógica if-else esperada?"
                              ],
                              "assessmentCriteria": [
                                "Precisão sintática do fragmento 'alt' (100% conformidade UML).",
                                "Clareza e exclusividade das guards (sem ambiguidades).",
                                "Cobertura completa de cenários alternativos.",
                                "Alinhamento visual e legibilidade do diagrama.",
                                "Validação lógica via simulação (sem dead-ends).",
                                "Integração coerente com o restante do diagrama de sequência."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Equivalente a estruturas if-else em linguagens como Java ou Python.",
                                "Lógica Computacional: Modelagem de árvores de decisão e fluxogramas.",
                                "Design de Software: Análise de requisitos não-funcionais em engenharia de software.",
                                "Matemática: Condicionais booleanas e tabelas-verdade."
                              ],
                              "realWorldApplication": "Modelar autenticação em apps bancários, onde [senha OK] libera transações e [senão] bloqueia conta, facilitando comunicação clara entre frontend e backend em equipes ágeis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.3.2",
                            "name": "Utilizar Fragmento 'loop' para Repetições",
                            "description": "Representar iterações com o operador 'loop' [condição], envolvendo múltiplas mensagens em um retângulo para fluxos repetitivos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito do Fragmento 'loop' em Diagramas de Sequência UML",
                                  "subSteps": [
                                    "Estude a definição oficial do fragmento 'loop' na especificação UML 2.5, focando em sua representação como um retângulo com 'loop' no cabeçalho.",
                                    "Analise exemplos básicos de diagramas de sequência que usam 'loop' para iterações, como processar uma lista de itens.",
                                    "Compare o 'loop' com outros fragmentos de interação, como 'alt' (alternativa) e 'opt' (opcional), para diferenciar usos.",
                                    "Identifique a sintaxe: [condição] após 'loop', envolvendo mensagens repetitivas.",
                                    "Anote os elementos visuais: bordas tracejadas opcionais e guardas de condição."
                                  ],
                                  "verification": "Explique em suas próprias palavras o propósito do 'loop' e desenhe um esboço simples à mão.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Especificação UML 2.5 (PDF online)",
                                    "Ferramenta de desenho UML gratuita como Draw.io ou Lucidchart",
                                    "Vídeo tutorial sobre fragmentos de interação UML (YouTube)"
                                  ],
                                  "tips": "Use analogias cotidianas, como 'loop para lavar pratos até acabar a pilha', para fixar o conceito.",
                                  "learningObjective": "Ao final, você definirá precisamente o fragmento 'loop' e sua sintaxe em diagramas de sequência.",
                                  "commonMistakes": [
                                    "Confundir 'loop' com loops em fluxogramas (UML sequência foca em interações entre objetos)",
                                    "Omitir a condição [ ]",
                                    "Usar 'loop' para condições mutuamente exclusivas (use 'alt' nesse caso)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Cenários Adequados para o Uso do Fragmento 'loop'",
                                  "subSteps": [
                                    "Revise um diagrama de sequência existente sem loops e identifique padrões repetitivos, como chamadas de método múltiplas.",
                                    "Liste cenários comuns: processar coleções (listas, arrays), tentativas de retry até sucesso, iterações em loops while/do-while.",
                                    "Mapeie objetos participantes: lifeline principal que itera sobre outros.",
                                    "Defina condições de parada claras, como '[while itensRestantes > 0]' ou '[for each item in lista]'.",
                                    "Documente 3 exemplos de fluxos repetitivos do seu contexto de projeto."
                                  ],
                                  "verification": "Crie uma tabela com 3 cenários: descrição, condição de loop e objetos envolvidos.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Exemplos de diagramas de sequência UML (site OMG UML)",
                                    "Seu próprio diagrama de sequência de um projeto recente",
                                    "Papel e caneta para brainstorming"
                                  ],
                                  "tips": "Pergunte: 'Essa interação se repete um número indeterminado de vezes?' Se sim, 'loop' é ideal.",
                                  "learningObjective": "Você identificará com precisão quando e onde aplicar o 'loop' em um diagrama.",
                                  "commonMistakes": [
                                    "Aplicar 'loop' a interações únicas (use 'opt')",
                                    "Ignorar exceções de parada infinita",
                                    "Não considerar o escopo de lifelines afetadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e Desenhar o Fragmento 'loop' Corretamente",
                                  "subSteps": [
                                    "Abra uma ferramenta UML e crie lifelines para os objetos envolvidos (ex: Cliente, Servidor, Banco de Dados).",
                                    "Desenhe o retângulo do fragmento: rotule 'loop [condição]' no topo, cubra as mensagens repetitivas.",
                                    "Adicione mensagens síncronas/assíncronas dentro do loop, garantindo setas conectadas às lifelines.",
                                    "Ajuste bordas tracejadas se o loop for opcional e teste o zoom para legibilidade.",
                                    "Valide sintaxe: condição em colchetes, sem erros de digitação."
                                  ],
                                  "verification": "Exporte o diagrama como imagem e verifique se o 'loop' está visualmente correto e legível.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Ferramenta UML: PlantUML, Lucidchart ou Visual Paradigm (versão free)",
                                    "Templates de diagrama de sequência prontos"
                                  ],
                                  "tips": "Mantenha o fragmento compacto; se muito grande, subdivida em loops aninhados.",
                                  "learningObjective": "Você desenhará um fragmento 'loop' sintaticamente correto e visualmente claro.",
                                  "commonMistakes": [
                                    "Posicionar o retângulo desalinhado com lifelines",
                                    "Esquecer de fechar o fragmento",
                                    "Usar condições vagas como [repetir] em vez de [while !empty(lista)]"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar, Validar e Refinar o Diagrama com 'loop'",
                                  "subSteps": [
                                    "Integre o 'loop' em um diagrama de sequência completo, conectando com fragmentos anteriores/seguintes.",
                                    "Simule a execução passo a passo: trace mensagens dentro/fora do loop.",
                                    "Peça feedback: compartilhe com um par para revisão.",
                                    "Refine: adicione notas, corrija desalinhamentos e otimize a condição.",
                                    "Gere relatório: anote lições aprendidas."
                                  ],
                                  "verification": "Realize uma walkthrough oral do diagrama, explicando cada iteração do loop.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Ferramenta UML com export PDF/SVG",
                                    "Checklist de validação UML (online)",
                                    "Parceiro de estudo ou fórum como Stack Overflow"
                                  ],
                                  "tips": "Use animação de ferramentas UML para visualizar a execução do loop.",
                                  "learningObjective": "Você integrará e validará o 'loop' em um diagrama funcional.",
                                  "commonMistakes": [
                                    "Loops aninhados sem clareza",
                                    "Condições que causam loops infinitos no modelo",
                                    "Ignorar retornos de mensagens dentro do loop"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de e-commerce, desenhe um diagrama onde o 'Carrinho' itera sobre 'Itens' com fragmento 'loop [for each item in carrinho.itens]': Carrinho envia getPreco() para Catálogo, recebe valor, acumula total, até processar todos os itens.",
                              "finalVerifications": [
                                "Desenhe independentemente um 'loop' para um cenário novo sem consultar referências.",
                                "Explique diferenças entre 'loop', 'alt' e 'par' em um diagrama híbrido.",
                                "Simule execução de um diagrama com 'loop' e identifique saídas para 3 condições diferentes.",
                                "Crie código pseudocódigo equivalente ao 'loop' UML.",
                                "Valide um diagrama de par com seu 'loop' adicionado."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe do 'loop' [condição] correta e precisa (20%)",
                                "Cobertura adequada das mensagens repetitivas dentro do fragmento (25%)",
                                "Integração coerente com o diagrama maior (20%)",
                                "Condição de parada clara e realista (15%)",
                                "Legibilidade visual e alinhamento (10%)",
                                "Ausência de erros comuns como loops infinitos modelados (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de iteração e laços em algoritmos (ex: somatória em loop)",
                                "Programação: Equivalência com estruturas for/while em linguagens como Java/Python",
                                "Design de Software: Modelagem de comportamentos repetitivos em padrões como Iterator",
                                "Lógica Computacional: Análise de fluxos de controle e condições booleanas"
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps mobile bancários, use 'loop' para modelar processamento repetitivo de transações em lote no diagrama de sequência, facilitando revisão de código e detecção de gargalos antes da implementação."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.3.3",
                            "name": "Modelar Interações Paralelas com 'par'",
                            "description": "Empregar o fragmento 'par' para execuções simultâneas em lifelines independentes, delimitando regiões paralelas em diagramas de sequência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Fragmento 'par' em Diagramas de Sequência UML",
                                  "subSteps": [
                                    "Estude a definição oficial do fragmento 'par' na especificação UML 2.x.",
                                    "Analise como 'par' modela execuções simultâneas em múltiplas lifelines independentes.",
                                    "Compare 'par' com fragmentos sequenciais como 'seq' e condicionais como 'alt'.",
                                    "Revise diagramas de exemplo onde 'par' é usado para regiões paralelas.",
                                    "Identifique restrições: lifelines dentro de 'par' não devem ter dependências de ordem."
                                  ],
                                  "verification": "Resuma em 3 frases o propósito e limitações do 'par', com um esboço simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Especificação UML 2.5 (seção de Interaction Fragments)",
                                    "Ferramenta PlantUML ou Draw.io",
                                    "Exemplos de diagramas online"
                                  ],
                                  "tips": "Visualize mentalmente threads independentes rodando ao mesmo tempo.",
                                  "learningObjective": "Dominar o conceito teórico de interações paralelas modeladas por 'par'.",
                                  "commonMistakes": [
                                    "Confundir 'par' com execução sequencial",
                                    "Ignorar independência entre lifelines",
                                    "Usar 'par' em fluxos com dependências lógicas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Mapear Cenários de Interações Paralelas",
                                  "subSteps": [
                                    "Selecione um caso de uso real, como processamento paralelo em um app.",
                                    "Liste lifelines envolvidas (ex: Cliente, ServidorA, ServidorB).",
                                    "Marque pontos onde ações podem ocorrer simultaneamente sem dependência.",
                                    "Crie um fluxograma preliminar destacando regiões paralelas.",
                                    "Valide se as ações em paralelo são verdadeiramente independentes."
                                  ],
                                  "verification": "Crie uma lista de 3 cenários potenciais e justifique o uso de 'par' em cada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para esboços",
                                    "Exemplos de sistemas reais (e-commerce, IoT)"
                                  ],
                                  "tips": "Pergunte: 'Essas ações podem rodar em threads separadas?'",
                                  "learningObjective": "Reconhecer oportunidades de modelagem paralela em fluxos complexos.",
                                  "commonMistakes": [
                                    "Forçar paralelismo onde há dependências",
                                    "Subestimar sincronizações pós-paralelo",
                                    "Ignorar exceções em cenários paralelos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o Diagrama de Sequência com Fragmento 'par'",
                                  "subSteps": [
                                    "Desenhe as lifelines principais no diagrama.",
                                    "Adicione mensagens sequenciais antes da região paralela.",
                                    "Insira o frame 'par' cobrindo as lifelines independentes.",
                                    "Preencha mensagens dentro de 'par' para cada lifeline simultânea.",
                                    "Adicione retornos ou sincronizações após o 'par', se necessário."
                                  ],
                                  "verification": "Exporte ou fotografe o diagrama e confirme sintaxe com uma ferramenta UML.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de modelagem (PlantUML, Lucidchart, Visual Paradigm)",
                                    "Templates de diagramas de sequência"
                                  ],
                                  "tips": "Use a sintaxe PlantUML: par ... end par para prototipagem rápida.",
                                  "learningObjective": "Aplicar corretamente a sintaxe e estrutura do 'par' em um diagrama.",
                                  "commonMistakes": [
                                    "Colocar 'par' em lifeline única",
                                    "Desalinhar frames de 'par'",
                                    "Misturar mensagens cruzadas dentro de 'par'"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Refinar o Diagrama Modelado",
                                  "subSteps": [
                                    "Verifique independência: remova 'par' e veja se ordem muda o significado.",
                                    "Teste com cenários de erro: o que acontece se uma lifeline falhar?",
                                    "Compare com código real (ex: threads em Java) para validar.",
                                    "Peça feedback ou use linter UML para erros.",
                                    "Itere adicionando notas ou guards se aplicável."
                                  ],
                                  "verification": "Explique como o diagrama reflete execução paralela e liste 2 melhorias.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de código paralelo (Java ExecutorService)",
                                    "Validador online PlantUML"
                                  ],
                                  "tips": "Simule execução passo a passo para detectar violações de paralelismo.",
                                  "learningObjective": "Garantir precisão e robustez no modelo de interações paralelas.",
                                  "commonMistakes": [
                                    "Esquecer sincronização pós-'par'",
                                    "Sobrecarregar 'par' com muitas lifelines",
                                    "Não testar independência"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de e-commerce, modelar o checkout: lifeline 'Pagamento' processa transação via gateway enquanto lifeline 'Notificacao' envia email de confirmação simultaneamente, usando 'par' para delimitar essas ações independentes em lifelines separadas.",
                              "finalVerifications": [
                                "O frame 'par' corretamente engloba apenas lifelines independentes?",
                                "Mensagens dentro de 'par' não implicam ordem sequencial entre lifelines?",
                                "Há sincronização ou merge explícito após o 'par', se necessário?",
                                "O diagrama compila sem erros em ferramentas UML?",
                                "Explicação oral demonstra compreensão de simultaneidade?",
                                "Comparação com implementação código confirma fidelidade?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na sintaxe UML do fragmento 'par' (100% conformidade).",
                                "Correta identificação de independência entre lifelines paralelas.",
                                "Clareza visual: frames alinhados e mensagens legíveis.",
                                "Cobertura completa do cenário, incluindo pré/pós-paralelo.",
                                "Validação contra erros comuns e cenários edge-case.",
                                "Integração lógica com outros fragmentos de interação."
                              ],
                              "crossCurricularConnections": [
                                "Programação Concorrente: Modelagem de threads e async/await.",
                                "Arquitetura de Software: Microsserviços e comunicação assíncrona.",
                                "Design de Sistemas Distribuídos: Paralelismo em cloud computing.",
                                "Matemática Discreta: Grafos acíclicos e caminhos paralelos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de aplicações web escaláveis, como Netflix ou Amazon, onde envio de notificações, logging e processamento de dados ocorrem em paralelo para otimizar performance e responsividade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.3.4",
                            "name": "Construir Diagramas Completos de Sequência",
                            "description": "Integrar lifelines, mensagens e fragmentos para criar um diagrama de sequência completo que modele um cenário de interação dinâmica entre objetos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Desenhar Lifelines dos Objetos Envolvidos",
                                  "subSteps": [
                                    "Analise o cenário de interação e liste todos os objetos ou atores participantes.",
                                    "Desenhe retângulos na parte superior para cabeçalhos de lifelines com nomes como 'Cliente:User' ou 'Servidor:Database'.",
                                    "Trace linhas verticais tracejadas (lifelines) descendentes de cada cabeçalho até o final do diagrama.",
                                    "Posicione lifelines paralelamente da esquerda para a direita em ordem de iniciação da interação.",
                                    "Adicione caixas de ativação (barras finas retas) nas lifelines onde o objeto está ativo."
                                  ],
                                  "verification": "Verifique se todas as lifelines estão nomeadas corretamente, paralelas e cobrem todos os objetos do cenário sem duplicatas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação como Draw.io ou Lucidchart",
                                    "Papel e lápis para rascunho",
                                    "Descrição do cenário de interação"
                                  ],
                                  "tips": "Comece sempre com o ator iniciador à esquerda para melhor legibilidade.",
                                  "learningObjective": "Compreender e representar visualmente os participantes persistentes em uma interação dinâmica.",
                                  "commonMistakes": [
                                    "Esquecer retornos de mensagens",
                                    "Nomear lifelines sem tipos de objetos",
                                    "Lifelines cruzadas ou desalinhadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Adicionar Mensagens e Fluxos de Comunicação",
                                  "subSteps": [
                                    "Identifique a sequência temporal de chamadas entre objetos.",
                                    "Desenhe setas horizontais para mensagens síncronas (seta cheia) e assíncronas (seta aberta).",
                                    "Inclua mensagens de retorno com setas tracejadas apontando para cima.",
                                    "Rotule cada mensagem com o nome do método ou operação, parâmetros e condições se aplicável.",
                                    "Ajuste as caixas de ativação para abranger o período de processamento do objeto receptor."
                                  ],
                                  "verification": "Confirme que as mensagens fluem logicamente da esquerda para a direita, com retornos correspondentes e sem lacunas temporais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação",
                                    "Referência UML para notação de mensagens"
                                  ],
                                  "tips": "Use numeração sequencial nas mensagens para rastrear ordem em cenários complexos.",
                                  "learningObjective": "Modelar trocas de mensagens síncronas e assíncronas entre objetos de forma precisa.",
                                  "commonMistakes": [
                                    "Confundir setas síncronas com assíncronas",
                                    "Omitir mensagens de retorno",
                                    "Mensagens sem rótulos claros"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inserir Fragmentos de Interação e Fluxos de Controle",
                                  "subSteps": [
                                    "Identifique pontos de decisão, loops ou opções no fluxo.",
                                    "Desenhe um retângulo de fragmento 'alt' para condições alternativas com guards como [condição].",
                                    "Adicione fragmento 'loop' para iterações com [iteração condition].",
                                    "Use 'opt' para seções opcionais e 'par' para interações paralelas.",
                                    "Posicione fragmentos envolvendo as lifelines relevantes e aninhe se necessário."
                                  ],
                                  "verification": "Teste se os fragmentos capturam corretamente ramificações e loops, com guards legíveis e sem sobreposições incorretas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação com suporte a UML",
                                    "Exemplos de fragmentos UML"
                                  ],
                                  "tips": "Mantenha guards concisos e booleanos para clareza.",
                                  "learningObjective": "Incorporar estruturas condicionais e de controle para modelar comportamentos dinâmicos complexos.",
                                  "commonMistakes": [
                                    "Guards mal formatados",
                                    "Fragmentos que não abrangem todas as lifelines afetadas",
                                    "Aninhamento excessivo sem necessidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Refinar, Validar e Finalizar o Diagrama",
                                  "subSteps": [
                                    "Adicione notas, durações ou estados nos lifelines se relevante.",
                                    "Verifique consistência: todas mensagens têm retornos? Fragmentos balanceados?",
                                    "Simule o fluxo passo a passo para detectar anomalias temporais.",
                                    "Ajuste layout para legibilidade: evite cruzamentos de setas, alinhe elementos.",
                                    "Exporte ou imprima o diagrama com legenda de notação."
                                  ],
                                  "verification": "O diagrama pode ser lido por outra pessoa e simula corretamente o cenário sem ambiguidades.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação",
                                    "Checklist de validação UML"
                                  ],
                                  "tips": "Use zoom out para verificar o layout geral antes de finalizar.",
                                  "learningObjective": "Garantir que o diagrama seja completo, legível e fiel ao modelo de interação.",
                                  "commonMistakes": [
                                    "Ignorar validação temporal",
                                    "Layout bagunçado",
                                    "Falta de legenda para notações personalizadas"
                                  ]
                                }
                              ],
                              "practicalExample": "Cenário: Processo de login em um app bancário. Lifelines: User, AuthService, Database. Mensagens: User -> AuthService.login(credentials), AuthService -> Database.query(user), retorno success/fail. Fragmento alt [success] proceed else [fail] error message.",
                              "finalVerifications": [
                                "Todas as lifelines representam objetos corretos do cenário.",
                                "Mensagens e retornos estão sequenciados temporalmente sem erros.",
                                "Fragmentos modelam adequadamente condições e loops.",
                                "Diagrama é legível e sem cruzamentos desnecessários.",
                                "Simulação manual do fluxo confirma o comportamento esperado.",
                                "Notações UML padrão são usadas consistentemente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na representação de lifelines e ativações (20%)",
                                "Correção e rotulagem de mensagens (25%)",
                                "Uso apropriado e correto de fragmentos (25%)",
                                "Layout, legibilidade e refinamentos (15%)",
                                "Validação lógica e consistência temporal (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação Orientada a Objetos: Mapeamento direto para chamadas de métodos em código.",
                                "Design de Software: Base para padrões como MVC ou Observer.",
                                "Banco de Dados: Modelagem de queries e transações em interações.",
                                "Engenharia de Software: Documentação para análise de requisitos.",
                                "Interfaces GUI: Fluxos de usuário em apps interativos."
                              ],
                              "realWorldApplication": "Em equipes de desenvolvimento ágil, diagramas de sequência são usados para planejar APIs REST, depurar fluxos de microservices ou documentar integrações em sistemas como e-commerce, onde modelam interações cliente-servidor para evitar bugs em produção."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.8.3",
                    "name": "Padrão Singleton",
                    "description": "Padrão de projeto criacional que garante uma única instância de uma classe.",
                    "individualConcepts": [
                      {
                        "id": "10.1.8.3.1",
                        "name": "Definição e Propósito do Padrão Singleton",
                        "description": "Compreender o que é o padrão Singleton, um padrão criacional que garante a existência de apenas uma instância de uma classe e fornece um ponto global de acesso a ela, resolvendo problemas de controle de recursos compartilhados.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.3.1.1",
                            "name": "Identificar a necessidade do Singleton",
                            "description": "Reconhecer cenários onde uma única instância é essencial, como gerenciadores de conexão de banco de dados, loggers ou configuradores globais, evitando múltiplas instâncias desnecessárias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de instância única e seus benefícios",
                                  "subSteps": [
                                    "Defina o que significa uma 'instância única' em programação orientada a objetos.",
                                    "Explique por que múltiplas instâncias podem causar problemas, como consumo excessivo de recursos ou inconsistências de estado.",
                                    "Liste os benefícios principais do Singleton: economia de recursos, estado global consistente e controle centralizado.",
                                    "Compare com classes normais que permitem múltiplas instâncias.",
                                    "Revise exemplos iniciais como cache ou gerenciador de configurações."
                                  ],
                                  "verification": "Escreva uma definição clara e liste pelo menos 3 benefícios sem consultar materiais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação sobre Padrão Singleton (Wikipedia ou livros de Design Patterns)",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": [
                                    "Use analogias do mundo real, como uma única chave mestra para um prédio, para fixar o conceito."
                                  ],
                                  "learningObjective": "Entender os fundamentos teóricos da necessidade de uma única instância.",
                                  "commonMistakes": [
                                    "Confundir Singleton com classe estática; lembre-se que Singleton permite lazy initialization."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar cenários comuns onde Singleton é essencial",
                                  "subSteps": [
                                    "Analise gerenciadores de conexão de banco de dados: por que múltiplas conexões simultâneas desperdiçam recursos?",
                                    "Examine loggers: explique como logs duplicados ou inconsistentes surgem com múltiplas instâncias.",
                                    "Estude configuradores globais: discuta a necessidade de configurações uniformes em toda a aplicação.",
                                    "Liste outros cenários: impressoras compartilhadas, gerenciadores de threads ou pools de conexões.",
                                    "Crie um mapa mental conectando cenários a problemas resolvidos pelo Singleton."
                                  ],
                                  "verification": "Liste 4 cenários específicos com justificativa para cada um em um documento.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de código em Java/Python de Singleton (GitHub ou tutoriais)",
                                    "Papel e caneta para mapa mental"
                                  ],
                                  "tips": [
                                    "Pergunte sempre: 'Essa classe precisa de estado global único?' para identificar necessidade."
                                  ],
                                  "learningObjective": "Reconhecer padrões de uso real do Singleton em aplicações.",
                                  "commonMistakes": [
                                    "Ignorar cenários thread-safe; sempre considere multithreading em aplicações reais."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar problemas causados por múltiplas instâncias",
                                  "subSteps": [
                                    "Simule um cenário sem Singleton: crie duas instâncias de um logger e observe logs duplicados.",
                                    "Calcule impactos: estime overhead de memória ou CPU com múltiplas conexões de BD.",
                                    "Identifique inconsistências: como estados divergentes afetam o comportamento da aplicação.",
                                    "Compare métricas antes/depois da implementação de Singleton.",
                                    "Documente lições aprendidas em um relatório curto."
                                  ],
                                  "verification": "Execute um código simples demonstrando o problema e anote os resultados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE com suporte a Java/Python (Eclipse, VS Code)",
                                    "Código de exemplo sem/with Singleton"
                                  ],
                                  "tips": [
                                    "Use ferramentas de profiling (como VisualVM) para visualizar consumo de recursos."
                                  ],
                                  "learningObjective": "Quantificar os riscos de não usar Singleton quando necessário.",
                                  "commonMistakes": [
                                    "Subestimar problemas em ambientes single-threaded; teste em multithread."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação em casos reais e exercícios",
                                  "subSteps": [
                                    "Revise um diagrama UML de uma aplicação e marque classes candidatas a Singleton.",
                                    "Resolva exercícios: dado um requisito, decida se Singleton é apropriado e justifique.",
                                    "Debata prós/contras em fóruns ou com pares.",
                                    "Crie um checklist pessoal para futura identificação.",
                                    "Autoavalie com cenários variados."
                                  ],
                                  "verification": "Aplique o checklist a 3 exemplos e justifique escolhas corretas/incorretas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exercícios online sobre Design Patterns (Refactoring.Guru)",
                                    "Diagrama UML de exemplo"
                                  ],
                                  "tips": [
                                    "Comece com 'YAGNI' (You Ain't Gonna Need It) mas priorize cenários de recurso limitado."
                                  ],
                                  "learningObjective": "Desenvolver habilidade prática de detecção intuitiva da necessidade de Singleton.",
                                  "commonMistakes": [
                                    "Abusar de Singleton; use apenas quando estado global é inevitável."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de e-commerce, um gerenciador de conexão com banco de dados como Singleton garante que apenas uma conexão compartilhada seja usada, evitando esgotamento de pool de conexões durante picos de tráfego e mantendo transações ACID consistentes.",
                              "finalVerifications": [
                                "Pode listar e justificar 3 cenários onde Singleton é essencial?",
                                "Identifica corretamente problemas de múltiplas instâncias em um exemplo dado?",
                                "Aplica um checklist para decidir uso de Singleton em novos requisitos?",
                                "Explica diferenças entre Singleton e outras classes em UML?",
                                "Simula impactos de não usar Singleton em código simples?",
                                "Discute limitações do Singleton em contextos modernos (ex: microsserviços)?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de cenários (90% de acertos em testes)",
                                "Justificativas claras e baseadas em recursos/estados globais",
                                "Uso correto de analogias e exemplos reais",
                                "Compreensão de trade-offs (thread-safety, testabilidade)",
                                "Checklist pessoal completo e acionável",
                                "Análise quantitativa de problemas (memória/CPU)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de recursos limitados (pools finitos)",
                                "Administração: Gerenciamento de recursos compartilhados em empresas",
                                "Física/Engenharia: Princípios de singularidade em sistemas (ex: uma única fonte de energia)",
                                "Banco de Dados: Otimização de conexões e transações"
                              ],
                              "realWorldApplication": "No desenvolvimento de aplicativos empresariais como ERPs (ex: SAP), Singletons gerenciam configurações globais e loggers, garantindo auditoria unificada e eficiência em ambientes de alta concorrência, reduzindo custos operacionais em até 30%."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.3.1.2",
                            "name": "Explicar os princípios do Singleton",
                            "description": "Descrever os quatro princípios essenciais: construtor privado, método estático getInstance(), variável estática para a instância única e lazy initialization para criação sob demanda.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Implementar o Construtor Privado",
                                  "subSteps": [
                                    "Crie uma nova classe Java chamada SingletonExample.",
                                    "Declare o construtor padrão da classe como private: private SingletonExample() {}",
                                    "Explique o propósito: impedir que instâncias sejam criadas diretamente via new fora da classe",
                                    "Teste tentando instanciar externamente para ver o erro de compilação",
                                    "Adicione um campo simples, como um contador, acessível apenas via métodos públicos"
                                  ],
                                  "verification": "Tente compilar código que chama new SingletonExample() fora da classe; deve falhar com erro de acesso.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (IntelliJ ou Eclipse)",
                                    "JDK 8 ou superior"
                                  ],
                                  "tips": "Sempre use modificador 'private' sem exceções para o construtor no Singleton.",
                                  "learningObjective": "Compreender como o construtor privado previne múltiplas instâncias externas.",
                                  "commonMistakes": [
                                    "Deixar o construtor público acidentalmente",
                                    "Esquecer de definir o corpo do construtor",
                                    "Usar protected em vez de private"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar a Variável Estática de Instância Única",
                                  "subSteps": [
                                    "Adicione um campo estático privado na classe: private static SingletonExample instance;",
                                    "Inicialize como null inicialmente: private static SingletonExample instance = null;",
                                    "Explique o papel: armazena a referência única à instância da classe",
                                    "Discuta o escopo estático: pertence à classe, não a instâncias",
                                    "Verifique acessibilidade: deve ser private para encapsulamento"
                                  ],
                                  "verification": "Inspecione o código-fonte; o campo instance deve ser static, private e do tipo da própria classe.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Documentação Java sobre modificadores static"
                                  ],
                                  "tips": "Nomeie a variável como 'instance' ou 'INSTANCE' para clareza convencional.",
                                  "learningObjective": "Entender o uso de variáveis estáticas para manter uma única referência compartilhada.",
                                  "commonMistakes": [
                                    "Declarar como não-estática",
                                    "Inicializar imediatamente com new (quebra lazy init)",
                                    "Tornar pública"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar o Método Estático getInstance()",
                                  "subSteps": [
                                    "Adicione um método público estático: public static SingletonExample getInstance() {}",
                                    "Dentro do método, retorne a instância estática",
                                    "Explique: ponto único de acesso para obter a instância",
                                    "Garanta thread-safety básica com if (instance == null) instance = new SingletonExample();",
                                    "Teste chamando getInstance() múltiplas vezes e comparando referências com =="
                                  ],
                                  "verification": "Chame getInstance() duas vezes e use System.identityHashCode() para confirmar mesma instância.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Console para testes de hashCode"
                                  ],
                                  "tips": "Faça o método synchronized em ambientes multi-threaded para evitar race conditions.",
                                  "learningObjective": "Dominar o método getInstance() como gateway controlado para a instância única.",
                                  "commonMistakes": [
                                    "Não tornar estático",
                                    "Retornar new toda vez",
                                    "Esquecer de checar null"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Lazy Initialization",
                                  "subSteps": [
                                    "No getInstance(), adicione lógica condicional: if (instance == null) { instance = new SingletonExample(); }",
                                    "Explique lazy init: criação sob demanda, só quando primeiro chamado",
                                    "Compare com eager init (instance = new ... no campo)",
                                    "Teste: chame getInstance() e verifique se construtor roda apenas na primeira chamada",
                                    "Discuta benefícios: economia de memória se não usado"
                                  ],
                                  "verification": "Adicione log no construtor; execute getInstance() múltiplas vezes; log aparece só uma vez.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Sistema de logging simples (System.out.println)"
                                  ],
                                  "tips": "Use double-checked locking para thread-safety avançado: synchronized(this) {}.",
                                  "learningObjective": "Aplicar lazy initialization para otimizar criação de instâncias.",
                                  "commonMistakes": [
                                    "Criar instância no campo estático (eager)",
                                    "Sem checagem de null",
                                    "Race conditions em multi-thread sem sync"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e Verificar os Princípios do Singleton",
                                  "subSteps": [
                                    "Compile e execute a classe completa com testes de múltiplas chamadas",
                                    "Adicione métodos utilitários à classe para demonstrar uso",
                                    "Explique verbalmente os 4 princípios em sequência",
                                    "Refatore para melhorias como enum Singleton (Java moderno)",
                                    "Documente o código com Javadoc destacando cada princípio"
                                  ],
                                  "verification": "Código compila, testes mostram uma única instância, explicação cobre todos os 4 princípios.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "JUnit para testes unitários opcionais"
                                  ],
                                  "tips": "Sempre teste com == para referências e equals para valores.",
                                  "learningObjective": "Sintetizar os quatro princípios em uma implementação funcional.",
                                  "commonMistakes": [
                                    "Ignorar serialização (pode quebrar singleton)",
                                    "Não considerar clonagem",
                                    "Falta de testes"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe Logger singleton: private static Logger instance; private Logger() {}; public static Logger getInstance() { if (instance == null) instance = new Logger(); return instance; } com método log(String msg) { System.out.println(msg); }. Chame Logger.getInstance().log('Teste'); duas vezes – mesma instância, logs funcionam.",
                              "finalVerifications": [
                                "Explicar os 4 princípios sem hesitação: construtor privado, variável estática, getInstance() estático, lazy init.",
                                "Implementar código funcional que retorna sempre a mesma instância via getInstance().",
                                "Demonstrar falha ao tentar new fora da classe.",
                                "Comparar hashCodes de múltiplas chamadas a getInstance() (iguais).",
                                "Identificar e corrigir um erro comum, como falta de null check.",
                                "Descrever trade-offs: thread-safety vs performance."
                              ],
                              "assessmentCriteria": [
                                "Construtor privado corretamente implementado (100% correto).",
                                "Variável estática private e inicializada como null.",
                                "Método getInstance() estático, público e com lógica de retorno única.",
                                "Lazy initialization via checagem condicional presente.",
                                "Testes verificam unicidade da instância (referências iguais).",
                                "Explicação verbal cobre propósito e limitações do padrão."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceito de funções injetoras e unicidade de elementos.",
                                "Design de Sistemas: Alocação de recursos limitados em redes (ex: portas únicas).",
                                "Banco de Dados: Controle de conexões únicas para evitar overhead.",
                                "Física/Engenharia: Modelagem de recursos singulares como um átomo único em simulações."
                              ],
                              "realWorldApplication": "Em aplicações web, Singleton gerencia uma única conexão de banco de dados (ex: pool único no Hibernate), loggers centrais (Log4j), caches de configuração (evita recarga múltipla) e gerenciadores de threads para evitar duplicatas em servidores multi-usuário."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.3.1.3",
                            "name": "Diferenciar Singleton de outras classes",
                            "description": "Comparar o Singleton com classes normais, destacando como ele viola o princípio de responsabilidade única em alguns contextos, mas é útil para singletons legítimos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos de Classes Convencionais",
                                  "subSteps": [
                                    "Defina o que é uma classe em programação orientada a objetos (POO).",
                                    "Explique a instanciação de objetos: como criar múltiplas instâncias de uma classe.",
                                    "Discuta o princípio de encapsulamento e herança em classes normais.",
                                    "Exemplo: Crie uma classe 'Carro' com atributos como cor e modelo, instanciando dois objetos.",
                                    "Analise como classes normais seguem o princípio de responsabilidade única (SRP) ao focar em uma responsabilidade."
                                  ],
                                  "verification": "Criar e instanciar uma classe normal em código, demonstrando múltiplas instâncias independentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code)",
                                    "Documentação de POO básica"
                                  ],
                                  "tips": "Use diagramas UML para visualizar classes e objetos.",
                                  "learningObjective": "Compreender as características fundamentais de classes convencionais em POO.",
                                  "commonMistakes": [
                                    "Confundir classe com objeto",
                                    "Ignorar que classes normais permitem múltiplas instâncias"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o Padrão Singleton",
                                  "subSteps": [
                                    "Defina o Singleton: classe que garante apenas uma instância em toda a aplicação.",
                                    "Descreva mecanismos como construtor privado e getInstance() estático.",
                                    "Implemente um Singleton simples em pseudocódigo ou linguagem escolhida.",
                                    "Teste criando múltiplas chamadas a getInstance(), verificando que retorna o mesmo objeto.",
                                    "Discuta thread-safety em Singletons para ambientes multi-threaded."
                                  ],
                                  "verification": "Implementar um Singleton e usar Object.ReferenceEquals ou === para confirmar unicidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplos de código Singleton (GitHub ou livros como GoF)"
                                  ],
                                  "tips": "Sempre inicialize a instância como lazy (sob demanda) para eficiência.",
                                  "learningObjective": "Dominar a estrutura e o propósito do padrão Singleton.",
                                  "commonMistakes": [
                                    "Esquecer construtor privado",
                                    "Não tornar getInstance() estático"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diferenças entre Singleton e Classes Normais",
                                  "subSteps": [
                                    "Liste diferenças: instanciação (única vs múltipla), acesso global vs local.",
                                    "Crie uma tabela comparativa: construtor, métodos de acesso, estado compartilhado.",
                                    "Compare gerenciamento de estado: global em Singleton vs por instância.",
                                    "Desenhe diagramas UML lado a lado para visualização.",
                                    "Discuta vantagens (controle centralizado) e desvantagens (dificuldade de testes)."
                                  ],
                                  "verification": "Preencher uma tabela comparativa e discutir em voz alta ou por escrito.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de diagramas (ex: Draw.io)",
                                    "Papel e caneta para tabela"
                                  ],
                                  "tips": "Foque em impactos práticos, como memória e testabilidade.",
                                  "learningObjective": "Identificar e articular diferenças chave entre Singleton e classes convencionais.",
                                  "commonMistakes": [
                                    "Ignorar estado global como problema",
                                    "Confundir com classes estáticas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Relação com Princípio de Responsabilidade Única (SRP)",
                                  "subSteps": [
                                    "Recapitule SRP: uma classe deve ter apenas uma razão para mudar.",
                                    "Explique como Singleton pode violar SRP ao gerenciar sua própria instanciação além da responsabilidade principal.",
                                    "Identifique casos legítimos: quando Singleton é útil (ex: logger global).",
                                    "Discuta alternativas: injeção de dependência para evitar violações.",
                                    "Avalie trade-offs: conveniência vs manutenibilidade."
                                  ],
                                  "verification": "Escrever um parágrafo explicando um caso de violação e um de uso legítimo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação SOLID principles",
                                    "Exemplos de código com SRP"
                                  ],
                                  "tips": "Pergunte: 'Essa classe faz mais que uma coisa?' para testar SRP.",
                                  "learningObjective": "Avaliar criticamente o uso de Singleton em relação a princípios SOLID.",
                                  "commonMistakes": [
                                    "Aplicar Singleton indiscriminadamente",
                                    "Não reconhecer violações sutis de SRP"
                                  ]
                                }
                              ],
                              "practicalExample": "Classe normal 'Carro': múltiplos carros podem ser criados, cada um com estado independente (cor, velocidade). Singleton 'Logger': apenas um logger global registra todos os eventos da aplicação, garantindo logs centralizados sem duplicação.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças principais entre Singleton e classes normais.",
                                "Implementar um Singleton e provar unicidade com testes.",
                                "Identificar um exemplo onde Singleton viola SRP e propor alternativa.",
                                "Criar diagrama UML comparativo.",
                                "Discutir 2 cenários reais onde Singleton é legítimo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de instanciação única vs múltipla (90% acerto).",
                                "Compreensão clara de mecanismos de implementação do Singleton.",
                                "Análise correta da relação com SRP, com exemplos.",
                                "Uso adequado de diagramas e tabelas comparativas.",
                                "Capacidade de discutir trade-offs e alternativas."
                              ],
                              "crossCurricularConnections": [
                                "Princípios SOLID (especialmente SRP e DIP).",
                                "Outros padrões de projeto (Factory, Abstract Factory).",
                                "Arquitetura de software e design de sistemas distribuídos.",
                                "Testes unitários e mock objects para Singletons."
                              ],
                              "realWorldApplication": "Em aplicações empresariais, o gerenciador de conexão de banco de dados é um Singleton para evitar múltiplas conexões desnecessárias, garantindo eficiência e consistência em transações financeiras."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.3.2",
                        "name": "Estrutura UML do Padrão Singleton",
                        "description": "Representar o padrão Singleton utilizando a Linguagem Unificada de Modelagem (UML), focando no diagrama de classes com construtor privado e método estático.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.3.2.1",
                            "name": "Desenhar o diagrama de classes UML",
                            "description": "Criar um diagrama UML mostrando a classe Singleton com atributo privado estático para a instância, método estático getInstance() e construtor privado, utilizando notações corretas como + para público e - para privado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e desenhar a estrutura básica da classe",
                                  "subSteps": [
                                    "Selecione uma ferramenta de modelagem UML como Draw.io, Lucidchart, PlantUML ou papel e lápis.",
                                    "Crie um novo diagrama e desenhe uma caixa retangular dividida em três compartimentos horizontais.",
                                    "No compartimento superior (nome da classe), escreva 'Singleton' centralizado e em negrito.",
                                    "Rotule os compartimentos inferiores como 'Atributos' e 'Métodos' se necessário para clareza.",
                                    "Ajuste o tamanho da caixa para acomodar o conteúdo futuro."
                                  ],
                                  "verification": "Verifique se a caixa possui três seções claras com 'Singleton' no topo.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação UML (Draw.io, Lucidchart, PlantUML)",
                                    "Papel e caneta (alternativa manual)"
                                  ],
                                  "tips": [
                                    "Mantenha proporções equilibradas para legibilidade.",
                                    "Use linhas retas e grossura uniforme."
                                  ],
                                  "learningObjective": "Dominar a estrutura fundamental de uma classe em diagrama de classes UML.",
                                  "commonMistakes": [
                                    "Dividir incorretamente em seções",
                                    "Nome da classe em minúscula ou não centralizado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Adicionar o construtor privado",
                                  "subSteps": [
                                    "No compartimento de métodos (terceira seção), insira a linha: - Singleton()",
                                    "O sinal '-' indica visibilidade privada.",
                                    "Posicione o texto alinhado à esquerda no compartimento.",
                                    "Garanta que não haja parâmetros no construtor para este exemplo básico.",
                                    "Verifique se o texto está legível e com espaçamento adequado."
                                  ],
                                  "verification": "Confirme que o construtor aparece como '- Singleton()' no compartimento de métodos.",
                                  "estimatedTime": "8 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação UML ativa"
                                  ],
                                  "tips": [
                                    "Lembre-se: construtor privado impede instanciação externa direta.",
                                    "Use itálico ou cor para destacar se a ferramenta permitir."
                                  ],
                                  "learningObjective": "Aplicar corretamente a notação de visibilidade privada em métodos UML.",
                                  "commonMistakes": [
                                    "Usar '+' em vez de '-' para privado",
                                    "Esquecer parênteses no construtor"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar o atributo privado estático para a instância",
                                  "subSteps": [
                                    "No compartimento de atributos (segunda seção), insira: - instance: Singleton",
                                    "Sublinhe o nome 'instance' para indicar que é estático.",
                                    "Use o sinal '-' para visibilidade privada.",
                                    "Especifique o tipo como 'Singleton' após os dois pontos.",
                                    "Alinhe o texto e ajuste espaçamento."
                                  ],
                                  "verification": "Verifique se '- instance: Singleton' está sublinhado e no compartimento correto.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação UML"
                                  ],
                                  "tips": [
                                    "Sublinhado é essencial para estáticos em UML.",
                                    "Tipo de retorno deve coincidir com a classe."
                                  ],
                                  "learningObjective": "Representar atributos estáticos privados com notação UML precisa.",
                                  "commonMistakes": [
                                    "Esquecer sublinhado para estático",
                                    "Usar tipo incorreto ou visibilidade pública"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar o método estático público getInstance()",
                                  "subSteps": [
                                    "No compartimento de métodos, adicione: + getInstance(): Singleton",
                                    "Sublinhe 'getInstance' para indicar estático.",
                                    "Use '+' para visibilidade pública.",
                                    "Inclua o tipo de retorno ': Singleton' após os parênteses.",
                                    "Posicione abaixo do construtor para ordem lógica."
                                  ],
                                  "verification": "Confirme '+ getInstance(): Singleton' sublinhado no compartimento de métodos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação UML"
                                  ],
                                  "tips": [
                                    "Método getInstance() retorna a instância única.",
                                    "Sublinhe apenas o nome do método/ atributo."
                                  ],
                                  "learningObjective": "Modelar métodos estáticos públicos com retorno de instância em UML.",
                                  "commonMistakes": [
                                    "Não sublinhar o método estático",
                                    "Omitir tipo de retorno"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Revisar, refinar e validar o diagrama completo",
                                  "subSteps": [
                                    "Revise todas as notações: '-' privado, '+' público, sublinhados em estáticos.",
                                    "Verifique divisões de compartimentos e alinhamento geral.",
                                    "Adicione título ao diagrama: 'Diagrama de Classes UML - Padrão Singleton'.",
                                    "Exporte ou fotografe o diagrama para portfólio.",
                                    "Compare com exemplos padrão UML de Singleton."
                                  ],
                                  "verification": "O diagrama completo atende a todos os elementos da descrição original.",
                                  "estimatedTime": "12 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação UML",
                                    "Referência UML oficial (opcional)"
                                  ],
                                  "tips": [
                                    "Zoom out para visão geral.",
                                    "Use grid/snap para alinhamento preciso."
                                  ],
                                  "learningObjective": "Garantir qualidade e conformidade total com padrões UML.",
                                  "commonMistakes": [
                                    "Ignorar sublinhados",
                                    "Compartimentos trocados"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenhe o diagrama UML para uma classe 'Logger' implementando Singleton: atributo privado estático '- instance: Logger' (sublinhado), construtor privado '- Logger()', e método público estático '+ getInstance(): Logger' (sublinhado).",
                              "finalVerifications": [
                                "Atributo 'instance' é privado, estático (sublinhado) e tipado como Singleton.",
                                "Construtor é privado ('-') sem parâmetros.",
                                "Método getInstance() é público ('+'), estático (sublinhado) com retorno Singleton.",
                                "Estrutura da classe dividida em três compartimentos corretos.",
                                "Notações de visibilidade (+/-) e sublinhados aplicados precisamente.",
                                "Nome da classe 'Singleton' no topo centralizado."
                              ],
                              "assessmentCriteria": [
                                "Precisão das notações de visibilidade (+ público, - privado).",
                                "Correta representação de elementos estáticos via sublinhado.",
                                "Estrutura da caixa de classe com compartimentos exatos.",
                                "Legibilidade e alinhamento visual do diagrama.",
                                "Conformidade com a descrição: todos elementos presentes.",
                                "Ausência de elementos extras ou incorretos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de unicidade e funções (análoga a funções injetoras).",
                                "Design Gráfico: Uso de símbolos visuais e hierarquia informacional.",
                                "Arquitetura de Software: Documentação de padrões de projeto.",
                                "Lógica Computacional: Controle de acesso e encapsulamento."
                              ],
                              "realWorldApplication": "Diagramas UML de Singleton são usados em equipes de desenvolvimento para documentar classes que garantem uma única instância, como gerenciadores de conexão de banco de dados, caches de aplicação ou sistemas de logging em softwares empresariais, facilitando comunicação e implementação em projetos reais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.3.2.2",
                            "name": "Interpretar relações no diagrama",
                            "description": "Analisar as associações e dependências no diagrama UML do Singleton, identificando como o método estático atua como ponto de acesso global sem herança ou composição explícita.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar componentes principais da classe Singleton no diagrama UML",
                                  "subSteps": [
                                    "Localize o retângulo representando a classe Singleton e anote seu nome",
                                    "Identifique os atributos privados, como a variável estática 'instance'",
                                    "Liste os métodos visíveis, destacando o construtor privado",
                                    "Observe multiplicidades e visibilidades (+ para público, - para privado)",
                                    "Desenhe um esboço simplificado da classe em papel"
                                  ],
                                  "verification": "Crie uma lista anotada dos componentes principais com visibilidades corretas",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagrama UML do Singleton",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Foquem nas caixas de atributos e métodos; ignore notas inicialmente",
                                  "learningObjective": "Reconhecer a estrutura básica da classe no diagrama UML Singleton",
                                  "commonMistakes": "Confundir visibilidade de atributos (privados vs públicos) ou ignorar a variável estática"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o construtor privado e sua implicação nas relações",
                                  "subSteps": [
                                    "Examine o símbolo do construtor com sinal de menos (-) indicando privacidade",
                                    "Trace dependências: note ausência de setas de composição ou agregação para o construtor",
                                    "Explique verbalmente por que o construtor privado previne instanciação externa",
                                    "Compare com classes normais que têm construtores públicos",
                                    "Anote como isso força o uso de um método alternativo para acesso"
                                  ],
                                  "verification": "Explique em uma frase curta o papel do construtor privado na prevenção de múltiplas instâncias",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Diagrama UML do Singleton",
                                    "Ferramenta de desenho UML como Draw.io (opcional)"
                                  ],
                                  "tips": "Pense no construtor como uma 'porta trancada' acessível apenas internamente",
                                  "learningObjective": "Compreender como o construtor privado estabelece dependências implícitas",
                                  "commonMistakes": "Assumir que construtor privado implica herança; ele é auto-contido"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar o método estático getInstance() como ponto de acesso global",
                                  "subSteps": [
                                    "Localize o método getInstance() com sinal de + (público) e sublinhado para estático",
                                    "Trace o fluxo: ele retorna a variável 'instance' se existir, ou cria uma",
                                    "Identifique ausência de setas de dependência externa para este método",
                                    "Simule o chamado: desenhe setas de chamada do cliente para getInstance()",
                                    "Descreva como isso cria acesso global sem passar referências"
                                  ],
                                  "verification": "Desenhe um diagrama de sequência simples mostrando o chamado de getInstance()",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama UML do Singleton",
                                    "Papel para diagrama de sequência"
                                  ],
                                  "tips": "Visualize getInstance() como um 'portal único' para a instância compartilhada",
                                  "learningObjective": "Analisar como o método estático fornece acesso singleton sem herança",
                                  "commonMistakes": "Confundir método estático com herança; não há seta de generalização"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar relações gerais: associações, dependências e ausência de herança/composição",
                                  "subSteps": [
                                    "Procure setas de associação: note que não há composição (diamante cheio) ou agregação",
                                    "Identifique dependências implícitas via getInstance() sem setas explícitas",
                                    "Confirme ausência de seta triangular para herança (generalização)",
                                    "Explique o padrão: controle via static sem relações estruturais explícitas",
                                    "Compare com outros padrões UML para contrastar"
                                  ],
                                  "verification": "Resuma em bullet points as relações chave e ausências no diagrama",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagrama UML do Singleton",
                                    "Exemplos de diagramas UML de outros padrões"
                                  ],
                                  "tips": "Use cores para destacar relações presentes vs ausentes",
                                  "learningObjective": "Integrar análise para entender o design relacional do Singleton",
                                  "commonMistakes": "Inventar relações não mostradas, como herança inexistente"
                                }
                              ],
                              "practicalExample": "No diagrama UML de um Logger Singleton para um app de e-commerce, a classe Logger possui atributo privado estático 'instance', construtor privado Logger(), e método público estático getInstance() que retorna a instância única. Clientes chamam Logger.getInstance().log('pedido criado') sem herança ou composição, garantindo logs centralizados globalmente.",
                              "finalVerifications": [
                                "Explicar verbalmente o fluxo de getInstance() sem referências a herança",
                                "Identificar corretamente todas as visibilidades no diagrama",
                                "Desenhar esboço reproduzindo relações chave sem erros",
                                "Discutir por que não há setas de composição ou generalização",
                                "Simular instanciação dupla e explicar falha via construtor privado",
                                "Comparar acesso Singleton com classe normal"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de atributos e métodos (30%)",
                                "Correta interpretação de visibilidades e staticidade (25%)",
                                "Análise completa de dependências implícitas (20%)",
                                "Explicação clara da ausência de herança/composição (15%)",
                                "Qualidade do esboço e síntese final (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos para nós (classes) e arestas (relações)",
                                "Design Gráfico: Princípios de notação visual em diagramas UML",
                                "Sistemas de Informação: Modelagem de dados com restrições de unicidade",
                                "Lógica: Análise de dependências condicionais em fluxos estáticos"
                              ],
                              "realWorldApplication": "Em sistemas de gerenciamento de banco de dados, o Singleton UML modela um ConnectionPool único, acessível via getInstance() por toda a aplicação, evitando múltiplas pools que desperdiçariam recursos e causariam inconsistências em transações globais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.3.3",
                        "name": "Implementação e Vantagens/Desvantagens",
                        "description": "Implementar o padrão Singleton em linguagens como Python ou C++, considerando thread-safety, e avaliar suas vantagens como economia de recursos e desvantagens como teste difícil e violação de princípios SOLID.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.3.3.1",
                            "name": "Implementar Singleton em Python",
                            "description": "Codificar uma classe Singleton em Python usando metaclass ou decorador, com lazy initialization e exemplo de uso para um logger, garantindo que múltiplas chamadas a getInstance() retornem a mesma instância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Padrão Singleton e Planejar a Implementação",
                                  "subSteps": [
                                    "Ler a definição do padrão Singleton: garantir uma única instância de uma classe.",
                                    "Identificar requisitos: lazy initialization, método getInstance(), exemplo com logger.",
                                    "Revisar conceitos Python: metaclasses (type) e decoradores (@property, funções).",
                                    "Estudar exemplos básicos de Singleton em Python da documentação oficial.",
                                    "Esboçar estrutura da classe: __init__ privado, getInstance() público."
                                  ],
                                  "verification": "Criar um diagrama ou notas resumindo os componentes chave do Singleton.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE Python (VS Code, PyCharm)",
                                    "Documentação Python: metaclasses e decoradores"
                                  ],
                                  "tips": "Anote prós (controle de instância) e contras (dificulta testes, thread-safety).",
                                  "learningObjective": "Dominar os fundamentos teóricos do Singleton para implementação prática.",
                                  "commonMistakes": [
                                    "Ignorar lazy loading, criando instância no módulo.",
                                    "Confundir com módulos Python que já são singletons por natureza."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Singleton usando Metaclass com Lazy Initialization",
                                  "subSteps": [
                                    "Definir uma metaclass SingletonMeta que sobrescreve __call__.",
                                    "Na metaclass, verificar se _instance existe; se não, criar com super().__call__(*args, **kwargs).",
                                    "Na classe Logger, definir __metaclass__ = SingletonMeta e tornar __init__ privado (_Logger__init__).",
                                    "Adicionar método getInstance() que retorna self se instância única.",
                                    "Implementar métodos logger: log(message) que printa timestamp + message."
                                  ],
                                  "verification": "Executar código: id(Logger()) == id(Logger()) deve ser True.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python 3.x instalado",
                                    "REPL ou script teste (test_singleton.py)"
                                  ],
                                  "tips": "Use cls._instance = None no início para lazy init.",
                                  "learningObjective": "Aplicar metaclasses para controlar instanciação de classes.",
                                  "commonMistakes": [
                                    "Não retornar a instância armazenada no __call__.",
                                    "Permitir múltiplas criações via new().__init__."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Singleton Alternativo usando Decorador",
                                  "subSteps": [
                                    "Criar decorador singleton(cls) que define _instance = None.",
                                    "No decorador, definir get_instance() com lógica lazy: if not cls._instance: cls._instance = cls().",
                                    "Aplicar @singleton na classe LoggerDecorator.",
                                    "Adicionar lazy check em get_instance(): retorna cls._instance ou cria.",
                                    "Implementar log() similar ao step anterior."
                                  ],
                                  "verification": "Testar: logger1 = LoggerDecorator.get_instance(); logger2 = LoggerDecorator.get_instance(); assert logger1 is logger2.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmo IDE e script de teste",
                                    "Exemplos de decoradores da PEP 318"
                                  ],
                                  "tips": "Decoradores são mais legíveis que metaclasses para iniciantes.",
                                  "learningObjective": "Usar decoradores para modificar comportamento de classes dinamicamente.",
                                  "commonMistakes": [
                                    "Não usar 'is' para comparação de identidade.",
                                    "Criar instância global em vez de por classe."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar o Singleton com Exemplo de Logger",
                                  "subSteps": [
                                    "Criar script de teste: múltiplas chamadas getInstance() e verificar id() iguais.",
                                    "Simular uso real: log mensagens de diferentes módulos simulados.",
                                    "Verificar lazy init: print se __init__ chamado só uma vez.",
                                    "Adicionar thread-safety básico com threading.Lock() no getInstance().",
                                    "Executar testes em loop para simular app real."
                                  ],
                                  "verification": "Todos testes passam: 100% cobertura de casos únicos e lazy.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Biblioteca unittest ou pytest",
                                    "Módulo threading para testes avançados"
                                  ],
                                  "tips": "Use assert logger1 is logger2, não ==.",
                                  "learningObjective": "Validar implementação com testes robustos.",
                                  "commonMistakes": [
                                    "Usar == em vez de is para identidade.",
                                    "Esquecer import de threading em ambientes multi-thread."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma classe LoggerSingleton para um app web: múltiplos módulos chamam LoggerSingleton.get_instance().log('Erro no login') e todos usam o MESMO logger, evitando duplicação de arquivos de log.",
                              "finalVerifications": [
                                "Múltiplas chamadas a getInstance() retornam id() idêntico.",
                                "Lazy initialization: __init__ executa apenas na primeira chamada.",
                                "Método log() funciona corretamente na instância única.",
                                "Sem erros em testes multi-thread básicos.",
                                "Código limpo, sem warnings de linter (pylint).",
                                "Exemplo de logger persiste estado (ex: contador de logs)."
                              ],
                              "assessmentCriteria": [
                                "Implementação correta via metaclass OU decorador com lazy init.",
                                "Testes unitários cobrem casos de uso único e múltiplo.",
                                "Código segue PEP 8 e é legível.",
                                "Verificação de identidade com 'is' e id().",
                                "Inclui exemplo prático de logger funcional.",
                                "Documentação inline nos métodos chave."
                              ],
                              "crossCurricularConnections": [
                                "Design de Software: Outros padrões GoF (Factory, Observer).",
                                "Sistemas Operacionais: Gerenciamento de recursos exclusivos (mutexes).",
                                "Matemática: Teoria de Conjuntos (unicidade de elementos).",
                                "Banco de Dados: Conexões singleton para pools.",
                                "Arquitetura de Software: Microservices com config global."
                              ],
                              "realWorldApplication": "Singleton é usado em frameworks como Django para caches globais, conexões de banco únicas (evita overhead), loggers centrais em apps empresariais, e gerenciadores de configuração para garantir consistência em toda a aplicação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.3.3.2",
                            "name": "Implementar Singleton thread-safe",
                            "description": "Adaptar a implementação para ambientes multithread, utilizando locks em Python (threading.Lock) ou double-checked locking em C++, para evitar criação múltipla de instâncias em acessos concorrentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Problema de Thread-Safety no Singleton",
                                  "subSteps": [
                                    "Revise a implementação básica do Singleton (lazy initialization sem sincronização).",
                                    "Simule cenários multithread: duas threads chamando getInstance() simultaneamente.",
                                    "Analise como isso pode levar à criação de múltiplas instâncias devido à race condition na verificação 'if instance is None'.",
                                    "Estude conceitos de atomicidade e critical sections em programação concorrente.",
                                    "Compare com single-threaded onde não há problema."
                                  ],
                                  "verification": "Desenhe um diagrama de sequência mostrando race condition e confirme que múltiplas instâncias seriam criadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Python threading",
                                    "Documentação C++ std::mutex",
                                    "Ferramenta de diagrama como Draw.io"
                                  ],
                                  "tips": "Use prints ou logs para visualizar o fluxo em um exemplo simples.",
                                  "learningObjective": "Identificar e explicar race conditions no Singleton padrão.",
                                  "commonMistakes": [
                                    "Ignorar o timing das threads",
                                    "Confundir com problemas de memória compartilhada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Singleton Thread-Safe em Python com threading.Lock",
                                  "subSteps": [
                                    "Importe threading e crie uma Lock global ou de classe.",
                                    "Modifique getInstance(): acquire lock antes da verificação 'if instance is None', crie instância se necessário, release lock.",
                                    "Torne a classe thread-safe usando @classmethod para getInstance.",
                                    "Adicione logging para rastrear chamadas e instâncias criadas.",
                                    "Teste basicamente com uma thread para validar funcionalidade básica."
                                  ],
                                  "verification": "Execute código com uma thread e confirme que uma única instância é criada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "Editor como VS Code",
                                    "Biblioteca threading"
                                  ],
                                  "tips": "Use context manager 'with lock:' para evitar forget release.",
                                  "learningObjective": "Criar uma implementação thread-safe usando locks explícitos.",
                                  "commonMistakes": [
                                    "Esquecer de release o lock",
                                    "Colocar lock fora da verificação condicional"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Singleton Thread-Safe em C++ com Double-Checked Locking",
                                  "subSteps": [
                                    "Inclua <mutex> e use std::mutex para lock.",
                                    "Implemente getInstance() com double-check: primeiro if sem lock, se null então lock, segundo if com lock, crie com new se ainda null, unlock.",
                                    "Use std::unique_ptr ou static local para gerenciamento de memória.",
                                    "Considere ordem de inicialização de variáveis estáticas (Meyers' Singleton como alternativa).",
                                    "Compile e teste sintaxe básica."
                                  ],
                                  "verification": "Compilar sem erros e chamar getInstance() múltiplas vezes retornando mesmo ponteiro.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "g++ ou clang++",
                                    "C++11 ou superior",
                                    "Editor com suporte C++"
                                  ],
                                  "tips": "Prefira std::call_once para simplicidade em C++11+ como alternativa ao DCL.",
                                  "learningObjective": "Aplicar double-checked locking para otimização de performance.",
                                  "commonMistakes": [
                                    "Não usar volatile ou atomic para pointer em DCL clássico",
                                    "Problemas de reordenação de CPU"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar em Ambiente Multithread",
                                  "subSteps": [
                                    "Crie 10-20 threads que chamam getInstance() simultaneamente.",
                                    "Use threading.Thread em Python ou std::thread em C++.",
                                    "Conte instâncias criadas via contador ou endereço de memória.",
                                    "Execute múltiplas rodadas e meça performance (tempo de first access).",
                                    "Compare com implementação não thread-safe para demonstrar falha."
                                  ],
                                  "verification": "Todas as threads retornam a mesma instância; contador mostra exatamente 1 criação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python multiprocessing ou concurrent.futures",
                                    "C++ <thread> e <future>",
                                    "Profiler como timeit"
                                  ],
                                  "tips": "Use join() em todas threads para garantir conclusão antes de verificar.",
                                  "learningObjective": "Validar corretude e performance em cenários concorrentes reais.",
                                  "commonMistakes": [
                                    "Poucas threads ou sem randomização de timing",
                                    "Não sincronizar verificação final"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um Singleton Logger thread-safe para uma aplicação web server: múltiplas requisições HTTP (threads) logam mensagens sem criar múltiplos arquivos de log ou corromper saída.",
                              "finalVerifications": [
                                "Apenas uma instância global é criada apesar de 100+ acessos concorrentes.",
                                "Todos os logs de threads são consistentes e sem duplicatas/corrupção.",
                                "Performance: lock overhead < 10% comparado a non-thread-safe em benchmarks.",
                                "Memória: sem leaks detectados por valgrind (C++) ou objgraph (Python).",
                                "Compilação/execução sem warnings de race conditions em tools como ThreadSanitizer.",
                                "Fallback: funciona corretamente em single-thread."
                              ],
                              "assessmentCriteria": [
                                "Código usa sincronização correta (lock ou atomic) sem deadlocks.",
                                "Testes multithread passam 100% das vezes (reprodutível).",
                                "Explicação clara de por quê a solução resolve race condition.",
                                "Otimização presente (ex: double-check ou call_once).",
                                "Documentação inline sobre trade-offs (performance vs simplicidade).",
                                "Código limpo, legível e segue boas práticas de cada linguagem."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Gerenciamento de threads e primitivas de sincronização.",
                                "Algoritmos: Análise de complexidade em cenários concorrentes (O(1) amortized).",
                                "Engenharia de Software: Padrões de design e responsabilidade única.",
                                "Segurança da Informação: Evitar condições de corrida que levam a vulnerabilidades."
                              ],
                              "realWorldApplication": "Em servidores web como Apache/Nginx (C++) ou Django/Flask (Python), gerenciando caches globais, pools de conexões DB ou configurações compartilhadas, garantindo consistência em alta concorrência sem overhead excessivo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.3.3.3",
                            "name": "Avaliar prós e contras do Singleton",
                            "description": "Discutir vantagens como controle global único e desvantagens como acoplamento global, dificuldade em unit tests e antipattern em excesso, com referências à bibliografia de Larman e Saraiva.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o conceito e implementação básica do Padrão Singleton",
                                  "subSteps": [
                                    "Ler a definição do Singleton: classe com instância única acessível globalmente.",
                                    "Analisar código de implementação thread-safe (ex: lazy initialization com double-checked locking).",
                                    "Identificar componentes chave: construtor privado, método getInstance() estático.",
                                    "Executar um exemplo simples em Java ou outra linguagem OO.",
                                    "Comparar com instanciação normal de classes."
                                  ],
                                  "verification": "Implementar e executar um Singleton básico sem erros de múltiplas instâncias.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código-fonte de exemplo Singleton (Java/C#)",
                                    "Documentação GoF (Gang of Four)"
                                  ],
                                  "tips": "Use enum para implementação simples e thread-safe em Java.",
                                  "learningObjective": "Compreender a estrutura essencial do Singleton para basear a avaliação.",
                                  "commonMistakes": [
                                    "Confundir com classes estáticas",
                                    "Ignorar problemas de thread-safety"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e analisar as vantagens (prós) do Singleton",
                                  "subSteps": [
                                    "Listar prós principais: controle global único, lazy initialization, redução de overhead de memória.",
                                    "Explicar como garante uma única instância para recursos compartilhados (ex: cache, logger).",
                                    "Discutir economia de recursos em cenários de acesso único (ex: conexão de banco em apps legados).",
                                    "Analisar impacto em performance e simplicidade de acesso.",
                                    "Referenciar exemplos onde prós superam contras."
                                  ],
                                  "verification": "Elaborar uma lista de pelo menos 3 prós com justificativas e exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo ou capítulo sobre Design Patterns",
                                    "Exemplos de código com Singleton otimizado"
                                  ],
                                  "tips": "Pense em cenários reais como gerenciadores de configuração para destacar economia.",
                                  "learningObjective": "Dominar os benefícios do Singleton para uma avaliação equilibrada.",
                                  "commonMistakes": [
                                    "Superestimar economia sem considerar escalabilidade",
                                    "Ignorar que prós são contextuais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e analisar as desvantagens (contras) do Singleton",
                                  "subSteps": [
                                    "Listar contras: acoplamento global (dificulta modularidade), hard to mock em unit tests.",
                                    "Explicar problemas de teste: dependência global impede isolamento.",
                                    "Discutir antipattern em excesso: viola Single Responsibility, difícil de configurar.",
                                    "Analisar impactos em multithreading e serialização.",
                                    "Comparar com alternativas como Dependency Injection."
                                  ],
                                  "verification": "Descrever 4 contras com impactos em desenvolvimento e testes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Craig Larman 'Applying UML and Patterns'",
                                    "Artigos sobre antipatterns"
                                  ],
                                  "tips": "Simule um unit test falhando devido a Singleton para vivenciar o contra.",
                                  "learningObjective": "Reconhecer riscos do Singleton para evitar uso indevido.",
                                  "commonMistakes": [
                                    "Minimizar impacto em testes",
                                    "Confundir com problemas de estado global genérico"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar o balanço prós/contras e consultar bibliografia",
                                  "subSteps": [
                                    "Comparar prós vs contras em tabela ou matriz de decisão.",
                                    "Discutir cenários ideais (ex: logger simples) vs ruins (ex: gerenciador de estado app).",
                                    "Referenciar Larman (críticas a global state) e Saraiva (contextos brasileiros OO).",
                                    "Propor alternativas: DI, Factory, Monostate.",
                                    "Concluir com guidelines para uso responsável."
                                  ],
                                  "verification": "Produzir um relatório curto com avaliação balanceada e citações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Bibliografia: Larman e Saraiva",
                                    "Ferramenta de tabela (Excel/Google Sheets)"
                                  ],
                                  "tips": "Use matriz ponderada: pontue prós/contras de 1-10 por critério.",
                                  "learningObjective": "Capacitar-se a decidir uso do Singleton com base em evidências.",
                                  "commonMistakes": [
                                    "Viés para prós sem dados",
                                    "Omitir referências bibliográficas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de e-commerce, avalie usar Singleton para o gerenciador de configurações: pró - acesso único rápido; contra - testes de carrinho falham por mock difícil. Alternativa: injetar via DI.",
                              "finalVerifications": [
                                "Listar corretamente 3+ prós e 4+ contras do Singleton.",
                                "Explicar impacto de contras em unit tests com exemplo.",
                                "Citar Larman sobre acoplamento global e Saraiva sobre OO.",
                                "Identificar 2 cenários onde Singleton é apropriado e 2 onde evitar.",
                                "Propor alternativa viável para um contra específico.",
                                "Demonstrar balanço em tabela ou parágrafo conciso."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na lista de prós/contras (70% cobertura).",
                                "Profundidade de análise com exemplos concretos.",
                                "Uso correto de referências bibliográficas.",
                                "Equilíbrio na avaliação (não enviesado).",
                                "Clareza na comunicação e estrutura lógica.",
                                "Identificação de alternativas modernas."
                              ],
                              "crossCurricularConnections": [
                                "Testes Unitários: mock e isolamento de dependências.",
                                "Arquitetura de Software: princípios SOLID e modularidade.",
                                "Gerenciamento de Dependências: DI vs padrões globais.",
                                "Desenvolvimento Ágil: impacto em TDD e refatoração.",
                                "Ética em Programação: evitar antipatterns para código sustentável."
                              ],
                              "realWorldApplication": "Em equipes de desenvolvimento de apps empresariais (ex: bancos), avaliar Singleton para pools de conexões DB evita duplicações iniciais, mas contras em CI/CD e microsserviços levam à migração para contêineres Spring ou .NET DI, melhorando testabilidade e escalabilidade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.8.4",
                    "name": "Padrão Factory Method",
                    "description": "Padrão de projeto criacional para delegar a criação de objetos a subclasses.",
                    "individualConcepts": [
                      {
                        "id": "10.1.8.4.1",
                        "name": "Intenção e Motivação do Padrão Factory Method",
                        "description": "O Factory Method é um padrão criacional que define uma interface para criar um objeto, permitindo que subclasses decidam qual classe instanciar, delegando a criação para subclasses e promovendo polimorfismo e extensibilidade sem modificar código existente.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.4.1.1",
                            "name": "Identificar problemas resolvidos pelo Factory Method",
                            "description": "Reconhecer situações onde a criação direta de objetos leva a violações do Open-Closed Principle, como quando diferentes subclasses precisam criar objetos específicos de forma polimórfica, evitando condicionais if-else para instâncias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Open-Closed Principle (OCP)",
                                  "subSteps": [
                                    "Ler a definição oficial do OCP: classes devem estar abertas para extensão e fechadas para modificação.",
                                    "Analisar exemplos simples de código que respeitam OCP usando herança ou interfaces.",
                                    "Identificar por que modificações em classes existentes quebram extensibilidade.",
                                    "Discutir cenários onde adicionar novas funcionalidades requer alterar código existente.",
                                    "Anotar 3 exemplos pessoais de código que violam OCP."
                                  ],
                                  "verification": "Escrever uma definição em suas próprias palavras e listar 2 exemplos de violações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo sobre SOLID Principles (SOLID Wikipedia ou Refactoring.Guru)",
                                    "Editor de código para anotar exemplos"
                                  ],
                                  "tips": [
                                    "Lembre-se: OCP foca em evitar mudanças no código fonte existente ao adicionar features.",
                                    "Use diagramas UML para visualizar herança."
                                  ],
                                  "learningObjective": "Compreender o cerne do OCP e suas implicações na criação de objetos.",
                                  "commonMistakes": [
                                    "Confundir OCP com Liskov Substitution Principle.",
                                    "Ignorar que OCP se aplica a extensões via subclasses sem alterar base."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Violações na Criação Direta de Objetos",
                                  "subSteps": [
                                    "Examinar código com criação direta de objetos usando 'new' e condicionais if-else.",
                                    "Simular adição de uma nova subclasse e observar necessidade de modificar o criador.",
                                    "Mapear como if-else para instâncias viola OCP ao adicionar tipos.",
                                    "Refatorar mentalmente um exemplo simples, destacando pontos de violação.",
                                    "Listar 4 cenários comuns: criação de documentos, veículos, pagamentos ou shapes."
                                  ],
                                  "verification": "Apontar violações OCP em um código fornecido e justificar por escrito.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de código em Java/Python (GitHub repo de design patterns)",
                                    "UML tool como PlantUML"
                                  ],
                                  "tips": [
                                    "Procure por 'if (type == \"X\") return new X()' – isso é um cheiro de violação.",
                                    "Pense em polimorfismo: subclasses devem decidir seus objetos internamente."
                                  ],
                                  "learningObjective": "Reconhecer padrões de código que violam OCP devido a criação rígida de objetos.",
                                  "commonMistakes": [
                                    "Não perceber que herança sozinha não resolve se criação é hardcoded.",
                                    "Focar só em performance em vez de manutenibilidade."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Problemas Resolvidos pelo Factory Method",
                                  "subSteps": [
                                    "Estudar a motivação do Factory Method: delegar criação para subclasses.",
                                    "Comparar código antes (com if-else) e depois (com Factory Method).",
                                    "Verificar como Factory Method permite polimorfismo na criação sem modificar cliente.",
                                    "Desenhar UML de classe mostrando Creator, ConcreteCreator e Product.",
                                    "Simular adição de novo produto sem tocar no código cliente."
                                  ],
                                  "verification": "Refatorar um código violador para Factory Method e testar extensibilidade.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Refactoring.Guru Factory Method page",
                                    "IDE com debugger (IntelliJ/VS Code)"
                                  ],
                                  "tips": [
                                    "Factory Method é sobre 'quem cria o quê' ser decidido polimórficamente.",
                                    "Use abstract createProduct() na base."
                                  ],
                                  "learningObjective": "Entender como Factory Method resolve violações OCP em criação de objetos.",
                                  "commonMistakes": [
                                    "Confundir com Abstract Factory (multi-família).",
                                    "Implementar factory estática em vez de instância polimórfica."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação em Cenários Reais",
                                  "subSteps": [
                                    "Analisar 3 códigos de exemplo de repositórios open-source com/ sem Factory.",
                                    "Identificar problemas resolvidos e propor Factory Method onde ausente.",
                                    "Criar um quiz pessoal: listar 5 situações e classificar se Factory é aplicável.",
                                    "Discutir com pares ou forum se a identificação está correta.",
                                    "Documentar lições aprendidas em um relatório curto."
                                  ],
                                  "verification": "Corretamente identificar e justificar Factory em 80% dos cenários testados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "GitHub searches for 'factory method example'",
                                    "Stack Overflow threads on OCP violations"
                                  ],
                                  "tips": [
                                    "Pergunte: 'Preciso de if-else para tipos? Subclasses variam produtos?'",
                                    "Integre com outros patterns como Template Method."
                                  ],
                                  "learningObjective": "Aplicar detecção de problemas resolvidos por Factory Method autonomamente.",
                                  "commonMistakes": [
                                    "Superestimar uso: nem toda criação precisa de factory.",
                                    "Ignorar overhead de complexidade desnecessária."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um editor de documentos, uma classe DocumentCreator usa if-else para criar WordDocument, PDFDocument ou ExcelDocument baseado em string. Ao adicionar GoogleDoc, modifica-se o criador (viola OCP). Com Factory Method, subclasses como WordCreator implementam createDocument() retornando seu tipo específico, permitindo extensão sem mudanças.",
                              "finalVerifications": [
                                "Explicar OCP e como criação direta viola.",
                                "Identificar 3 violações em código fornecido.",
                                "Desenhar UML de Factory Method resolvendo um problema.",
                                "Refatorar código simples com sucesso.",
                                "Listar cenários onde Factory NÃO é necessário.",
                                "Justificar motivação em um exemplo real."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de violações OCP (90% acerto).",
                                "Clareza na justificativa de problemas resolvidos por Factory.",
                                "Qualidade do UML e refatoração proposta.",
                                "Compreensão de polimorfismo na criação.",
                                "Identificação correta de limites do pattern.",
                                "Criatividade em exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Princípios SOLID (especialmente L e D).",
                                "Padrões de Projeto Creational (Abstract Factory, Builder).",
                                "Refatoração e Code Smells (Switch Statements).",
                                "UML e Modelagem de Software.",
                                "Testes Unitários (facilitados por factories)."
                              ],
                              "realWorldApplication": "Frameworks como Spring usam Factory Methods (BeanFactory) para criar beans polimórficos sem if-else rígidos, permitindo plugins/extensões sem recompilar o core, comum em apps empresariais escaláveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.4.1.2",
                            "name": "Explicar a motivação para delegar criação a subclasses",
                            "description": "Descrever como o padrão permite que uma superclasse defina o esqueleto de um algoritmo que cria objetos, enquanto subclasses implementam a criação específica, facilitando herança e polimorfismo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o problema da criação rígida de objetos em superclasses",
                                  "subSteps": [
                                    "Identifique cenários onde uma superclasse precisa criar objetos de subclasses variáveis.",
                                    "Analise como hardcoding a criação em uma superclasse viola o princípio de abertura/fechamento (Open/Closed Principle).",
                                    "Discuta exemplos simples, como uma classe Vehicle criando Car ou Bike diretamente.",
                                    "Explique as limitações: falta de flexibilidade e acoplamento forte.",
                                    "Registre anotações sobre os problemas identificados."
                                  ],
                                  "verification": "Liste pelo menos 3 problemas causados pela criação rígida e forneça um exemplo de código problemático.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code)",
                                    "Documentação GoF Design Patterns (páginas sobre Factory Method)"
                                  ],
                                  "tips": "Use diagramas UML para visualizar o acoplamento antes e depois.",
                                  "learningObjective": "Reconhecer as limitações da criação de objetos diretamente na superclasse.",
                                  "commonMistakes": [
                                    "Confundir com Singleton (foco em instância única)",
                                    "Ignorar impacto na extensibilidade futura"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o esqueleto do algoritmo de criação na superclasse abstrata",
                                  "subSteps": [
                                    "Crie uma superclasse abstrata com um método factory template que chama passos primitivos abstratos.",
                                    "Defina métodos abstratos como createPartA(), createPartB() para delegar às subclasses.",
                                    "Implemente o método factoryMethod() que orquestra os passos sem conhecer detalhes concretos.",
                                    "Teste o esqueleto com um pseudocódigo.",
                                    "Desenhe um diagrama de classes UML mostrando a estrutura."
                                  ],
                                  "verification": "Implemente e execute um esqueleto funcional que chama métodos abstratos sem erros de compilação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE com suporte a OOP (ex: IntelliJ, Eclipse)",
                                    "Papel e caneta para diagramas UML"
                                  ],
                                  "tips": "Mantenha o esqueleto genérico; evite lógica específica de subclasses.",
                                  "learningObjective": "Entender como a superclasse define o 'como' geral sem o 'o quê' específico.",
                                  "commonMistakes": [
                                    "Implementar lógica concreta no esqueleto",
                                    "Esquecer de tornar métodos abstratos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a criação específica nas subclasses",
                                  "subSteps": [
                                    "Crie subclasses concretas (ex: ConcreteCreatorA, ConcreteCreatorB).",
                                    "Sobrescreva os métodos primitivos para retornar objetos específicos.",
                                    "Demonstre polimorfismo invocando o factoryMethod() na superclasse.",
                                    "Teste criando diferentes objetos via subclasses.",
                                    "Compare o código antes/depois para visualizar a delegação."
                                  ],
                                  "verification": "Gere objetos diferentes usando a mesma interface de superclasse, confirmando polimorfismo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Linguagem OOP (ex: Java, C#)",
                                    "Exemplos de código do livro Head First Design Patterns"
                                  ],
                                  "tips": "Use System.out.println para logar o tipo de objeto criado e verificar delegação.",
                                  "learningObjective": "Aplicar herança para personalizar criação sem alterar a superclasse.",
                                  "commonMistakes": [
                                    "Retornar tipos errados nos métodos primitivos",
                                    "Não usar super para chamar o template"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar benefícios e motivação da delegação",
                                  "subSteps": [
                                    "Liste vantagens: extensibilidade, reutilização do algoritmo, polimorfismo.",
                                    "Discuta conformidade com SOLID (especialmente Dependency Inversion e Open/Closed).",
                                    "Compare com Factory simples ou new direto.",
                                    "Resuma a motivação: 'Delegar para subclasses permite algoritmos flexíveis sem acoplamento'.",
                                    "Crie um resumo em 1 parágrafo explicando a motivação."
                                  ],
                                  "verification": "Escreva um parágrafo explicando a motivação e cite 3 benefícios com exemplos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Notas dos steps anteriores",
                                    "Artigo sobre Factory Method no Refactoring.Guru"
                                  ],
                                  "tips": "Foquem em 'por quê' usar, não só 'como'; relacione a cenários reais.",
                                  "learningObjective": "Articular claramente a motivação para delegação em termos de herança e polimorfismo.",
                                  "commonMistakes": [
                                    "Confundir motivação com Abstract Factory",
                                    "Subestimar impacto na manutenção"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um framework de GUI, a classe AbstractWindowFactory define createWindow() que chama createTitleBar() e createMenuBar(). Subclasses como WindowsWindowFactory implementam barras específicas do Windows, enquanto MacWindowFactory faz para macOS, permitindo criar janelas nativas sem alterar o framework principal.",
                              "finalVerifications": [
                                "Explica em palavras próprias por que delegar criação evita acoplamento rígido.",
                                "Identifica o papel do 'esqueleto de algoritmo' na superclasse.",
                                "Demonstra com código como subclasses personalizam sem modificar a superclasse.",
                                "Lista pelo menos 3 benefícios (herança, polimorfismo, extensibilidade).",
                                "Diferencia Factory Method de criação direta com new.",
                                "Aplica o conceito a um exemplo real como frameworks de UI."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Correta distinção entre esqueleto e passos primitivos (30%).",
                                "Clareza na explicação: Linguagem acessível e lógica sequencial (20%).",
                                "Uso de exemplos: Código/diagramas concretos e relevantes (20%).",
                                "Profundidade de benefícios: Cobertura de herança, polimorfismo e SOLID (15%).",
                                "Comparação com alternativas: Evidência de entendimento diferencial (10%).",
                                "Aplicação prática: Capacidade de contextualizar em cenários reais (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Princípios SOLID: Open/Closed e Dependency Inversion.",
                                "UML e Modelagem: Diagramas de classes para padrões de projeto.",
                                "Engenharia de Software: Manutenção e extensibilidade de código.",
                                "Interfaces GUI: Criação polimórfica de componentes visuais."
                              ],
                              "realWorldApplication": "Bibliotecas como Spring Framework usam Factory Methods para instanciar beans configuráveis por subclasses, permitindo injeção de dependências flexíveis em aplicações empresariais sem recodificação central."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.4.1.3",
                            "name": "Determinar quando usar Factory Method",
                            "description": "Avaliar cenários como criação de famílias de objetos relacionados ou quando o cliente não deve conhecer classes concretas, diferenciando de criação simples ou outros padrões criacionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Intenção e Motivação do Factory Method",
                                  "subSteps": [
                                    "Leia a definição oficial do padrão Factory Method do livro 'Design Patterns' de Gamma et al.",
                                    "Identifique os problemas resolvidos: delegar criação de objetos para subclasses e isolar o cliente das classes concretas.",
                                    "Anote exemplos de motivação: famílias de objetos relacionados e extensibilidade sem modificar código cliente.",
                                    "Compare com criação direta de objetos via 'new' para entender a necessidade de abstração.",
                                    "Resuma em suas palavras os benefícios principais: flexibilidade e aderência ao Open-Closed Principle."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando quando e por quê usar Factory Method, sem mencionar implementação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro 'Design Patterns' (capítulo Factory Method)",
                                    "Notas ou editor de texto"
                                  ],
                                  "tips": "Foque na motivação conceitual, não no código ainda; use analogias como uma fábrica de carros produzindo modelos diferentes.",
                                  "learningObjective": "Entender os princípios fundamentais que justificam o uso do Factory Method.",
                                  "commonMistakes": [
                                    "Confundir com Abstract Factory prematuramente",
                                    "Ignorar o princípio de isolamento do cliente",
                                    "Pensar apenas em performance, não em design"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Cenários Clássicos de Aplicação",
                                  "subSteps": [
                                    "Liste cenários onde há famílias de objetos relacionados, como diferentes tipos de documentos (PDF, Word) criados por um app.",
                                    "Identifique casos onde o cliente não deve conhecer classes concretas, ex: framework GUI criando botões platform-specific.",
                                    "Analise situações de criação condicional complexa, como loggers para diferentes ambientes (dev, prod).",
                                    "Crie uma tabela com colunas: Cenário, Por quê Factory Method, Alternativa simples rejeitada.",
                                    "Valide com pelo menos 3 exemplos reais de bibliotecas open-source."
                                  ],
                                  "verification": "Crie uma lista de 4 cenários onde Factory Method é ideal, justificando cada um em 1 frase.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RefCard GoF Patterns",
                                    "Exemplos de código em GitHub (buscar 'factory method example')"
                                  ],
                                  "tips": "Pergunte: 'O cliente precisa saber o tipo exato?' Se não, Factory Method pode ser candidato.",
                                  "learningObjective": "Reconhecer padrões de problemas que se beneficiam do Factory Method.",
                                  "commonMistakes": [
                                    "Aplicar em criações simples sem variação",
                                    "Ignorar famílias relacionadas",
                                    "Confundir com Singleton"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar de Criação Simples e Outros Padrões Criacionais",
                                  "subSteps": [
                                    "Compare Factory Method vs. new direto: liste prós/contras em cenários com 1 vs. múltiplas subclasses.",
                                    "Diferencie de Abstract Factory: FM para um produto, AF para famílias completas.",
                                    "Analise vs. Builder: FM para criação simples, Builder para complexa com passos.",
                                    "Crie fluxograma de decisão: 'Criação simples? -> new; Famílias? -> FM/AF; etc.'",
                                    "Teste com 2 cenários: um para FM, um para outro padrão."
                                  ],
                                  "verification": "Desenhe um fluxograma de decisão para escolher Factory Method vs. alternativas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama comparativo de padrões criacionais (RefCard)",
                                    "Ferramenta de diagrama como Draw.io"
                                  ],
                                  "tips": "Use a regra: se subclass pode definir o tipo criado, FM é perfeito.",
                                  "learningObjective": "Saber quando NÃO usar Factory Method para evitar over-engineering.",
                                  "commonMistakes": [
                                    "Usar FM para singletons ou criações triviais",
                                    "Misturar com Prototype",
                                    "Esquecer OCP"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Avaliação de Cenários Hipotéticos",
                                  "subSteps": [
                                    "Pegue 5 cenários aleatórios de apps (ex: jogo criando inimigos, app criando shapes).",
                                    "Para cada: avalie se FM aplica, justifique sim/não com critérios.",
                                    "Implemente pseudocódigo para 2 cenários positivos.",
                                    "Revise com peer ou auto-checklist: cenários cobertos? Diferenciações claras?",
                                    "Registre lições aprendidas em um journal."
                                  ],
                                  "verification": "Avalie 3 cenários fornecidos e decida uso de FM com justificativa detalhada.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Lista de cenários de exercícios online (ex: Refactoring.Guru)",
                                    "Pseudocódigo editor"
                                  ],
                                  "tips": "Sempre pergunte: 'Isso melhora extensibilidade sem quebrar clientes?'",
                                  "learningObjective": "Aplicar critérios para decidir uso de Factory Method em contextos reais.",
                                  "commonMistakes": [
                                    "Over-generalizar para todo 'new'",
                                    "Ignorar custo de complexidade",
                                    "Não considerar manutenção futura"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um editor de imagens, use Factory Method para criar ferramentas de desenho (Brush, Pencil, Eraser) específicas para diferentes plataformas (Windows, Mac), onde o cliente (UI) chama createTool() sem conhecer BrushWindows vs. BrushMac, permitindo adicionar novas plataformas via subclasses.",
                              "finalVerifications": [
                                "Pode listar 3 cenários onde Factory Method é essencial e 2 onde new direto basta.",
                                "Explica corretamente a diferença entre Factory Method e Abstract Factory.",
                                "Identifica violações do OCP em código sem FM.",
                                "Avalia um cenário hipotético com justificativa precisa em <2 minutos.",
                                "Cria fluxograma de decisão para padrões criacionais.",
                                "Distingue motivação de FM de Builder/Prototype."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de cenários (famílias de objetos, isolamento de classes concretas).",
                                "Clareza na diferenciação de outros padrões e criação direta.",
                                "Uso correto de princípios SOLID (especialmente OCP).",
                                "Profundidade de justificativas com exemplos concretos.",
                                "Capacidade de evitar over-engineering em casos simples.",
                                "Fluidez na aplicação a cenários novos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Árvores de decisão e fluxogramas para escolha de padrões.",
                                "Design de Sistemas: Arquitetura de software e modularidade.",
                                "Lógica Computacional: Abstração e polimorfismo.",
                                "Gestão de Projetos: Trade-offs de complexidade vs. extensibilidade."
                              ],
                              "realWorldApplication": "Frameworks como Spring usam Factory Methods para instanciar beans configuráveis dinamicamente; jogos como Unity criam entidades (inimigos, itens) via factories para suportar mods sem recompilar o core."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.4.2",
                        "name": "Estrutura e Participantes do Padrão",
                        "description": "A estrutura envolve quatro papéis principais: Product (interface para objetos criados), ConcreteProduct (implementações específicas), Creator (declara factory method) e ConcreteCreator (implementa o método para retornar ConcreteProduct).",
                        "specificSkills": [
                          {
                            "id": "10.1.8.4.2.1",
                            "name": "Identificar os papéis das classes no Factory Method",
                            "description": "Mapear Creator como classe que declara o método factoryMethod() retornando Product, ConcreteCreator sobrescrevendo para retornar instâncias de ConcreteProduct, e Product como interface comum.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição e estrutura geral do Factory Method Pattern",
                                  "subSteps": [
                                    "Leia a definição oficial do padrão Factory Method do livro 'Design Patterns' ou documentação equivalente.",
                                    "Identifique os componentes principais: Product, ConcreteProduct, Creator e ConcreteCreator.",
                                    "Desenhe um esboço simples do diagrama de classes UML sem detalhes.",
                                    "Anote as responsabilidades gerais de cada componente.",
                                    "Compare com exemplos básicos online para confirmação."
                                  ],
                                  "verification": "Confirme se o esboço UML contém os quatro componentes principais sem erros de nomenclatura.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro 'Design Patterns' ou site Refactoring.Guru",
                                    "Papel e caneta ou ferramenta UML como Lucidchart"
                                  ],
                                  "tips": "Comece pelo overview para contextualizar; evite mergulhar em código ainda.",
                                  "learningObjective": "Compreender os blocos fundamentais do padrão antes de mapear papéis específicos.",
                                  "commonMistakes": [
                                    "Confundir Factory Method com Abstract Factory",
                                    "Ignorar a hierarquia de herança"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o papel do Product e ConcreteProduct",
                                  "subSteps": [
                                    "Examine a interface ou classe abstrata Product: ela define o produto criado.",
                                    "Identifique ConcreteProduct como implementações concretas que estendem Product.",
                                    "Marque no diagrama UML a seta de realização (realization) de ConcreteProduct para Product.",
                                    "Liste métodos comuns no Product, como 'operation()'.",
                                    "Teste conceitualmente: 'O client usa Product sem saber o ConcreteProduct'."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito: 'Product é a interface comum para produtos'.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama UML em progresso",
                                    "Exemplo de código Factory Method em Java/Python"
                                  ],
                                  "tips": "Pense em Product como um contrato que garante polimorfismo.",
                                  "learningObjective": "Mapear precisamente os papéis do produto no padrão.",
                                  "commonMistakes": [
                                    "Achar que Product cria algo",
                                    "Esquecer que ConcreteProduct é instanciado pelo Creator"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o papel do Creator e ConcreteCreator",
                                  "subSteps": [
                                    "Identifique Creator: classe abstrata que declara factoryMethod() retornando Product.",
                                    "Note que ConcreteCreator sobrescreve factoryMethod() para retornar ConcreteProduct específico.",
                                    "Adicione ao diagrama UML: método factoryMethod() em Creator e override em ConcreteCreator.",
                                    "Explique o fluxo: Client chama factoryMethod() no Creator, recebe Product polimórfico.",
                                    "Diferencie: Creator gerencia criação, não conhece ConcreteProduct."
                                  ],
                                  "verification": "Simule o fluxo em pseudocódigo: Creator.factoryMethod() -> retorna Product.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta UML",
                                    "Pseudocódigo editor como VS Code"
                                  ],
                                  "tips": "Foco no 'factoryMethod()' como o coração do padrão.",
                                  "learningObjective": "Distinguir responsabilidades do Creator na delegação de criação.",
                                  "commonMistakes": [
                                    "Confundir Creator com Product",
                                    "Pensar que ConcreteCreator usa new Product() diretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Mapear e validar todos os papéis em um diagrama completo",
                                  "subSteps": [
                                    "Integre todos os componentes no diagrama UML final com associações corretas.",
                                    "Adicione rótulos explicando papéis: 'Creator declara factoryMethod()', etc.",
                                    "Compare com um diagrama referência oficial.",
                                    "Crie uma tabela resumindo: Classe | Papel | Responsabilidade.",
                                    "Teste explicando para um 'parceiro de estudo' imaginário."
                                  ],
                                  "verification": "O diagrama final corresponde 100% ao padrão padrão UML do Factory Method.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta UML completa como PlantUML ou Draw.io",
                                    "Diagrama referência do GoF"
                                  ],
                                  "tips": "Use cores para diferenciar abstrato (azul) e concreto (verde).",
                                  "learningObjective": "Consolidar o mapeamento completo dos papéis das classes.",
                                  "commonMistakes": [
                                    "Setas erradas na UML (use herança e realization corretas)",
                                    "Omitir factoryMethod()"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de fabricação de veículos: Product é interface Vehicle com método drive(); ConcreteProduct: Car e Motorcycle implementam; Creator: VehicleFactory com factoryMethod() retornando Vehicle; ConcreteCreator: CarFactory sobrescreve para new Car(), MotorcycleFactory para new Motorcycle(). Client usa VehicleFactory.factoryMethod() sem saber se é Car ou Motorcycle.",
                              "finalVerifications": [
                                "Pode desenhar o diagrama UML dos 4 componentes corretamente em <5 minutos?",
                                "Explica verbalmente o papel de cada classe sem hesitação?",
                                "Identifica corretamente factoryMethod() como o método chave no Creator?",
                                "Diferencia Product de Creator em uma frase?",
                                "Simula o fluxo de criação com um exemplo simples?",
                                "Detecta erros em um diagrama UML fornecido com papéis trocados?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de papéis (100% correto: Product, ConcreteProduct, Creator, ConcreteCreator)",
                                "Correção do diagrama UML (herança, realization, método factoryMethod())",
                                "Clareza na explicação de responsabilidades e fluxo polimórfico",
                                "Uso de terminologia padrão (ex: 'declara factoryMethod()')",
                                "Capacidade de aplicar em exemplo prático sem erros",
                                "Detecção de equívocos comuns como confusão com outros padrões"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstração e polimorfismo semelhantes a funções genéricas",
                                "Design Gráfico: Analogia com templates em interfaces GUI",
                                "Engenharia de Software: Princípios SOLID (Dependency Inversion)",
                                "Lógica: Fluxo de controle condicional via herança",
                                "Negócios: Modelagem de processos fabris escaláveis"
                              ],
                              "realWorldApplication": "Em frameworks como Spring (fábricas de beans), editores de imagem (fábricas de filtros: BlurFilterFactory cria BlurFilter), ou jogos (WeaponFactory cria Sword ou Gun polimórficos), permitindo extensibilidade sem alterar código cliente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.4.2.2",
                            "name": "Desenhar diagrama UML da estrutura",
                            "description": "Criar diagrama de classes UML mostrando abstrações, herança de Creator para ConcreteCreator, Product para ConcreteProduct, e seta de dependência do factoryMethod() para Product.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e esboçar as classes abstratas principais",
                                  "subSteps": [
                                    "Revise a estrutura do Factory Method: Creator (classe abstrata com factoryMethod()) e Product (interface ou classe abstrata).",
                                    "Desenhe retângulos para Creator e Product no canvas, rotulando-os como '<<interface>>' ou 'abstract class'.",
                                    "Adicione atributos e métodos básicos: em Creator, inclua 'factoryMethod(): Product'; em Product, métodos abstratos relevantes.",
                                    "Posicione Creator à esquerda e Product à direita para fluxo lógico.",
                                    "Use notação UML padrão: nome da classe em negrito no topo."
                                  ],
                                  "verification": "Verifique se Creator e Product estão desenhados com notação abstrata correta e factoryMethod() visível.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação como Draw.io ou Lucidchart",
                                    "Papel e lápis para rascunho inicial"
                                  ],
                                  "tips": "Comece com esboço à mão para visualizar antes de digitalizar.",
                                  "learningObjective": "Compreender as abstrações centrais do padrão Factory Method.",
                                  "commonMistakes": "Confundir Creator com classe concreta ou omitir o tipo de retorno do factoryMethod()."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenhar as classes concretas e herança",
                                  "subSteps": [
                                    "Crie ConcreteCreator herdando de Creator: adicione seta de herança (triângulo vazio) de ConcreteCreator para Creator.",
                                    "Implemente factoryMethod() em ConcreteCreator retornando ConcreteProduct.",
                                    "Crie ConcreteProduct implementando Product: adicione seta de realização (triângulo cheio) de ConcreteProduct para Product.",
                                    "Adicione implementações concretas de métodos em ConcreteProduct.",
                                    "Ajuste posições para hierarquia visual clara."
                                  ],
                                  "verification": "Confirme setas de herança (generalização) e realização presentes e corretas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação",
                                    "Referência UML oficial (ex: uml.org)"
                                  ],
                                  "tips": "Use setas pontilhadas para dependências futuras; sólidas para herança.",
                                  "learningObjective": "Dominar relacionamentos de herança e implementação em UML.",
                                  "commonMistakes": "Usar seta errada (ex: composição em vez de herança) ou inverter direção."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar dependência do factoryMethod() e refinar o diagrama",
                                  "subSteps": [
                                    "Desenhe seta de dependência (pontilhada com seta aberta) do factoryMethod() em Creator para Product.",
                                    "Rotule a dependência como '<<create>> factoryMethod()'.",
                                    "Adicione multiplicidades se aplicável (ex: 1 para Creator retorna 1 Product).",
                                    "Inclua notas ou constraints para esclarecer o padrão.",
                                    "Limpe o diagrama: alinhe elementos, ajuste tamanhos e adicione legendas."
                                  ],
                                  "verification": "Verifique se a dependência está corretamente rotulada e conecta factoryMethod() a Product.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação",
                                    "Exemplo de diagrama Factory Method oficial"
                                  ],
                                  "tips": "A dependência mostra 'usa' sem herança forte; evite solidificar.",
                                  "learningObjective": "Representar dinâmicas de criação via dependências UML.",
                                  "commonMistakes": "Fazer dependência bidirecional ou usar associação em vez de dependência."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e finalizar o diagrama",
                                  "subSteps": [
                                    "Compare com diagrama oficial do Factory Method (GoF).",
                                    "Teste legibilidade: imprima ou exporte e revise à distância.",
                                    "Adicione título, versão e data ao diagrama.",
                                    "Documente explicações breves para cada elemento.",
                                    "Salve em formato editável e PDF."
                                  ],
                                  "verification": "Diagrama corresponde 100% à estrutura: abstrações, herança e dependência.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Diagrama oficial Factory Method",
                                    "Ferramenta de exportação PDF"
                                  ],
                                  "tips": "Use zoom out para checar balanceamento visual.",
                                  "learningObjective": "Garantir precisão e profissionalismo em diagramas UML.",
                                  "commonMistakes": "Ignorar multiplicidades ou constraints que afetam o padrão."
                                }
                              ],
                              "practicalExample": "Em um sistema de criação de documentos: Creator é DocumentCreator (abstract com factoryMethod(): Document); ConcreteCreator é PDFCreator (retorna PDFDocument); Product é Document (interface com render()); ConcreteProduct é PDFDocument (implementa render() com PDF-specific logic). Desenhe mostrando herança PDFCreator -> DocumentCreator e dependência factoryMethod() -> Document.",
                              "finalVerifications": [
                                "Creator possui factoryMethod() retornando Product.",
                                "ConcreteCreator herda corretamente de Creator.",
                                "ConcreteProduct implementa Product.",
                                "Seta de dependência pontilhada de factoryMethod() para Product.",
                                "Notação UML padrão usada em todas classes e relacionamentos.",
                                "Diagrama é legível e bem organizado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na representação de abstrações e concretas (30%)",
                                "Correção de setas e relacionamentos UML (25%)",
                                "Clareza visual e legibilidade (20%)",
                                "Inclusão de dependência factoryMethod() (15%)",
                                "Refinamentos como labels e constraints (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Design de Software: Integra com outros padrões GoF como Abstract Factory.",
                                "Programação: Mapeia diretamente para código OOP em Java/C++.",
                                "Análise de Sistemas: Útil em modelagem de requisitos e arquitetura.",
                                "Engenharia de Software: Essencial para documentação de projetos ágeis."
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps como editores de imagem (ex: fábrica de filtros: BlurFilterCreator cria BlurFilterProduct), permitindo extensibilidade sem modificar código cliente, comum em frameworks como Spring ou bibliotecas GUI."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.4.2.3",
                            "name": "Interpretar interações no diagrama de sequência",
                            "description": "Analisar diagrama de sequência UML onde cliente invoca factoryMethod() no Creator, que delega à subclasse para criar e retornar o Product polimórfico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar Participantes e Lifelines no Diagrama",
                                  "subSteps": [
                                    "Examine o eixo horizontal para localizar lifelines: Client (esquerda), Creator, ConcreteCreator (subclasse), Product.",
                                    "Identifique caixas de objeto no topo de cada lifeline com nomes e tipos (ex: :Creator, :CircleFactory).",
                                    "Observe retângulos de ativação nas lifelines para indicar períodos ativos.",
                                    "Note setas de mensagens entre lifelines e suas direções (esquerda-direita ou retorno).",
                                    "Marque participantes inativos ou opcionais no Factory Method padrão."
                                  ],
                                  "verification": "Liste todos os participantes com seus papéis (Client, Creator, ConcreteCreator, Product) e desenhe os lifelines.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagrama de sequência UML do Factory Method",
                                    "Papel e caneta ou ferramenta de diagrama como Lucidchart"
                                  ],
                                  "tips": "Comece sempre pelo Client na esquerda; ignore mensagens secundárias inicialmente.",
                                  "learningObjective": "Reconhecer e nomear os papéis estruturais do padrão Factory Method em UML.",
                                  "commonMistakes": [
                                    "Confundir Creator com ConcreteCreator",
                                    "Ignorar lifelines vazias como indício de delegação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Chamada Inicial e Delegação do factoryMethod()",
                                  "subSteps": [
                                    "Rastreie a seta síncrona do Client para Creator rotulada 'factoryMethod()'.",
                                    "Siga para o retângulo de ativação no Creator indicando processamento.",
                                    "Identifique a mensagem de delegação do Creator para ConcreteCreator (ex: chamada virtual ou polimórfica).",
                                    "Observe parâmetros passados, como tipo de produto desejado.",
                                    "Confirme ausência de conhecimento direto do ConcreteProduct pelo Creator."
                                  ],
                                  "verification": "Descreva verbalmente ou anote o fluxo: Client -> Creator.factoryMethod() -> ConcreteCreator.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de sequência",
                                    "Folha de anotações para fluxos"
                                  ],
                                  "tips": "Foco em setas sólidas para chamadas síncronas; use seta tracejada para retornos.",
                                  "learningObjective": "Entender como o Creator delega criação sem especificar classe concreta.",
                                  "commonMistakes": [
                                    "Assumir que Creator cria diretamente",
                                    "Perder a seta de delegação interna"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar Criação Polimórfica e Retorno do Product",
                                  "subSteps": [
                                    "Localize no ConcreteCreator a criação do ConcreteProduct (ex: new Circle()).",
                                    "Rastreie o retorno ascendente: ConcreteProduct -> Product (upcast polimórfico) -> Creator -> Client.",
                                    "Identifique setas de retorno tracejadas com tipo Product.",
                                    "Verifique interações subsequentes do Client com o Product retornado.",
                                    "Confirme encapsulamento: Client usa apenas interface Product."
                                  ],
                                  "verification": "Simule o fluxo em voz alta, mencionando tipos polimórficos em cada retorno.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama ampliado",
                                    "Simulador UML online como PlantUML"
                                  ],
                                  "tips": "Pinte setas de retorno em azul para visualizar o fluxo reverso claramente.",
                                  "learningObjective": "Compreender polimorfismo na criação e retorno de objetos.",
                                  "commonMistakes": [
                                    "Ignorar upcast para Product",
                                    "Confundir retorno com nova chamada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Interações Completas e Dinâmica do Padrão",
                                  "subSteps": [
                                    "Reconstrua a sequência temporal completa de mensagens de cima para baixo.",
                                    "Analise lifetime dos objetos: criação, uso e destruição implícita.",
                                    "Identifique benefícios: desacoplamento Client-Product via Creator.",
                                    "Compare com diagrama de classes para validar consistência.",
                                    "Anote loops ou condições opcionais se presentes no diagrama."
                                  ],
                                  "verification": "Crie um resumo escrito do fluxo dinâmico em 5-7 linhas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagrama original e resumo de classes Factory Method",
                                    "Template de resumo"
                                  ],
                                  "tips": "Use timeline vertical para ordenar eventos precisamente.",
                                  "learningObjective": "Sintetizar a dinâmica completa do Factory Method em sequência UML.",
                                  "commonMistakes": [
                                    "Focar só em criação, ignorando uso posterior",
                                    "Desconsiderar ordem temporal"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app de editor gráfico, Client (EditorUI) invoca ShapeFactory.factoryMethod('circle'), que delega para CircleFactory criando Circle (Product). Client recebe Circle via interface Shape e chama draw() para renderizar.",
                              "finalVerifications": [
                                "Liste corretamente os 4 participantes principais e suas interações.",
                                "Explique o papel da delegação polimórfica do Creator.",
                                "Descreva o fluxo de retorno do Product até o Client.",
                                "Identifique pelo menos 2 benefícios do padrão observados no diagrama.",
                                "Simule verbalmente o diagrama sem olhar para ele.",
                                "Compare com um diagrama de classes equivalente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de mensagens síncronas e assíncronas (100%).",
                                "Correta interpretação de polimorfismo e upcast (exemplo específico).",
                                "Compreensão de delegação sem acoplamento concreto.",
                                "Análise completa da sequência temporal sem omissões.",
                                "Uso correto de terminologia UML (lifeline, ativação, retorno).",
                                "Síntese de dinâmica e benefícios do padrão."
                              ],
                              "crossCurricularConnections": [
                                "Princípios OOP: Polimorfismo e Abstração.",
                                "Padrões de Projeto: Relação com Abstract Factory e Builder.",
                                "Análise de Sistemas: Modelagem dinâmica em engenharia de software.",
                                "Lógica Computacional: Fluxo de controle e delegação.",
                                "Design UI/UX: Criação dinâmica de componentes gráficos."
                              ],
                              "realWorldApplication": "Frameworks como Spring IoC usam factories para instanciar beans polimórficos dinamicamente baseados em configurações, permitindo injeção de dependências sem acoplamento rígido em apps empresariais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.4.3",
                        "name": "Implementação e Aplicação Prática",
                        "description": "Implementação envolve definir o método factory na classe base e sobrescrevê-lo nas subclasses para criar objetos específicos, aplicável em linguagens como Python ou C++ com herança e polimorfismo.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.4.3.1",
                            "name": "Implementar classe Creator com factory method",
                            "description": "Criar classe abstrata Creator com método abstrato factoryMethod() que retorna interface Product, e método de negócio que usa o produto criado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a Interface Product e Implementações Concretas",
                                  "subSteps": [
                                    "Crie a interface Product com um método abstrato relevante, como 'void use()'.",
                                    "Implemente ConcreteProductA que retorna Product com implementação específica (ex: 'Usando Produto A').",
                                    "Implemente ConcreteProductB similarmente (ex: 'Usando Produto B').",
                                    "Teste cada implementação individualmente em um método main para verificar polimorfismo.",
                                    "Garanta que as classes usem linguagem Java com package e imports corretos."
                                  ],
                                  "verification": "Compilar e executar ConcreteProductA e ConcreteProductB sem erros, confirmando saída correta via console.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE (IntelliJ ou Eclipse)",
                                    "JDK 11+",
                                    "Editor de texto para diagramas UML opcionais"
                                  ],
                                  "tips": "Mantenha os métodos simples para focar no papel do Product; use System.out.println para depuração visual.",
                                  "learningObjective": "Compreender o contrato do Product como base para o polimorfismo no Factory Method.",
                                  "commonMistakes": [
                                    "Esquecer de implementar todos os métodos da interface",
                                    "Não testar polimorfismo individualmente",
                                    "Usar classes concretas em vez de interface"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar a Classe Abstrata Creator com Factory Method Abstrato",
                                  "subSteps": [
                                    "Declare 'public abstract class Creator'.",
                                    "Adicione 'public abstract Product factoryMethod();' como método abstrato.",
                                    "Implemente um método de negócio esqueleto, como 'public void someOperation() { Product product = factoryMethod(); product.use(); }'.",
                                    "Adicione comentários Javadoc explicando o uso do factoryMethod no contexto do padrão.",
                                    "Compile a classe para verificar abstração."
                                  ],
                                  "verification": "Creator compila como classe abstrata; tentativa de instanciar falha com erro de compilação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE com suporte a Java",
                                    "Documentação do Padrão Factory Method (GoF)"
                                  ],
                                  "tips": "O factoryMethod deve ser simples e retornar apenas a interface Product para promover abstração.",
                                  "learningObjective": "Estabelecer a estrutura da Creator que delega a criação para subclasses.",
                                  "commonMistakes": [
                                    "Tornar factoryMethod concreto em vez de abstrato",
                                    "Não usar o produto no método de negócio",
                                    "Esquecer modificador 'abstract'"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Subclasses Concretas de Creator",
                                  "subSteps": [
                                    "Crie 'ConcreteCreatorA extends Creator' e override 'public Product factoryMethod() { return new ConcreteProductA(); }'.",
                                    "Crie 'ConcreteCreatorB extends Creator' similarmente para ConcreteProductB.",
                                    "Adicione construtores vazios ou parâmetros opcionais nas subclasses.",
                                    "Teste compilação das subclasses.",
                                    "Verifique herança via IDE (Ctrl+H hierarchy)."
                                  ],
                                  "verification": "Subclasses compilam e override factoryMethod é reconhecido; chamada someOperation() em instância imprime saída correta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE",
                                    "Exemplos de código Factory Method"
                                  ],
                                  "tips": "Use nomes claros como ConcreteCreator para reforçar o padrão; evite lógica extra no factoryMethod.",
                                  "learningObjective": "Implementar variações concretas que encapsulam a criação específica.",
                                  "commonMistakes": [
                                    "Não usar 'override' annotation",
                                    "Retornar tipo concreto em vez de interface",
                                    "Adicionar lógica desnecessária no factoryMethod"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar o Padrão Factory Method em um Cliente",
                                  "subSteps": [
                                    "Crie classe Client com método main().",
                                    "Instancie ConcreteCreatorA e chame someOperation().",
                                    "Instancie ConcreteCreatorB e chame someOperation().",
                                    "Execute e observe saídas diferentes sem condicionais no cliente.",
                                    "Refatore para usar Creator diretamente se possível (ex: via configuração)."
                                  ],
                                  "verification": "Programa executa sem erros, produzindo saídas polimórficas corretas para cada Creator.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "IDE com runner de main",
                                    "Console para output"
                                  ],
                                  "tips": "O cliente deve depender apenas de Creator, demonstrando desacoplamento.",
                                  "learningObjective": "Validar o uso do padrão para criação flexível sem conhecimento de concretos.",
                                  "commonMistakes": [
                                    "Usar if-else no cliente para escolher produto",
                                    "Instanciar produtos diretamente",
                                    "Ignorar exceções de compilação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de desenhos: Interface Shape com draw(). Circle e Square implementam. ShapeCreator abstrato com abstract Shape factoryMethod() e void render() { Shape s = factoryMethod(); s.draw(); }. CircleCreator retorna Circle; SquareCreator retorna Square. Cliente usa CircleCreator.render() para desenhar círculo sem saber de Circle.",
                              "finalVerifications": [
                                "Classe Creator é abstrata com factoryMethod() abstrato retornando Product.",
                                "Método de negócio em Creator usa factoryMethod() e invoca operação no Product.",
                                "Subclasses concretas override factoryMethod() corretamente sem vazamentos de concretos.",
                                "Cliente compila e executa usando apenas Creator, produzindo comportamentos polimórficos.",
                                "Código segue convenções Java (nomenclatura, modifiers).",
                                "Nenhum if-else ou instanceof no cliente para decisão de criação."
                              ],
                              "assessmentCriteria": [
                                "Correção sintática e semântica: código compila e roda sem erros.",
                                "Adesão ao padrão Factory Method: criação encapsulada em subclasses.",
                                "Uso efetivo de polimorfismo e abstração via interfaces.",
                                "Desacoplamento: cliente ignora classes concretas de Product.",
                                "Clareza e documentação: comentários e nomes autoexplicativos.",
                                "Eficiência: sem lógica redundante ou violações SOLID."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstração de funções genéricas e polimorfismo como mapeamento de tipos.",
                                "Engenharia de Software: Aplicação de padrões de design para escalabilidade e manutenibilidade.",
                                "Lógica e Algoritmos: Delegação de responsabilidades sem condicionais explícitas.",
                                "Design Gráfico: Criação dinâmica de elementos visuais em editores."
                              ],
                              "realWorldApplication": "Em frameworks como Java Swing para criação dinâmica de componentes GUI (botões, painéis) sem especificar classes concretas no código cliente, ou em jogos para spawnar inimigos variados via factories, permitindo extensão fácil sem modificar código existente."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.4.3.2",
                            "name": "Desenvolver ConcreteCreator e ConcreteProduct",
                            "description": "Implementar subclasses ConcreteCreator que sobrescrevem factoryMethod() para retornar instâncias específicas de ConcreteProduct, demonstrando encapsulamento e polimorfismo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir e implementar subclasses ConcreteProduct",
                                  "subSteps": [
                                    "Analise a classe abstrata Product e identifique métodos abstratos a serem implementados.",
                                    "Crie a primeira subclasse ConcreteProductA, estendendo Product.",
                                    "Implemente todos os métodos concretos com lógica específica para o produto A.",
                                    "Crie a segunda subclasse ConcreteProductB, seguindo o mesmo padrão.",
                                    "Teste a criação de instâncias isoladas de cada ConcreteProduct."
                                  ],
                                  "verification": "Compilar o código e instanciar objetos de ConcreteProductA e ConcreteProductB, verificando se os métodos funcionam corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (IntelliJ, Eclipse ou VS Code)",
                                    "JDK 8 ou superior",
                                    "Exemplo de classe Product base"
                                  ],
                                  "tips": [
                                    "Use nomes descritivos como 'PizzaMarguerita' para ConcreteProductA em um exemplo de pizzaria.",
                                    "Garanta que os construtores sejam públicos ou protegidos conforme necessário."
                                  ],
                                  "learningObjective": "Especializar a abstração Product em implementações concretas, promovendo polimorfismo.",
                                  "commonMistakes": [
                                    "Esquecer de chamar super() no construtor.",
                                    "Implementar métodos com assinaturas diferentes da superclasse.",
                                    "Não tratar exceções ou casos edge nos métodos concretos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar subclasses ConcreteCreator",
                                  "subSteps": [
                                    "Analise a classe abstrata Creator com o método factoryMethod() declarado.",
                                    "Crie ConcreteCreatorA estendendo Creator.",
                                    "Implemente o construtor de ConcreteCreatorA, se necessário, para configurações específicas.",
                                    "Crie ConcreteCreatorB estendendo Creator, de forma similar.",
                                    "Verifique a herança no diagrama UML ou IDE."
                                  ],
                                  "verification": "Compilar as classes ConcreteCreator e confirmar herança via instanceof ou diagrama de classes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código com suporte a UML (IntelliJ ou PlantUML)",
                                    "Classe Creator base"
                                  ],
                                  "tips": [
                                    "Mantenha os ConcreteCreator leves, delegando a criação para factoryMethod.",
                                    "Use injeção de dependências se aplicável para flexibilidade."
                                  ],
                                  "learningObjective": "Entender o papel do ConcreteCreator como ponto de extensão do padrão Factory Method.",
                                  "commonMistakes": [
                                    "Herança incorreta da classe Creator.",
                                    "Adicionar lógica desnecessária no construtor que viole o encapsulamento.",
                                    "Expor referências diretas a ConcreteProduct no ConcreteCreator."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Sobrescrever factoryMethod() nos ConcreteCreator",
                                  "subSteps": [
                                    "Em ConcreteCreatorA, sobrescreva factoryMethod() para retornar new ConcreteProductA().",
                                    "Em ConcreteCreatorB, sobrescreva factoryMethod() para retornar new ConcreteProductB().",
                                    "Garanta que factoryMethod() retorne o tipo Product (polimorfismo).",
                                    "Adicione logs ou prints para depuração do tipo retornado.",
                                    "Compile e execute chamadas básicas para factoryMethod()."
                                  ],
                                  "verification": "Chame factoryMethod() em cada ConcreteCreator e verifique o tipo exato do objeto retornado via getClass() ou toString().",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Ferramenta de depuração (debugger da IDE)"
                                  ],
                                  "tips": [
                                    "Mantenha factoryMethod() simples e idempotente.",
                                    "Use @Override annotation para evitar erros de digitação."
                                  ],
                                  "learningObjective": "Demonstrar como o override encapsula a criação específica, escondendo detalhes do cliente.",
                                  "commonMistakes": [
                                    "Retornar tipo errado (não Product).",
                                    "Não usar override, causando método shadow.",
                                    "Retornar null ou instâncias inválidas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e demonstrar encapsulamento e polimorfismo",
                                  "subSteps": [
                                    "Crie um cliente que use apenas Creator, sem referenciar Concrete* classes.",
                                    "Instancie ConcreteCreatorA e chame algum método que use factoryMethod().",
                                    "Repita com ConcreteCreatorB e compare comportamentos.",
                                    "Execute testes unitários para verificar polimorfismo.",
                                    "Analise o código para confirmar encapsulamento (sem acoplamento forte)."
                                  ],
                                  "verification": "Cliente compila e roda sem conhecimento de ConcreteProduct; objetos se comportam polimorficamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "JUnit ou framework de testes",
                                    "Cliente de exemplo"
                                  ],
                                  "tips": [
                                    "Use interfaces para o cliente interagir apenas com Product.",
                                    "Meça acoplamento com ferramentas como JDepend."
                                  ],
                                  "learningObjective": "Validar os princípios OOP no contexto do Factory Method.",
                                  "commonMistakes": [
                                    "Cliente acoplado diretamente a ConcreteProduct.",
                                    "Testes que expõem implementação interna.",
                                    "Ignorar exceções em fluxos de criação."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma pizzaria: ConcreteProduct como 'PizzaMarguerita' e 'PizzaCalabresa' (extendendo Pizza com ingredientes específicos). ConcreteCreator como 'MargueritaCreator' (factoryMethod retorna PizzaMarguerita) e 'CalabresaCreator'. Cliente pede 'pizza = creator.factoryMethod(); pizza.preparar();' sem saber o tipo exato.",
                              "finalVerifications": [
                                "factoryMethod() de cada ConcreteCreator retorna o ConcreteProduct correto.",
                                "Cliente usa apenas Creator e Product, sem dependência em concretos.",
                                "Polimorfismo: diferentes ConcreteCreator produzem comportamentos distintos via Product.",
                                "Código compila e executa sem erros ou vazamentos.",
                                "Encapsulamento: detalhes de criação invisíveis ao cliente.",
                                "Testes unitários passam para todos os cenários."
                              ],
                              "assessmentCriteria": [
                                "Implementação correta de herança e override sem erros de compilação.",
                                "Demonstração clara de polimorfismo em uso real.",
                                "Encapsulamento mantido: acoplamento baixo entre cliente e concretos.",
                                "Código limpo, com comentários e nomes autoexplicativos.",
                                "Testes abrangentes cobrindo casos normais e edge.",
                                "Uso apropriado de princípios SOLID (especialmente Dependency Inversion)."
                              ],
                              "crossCurricularConnections": [
                                "UML: Criação de diagramas de classe mostrando herança e dependências.",
                                "Interfaces GUI: Factories para componentes como JButton customizados em Swing.",
                                "Design de Software: Aplicação em outros padrões como Abstract Factory.",
                                "Matemática: Hierarquias de classes como árvores de herança.",
                                "Banco de Dados: Factories para objetos de conexão (JDBC drivers)."
                              ],
                              "realWorldApplication": "Em frameworks como Spring (factories para beans específicos), Java AWT/Swing (criação de componentes GUI polimórficos) ou jogos (factories para inimigos/types de armas), permitindo extensão sem modificar código cliente."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.4.3.3",
                            "name": "Aplicar em exemplo real como criação de GUI ou documentos",
                            "description": "Codificar exemplo onde Application é Creator, criando diferentes Document (Product) via subclasses como TextDocumentCreator, integrando com interfaces GUI.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejar a estrutura do Padrão Factory Method para criação de documentos",
                                  "subSteps": [
                                    "Identifique os papéis: Product (Document abstrato), ConcreteProduct (TextDocument, ImageDocument), Creator (Application abstrato), ConcreteCreator (TextDocumentCreator).",
                                    "Desenhe o diagrama de classes UML mostrando o método factoryMethod() no Creator.",
                                    "Defina as interfaces GUI para seleção do tipo de documento (ex: botões ou menu).",
                                    "Liste os atributos e métodos necessários para cada classe de Document (ex: open(), save()).",
                                    "Esboce o fluxo: Application chama factoryMethod() baseado na seleção GUI."
                                  ],
                                  "verification": "Diagrama UML completo e anotado com papéis do padrão Factory Method.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta de diagramação (Draw.io, Lucidchart), papel e caneta ou editor de texto.",
                                  "tips": "Use setas para mostrar herança e chamadas de método factoryMethod().",
                                  "learningObjective": "Compreender os componentes essenciais do Factory Method e sua integração com GUI.",
                                  "commonMistakes": "Confundir Creator com Product ou ignorar a abstração do factoryMethod()."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar as classes Product (Document e subclasses concretas)",
                                  "subSteps": [
                                    "Crie a classe abstrata Document com métodos abstratos como createContent(), open(), save().",
                                    "Implemente TextDocument com conteúdo textual simples (ex: String content).",
                                    "Implemente ImageDocument com simulação de imagem (ex: byte[] pixels).",
                                    "Implemente PDFDocument com estrutura básica (ex: páginas e metadados).",
                                    "Teste unitariamente cada classe com JUnit para verificar métodos básicos."
                                  ],
                                  "verification": "Classes compilam e testes unitários passam para open() e save() em cada Document.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "IDE Java (Eclipse, IntelliJ), JDK 8+, JUnit para testes.",
                                  "tips": "Mantenha as classes leves; foque em simulações para evitar dependências externas.",
                                  "learningObjective": "Criar produtos concretos que encapsulem a variação no Factory Method.",
                                  "commonMistakes": "Expor implementação interna do Document no Creator."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar os Creators (Application abstrato e subclasses concretas)",
                                  "subSteps": [
                                    "Crie a classe abstrata Application com factoryMethod() retornando Document.",
                                    "Implemente TextDocumentCreator sobrescrevendo factoryMethod() para retornar new TextDocument().",
                                    "Implemente ImageDocumentCreator e PDFDocumentCreator similarmente.",
                                    "Adicione lógica em Application para escolher o ConcreteCreator baseado em input (ex: String type).",
                                    "Teste a criação de diferentes Documents via main() simples."
                                  ],
                                  "verification": "Código cria instâncias corretas de Documents baseadas no tipo selecionado.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "IDE Java, JDK.",
                                  "tips": "Use switch ou if para selecionar ConcreteCreator no Application.",
                                  "learningObjective": "Implementar o núcleo do Factory Method com delegação para subclasses.",
                                  "commonMistakes": "Fazer factoryMethod() concreto na classe abstrata Application."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar com interface GUI e realizar testes finais",
                                  "subSteps": [
                                    "Crie uma janela Swing (JFrame) com botões para 'Texto', 'Imagem', 'PDF'.",
                                    "No ActionListener de cada botão, instancie Application com o tipo correspondente e chame factoryMethod().",
                                    "Exiba o Document criado em um JTextArea ou JLabel (ex: 'Documento Texto criado!').",
                                    "Adicione botões para open() e save() no Document criado.",
                                    "Execute e teste todos os fluxos, registrando logs ou saídas."
                                  ],
                                  "verification": "Aplicação GUI roda, cria Documents corretos e executa open/save sem crashes.",
                                  "estimatedTime": "70 minutos",
                                  "materials": "IDE Java com Swing, JDK.",
                                  "tips": "Use SwingUtilities.invokeLater() para thread safety na GUI.",
                                  "learningObjective": "Aplicar Factory Method em um contexto GUI real e acionável.",
                                  "commonMistakes": "Não tratar exceções em inputs inválidos ou threading GUI."
                                }
                              ],
                              "practicalExample": "Desenvolva uma aplicação Java Swing chamada DocumentFactoryApp. Um menu dropdown permite selecionar 'Texto', 'Imagem' ou 'PDF'. Ao clicar 'Criar', a classe Application usa Factory Method para instanciar o Document via TextDocumentCreator, ImageDocumentCreator ou PDFDocumentCreator. Botões 'Abrir' e 'Salvar' operam no Document criado, exibindo resultados em uma área de texto.",
                              "finalVerifications": [
                                "O código compila e executa sem erros.",
                                "Seleção GUI cria o Document correto (ver tipo via toString()).",
                                "Métodos open() e save() funcionam para todos os Documents.",
                                "Não há acoplamento direto entre Application e classes concretas de Document.",
                                "Testes unitários cobrem 80% das classes.",
                                "GUI é responsiva e intuitiva."
                              ],
                              "assessmentCriteria": [
                                "Corretude do Padrão Factory Method (factoryMethod() abstrato no Creator).",
                                "Qualidade do código: coesão, baixo acoplamento e legibilidade.",
                                "Funcionalidade completa da GUI com todos os tipos de Document.",
                                "Tratamento de erros e exceções adequados.",
                                "Cobertura de testes unitários e verificações manuais.",
                                "Comentários e documentação clara nos métodos chave."
                              ],
                              "crossCurricularConnections": [
                                "Design de Software: Aplicação de padrões de projeto em desenvolvimento real.",
                                "Programação Gráfica: Integração de OO com bibliotecas GUI como Swing.",
                                "Engenharia de Software: Modularidade e extensibilidade de código.",
                                "UML: Modelagem de classes e relacionamentos para padrões.",
                                "Banco de Dados: Extensão para salvar Documents em BD via Factory."
                              ],
                              "realWorldApplication": "Em editores como Microsoft Word ou LibreOffice, onde o usuário seleciona tipos de documento (DOCX, PDF, ODT) e o sistema usa Factory Method para criar instâncias específicas, integrando com interfaces gráficas para edição e exportação dinâmica."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.4.4",
                        "name": "Consequências, Vantagens e Relações",
                        "description": "O padrão oferece flexibilidade para adicionar novos produtos via subclasses, evita condicionais, mas pode introduzir complexidade; relaciona-se com Template Method e Abstract Factory.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.4.4.1",
                            "name": "Listar vantagens e desvantagens",
                            "description": "Explicar benefícios como extensibilidade sem modificação, polimorfismo puro, e trade-offs como mais classes e dependência de herança.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais do Padrão Factory Method",
                                  "subSteps": [
                                    "Ler a definição do Factory Method: um padrão criacional que define uma interface para criar objetos, mas permite que subclasses alterem o tipo de objeto criado.",
                                    "Identificar componentes chave: Creator (classe abstrata com factory method), ConcreteCreator (implementações), Product (interface) e ConcreteProduct.",
                                    "Analisar o diagrama UML típico do padrão para visualizar relações.",
                                    "Comparar com criação direta de objetos para entender o propósito.",
                                    "Anotar princípios SOLID relacionados, como Open/Closed Principle."
                                  ],
                                  "verification": "Criar um resumo de 1 parágrafo explicando o padrão e seus componentes principais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagrama UML do Factory Method",
                                    "Documentação GoF (Gang of Four)",
                                    "Exemplos de código em Java ou Python"
                                  ],
                                  "tips": "Use mind maps para conectar componentes e princípios SOLID.",
                                  "learningObjective": "Compreender a estrutura e intenção do padrão para contextualizar vantagens e desvantagens.",
                                  "commonMistakes": [
                                    "Confundir com Abstract Factory",
                                    "Ignorar o foco em herança para criação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Listar e explicar as principais vantagens",
                                  "subSteps": [
                                    "Identificar extensibilidade sem modificação: novas subclasses de ConcreteProduct e ConcreteCreator sem alterar código existente.",
                                    "Destacar polimorfismo puro: cliente usa interface Product sem conhecer implementações concretas.",
                                    "Notar isolamento de lógica de criação: centraliza criação em subclasses, facilitando manutenção.",
                                    "Explicar suporte ao Open/Closed Principle: aberto para extensão, fechado para modificação.",
                                    "Adicionar promoção de código loosely coupled entre criador e produto."
                                  ],
                                  "verification": "Escrever uma lista com 4-5 vantagens, cada uma com 1-2 frases de explicação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro Design Patterns (GoF)",
                                    "Artigos sobre SOLID principles",
                                    "Exemplos de código extensíveis"
                                  ],
                                  "tips": "Associe cada vantagem a um benefício mensurável, como 'reduz bugs em 30% ao evitar modificações'.",
                                  "learningObjective": "Dominar as vantagens chave, focando em extensibilidade e polimorfismo.",
                                  "commonMistakes": [
                                    "Listar vantagens genéricas de OOP sem especificidade ao Factory Method",
                                    "Omitir ligação com SOLID"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Listar e explicar as principais desvantagens",
                                  "subSteps": [
                                    "Reconhecer proliferação de classes: cada novo produto requer Creator e Product subclasses.",
                                    "Dependência de herança: requer hierarquia de classes, limitando em linguagens sem herança forte.",
                                    "Complexidade inicial: mais código boilerplate comparado a criação direta.",
                                    "Dificuldade em depuração: rastrear qual ConcreteCreator é usado pode ser desafiador.",
                                    "Sobrecarga para casos simples: over-engineering em cenários com poucos produtos."
                                  ],
                                  "verification": "Criar uma lista com 3-4 desvantagens, justificando cada uma com um cenário hipotético.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Casos de estudo de refatoração",
                                    "Comparações com Singleton ou Prototype",
                                    "Ferramentas de análise de complexidade como SonarQube"
                                  ],
                                  "tips": "Pondere trade-offs: 'mais classes agora, mas escalável depois'.",
                                  "learningObjective": "Identificar trade-offs realistas para avaliação equilibrada do padrão.",
                                  "commonMistakes": [
                                    "Exagerar desvantagens sem contexto",
                                    "Confundir com problemas de outros padrões criacionais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Organizar, sintetizar e validar a lista completa",
                                  "subSteps": [
                                    "Combinar listas de V e D em uma tabela ou lista balanceada (ex: 4V vs 3D).",
                                    "Priorizar itens por impacto: classificar como 'alta/média/baixa' relevância.",
                                    "Adicionar exemplos concretos para cada item.",
                                    "Verificar completude comparando com fontes autorizadas (GoF).",
                                    "Discutir quando usar: critérios para escolher Factory Method vs alternativas."
                                  ],
                                  "verification": "Produzir um documento final com lista organizada, exemplos e critérios de uso.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Template de tabela V/D",
                                    "Referências GoF capítulo Factory Method",
                                    "Ferramenta de edição como Markdown ou Google Docs"
                                  ],
                                  "tips": "Use bullet points e negrito para clareza visual.",
                                  "learningObjective": "Criar uma apresentação estruturada e acionável das V/D.",
                                  "commonMistakes": [
                                    "Listas desbalanceadas (só V ou só D)",
                                    "Falta de exemplos concretos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de pizzaria, o Factory Method permite adicionar 'PizzaCalabresa' criando PizzaCalabresaCreator e PizzaCalabresa sem alterar PizzaStore ou cliente, demonstrando extensibilidade (V); porém, exige duas novas classes, aumentando complexidade para apenas uma pizza nova (D).",
                              "finalVerifications": [
                                "Lista contém pelo menos 4 vantagens com explicações precisas.",
                                "Lista inclui pelo menos 3 desvantagens realistas.",
                                "Cada item tem exemplo ou justificativa contextual.",
                                "Referência explícita a princípios como Open/Closed.",
                                "Síntese balanceada discute trade-offs.",
                                "Documento final é claro e organizado em tabela/lista."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (90% das V/D corretas conforme GoF).",
                                "Completude (cobertura de extensibilidade, polimorfismo, classes extras, herança).",
                                "Profundidade de explicações (exemplos e impactos).",
                                "Equilíbrio entre V e D (não enviesado).",
                                "Clareza e estrutura (fácil leitura).",
                                "Conexão com contexto OOP/UML."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Análise de trade-offs em design.",
                                "Design Thinking: Avaliação de protótipos e iterações.",
                                "Gestão de Projetos: Custo-benefício em desenvolvimento.",
                                "Matemática: Análise de complexidade O(n) vs escalabilidade."
                              ],
                              "realWorldApplication": "No framework Spring Boot (Java), factories gerenciam criação de beans, permitindo extensibilidade via anotações sem modificar o core, usado em apps empresariais como e-commerces da Amazon, balanceando mais classes iniciais com manutenção de longo prazo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.4.4.2",
                            "name": "Comparar com outros padrões criacionais",
                            "description": "Diferenciar Factory Method (um produto por creator) de Abstract Factory (família de produtos) e Simple Factory (não OO).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o padrão Factory Method",
                                  "subSteps": [
                                    "Ler a definição oficial do padrão Factory Method do livro GoF: criador define interface para criar produto, subclasses decidem classe concreta.",
                                    "Analisar o diagrama UML: Creator com factoryMethod(), ConcreteCreator implementa, Product interface.",
                                    "Estudar um exemplo de código simples em Java ou Python, como criar diferentes tipos de documentos.",
                                    "Identificar características chave: um produto por creator, dependência invertida, extensibilidade via subclasses.",
                                    "Anotar vantagens: isola criação, promove polimorfismo."
                                  ],
                                  "verification": "Criar um diagrama UML resumido do Factory Method e explicar verbalmente suas partes principais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro GoF (Gang of Four), diagramas UML online, editor de código (IntelliJ ou VS Code)"
                                  ],
                                  "tips": "Foque nas responsabilidades do Creator abstrato versus concreto para entender a delegação.",
                                  "learningObjective": "Compreender a estrutura e intenção do Factory Method, focando em um produto por creator.",
                                  "commonMistakes": "Confundir com criação direta no cliente, ignorando a abstração do creator."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o padrão Abstract Factory",
                                  "subSteps": [
                                    "Ler definição: fornece interface para criar famílias de produtos relacionados sem especificar classes concretas.",
                                    "Analisar diagrama UML: AbstractFactory com múltiplos createProduct(), ConcreteFactory implementa famílias.",
                                    "Examinar exemplo de código: fábrica para GUI (botões e janelas para Windows/Mac).",
                                    "Destacar diferenças iniciais: múltiplos produtos por factory, consistência entre famílias.",
                                    "Listar vantagens: troca fácil de famílias, promove consistência."
                                  ],
                                  "verification": "Desenhar diagrama UML do Abstract Factory e listar os métodos de criação de produtos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro GoF, exemplos de código em repositórios GitHub (padrões de design), ferramenta de diagrama (Draw.io)"
                                  ],
                                  "tips": "Pense em 'famílias' como temas ou plataformas inteiras para visualizar melhor.",
                                  "learningObjective": "Dominar a estrutura do Abstract Factory, enfatizando famílias de produtos inter-relacionados.",
                                  "commonMistakes": "Misturar com Factory Method achando que é só uma extensão simples."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Simple Factory (não OO purista)",
                                  "subSteps": [
                                    "Definir Simple Factory: função ou classe estática que encapsula lógica de criação via parâmetro (switch/if).",
                                    "Comparar com OO: não usa herança/polimorfismo, viola OCP (Open-Closed Principle).",
                                    "Ver exemplo: função createShape(String type) com switch para Circle/Rectangle.",
                                    "Identificar limitações: rígida, difícil de estender sem modificar código central.",
                                    "Anotar quando usar: cenários simples, protótipos rápidos."
                                  ],
                                  "verification": "Implementar uma Simple Factory em código e testar com diferentes inputs.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código, documentação online sobre anti-padrões"
                                  ],
                                  "tips": "Implemente-a para sentir a rigidez e contrastar com os outros padrões.",
                                  "learningObjective": "Reconhecer a Simple Factory como alternativa não-OO e suas fraquezas.",
                                  "commonMistakes": "Confundir com Factory Method por ambos encapsularem criação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e diferenciar os padrões",
                                  "subSteps": [
                                    "Criar tabela comparativa: colunas para Factory Method, Abstract Factory, Simple Factory (linhas: produtos, OO?, extensibilidade, complexidade).",
                                    "Destacar diferenças chave: Factory Method (1 produto/creator, OO), Abstract (família, OO), Simple (switch, não OO).",
                                    "Discutir relações: Factory Method como base para Abstract; Simple como precursor simples.",
                                    "Simular cenários: quando usar cada (ex: Factory para documentos, Abstract para UI kits).",
                                    "Refletir sobre consequências: impacto em código, manutenção e escalabilidade."
                                  ],
                                  "verification": "Preencher tabela comparativa e explicar 3 diferenças principais em voz alta ou por escrito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha Excel/Google Sheets para tabela, exemplos de código dos steps anteriores"
                                  ],
                                  "tips": "Use cores na tabela para destacar OO vs não-OO e número de produtos.",
                                  "learningObjective": "Diferenciar precisamente os três padrões e saber quando aplicar cada um.",
                                  "commonMistakes": "Generalizar demais, ignorando nuances como suporte a famílias no Abstract Factory."
                                }
                              ],
                              "practicalExample": "Em um sistema de pizzaria: Factory Method cria uma pizza específica por subclasse (ChicagoPizzaCreator); Abstract Factory cria família (pizza + massa + molho para NY/Chicago); Simple Factory usa switch('tipo') para retornar Pizza.",
                              "finalVerifications": [
                                "Explicar verbalmente as 3 diferenças principais entre Factory Method e Abstract Factory.",
                                "Identificar se um código dado usa Simple Factory e por que não é OO puro.",
                                "Criar um diagrama comparativo rápido dos três padrões.",
                                "Escolher o padrão certo para um cenário: 'criar família de botões e menus para diferentes SO'.",
                                "Listar 2 vantagens e 1 desvantagem de cada padrão.",
                                "Refatorar um código Simple Factory para Factory Method."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de diferenças estruturais (produtos, herança).",
                                "Correta classificação de aderência a princípios OO (OCP, DIP).",
                                "Uso de exemplos relevantes e código funcional.",
                                "Profundidade na tabela comparativa (cobertura de pelo menos 5 critérios).",
                                "Capacidade de escolher padrão adequado para cenários reais.",
                                "Clareza na explicação verbal/escrita das relações entre padrões."
                              ],
                              "crossCurricularConnections": [
                                "Análise de Sistemas: Abstração e modelagem de dependências em diagramas UML.",
                                "Matemática: Teoria de conjuntos para famílias de produtos inter-relacionados.",
                                "Lógica de Programação: Condicionais (switch) vs polimorfismo.",
                                "Engenharia de Software: Princípios SOLID e refatoração de código legado."
                              ],
                              "realWorldApplication": "Frameworks como Spring (Factory Beans para beans), bibliotecas GUI (Swing/AWT usam Abstract Factory para look-and-feel multiplataforma), ou engines de jogos (fábricas para assets como sprites e sons)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.8.5",
                    "name": "Componentes Básicos de Interfaces GUI",
                    "description": "Elementos como botões, labels, caixas de texto e janelas em programação GUI.",
                    "individualConcepts": [
                      {
                        "id": "10.1.8.5.1",
                        "name": "Janelas em Interfaces GUI",
                        "description": "As janelas são os contêineres principais em programação GUI, responsáveis por abrigar outros componentes e definir a estrutura básica da interface do usuário, utilizando classes como Frame ou Window em bibliotecas como Tkinter (Python) ou JFrame (Java).",
                        "specificSkills": [
                          {
                            "id": "10.1.8.5.1.1",
                            "name": "Criar uma janela básica",
                            "description": "Instanciar uma classe de janela (ex: Tk() em Tkinter ou JFrame em Swing) e configurar suas propriedades iniciais como título e dimensões.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente de desenvolvimento",
                                  "subSteps": [
                                    "Instale o Python se não estiver instalado (versão 3.6+)",
                                    "Verifique se Tkinter está disponível executando 'python -m tkinter' no terminal",
                                    "Crie um novo arquivo Python com extensão .py (ex: janela_basica.py)",
                                    "Importe a biblioteca Tkinter no topo do arquivo: from tkinter import Tk",
                                    "Adicione comentários explicando o propósito do script"
                                  ],
                                  "verification": "Execute o script sem erros de importação e confirme que Tkinter é reconhecido",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python instalado",
                                    "Editor de código (VS Code, PyCharm ou IDLE)",
                                    "Terminal ou prompt de comando"
                                  ],
                                  "tips": "Use um ambiente virtual (venv) para isolar dependências",
                                  "learningObjective": "Configurar corretamente o ambiente para desenvolvimento GUI com Tkinter",
                                  "commonMistakes": [
                                    "Esquecer de importar Tkinter",
                                    "Usar versão errada do Python sem Tkinter"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Instanciar a classe de janela básica",
                                  "subSteps": [
                                    "Crie uma variável para a janela principal: root = Tk()",
                                    "Adicione um comentário explicando que Tk() cria a instância raiz da aplicação",
                                    "Evite renomear 'root' para manter convenções",
                                    "Teste a instância executando root.mainloop() temporariamente",
                                    "Feche a janela para prosseguir"
                                  ],
                                  "verification": "A janela vazia abre e fecha sem crashes ao chamar mainloop()",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Arquivo .py criado no step 1",
                                    "Editor de código"
                                  ],
                                  "tips": "Sempre use 'root' ou 'window' como nome para clareza",
                                  "learningObjective": "Entender a instanciação da classe Tk() como base da GUI",
                                  "commonMistakes": [
                                    "Chamar mainloop() antes de configurar propriedades",
                                    "Não criar a instância"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar propriedades iniciais da janela",
                                  "subSteps": [
                                    "Defina o título: root.title('Minha Primeira Janela')",
                                    "Ajuste as dimensões: root.geometry('400x300') ou root.resize(400, 300)",
                                    "Centralize a janela na tela usando: root.eval('tk::PlaceWindow . center')",
                                    "Teste as mudanças executando o script novamente",
                                    "Adicione mais uma propriedade opcional como cor de fundo: root.configure(bg='white')"
                                  ],
                                  "verification": "Janela abre com título correto, tamanho exato e centralizada",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código dos steps anteriores"
                                  ],
                                  "tips": "Use geometry('WxH+X+Y') para posição exata se necessário",
                                  "learningObjective": "Aplicar métodos de configuração básica para personalizar a aparência inicial",
                                  "commonMistakes": [
                                    "Esquecer aspas no título",
                                    "Usar dimensões inválidas como letras"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar e finalizar o loop principal da aplicação",
                                  "subSteps": [
                                    "Adicione root.mainloop() no final do script",
                                    "Explique em comentário que mainloop() inicia o event loop",
                                    "Execute o script completo e interaja com a janela (redimensionar, fechar)",
                                    "Trate exceções básicas com try-except ao redor do mainloop()",
                                    "Salve o arquivo e crie uma versão com print('Janela fechada') no quit"
                                  ],
                                  "verification": "Aplicação roda indefinidamente até fechar a janela manualmente, sem erros",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código completo"
                                  ],
                                  "tips": "Nunca chame mainloop() múltiplas vezes no mesmo root",
                                  "learningObjective": "Compreender o ciclo de vida da aplicação GUI com event loop",
                                  "commonMistakes": [
                                    "Colocar mainloop() antes das configurações",
                                    "Fechar sem mainloop()"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e depurar a janela básica",
                                  "subSteps": [
                                    "Execute em diferentes resoluções de tela",
                                    "Verifique responsividade redimensionando a janela",
                                    "Adicione um label simples para testar: from tkinter import Label; Label(root, text='Olá Mundo').pack()",
                                    "Use print statements para debug de propriedades",
                                    "Documente o código final com docstring"
                                  ],
                                  "verification": "Janela funcional com label visível, sem warnings ou erros no console",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código finalizado"
                                  ],
                                  "tips": "Use pack(), grid() ou place() para widgets iniciais",
                                  "learningObjective": "Validar e iterar sobre a implementação básica de GUI",
                                  "commonMistakes": [
                                    "Não testar em múltiplos ambientes",
                                    "Ignorar warnings de depreciação"
                                  ]
                                }
                              ],
                              "practicalExample": "from tkinter import Tk\nroot = Tk()\nroot.title('Janela Básica')\nroot.geometry('400x300')\nroot.mainloop()  # Executa e exibe a janela com título e tamanho corretos",
                              "finalVerifications": [
                                "Janela abre sem erros e fecha corretamente",
                                "Título da janela corresponde ao definido",
                                "Dimensões iniciais são exatamente 400x300 pixels",
                                "Janela é centralizada na tela",
                                "Nenhum erro ou warning no console",
                                "Aplicação responde a redimensionamento e fechamento"
                              ],
                              "assessmentCriteria": [
                                "Código limpo com import correto e comentários",
                                "Instanciação adequada de Tk() sem variáveis globais desnecessárias",
                                "Configurações de título e geometry aplicadas antes de mainloop()",
                                "Uso correto de mainloop() para event handling",
                                "Testes demonstrados com saídas visuais e sem bugs",
                                "Adesão a boas práticas OO (ex: root como instância principal)"
                              ],
                              "crossCurricularConnections": [
                                "Design Gráfico: Conceitos de layout e UX/UI básicos",
                                "Matemática: Cálculos de dimensões e posicionamento geométrico",
                                "Lógica de Programação: Eventos e loops em programação orientada a eventos",
                                "Inglês Técnico: Terminologia GUI (window, title, geometry)"
                              ],
                              "realWorldApplication": "Criação de interfaces para aplicativos desktop como gerenciadores de tarefas, editores de texto simples ou dashboards administrativos em empresas, base para ferramentas como calculadoras ou formulários de login em sistemas empresariais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.5.1.2",
                            "name": "Configurar propriedades da janela",
                            "description": "Definir título, tamanho (width/height), posição na tela e layout manager para organizar componentes filhos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o título da janela",
                                  "subSteps": [
                                    "Importe a classe JFrame da biblioteca Swing: import javax.swing.JFrame;",
                                    "Crie uma instância de JFrame: JFrame janela = new JFrame();",
                                    "Defina o título usando o método setTitle(): janela.setTitle(\"Meu Aplicativo\");",
                                    "Verifique se o título não excede 60 caracteres para melhor usabilidade",
                                    "Teste a compilação para garantir ausência de erros de sintaxe"
                                  ],
                                  "verification": "Execute o programa e confirme que o título aparece corretamente na barra superior da janela",
                                  "estimatedTime": "10 minutos",
                                  "materials": "IDE (Eclipse ou IntelliJ), JDK 8+",
                                  "tips": "Use títulos descritivos que reflitam o propósito da aplicação para melhor UX",
                                  "learningObjective": "Entender como personalizar a identificação visual da janela",
                                  "commonMistakes": "Esquecer de importar javax.swing.JFrame ou usar aspas duplas incorretas"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o tamanho da janela (width e height)",
                                  "subSteps": [
                                    "Calcule as dimensões desejadas, ex: largura 800px e altura 600px",
                                    "Use o método setSize(): janela.setSize(800, 600);",
                                    "Alternativamente, use setPreferredSize(new Dimension(800, 600)) para layouts mais flexíveis",
                                    "Considere a resolução da tela para evitar tamanhos excessivos",
                                    "Chame pack() após adicionar componentes para ajustar automaticamente"
                                  ],
                                  "verification": "Execute e meça visualmente se a janela abre com as dimensões exatas especificadas",
                                  "estimatedTime": "15 minutos",
                                  "materials": "IDE com visualizador de GUI, calculadora para proporções",
                                  "tips": "Mantenha proporções áureas (1:1.618) para design harmonioso",
                                  "learningObjective": "Dominar o controle de dimensões para layouts responsivos",
                                  "commonMistakes": "Confundir parâmetros (width antes de height) ou usar setSize sem pack()"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir a posição da janela na tela",
                                  "subSteps": [
                                    "Importe Toolkit e Dimension: import java.awt.*;",
                                    "Obtenha as dimensões da tela: Dimension tela = Toolkit.getDefaultToolkit().getScreenSize();",
                                    "Calcule a posição central: int x = (tela.width - 800) / 2; int y = (tela.height - 600) / 2;",
                                    "Aplique com setLocation(): janela.setLocation(x, y); ou setLocationRelativeTo(null) para centralizar",
                                    "Teste em diferentes resoluções de tela"
                                  ],
                                  "verification": "A janela deve abrir centralizada independentemente da resolução da tela",
                                  "estimatedTime": "20 minutos",
                                  "materials": "IDE, monitor com resolução variável para testes",
                                  "tips": "Use setLocationByPlatform(true) para comportamento nativo em alguns casos",
                                  "learningObjective": "Aprender cálculos posicionais para acessibilidade multiplataforma",
                                  "commonMistakes": "Não importar classes necessárias ou erros aritméticos nos cálculos de centro"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar layout manager e organizar componentes filhos",
                                  "subSteps": [
                                    "Escolha um layout, ex: BorderLayout: janela.setLayout(new BorderLayout());",
                                    "Crie componentes filhos, ex: JButton botao = new JButton(\"Clique\");",
                                    "Adicione ao layout: janela.add(botao, BorderLayout.CENTER);",
                                    "Configure operação de fechamento: janela.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);",
                                    "Torne visível: janela.setVisible(true);"
                                  ],
                                  "verification": "Componentes devem estar organizados corretamente sem sobreposições ao executar",
                                  "estimatedTime": "25 minutos",
                                  "materials": "IDE, documentação Swing Layout Managers",
                                  "tips": "Comece com BorderLayout para simplicidade, evolua para GridBagLayout",
                                  "learningObjective": "Integrar propriedades da janela com gerenciamento de layout",
                                  "commonMistakes": "Esquecer setVisible(true) ou defaultCloseOperation, causando janelas não responsivas"
                                }
                              ],
                              "practicalExample": "Crie uma janela JFrame intitulada 'Calculadora Simples' com tamanho 400x300 pixels, posicionada no centro da tela, usando FlowLayout. Adicione três JButtons ('1', '2', '+') alinhados horizontalmente. Código base: JFrame calc = new JFrame(\"Calculadora Simples\"); calc.setSize(400,300); calc.setLocationRelativeTo(null); calc.setLayout(new FlowLayout()); calc.add(new JButton(\"1\")); ... calc.setVisible(true);",
                              "finalVerifications": [
                                "Título da janela corresponde exatamente ao definido",
                                "Dimensões width/height atendem aos valores especificados",
                                "Janela abre centralizada ou na posição calculada",
                                "Layout manager organiza componentes sem sobreposições",
                                "Janela fecha corretamente ao clicar no X",
                                "Nenhum erro de compilação ou runtime"
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de título (100% match)",
                                "Correção matemática no cálculo de tamanho e posição (erro <5px)",
                                "Uso adequado de layout manager com pelo menos 2 componentes",
                                "Código limpo, comentado e sem warnings",
                                "Responsividade em telas de 1366x768 e 1920x1080",
                                "Tempo de execução sem lags visuais"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculos geométricos para posição e proporções",
                                "Design Gráfico: Princípios de UI/UX para tamanhos e layouts",
                                "Física: Analogia com vetores para posicionamento 2D",
                                "Língua Portuguesa: Redação clara de títulos descritivos"
                              ],
                              "realWorldApplication": "Em desenvolvimento de software desktop, como editores de imagem (Photoshop-like), gerenciadores de banco de dados ou aplicativos empresariais, onde janelas personalizadas melhoram a usabilidade e experiência do usuário final."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.8.5.1.3",
                            "name": "Exibir e gerenciar o ciclo de vida da janela",
                            "description": "Tornar a janela visível com métodos como show() ou mainloop(), e implementar fechamento graceful com eventos de saída.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Criar a instância básica da janela",
                                  "subSteps": [
                                    "Importar o módulo Tkinter (from tkinter import Tk)",
                                    "Instanciar a janela principal: root = Tk()",
                                    "Configurar propriedades iniciais como título (root.title('Minha Janela')) e tamanho (root.geometry('400x300'))",
                                    "Evitar configurações avançadas neste passo para focar no básico",
                                    "Executar root.update() para refrescar a janela internamente"
                                  ],
                                  "verification": "Verificar se a instância root existe sem erros de sintaxe e responde a comandos básicos como root.title()",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python 3.x instalado",
                                    "Editor de código (VS Code ou IDLE)",
                                    "Documentação Tkinter oficial"
                                  ],
                                  "tips": "Sempre use root como nome da janela principal para convenção",
                                  "learningObjective": "Compreender a criação de uma janela vazia e suas propriedades fundamentais",
                                  "commonMistakes": [
                                    "Esquecer de importar Tkinter",
                                    "Usar Tk() múltiplas vezes sem destruir a anterior",
                                    "Não definir título, levando a janelas genéricas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Tornar a janela visível e iniciar o loop principal",
                                  "subSteps": [
                                    "Chamar root.deiconify() ou simplesmente root.mainloop() para exibir",
                                    "Entender que mainloop() inicia o ciclo de eventos da GUI",
                                    "Adicionar root.withdraw() se quiser esconder inicialmente e depois show",
                                    "Testar visibilidade ajustando posição na tela (root.geometry('+100+100'))",
                                    "Observar que mainloop() bloqueia o thread até o fechamento"
                                  ],
                                  "verification": "A janela aparece na tela e permanece responsiva até manualmente fechada",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ambiente Python com Tkinter",
                                    "Monitor para visualizar a janela"
                                  ],
                                  "tips": "Use mainloop() apenas uma vez por aplicação para evitar loops aninhados",
                                  "learningObjective": "Dominar métodos para visibilidade e o conceito de event loop em GUIs",
                                  "commonMistakes": [
                                    "Chamar mainloop() antes de configurações, causando comportamentos inesperados",
                                    "Confundir show() com mainloop() em frameworks diferentes",
                                    "Fechar terminal sem graceful exit"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar eventos de fechamento graceful",
                                  "subSteps": [
                                    "Definir uma função de callback: def on_closing(): root.quit()",
                                    "Registrar o handler: root.protocol('WM_DELETE_WINDOW', on_closing)",
                                    "Adicionar confirmações opcionais: if messagebox.askokcancel('Sair', 'Deseja sair?')",
                                    "Chamar root.destroy() após quit() para liberar recursos",
                                    "Testar clicando no X da janela"
                                  ],
                                  "verification": "Ao clicar no botão fechar (X), a aplicação encerra sem erros ou crashes abruptos",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tkinter com messagebox (from tkinter import messagebox)",
                                    "Conhecimento básico de funções callback"
                                  ],
                                  "tips": "Sempre destrua widgets filhos antes de root.destroy() para evitar memory leaks",
                                  "learningObjective": "Implementar handlers de eventos para gerenciamento seguro do ciclo de vida",
                                  "commonMistakes": [
                                    "Não registrar o protocol, causando fechamento forçado",
                                    "Esquecer root.quit() antes de destroy()",
                                    "Ignorar confirmações em apps de produção"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e otimizar o ciclo de vida completo",
                                  "subSteps": [
                                    "Executar a aplicação completa com mainloop()",
                                    "Simular múltiplos aberturas/fechamentos para estabilidade",
                                    "Adicionar logs ou prints para rastrear eventos de ciclo",
                                    "Otimizar com root.after() para tarefas periódicas no loop",
                                    "Verificar uso de CPU/memória durante execução prolongada"
                                  ],
                                  "verification": "A janela abre, fecha graceful várias vezes sem vazamentos ou travamentos",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramentas de monitoramento (Task Manager)",
                                    "Código completo dos passos anteriores"
                                  ],
                                  "tips": "Use threading se precisar de operações não-bloqueantes no mainloop",
                                  "learningObjective": "Integrar todos os elementos para um gerenciamento robusto do ciclo de vida da janela",
                                  "commonMistakes": [
                                    "Loops infinitos sem break condicional",
                                    "Não limpar eventos pendentes",
                                    "Ignorar exceções no handler de fechamento"
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo em Python com Tkinter:\nfrom tkinter import Tk, messagebox\n\ndef on_closing():\n    if messagebox.askokcancel('Sair', 'Deseja sair?'):\n        root.destroy()\n\nroot = Tk()\nroot.title('Ciclo de Vida')\nroot.geometry('400x300')\nroot.protocol('WM_DELETE_WINDOW', on_closing)\nroot.mainloop()",
                              "finalVerifications": [
                                "Janela abre visível sem erros",
                                "Botão X aciona handler personalizado sem crash",
                                "Recursos da aplicação são liberados após fechamento (verificar processos)",
                                "Event loop processa eventos corretamente durante execução",
                                "Configurações iniciais (título, tamanho) persistem",
                                "Sem warnings ou erros no console"
                              ],
                              "assessmentCriteria": [
                                "Código executa sem exceções e gerencia visibilidade corretamente (40%)",
                                "Handler de fechamento é implementado e testado (30%)",
                                "Estrutura segue boas práticas de GUI (20%)",
                                "Documentação/comentários explicam ciclo de vida (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Design de UX/UI: Princípios de lifecycle em apps mobile/web",
                                "Programação de Eventos: Padrões observer em POO",
                                "Gerenciamento de Recursos: Conceitos de alocação/liberação em SO",
                                "Testes de Software: Verificação de estados e transições"
                              ],
                              "realWorldApplication": "Em desenvolvimento de aplicativos desktop como editores de texto (ex: Notepad++), ferramentas de gerenciamento de projetos ou dashboards empresariais, onde janelas devem abrir rapidamente, responder a interações e fechar salvando estado sem perda de dados, evitando crashes que frustram usuários."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.5.2",
                        "name": "Labels (Rótulos)",
                        "description": "Labels são componentes estáticos usados para exibir texto ou ícones informativos, sem interação direta do usuário, implementados por classes como Label em Tkinter ou JLabel em Swing.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.5.2.1",
                            "name": "Criar um label básico",
                            "description": "Instanciar um Label com texto inicial e adicionar à janela pai usando métodos de packing ou grid.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente de desenvolvimento",
                                  "subSteps": [
                                    "Instale o Python com suporte a Tkinter (geralmente incluído por padrão).",
                                    "Abra um IDE ou editor de texto como VS Code, PyCharm ou IDLE.",
                                    "Crie um novo arquivo Python e salve com extensão .py.",
                                    "Importe a biblioteca Tkinter no topo do arquivo: from tkinter import *.",
                                    "Crie a janela principal: root = Tk(); root.title('Janela com Label'); root.geometry('300x200')."
                                  ],
                                  "verification": "Execute o código básico da janela e confirme que uma janela vazia aparece sem erros.",
                                  "estimatedTime": "5-10 minutos",
                                  "materials": [
                                    "Python 3.x instalado",
                                    "IDE/editor de código",
                                    "Documentação Tkinter oficial"
                                  ],
                                  "tips": "Use from tkinter import * para simplicidade inicial; evite conflitos de nomes.",
                                  "learningObjective": "Configurar um ambiente funcional para desenvolvimento de interfaces GUI com Tkinter.",
                                  "commonMistakes": [
                                    "Esquecer o import da biblioteca",
                                    "Não definir tamanho ou título da janela",
                                    "Executar sem salvar o arquivo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Instanciar o Label com texto inicial",
                                  "subSteps": [
                                    "Crie uma variável para o Label: meu_label = Label(root, text='Olá, Mundo!').",
                                    "Personalize opções básicas: adicione fg='blue' para cor do texto e font=('Arial', 14) para fonte.",
                                    "Experimente alinhamento: use anchor='center' para centralizar o texto no label.",
                                    "Atribua a variável para uso posterior.",
                                    "Verifique sintaxe no editor."
                                  ],
                                  "verification": "Inspecione o código no editor; não há erros de sintaxe e o Label é instanciado corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Referência de parâmetros Label no docs.python.org",
                                    "Editor com realce de sintaxe"
                                  ],
                                  "tips": "Sempre especifique o parâmetro 'text' explicitamente para clareza.",
                                  "learningObjective": "Criar uma instância de Label com propriedades básicas de texto e aparência.",
                                  "commonMistakes": [
                                    "Esquecer o parâmetro 'root' ou 'parent'",
                                    "Usar aspas simples/duplas inconsistentes",
                                    "Não definir text=''"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar o Label à janela pai usando pack ou grid",
                                  "subSteps": [
                                    "Escolha pack(): meu_label.pack(pady=20) para adicionar com padding vertical.",
                                    "Ou use grid(): meu_label.grid(row=0, column=0, padx=10, pady=10) para layout em grade.",
                                    "Teste ambos os métodos em códigos separados para comparar.",
                                    "Ajuste parâmetros como side='top' no pack ou sticky='nsew' no grid para posicionamento.",
                                    "Salve e execute para visualizar."
                                  ],
                                  "verification": "Execute o programa; o Label deve aparecer na janela sem sobreposições ou erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplos de pack/grid na documentação Tkinter",
                                    "Janela de preview do IDE"
                                  ],
                                  "tips": "Pack é mais simples para layouts lineares; grid para tabelas complexas.",
                                  "learningObjective": "Integrar o Label à hierarquia da janela usando gerenciadores de layout.",
                                  "commonMistakes": [
                                    "Chamar pack/grid sem parênteses",
                                    "Conflito entre pack e grid na mesma janela",
                                    "Falta de padx/pady causando colagens"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar e testar a aplicação completa",
                                  "subSteps": [
                                    "Adicione root.mainloop() no final do código.",
                                    "Execute o script: python nome_do_arquivo.py.",
                                    "Redimensione a janela e observe o comportamento do Label.",
                                    "Modifique o texto dinamicamente: meu_label.config(text='Texto alterado') e teste.",
                                    "Feche a janela e refatore o código para reutilização."
                                  ],
                                  "verification": "A aplicação roda em loop, Label é visível e responsivo; sem crashes.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Terminal ou console do IDE",
                                    "Notebook para anotações de testes"
                                  ],
                                  "tips": "mainloop() é essencial para eventos GUI; sem ele, a janela fecha imediatamente.",
                                  "learningObjective": "Finalizar e validar uma interface GUI básica com Label funcional.",
                                  "commonMistakes": [
                                    "Esquecer root.mainloop()",
                                    "Loop infinito sem opção de fechar",
                                    "Alterar config sem pack/grid prévio"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um arquivo app_label.py:\nfrom tkinter import *\nroot = Tk()\nroot.title('Meu Primeiro Label')\nroot.geometry('400x300')\nlabel_exemplo = Label(root, text='Bem-vindo ao Tkinter!', fg='green', font=('Arial', 16))\nlabel_exemplo.pack(pady=50)\nroot.mainloop()\nExecute e veja o label verde centralizado na janela.",
                              "finalVerifications": [
                                "O Label é instanciado com texto visível e sem erros de sintaxe.",
                                "O Label aparece corretamente posicionado na janela pai.",
                                "A aplicação executa em loop com mainloop() e fecha via botão X.",
                                "Mudanças em config(text=) atualizam o Label dinamicamente.",
                                "Nenhum erro no console ao rodar ou interagir.",
                                "Layout responsivo ao redimensionar a janela."
                              ],
                              "assessmentCriteria": [
                                "Código completo e executável sem erros.",
                                "Uso correto de Label com parent e text obrigatórios.",
                                "Aplicação de pack() ou grid() com pelo menos um parâmetro de layout.",
                                "Inclusão de mainloop() para GUI interativa.",
                                "Personalizações básicas (fonte, cor) demonstradas.",
                                "Comentários no código explicando cada seção."
                              ],
                              "crossCurricularConnections": [
                                "Design Gráfico: Conceitos de layout, tipografia e cores em interfaces.",
                                "Lógica de Programação: Sequência de instanciação e configuração de objetos.",
                                "Matemática: Coordenadas e posicionamento em grid (row/column).",
                                "Inglês Técnico: Leitura de documentação oficial Tkinter.",
                                "UX/UI: Princípios de usabilidade em elementos visuais simples."
                              ],
                              "realWorldApplication": "Labels são usados em aplicativos desktop como formulários de login (ex: 'Digite seu usuário'), painéis de status em editores de texto, dashboards de software (ex: exibir 'Conectado' em apps de rede) e interfaces de jogos para pontuações ou instruções."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.1.3"
                            ]
                          },
                          {
                            "id": "10.1.8.5.2.2",
                            "name": "Personalizar aparência do label",
                            "description": "Configurar fonte, cor de texto/fundo, alinhamento e tamanho para melhorar a usabilidade visual.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar a fonte e o tamanho do texto do label",
                                  "subSteps": [
                                    "Importe as classes necessárias: javax.swing.JLabel e java.awt.Font.",
                                    "Crie um objeto JLabel com o texto desejado, ex: JLabel label = new JLabel('Texto do Label');",
                                    "Defina a fonte usando new Font('Arial', Font.BOLD, 16), passando nome da família, estilo e tamanho.",
                                    "Aplique a fonte ao label com label.setFont(font);",
                                    "Compile e execute o código para visualizar a mudança."
                                  ],
                                  "verification": "Execute o programa e confirme que o texto do label aparece na fonte e tamanho especificados, sem distorções.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE com suporte a Java (Eclipse ou IntelliJ)",
                                    "JDK 8 ou superior",
                                    "Biblioteca Swing incluída no JDK"
                                  ],
                                  "tips": "Use fontes sans-serif como Arial ou Helvetica para melhor legibilidade em interfaces digitais; teste tamanhos em diferentes resoluções.",
                                  "learningObjective": "Compreender como o objeto Font personaliza tipografia para melhorar a hierarquia visual.",
                                  "commonMistakes": [
                                    "Esquecer de importar java.awt.Font",
                                    "Usar tamanho de fonte muito pequeno (<12pt) que compromete acessibilidade",
                                    "Não especificar estilo (ex: Font.PLAIN)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Personalizar cores de texto e fundo do label",
                                  "subSteps": [
                                    "Importe java.awt.Color se necessário.",
                                    "Defina a cor do texto com label.setForeground(Color.BLUE); ou new Color(0, 0, 255).",
                                    "Configure a cor de fundo com label.setBackground(new Color(255, 255, 240)); e ative com label.setOpaque(true);.",
                                    "Verifique contraste usando ferramentas online como WebAIM Contrast Checker.",
                                    "Atualize o código e recompile para testar."
                                  ],
                                  "verification": "No runtime, o texto deve ter a cor correta sobre o fundo visível, com bom contraste (ratio >4.5:1).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE Java",
                                    "Ferramenta de verificação de contraste (ex: WebAIM online)",
                                    "Código base do Step 1"
                                  ],
                                  "tips": "Sempre defina setOpaque(true) para fundos coloridos funcionarem; prefira cores com alto contraste para acessibilidade.",
                                  "learningObjective": "Dominar o uso de Color e opacidade para criar labels visualmente distintos e acessíveis.",
                                  "commonMistakes": [
                                    "Omitir setOpaque(true), fazendo o fundo ficar transparente",
                                    "Escolher cores com baixo contraste, violando padrões WCAG",
                                    "Usar cores hardcoded sem considerar temas dark/light"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ajustar alinhamento e tamanho preferido do label",
                                  "subSteps": [
                                    "Configure alinhamento horizontal com label.setHorizontalAlignment(SwingConstants.CENTER);.",
                                    "Ajuste alinhamento vertical com label.setVerticalAlignment(SwingConstants.TOP);.",
                                    "Defina tamanho preferido com label.setPreferredSize(new Dimension(200, 40));.",
                                    "Adicione o label a um container como JPanel com layout adequado (ex: BorderLayout).",
                                    "Teste redimensionando a janela para verificar responsividade."
                                  ],
                                  "verification": "O texto deve estar alinhado corretamente e o label manter proporções ao redimensionar a interface.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE Java",
                                    "Código dos steps anteriores",
                                    "Documentação Swing para SwingConstants"
                                  ],
                                  "tips": "Use SwingConstants para alinhamentos padronizados; combine com layouts como GridBagLayout para controle fino.",
                                  "learningObjective": "Aprender a controlar posicionamento e dimensões para otimizar usabilidade visual.",
                                  "commonMistakes": [
                                    "Não usar layouts, causando desalinhamentos",
                                    "Definir tamanhos fixos sem considerar responsividade",
                                    "Confundir horizontal com vertical alignment"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar personalizações e validar usabilidade visual",
                                  "subSteps": [
                                    "Monte uma interface simples com múltiplos labels personalizados em um JFrame.",
                                    "Teste em diferentes tamanhos de tela e modos (dark/light se aplicável).",
                                    "Colete feedback visual: legibilidade, atratividade e consistência.",
                                    "Ajuste iterações baseadas em testes (ex: aumentar fonte se necessário).",
                                    "Documente as escolhas em comentários no código."
                                  ],
                                  "verification": "A interface completa deve exibir labels personalizados de forma harmoniosa, sem sobreposições ou ilegibilidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE Java",
                                    "Código completo dos steps anteriores",
                                    "Dispositivos com resoluções variadas para teste"
                                  ],
                                  "tips": "Priorize princípios de design como Fitts' Law para tamanhos clicáveis; teste com usuários reais se possível.",
                                  "learningObjective": "Integrar personalizações em contextos reais, avaliando impacto na experiência do usuário.",
                                  "commonMistakes": [
                                    "Ignorar responsividade, quebrando em telas pequenas",
                                    "Sobrecarregar com muitas customizações desnecessárias",
                                    "Não testar em runtime antes de finalizar"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um label para um formulário de login: 'Digite seu usuário' em fonte Arial Bold 14pt, texto azul escuro (#003366), fundo branco com borda sutil, alinhado à esquerda em um painel de 250x30 pixels. Integre em um JFrame com botão ao lado para simular uso real.",
                              "finalVerifications": [
                                "Todos os atributos (fonte, cores, alinhamento) são aplicados corretamente sem erros de compilação.",
                                "Contraste de cores atende WCAG AA (4.5:1 para texto normal).",
                                "Label mantém aparência consistente ao redimensionar a janela.",
                                "Texto é legível em diferentes ambientes de iluminação simulados.",
                                "Integração com outros componentes não causa desalinhamentos.",
                                "Tempo de renderização é fluido (sem lags visuais)."
                              ],
                              "assessmentCriteria": [
                                "Escolha de fonte e tamanho promove legibilidade e hierarquia visual (nota 1-5).",
                                "Contraste e harmonia de cores melhoram usabilidade e acessibilidade.",
                                "Alinhamento e dimensões são apropriados ao contexto da interface.",
                                "Customizações contribuem para UX intuitiva, sem excessos.",
                                "Código é limpo, comentado e segue boas práticas Swing.",
                                "Testes demonstram robustez em cenários variados."
                              ],
                              "crossCurricularConnections": [
                                "Design Gráfico: Princípios de tipografia e teoria das cores.",
                                "Acessibilidade e Inclusão: Padrões WCAG para interfaces digitais.",
                                "Psicologia: Impacto visual na percepção e atenção do usuário.",
                                "Matemática: Modelos de cores RGB/HSB e dimensões geométricas.",
                                "Artes Visuais: Composição e equilíbrio em layouts."
                              ],
                              "realWorldApplication": "Em aplicativos desktop como editores de texto (ex: Notepad++), painéis de dashboards empresariais ou interfaces de jogos, labels personalizados guiam usuários, destacam informações críticas (ex: erros em vermelho) e melhoram a retenção visual, elevando a satisfação do usuário em 20-30% conforme estudos UX."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.8.5.2.3",
                            "name": "Atualizar texto dinamicamente",
                            "description": "Alterar o conteúdo do label em resposta a eventos, utilizando métodos setText() ou configure().",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de atualização dinâmica de texto em Labels",
                                  "subSteps": [
                                    "Estude a documentação do método setText() para JLabel em Java Swing.",
                                    "Revise o ciclo de vida de componentes GUI e eventos de interface.",
                                    "Identifique cenários onde a atualização dinâmica é necessária, como respostas a ações do usuário.",
                                    "Analise exemplos simples de código estático vs. dinâmico.",
                                    "Desenhe um diagrama UML simples mostrando a interação entre botão e label."
                                  ],
                                  "verification": "Resuma em 3 frases o que é atualização dinâmica e liste 2 diferenças para atualização estática.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação Java Swing (Oracle Docs), IDE como IntelliJ ou Eclipse, editor de diagramas UML (ex: draw.io)",
                                  "tips": "Sempre importe javax.swing.* para evitar erros de classe não encontrada.",
                                  "learningObjective": "Entender o mecanismo de atualização de texto em Labels e sua integração com eventos.",
                                  "commonMistakes": "Confundir setText() com setLabelFor(); não importar pacotes Swing corretamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar um Label básico e atualizar estaticamente",
                                  "subSteps": [
                                    "Crie um JFrame simples com um JLabel centralizado.",
                                    "Defina texto inicial no Label usando setText() no construtor.",
                                    "Compile e execute para verificar exibição estática.",
                                    "Altere o texto manualmente no código e recompile para observar mudanças.",
                                    "Adicione formatação básica como fonte e cor para melhor visualização."
                                  ],
                                  "verification": "Execute o programa e confirme que o Label exibe texto fixo sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "IDE Java (Eclipse/NetBeans), JDK 8+",
                                  "tips": "Use BorderLayout para posicionamento fácil do Label.",
                                  "learningObjective": "Dominar a criação e configuração inicial de Labels com texto estático.",
                                  "commonMistakes": "Esquecer de chamar setVisible(true) no JFrame; usar strings vazias."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar atualização dinâmica via evento de botão",
                                  "subSteps": [
                                    "Adicione um JButton ao JFrame ao lado do Label.",
                                    "Registre um ActionListener no botão usando addActionListener().",
                                    "No método actionPerformed(), chame label.setText('Novo texto dinâmico').",
                                    "Teste clicando no botão múltiplas vezes para ver mudanças.",
                                    "Adicione lógica condicional, como alternar entre dois textos."
                                  ],
                                  "verification": "Clique no botão e verifique se o texto do Label muda instantaneamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "IDE Java, código base do passo anterior",
                                  "tips": "Use lambda expressions para ActionListener em Java 8+: button.addActionListener(e -> label.setText('Atualizado!'));",
                                  "learningObjective": "Implementar eventos que disparam atualizações dinâmicas em Labels.",
                                  "commonMistakes": "Não repintar a interface com revalidate() ou repaint() em casos complexos; erros de escopo de variáveis."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avançar com entradas do usuário e validações",
                                  "subSteps": [
                                    "Adicione um JTextField para input do usuário.",
                                    "Atualize o Label com o texto digitado via botão 'Atualizar'.",
                                    "Implemente validação: se campo vazio, exiba 'Erro: campo vazio'.",
                                    "Adicione um timer (javax.swing.Timer) para atualizar Label a cada 5s com hora atual.",
                                    "Teste cenários de erro e normal para robustez."
                                  ],
                                  "verification": "Digite texto, clique e confirme atualização; teste timer rodando.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "IDE Java, documentação Timer Swing",
                                  "tips": "Use SimpleDateFormat para formatar datas no Label.",
                                  "learningObjective": "Integrar inputs, validações e timers para atualizações avançadas.",
                                  "commonMistakes": "Não tratar NullPointerException em inputs vazios; esquecer de parar o timer."
                                }
                              ],
                              "practicalExample": "Crie um app de contador: um botão '+' incrementa um número no Label, começando em 0. Exemplo: Label mostra 'Contagem: 5' após 5 cliques, resetável por botão '-'.",
                              "finalVerifications": [
                                "O Label atualiza texto sem recompilar o programa.",
                                "Eventos de botão disparam mudanças corretas no texto.",
                                "Inputs do usuário são refletidos dinamicamente com validação.",
                                "Timer ou loops atualizam texto em intervalos sem travar UI.",
                                "Nenhum erro de compilação ou runtime ao testar múltiplas vezes.",
                                "Interface permanece responsiva durante atualizações."
                              ],
                              "assessmentCriteria": [
                                "Código limpo, com comentários e estrutura OOP (5/5).",
                                "Funcionalidade completa: atualizações via eventos e inputs (5/5).",
                                "Tratamento de erros e validações implementados (4/5).",
                                "Uso eficiente de recursos Swing, sem vazamentos (4/5).",
                                "Testes demonstrados com saídas variadas (5/5).",
                                "Integração com UML: diagrama de classes presente (3/5)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica condicional e contadores numéricos.",
                                "Português: Manipulação e formatação de strings dinâmicas.",
                                "Design: Princípios de UX para feedback visual em interfaces.",
                                "Física/Química: Simulações com atualizações em tempo real (ex: medidores)."
                              ],
                              "realWorldApplication": "Em dashboards de monitoramento (ex: apps de banco mostrando saldo atualizado), forms web dinâmicos, jogos com pontuação em tempo real, ou apps de chat exibindo mensagens novas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.5.3",
                        "name": "Caixas de Texto",
                        "description": "Caixas de texto permitem entrada e edição de dados pelo usuário, com suporte a single-line ou multi-line, representadas por classes como Entry ou Text em Tkinter.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.5.3.1",
                            "name": "Criar uma caixa de texto simples",
                            "description": "Instanciar Entry ou TextField, definir texto inicial e posicionar na interface com gerenciadores de layout.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente de desenvolvimento JavaFX",
                                  "subSteps": [
                                    "Verifique se o JDK 17+ está instalado e configurado na IDE (IntelliJ ou Eclipse).",
                                    "Crie um novo projeto JavaFX ou adicione dependências JavaFX via Maven/Gradle.",
                                    "Importe as classes necessárias: javafx.scene.control.TextField e javafx.scene.layout.*.",
                                    "Crie uma classe principal que estenda Application.",
                                    "Implemente o método start(Stage primaryStage)."
                                  ],
                                  "verification": "O projeto compila sem erros e exibe uma janela vazia ao executar.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "IDE com suporte JavaFX (IntelliJ IDEA)",
                                    "JDK 17+",
                                    "Dependências JavaFX"
                                  ],
                                  "tips": [
                                    "Use Maven para gerenciar dependências automaticamente.",
                                    "Teste o setup com um Stage simples antes de prosseguir.",
                                    "Ative módulos JavaFX no VM options se necessário: --module-path /path/to/javafx/lib --add-modules javafx.controls"
                                  ],
                                  "learningObjective": "Configurar um ambiente funcional para desenvolvimento de interfaces GUI em JavaFX.",
                                  "commonMistakes": [
                                    "Esquecer de adicionar módulos JavaFX no classpath.",
                                    "Não estender a classe Application.",
                                    "Usar JDK sem suporte a módulos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Instanciar e configurar o TextField básico",
                                  "subSteps": [
                                    "Declare uma variável TextField: TextField textField = new TextField();",
                                    "Defina o texto inicial: textField.setText(\"Digite aqui...\");",
                                    "Opcionalmente, defina prompt: textField.setPromptText(\"Exemplo de entrada\");",
                                    "Configure largura: textField.setPrefWidth(200);",
                                    "Teste a instanciação adicionando-a temporariamente a um layout vazio."
                                  ],
                                  "verification": "Ao executar, o TextField aparece com o texto inicial visível e permite digitação.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Código do Step 1",
                                    "Documentação JavaFX TextField"
                                  ],
                                  "tips": [
                                    "Use setPromptText para placeholders sem afetar getText().",
                                    "Prefira prefWidth sobre setWidth para responsividade.",
                                    "Sempre teste digitação para verificar eventos de foco."
                                  ],
                                  "learningObjective": "Criar e personalizar um componente TextField com propriedades essenciais.",
                                  "commonMistakes": [
                                    "Confundir setText com setPromptText.",
                                    "Não definir tamanho, resultando em campo muito estreito.",
                                    "Esquecer import javafx.scene.control.TextField."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Posicionar o TextField usando gerenciadores de layout",
                                  "subSteps": [
                                    "Crie um layout container: VBox root = new VBox(10);",
                                    "Adicione o TextField ao layout: root.getChildren().add(textField);",
                                    "Configure a cena: Scene scene = new Scene(root, 400, 300);",
                                    "Aplique a cena ao stage: primaryStage.setScene(scene);",
                                    "Defina título e mostre: primaryStage.setTitle(\"Caixa de Texto Simples\"); primaryStage.show();"
                                  ],
                                  "verification": "O TextField está centralizado ou posicionado corretamente na janela sem sobreposições.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código dos Steps 1-2",
                                    "Exemplos de VBox/HBox na doc JavaFX"
                                  ],
                                  "tips": [
                                    "Use VBox para empilhamento vertical simples.",
                                    "Adicione espaçamento com VBox.setSpacing(10).",
                                    "Teste redimensionamento da janela para verificar responsividade."
                                  ],
                                  "learningObjective": "Integrar componentes GUI em layouts hierárquicos para posicionamento preciso.",
                                  "commonMistakes": [
                                    "Não definir tamanho da Scene, causando janelas mínimas.",
                                    "Adicionar múltiplos filhos sem espaçamento.",
                                    "Esquecer primaryStage.show()."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e refinar a funcionalidade da caixa de texto",
                                  "subSteps": [
                                    "Adicione um listener simples: textField.textProperty().addListener((obs, old, newVal) -> System.out.println(newVal));",
                                    "Teste entrada, foco e prompt text.",
                                    "Ajuste propriedades como editable: textField.setEditable(true);",
                                    "Compile e execute o aplicativo completo.",
                                    "Documente o código com comentários sobre cada parte."
                                  ],
                                  "verification": "Texto é editável, prompt aparece em foco perdido, e mudanças são logadas no console.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Código completo dos steps anteriores"
                                  ],
                                  "tips": [
                                    "Use console para debug de eventos iniciais.",
                                    "Considere setFocusTraversable para navegação por teclado.",
                                    "Salve o projeto em Git para versionamento."
                                  ],
                                  "learningObjective": "Validar e aprimorar o comportamento interativo do componente.",
                                  "commonMistakes": [
                                    "Não testar em diferentes tamanhos de tela.",
                                    "Ignorar eventos de texto para validação.",
                                    "Deixar editable=false acidentalmente."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um formulário de login simples: instancie um TextField para 'Usuário' com texto inicial 'admin', posicione-o em um VBox ao lado de um Label, e adicione um Button abaixo. Ao digitar, imprima o valor no console. Código exemplo: VBox root = new VBox(10, new Label(\"Usuário:\"), textField, new Button(\"Login\"));",
                              "finalVerifications": [
                                "TextField é instanciado e visível na interface.",
                                "Texto inicial ou prompt é exibido corretamente.",
                                "Componente responde a entrada de usuário (digitação e foco).",
                                "Layout posiciona o TextField sem distorções ou sobreposições.",
                                "Aplicativo compila e executa sem erros de runtime.",
                                "Propriedades como largura e editabilidade funcionam como esperado."
                              ],
                              "assessmentCriteria": [
                                "Código limpo, comentado e segue convenções Java.",
                                "Uso correto de TextField e layout sem hacks.",
                                "Funcionalidade completa: instanciação, texto inicial e posicionamento.",
                                "Tratamento básico de eventos ou validação demonstrado.",
                                "Responsividade em diferentes tamanhos de janela.",
                                "Eficiência: sem vazamentos de memória ou loops infinitos."
                              ],
                              "crossCurricularConnections": [
                                "Design de UX/UI: Princípios de usabilidade em formulários.",
                                "Matemática: Cálculo de coordenadas e proporções em layouts.",
                                "Lógica de Programação: Eventos e propriedades observáveis.",
                                "Padrões de Projeto: Observer para listeners de texto."
                              ],
                              "realWorldApplication": "Desenvolvimento de formulários em aplicativos desktop como gerenciadores de login, editores de texto ou ferramentas de cadastro em sistemas empresariais, similar a campos de entrada em apps como editores de e-mail ou painéis de configuração."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.1.3"
                            ]
                          },
                          {
                            "id": "10.1.8.5.3.2",
                            "name": "Configurar validação e máscaras",
                            "description": "Implementar validação de entrada (ex: apenas números), limite de caracteres e modos editável/não editável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar propriedades básicas da caixa de texto",
                                  "subSteps": [
                                    "Criar uma instância de JTextField no código Java Swing.",
                                    "Definir o número de colunas com setColumns() para controlar o tamanho visual.",
                                    "Configurar o modo editável com setEditable(true/false).",
                                    "Adicionar o componente a um container como JPanel.",
                                    "Executar a aplicação com JFrame.setVisible(true)."
                                  ],
                                  "verification": "Verifique se a caixa de texto aparece com o tamanho correto e permite ou bloqueia edição conforme configurado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "IDE como IntelliJ ou Eclipse, JDK 8+, documentação Swing JTextField.",
                                  "tips": "Use setEditable(false) para campos de exibição apenas, como IDs gerados.",
                                  "learningObjective": "Compreender e aplicar propriedades fundamentais de JTextField para controle básico de entrada.",
                                  "commonMistakes": "Esquecer de adicionar o JTextField ao container ou não chamar revalidate() após mudanças."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar limite de caracteres",
                                  "subSteps": [
                                    "Obter o Document do JTextField com getDocument().",
                                    "Criar uma subclasse de PlainDocument e sobrescrever insertString() para limitar o comprimento.",
                                    "Definir uma constante MAX_LENGTH (ex: 11 para CPF).",
                                    "Verificar se o novo texto excederia o limite antes de inserir.",
                                    "Definir o Document customizado com setDocument()."
                                  ],
                                  "verification": "Digite mais caracteres que o limite; o excesso deve ser ignorado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Código base do Step 1, documentação PlainDocument.",
                                  "tips": "Teste com backspace para garantir que deleções funcionem corretamente.",
                                  "learningObjective": "Dominar o uso de Document para controlar o tamanho máximo de entrada.",
                                  "commonMistakes": "Não chamar super.insertString() após a verificação, causando falhas na inserção."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar validação de entrada específica (ex: apenas números)",
                                  "subSteps": [
                                    "Criar um DocumentFilter customizado estendendo AbstractDocument.FilterBypass.",
                                    "Sobrescrever replace() para filtrar apenas dígitos com Character.isDigit().",
                                    "Rejeitar entradas inválidas retornando false ou limpando o texto.",
                                    "Aplicar o filtro com ((AbstractDocument) textField.getDocument()).setDocumentFilter(filter).",
                                    "Testar com letras e símbolos para confirmar rejeição."
                                  ],
                                  "verification": "Insira letras ou símbolos; eles devem ser bloqueados, permitindo apenas números.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código dos steps anteriores, documentação DocumentFilter.",
                                  "tips": "Use replaceFilter para lidar com colar (paste) de texto inválido.",
                                  "learningObjective": "Aplicar filtros de documento para validação em tempo real de tipos de dados.",
                                  "commonMistakes": "Não tratar o caso de offset e length corretamente no replace(), permitindo entradas inválidas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar validação, máscaras e testar cenários completos",
                                  "subSteps": [
                                    "Combinar limite e filtro numérico em um único DocumentFilter.",
                                    "Adicionar um botão de validação final com InputVerifier para checks adicionais.",
                                    "Criar cenários de teste: edição, não edição, input inválido, limite atingido.",
                                    "Implementar feedback visual (ex: borda vermelha em erro com setBorder()).",
                                    "Executar e depurar a aplicação completa."
                                  ],
                                  "verification": "Todos os testes passam: limite respeitado, apenas números, modos editáveis funcionam.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Código completo, JUnit para testes unitários opcionais.",
                                  "tips": "Use SwingUtilities.invokeLater() para atualizações de UI seguras.",
                                  "learningObjective": "Integrar múltiplas validações em componentes GUI robustos.",
                                  "commonMistakes": "Conflitos entre filtros múltiplos; use um filtro composto."
                                }
                              ],
                              "practicalExample": "Crie um formulário de cadastro de CPF: JTextField com máscara numérica (apenas 11 dígitos), limite de 11 chars, inicialmente editável. Ao clicar 'Confirmar', valida se completo e formata como 000.000.000-00 se válido.",
                              "finalVerifications": [
                                "Caixa aceita apenas dígitos (0-9).",
                                "Entrada é truncada exatamente no limite de caracteres.",
                                "Modo não editável bloqueia digitação e colar.",
                                "Validação em tempo real sem travamentos na UI.",
                                "Feedback visual claro para erros de input.",
                                "Funciona com atalhos como Ctrl+V (colar inválido rejeitado)."
                              ],
                              "assessmentCriteria": [
                                "Código limpo com DocumentFilter corretamente implementado (80% peso).",
                                "Todos os substeps funcionais sem exceções (10% peso).",
                                "Testes manuais cobrem cenários edge (5% peso).",
                                "Comentários explicando lógica de filtro (3% peso).",
                                "Integração fluida em JFrame funcional (2% peso)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Validação de expressões regulares para padrões numéricos.",
                                "Design de UX: Princípios de feedback imediato e acessibilidade em interfaces.",
                                "Segurança da Informação: Prevenção de injeções via inputs sanitizados.",
                                "Lógica de Programação: Estruturas condicionais e filtros em fluxos de dados."
                              ],
                              "realWorldApplication": "Em sistemas de cadastro como bancos ou e-commerces, valida campos como telefone, CEP ou cartão de crédito, prevenindo erros de usuário e ataques de injeção SQL via inputs maliciosos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.3.1"
                            ]
                          },
                          {
                            "id": "10.1.8.5.3.3",
                            "name": "Capturar e processar entrada do usuário",
                            "description": "Recuperar texto com get() e associar eventos como onChange para processar dados em tempo real.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Caixa de Texto (JTextField) na Interface GUI",
                                  "subSteps": [
                                    "Importe as classes necessárias: javax.swing.* e java.awt.*",
                                    "Crie uma instância de JFrame como janela principal",
                                    "Instancie um JTextField com tamanho inicial (ex: new JTextField(20))",
                                    "Adicione o JTextField a um JPanel ou diretamente ao JFrame usando add()",
                                    "Configure o layout (ex: BorderLayout ou FlowLayout) e torne visível com setVisible(true)"
                                  ],
                                  "verification": "Execute o programa e confirme que a caixa de texto aparece na janela e aceita digitação",
                                  "estimatedTime": "10 minutos",
                                  "materials": "IDE (IntelliJ ou Eclipse), JDK 8+, documentação Swing JTextField",
                                  "tips": "Use setColumns(20) para definir largura fixa e evitar redimensionamento indesejado",
                                  "learningObjective": "Entender a criação e posicionamento básico de componentes de entrada em GUIs Java",
                                  "commonMistakes": "Esquecer de chamar pack() ou setVisible(true), resultando em janela invisível; não importar pacotes corretos"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Recuperar Texto Estático com getText()",
                                  "subSteps": [
                                    "Crie um JButton para acionar a recuperação (ex: new JButton('Capturar'))",
                                    "Adicione o botão à interface ao lado da caixa de texto",
                                    "Implemente um ActionListener no botão: button.addActionListener(e -> { String texto = textField.getText(); System.out.println(texto); })",
                                    "Teste digitando texto e clicando no botão para ver saída no console",
                                    "Adicione validação básica: if (texto.isEmpty()) { JOptionPane.showMessageDialog(null, 'Campo vazio!'); }"
                                  ],
                                  "verification": "Digite texto, clique no botão e verifique se o texto é impresso no console ou exibido em dialog",
                                  "estimatedTime": "15 minutos",
                                  "materials": "IDE com console/debugger, JOptionPane para feedback visual",
                                  "tips": "Use trim() em getText() para remover espaços em branco: textField.getText().trim()",
                                  "learningObjective": "Dominar a recuperação síncrona de dados de entrada do usuário via métodos getter",
                                  "commonMistakes": "Chamar getText() sem referenciar corretamente o campo (NullPointerException); ignorar texto vazio"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Associar Evento onChange com DocumentListener para Processamento em Tempo Real",
                                  "subSteps": [
                                    "Obtenha o Document do JTextField: Document doc = textField.getDocument();",
                                    "Crie uma classe anônima implementando DocumentListener: addDocumentListener(new DocumentListener() { ... })",
                                    "Implemente os métodos: insertUpdate, removeUpdate e changedUpdate para capturar mudanças",
                                    "No insertUpdate/removeUpdate: String textoAtual = textField.getText(); processe em tempo real (ex: valide comprimento)",
                                    "Registre o listener: doc.addDocumentListener(listener);"
                                  ],
                                  "verification": "Digite/caracteres na caixa e observe ações imediatas no console ou label de status",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação Java Swing DocumentListener, debugger para rastrear eventos",
                                  "tips": "Use SwingUtilities.invokeLater() em listeners para atualizações thread-safe na UI",
                                  "learningObjective": "Implementar listeners de eventos para detecção assíncrona e reativa de mudanças no texto",
                                  "commonMistakes": "Implementar apenas insertUpdate e esquecer removeUpdate; conflitos de thread sem invokeLater"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Processar e Validar Dados em Tempo Real com Feedback Visual",
                                  "subSteps": [
                                    "Adicione um JLabel para status (ex: JLabel statusLabel = new JLabel('Pronto');)",
                                    "No DocumentListener, processe: if (textoAtual.length() >= 5) { statusLabel.setText('Válido!'); } else { statusLabel.setText('Digite mais...'); }",
                                    "Inclua validação avançada: verifique se é número com try { Integer.parseInt(textoAtual); } catch (NumberFormatException e) { ... }",
                                    "Atualize a UI: statusLabel.repaint(); ou use SwingWorker para tarefas pesadas",
                                    "Teste cenários: digitação, backspace, colar texto"
                                  ],
                                  "verification": "Altere o texto e confirme feedback imediato no label sem delay ou lags",
                                  "estimatedTime": "15 minutos",
                                  "materials": "JLabel para UI feedback, exemplos de validação regex opcionais",
                                  "tips": "Debounce eventos com Timer para evitar processamento excessivo em digitação rápida",
                                  "learningObjective": "Integrar captura de entrada com lógica de negócio e feedback UX em tempo real",
                                  "commonMistakes": "Atualizações de UI fora da EDT (Event Dispatch Thread); validações sem tratamento de exceções"
                                }
                              ],
                              "practicalExample": "Crie um validador de senha em tempo real: ao digitar em um JTextField, o DocumentListener verifica força (comprimento >8, tem maiúscula/número) e atualiza um JLabel com 'Senha fraca/média/forte' e cor de fundo verde/vermelho.",
                              "finalVerifications": [
                                "Texto é recuperado corretamente com getText() em cliques e mudanças",
                                "Eventos de insert/removeUpdate disparam processamento imediato sem lags",
                                "Validações funcionam para cenários vazios, inválidos e válidos",
                                "Feedback visual atualiza na UI sem erros de thread",
                                "Console/debugger mostra logs de todos os eventos de mudança",
                                "Programa compila e roda sem exceções (NullPointer, NumberFormat)"
                              ],
                              "assessmentCriteria": [
                                "Precisão na captura: 100% dos textos digitados são processados corretamente",
                                "Responsividade: Mudanças refletem em <100ms",
                                "Robustez: Trata erros como texto vazio ou inválido sem crash",
                                "Código limpo: Listeners bem implementados, sem código duplicado",
                                "UX: Feedback claro e intuitivo para o usuário",
                                "Extensibilidade: Fácil adicionar novas validações"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Validação de expressões numéricas ou regex para padrões",
                                "Design de UX/UI: Princípios de feedback imediato e acessibilidade",
                                "Segurança da Informação: Validações de input para prevenir injeções",
                                "Lógica de Programação: Condicionais e exceções em fluxos reativos"
                              ],
                              "realWorldApplication": "Formulários de login em apps desktop/bancários (ex: validação CPF em tempo real), editores de texto com auto-complete (Notepad++), ou interfaces de chat com filtros de spam durante digitação."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.3.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.5.4",
                        "name": "Botões",
                        "description": "Botões são componentes interativos que respondem a cliques, acionando ações específicas, implementados por classes como Button em Tkinter ou JButton em Swing.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.5.4.1",
                            "name": "Criar um botão básico",
                            "description": "Instanciar Button com texto ou ícone e adicionar à janela, configurando posição e aparência inicial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de desenvolvimento e importar bibliotecas",
                                  "subSteps": [
                                    "Instale e abra um IDE como IntelliJ IDEA, Eclipse ou VS Code com extensão Java.",
                                    "Crie um novo projeto Java com JDK 8 ou superior.",
                                    "Adicione as importações necessárias: import javax.swing.*; e import java.awt.*;",
                                    "Verifique se não há erros de importação no código inicial.",
                                    "Compile um 'Hello World' simples para testar o ambiente."
                                  ],
                                  "verification": "O IDE não mostra erros de importação e o código compila sem problemas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "IDE Java (IntelliJ, Eclipse ou VS Code)",
                                    "JDK 8+ instalado"
                                  ],
                                  "tips": "Use imports específicos como 'import javax.swing.JButton;' para evitar conflitos em projetos grandes.",
                                  "learningObjective": "Compreender as dependências e bibliotecas Swing para desenvolvimento de GUIs.",
                                  "commonMistakes": [
                                    "Esquecer de importar pacotes Swing",
                                    "Usar AWT em vez de Swing",
                                    "JDK desatualizado causando incompatibilidades"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar a janela principal (JFrame)",
                                  "subSteps": [
                                    "Instancie um JFrame: JFrame janela = new JFrame('Minha Janela');",
                                    "Defina o tamanho da janela: janela.setSize(400, 300);",
                                    "Configure o comportamento de fechamento: janela.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);",
                                    "Posicione a janela no centro da tela: janela.setLocationRelativeTo(null);",
                                    "Não torne visível ainda para adicionar componentes."
                                  ],
                                  "verification": "Execute o código e confirme que uma janela vazia de 400x300 pixels abre e fecha corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código base do Step 1",
                                    "Documentação Swing JFrame"
                                  ],
                                  "tips": "Sempre defina setDefaultCloseOperation para evitar que o programa continue rodando em background.",
                                  "learningObjective": "Dominar a criação e configuração básica de uma janela contêiner em Swing.",
                                  "commonMistakes": [
                                    "Esquecer setSize ou setVisible",
                                    "Não definir close operation levando a processos zumbis",
                                    "Usar tamanhos muito pequenos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Instanciar e configurar o botão básico (JButton)",
                                  "subSteps": [
                                    "Crie o botão: JButton botao = new JButton('Clique Aqui');",
                                    "Adicione um ícone opcional: botao.setIcon(new ImageIcon('caminho/icone.png'));",
                                    "Defina posição e tamanho: botao.setBounds(50, 50, 150, 40);",
                                    "Configure aparência inicial: botao.setBackground(Color.BLUE); botao.setForeground(Color.WHITE);",
                                    "Adicione tooltip: botao.setToolTipText('Este é um botão de exemplo');"
                                  ],
                                  "verification": "Inspecione o objeto botão no debugger ou imprima suas propriedades para confirmar configurações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Imagens para ícone (opcional)",
                                    "Tabela de cores Java AWT"
                                  ],
                                  "tips": "Use setBounds apenas com layout null; prefira layouts como BorderLayout para apps reais.",
                                  "learningObjective": "Aprender a personalizar propriedades visuais e posicionais de um JButton.",
                                  "commonMistakes": [
                                    "Posição fora dos limites da janela",
                                    "Ícone com caminho inválido causando null pointer",
                                    "Cores incompatíveis reduzindo legibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar o botão à janela e exibir a interface",
                                  "subSteps": [
                                    "Configure layout absoluto se usando bounds: janela.getContentPane().setLayout(null);",
                                    "Adicione o botão: janela.add(botao);",
                                    "Torne a janela visível: janela.setVisible(true);",
                                    "Teste a compilação e execução completa.",
                                    "Ajuste posição se necessário para centralizar o botão."
                                  ],
                                  "verification": "Execute o programa e confirme que o botão aparece na posição correta com texto/ícone e aparência definida.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código completo dos steps anteriores"
                                  ],
                                  "tips": "Evite layout null em produção; use FlowLayout ou BorderLayout para responsividade.",
                                  "learningObjective": "Integrar componentes à janela e gerenciar visibilidade da GUI.",
                                  "commonMistakes": [
                                    "Esquecer janela.add(botao)",
                                    "Layout não configurado causando sobreposição",
                                    "setVisible antes de add"
                                  ]
                                }
                              ],
                              "practicalExample": "```java\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class BotaoExemplo {\n    public static void main(String[] args) {\n        JFrame janela = new JFrame('Botão Básico');\n        janela.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        janela.setSize(400, 300);\n        janela.getContentPane().setLayout(null);\n        \n        JButton botao = new JButton('Clique Aqui');\n        botao.setBounds(100, 100, 200, 50);\n        botao.setBackground(Color.GREEN);\n        janela.add(botao);\n        \n        janela.setVisible(true);\n    }\n}``` Este código cria uma janela com um botão verde centralizado.",
                              "finalVerifications": [
                                "A janela abre sem erros de compilação ou runtime.",
                                "O botão é visível com texto/ícone e aparência configurada.",
                                "O botão responde a hover (muda cor ou mostra tooltip).",
                                "Fechando a janela, o programa termina completamente.",
                                "Posição e tamanho do botão estão corretos dentro da janela.",
                                "Nenhum componente sobreposto ou desalinhado."
                              ],
                              "assessmentCriteria": [
                                "Código compila e executa sem exceções.",
                                "Propriedades do botão (texto, ícone, cor, posição) aplicadas corretamente.",
                                "Uso correto de JFrame como contêiner.",
                                "Layout configurado adequadamente para exibição.",
                                "Código limpo, indentado e comentado.",
                                "Tempo de execução eficiente sem lags."
                              ],
                              "crossCurricularConnections": [
                                "Design Gráfico: Princípios de UI/UX para posicionamento e cores acessíveis.",
                                "Matemática: Cálculo de coordenadas (x, y) e dimensões para layout.",
                                "Lógica de Programação: Sequência de instanciação e adição de objetos.",
                                "Artes Visuais: Escolha de ícones e paletas de cores harmoniosas."
                              ],
                              "realWorldApplication": "Criação de interfaces em aplicativos desktop como editores de texto (botões Salvar/Abrir), jogos simples (botões Iniciar/Pausar) ou ferramentas empresariais (botões Confirmar/Cancelar), base para frameworks como JavaFX ou web com HTML/CSS."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.1.3"
                            ]
                          },
                          {
                            "id": "10.1.8.5.4.2",
                            "name": "Associar ações a eventos de clique",
                            "description": "Definir callbacks ou command handlers (ex: lambda ou função em Python) para executar código ao clicar.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente GUI básico com tkinter",
                                  "subSteps": [
                                    "Instale o tkinter se necessário (geralmente vem com Python).",
                                    "Importe o módulo tkinter: from tkinter import *.",
                                    "Crie a janela principal: root = Tk() e configure título e tamanho com root.title() e root.geometry().",
                                    "Inicie o loop principal: root.mainloop().",
                                    "Teste executando um script simples para ver a janela vazia."
                                  ],
                                  "verification": "Uma janela GUI vazia abre sem erros ao executar o script.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Python instalado com tkinter, editor de código (VS Code ou IDLE).",
                                  "tips": "Sempre chame root.mainloop() no final para manter a janela aberta.",
                                  "learningObjective": "Compreender a estrutura básica de uma aplicação GUI em Python com tkinter.",
                                  "commonMistakes": "Esquecer de importar tkinter ou chamar mainloop(), causando janela que não abre."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar e posicionar um botão na interface",
                                  "subSteps": [
                                    "Crie o botão: button = Button(root, text='Clique Aqui').",
                                    "Posicione o botão usando pack(): button.pack().",
                                    "Personalize o botão com parâmetros como width, height, bg, fg.",
                                    "Execute e verifique se o botão aparece na janela.",
                                    "Experimente diferentes métodos de layout como grid() ou place()."
                                  ],
                                  "verification": "O botão é visível e centralizado na janela GUI.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Script Python anterior, documentação tkinter Button.",
                                  "tips": "Use pack() para layouts simples; grid() para tabelas.",
                                  "learningObjective": "Dominar a criação e posicionamento de widgets Button em tkinter.",
                                  "commonMistakes": "Não chamar pack() ou grid(), fazendo o botão invisível."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir uma função callback para a ação do clique",
                                  "subSteps": [
                                    "Defina uma função simples: def on_click(): print('Botão clicado!').",
                                    "Alternativamente, use lambda: lambda: print('Lambda acionado!').",
                                    "Adicione lógica mais complexa, como alterar texto de um Label.",
                                    "Crie um Label para feedback: label = Label(root, text=''). label.pack().",
                                    "Atualize o Label na função: label.config(text='Clicado!').",
                                    "Teste a função isoladamente chamando-a diretamente."
                                  ],
                                  "verification": "Executar a função manualmente produz o output esperado no console ou na GUI.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Script com botão, console para debugar prints.",
                                  "tips": "Funções callback não devem receber argumentos extras; use lambda para passar parâmetros.",
                                  "learningObjective": "Criar funções ou lambdas acionáveis como handlers de eventos.",
                                  "commonMistakes": "Passar argumentos errados à função, causando TypeError."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Associar a função ao evento de clique do botão",
                                  "subSteps": [
                                    "Use o método bind: button.bind('<Button-1>', on_click).",
                                    "Ou configure command no Button: button = Button(..., command=on_click).",
                                    "Diferencie: command para ação padrão de clique; bind para eventos específicos.",
                                    "Execute a aplicação e clique no botão várias vezes.",
                                    "Adicione tratamento de erros com try-except na callback."
                                  ],
                                  "verification": "Clicar no botão executa a callback sem erros, produzindo o efeito esperado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Script completo, documentação tkinter bind e command.",
                                  "tips": "command= é mais simples para cliques; bind= para eventos avançados como duplo-clique.",
                                  "learningObjective": "Vincular eventos de usuário (clique) a ações de código via callbacks.",
                                  "commonMistakes": "Passar a função com parênteses (on_click()), executando-a imediatamente."
                                }
                              ],
                              "practicalExample": "Crie uma calculadora simples: botão '+' que soma dois números em Labels. Código: from tkinter import *; root=Tk(); num1=Label(root,text='2'); num1.pack(); num2=Label(root,text='3'); num2.pack(); result=Label(root,text=''); result.pack(); def somar(): result.config(text=str(int(num1.cget('text'))+int(num2.cget('text')))); Button(root,text='+',command=somar).pack(); root.mainloop(). Clique no botão para ver '5'.",
                              "finalVerifications": [
                                "A janela GUI abre com botão visível.",
                                "Clique único executa exatamente uma vez a callback.",
                                "Múltiplos cliques acumulam efeitos corretamente.",
                                "Sem erros no console ao clicar.",
                                "Fechar a janela encerra sem crashes.",
                                "Lambda alternativa funciona identicamente."
                              ],
                              "assessmentCriteria": [
                                "Código usa corretamente command ou bind sem erros sintáticos.",
                                "Callback executa ação específica e mensurável (ex: print, label update).",
                                "Layout do botão é funcional e responsivo.",
                                "Função callback é modular e reutilizável.",
                                "Inclui tratamento básico de eventos sem vazamentos de memória.",
                                "Tempo de resposta ao clique é instantâneo (<100ms)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica de eventos em algoritmos reativos.",
                                "Design: Princípios de UX para botões intuitivos.",
                                "Física: Modelagem de interações homem-máquina como sistemas de eventos.",
                                "Linguagens: Paradigma event-driven em outras linguagens (JS, C#)."
                              ],
                              "realWorldApplication": "Em aplicativos desktop como editores de texto (salvar ao clicar), jogos (pular níveis), dashboards web (filtrar dados), ou automações industriais (acionar relés via GUI)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.4.1"
                            ]
                          },
                          {
                            "id": "10.1.8.5.4.3",
                            "name": "Gerenciar estados do botão",
                            "description": "Controlar estados como enabled/disabled, hover effects e feedback visual para melhor UX.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e Definir os Estados Básicos do Botão",
                                  "subSteps": [
                                    "Pesquise a documentação da biblioteca GUI (ex: JButton no Java Swing ou equivalente em outras frameworks como Qt ou HTML/CSS para web).",
                                    "Identifique estados principais: normal/default, hover/mouse-over, pressed/active, disabled e focus.",
                                    "Crie um diagrama simples (UML state diagram) ilustrando transições entre estados.",
                                    "Defina condições de ativação para cada estado (ex: disabled quando dados inválidos).",
                                    "Documente visualmente cada estado com sketches ou screenshots de referência."
                                  ],
                                  "verification": "Diagrama de estados criado e condições listadas em um arquivo de notas ou comentário no código.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação da API GUI (ex: Oracle Java Swing docs)",
                                    "Ferramenta de diagramação como Draw.io ou papel e caneta",
                                    "Editor de código"
                                  ],
                                  "tips": "Use exemplos oficiais da biblioteca para evitar reinventar padrões nativos.",
                                  "learningObjective": "Compreender os estados visuais e lógicos de um botão para planejar sua implementação.",
                                  "commonMistakes": [
                                    "Ignorar o estado focus para acessibilidade",
                                    "Confundir hover (mouse sobre) com pressed (clique)",
                                    "Não considerar estados em diferentes temas (light/dark mode)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Controle de Estados Enabled/Disabled",
                                  "subSteps": [
                                    "Crie um botão básico em sua interface (ex: JButton btnLogin = new JButton('Login');).",
                                    "Adicione lógica condicional para setEnabled(true/false) baseada em validações (ex: campos de form preenchidos).",
                                    "Integre eventos como ActionListener para alternar estados dinamicamente (ex: disable no clique inicial).",
                                    "Teste manualmente alternando estados via código ou UI.",
                                    "Adicione tooltips ou labels explicativos para estado disabled (ex: 'Preencha o email primeiro')."
                                  ],
                                  "verification": "Botão habilita/desabilita corretamente ao alterar condições de validação, sem erros de NullPointer.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE com suporte a GUI (ex: IntelliJ com Swing)",
                                    "Exemplo de form simples com campos de input"
                                  ],
                                  "tips": "Sempre chame revalidate() e repaint() após mudanças de estado em containers dinâmicos.",
                                  "learningObjective": "Controlar programaticamente a interatividade do botão com base em lógica de negócio.",
                                  "commonMistakes": [
                                    "Esquecer de desabilitar durante processamento assíncrono",
                                    "Não restaurar enabled após erro",
                                    "Usar apenas setVisible em vez de setEnabled"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar Efeitos Hover e Feedback Visual",
                                  "subSteps": [
                                    "Implemente MouseListener para detectar hover/enter/exit (ex: btn.addMouseListener(new HoverHandler());).",
                                    "Altere propriedades visuais no hover: cor de fundo, borda, cursor (ex: setBackground(Color.BLUE); setCursor(Cursor.HAND_CURSOR);).",
                                    "Adicione feedback para pressed: animação sutil ou mudança de ícone.",
                                    "Inclua feedback visual extra como ícone de loading (ex: setIcon(loadingIcon)) durante ações longas.",
                                    "Garanta transições suaves usando Timer ou animações nativas da biblioteca."
                                  ],
                                  "verification": "Hover muda aparência instantaneamente, pressed dá feedback tátil/visual, e loading aparece em simulação de delay.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ícones gratuitos (ex: FontAwesome ou Material Icons)",
                                    "Biblioteca de animações se disponível (ex: JavaFX Transitions)"
                                  ],
                                  "tips": "Mantenha consistência com o tema da aplicação; teste em diferentes resoluções.",
                                  "learningObjective": "Melhorar a UX com respostas visuais imediatas e intuitivas aos inputs do usuário.",
                                  "commonMistakes": [
                                    "Efeitos muito exagerados que distraem",
                                    "Não remover listeners em hover ao desabilitar",
                                    "Ignorar hover em touch devices (usar :active em CSS equivalente)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar Transições, Acessibilidade e Otimizar UX",
                                  "subSteps": [
                                    "Teste todos os estados em cenários reais: mouse, teclado (Tab + Enter), touch simulado.",
                                    "Verifique acessibilidade: contraste de cores (WCAG AA), ARIA labels para screen readers (ex: setAccessibleName).",
                                    "Otimize performance: evite loops infinitos em listeners, use weak references se necessário.",
                                    "Colete feedback de usuário simulado: grave vídeo de interação e analise.",
                                    "Refatore código em métodos reutilizáveis (ex: classe ButtonStateManager)."
                                  ],
                                  "verification": "Todos estados funcionam sem falhas em testes unitários e manuais; relatório de acessibilidade ok.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de acessibilidade (ex: WAVE ou Lighthouse)",
                                    "Screen recorder",
                                    "JUnit para testes automatizados"
                                  ],
                                  "tips": "Priorize mobile-first se aplicável; use focus-visible para evitar hover em teclado.",
                                  "learningObjective": "Garantir que o gerenciamento de estados seja robusto, acessível e user-friendly.",
                                  "commonMistakes": [
                                    "Baixo contraste em disabled (torna invisível)",
                                    "Não testar em navegadores/browsers diferentes",
                                    "Listeners não removidos causando memory leaks"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um formulário de login: botão 'Entrar' disabled até email/senha válidos; no hover, destaca com sombra azul; ao clicar, desabilita, mostra spinner de loading por 2s simulados, então habilita com ícone de check verde se sucesso.",
                              "finalVerifications": [
                                "Botão alterna corretamente entre enabled/disabled baseado em validações.",
                                "Hover e pressed fornecem feedback visual imediato e reversível.",
                                "Feedback de loading aparece durante ações assíncronas e desaparece adequadamente.",
                                "Estados funcionam via mouse, teclado e touch.",
                                "Contraste e labels atendem padrões de acessibilidade básica.",
                                "Nenhum erro de console ou crash durante transições rápidas."
                              ],
                              "assessmentCriteria": [
                                "Código modular e comentado, com métodos dedicados por estado.",
                                "UX intuitiva: usuário entende imediatamente o estado e ações possíveis.",
                                "Performance: sem lags ou memory leaks em testes repetidos.",
                                "Conformidade com padrões da biblioteca GUI (ex: LAF no Swing).",
                                "Reutilizabilidade: classe ou métodos aplicáveis a outros botões.",
                                "Cobertura de testes: pelo menos 80% dos estados testados automaticamente."
                              ],
                              "crossCurricularConnections": [
                                "Design de UX/UI: Princípios de affordance e feedback (Don Norman).",
                                "Acessibilidade: WCAG 2.1 guidelines para controles interativos.",
                                "Padrões de Projeto: State Pattern para gerenciar estados complexos.",
                                "Testes de Software: Unit e usability testing.",
                                "Animações e Gráficos: Transições CSS/JavaFX para efeitos suaves."
                              ],
                              "realWorldApplication": "Botões de submit em e-commerces (desabilita no checkout para evitar double-submit), controles de jogos (disabled até power-up), apps mobile (hover simulado via long-press), dashboards (loading em refresh de dados)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.4.2"
                            ]
                          },
                          {
                            "id": "10.1.8.5.4.4",
                            "name": "Integrar botão com outros componentes",
                            "description": "Usar botão para interagir com labels, caixas de texto (ex: limpar ou submeter dados), demonstrando composição OOP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar os componentes básicos individuais",
                                  "subSteps": [
                                    "Crie uma classe principal que estenda JFrame para o container principal.",
                                    "Instancie um JLabel para exibir texto informativo (ex: 'Digite seu nome:').",
                                    "Instancie um JTextField para entrada de dados do usuário.",
                                    "Instancie um JButton com texto 'Limpar' ou 'Submeter'.",
                                    "Configure propriedades iniciais como tamanho, posição e texto dos componentes."
                                  ],
                                  "verification": "Verifique no código se todos os componentes foram declarados e inicializados corretamente sem erros de compilação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE com suporte a Java (Eclipse ou IntelliJ)",
                                    "Biblioteca Swing (javax.swing)"
                                  ],
                                  "tips": "Use variáveis de instância para os componentes para facilitar o acesso posterior.",
                                  "learningObjective": "Compreender a criação e configuração inicial de componentes GUI em OOP.",
                                  "commonMistakes": "Esquecer de importar javax.swing.* ou usar nomes de classes incorretos como 'Button' em vez de 'JButton'."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Adicionar componentes a um container e layout",
                                  "subSteps": [
                                    "Crie um JPanel como container para os componentes.",
                                    "Use um layout manager simples como FlowLayout ou BorderLayout.",
                                    "Adicione o JLabel, JTextField e JButton ao JPanel usando add().",
                                    "Adicione o JPanel ao JFrame.",
                                    "Configure o tamanho da janela e torne-a visível com setVisible(true)."
                                  ],
                                  "verification": "Execute o programa e confirme que todos os componentes aparecem na interface sem sobreposições.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE com suporte a Java",
                                    "Documentação Swing para layouts"
                                  ],
                                  "tips": "Comece com FlowLayout para simplicidade; ajuste para layouts mais complexos depois.",
                                  "learningObjective": "Dominar a composição de componentes em containers OOP.",
                                  "commonMistakes": "Não chamar setVisible(true) ou pack() no JFrame, resultando em janela invisível."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o ActionListener no botão",
                                  "subSteps": [
                                    "Crie uma classe interna ou anônima que implemente ActionListener.",
                                    "Registre o listener no botão com botão.addActionListener().",
                                    "No método actionPerformed(), capture o texto do JTextField com getText().",
                                    "Implemente lógica para limpar: setText('') no JTextField e atualize JLabel.",
                                    "Para submeter, valide o texto e exiba mensagem no JLabel (ex: 'Dados submetidos!')."
                                  ],
                                  "verification": "Clique no botão e observe se o TextField é limpo e JLabel atualizado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE com suporte a Java",
                                    "Exemplos de ActionListener na documentação Oracle"
                                  ],
                                  "tips": "Use lambda expressions (Java 8+) para listeners curtos: botão.addActionListener(e -> { ... });",
                                  "learningObjective": "Aplicar programação de eventos e composição OOP para interações dinâmicas.",
                                  "commonMistakes": "Não importar java.awt.event.ActionListener ou confundir ActionEvent com parâmetros errados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar integrações e refatorar para padrões OOP",
                                  "subSteps": [
                                    "Teste cenários: entrada vazia, texto válido, múltiplos cliques.",
                                    "Adicione validações (ex: if texto.isEmpty() mostrar alerta no JLabel).",
                                    "Encapsule lógica em métodos privados para melhor organização.",
                                    "Verifique composição OOP: componentes como atributos da classe principal.",
                                    "Compile e execute testes finais para robustez."
                                  ],
                                  "verification": "Registre logs ou use System.out.println para confirmar ações em diferentes fluxos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE com debugger",
                                    "Ferramentas de teste unitário como JUnit para GUI básica"
                                  ],
                                  "tips": "Use debugger para pausar no actionPerformed e inspecionar estados.",
                                  "learningObjective": "Garantir robustez e aderência a princípios OOP como encapsulamento.",
                                  "commonMistakes": "Não tratar exceções ou casos edge, como texto nulo causando NullPointerException."
                                }
                              ],
                              "practicalExample": "Crie um formulário simples de 'Cadastro de Nome': JLabel 'Nome:', JTextField para entrada, JButton 'Submeter'. Ao clicar, se o campo não estiver vazio, JLabel muda para 'Nome submetido: [texto]', senão limpa e avisa 'Campo vazio!'. Demonstra composição onde JFrame contém JPanel com Label, Field e Button.",
                              "finalVerifications": [
                                "Botão responde imediatamente ao clique sem atrasos.",
                                "JTextField é limpo ou processado corretamente.",
                                "JLabel reflete mudanças dinâmicas baseadas na ação.",
                                "Nenhuma exceção é lançada em testes variados.",
                                "Interface permanece responsiva após múltiplas interações.",
                                "Código compila e executa em diferentes tamanhos de janela."
                              ],
                              "assessmentCriteria": [
                                "Uso correto de composição OOP (componentes como atributos encapsulados).",
                                "Implementação precisa de ActionListener sem vazamentos de memória.",
                                "Lógica de interação funcional e sem bugs em cenários comuns.",
                                "Código limpo, com comentários e métodos bem nomeados.",
                                "Adesão a padrões GUI Swing (layouts apropriados).",
                                "Validações básicas implementadas para entradas inválidas."
                              ],
                              "crossCurricularConnections": [
                                "Lógica de Programação: Uso de condicionais if/else em eventos.",
                                "Design de Interfaces: Princípios de UX para botões acionáveis.",
                                "Matemática Computacional: Validações booleanas em strings.",
                                "Padrões de Projeto: Observer pattern implícito em listeners."
                              ],
                              "realWorldApplication": "Em aplicativos desktop como editores de texto (botão 'Limpar Tudo'), formulários de login em softwares empresariais ou painéis de controle em ferramentas de gerenciamento, onde botões integram com campos para submissão e limpeza de dados dinamicamente."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.2.3",
                              "10.1.8.5.3.3",
                              "10.1.8.5.4.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.8.6",
                    "name": "Gerenciamento de Eventos em GUI",
                    "description": "Tratamento de cliques, teclas e callbacks em interfaces gráficas orientadas a objetos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.8.6.1",
                        "name": "Eventos de Usuário em Interfaces Gráficas",
                        "description": "Compreensão dos eventos gerados por interações do usuário em GUIs orientadas a objetos, incluindo cliques do mouse e pressionamentos de teclas, e sua representação em linguagens como Python (tkinter) ou C++ (Qt).",
                        "specificSkills": [
                          {
                            "id": "10.1.8.6.1.1",
                            "name": "Identificar tipos de eventos de clique",
                            "description": "Diferenciar eventos de clique simples, duplo clique e eventos de mouse (press, release, motion) em componentes GUI, utilizando abstração de classes de eventos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Eventos de Mouse",
                                  "subSteps": [
                                    "Estude a hierarquia de classes de eventos em GUI (ex: MouseEvent herda de InputEvent)",
                                    "Identifique propriedades comuns: getX(), getY(), getButton(), getClickCount()",
                                    "Revise documentação oficial (ex: Java AWT/Swing MouseEvent API)",
                                    "Anote diferenças entre eventos de mouse e teclado",
                                    "Crie um diagrama UML simples da classe MouseEvent"
                                  ],
                                  "verification": "Crie um resumo escrito listando 5 propriedades chave de MouseEvent e explique seu propósito",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Java MouseEvent API",
                                    "Editor de texto ou diagrama UML online (ex: draw.io)"
                                  ],
                                  "tips": "Comece pela hierarquia de classes para visualizar abstrações OO",
                                  "learningObjective": "Entender a abstração de classes de eventos de mouse em frameworks GUI",
                                  "commonMistakes": [
                                    "Confundir MouseEvent com ActionEvent",
                                    "Ignorar herança de InputEvent"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar Clique Simples e Duplo Clique",
                                  "subSteps": [
                                    "Implemente um listener para mouseClicked() e use getClickCount() para distinguir 1 vs 2 cliques",
                                    "Teste em um componente JButton ou JPanel com System.out.println para logs",
                                    "Adicione delays artificiais para simular timing de cliques",
                                    "Registre coordenadas e botões envolvidos (esquerdo/direito)",
                                    "Refatore código para uma classe handler dedicada"
                                  ],
                                  "verification": "Execute o código e demonstre logs diferenciando clique simples (count=1) de duplo (count=2)",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "IDE com Java/Swing (ex: IntelliJ, Eclipse)",
                                    "JFrame básico para testes"
                                  ],
                                  "tips": "Use MouseAdapter para simplificar implementação de listeners",
                                  "learningObjective": "Aplicar getClickCount() para identificar tipos de cliques em eventos",
                                  "commonMistakes": [
                                    "Não verificar getClickCount() > 1",
                                    "Confundir mouseClicked() com mousePressed()"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Eventos de Press, Release e Motion",
                                  "subSteps": [
                                    "Registre mousePressed(), mouseReleased() e mouseDragged()/mouseMoved()",
                                    "Capture estados: botão pressionado, solto e movimento contínuo",
                                    "Implemente desenho dinâmico (ex: traçar linha em motion)",
                                    "Diferencie dragged (com botão) vs moved (sem botão)",
                                    "Adicione validações para coordenadas e botões específicos"
                                  ],
                                  "verification": "Crie um painel que desenha linhas em motion/dragged e logs press/release; grave vídeo curto de teste",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "IDE Java/Swing",
                                    "Graphics2D para desenho em JPanel"
                                  ],
                                  "tips": "Consuma eventos desnecessários com return para evitar propagação",
                                  "learningObjective": "Distinguir eventos de estado do mouse (press/release/motion) via métodos específicos",
                                  "commonMistakes": [
                                    "Não consumir eventos em motion levando a loops",
                                    "Ignorar modifiers para botões"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e Abstrair Gerenciamento de Eventos de Clique",
                                  "subSteps": [
                                    "Crie uma classe abstrata EventHandler com métodos sobrescritos para cada tipo",
                                    "Registre o handler em múltiplos componentes GUI",
                                    "Teste cenários compostos: duplo clique com motion",
                                    "Adicione logging estruturado para todos os eventos",
                                    "Refatore para usar enums para tipos de evento detectados"
                                  ],
                                  "verification": "Implemente app completo com handler abstrato e liste todos os eventos capturados corretamente",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código dos steps anteriores",
                                    "UML tool para classe abstrata"
                                  ],
                                  "tips": "Use interfaces como MouseListener/MouseMotionListener para polimorfismo",
                                  "learningObjective": "Utilizar abstração OO para gerenciar múltiplos tipos de eventos de clique",
                                  "commonMistakes": [
                                    "Não implementar todas as interfaces necessárias",
                                    "Event bubbling não controlado"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um editor de desenho simples em Swing onde: clique simples seleciona ferramenta, duplo clique abre propriedades, press+drag desenha linhas, release finaliza stroke, e motion atualiza preview.",
                              "finalVerifications": [
                                "Liste e explique diferenças entre mouseClicked(), mousePressed(), mouseReleased(), mouseDragged() e mouseMoved()",
                                "Forneça código funcional diferenciando clique simples vs duplo com getClickCount()",
                                "Demonstre app testando todos os eventos com logs ou visuais",
                                "Crie diagrama UML da hierarquia MouseEvent",
                                "Identifique e corrija 3 erros comuns em um código buggy fornecido"
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção de eventos (100% cobertura dos tipos solicitados)",
                                "Uso correto de APIs como getClickCount(), getButton(), coordenadas",
                                "Abstração OO adequada (classes/interfaces handlers)",
                                "Código limpo, testável e sem vazamentos de eventos",
                                "Explicações claras em comentários ou docs",
                                "Eficiência temporal: eventos consumidos quando necessário"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de coordenadas (getX/Y) e vetores em motion",
                                "Design de UX/UI: Timing e feedback para cliques intuitivos",
                                "Física: Modelagem de estados (press/release como forças)",
                                "Lógica Matemática: Estados finitos para tracking de cliques"
                              ],
                              "realWorldApplication": "Em editores de imagem (Photoshop: tools selection via clicks), jogos (double-click para ações rápidas), interfaces web/mobile (hover/motion para tooltips), e apps desktop (drag-drop em explorers de arquivos)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.6.1.2",
                            "name": "Identificar eventos de teclado",
                            "description": "Reconhecer eventos de key press, key release e teclas especiais (como Enter, Escape) em widgets de entrada de texto ou janelas principais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Eventos de Teclado",
                                  "subSteps": [
                                    "Estude a definição de eventos de teclado: keyPressed (pressionamento inicial), keyReleased (liberação) e keyTyped (digitação efetiva).",
                                    "Revise a hierarquia de eventos em GUI, focando em KeyEvent e KeyListener.",
                                    "Analise exemplos de documentação oficial para entender parâmetros como getKeyCode() e getKeyChar().",
                                    "Compare keyPressed vs keyTyped em cenários de teclas especiais.",
                                    "Anote diferenças entre eventos em contextos de widgets vs janelas."
                                  ],
                                  "verification": "Crie um diagrama mental ou mapa conceitual resumindo os três tipos de eventos e suas diferenças.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação Java Swing KeyListener (Oracle Docs), editor de texto para anotações.",
                                  "tips": "Use analogias físicas: keyPressed é como apertar um botão, keyReleased é soltar.",
                                  "learningObjective": "Diferenciar precisamente os tipos de eventos de teclado e seus triggers.",
                                  "commonMistakes": "Confundir keyTyped (só para caracteres imprimíveis) com keyPressed (todas as teclas)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Eventos de Teclado em Widgets de Entrada de Texto",
                                  "subSteps": [
                                    "Examine código de um JTextField com KeyListener anexado.",
                                    "Identifique chamadas para keyPressed, keyReleased e keyTyped no listener.",
                                    "Teste em uma IDE: adicione prints para observar sequência de eventos ao digitar.",
                                    "Registre eventos para teclas alfanuméricas vs especiais em campos de texto.",
                                    "Modifique o código para filtrar apenas eventos em JTextField."
                                  ],
                                  "verification": "Execute o código e liste a sequência exata de eventos ao pressionar 'A' e Enter.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "IDE com Java (Eclipse/IntelliJ), JFrame simples com JTextField.",
                                  "tips": "Foque no foco do componente: eventos só disparam se o widget estiver focado.",
                                  "learningObjective": "Reconhecer implementação e disparo de eventos de teclado em inputs de texto.",
                                  "commonMistakes": "Ignorar que JTextField consome alguns eventos por padrão (ex: Enter para nova linha)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Eventos de Teclado em Janelas Principais",
                                  "subSteps": [
                                    "Configure KeyListener na JFrame ou JWindow principal.",
                                    "Compare comportamento: eventos globais vs componentes filhos.",
                                    "Teste keyPressed para Escape e Enter sem foco em widgets filhos.",
                                    "Analise propagação de eventos da janela para componentes.",
                                    "Desabilite consumo de eventos em componentes para captura na janela."
                                  ],
                                  "verification": "Demonstre código onde Escape fecha a janela via keyPressed na JFrame.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "IDE Java, JFrame vazia para testes.",
                                  "tips": "Use addKeyListener na janela e requestFocus() para garantir captura.",
                                  "learningObjective": "Distinguir captura de eventos de teclado em containers raiz vs folhas.",
                                  "commonMistakes": "Esquecer de chamar requestFocusInWindow() na janela."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar e Testar Teclas Especiais",
                                  "subSteps": [
                                    "Liste códigos de teclas especiais: VK_ENTER (10), VK_ESCAPE (27).",
                                    "Implemente lógica condicional com getKeyCode() == KeyEvent.VK_ENTER.",
                                    "Teste keyPressed para Enter (ação) vs keyTyped (caractere).",
                                    "Crie cenários: Enter para submit, Escape para cancelar.",
                                    "Valide em ambos widgets e janelas."
                                  ],
                                  "verification": "Escreva e execute snippet que responde diferentemente a Enter e Escape.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "IDE Java, tabela de KeyEvent.VK_ codes.",
                                  "tips": "Sempre use constantes VK_ em vez de números mágicos para portabilidade.",
                                  "learningObjective": "Identificar e manusear teclas especiais de forma precisa.",
                                  "commonMistakes": "Usar getKeyChar() para teclas não-caractere, que retorna 0."
                                }
                              ],
                              "practicalExample": "Em um app de chat Java Swing, adicione KeyListener ao JTextField de mensagem: no keyPressed se VK_ENTER, envie mensagem e limpe campo; no keyPressed se VK_ESCAPE no JFrame, minimize a janela. Teste sequência: digite 'oi', Enter -> envia; Escape -> minimiza.",
                              "finalVerifications": [
                                "Liste e explique keyPressed, keyReleased e keyTyped com exemplos.",
                                "Identifique em código fornecido onde eventos de teclado são capturados em JTextField.",
                                "Diferencie captura em JFrame vs JTextField com prints de teste.",
                                "Escreva condicional correta para VK_ENTER e VK_ESCAPE.",
                                "Explique por que keyTyped não dispara para Escape.",
                                "Demonstre não-propagação de eventos consumidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção entre os três tipos de eventos de teclado (90%+ correto).",
                                "Correta identificação de listeners em código GUI (sem erros de escopo).",
                                "Implementação funcional de handlers para teclas especiais.",
                                "Compreensão de foco e propagação demonstrada em testes.",
                                "Uso apropriado de getKeyCode() vs getKeyChar().",
                                "Explicações claras de verificações e erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "UX Design: Atalhos de teclado melhoram acessibilidade (WCAG 2.1).",
                                "Matemática: Mapeamento de códigos de teclas como funções discretas.",
                                "Segurança da Informação: Detecção de Escape para cancelar ações sensíveis.",
                                "Desenvolvimento de Jogos: Controles de teclado em engines como LibGDX."
                              ],
                              "realWorldApplication": "Em editores de texto como VS Code ou navegadores, Enter submete formulários e Escape cancela modais; em jogos, teclas especiais controlam menus sem mouse, otimizando interação em apps desktop empresariais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.6.1.3",
                            "name": "Representar eventos em diagramas UML",
                            "description": "Modelar eventos de GUI usando diagramas de sequência UML para ilustrar o fluxo de um clique ou tecla até o processamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar participantes e componentes do evento GUI",
                                  "subSteps": [
                                    "Analise o evento específico (ex: clique em botão ou pressionar tecla).",
                                    "Liste os atores envolvidos: usuário, componentes GUI (botão, janela), listeners e handlers.",
                                    "Identifique objetos backend: controller, service, model ou database.",
                                    "Desenhe lifelines verticais para cada participante.",
                                    "Marque o ponto de partida do evento (ex: seta de ativação do usuário)."
                                  ],
                                  "verification": "Verifique se todos os componentes essenciais estão listados e lifelines desenhados corretamente sem sobreposições.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis ou software UML como PlantUML, Lucidchart ou Draw.io",
                                  "tips": "Comece pelo ator principal (usuário) e siga o fluxo lógico de disparo do evento.",
                                  "learningObjective": "Compreender e mapear os atores e objetos envolvidos no fluxo de um evento GUI.",
                                  "commonMistakes": "Esquecer componentes intermediários como event dispatchers ou confundir atores com objetos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear a sequência de mensagens e interações",
                                  "subSteps": [
                                    "Defina a mensagem inicial: ex: 'click()' do usuário para o botão.",
                                    "Trace o fluxo: botão chama listener, listener invoca handler, handler processa lógica.",
                                    "Identifique retornos síncronos/assíncronos e ativações (retângulos finos nas lifelines).",
                                    "Adicione condições ou loops se o evento envolver repetições (ex: alt/loop frames).",
                                    "Anote parâmetros e tipos de mensagens (ex: MouseEvent, KeyEvent)."
                                  ],
                                  "verification": "Confirme que cada seta de mensagem tem direção correta, label descritiva e corresponde ao fluxo real.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software UML ou quadro branco para esboços iniciais",
                                  "tips": "Use setas abertas para chamadas de método e cheias para retornos; numerar mensagens para clareza.",
                                  "learningObjective": "Modelar precisamente as interações temporais entre componentes em um diagrama de sequência.",
                                  "commonMistakes": "Ignorar retornos de métodos ou representar chamadas assíncronas como síncronas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e formatar o diagrama UML completo",
                                  "subSteps": [
                                    "Posicione lifelines da esquerda para direita: ator -> GUI -> lógica -> dados.",
                                    "Desenhe todas as mensagens com notação UML padrão (setas, frames de ativação).",
                                    "Adicione frames combinados se necessário (ex: opt para condições, par para paralelas).",
                                    "Inclua notas para esclarecimentos (ex: 'Validação de input').",
                                    "Ajuste layout para legibilidade: evite cruzamentos de setas."
                                  ],
                                  "verification": "O diagrama deve ser legível, com todas mensagens rotuladas e sem erros de sintaxe UML.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramenta digital UML para exportação (ex: PlantUML online ou Visual Paradigm)",
                                  "tips": "Mantenha o diagrama focado: limite a 8-10 mensagens para simplicidade inicial.",
                                  "learningObjective": "Aplicar notação UML precisa para representar fluxos de eventos GUI.",
                                  "commonMistakes": "Usar notação errada (ex: setas de sincronização em vez de assíncronas) ou sobrecarregar com detalhes desnecessários."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar, refinar e documentar o diagrama",
                                  "subSteps": [
                                    "Simule o fluxo passo a passo: execute mentalmente ou em código real.",
                                    "Verifique cobertura completa: do input do usuário ao processamento final.",
                                    "Colete feedback: compare com documentação oficial ou código fonte.",
                                    "Adicione título, versão e legenda ao diagrama.",
                                    "Exporte em formato compartilhável (PNG/SVG) com código fonte se usar PlantUML."
                                  ],
                                  "verification": "Diagrama simula corretamente um teste real do evento sem discrepâncias.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Código fonte da aplicação GUI para referência cruzada",
                                  "tips": "Use ferramentas de validação UML online para checar sintaxe.",
                                  "learningObjective": "Garantir precisão e utilidade prática do diagrama através de validação.",
                                  "commonMistakes": "Pular validação, resultando em diagramas imprecisos que não refletem a implementação real."
                                }
                              ],
                              "practicalExample": "Modelagem do clique no botão 'Login' em uma aplicação Swing/Java: Actor (User) envia 'mouseClicked(MouseEvent)' para JButton -> ActionListener.onActionPerformed() -> LoginController.validateUser() -> UserService.checkCredentials() -> Database.query() -> retorno com sucesso/erro, exibindo JOptionPane.",
                              "finalVerifications": [
                                "Todos os lifelines estão presentes e corretamente nomeados (ex: :User, :Button, :Controller).",
                                "Sequência de mensagens cobre do evento inicial ao processamento final sem lacunas.",
                                "Notação UML é padrão: setas de mensagem, ativações, frames opcionais usados corretamente.",
                                "Diagrama é legível e pode ser seguido por outro desenvolvedor.",
                                "Validação contra código real confirma precisão do fluxo.",
                                "Documentação inclui título, contexto e exportação em formato utilizável."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de participantes e mensagens (80% cobertura).",
                                "Correta aplicação de notação UML de sequência (sem erros sintáticos).",
                                "Clareza e legibilidade do diagrama (fluxo intuitivo).",
                                "Inclusão de detalhes relevantes como condições/retornos sem sobrecarga.",
                                "Validação demonstrada com simulação ou referência a código.",
                                "Criatividade em conexões com cenários reais GUI."
                              ],
                              "crossCurricularConnections": [
                                "Design de Software: Integra com padrões MVC para GUIs.",
                                "Análise de Sistemas: Facilita modelagem de requisitos não-funcionais como performance.",
                                "Lógica e Matemática: Representa fluxos condicionais semelhantes a árvores de decisão.",
                                "Desenvolvimento Web/Mobile: Aplicável a frameworks como React ou Android com event handlers."
                              ],
                              "realWorldApplication": "Em equipes de desenvolvimento de software, esses diagramas são usados para debugar fluxos de eventos em aplicações desktop/web/mobile, planejar refatorações e onboardar novos desenvolvedores, reduzindo erros em GUIs complexas como dashboards ou e-commerces."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.6.2",
                        "name": "Listeners e Callbacks em OOO",
                        "description": "Mecanismos de registro de observadores (listeners) e funções de callback para desacoplar componentes GUI de seu tratamento de eventos, promovendo polimorfismo e herança.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.6.2.1",
                            "name": "Implementar interfaces de listener",
                            "description": "Criar classes que implementam interfaces como ActionListener ou KeyListener, utilizando encapsulamento para definir métodos de callback.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender conceitos de interfaces de listener e callbacks",
                                  "subSteps": [
                                    "Leia a documentação oficial da interface ActionListener no JavaDocs.",
                                    "Identifique o método actionPerformed(ActionEvent e) como ponto de callback.",
                                    "Compare com KeyListener e seus métodos keyPressed, keyReleased, keyTyped.",
                                    "Estude exemplos básicos de eventos em Swing.",
                                    "Anote diferenças entre listeners anônimos e classes implementadoras."
                                  ],
                                  "verification": "Crie um diagrama mental ou resumo escrito explicando como um listener responde a eventos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "JavaDocs Oracle (ActionListener, KeyListener)",
                                    "IDE com Swing (IntelliJ ou Eclipse)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Foquem em eventos como cliques e teclas; ignore eventos avançados por enquanto.",
                                  "learningObjective": "Compreender o papel das interfaces de listener no gerenciamento de eventos GUI.",
                                  "commonMistakes": [
                                    "Confundir interface com classe abstrata",
                                    "Ignorar o parâmetro ActionEvent",
                                    "Achar que listeners executam automaticamente sem registro"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar uma classe que implementa ActionListener",
                                  "subSteps": [
                                    "Crie uma nova classe Java chamada MeuActionListener.",
                                    "Declare que ela implements ActionListener.",
                                    "Implemente o método public void actionPerformed(ActionEvent e).",
                                    "Adicione código simples no método, como System.out.println('Botão clicado!').",
                                    "Use encapsulamento definindo variáveis privadas para estado da classe."
                                  ],
                                  "verification": "Compile a classe sem erros e execute um teste unitário chamando actionPerformed manualmente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE Java",
                                    "JDK 8 ou superior"
                                  ],
                                  "tips": "Use variáveis privadas com getters/setters para encapsulamento verdadeiro.",
                                  "learningObjective": "Desenvolver uma classe reutilizável que responde a eventos de ação.",
                                  "commonMistakes": [
                                    "Esquecer o import java.awt.event.*;",
                                    "Não tratar exceções no callback",
                                    "Tornar o método público sem override correto"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Registrar o listener em um componente GUI",
                                  "subSteps": [
                                    "Crie um JFrame simples com um JButton.",
                                    "Instancie sua classe MeuActionListener.",
                                    "Use botão.addActionListener(meuListener) para registrar.",
                                    "Execute a aplicação e clique no botão para testar.",
                                    "Adicione um JLabel para feedback visual no callback."
                                  ],
                                  "verification": "Clique no botão deve imprimir mensagem no console e atualizar o JLabel.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código base de JFrame/JButton",
                                    "IDE com visualizador Swing"
                                  ],
                                  "tips": "Sempre use SwingUtilities.invokeLater para threads seguras em GUI.",
                                  "learningObjective": "Integrar listeners a componentes visuais para responder a interações do usuário.",
                                  "commonMistakes": [
                                    "Esquecer de chamar addActionListener",
                                    "Não importar javax.swing.*",
                                    "Executar GUI em thread principal sem invokeLater"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Expandir para KeyListener e testar cenários múltiplos",
                                  "subSteps": [
                                    "Crie uma classe MeuKeyListener implements KeyListener.",
                                    "Implemente os três métodos requeridos.",
                                    "Adicione o listener a um JTextField com campo.addKeyListener(keyListener).",
                                    "Teste cliques e teclas simultaneamente em uma GUI composta.",
                                    "Refatore para encapsular lógica comum em métodos privados."
                                  ],
                                  "verification": "Digite no campo e pressione teclas deve disparar callbacks corretos; verifique console.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código anterior expandido",
                                    "JTextField no JFrame"
                                  ],
                                  "tips": "KeyListener requer foco no componente; use requestFocus().",
                                  "learningObjective": "Aplicar múltiplos listeners com encapsulamento em GUIs interativas.",
                                  "commonMistakes": [
                                    "Não implementar todos métodos de KeyListener",
                                    "Ignorar foco do componente",
                                    "Misturar ActionEvent com KeyEvent"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um aplicativo de calculadora simples, crie um botão 'Calcular' com ActionListener que lê valores de JTextFields, soma-os e exibe no JLabel. Adicione KeyListener no campo de entrada para calcular Enter pressionado, usando encapsulamento para armazenar operandos privados.",
                              "finalVerifications": [
                                "Classe compila e executa sem erros de interface não implementada.",
                                "Eventos disparam callbacks corretos (console ou UI feedback).",
                                "Encapsulamento: variáveis privadas acessíveis só via métodos.",
                                "Múltiplos listeners coexistem sem conflitos.",
                                "Aplicação fecha corretamente com frame.dispose().",
                                "Testes unitários para métodos callback passam."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação das interfaces (todos métodos override corretos).",
                                "Uso efetivo de encapsulamento (private fields com accessors).",
                                "Código limpo, legível e comentado.",
                                "Resposta correta a eventos sem vazamentos de memória.",
                                "Reutilização da classe listener em contextos diferentes.",
                                "Tratamento básico de exceções em callbacks."
                              ],
                              "crossCurricularConnections": [
                                "Design de Software: Padrões Observer para eventos desacoplados.",
                                "Matemática: Lógica booleana em condições de eventos.",
                                "Desenvolvimento Web: Semelhanças com event listeners em JavaScript DOM.",
                                "Engenharia de Software: Testes unitários para callbacks.",
                                "UX/UI: Princípios de responsividade em interfaces."
                              ],
                              "realWorldApplication": "Desenvolvimento de aplicativos desktop como editores de texto (Notepad++ usa listeners para teclas e menus) ou dashboards interativos em ferramentas empresariais (ex: IntelliJ plugins respondem a cliques e atalhos via listeners encapsulados)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.6.2.2",
                            "name": "Registrar callbacks em componentes",
                            "description": "Associar instâncias de listeners a botões, campos de texto ou janelas usando métodos como bind() em Python ou connect() em Qt.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos de Eventos e Callbacks em GUI",
                                  "subSteps": [
                                    "Estude o que são eventos em interfaces gráficas (ex: clique de mouse, tecla pressionada).",
                                    "Aprenda o papel de callbacks: funções chamadas automaticamente em resposta a eventos.",
                                    "Identifique diferenças entre listeners (objetos) e funções simples como callbacks.",
                                    "Revise documentação de tkinter (Python) para bind() ou PyQt para connect().",
                                    "Anote exemplos de eventos comuns: <Button-1> para clique esquerdo."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos e liste 3 eventos comuns com seus callbacks.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação oficial tkinter/PyQt, notebook para anotações.",
                                  "tips": "Use diagramas para visualizar fluxo: Evento → Callback → Ação.",
                                  "learningObjective": "Dominar terminologia e fluxo de eventos em GUIs OOO.",
                                  "commonMistakes": "Confundir callback com método de classe sem self; ignorar propagação de eventos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar Componentes GUI Básicos",
                                  "subSteps": [
                                    "Instale tkinter (padrão Python) ou PyQt5/6.",
                                    "Crie uma janela principal com Tk() ou QApplication.",
                                    "Adicione um botão ou campo de texto usando Button() ou Entry().",
                                    "Configure propriedades básicas: texto, posição com pack() ou grid().",
                                    "Execute o app vazio para verificar renderização."
                                  ],
                                  "verification": "App roda sem erros e exibe botão/campo visível.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de código (VS Code/PyCharm), Python 3+.",
                                  "tips": "Sempre chame mainloop() ou exec() para loop de eventos.",
                                  "learningObjective": "Construir widgets reutilizáveis em ambientes GUI OOO.",
                                  "commonMistakes": "Esquecer de importar tkinter; não chamar loop principal."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Funções Callback",
                                  "subSteps": [
                                    "Crie uma função simples def callback(event): print('Evento!').",
                                    "Para OOO, defina como método de classe: def on_click(self, event).",
                                    "Passe parâmetros event para acessar detalhes (x, y, widget).",
                                    "Teste a função isoladamente chamando manualmente.",
                                    "Adicione lógica real: atualizar label ou contador."
                                  ],
                                  "verification": "Função executa corretamente quando chamada manualmente, imprimindo detalhes do event.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Código do Step 2, console para testes.",
                                  "tips": "Use lambda para callbacks inline: button.bind('<Button-1>', lambda e: func(e)).",
                                  "learningObjective": "Desenvolver handlers de eventos parametrizados.",
                                  "commonMistakes": "Não capturar event; usar print sem flush em loops."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Registrar Callbacks nos Componentes",
                                  "subSteps": [
                                    "Use widget.bind('<Button-1>', callback) para botões.",
                                    "Para campos: entry.bind('<Return>', callback_enter).",
                                    "Em Qt: button.clicked.connect(self.on_click).",
                                    "Registre múltiplos: bind para <KeyPress>, <FocusIn>.",
                                    "Teste interativo: clique/tecle e verifique saída."
                                  ],
                                  "verification": "Evento dispara callback corretamente; logs mostram execução.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código completo dos steps anteriores.",
                                  "tips": "unbind() para remover; use after() para delays em callbacks.",
                                  "learningObjective": "Associar listeners dinamicamente a componentes GUI.",
                                  "commonMistakes": "String de evento errada (ex: 'Button-1' vs '<Button-1>'); callback retorna valor não usado."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Debugar e Otimizar Registros de Callbacks",
                                  "subSteps": [
                                    "Adicione try/except em callbacks para capturar erros.",
                                    "Use print(event) para inspecionar objetos event.",
                                    "Teste edge cases: múltiplos binds, eventos sobrepostos.",
                                    "Refatore para classe OOO com self como listener.",
                                    "Meça performance: evite callbacks pesados no main thread."
                                  ],
                                  "verification": "App lida com 10+ cliques sem crash; logs limpos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Debugger (pdb ou IDE breakpoints).",
                                  "tips": "Priorize weak references em listeners para evitar memory leaks.",
                                  "learningObjective": "Garantir robustez em gerenciamento de eventos.",
                                  "commonMistakes": "Binds duplicados causando múltiplas execuções; leaks de memória em classes."
                                }
                              ],
                              "practicalExample": "Crie um app tkinter com botão 'Clique Aqui'. Ao clicar, um label muda de 'Aguardando' para 'Clicado X vezes' (contador). Use bind('<Button-1>', on_click) onde on_click(event) acessa event.x para log posição.",
                              "finalVerifications": [
                                "Callback executa unicamente por evento sem duplicatas.",
                                "Event object fornece dados corretos (coordenadas, widget).",
                                "App responde a múltiplos tipos de eventos (clique, key).",
                                "Sem erros em console após 50 interações.",
                                "Código modular: callback em classe OOO.",
                                "Desempenho fluido, sem lags em loop de eventos."
                              ],
                              "assessmentCriteria": [
                                "Código usa bind/connect corretamente (100%).",
                                "Callbacks lidam com event params adequadamente (90%).",
                                "Estrutura OOO com instâncias de listeners (80%).",
                                "Tratamento de erros e debugs implementados (70%).",
                                "Exemplo prático funcional e comentado (60%).",
                                "Otimização para múltiplos eventos (50%)."
                              ],
                              "crossCurricularConnections": [
                                "Padrão Observer em Design Patterns (UML).",
                                "Event handling em JavaScript DOM (addEventListener).",
                                "Sinais e Slots em C++/Qt para sistemas embarcados.",
                                "Delegates em Swift/iOS para mobile GUI."
                              ],
                              "realWorldApplication": "Em editores de texto como VS Code (plugins respondem a cliques), jogos (callbacks para inputs de usuário), dashboards web/desktop (atualizações em tempo real via botões)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.6.2.3",
                            "name": "Aplicar padrões de projeto para eventos",
                            "description": "Utilizar o padrão Observer para gerenciar múltiplos listeners em um componente GUI, garantindo escalabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais do Padrão Observer",
                                  "subSteps": [
                                    "Estude a definição do Padrão Observer: um Subject mantém uma lista de Observers e os notifica de mudanças de estado.",
                                    "Identifique os papéis: Subject (mantém lista de observers e métodos attach/detach/notify), Observer (interface com update).",
                                    "Analise um diagrama UML do padrão, focando em associações e multiplicidades.",
                                    "Compare com listeners nativos em Swing/AWT para entender a abstração.",
                                    "Revise cenários de uso em GUI, como botões notificando múltiplos componentes."
                                  ],
                                  "verification": "Resuma em um parágrafo os componentes do padrão e desenhe um diagrama simples à mão ou em ferramenta UML.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação GoF (Gang of Four), diagramas UML online, editor de diagramas como draw.io",
                                  "tips": "Use analogias reais, como um jornal (subject) notificando assinantes (observers).",
                                  "learningObjective": "Entender a estrutura e intenção do Padrão Observer para decoupling em eventos GUI.",
                                  "commonMistakes": "Confundir com Publisher-Subscriber; ignorar detach para evitar memory leaks."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir as interfaces Subject e Observer",
                                  "subSteps": [
                                    "Crie a interface Observer com método update(Subject subject).",
                                    "Defina a interface Subject com addObserver(Observer o), removeObserver(Observer o), notifyObservers().",
                                    "Implemente uma lista interna de observers no Subject (use ArrayList<Observer>).",
                                    "Adicione métodos para getState() no Subject para passagem de dados.",
                                    "Compile e teste as interfaces vazias para garantir sintaxe correta."
                                  ],
                                  "verification": "Compile o código sem erros e crie um Observer mock que imprima 'notificado' no update.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "IDE Java (Eclipse ou IntelliJ), JDK 8+",
                                  "tips": "Mantenha interfaces minimalistas; evite dependências circulares.",
                                  "learningObjective": "Criar as abstrações contratuais para o padrão Observer.",
                                  "commonMistakes": "Esquecer de gerenciar null pointers na lista de observers; não usar weak references para evitar leaks."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Subject em um componente GUI",
                                  "subSteps": [
                                    "Crie uma classe ButtonSubject que implementa Subject e estende JButton.",
                                    "Sobreponha actionPerformed para chamar notifyObservers após clique.",
                                    "Implemente addObserver, removeObserver e notifyObservers iterando a lista.",
                                    "Adicione um estado interno (ex: contador de cliques) passado no update.",
                                    "Crie um JFrame simples para instanciar o ButtonSubject."
                                  ],
                                  "verification": "Execute o app; clique no botão e verifique se um observer mock é notificado via console.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "IDE Java com Swing/AWT, JDK",
                                  "tips": "Use SwingUtilities.invokeLater para threads seguras em GUI.",
                                  "learningObjective": "Integrar o padrão Observer a um componente GUI real para eventos de usuário.",
                                  "commonMistakes": "Notificar observers em thread errada causando freezes; não sincronizar lista em ambientes multi-thread."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar múltiplos Observers e testar escalabilidade",
                                  "subSteps": [
                                    "Crie LabelObserver que atualiza um JLabel com o estado do Subject.",
                                    "Crie LoggerObserver que grava eventos em arquivo ou console.",
                                    "Registre 3-5 observers no ButtonSubject e clique múltiplas vezes.",
                                    "Teste removeObserver removendo um e verificando que não é mais notificado.",
                                    "Meça performance adicionando 10+ observers e simulando cliques rápidos."
                                  ],
                                  "verification": "Todos observers reagem corretamente a cliques; remoção funciona; sem exceções em escala.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "IDE Java, JFrame para visualização",
                                  "tips": "Use JUnit para testes automatizados de notify com múltiplos observers.",
                                  "learningObjective": "Demonstrar escalabilidade gerenciando múltiplos listeners de forma desacoplada.",
                                  "commonMistakes": "Loops infinitos por observers se registrando mutuamente; ignorar exceções em um observer parando os demais."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Refatorar e otimizar para boas práticas",
                                  "subSteps": [
                                    "Adicione suporte a WeakReference na lista para evitar memory leaks.",
                                    "Implemente notifyObservers com try-catch para isolar falhas individuais.",
                                    "Adicione getters/setters para estado e documente com Javadoc.",
                                    "Crie um teste de carga com 50 observers e meça tempo de notificação.",
                                    "Compare código com implementação nativa Swing ActionListener."
                                  ],
                                  "verification": "Código passa em testes unitários; performance aceitável (<100ms para 50 observers); sem leaks detectados por profiler.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "JUnit para testes, VisualVM para profiling",
                                  "tips": "Sempre limpe observers em dispose() de componentes GUI.",
                                  "learningObjective": "Aplicar refinamentos para produção, garantindo robustez e escalabilidade.",
                                  "commonMistakes": "Não limpar observers desregistrados; sobrecarregar update com lógica pesada."
                                }
                              ],
                              "practicalExample": "Em um editor de texto GUI, um JTextArea (Subject) notifica: um LabelObserver atualiza contador de palavras, um LoggerObserver salva auto-save, e um StatusBarObserver atualiza barra de progresso. Clique em 'Salvar' notifica todos sem acoplamento direto.",
                              "finalVerifications": [
                                "Subject notifica todos observers registrados em mudanças de estado.",
                                "Observers podem ser adicionados/removidos dinamicamente sem quebrar o sistema.",
                                "Múltiplos (10+) observers respondem em <200ms por notificação.",
                                "Remoção de observer impede futuras notificações corretamente.",
                                "Não há memory leaks detectados após múltiplos ciclos attach/detach.",
                                "Código segue princípios SOLID, especialmente Dependency Inversion."
                              ],
                              "assessmentCriteria": [
                                "Implementação fiel das interfaces Subject/Observer com lista gerenciada.",
                                "Integração correta em componente GUI com notificação em eventos.",
                                "Escalabilidade demonstrada com múltiplos observers sem degradação.",
                                "Tratamento de erros e boas práticas (threads, leaks) aplicadas.",
                                "Código limpo, documentado e testável.",
                                "Uso efetivo de UML para modelagem inicial."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Modelagem de relações many-to-many como grafos direcionados.",
                                "Design de Software: Aplicação de SOLID e refatoração em POO.",
                                "Análise de Sistemas: Modelagem de eventos em diagramas de sequência UML.",
                                "Banco de Dados: Paralelo com triggers e subscribers em sistemas reativos."
                              ],
                              "realWorldApplication": "Frameworks como JavaFX ou React usam Observer para eventos UI escaláveis, como em dashboards financeiros onde múltiplas views (gráficos, tabelas, alertas) reagem a atualizações de dados em tempo real sem acoplamento rígido."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.6.3",
                        "name": "Tratamento Prático de Cliques e Teclas",
                        "description": "Implementação concreta de handlers para eventos de clique e teclado em aplicações GUI, com tratamento de exceções e uso de tipos genéricos.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.6.3.1",
                            "name": "Criar handler para eventos de clique",
                            "description": "Desenvolver e registrar um método que responde a cliques em botões ou áreas clicáveis, atualizando o estado da aplicação via encapsulamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Preparar o Componente para Eventos de Clique",
                                  "subSteps": [
                                    "Selecione um componente GUI clicável, como JButton ou JLabel com mouse listener.",
                                    "Verifique as importações necessárias: javax.swing.* e java.awt.event.*.",
                                    "Declare o componente como atributo da classe para encapsulamento.",
                                    "Inicialize o componente no construtor ou método init.",
                                    "Defina propriedades iniciais, como texto e layout."
                                  ],
                                  "verification": "Componente é visível na interface e pronto para registro de eventos, sem erros de compilação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "IDE com suporte a Java (Eclipse ou IntelliJ)",
                                    "Documentação oficial Java Swing sobre ActionListener"
                                  ],
                                  "tips": "Prefira JButton para cliques intencionais; use MouseListener para áreas personalizadas.",
                                  "learningObjective": "Compreender componentes que emitem eventos de clique e preparar o ambiente.",
                                  "commonMistakes": [
                                    "Esquecer importações de eventos",
                                    "Declarar componente local em vez de atributo",
                                    "Não inicializar no construtor"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar o Método Handler para o Evento",
                                  "subSteps": [
                                    "Implemente a interface ActionListener ou crie uma classe interna anônima.",
                                    "Defina o método actionPerformed(ActionEvent e) com lógica de resposta.",
                                    "Encapsule acesso a estado usando atributos da classe.",
                                    "Adicione tratamento de exceções básicas com try-catch.",
                                    "Atualize o estado da aplicação dentro do handler, como variáveis ou UI."
                                  ],
                                  "verification": "Método handler compilado sem erros e acessa estado encapsulado corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos de código Java Swing",
                                    "Referência API ActionListener"
                                  ],
                                  "tips": "Mantenha o handler curto e focado; delegue lógica complexa para métodos privados.",
                                  "learningObjective": "Desenvolver handlers que respondem de forma segura e encapsulada a eventos.",
                                  "commonMistakes": [
                                    "Usar variáveis locais não encapsuladas",
                                    "Ignorar o parâmetro ActionEvent",
                                    "Colocar lógica pesada no handler"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Registrar o Handler no Componente",
                                  "subSteps": [
                                    "Chame addActionListener(this) ou new ActionListener() no componente.",
                                    "Se usando classe interna, associe via addActionListener(handlerInstance).",
                                    "Posicione o registro após inicializar o componente.",
                                    "Compile e execute para verificar associação sem exceções.",
                                    "Confirme que o handler é o único listener registrado, se aplicável."
                                  ],
                                  "verification": "Registro confirmado por ausência de NullPointerException ao clicar.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código base da aplicação GUI",
                                    "Debugger da IDE para breakpoints"
                                  ],
                                  "tips": "Use 'this' se a classe principal implementar ActionListener para simplicidade.",
                                  "learningObjective": "Associar corretamente handlers a componentes para captura de eventos.",
                                  "commonMistakes": [
                                    "Registrar antes de inicializar componente",
                                    "Múltiplos registros sem remoção",
                                    "Confundir addActionListener com addMouseListener"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Depurar e Integrar com Estado da Aplicação",
                                  "subSteps": [
                                    "Execute a aplicação e clique no componente múltiplas vezes.",
                                    "Verifique atualizações de estado via prints ou UI feedback.",
                                    "Use debugger para inspecionar chamadas do handler.",
                                    "Adicione feedback visual, como mudança de cor ou label.",
                                    "Refatore para encapsulamento total e remova debugs."
                                  ],
                                  "verification": "Cliques acionam handler consistentemente, atualizando estado sem crashes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Aplicação GUI executável",
                                    "Ferramentas de debug da IDE"
                                  ],
                                  "tips": "Teste edge cases como cliques rápidos ou em sequência.",
                                  "learningObjective": "Validar e integrar handlers em fluxos de aplicação reais.",
                                  "commonMistakes": [
                                    "Não testar múltiplos cliques",
                                    "Deixar prints de debug no código final",
                                    "Ignorar threads em GUIs"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma calculadora simples em Java Swing, crie um JButton '+' que, ao ser clicado, adiciona 1 a um JLabel exibindo o total atual, atualizando o estado encapsulado na classe principal.",
                              "finalVerifications": [
                                "Handler é acionado unicamente por cliques no componente alvo.",
                                "Estado da aplicação é atualizado corretamente após cada clique.",
                                "Nenhum erro ou exceção é lançado no console.",
                                "Múltiplos cliques produzem resultados cumulativos esperados.",
                                "Handler respeita encapsulamento sem variáveis globais.",
                                "Interface permanece responsiva durante eventos."
                              ],
                              "assessmentCriteria": [
                                "Código utiliza ActionListener de forma padrão e idiomática.",
                                "Encapsulamento total: estado acessado via atributos privados.",
                                "Handler é conciso, com lógica delegada se complexa.",
                                "Tratamento básico de erros presente.",
                                "Testes manuais demonstram funcionamento correto.",
                                "Comentários explicam o fluxo de eventos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica booleana e sequências condicionais em eventos.",
                                "Design: Princípios de UX para feedback responsivo a interações.",
                                "Física: Modelagem de eventos como respostas a estímulos.",
                                "Linguagens: Parsing de eventos similar a processamento de inputs."
                              ],
                              "realWorldApplication": "Em aplicativos como editores de texto (botão 'Salvar' atualiza arquivo) ou jogos (botão 'Pular' move personagem), handlers de clique gerenciam interações usuário-sistema de forma reativa e encapsulada."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.6.3.2",
                            "name": "Implementar handler para eventos de tecla",
                            "description": "Configurar captura e processamento de teclas em campos de entrada, diferenciando teclas de caracteres e de função, com validação de entrada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e o componente de entrada",
                                  "subSteps": [
                                    "Criar uma classe principal que estenda JFrame para o container da GUI.",
                                    "Instanciar um JTextField ou JTextArea como campo de entrada.",
                                    "Adicionar o campo a um JPanel e configurar o layout (ex: BorderLayout).",
                                    "Configurar propriedades iniciais do campo, como foco e tamanho.",
                                    "Tornar a janela visível e configurada para ser redimensionável."
                                  ],
                                  "verification": "Verificar se o JFrame abre corretamente com o campo de entrada visível e focado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "JDK instalado",
                                    "IDE como IntelliJ ou Eclipse",
                                    "Documentação Swing: JTextField"
                                  ],
                                  "tips": "Use setFocusable(true) no campo para garantir captura de eventos.",
                                  "learningObjective": "Entender a configuração básica de componentes GUI para eventos de teclado.",
                                  "commonMistakes": [
                                    "Esquecer de chamar setVisible(true)",
                                    "Não adicionar o campo ao container",
                                    "Layout incorreto causando invisibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e registrar o KeyListener",
                                  "subSteps": [
                                    "Criar uma classe interna ou anônima que implemente a interface KeyListener.",
                                    "Sobrescrever os métodos keyPressed, keyReleased e keyTyped.",
                                    "Registrar o listener no campo de entrada usando addKeyListener().",
                                    "Adicionar prints ou logs iniciais nos métodos para depuração.",
                                    "Compilar e executar para confirmar registro sem erros."
                                  ],
                                  "verification": "Executar e pressionar teclas; verificar logs indicando que os métodos são chamados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Java: KeyListener",
                                    "Exemplos de KeyEvent"
                                  ],
                                  "tips": "Use KeyAdapter em vez de KeyListener para evitar implementar métodos desnecessários.",
                                  "learningObjective": "Dominar o registro de listeners para captura de eventos de teclado.",
                                  "commonMistakes": [
                                    "Esquecer de chamar addKeyListener()",
                                    "Não sobrescrever todos os métodos",
                                    "Listener em componente errado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar e processar tipos de teclas",
                                  "subSteps": [
                                    "No keyPressed: Capturar teclas de função (ex: VK_ENTER, VK_BACK_SPACE) usando getKeyCode().",
                                    "No keyTyped: Processar caracteres imprimíveis com getKeyChar().",
                                    "No keyReleased: Limpar estados ou ações pós-tecla (ex: validar após digitação).",
                                    "Implementar lógica para diferenciar: bloquear teclas não alfanuméricas exceto permitidas.",
                                    "Adicionar validação básica, como impedir letras em campo numérico."
                                  ],
                                  "verification": "Testar teclas: Enter deve disparar ação específica; letras em campo numérico devem ser ignoradas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de KeyEvent.VK_* constants",
                                    "API KeyEvent"
                                  ],
                                  "tips": "Use event.consume() para bloquear propagação de eventos indesejados.",
                                  "learningObjective": "Diferenciar eventos de teclas de caracteres vs. função e processá-los adequadamente.",
                                  "commonMistakes": [
                                    "Confundir keyTyped com keyPressed para caracteres",
                                    "Não usar getKeyCode() corretamente",
                                    "Ignorar event.consume()"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar validação de entrada e testar completamente",
                                  "subSteps": [
                                    "Implementar método de validação no texto do campo (ex: só números via regex).",
                                    "Reagir a teclas específicas: Enter para submeter, Escape para limpar.",
                                    "Adicionar feedback visual (ex: borda vermelha em erro).",
                                    "Executar testes unitários para cenários: teclas válidas/inválidas, combinações.",
                                    "Refatorar código para handler reutilizável."
                                  ],
                                  "verification": "Campo aceita só entrada válida; teclas de função executam ações corretas sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Regex para validação",
                                    "JUnit para testes"
                                  ],
                                  "tips": "Centralize lógica em métodos privados para reutilização em múltiplos campos.",
                                  "learningObjective": "Integrar validação e processamento para entradas seguras e responsivas.",
                                  "commonMistakes": [
                                    "Validação só no final, não em tempo real",
                                    "Não tratar teclas modificadoras (Shift, Ctrl)",
                                    "Falta de feedback ao usuário"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um JTextField que aceite apenas números (0-9), ignore letras e Delete/Backspace funcionem. Pressionar Enter valida e exibe 'Válido: [número]' em um JLabel; Escape limpa o campo.",
                              "finalVerifications": [
                                "keyPressed distingue VK_ENTER e VK_ESCAPE corretamente.",
                                "keyTyped filtra apenas caracteres numéricos.",
                                "Validação impede entrada inválida em tempo real.",
                                "Feedback visual aparece em erros de entrada.",
                                "Handler funciona sem quebrar foco ou navegação.",
                                "Código é limpo e comentado."
                              ],
                              "assessmentCriteria": [
                                "Correta implementação dos 3 métodos do KeyListener (100%).",
                                "Diferenciação precisa entre teclas de caractere e função (90%).",
                                "Validação robusta com regex ou lógica condicional (85%).",
                                "Uso de event.consume() para bloquear eventos indesejados (80%).",
                                "Testes demonstrados para 5+ cenários (75%).",
                                "Código modular e reutilizável (70%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Uso de expressões regulares para padrões numéricos.",
                                "Design de UX: Feedback visual e acessibilidade para navegação por teclado.",
                                "Segurança da Informação: Validação de entrada contra injeções maliciosas.",
                                "Lógica Computacional: Estruturas condicionais e eventos assíncronos."
                              ],
                              "realWorldApplication": "Em formulários web/bancários para validar CPFs/cartões sem letras; editores de código que respondem a atalhos (Ctrl+S); jogos que capturam movimentos via setas sem texto."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.6.3.3",
                            "name": "Gerenciar conflitos e exceções em eventos",
                            "description": "Tratar exceções em callbacks de eventos e resolver conflitos entre múltiplos handlers usando prioridades ou herança polimórfica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Capturar Exceções em Callbacks de Eventos",
                                  "subSteps": [
                                    "Analise o código do callback de evento (ex: actionPerformed em Java Swing) para pontos potenciais de falha como NullPointerException ou IndexOutOfBoundsException.",
                                    "Adicione blocos try-catch ao redor do código principal do callback.",
                                    "Registre a exceção usando logging (ex: Logger.getLogger().severe()) sem interromper o fluxo do evento.",
                                    "Defina uma política de fallback, como exibir uma mensagem de erro no UI ou restaurar estado padrão.",
                                    "Teste injetando exceções manualmente para validar captura."
                                  ],
                                  "verification": "Execute o evento e force uma exceção; verifique se o app não trava e log é gerado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "IDE com suporte a debugging (Eclipse/IntelliJ)",
                                    "Exemplo de GUI simples com botão",
                                    "Biblioteca de logging (SLF4J/Log4j)"
                                  ],
                                  "tips": "Use catch específico antes de catch genérico (Exception) para granularidade.",
                                  "learningObjective": "Compreender como exceções propagam em threads de eventos GUI e isolá-las.",
                                  "commonMistakes": [
                                    "Ignorar exceções silenciosamente sem logging",
                                    "Usar System.exit() em catch, causando crash do app"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Sistema de Prioridades para Múltiplos Handlers",
                                  "subSteps": [
                                    "Crie uma interface ou classe base para EventHandler com campo priority (int).",
                                    "Modifique o dispatcher de eventos para ordenar handlers por prioridade antes de invocar.",
                                    "Registre múltiplos handlers no componente GUI usando addActionListener ou similar, associando prioridades.",
                                    "No dispatcher, itere handlers em ordem decrescente de prioridade e pare se um handler retornar false (consumir evento).",
                                    "Teste com handlers de baixa e alta prioridade competindo por um clique."
                                  ],
                                  "verification": "Registre 3 handlers com prioridades 1, 2, 5; confirme execução na ordem 5->2->1 via logs.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código base de GUI com EventDispatcher customizado",
                                    "Documentação Java AWT/Swing EventQueue"
                                  ],
                                  "tips": "Prioridade negativa para handlers de 'bloqueio' que cancelam propagação.",
                                  "learningObjective": "Resolver conflitos ordenando handlers para evitar sobreposições indesejadas.",
                                  "commonMistakes": [
                                    "Executar todos handlers independentemente de prioridade",
                                    "Esquecer de consumir evento após handler prioritário"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Herança Polimórfica para Handlers Especializados",
                                  "subSteps": [
                                    "Defina uma hierarquia de classes: AbstractEventHandler -> ClickHandler -> DoubleClickHandler (sobrescreve método handle).",
                                    "Use polimorfismo no dispatcher: aceite List<EventHandler> e chame handle() polimórfico.",
                                    "Implemente sobrescrita para resolver conflitos, ex: DoubleClickHandler ignora single clicks.",
                                    "Integre com prioridades: subclasse herda ou sobrescreve priority.",
                                    "Refatore handlers existentes para herdar da base polimórfica."
                                  ],
                                  "verification": "Crie instâncias polimórficas; verifique se double-click ignora single-click via polimorfismo.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "UML diagram para hierarquia de classes",
                                    "Exemplo de código com ActionListener polimórfico"
                                  ],
                                  "tips": "Use @Override e anotações para clareza em sobrescritas.",
                                  "learningObjective": "Usar OOP para handlers flexíveis que resolvem conflitos via comportamento polimórfico.",
                                  "commonMistakes": [
                                    "Não chamar super.handle() quando necessário",
                                    "Violar Liskov Substitution Principle com comportamentos inesperados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Integrar Gerenciamento Completo de Eventos",
                                  "subSteps": [
                                    "Crie cenários de teste: exceção + conflito de prioridade + handler polimórfico.",
                                    "Use unit tests (JUnit) para mockar eventos e verificar ordem/invocação.",
                                    "Simule load com múltiplos eventos rápidos (teclas/cliques) para exceções em thread.",
                                    "Monitore performance: garanta que tratamento não degrade FPS do GUI.",
                                    "Documente o sistema em comentários ou README."
                                  ],
                                  "verification": "Rodar suite de testes; 100% cobertura de exceções e conflitos resolvidos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "JUnit/Mockito para testes",
                                    "Ferramenta de profiling (VisualVM)"
                                  ],
                                  "tips": "Teste edge cases como eventos vazios ou handlers nulos.",
                                  "learningObjective": "Validar sistema integrado para robustez em produção.",
                                  "commonMistakes": [
                                    "Testar só casos felizes",
                                    "Ignorar threading em eventos assíncronos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app Swing de editor de texto: Botão 'Salvar' tem 3 handlers - prioridade 10: valida campos (consome se inválido), pri 5: salva arquivo (lança IOException se disco cheio), pri 1: log de auditoria. Se IOException ocorre, catch loga e mostra dialog 'Tente novamente'; double-click no botão usa handler polimórfico que ignora single-click.",
                              "finalVerifications": [
                                "App GUI não trava com exceções em qualquer handler.",
                                "Handlers executam na ordem correta de prioridade.",
                                "Handlers polimórficos resolvem conflitos (ex: double-click prevalece).",
                                "Logs capturam todas exceções com stack trace.",
                                "Eventos são consumidos corretamente sem propagação indesejada.",
                                "Performance mantida sob load de 100 eventos/segundo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na captura e logging de exceções (sem vazamentos).",
                                "Correta ordenação e consumo por prioridade.",
                                "Uso efetivo de polimorfismo sem violações OOP.",
                                "Cobertura de testes >90% para cenários de conflito/exceção.",
                                "Código limpo, legível com comentários explicativos.",
                                "Tratamento thread-safe para eventos GUI."
                              ],
                              "crossCurricularConnections": [
                                "Debugging e Logging: Integra com práticas de monitoramento (ex: ELK Stack).",
                                "Design Patterns: Relaciona com Chain of Responsibility para handlers.",
                                "Arquitetura de Software: Princípios SOLID em gerenciamento de eventos.",
                                "Testes de Software: Unit/integration testing para robustez.",
                                "Segurança: Prevenção de DoS via exceções não tratadas."
                              ],
                              "realWorldApplication": "Em editores como VS Code ou IntelliJ, cliques em botões 'Run' têm handlers prioritários (validação > execução > log); exceções (ex: compilação falha) são capturadas para UI responsivo, evitando crashes em plugins conflitantes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "totalSkills": 382
          }
        ],
        "totalSkills": 382
      }
    ]
  }
}