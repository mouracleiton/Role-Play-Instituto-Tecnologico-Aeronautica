{
  "formatVersion": "1.0",
  "exportDate": "2025-12-04T01:04:55.216Z",
  "appVersion": "1.0",
  "curriculumData": {
    "metadata": {
      "baseOn": "Catálogo dos Cursos de Graduação 2025 - AT-55",
      "lastUpdated": "2025-12-04",
      "totalAtomicSkills": 291
    },
    "areas": [
      {
        "id": "10",
        "name": "Matemática",
        "description": "Área de Matemática do currículo do ITA, abrangendo disciplinas avançadas em álgebra e computação numérica.",
        "disciplines": [
          {
            "id": "10.1",
            "name": "AT-55 - Álgebra Linear Computacional",
            "description": "Decomposição em valores singulares. Sensibilidade de sistemas de equações lineares. Ortogonalização e decomposição QR. Quadrados mínimos lineares. Análise de sensibilidade. Análise de métodos iterativos clássicos para sistemas lineares. Bibliografia: GOLUB, G. H.; VAN LOAN, C. F. Matrix computations. 3. ed. Baltimore: Johns Hopkins University Press, 1996. MEYER, C. D. Matrix analysis and applied linear algebra. Philadelphia: SIAM, 2000. WATKINS, D. S. Fundamentals of matrix computations. 3. ed. New York: Wiley, 2010.",
            "mainTopics": [
              {
                "id": "10.1.1",
                "name": "Decomposição em Valores Singulares",
                "description": "Estudo da decomposição SVD de matrizes, suas propriedades e aplicações em análise numérica.",
                "totalSkills": 52,
                "atomicTopics": [
                  {
                    "id": "10.1.1.1",
                    "name": "Definição da Decomposição SVD",
                    "description": "Apresentação formal da decomposição de uma matriz retangular em produto de matrizes unitárias e diagonal com valores singulares não negativos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.1.1",
                        "name": "Valores Singulares",
                        "description": "Os valores singulares de uma matriz retangular A ∈ ℝ^{m×n} são definidos como as raízes quadradas não negativas dos autovalores das matrizes simétricas e semidefinidas positivas AᵀA ∈ ℝ^{n×n} e AAᵀ ∈ ℝ^{m×m}, ordenados de forma decrescente.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.1.1",
                            "name": "Definir valores singulares via autovalores de AᵀA",
                            "description": "Explicar que os valores singulares σ₁ ≥ σ₂ ≥ … ≥ σ_r > 0 são dados por σ_i = √λ_i, onde λ_i são os autovalores positivos de AᵀA ordenados decrescentemente, e r é o posto de A.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as propriedades da matriz AᵀA",
                                  "subSteps": [
                                    "Lembre-se que A é uma matriz m x n real.",
                                    "Calcule AᵀA, que resulta em uma matriz n x n simétrica e semi-definida positiva.",
                                    "Verifique que os autovalores de AᵀA são não-negativos (λ_i ≥ 0).",
                                    "Identifique que AᵀA tem posto igual ao posto de A.",
                                    "Entenda que autovetores de AᵀA são ortogonais devido à simetria."
                                  ],
                                  "verification": "Confirme calculando AᵀA para uma matriz exemplo e verificando simetria (AᵀA = (AᵀA)ᵀ) e não-negatividade de autovalores.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, calculadora matricial ou Python (NumPy para np.dot(A.T, A))",
                                  "tips": "Sempre verifique a simetria transpondo AᵀA para confirmar AᵀA = (AᵀA)ᵀ.",
                                  "learningObjective": "Entender por que AᵀA é simétrica e semi-definida positiva, base para valores singulares.",
                                  "commonMistakes": "Confundir AᵀA com AAᵀ (dimensões diferentes); esquecer que autovalores são ≥0."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os autovalores de AᵀA",
                                  "subSteps": [
                                    "Ordene os autovalores positivos de AᵀA em ordem decrescente: λ₁ ≥ λ₂ ≥ … ≥ λ_r > 0.",
                                    "Ignore autovalores zero, pois r é o número de autovalores positivos (posto de A).",
                                    "Use o polinômio característico det(AᵀA - λI) = 0 para matrizes pequenas.",
                                    "Para matrizes maiores, utilize métodos numéricos como decomposição QR.",
                                    "Anote os autovalores ordenados."
                                  ],
                                  "verification": "Resolva o polinômio característico e liste λ_i ordenados, confirmando λ_i ≥ 0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora simbólica (SymPy em Python) ou software como MATLAB (eig(A'*A))",
                                  "tips": "Para matrizes 2x2, use fórmula quadrática para agilizar o cálculo.",
                                  "learningObjective": "Dominar o cálculo e ordenação de autovalores positivos de AᵀA.",
                                  "commonMistakes": "Não ordenar decrescentemente; incluir autovalores zero como positivos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir os valores singulares a partir dos autovalores",
                                  "subSteps": [
                                    "Defina σ_i = √λ_i para i = 1 a r, onde λ_i são autovalores positivos ordenados.",
                                    "Ordene os σ_i decrescentemente: σ₁ ≥ σ₂ ≥ … ≥ σ_r > 0.",
                                    "Verifique que σ_i são reais e positivos.",
                                    "Registre que valores singulares capturam a 'energia' da matriz via normas.",
                                    "Compare com definição via norma de colunas para validação."
                                  ],
                                  "verification": "Calcule √λ_i e confirme ordenação e positividade dos σ_i.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora para raízes quadradas, planilha ou Python (np.sqrt(eigenvals))",
                                  "tips": "Use aproximações numéricas para raízes se λ_i forem grandes.",
                                  "learningObjective": "Aplicar a fórmula σ_i = √λ_i corretamente para definir valores singulares.",
                                  "commonMistakes": "Esquecer a raiz quadrada; inverter ordem de σ_i."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar o posto e relação com SVD",
                                  "subSteps": [
                                    "Identifique r como o número de σ_i > 0, igual ao posto de A.",
                                    "Relacione com SVD completa: A = U Σ Vᵀ, onde Σ tem σ_i na diagonal.",
                                    "Verifique que posto(A) = r.",
                                    "Discuta implicações: se r < min(m,n), A é rank-deficient.",
                                    "Teste com exemplo numérico completo."
                                  ],
                                  "verification": "Conte σ_i > 0 e confirme igual ao posto de A via eliminação gaussiana.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software para SVD (np.linalg.svd em Python) para comparação",
                                  "tips": "Compare σ_i computados com função SVD built-in para validação.",
                                  "learningObjective": "Conectar valores singulares ao posto e estrutura SVD.",
                                  "commonMistakes": "Confundir posto de A com posto de AᵀA (são iguais); ignorar σ_i = 0."
                                }
                              ],
                              "practicalExample": "Considere A = [[3, 0], [0, 4]]. Então AᵀA = [[9, 0], [0, 16]]. Autovalores λ₁=16, λ₂=9. Valores singulares σ₁=4, σ₂=3. Posto r=2, pois ambos >0. SVD: U=I, Σ=diag(4,3), V=I.",
                              "finalVerifications": [
                                "Explique verbalmente a relação σ_i = √λ_i de AᵀA.",
                                "Calcule valores singulares para uma matriz 2x2 dada.",
                                "Identifique o posto via contagem de σ_i >0.",
                                "Diferencie autovalores de AᵀA de valores singulares.",
                                "Aplique a definição em um exemplo rank-deficient (ex: A com coluna zero)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula σ_i = √λ_i com ordenação correta.",
                                "Correta identificação de autovalores positivos e posto r.",
                                "Uso apropriado de propriedades simétricas de AᵀA.",
                                "Capacidade de validar com exemplos numéricos.",
                                "Explicação clara da relação com SVD completa.",
                                "Evitar erros comuns como inclusão de λ=0."
                              ],
                              "crossCurricularConnections": [
                                "Física: Valores singulares em análise modal de vibrações (autovalores de matrizes de rigidez).",
                                "Ciência da Computação: Pré-processamento em PCA e redução dimensional via SVD.",
                                "Estatística: Análise de componentes principais (PCA) usa autovalores de covariância similar a AᵀA.",
                                "Engenharia: Compressão de sinais em processamento de imagens."
                              ],
                              "realWorldApplication": "Em machine learning, valores singulares de AᵀA são usados na SVD para redução de dimensionalidade em grandes datasets, como recomendação de produtos na Netflix ou compressão de imagens JPEG."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.2",
                            "name": "Relacionar valores singulares com AAᵀ",
                            "description": "Demonstrar que os autovalores não nulos de AAᵀ coincidem com os de AᵀA, e os valores singulares são as raízes quadradas desses autovalores compartilhados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições de autovalores e propriedades de AAᵀ e AᵀA",
                                  "subSteps": [
                                    "Defina autovalor λ e autovetor v para uma matriz M onde Mv = λv.",
                                    "Note que AAᵀ e AᵀA são matrizes simétricas semi-definidas positivas (PSD).",
                                    "Liste propriedades: autovalores reais e não negativos.",
                                    "Escreva explicitamente AAᵀ (m x m) e AᵀA (n x n) para A m x n.",
                                    "Identifique dimensões e ranks relacionados."
                                  ],
                                  "verification": "Confirme que você pode escrever as equações características para ambas as matrizes e listar pelo menos 3 propriedades PSD.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Matriz A exemplo 2x2 ou 3x2"
                                  ],
                                  "tips": "Comece com matrizes pequenas para visualizar; use notação clara para evitar confusão entre AAᵀ e AᵀA.",
                                  "learningObjective": "Compreender as propriedades fundamentais de AAᵀ e AᵀA como base para autovalores compartilhados.",
                                  "commonMistakes": [
                                    "Confundir dimensões de AAᵀ (quadrada m x m) com AᵀA (n x n)",
                                    "Esquecer que são PSD e autovalores ≥0",
                                    "Ignorar autovalores zero"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provar que autovalores não nulos de AAᵀ e AᵀA coincidem",
                                  "subSteps": [
                                    "Suponha AᵀA v = λ v com λ > 0 e v ≠ 0.",
                                    "Mostre que AAᵀ (A v) = λ (A v), definindo u = A v ≠ 0.",
                                    "Conclua que λ é autovalor de AAᵀ com autovetor u.",
                                    "Repita no sentido inverso: de AAᵀ w = λ w implica AᵀA (Aᵀ w) = λ (Aᵀ w).",
                                    "Discuta multiplicidades e autovalores zero (devido a dimensões diferentes)."
                                  ],
                                  "verification": "Escreva a prova bidirecional em suas palavras e verifique com um exemplo numérico simples.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Papel e calculadora",
                                    "Software como Python/NumPy para verificação opcional"
                                  ],
                                  "tips": "Use setas para mapear autovetores: v → A v → u; prove não nulidade de u se λ > 0.",
                                  "learningObjective": "Demonstrar matematicamente a igualdade dos autovalores não nulos.",
                                  "commonMistakes": [
                                    "Assumir todos autovalores iguais, ignorando zeros",
                                    "Não provar direção inversa",
                                    "Erros algébricos em Aᵀ (A v) = λ Aᵀ v"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir valores singulares como raízes quadradas dos autovalores compartilhados",
                                  "subSteps": [
                                    "Defina σ_i = √λ_i para cada autovalor não nulo λ_i compartilhado.",
                                    "Explique que σ_i são os valores singulares de A, ordenados decrescentemente.",
                                    "Relacione com decomposição SVD: A = U Σ Vᵀ onde Σ tem diagonais σ_i.",
                                    "Note que há min(m,n) valores singulares potenciais, com zeros se rank < min(m,n).",
                                    "Verifique que σ_i² = λ_i para consistência."
                                  ],
                                  "verification": "Escreva a definição formal e compute σ para um conjunto de λ exemplo.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de λ para AAᵀ e AᵀA"
                                  ],
                                  "tips": "Sempre tome raiz quadrada positiva (σ ≥ 0); ordene σ_1 ≥ σ_2 ≥ ...",
                                  "learningObjective": "Estabelecer a conexão direta entre valores singulares e autovalores de AAᵀ/AᵀA.",
                                  "commonMistakes": [
                                    "Tomar raiz negativa",
                                    "Confundir σ com λ diretamente",
                                    "Ignorar ordenação decrescente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a relação com exemplo computacional",
                                  "subSteps": [
                                    "Escolha A = [[1,0],[0,2],[0,0]] (3x2).",
                                    "Compute AᵀA (2x2) e encontre autovalores λ1=5, λ2=1.",
                                    "Compute AAᵀ (3x3) e confirme autovalores 5,1,0.",
                                    "Extraia σ1=√5, σ2=1.",
                                    "Use software para SVD e confirme σ."
                                  ],
                                  "verification": "Mostre cálculos coincidem e SVD numérico matches σ.",
                                  "estimatedTime": "25-40 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Papel para cálculos manuais"
                                  ],
                                  "tips": "Use np.linalg.svd() para verificação; compare exatamente.",
                                  "learningObjective": "Aplicar a teoria em prática para solidificar compreensão.",
                                  "commonMistakes": [
                                    "Erros aritméticos em multiplicação de matrizes",
                                    "Não checar autovalor zero extra",
                                    "Desalinhar índices de σ"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[3, 0], [0, 4]] (2x2), AᵀA = [[9,0],[0,16]] com λ=9,16; AAᵀ=mesmo. σ1=4, σ2=3. SVD: A = [[1,0],[0,1]] diag(4,3) [[1,0],[0,1]]. Confirma σ=√λ.",
                              "finalVerifications": [
                                "Pode provar bidirecionalmente que autovalores não nulos coincidem?",
                                "Define corretamente σ_i = √λ_i para λ>0?",
                                "Identifica autovalores zero corretamente em exemplos?",
                                "Computa σ para matriz exemplo manualmente?",
                                "Explica papel na SVD?",
                                "Discute rank via número de σ>0?"
                              ],
                              "assessmentCriteria": [
                                "Precisão da prova de autovalores compartilhados (bidirecional).",
                                "Correta definição e cálculo de valores singulares como √λ.",
                                "Tratamento adequado de autovalores zero e dimensões.",
                                "Exemplo numérico verificado com SVD.",
                                "Clareza na explicação oral/escrita da relação.",
                                "Identificação de propriedades PSD."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modos normais em vibrações (autovalores de matrizes inércia).",
                                "Computação: Algoritmos SVD para PCA em ML.",
                                "Estatística: Análise de componentes principais via AAᵀ.",
                                "Engenharia: Compressão de sinais via truncagem SVD."
                              ],
                              "realWorldApplication": "Em processamento de imagens, SVD usa valores singulares (raízes de autovalores de AAᵀ) para compressão: manter top-k σ_i reduz dados mantendo qualidade, como no JPEG2000."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.3",
                            "name": "Propriedades básicas dos valores singulares",
                            "description": "Listar propriedades como não negatividade (σ_i ≥ 0), ordenação decrescente, número de valores singulares positivos igual ao posto de A, e relação com normas de matriz (||A||₂ = σ₁).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a não negatividade dos valores singulares",
                                  "subSteps": [
                                    "Defina valores singulares como as raízes quadradas dos autovalores da matriz A^T A.",
                                    "Explique que autovalores de A^T A são não negativos, logo σ_i = sqrt(λ_i) ≥ 0.",
                                    "Discuta implicações geométricas: alongamentos não negativos nos eixos singulares.",
                                    "Pratique com uma matriz 2x2 simples para visualizar."
                                  ],
                                  "verification": "Calcule σ_i para uma matriz dada e confirme todos ≥ 0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Matriz de exemplo 2x2",
                                    "Calculadora ou Python (numpy.linalg.svd)"
                                  ],
                                  "tips": "Lembre-se: σ_i sempre reais e não negativos, diferentemente de autovalores gerais.",
                                  "learningObjective": "Identificar e justificar por que todos os valores singulares σ_i são maiores ou iguais a zero.",
                                  "commonMistakes": [
                                    "Assumir que σ_i podem ser negativos como autovalores",
                                    "Confundir com decomposição espectral"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a ordenação decrescente dos valores singulares",
                                  "subSteps": [
                                    "Estude os autovalores de A^T A ordenados λ1 ≥ λ2 ≥ ... ≥ λn ≥ 0.",
                                    "Defina σ1 ≥ σ2 ≥ ... ≥ σr > 0 ≥ σ_{r+1} = ... = 0, onde r é o rank.",
                                    "Verifique em exemplos como matrizes diagonais ou rank-deficient.",
                                    "Analise o impacto na aproximação de baixo rank.",
                                    "Compare com ordenação em autovalores."
                                  ],
                                  "verification": "Liste σ_i em ordem decrescente para uma SVD computada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software SVD (MATLAB ou Octave)",
                                    "Matrizes de teste rank 1 e full rank"
                                  ],
                                  "tips": "A convenção padrão é σ1 máximo, facilitando truncamento para aproximação.",
                                  "learningObjective": "Explicar e demonstrar a ordenação σ1 ≥ σ2 ≥ ... ≥ σ_min(m,n).",
                                  "commonMistakes": [
                                    "Ordenar de forma crescente",
                                    "Ignorar zeros no final"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar valores singulares com o posto da matriz",
                                  "subSteps": [
                                    "Defina rank(A) = número de σ_i > 0.",
                                    "Prove que σ_i > 0 para i=1 a r, e σ_i=0 para i>r.",
                                    "Identifique singularidades: se rank(A)<min(m,n), há σ_i=0.",
                                    "Aplique em matrizes nulas ou lineares dependentes."
                                  ],
                                  "verification": "Para uma matriz dada, compute rank e conte σ_i > 0.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Matrizes rank-deficient",
                                    "Ferramenta de rank (numpy.linalg.matrix_rank)"
                                  ],
                                  "tips": "Rank é invariante sob SVD: conta direções não nulas de alongamento.",
                                  "learningObjective": "Conectar o número de valores singulares positivos ao rank da matriz.",
                                  "commonMistakes": [
                                    "Contar todos σ_i incluindo zeros",
                                    "Confundir com dimensão do kernel"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Conectar valores singulares com normas de matriz",
                                  "subSteps": [
                                    "Defina norma 2: ||A||_2 = sup ||Ax||_2 / ||x||_2 = σ1.",
                                    "Prove geometricamente: máximo alongamento unitário.",
                                    "Compare com outras normas (Frobenius: sqrt(∑σ_i^2)).",
                                    "Verifique numericamente em exemplos.",
                                    "Discuta implicações para estabilidade e condicionamento (κ=σ1/σ_min)."
                                  ],
                                  "verification": "Compute ||A||_2 e confirme igual a σ1 máxima.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código Python para normas e SVD",
                                    "Matrizes conhecidas como identidade e Hilbert"
                                  ],
                                  "tips": "σ1 é o 'ganho' máximo da transformação linear A.",
                                  "learningObjective": "Demonstrar que a norma espectral ||A||_2 = σ1.",
                                  "commonMistakes": [
                                    "Confundir ||A||_2 com ||A||_F",
                                    "Esquecer normalização unitária"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[3, 0], [0, 2]], SVD dá U=Id, Σ=diag(3,2), V=Id. Verifique: σ1=3≥σ2=2≥0, ambos ≥0, 2 σ_i>0 = rank(A)=2, ||A||_2=3=σ1. Liste propriedades e confirme.",
                              "finalVerifications": [
                                "Liste corretamente as 4 propriedades básicas.",
                                "Para matriz dada, identifique σ_i ≥0 e ordenados.",
                                "Conte σ_i>0 e relacione ao rank.",
                                "Calcule ||A||_2 e iguale a σ1.",
                                "Explique diferenças com autovalores.",
                                "Aplique em matriz rank 1."
                              ],
                              "assessmentCriteria": [
                                "Precisão na justificativa matemática (≥80%).",
                                "Correta identificação em exemplos numéricos.",
                                "Explicação clara de ordenação e não negatividade.",
                                "Conexão precisa com rank e norma 2.",
                                "Ausência de erros comuns como negatividade.",
                                "Capacidade de generalizar para m x n."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de componentes principais (PCA via SVD).",
                                "Ciência da Computação: Compressão de imagens (truncamento σ_i).",
                                "Física: Modos normais e vibrações (valores singulares em sistemas).",
                                "Engenharia: Análise de estabilidade de estruturas.",
                                "Machine Learning: Redução de dimensionalidade."
                              ],
                              "realWorldApplication": "Em visão computacional, SVD de imagens usa σ_i decrescentes para compressão JPEG2000, preservando qualidade ao truncar pequenos σ_i, reduzindo armazenamento em gigabytes para megabytes sem perda perceptível."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.2",
                        "name": "Vetores Singulares",
                        "description": "Os vetores singulares direitos são os autovetores ortonormais de AᵀA, e os vetores singulares esquerdos são os autovetores ortonormais de AAᵀ, satisfazendo as condições de ortogonalidade e normalização.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.2.1",
                            "name": "Definir vetores singulares direitos",
                            "description": "Explicar que os vetores singulares direitos v_i (colunas de V) são autovetores de AᵀA associados a λ_i = σ_i², com ||v_i||₂ = 1 e {v_i} ortonormais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar autovetores e autovalores de matrizes simétricas",
                                  "subSteps": [
                                    "Defina autovetor e autovalor para uma matriz genérica.",
                                    "Explique por que AᵀA é simétrica e positiva semidefinida.",
                                    "Discuta a decomposição espectral de matrizes simétricas: AᵀA = VΛVᵀ onde V é ortonormal."
                                  ],
                                  "verification": "Resuma em suas palavras a relação entre autovetores de AᵀA e bases ortonormais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang), notebook Jupyter"
                                  ],
                                  "tips": "Lembre-se: autovalores de AᵀA são não-negativos (λ_i ≥ 0).",
                                  "learningObjective": "Compreender os fundamentos de autovetores para contextualizar SVD.",
                                  "commonMistakes": [
                                    "Confundir autovetores com vetores próprios não normalizados.",
                                    "Ignorar que AᵀA é sempre simétrica."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir e analisar a matriz AᵀA",
                                  "subSteps": [
                                    "Compute AᵀA para uma matriz A exemplo (ex: A 2x3).",
                                    "Encontre autovalores λ_i de AᵀA resolvendo det(AᵀA - λI) = 0.",
                                    "Identifique autovetores v_i correspondentes e normalize-os (||v_i||₂ = 1)."
                                  ],
                                  "verification": "Verifique que AᵀA v_i = λ_i v_i para o autovetor calculado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora matricial ou Python (numpy.linalg.eig)",
                                    "Matriz A de exemplo impressa"
                                  ],
                                  "tips": "Use decomposição QR iterativa para autovalores grandes se necessário.",
                                  "learningObjective": "Saber calcular autovetores de AᵀA manualmente ou computacionalmente.",
                                  "commonMistakes": [
                                    "Erro em transposição: AᵀA ≠ AAᵀ.",
                                    "Não normalizar vetores adequadamente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir vetores singulares direitos v_i no contexto SVD",
                                  "subSteps": [
                                    "Recapitule SVD: A = UΣVᵀ onde colunas de V são v_i.",
                                    "Explique que v_i são autovetores de AᵀA com λ_i = σ_i² (σ_i = sqrt(λ_i)).",
                                    "Mostre que colunas de V formam base ortonormal para o espaço de colunas de Aᵀ."
                                  ],
                                  "verification": "Escreva a equação AᵀA v_i = σ_i² v_i e prove para um exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de SVD, software MATLAB/Python para verificação"
                                  ],
                                  "tips": "Visualize geometricamente: v_i maximiza ||Av|| sob ||v||=1 para o maior σ.",
                                  "learningObjective": "Associar precisamente v_i de SVD aos autovetores de AᵀA.",
                                  "commonMistakes": [
                                    "Confundir v_i (direitos) com u_i (esquerdos de AAᵀ).",
                                    "Esquecer σ_i = sqrt(λ_i)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar propriedades ortonormalidade e normalização",
                                  "subSteps": [
                                    "Confirme ||v_i||₂ = 1 para cada v_i.",
                                    "Verifique ortogonalidade: v_iᵀ v_j = δ_ij (0 se i≠j).",
                                    "Discuta ordenação decrescente por σ_i e truncagem em SVD de baixo rank."
                                  ],
                                  "verification": "Compute v_iᵀ v_j para i≠j e confirme =0; ||v_i||=1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Vetores v_i do exemplo anterior"
                                  ],
                                  "tips": "Use Gram-Schmidt se precisar ortonormalizar manualmente.",
                                  "learningObjective": "Garantir que {v_i} forme base ortonormal.",
                                  "commonMistakes": [
                                    "Ordem errada dos autovetores (não decrescente em σ_i).",
                                    "Normalização L1 em vez de L2."
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[3,0],[0,4]], AᵀA = [[9,0],[0,16]]. Autovalores λ1=16 (σ1=4), λ2=9 (σ2=3). v1=[1,0]ᵀ, v2=[0,1]ᵀ (ortonormais, unitários).",
                              "finalVerifications": [
                                "Explique verbalmente a relação v_i e AᵀA.",
                                "Compute v_i para uma A 2x2 não-diagonal.",
                                "Prove σ_i² = λ_i.",
                                "Confirme ortonormalidade matricialmente: VᵀV = I.",
                                "Dê exemplo onde rank(A)<min(m,n) afeta v_i."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de v_i como autovetores de AᵀA.",
                                "Correta derivação de λ_i = σ_i².",
                                "Demonstração clara de ||v_i||=1 e ortonormalidade.",
                                "Uso correto de notação matricial.",
                                "Exemplo prático resolvido sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modos normais em vibrações (autovetores de matriz de massa-rigidez).",
                                "Ciência de Dados: PCA usa autovetores de covariância (análoga a AᵀA).",
                                "Computação Gráfica: SVD para rotação e escalas em transformações.",
                                "Estatística: Análise de componentes principais via SVD."
                              ],
                              "realWorldApplication": "Em compressão de imagens (JPEG2000), v_i de SVD truncado codificam direções de menor variância, reduzindo dados sem perda perceptível de qualidade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.1.2.2",
                            "name": "Definir vetores singulares esquerdos",
                            "description": "Descrever que os vetores singulares esquerdos u_i (colunas de U) são autovetores de AAᵀ associados a σ_i², ou alternativamente u_i = (1/σ_i) A v_i para σ_i > 0, com ortonormalidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos de SVD e vetores singulares direitos",
                                  "subSteps": [
                                    "Recordar a decomposição SVD: A = U Σ Vᵀ, onde U e V são ortogonais, Σ diagonal com valores singulares σ_i ≥ 0.",
                                    "Entender que v_i (colunas de V) são autovetores de Aᵀ A com autovalores σ_i².",
                                    "Verificar ortonormalidade: Vᵀ V = I.",
                                    "Calcular Aᵀ A para uma matriz exemplo pequena.",
                                    "Identificar os σ_i como raízes quadradas dos autovalores positivos de Aᵀ A."
                                  ],
                                  "verification": "Conseguir decompor uma matriz 2x2 em SVD parcial, identificando v_i corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora ou Python (NumPy) para eigen decomposição"
                                  ],
                                  "tips": "Comece com matrizes simétricas positivas definidas para simplificar.",
                                  "learningObjective": "Compreender o papel dos vetores singulares direitos como base para definir os esquerdos.",
                                  "commonMistakes": [
                                    "Confundir Aᵀ A com A Aᵀ",
                                    "Esquecer que σ_i são não-negativos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a matriz A Aᵀ e seus autovetores",
                                  "subSteps": [
                                    "Calcular A Aᵀ para a mesma matriz exemplo, notando que é simétrica positiva semidefinida.",
                                    "Derivar que os autovalores de A Aᵀ são os mesmos σ_i² de Aᵀ A (não-nulos).",
                                    "Resolver o problema de autovalores: A Aᵀ u_i = σ_i² u_i para σ_i > 0.",
                                    "Verificar dimensionalidade: A Aᵀ é m x m se A é m x n.",
                                    "Listar autovetores u_i correspondentes aos σ_i²."
                                  ],
                                  "verification": "Computar autovetores de A Aᵀ e confirmar que os autovalores coincidem com σ_i².",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python (NumPy/SciPy para eig)",
                                    "Matriz exemplo impressa"
                                  ],
                                  "tips": "Use np.linalg.svd() para validar manualmente.",
                                  "learningObjective": "Reconhecer u_i como autovetores de A Aᵀ associados a σ_i².",
                                  "commonMistakes": [
                                    "Ignorar autovalores zero",
                                    "Não normalizar os autovetores"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a relação alternativa u_i = (1/σ_i) A v_i",
                                  "subSteps": [
                                    "Partindo de A v_i = σ_i u_i (pela definição SVD).",
                                    "Rearranjar para u_i = A v_i / σ_i (para σ_i > 0).",
                                    "Verificar computacionalmente: multiplicar A por v_i normalizado e dividir por σ_i.",
                                    "Provar que isso produz um vetor unitário.",
                                    "Comparar com autovetores diretos de A Aᵀ para consistência."
                                  ],
                                  "verification": "Para uma matriz exemplo, calcular u_i via A Aᵀ e via A v_i / σ_i, confirmando igualdade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software Python/MATLAB",
                                    "Exemplo numérico pré-calculado"
                                  ],
                                  "tips": "Escolha σ_i > 0 para evitar divisão por zero.",
                                  "learningObjective": "Dominar as duas definições equivalentes de u_i e sua interdependência com v_i.",
                                  "commonMistakes": [
                                    "Dividir por σ_i = 0",
                                    "Esquecer normalização após multiplicação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar ortonormalidade e propriedades dos u_i",
                                  "subSteps": [
                                    "Confirmar Uᵀ U = I: colunas u_i ortonormais.",
                                    "Verificar que {u_i} formam base ortonormal para espaço coluna de A (para σ_i > 0).",
                                    "Estender para autovalores zero: completar com base ortonormal do núcleo esquerdo.",
                                    "Testar em exemplo: calcular U de SVD e verificar ortogonalidade.",
                                    "Discutir unicidade até sinal."
                                  ],
                                  "verification": "Construir U completo e computar Uᵀ U ≈ I (com tolerância numérica).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python para verificação matricial"
                                  ],
                                  "tips": "Use tolerância 1e-10 para erros numéricos.",
                                  "learningObjective": "Entender a ortonormalidade como propriedade essencial dos vetores singulares esquerdos.",
                                  "commonMistakes": [
                                    "Não completar base para dimensões maiores",
                                    "Confundir com V"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[1, 0], [0, 2]], SVD é U = I_2, Σ = diag(1,2), V = I_2. Então u1 = [1,0], autovetor de A Aᵀ = [[1,0],[0,4]] com λ=1; u2=[0,1] com λ=4. Alternativa: u1 = A v1 /1 = [1,0]; u2 = A v2 /2 = [0,1]. Verifique Uᵀ U = I.",
                              "finalVerifications": [
                                "Explicar verbalmente as duas definições de u_i.",
                                "Calcular u_i para nova matriz 3x2 via ambas métodos.",
                                "Verificar A ≈ U Σ Vᵀ com erro <1e-10.",
                                "Confirmar ortonormalidade de U.",
                                "Identificar casos σ_i=0 corretamente.",
                                "Provar por que u_i são ortonormais via A v_i."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de u_i como autovetores de A Aᵀ.",
                                "Correta aplicação da fórmula u_i = A v_i / σ_i.",
                                "Demonstração de ortonormalidade com cálculo explícito.",
                                "Tratamento adequado de σ_i = 0.",
                                "Uso correto de ferramentas computacionais sem erros.",
                                "Explicação clara de propriedades em contexto SVD."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modos normais em mecânica vibracional (autovetores de matrizes de rigidez).",
                                "Ciência de Dados: Análise de Componentes Principais (PCA) via SVD.",
                                "Computação Gráfica: Compressão de imagens usando truncagem SVD.",
                                "Estatística: Covariância empírica e decomposição espectral."
                              ],
                              "realWorldApplication": "Em processamento de imagens, os vetores singulares esquerdos u_i capturam direções principais de variação nos pixels (espaço de características), permitindo compressão lossless/truncada em U Σ Vᵀ, usada no JPEG2000 e recomendação de sistemas (Netflix)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.1.2.3",
                            "name": "Verificar ortogonalidade dos vetores singulares",
                            "description": "Demonstrar que as colunas de U formam uma base ortonormal de ℝ^m e as de V formam uma base ortonormal de ℝ^n, com relações como A v_i = σ_i u_i.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recapitular as propriedades fundamentais da SVD",
                                  "subSteps": [
                                    "Revise a decomposição SVD: A = U Σ V^T, onde U é m×m ortogonal, Σ é m×n diagonal com σ_i ≥ 0, V é n×n ortogonal.",
                                    "Identifique as colunas de U como vetores singulares esquerdos u_i e de V como vetores singulares direitos v_i.",
                                    "Lembre que bases ortonormais satisfazem u_i · u_j = δ_{ij} e ||u_i|| = 1.",
                                    "Confirme que as dimensões: colunas de U em ℝ^m, de V em ℝ^n.",
                                    "Prepare uma matriz exemplo A para verificação prática."
                                  ],
                                  "verification": "Liste corretamente as propriedades e dimensões da SVD sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre SVD",
                                    "Matriz exemplo A (ex: 2x2 ou 3x2)"
                                  ],
                                  "tips": "Use diagramas para visualizar U, Σ, V; foque em ortogonalidade como U^T U = I.",
                                  "learningObjective": "Compreender o papel ortogonal dos vetores singulares na SVD.",
                                  "commonMistakes": [
                                    "Confundir U com V",
                                    "Esquecer normalização (||u_i||=1)",
                                    "Ignorar dimensões m e n"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar ortogonalidade e normalização das colunas de U",
                                  "subSteps": [
                                    "Compute U^T U manualmente ou com software, confirmando identidade I_m.",
                                    "Para cada par u_i, u_j (i≠j), calcule produto escalar u_i^T u_j = 0.",
                                    "Verifique normalização: u_i^T u_i = 1 para todos i.",
                                    "Analise geometricamente: ângulos retos entre vetores em ℝ^m.",
                                    "Registre resultados em tabela para u_1 a u_m."
                                  ],
                                  "verification": "U^T U = I_m com todos elementos fora da diagonal zero e diagonal unitária.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB",
                                    "Matriz U da SVD exemplo"
                                  ],
                                  "tips": "Use precisão numérica; arredonde erros <10^{-10} a zero.",
                                  "learningObjective": "Demonstrar que colunas de U formam base ortonormal de ℝ^m.",
                                  "commonMistakes": [
                                    "Erro de transposição (U U^T vs U^T U)",
                                    "Não verificar todos pares",
                                    "Confundir com autovetores"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar ortogonalidade e normalização das colunas de V",
                                  "subSteps": [
                                    "Compute V^T V, confirmando I_n.",
                                    "Calcule v_i^T v_j = 0 para i≠j e v_i^T v_i = 1.",
                                    "Visualize vetores em ℝ^n como perpendiculares e unitários.",
                                    "Compare com U, notando diferenças dimensionais se m≠n.",
                                    "Documente em tabela similar à de U."
                                  ],
                                  "verification": "V^T V = I_n exatamente ou numericamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software computacional",
                                    "Matriz V da SVD"
                                  ],
                                  "tips": "Para SV compactas, verifique apenas colunas não-nulas.",
                                  "learningObjective": "Demonstrar base ortonormal das colunas de V em ℝ^n.",
                                  "commonMistakes": [
                                    "Usar V V^T em vez de V^T V",
                                    "Esquecer σ_i=0 implicam v_i irrelevantes",
                                    "Erro aritmético em produtos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar as relações singulares A v_i = σ_i u_i",
                                  "subSteps": [
                                    "Para cada i, compute A v_i e compare com σ_i u_i.",
                                    "Verifique para σ_i > 0 e note que para σ_i=0, A v_i = 0.",
                                    "Confirme consistência com A = U Σ V^T multiplicando.",
                                    "Analise numericamente ||A v_i - σ_i u_i|| ≈ 0.",
                                    "Conclua integrando todas verificações."
                                  ],
                                  "verification": "Equação holds para todos i=1 a min(m,n).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Matriz A original",
                                    "Σ diagonal"
                                  ],
                                  "tips": "Comece com i=1 (maior σ); use norma euclidiana para resíduos.",
                                  "learningObjective": "Validar conexões entre vetores singulares via equações definidoras.",
                                  "commonMistakes": [
                                    "Índices errados i/j",
                                    "Não escalar por σ_i",
                                    "Ignorar núcleo para σ_i=0"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 2], [3, 4], [5, 0]] (3x2). SVD: U (3x3), Σ (3x2), V (2x2). Compute U^T U = I_3, V^T V = I_2, e A v_1 = σ_1 u_1 ≈ [6.95, 0.39]^T * σ_1, verificando numericamente com Python (np.linalg.svd).",
                              "finalVerifications": [
                                "U^T U = I_m e V^T V = I_n confirmados.",
                                "||u_i|| = 1 e u_i ⊥ u_j para todos i,j.",
                                "||v_i|| = 1 e v_i ⊥ v_j para todos i,j.",
                                "A v_i = σ_i u_i para i=1 a r (rank).",
                                "Resíduos numéricos < 10^{-10}.",
                                "Explicação correta de bases ortonormais."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos matriciais (90%+ acurácia).",
                                "Compreensão conceitual de ortogonalidade.",
                                "Uso correto de ferramentas computacionais.",
                                "Identificação e correção de erros comuns.",
                                "Integração de verificações em relatório coerente.",
                                "Explicação das relações A v_i = σ_i u_i."
                              ],
                              "crossCurrularConnections": [
                                "Física: Vetores próprios em mecânica quântica (hamiltonianos).",
                                "Computação: Algoritmos numéricos para SVD (LAPACK).",
                                "Estatística: PCA via SVD para redução dimensional.",
                                "Engenharia: Compressão de sinais e análise modal."
                              ],
                              "realWorldApplication": "Em processamento de imagens, SVD comprime dados verificando ortogonalidade para reconstrução lossless; em recomendadores (Netflix), analisa preferências usuário-item via vetores singulares ortogonais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.3",
                        "name": "Forma Formal da Decomposição SVD",
                        "description": "Qualquer matriz real A ∈ ℝ^{m×n} admite uma decomposição SVD A = U Σ Vᵀ, onde U ∈ ℝ^{m×m} e V ∈ ℝ^{n×n} são matrizes ortogonais, e Σ ∈ ℝ^{m×n} é diagonal com entradas σ_i não negativas ordenadas decrescentemente.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.3.1",
                            "name": "Enunciar o teorema da SVD",
                            "description": "Apresentar formalmente o teorema: Toda matriz A m×n possui SVD A = U Σ Vᵀ com U, V ortogonais e Σ diagonal com σ₁ ≥ … ≥ σ_min(m,n) ≥ 0, e existência única para os σ_i e V sob condições de ordenação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos pré-requisitos da SVD",
                                  "subSteps": [
                                    "Defina uma matriz A de dimensões m × n.",
                                    "Explique o que significa uma matriz ortogonal (U e V tal que UᵀU = I e VᵀV = I).",
                                    "Descreva uma matriz diagonal Σ com entradas σ₁ ≥ σ₂ ≥ … ≥ σ_min(m,n) ≥ 0.",
                                    "Identifique os valores singulares como as raízes quadradas dos autovalores da matriz AᵀA ou AAᵀ.",
                                    "Lembre que os valores singulares são não-negativos e ordenados de forma decrescente."
                                  ],
                                  "verification": "Liste e explique corretamente os três conceitos principais (matriz m×n, ortogonalidade e Σ diagonal ordenada) sem consultar materiais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang)",
                                    "Notas de aula sobre SVD",
                                    "Calculadora ou software como MATLAB para exemplos simples"
                                  ],
                                  "tips": "Use diagramas para visualizar U, Σ e V como transformações geométricas (rotação, escalonamento, rotação).",
                                  "learningObjective": "Compreender os blocos fundamentais da decomposição SVD.",
                                  "commonMistakes": [
                                    "Confundir ortogonalidade com unitariedade em contextos complexos",
                                    "Esquecer que σ_i ≥ 0 e ordenados decrescentemente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar a forma geral do teorema",
                                  "subSteps": [
                                    "Escreva a equação fundamental: A = U Σ Vᵀ.",
                                    "Identifique as dimensões: U é m×m ortogonal, Σ é m×n diagonal, V é n×n ortogonal.",
                                    "Repita a equação verbalmente: 'Toda matriz A m×n admite decomposição A = U Σ V transpose'.",
                                    "Anote exemplos de dimensões para m > n e m < n.",
                                    "Pratique escrevendo a equação 5 vezes variando m e n."
                                  ],
                                  "verification": "Escreva a forma A = U Σ Vᵀ com dimensões corretas para uma matriz 3×2.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta para anotações",
                                    "Quadro branco para repetição"
                                  ],
                                  "tips": "Associe U a 'esquerda', Σ a 'meio' e Vᵀ a 'direita' para fixar a ordem.",
                                  "learningObjective": "Fixar na memória a representação matricial exata da SVD.",
                                  "commonMistakes": [
                                    "Escrever A = U V Σ em vez de A = U Σ Vᵀ",
                                    "Confundir dimensões de U e V"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar a unicidade e condições do teorema",
                                  "subSteps": [
                                    "Explique a unicidade dos valores singulares σ_i (únicos sob ordenação decrescente).",
                                    "Descreva a unicidade de V sob a condição de ordenação dos σ_i.",
                                    "Discuta que U e V não são únicos quando há σ_i repetidos.",
                                    "Enuncie: 'Os σ_i são únicos; V é único para σ_i distintos; U segue similarmente'.",
                                    "Compare com decomposição em autovalores (EVD), onde unicidade é mais restrita."
                                  ],
                                  "verification": "Resuma em uma frase a unicidade de cada componente da SVD.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo ou capítulo sobre propriedades da SVD",
                                    "Exemplos computacionais em Python (numpy.linalg.svd)"
                                  ],
                                  "tips": "Pense em singularidades multiplicadas como 'degenerescências' que permitem rotações em U e V.",
                                  "learningObjective": "Dominar as condições de existência e unicidade do teorema.",
                                  "commonMistakes": [
                                    "Acreditar que toda SVD é única",
                                    "Ignorar a ordenação na unicidade de V"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar o enunciado formal completo",
                                  "subSteps": [
                                    "Combine todos os elementos: 'Toda matriz A m×n possui SVD A = U Σ Vᵀ com U, V ortogonais e Σ diagonal σ₁ ≥ … ≥ σ_min(m,n) ≥ 0'.",
                                    "Adicione unicidade: 'Os σ_i são únicos; V é único sob ordenação'.",
                                    "Recite em voz alta 10 vezes, variando velocidade.",
                                    "Escreva o teorema completo de memória em um papel.",
                                    "Explique para um colega ou grave áudio para autoavaliação."
                                  ],
                                  "verification": "Recite e escreva o teorema completo sem erros em menos de 1 minuto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gravador de voz ou app de notas",
                                    "Papel para escrita final"
                                  ],
                                  "tips": "Use mnemônicos: 'U Σ Vᵀ' como 'Use Sua Visão Transposta'.",
                                  "learningObjective": "Enunciar o teorema de forma fluida e precisa.",
                                  "commonMistakes": [
                                    "Omitir a ordenação decrescente",
                                    "Esquecer Vᵀ em vez de V"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a matriz A = [[1, 0], [0, 0]] (2×2), a SVD é A = U Σ Vᵀ onde U = I (identidade), Σ = diag(1, 0), V = I, com σ₁=1 ≥ σ₂=0 ≥ 0, ilustrando a forma formal e ordenação.",
                              "finalVerifications": [
                                "Recitar o teorema completo sem pausas ou erros.",
                                "Explicar dimensões de U, Σ e V para m≠n.",
                                "Identificar corretamente os valores singulares como não-negativos e ordenados.",
                                "Discutir unicidade para σ_i distintos vs. repetidos.",
                                "Aplicar o teorema a um exemplo simples como matriz identidade.",
                                "Diferenciar SVD de EVD verbalmente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática (U Σ Vᵀ correto).",
                                "Correta descrição da ordenação decrescente dos σ_i.",
                                "Menção explícita à ortogonalidade de U e V.",
                                "Inclusão da unicidade sob condições de ordenação.",
                                "Uso correto de dimensões m×n.",
                                "Fluência no enunciado sem hesitações."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Algoritmos computacionais para calcular SVD (ex: Golub-Reinsch).",
                                "Processamento de Imagens: Compressão via truncada SVD.",
                                "Machine Learning: Redução de dimensionalidade em PCA.",
                                "Física Computacional: Simulações quânticas e análise espectral."
                              ],
                              "realWorldApplication": "A SVD é fundamental em compressão de dados (ex: Netflix recomendações via PCA/SVD), processamento de sinais (ruído removal), e reconhecimento facial (eigenfaces), permitindo análise eficiente de grandes matrizes em IA e engenharia."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1",
                              "10.1.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.1.3.2",
                            "name": "Interpretar componentes da SVD",
                            "description": "Explicar o papel de U (espaço coluna de A), Σ (escalas singulares), Vᵀ (espaço linha de A), e reconstrução A = ∑ σ_i u_i v_iᵀ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a matriz U e seu papel no espaço coluna de A",
                                  "subSteps": [
                                    "Revise a definição: U é uma matriz ortogonal m x m cujas colunas são os vetores singulares esquerdos de A.",
                                    "Entenda que as colunas de U formam uma base ortonormal para o espaço coluna de A.",
                                    "Verifique propriedades: Uᵀ U = I (ortogonalidade) e A = U Σ Vᵀ implica espaço coluna.",
                                    "Visualize geometricamente: U rotaciona/reflete para alinhar com os eixos singulares.",
                                    "Pratique com uma matriz exemplo: compute colunas de U via autovetores de A Aᵀ."
                                  ],
                                  "verification": "Liste 3 propriedades de U e explique como elas se relacionam ao espaço coluna de A.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matriz A de exemplo 2x2 ou 3x3",
                                    "Python com numpy.linalg.svd",
                                    "Papel e lápis para esboços geométricos"
                                  ],
                                  "tips": "Lembre-se: colunas de U são autovetores de A Aᵀ, normalizados.",
                                  "learningObjective": "Identificar U como base ortonormal do espaço coluna de A.",
                                  "commonMistakes": [
                                    "Confundir colunas de U com autovetores de A",
                                    "Ignorar a ortogonalidade de U"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar a matriz diagonal Σ e os valores singulares",
                                  "subSteps": [
                                    "Defina Σ: matriz m x n diagonal com valores singulares σ₁ ≥ σ₂ ≥ ... ≥ 0 na diagonal.",
                                    "Entenda o significado: σ_i representam as 'escalas' ou 'comprimentos' dos componentes singulares.",
                                    "Ordene os valores: decrescentes, indicando importância relativa dos modos.",
                                    "Relacione com norma: maior σ_i captura mais 'energia' da matriz A.",
                                    "Compute para exemplo: extraia σ de output SVD e interprete magnitudes."
                                  ],
                                  "verification": "Para uma Σ exemplo, explique o que cada σ_i representa em termos de escala.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Output de SVD de matriz exemplo",
                                    "Calculadora ou Python para valores singulares"
                                  ],
                                  "tips": "Valores singulares zero indicam nulidade; ignore-os na reconstrução aproximada.",
                                  "learningObjective": "Explicar σ_i como fatores de escala nos componentes rank-1.",
                                  "commonMistakes": [
                                    "Pensar que Σ é simétrica sempre",
                                    "Confundir ordem decrescente com crescente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Vᵀ e seu papel no espaço linha de A",
                                  "subSteps": [
                                    "Defina Vᵀ: transpose de V (n x n ortogonal), linhas de Vᵀ são vetores singulares direitos.",
                                    "Entenda relação: colunas de V formam base ortonormal para espaço linha de A.",
                                    "Propriedades: V Vᵀ = I, autovetores de Aᵀ A.",
                                    "Geometricamente: V rotaciona o espaço de entrada para alinhar com singulares.",
                                    "Extraia de SVD: interprete linhas de Vᵀ como direções principais de variação."
                                  ],
                                  "verification": "Descreva como Vᵀ contribui para o espaço linha e cite uma propriedade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matriz A exemplo",
                                    "Software SVD para extrair V",
                                    "Notas sobre Aᵀ A"
                                  ],
                                  "tips": "Vᵀ Aᵀ = Σ Uᵀ mostra dualidade esquerda-direita.",
                                  "learningObjective": "Reconhecer Vᵀ como base para espaço linha de A.",
                                  "commonMistakes": [
                                    "Confundir V com U",
                                    "Esquecer que é Vᵀ na decomposição"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender a reconstrução A = U Σ Vᵀ como soma de componentes rank-1",
                                  "subSteps": [
                                    "Escreva a equação: A = ∑_{i=1}^r σ_i u_i v_iᵀ, onde r é o rank.",
                                    "Interprete cada termo: σ_i u_i v_iᵀ é matriz rank-1 escalada.",
                                    "Reconstrua passo a passo: some os primeiros k termos para aproximação.",
                                    "Verifique: multiplique U Σ Vᵀ e confira igual a A original.",
                                    "Discuta truncada: SVD low-rank para compressão/dimensionalidade."
                                  ],
                                  "verification": "Reconstrua A de seus componentes SVD e explique o papel de cada termo na soma.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código Python para reconstrução",
                                    "Matriz A 3x2 exemplo",
                                    "Gráficos de aproximação"
                                  ],
                                  "tips": "Comece com k=1: maior σ_i dá melhor aproximação rank-1.",
                                  "learningObjective": "Explicar decomposição como soma de dyads escalados.",
                                  "commonMistakes": [
                                    "Esquecer o transpose em v_iᵀ",
                                    "Somar além do rank"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[1, 2], [0, 1]], SVD dá U ≈ [[0.81, -0.59], [0.59, 0.81]], Σ = diag(2.62, 0.38), Vᵀ ≈ [[0.85, 0.53], [-0.53, 0.85]]. U gira colunas de A; Σ escala (2.62 dominante); Vᵀ gira linhas. Reconstrução: 2.62*u1*v1ᵀ + 0.38*u2*v2ᵀ ≈ A, com primeiro termo capturando ~98% da norma.",
                              "finalVerifications": [
                                "Explicar corretamente o papel de U como base do espaço coluna.",
                                "Identificar Σ como contendo escalas singulares ordenadas.",
                                "Descrever Vᵀ relacionado ao espaço linha via autovetores de Aᵀ A.",
                                "Reconstruir A = U Σ Vᵀ e justificar a soma σ_i u_i v_iᵀ.",
                                "Aplicar SVD a uma matriz 2x2 e interpretar componentes.",
                                "Discutir o que acontece se σ_i = 0."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de U, Σ, Vᵀ (80% peso).",
                                "Compreensão geométrica: explicação de rotações e escalas.",
                                "Habilidade de reconstrução: cálculo numérico exato ou aproximado.",
                                "Uso de notação matemática: σ_i u_i v_iᵀ correto.",
                                "Interpretação qualitativa: importância relativa dos componentes.",
                                "Clareza na explicação oral/escrita."
                              ],
                              "crossCurricularConnections": [
                                "Ciência de Dados: PCA via SVD para redução de dimensionalidade.",
                                "Processamento de Imagens: Compressão JPEG2000 usando SVD truncado.",
                                "Machine Learning: Sistemas de recomendação (Netflix Prize).",
                                "Física Computacional: Diagonalização em mecânica quântica.",
                                "Engenharia: Análise modal em vibrações/estruturas."
                              ],
                              "realWorldApplication": "Em sistemas de recomendação como Netflix, SVD decompõe a matriz usuário-filme em U (perfis usuário), Σ (forças de preferência), Vᵀ (perfis filme), permitindo predições preenchendo zeros e reduzindo dimensionalidade para milhões de entradas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1",
                              "10.1.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.1.3.3",
                            "name": "Discutir variantes da SVD",
                            "description": "Diferenciar SVD completa (U m×m, V n×n) de SVD econômica (U m×r, Σ r×r, V n×r), e casos especiais como matrizes quadradas ou de posto deficiente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição da SVD Completa",
                                  "subSteps": [
                                    "Lembre a decomposição SVD básica: para matriz A ∈ ℝ^{m×n}, A = U Σ V^T, onde U ∈ ℝ^{m×m} ortogonal, Σ ∈ ℝ^{m×n} diagonal não-negativa, V ∈ ℝ^{n×n} ortogonal.",
                                    "Identifique as dimensões exatas: U tem m colunas ortonormais formando base de ℝ^m, V para ℝ^n, Σ tem singular values na diagonal principal.",
                                    "Discuta propriedades: A e Σ têm os mesmos singular values, ||A||_2 = σ_1 (maior singular value).",
                                    "Construa um exemplo simples: SVD completa de uma matriz 2x2 quadrada.",
                                    "Verifique ortogonalidade: U^T U = I_m, V^T V = I_n."
                                  ],
                                  "verification": "Reproduzir manualmente a SVD completa de uma matriz 2x3 fornecida e confirmar dimensões e ortogonalidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang), calculadora ou Python/NumPy para verificação"
                                  ],
                                  "tips": "Sempre anote as dimensões m e n para evitar confusões; use software para validar cálculos manuais.",
                                  "learningObjective": "Compreender a estrutura dimensional e propriedades da SVD completa.",
                                  "commonMistakes": [
                                    "Confundir dimensões de Σ como quadrada sempre",
                                    "Esquecer que U e V são quadradas completas",
                                    "Não verificar ortogonalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a SVD Econômica (Thin SVD)",
                                  "subSteps": [
                                    "Defina SVD econômica: A = Ũ Σ̃ Ṽ^T, onde Ũ ∈ ℝ^{m×r} (r = rank(A)), Σ̃ ∈ ℝ^{r×r} diagonal, Ṽ ∈ ℝ^{n×r}, com r ≤ min(m,n).",
                                    "Compare dimensões: Ũ tem apenas r colunas (vetores singulares esquerdos relevantes), similar para Ṽ.",
                                    "Explique economia: Armazena apenas componentes não-nulas, reduzindo custo computacional e memória.",
                                    "Construa exemplo: SVD econômica da mesma matriz 2x3 do step 1.",
                                    "Verifique equivalência: Ũ Σ̃ Ṽ^T = U Σ V^T para a parte relevante."
                                  ],
                                  "verification": "Converter uma SVD completa em econômica removendo zeros e confirmar igualdade numérica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software NumPy/MATLAB com svd(full=False) vs svd(full=True)",
                                    "Papel e lápis para dimensões"
                                  ],
                                  "tips": "r é o número de singular values não-zero; foque em eficiência para matrizes grandes.",
                                  "learningObjective": "Dominar a forma reduzida da SVD e suas vantagens dimensionais.",
                                  "commonMistakes": [
                                    "Assumir r = min(m,n) sempre (ignora rank deficiente)",
                                    "Confundir Ṽ como n×n",
                                    "Não notar que Σ̃ é sempre quadrada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar Variantes e Discutir Quando Usar Cada Uma",
                                  "subSteps": [
                                    "Liste diferenças chave: Completa preserva bases completas de ℝ^m e ℝ^n; Econômica é compacta para rank baixo.",
                                    "Discuta cenários: Use completa para reconstrução total ou quando m,n pequenos; econômica para big data ou redução dimensional.",
                                    "Compare custo: Completa O(min(m,n)^3 + ...), econômica mais eficiente em armazenamento.",
                                    "Avalie precisão: Ambas exatas, mas econômica ignora singular values zero implicitamente.",
                                    "Pratique switch: Dado A, compute ambas e compare outputs."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito por que escolher econômica para uma matriz 1000x10 de rank 5.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação NumPy svd modes",
                                    "Exemplos de matrizes geradas aleatoriamente"
                                  ],
                                  "tips": "Pense em aplicações: econômica para PCA em ML onde rank << n.",
                                  "learningObjective": "Saber selecionar variante baseada em contexto computacional.",
                                  "commonMistakes": [
                                    "Usar completa desnecessariamente em dados esparsos",
                                    "Ignorar overhead de memória em SVD completa"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Casos Especiais: Matrizes Quadradas e de Posto Deficiente",
                                  "subSteps": [
                                    "Matrizes quadradas (m=n): SVD completa U,V n×n; econômica se rank < n vira U n×r, etc.",
                                    "Posto deficiente (r < min(m,n)): Σ tem zeros; econômica remove eles, Σ̃ r×r.",
                                    "Exemplo quadrada rank-deficient: A = [[1,0],[0,0]], mostrar ambas variantes.",
                                    "Discuta implicações: Null space em Ṽ colunas extras zero; range em Ũ.",
                                    "Verifique: Compute rank via número de singular values > tol."
                                  ],
                                  "verification": "Para matriz 3x3 rank 2, descrever dims de U,Σ,V em completa e econômica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matrizes de exemplo handwritten",
                                    "Software para svd e rank computation"
                                  ],
                                  "tips": "Use tolerância numérica (eps*max(singular values)) para detectar zeros.",
                                  "learningObjective": "Identificar e decompor SVD em casos não-triviais.",
                                  "commonMistakes": [
                                    "Tratar rank deficiente como full rank",
                                    "Confundir para quadradas: econômica só se r<n",
                                    "Ignorar numérica instabilidade em zeros"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[3, 0], [0, 0], [0, 4]] (3x2, rank 2). SVD completa: U 3x3, Σ 3x2 (σ1=4, σ2=3, resto zero), V 2x2. Econômica: Ũ 3x2, Σ̃ 2x2 diag(4,3), Ṽ 2x2. Verifique A ≈ U Σ V^T = Ũ Σ̃ Ṽ^T.",
                              "finalVerifications": [
                                "Explicar dims de U, Σ, V para SVD completa vs econômica em m=5, n=3, r=2.",
                                "Identificar quando SVD econômica economiza 50% memória.",
                                "Computar SVD de matriz quadrada 4x4 rank 3 e listar singular values.",
                                "Discutir por que software default usa econômica.",
                                "Reconstruir A de sua SVD econômica e confirmar erro < 1e-10.",
                                "Explicar impacto de rank deficiente na forma de Σ."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas dimensões e propriedades de cada variante (90% correto).",
                                "Capacidade de escolher variante baseada em m,n,r e aplicação (razão lógica).",
                                "Exemplos corretos com verificação numérica.",
                                "Compreensão de eficiência computacional e armazenamento.",
                                "Tratamento correto de casos especiais sem erros dimensionais.",
                                "Explicações claras diferenciando completa vs econômica."
                              ],
                              "crossCurricularConnections": [
                                "Machine Learning: SVD econômica em PCA para redução dimensional.",
                                "Processamento de Sinais: Compressão via truncada SVD (aproximação low-rank).",
                                "Estatística: Análise de componentes principais e regressão.",
                                "Computação Científica: Solução de sistemas lineares via pseudo-inversa (SVD).",
                                "Física: Decomposição espectral em mecânica quântica."
                              ],
                              "realWorldApplication": "Em visão computacional, SVD econômica comprime imagens (ex: JPEG2000) retendo 99% energia com r<<min(m,n), reduzindo armazenamento em gigapixels de dados de satélite; em recomendadores Netflix, low-rank SVD aproxima matriz usuário-item para previsões eficientes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1",
                              "10.1.1.1.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.2",
                    "name": "Propriedades da SVD",
                    "description": "Estudo das propriedades algébricas, como ordenação dos valores singulares, unicidade e relação com norma e condição da matriz.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.2.1",
                        "name": "Ordenação dos Valores Singulares",
                        "description": "Estudo da propriedade fundamental de que os valores singulares de uma matriz são ordenados de forma não-crescente e não-negativos, com σ₁ ≥ σ₂ ≥ ... ≥ σₘ ≥ 0, e sua importância na análise espectral da matriz.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.1",
                            "name": "Enunciar a ordenação dos valores singulares",
                            "description": "Descrever formalmente a ordenação não-crescente dos valores singulares σ₁ ≥ σ₂ ≥ ... ≥ σ_r > 0 ≥ σ_{r+1} = ... = σ_min(m,n), justificando sua origem a partir dos autovalores da matriz AᵀA ou AAᵀ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais da SVD e Valores Singulares",
                                  "subSteps": [
                                    "Defina a decomposição SVD de uma matriz A ∈ ℝ^{m×n} como A = U Σ Vᵀ, onde U e V são ortogonais e Σ é diagonal com entradas σ_i.",
                                    "Explique que os valores singulares σ_i são números reais não-negativos.",
                                    "Identifique que os σ_i são as raízes quadradas dos autovalores das matrizes AᵀA (n×n) ou AAᵀ (m×n).",
                                    "Discuta que AᵀA e AAᵀ são simétricas e positivas semi-definidas (PSD).",
                                    "Liste os autovalores não-nulos de AᵀA e AAᵀ como iguais."
                                  ],
                                  "verification": "Escreva a definição de SVD e relacione σ_i aos autovalores de AᵀA para uma matriz exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre Álgebra Linear",
                                    "Matriz exemplo 2×2",
                                    "Calculadora ou software como Python/NumPy"
                                  ],
                                  "tips": "Sempre lembre que σ_i ≥ 0 por serem raízes quadradas de autovalores PSD.",
                                  "learningObjective": "Compreender a origem e estrutura básica dos valores singulares.",
                                  "commonMistakes": [
                                    "Confundir valores singulares com autovalores de A",
                                    "Esquecer que U e V são ortogonais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Propriedades de AᵀA e AAᵀ",
                                  "subSteps": [
                                    "Calcule AᵀA para uma matriz A exemplo e verifique que é simétrica PSD.",
                                    "Encontre os autovalores λ_1 ≥ λ_2 ≥ ... ≥ λ_n ≥ 0 de AᵀA por convenção de ordenação decrescente.",
                                    "Defina σ_i = √λ_i para i=1 a min(m,n), preenchendo zeros se necessário.",
                                    "Repita para AAᵀ e note que autovalores não-nulos coincidem.",
                                    "Verifique numericamente com uma matriz exemplo usando software."
                                  ],
                                  "verification": "Para A = [[1,1],[0,1]], compute AᵀA, seus autovalores e derive os σ_i ordenados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matriz exemplo impressa ou digital",
                                    "Software NumPy/MATLAB para eigen/svd",
                                    "Papel e lápis para cálculos manuais"
                                  ],
                                  "tips": "Use decomposição espectral para matrizes pequenas para praticar.",
                                  "learningObjective": "Relacionar explicitamente autovalores de AᵀA/AAᵀ aos valores singulares.",
                                  "commonMistakes": [
                                    "Não ordenar autovalores decrescentemente",
                                    "Esquecer zeros para σ_i além de rank(A)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar a Convenção de Ordenação dos Autovalores",
                                  "subSteps": [
                                    "Revise que para matrizes simétricas PSD, autovalores são ordenados λ_1 ≥ λ_2 ≥ ... ≥ λ_k > 0 = λ_{k+1} = ... = λ_n.",
                                    "Explique por que essa ordenação é padrão em álgebra linear numérica.",
                                    "Derive que σ_1 ≥ σ_2 ≥ ... ≥ σ_r > 0 ≥ σ_{r+1} = ... = σ_{min(m,n)} segue da ordenação de λ_i.",
                                    "Discuta o rank r como o número de σ_i > 0.",
                                    "Ilustre com teorema de Courant-Fischer para justificar ordenação."
                                  ],
                                  "verification": "Prove que se λ_i ≥ λ_j para i<j, então σ_i ≥ σ_j, citando propriedades de raízes quadradas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang)",
                                    "Artigos sobre propriedades PSD",
                                    "Exemplos computados"
                                  ],
                                  "tips": "Pense na interpretação geométrica: maiores σ_i correspondem a direções de maior 'alongamento'.",
                                  "learningObjective": "Entender a justificativa matemática para a ordenação não-crescente.",
                                  "commonMistakes": [
                                    "Assumir ordenação crescente",
                                    "Ignorar multiplicidades de autovalores zero"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Enunciar Formalmente a Ordenação e Justificar",
                                  "subSteps": [
                                    "Escreva a notação completa: σ_1 ≥ σ_2 ≥ ... ≥ σ_r > 0 ≥ σ_{r+1} = ... = σ_{min(m,n)}.",
                                    "Justifique: σ_i = √λ_i onde λ_i são autovalores ordenados de AᵀA ou AAᵀ.",
                                    "Explique o papel do rank r = dim(im(A)).",
                                    "Forneça prova sucinta usando propriedades de autovalores PSD.",
                                    "Teste o enunciado com exemplo numérico completo."
                                  ],
                                  "verification": "Enuncie a ordenação para uma matriz qualquer e justifique com AᵀA.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha para escrita formal",
                                    "Exemplo final consolidado",
                                    "Referência teórica"
                                  ],
                                  "tips": "Memorize a notação exata, incluindo o >0 e os zeros finais.",
                                  "learningObjective": "Dominar o enunciado preciso e sua derivação.",
                                  "commonMistakes": [
                                    "Usar ≥ para todos σ_i incluindo zeros",
                                    "Confundir min(m,n) com max(m,n)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[3,0],[0,1]] (2×2), AᵀA = [[9,0],[0,1]], autovalores λ1=9, λ2=1, então σ1=3 ≥ σ2=1 >0. A SVD ordena Σ=diag(3,1). Isso captura a 'energia' principal na primeira direção.",
                              "finalVerifications": [
                                "Enuncia corretamente σ₁ ≥ ... ≥ σ_r > 0 ≥ σ_{r+1} = ... = σ_min(m,n).",
                                "Justifica origem como √ dos autovalores ordenados de AᵀA/AAᵀ.",
                                "Identifica r como o rank de A.",
                                "Aplica a uma matriz exemplo produzindo ordenação correta.",
                                "Explica por que a ordenação é não-crescente.",
                                "Distingue autovalores zero dos positivos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática (símbolos, índices, desigualdades).",
                                "Correção na justificativa via autovalores PSD.",
                                "Compreensão conceitual de rank e zeros finais.",
                                "Capacidade de computar e ordenar σ_i em exemplos.",
                                "Clareza na explicação oral ou escrita.",
                                "Identificação de propriedades de AᵀA/AAᵀ."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Ordenação em PCA/SVD para redução de dimensionalidade.",
                                "Computação: Funções svd() em NumPy/MATLAB retornam σ ordenados.",
                                "Física: Análise de vibrações modais usa autovalores ordenados.",
                                "Engenharia: Compressão de sinais prioriza maiores σ_i."
                              ],
                              "realWorldApplication": "Na compressão de imagens (JPEG2000), os maiores valores singulares σ_i capturam a maior parte da energia da imagem, permitindo truncar os menores para reduzir tamanho sem perda perceptível de qualidade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2",
                            "name": "Verificar ordenação em exemplos numéricos",
                            "description": "Aplicar SVD computacionalmente a matrizes exemplo usando software como MATLAB ou Python (numpy.linalg.svd) e confirmar que os valores singulares retornados estão ordenados de forma decrescente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e preparar matriz exemplo",
                                  "subSteps": [
                                    "Escolha uma matriz retangular simples, como uma 2x3 ou 3x2, com valores numéricos variados.",
                                    "Defina a matriz em formato de array/lista compatível com Python ou MATLAB.",
                                    "Registre a matriz escolhida e seus dimensões (linhas x colunas).",
                                    "Visualize a matriz para confirmar entrada correta.",
                                    "Prepare um notebook Jupyter ou script para documentar."
                                  ],
                                  "verification": "Matriz definida corretamente e impressa na tela sem erros de sintaxe.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Editor de código (VS Code, Jupyter Notebook), Python instalado.",
                                  "tips": "Comece com matrizes pequenas para depuração rápida.",
                                  "learningObjective": "Entender como preparar dados de entrada para SVD computacional.",
                                  "commonMistakes": "Usar matriz quadrada simétrica desnecessariamente; esquecer de importar bibliotecas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar ambiente e computar SVD",
                                  "subSteps": [
                                    "Instale numpy se necessário: pip install numpy.",
                                    "Importe numpy como np.",
                                    "Defina a matriz A no código.",
                                    "Execute SVD: U, s, Vt = np.linalg.svd(A, full_matrices=False).",
                                    "Imprima U, s e Vt para inspeção inicial."
                                  ],
                                  "verification": "SVD executada sem erros e valores singulares s impressos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python 3+, biblioteca NumPy, ambiente Jupyter ou terminal.",
                                  "tips": "Use full_matrices=False para economia computacional em matrizes retangulares.",
                                  "learningObjective": "Aplicar função SVD computacionalmente de forma correta.",
                                  "commonMistakes": "Confundir ordem dos retornos (U, s, Vt); não especificar full_matrices."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair e analisar valores singulares",
                                  "subSteps": [
                                    "Identifique o array s de valores singulares.",
                                    "Imprima s explicitamente e note seu comprimento (min(m,n) para matriz m x n).",
                                    "Calcule manualmente se s[0] >= s[1] >= ... >= s[k-1] >= 0.",
                                    "Registre os valores exatos de s.",
                                    "Compare com propriedades teóricas (não-negativos, ordenados decrescentes)."
                                  ],
                                  "verification": "Lista de valores singulares extraída e impressa corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Código Python do passo anterior.",
                                  "tips": "Use np.sort(s)[::-1] para comparar ordenação manual.",
                                  "learningObjective": "Isolar e interpretar componente de valores singulares da SVD.",
                                  "commonMistakes": "Ignorar zeros no final; assumir ordenação crescente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar ordenação programaticamente e concluir",
                                  "subSteps": [
                                    "Escreva código para check: np.all(np.diff(s) <= 0).",
                                    "Execute o check e imprima True/False.",
                                    "Teste com matriz transposta ou outra matriz para generalizar.",
                                    "Documente observações em relatório ou comentário.",
                                    "Confirme que propriedade se mantém em múltiplos exemplos."
                                  ],
                                  "verification": "Check de ordenação retorna True para exemplos válidos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Código Python expandido.",
                                  "tips": "Use assert np.all(np.diff(s) <= 0) para automação.",
                                  "learningObjective": "Validar propriedade de ordenação decrescente empiricamente.",
                                  "commonMistakes": "Usar > em vez de >= (permite zeros iguais); não testar casos edge."
                                }
                              ],
                              "practicalExample": "Matriz A = np.array([[1, 2, 3], [4, 5, 6]]). SVD: s ≈ [9.52, 0.38]. Check: 9.52 > 0.38 (True). Código: import numpy as np; A = np.array([[1,2,3],[4,5,6]]); U,s,Vt=np.linalg.svd(A,full_matrices=False); print(s); print(np.all(np.diff(s)<=0)) → True.",
                              "finalVerifications": [
                                "Valores singulares s são não-negativos.",
                                "s está ordenado decrescente: s[i] >= s[i+1] para todo i.",
                                "Comprimento de s é min(m,n).",
                                "SVD reconstrói A: np.allclose(A, U @ np.diag(s) @ Vt) é True.",
                                "Testado em pelo menos duas matrizes diferentes.",
                                "Código roda sem erros em ambiente padrão."
                              ],
                              "assessmentCriteria": [
                                "Execução correta de SVD sem erros de código.",
                                "Identificação precisa dos valores singulares.",
                                "Verificação automatizada de ordenação decrescente.",
                                "Interpretação correta da propriedade teórica.",
                                "Documentação clara de resultados e exemplos.",
                                "Generalização para múltiplas matrizes."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Uso de NumPy para álgebra linear.",
                                "Análise de Dados: SVD em PCA para redução dimensional.",
                                "Estatística: Valores singulares em análise de variância.",
                                "Engenharia: Compressão de sinais onde ordenação define componentes principais."
                              ],
                              "realWorldApplication": "Em Processamento de Imagens, SVD ordena componentes de energia decrescente para compressão eficiente (ex: JPEG2000); em Recomendação de Netflix, prioriza fatores latentes mais importantes para precisão."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.3",
                            "name": "Relacionar multiplicidade com ordenação",
                            "description": "Explicar como valores singulares repetidos afetam a ordenação e derivar implicações para o posto da matriz quando σ_k = σ_{k+1} = ... = 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a ordenação padrão dos valores singulares na SVD",
                                  "subSteps": [
                                    "Lembre-se da decomposição SVD: A = U Σ V^T, onde Σ é diagonal com σ1 ≥ σ2 ≥ ... ≥ σn ≥ 0.",
                                    "Identifique que a ordenação é não crescente, permitindo igualdades (multiplicidades).",
                                    "Escreva um exemplo simples de Σ com valores distintos: diag(5, 3, 1, 0, 0).",
                                    "Discuta por que a ordenação é essencial para propriedades como aproximação de baixo rank.",
                                    "Verifique a convenção padrão em textos de álgebra linear."
                                  ],
                                  "verification": "Construa manualmente Σ para uma matriz 3x3 e confirme σ1 ≥ σ2 ≥ σ3.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora ou Python (numpy.linalg.svd)"
                                  ],
                                  "tips": "Sempre normalize para ordenação decrescente ao computar SVD numericamente.",
                                  "learningObjective": "Compreender a convenção de ordenação não crescente dos valores singulares.",
                                  "commonMistakes": [
                                    "Confundir com autovalores (não ordenados por módulo)",
                                    "Ignorar zeros no final"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o impacto de multiplicidades em valores singulares não-zero",
                                  "subSteps": [
                                    "Defina multiplicidade: número de σi iguais consecutivos devido à ordenação.",
                                    "Exemplo: Σ com σ1 = σ2 = 4 > σ3 = 2 > 0.",
                                    "Analise geometricamente: multiplicidade k para σ implica dimensão k no espaço de valores singulares.",
                                    "Compute SVD de uma matriz com multiplicidade conhecida, como uma projeção.",
                                    "Verifique que a ordenação preserva multiplicidades sem alterar propriedades."
                                  ],
                                  "verification": "Encontre ou crie uma matriz onde dois σi sejam iguais e confirme na SVD.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software Python/MATLAB",
                                    "Matriz exemplo 4x4"
                                  ],
                                  "tips": "Use tolerância numérica (eps) para detectar igualdades em computação.",
                                  "learningObjective": "Explicar como multiplicidades não-zero afetam a estrutura da SVD.",
                                  "commonMistakes": [
                                    "Assumir que multiplicidades implicam singularidade",
                                    "Desordenar ao reescalar"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar multiplicidade do valor singular zero e relação com o posto",
                                  "subSteps": [
                                    "Defina posto(rank): r = max{k | σk > 0}, multiplicidade de zero m = n - r.",
                                    "Exemplo: Se σ3 = σ4 = σ5 = 0 em matriz 5x5, rank=2.",
                                    "Derive: Quando σk = σ_{k+1} = ... = σn = 0, rank(A) = k-1.",
                                    "Conecte à nulidade: dim(ker(A)) = m, dim(ker(A^T)) = m.",
                                    "Prove usando propriedades: trace(Σ) não afeta, mas contagem de zeros sim."
                                  ],
                                  "verification": "Para uma matriz rank-deficient, compute SVD e conte zeros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matrizes rank-deficient exemplos",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use svdvals() para valores singulares rápidos sem U,V.",
                                  "learningObjective": "Derivar implicações do posto a partir de multiplicidade de zero.",
                                  "commonMistakes": [
                                    "Contar zeros incluindo não-exatos por numérica",
                                    "Confundir com autovalores zero"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar implicações gerais e derivar fórmulas",
                                  "subSteps": [
                                    "Resuma: Multiplicidades preservam ordenação; zeros definem rank.",
                                    "Derive: rank(A) = #{i | σi > 0}, independentemente de multiplicidades não-zero.",
                                    "Discuta estabilidade: multiplicidades afetam conditioning number.",
                                    "Aplique a aproximação: corte após último σ >0.",
                                    "Crie tabela comparativa de exemplos com diferentes multiplicidades."
                                  ],
                                  "verification": "Resolva problema: dada Σ com multiplicidades, encontre rank e explique ordenação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela em papel",
                                    "Exemplos de problemas"
                                  ],
                                  "tips": "Visualize com heatmaps de Σ para multiplicidades.",
                                  "learningObjective": "Integrar multiplicidade, ordenação e posto em uma visão coesa.",
                                  "commonMistakes": [
                                    "Ignorar ordenação em aproximações de baixo rank",
                                    "Confundir multiplicidade com degenerescência"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[1,1],[1,1]] (rank 1). SVD: σ1=√2, σ2=0 (multiplicidade 1 para zero). Se A zero 2x2, σ1=σ2=0 (multiplicidade 2), rank=0. Explique ordenação e posto.",
                              "finalVerifications": [
                                "Explique verbalmente como σk=...=σn=0 implica rank=k-1.",
                                "Compute SVD de matriz com multiplicidade não-zero e identifique rank.",
                                "Diferencie impacto de multiplicidades >0 vs =0.",
                                "Crie Σ inválida (não ordenada) e corrija.",
                                "Relacione nulidade com multiplicidade de zero."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de multiplicidade e ordenação (90% correto).",
                                "Correta derivação de rank de sequência de σi (sem erros).",
                                "Uso apropriado de exemplos concretos com SVD computada.",
                                "Clareza em conectar propriedades geométricas (espaços).",
                                "Identificação de pelo menos 2 implicações práticas.",
                                "Ausência de confusões com autovalores."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação numérica de SVD em NumPy/SciPy.",
                                "Física: Análise de componentes principais (PCA) onde multiplicidades indicam ruído.",
                                "Estatística: Redução dimensional com truncagem baseada em σ.",
                                "Engenharia: Compressão de dados matriciais (imagens)."
                              ],
                              "realWorldApplication": "Em processamento de imagens, SVD com multiplicidades de σ pequenos (~zero) permite compressão lossless cortando zeros, preservando rank para reconstrução fiel; ex: JPEG2000 usa similar para eficiência."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.2",
                        "name": "Unicidade da Decomposição SVD",
                        "description": "Análise da unicidade da SVD, onde os valores singulares são únicos, mas as matrizes ortogonais U e V são únicas apenas até sinais e permutações em blocos de singularidades iguais.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.2.1",
                            "name": "Enunciar teorema de unicidade da SVD",
                            "description": "Formular o teorema de unicidade: os valores singulares σ_i são únicos; colunas de U e V correspondentes a σ_i distintos são únicas até sinal; para σ_i = σ_j, subespaços são únicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição e componentes da Decomposição em Valores Singulares (SVD)",
                                  "subSteps": [
                                    "Lembre-se da forma padrão da SVD: para uma matriz A m×n, A = U Σ V^H onde U é unitária m×m, Σ é diagonal m×n com σ_i ≥ 0 não-crescentes, V unitária n×n.",
                                    "Identifique os componentes: valores singulares σ_i são as raízes quadradas dos autovalores de A^H A ou A A^H.",
                                    "Entenda as propriedades ortogonais: colunas de U e V são vetores singulares esquerdos e direitos.",
                                    "Visualize geometricamente: SVD representa rotações, escalas e rotações inversas.",
                                    "Anote exemplos simples de SVD para matrizes 2x2."
                                  ],
                                  "verification": "Escreva a definição completa da SVD e identifique corretamente U, Σ e V em um exemplo dado.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Notas de aula sobre SVD",
                                    "Livro de Álgebra Linear (ex: Strang)",
                                    "Calculadora ou software como MATLAB/Python (numpy.linalg.svd)"
                                  ],
                                  "tips": "Use diagramas para visualizar as transformações; foque nos autovalores positivos.",
                                  "learningObjective": "Compreender os componentes fundamentais da SVD como base para discutir unicidade.",
                                  "commonMistakes": [
                                    "Confundir SVD com decomposição espectral (que requer simetria)",
                                    "Esquecer que Σ tem σ_i em ordem não-crescente",
                                    "Ignorar o caso complexo com V^H"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a unicidade dos valores singulares σ_i",
                                  "subSteps": [
                                    "Prove ou entenda por que σ_i são únicos: derivam dos autovalores de A^H A, que são únicos até multiplicidade.",
                                    "Note que σ_i = sqrt(λ_i) onde λ_i são autovalores de A^H A, ordenados σ_1 ≥ σ_2 ≥ ... ≥ 0.",
                                    "Discuta multiplicidade: mesmo com σ_i = σ_j, os valores em si são idênticos e únicos como conjunto.",
                                    "Verifique com exemplo: compute SVD de matrizes com autovalores conhecidos.",
                                    "Registre que a ordenação não-crescente garante unicidade na diagonal de Σ."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que os σ_i são sempre únicos, independentemente da matriz A.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Folha de papel para provas",
                                    "Exemplos de matrizes em Python ou MATLAB",
                                    "Referência teórica (ex: Golub & Van Loan)"
                                  ],
                                  "tips": "Lembre-se: autovalores têm multiplicidade, mas valores singulares são definidos positivamente e ordenados.",
                                  "learningObjective": "Dominar a unicidade intrínseca dos valores singulares como primeiro pilar do teorema.",
                                  "commonMistakes": [
                                    "Pensar que multiplicidade afeta unicidade dos valores",
                                    "Confundir ordenação crescente vs. não-crescente",
                                    "Esquecer normalização positiva dos σ_i"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a unicidade das colunas de U e V para σ_i distintos",
                                  "subSteps": [
                                    "Entenda para σ_i > σ_j: colunas u_i e v_i são únicas até sinal (u_i ou -u_i, similar para v_i).",
                                    "Razão: equações de autovetores normalizados permitem flip de sinal.",
                                    "Verifique: se A v_i = σ_i u_i, então A (-v_i) = σ_i (-u_i) preserva SVD.",
                                    "Discuta subespaços: para σ_i distintos, os vetores singulares definem direções únicas.",
                                    "Pratique com matriz diagonal: SVD é quase identidade, flips de sinal evidentes."
                                  ],
                                  "verification": "Dado um σ_i distinto, descreva as possíveis variações em U e V e demonstre com um exemplo numérico.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Software computacional para SVD múltiplas execuções",
                                    "Matrizes de teste com σ_i distintos"
                                  ],
                                  "tips": "Sempre normalize vetores unitários; sinal é convenção arbitrária em algoritmos.",
                                  "learningObjective": "Compreender a unicidade condicional às convenções de sinal para singular values distintos.",
                                  "commonMistakes": [
                                    "Ignorar o 'até sinal'",
                                    "Confundir com unicidade absoluta das matrizes",
                                    "Aplicar a casos de multiplicidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Abordar o caso de singular values iguais (σ_i = σ_j) e formular o teorema completo",
                                  "subSteps": [
                                    "Para σ_i = σ_j > 0: subespaços coluna correspondentes em U e V são únicos (ortogonais entre blocos).",
                                    "Dentro do bloco de multiplicidade, bases são únicas até ortogonalidade e sinais.",
                                    "Enuncie completo: σ_i únicos; para distintos, colunas únicas até sinal; para iguais, subespaços únicos.",
                                    "Memorize formulação precisa: 'Os valores singulares são únicos; as colunas de U e V correspondentes a σ_i distintos são únicas até um fator de sinal; para σ_i = σ_j, os subespaços são únicos.'",
                                    "Teste enunciação em voz alta e escreva 3 vezes."
                                  ],
                                  "verification": "Recite o teorema completo sem olhar notas e aplique a um exemplo com multiplicidade.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Flashcards para memorização",
                                    "Matriz com σ_i repetidos (ex: identidade bloqueada)"
                                  ],
                                  "tips": "Use mnemônicos: 'σ único, colunas até sinal, subespaços para iguais'.",
                                  "learningObjective": "Formular e internalizar o enunciado exato do teorema de unicidade da SVD.",
                                  "commonMistakes": [
                                    "Esquecer subespaços para multiplicidade",
                                    "Trocar U/V ou esquerdos/direitos",
                                    "Omitir 'até sinal' ou ordenação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[3,0],[0,1]], SVD é U = I, Σ = diag(3,1), V = I (até sinais). Mudando sinais em colunas de U e V correspondentes mantém A = U Σ V^T, ilustrando unicidade até sinal para σ_1=3 ≠ σ_2=1.",
                              "finalVerifications": [
                                "Recitar corretamente que σ_i são únicos.",
                                "Explicar unicidade das colunas de U e V até sinal para σ_i distintos.",
                                "Descrever subespaços únicos para σ_i = σ_j.",
                                "Aplicar o teorema a uma SVD computada.",
                                "Identificar erros em um enunciado incompleto.",
                                "Diferenciar de unicidade em eigen decomposição."
                              ],
                              "assessmentCriteria": [
                                "Precisão verbatim no enunciado do teorema (100% match).",
                                "Compreensão conceitual via explicação de provas intuitivas.",
                                "Aplicação correta a exemplos numéricos simples e com multiplicidade.",
                                "Identificação de casos especiais (σ_i=0, rank deficient).",
                                "Clareza na distinção entre valores, colunas e subespaços.",
                                "Capacidade de discutir implicações computacionais."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: estabilidade e algoritmos de SVD (Golub-Kahan).",
                                "Machine Learning: unicidade em PCA e redução dimensional.",
                                "Processamento de Imagens: compressão JPEG via SVD única.",
                                "Física Computacional: modais em mecânica quântica.",
                                "Estatística: análise de componentes principais."
                              ],
                              "realWorldApplication": "Em sistemas de recomendação (Netflix), SVD reduz dimensionalidade de matrizes usuário-item; unicidade garante que reconstruções sejam consistentes across implementações, evitando ambiguidades em perfis de usuários."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.2.2",
                            "name": "Demonstrar não-unicidade por ambiguidade de sinal",
                            "description": "Construir exemplo de matriz 2x2 com SVD não única, mostrando que U e V podem ser multiplicados por matrizes de sinal diagonal sem alterar A = UΣVᵀ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os fundamentos da Decomposição em Valores Singulares (SVD)",
                                  "subSteps": [
                                    "Lembre-se da forma padrão da SVD: A = U Σ Vᵀ, onde U e V são ortogonais e Σ é diagonal com valores singulares não-negativos.",
                                    "Entenda que para matrizes 2x2, U e V são matrizes 2x2 ortogonais.",
                                    "Discuta por que a SVD é única em termos de Σ, mas U e V podem não ser.",
                                    "Identifique fontes de não-unicidade, como rotações e sinais."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a equação SVD e liste duas razões potenciais para não-unicidade.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora ou software como Python (NumPy) ou MATLAB"
                                  ],
                                  "tips": "Use diagramas para visualizar U girando colunas e V girando linhas.",
                                  "learningObjective": "Compreender a estrutura da SVD e identificar limitações de unicidade.",
                                  "commonMistakes": [
                                    "Confundir SVD com autovalores",
                                    "Esquecer que Σ tem valores não-negativos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir e computar SVD de uma matriz 2x2 simples",
                                  "subSteps": [
                                    "Escolha a matriz A = [[3, 0], [0, 1]].",
                                    "Calcule os valores singulares: σ1 = 3, σ2 = 1.",
                                    "Encontre U e V iniciais: U = I, Σ = diag(3,1), V = I.",
                                    "Verifique A = U Σ Vᵀ.",
                                    "Registre a decomposição exata."
                                  ],
                                  "verification": "Mostre o cálculo manual ou output do software confirmando A = U Σ Vᵀ.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Software NumPy/Python ou MATLAB",
                                    "Papel para cálculos manuais"
                                  ],
                                  "tips": "Para matrizes diagonais, SVD é trivial; use np.linalg.svd() para automação.",
                                  "learningObjective": "Executar SVD computacionalmente em uma matriz 2x2.",
                                  "commonMistakes": [
                                    "Esquecer o transposto em Vᵀ",
                                    "Usar valores singulares negativos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir ambiguidade de sinal com matrizes de sinal diagonal",
                                  "subSteps": [
                                    "Defina matriz de sinal S1 = diag(1, -1).",
                                    "Crie U' = U S1 e V' = V S1.",
                                    "Note que S1ᵀ S1 = I, preservando ortogonalidade.",
                                    "Mostre que U' Σ (V')ᵀ = U S1 Σ S1ᵀ Vᵀ = U Σ Vᵀ = A, pois S1 Σ S1ᵀ = Σ (sinais cancelam).",
                                    "Repita com S2 = diag(-1, 1) para outra variação."
                                  ],
                                  "verification": "Calcule U', V', Σ e confirme A = U' Σ (V')ᵀ numericamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software para multiplicação de matrizes",
                                    "Papel para derivação algébrica"
                                  ],
                                  "tips": "Lembre-se: multiplicar U e V pelo mesmo S preserva A devido à compensação de sinais.",
                                  "learningObjective": "Demonstrar matematicamente como sinais ambíguos geram SVDs equivalentes.",
                                  "commonMistakes": [
                                    "Multiplicar U e V por S diferentes sem compensação",
                                    "Ignorar que Σ é diagonal positivo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e generalizar a não-unicidade por ambiguidade de sinal",
                                  "subSteps": [
                                    "Compare as múltiplas SVDs: original, com S1 e com S2.",
                                    "Discuta que há 4 SVDs possíveis para rank 2 (2^2 combinações de sinais).",
                                    "Teste com outra matriz 2x2 não-diagonal, ex: A = [[1,1],[1,1]].",
                                    "Conclua que Σ é único, mas U,V têm liberdade de sinal.",
                                    "Documente todas as decomposições equivalentes."
                                  ],
                                  "verification": "Liste pelo menos duas SVDs diferentes que produzem a mesma A e verifique numericamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Software NumPy/Python",
                                    "Planilha para comparações"
                                  ],
                                  "tips": "Use tolerância numérica (1e-10) para verificar igualdade devido a erros de ponto flutuante.",
                                  "learningObjective": "Generalizar a ambiguidade de sinal para qualquer SVD 2x2 de rank cheio.",
                                  "commonMistakes": [
                                    "Achar que todas as não-unicidades são só sinais",
                                    "Confundir com fases complexas em SVD complexa"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[3,0],[0,1]], SVD original: U=I, Σ=diag(3,1), V=I. Nova: U'=diag(1,-1), V'=diag(1,-1), então U'Σ(V')ᵀ = diag(1,-1) diag(3,1) diag(1,-1) = diag(3,1) = A.",
                              "finalVerifications": [
                                "Pelo menos duas SVDs diferentes (U,V) produzem a mesma A.",
                                "Σ permanece idêntico em todas as variantes.",
                                "U' e V' são ortogonais (U'U'=I, V'V'=I).",
                                "Cálculo numérico confirma ||A - U'Σ(V')ᵀ|| < 1e-10.",
                                "Explicação algébrica mostra cancelamento de sinais."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática na derivação da ambiguidade (100%).",
                                "Número e variedade de exemplos SVDs gerados (pelo menos 2).",
                                "Verificação numérica precisa sem erros de arredondamento.",
                                "Explicação clara da preservação de A apesar de mudanças em U,V.",
                                "Generalização para SVDs genéricas 2x2.",
                                "Uso adequado de notação matricial (ᵀ, diag)."
                              ],
                              "crossCurricularConnections": [
                                "Ciência de Dados: Normalização de sinais em PCA/SVD para análise de componentes principais.",
                                "Processamento de Imagens: Flip de sinais em compressão JPEG sem perda perceptível.",
                                "Física Computacional: Modelagem de vibrações onde fases/signos são ambíguos.",
                                "Programação: Implementação robusta de SVD em bibliotecas como SciPy."
                              ],
                              "realWorldApplication": "Em reconhecimento facial ou compressão de imagens via SVD, múltiplas representações (devido a sinais) são equivalentes; algoritmos escolhem convenções (ex: primeiros elementos positivos) para padronizar, evitando ambiguidades em pipelines de ML."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.2.3",
                            "name": "Analisar unicidade em singularidades múltiplas",
                            "description": "Provar que para valores singulares distintos, as colunas associadas de U e V são únicas até sinal, usando propriedades de autovetores de AᵀA e AAᵀ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Fundamentais de SVD e Autovalores Associados",
                                  "subSteps": [
                                    "Defina a decomposição SVD de uma matriz A m×n como A = U Σ Vᵀ, onde U e V são ortogonais e Σ é diagonal com valores singulares σ_i ≥ 0.",
                                    "Explique que os valores singulares σ_i são as raízes quadradas dos autovalores de AᵀA (para V) e AAᵀ (para U).",
                                    "Verifique que AᵀA V = V (Σᵀ Σ) e AAᵀ U = U (Σ Σᵀ), confirmando que colunas de V e U são autovetores.",
                                    "Liste propriedades chave: autovalores de AᵀA são σ_i², ordenados decrescentemente.",
                                    "Pratique com uma matriz simples para computar SVD manualmente."
                                  ],
                                  "verification": "Escreva as equações AᵀA V = V Λ e AAᵀ U = U Γ, com Λ = diag(σ_i²), e confirme com um exemplo 2×2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Álgebra Linear (ex: Strang), calculadora ou Python/NumPy para SVD.",
                                  "tips": "Sempre comece pelas definições para ancorar a prova; visualize geometricamente como rotações e escalas.",
                                  "learningObjective": "Compreender a conexão exata entre SVD e problemas de autovalores de AᵀA e AAᵀ.",
                                  "commonMistakes": "Confundir dimensões de U (m×m) e V (n×n); esquecer que σ_i são não-negativos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estabelecer Unicidade de Autovetores para Autovalores Distintos em AᵀA",
                                  "subSteps": [
                                    "Lembre o teorema: em matrizes simétricas (como AᵀA), autovetores correspondentes a autovalores distintos são ortogonais.",
                                    "Prove que o eigenspace para um autovalor simples (multiplicidade 1) é 1-dimensional, logo autovetor único até escalar.",
                                    "Como σ_i distintos implicam λ_i = σ_i² distintos (pois f(x)=x² injetiva para x≥0), colunas de V são únicas até escalar.",
                                    "Normalize para comprimento unitário: únicas até sinal (±).",
                                    "Verifique ortogonalidade: v_iᵀ v_j = 0 para i≠j."
                                  ],
                                  "verification": "Esboce a prova de unicidade do eigenspace e aplique a AᵀA; teste com autovalores numéricos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Notas de aula sobre teoria espectral, software para diagonalizar AᵀA.",
                                  "tips": "Use o fato de que AᵀA é simétrica positiva-semidefinida para invocar teoremas padrão.",
                                  "learningObjective": "Dominar a unicidade de autovetores para autovalores simples em contextos simétricos.",
                                  "commonMistakes": "Ignorar que multiplicidade algébrica=geométrica para autovalores distintos; confundir com autovalores múltiplos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estender a Análise para Colunas de U via AAᵀ",
                                  "subSteps": [
                                    "Repita o argumento para AAᵀ: autovalores σ_i² (com zeros extras se m>n), colunas de U como autovetores.",
                                    "Para σ_i >0 distintos, os autovetores associados em AAᵀ são únicos até sinal, alinhando com U.",
                                    "Note que U e V estão ligados por u_i = (1/σ_i) A v_i, preservando unicidade até sinal.",
                                    "Confirme consistência: mudança de sinal em v_i requer mudança em u_i para manter A.",
                                    "Discuta implicações para singularidades múltiplas: foco em σ_i distintos."
                                  ],
                                  "verification": "Derive u_i a partir de v_i e verifique AᵀA v_i = σ_i² v_i implica AAᵀ u_i = σ_i² u_i.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Matriz exemplo com singularidades distintas, MATLAB/Python para verificar.",
                                  "tips": "Mantenha rastreamento das relações u_i = A v_i / σ_i para ligar U e V.",
                                  "learningObjective": "Conectar explicitamente unicidade em U e V através da relação SVD.",
                                  "commonMistakes": "Esquecer zeros em Σ para retangular; assumir simetria idêntica sem ajustar dimensões."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e Verificar a Prova Completa de Unicidade até Sinal",
                                  "subSteps": [
                                    "Enuncie o teorema: Para σ_i ≠ σ_j, u_i e v_i são únicos até sinal em suas famílias ortonormais.",
                                    "Combine Steps 1-3 em uma prova coesa, destacando independência de autovalores distintos.",
                                    "Aborde mudança de sinal: Se V' = V D (D diagonal ±1), então U' = U D preserva SVD.",
                                    "Teste numericamente com perturbações para ver estabilidade.",
                                    "Generalize para multiplicidade >1 (não único, mas aqui foco em distintos)."
                                  ],
                                  "verification": "Escreva prova formal de 1 página e valide com contraexemplo para σ_i iguais.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Papel para prova, Jupyter notebook para simulações SVD.",
                                  "tips": "Estruture prova como: Definições → Propriedades → Unicidade → Conclusão.",
                                  "learningObjective": "Sintetizar prova rigorosa de unicidade em SVD para singular values distintos.",
                                  "commonMistakes": "Não mencionar 'até sinal'; confundir unicidade com ortogonalidade."
                                }
                              ],
                              "practicalExample": "Considere A = [[3,0],[0,2]], SVD: σ1=3, σ2=2 distintos. AᵀA = diag(9,4), autovetores e1,e2 únicos até sinal. Similar para AAᵀ. Perturbe sinais e verifique A = U Σ Vᵀ ainda vale.",
                              "finalVerifications": [
                                "Pode derivar corretamente AᵀA v_i = σ_i² v_i e AAᵀ u_i = σ_i² u_i.",
                                "Explica unicidade do eigenspace 1D para autovalores simples.",
                                "Demonstra preservação de SVD sob mudança de sinal em pares u_i, v_i.",
                                "Identifica erro em caso de σ_i = σ_j (não único).",
                                "Valida numericamente com matriz 3×2 de rank 2.",
                                "Escreve prova concisa sem gaps lógicos."
                              ],
                              "assessmentCriteria": [
                                "Clareza e precisão na derivação das relações autovetor-SVD (30%).",
                                "Correto uso de teoremas espectrais para unicidade (25%).",
                                "Tratamento adequado de normalização e sinais (20%).",
                                "Exemplos numéricos de suporte (15%).",
                                "Conexão explícita entre U, V e singular values distintos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Ciência de Computação: Estabilidade numérica em algoritmos SVD (ex: LAPACK).",
                                "Física: Autovalores em mecânica quântica (observáveis hermitianos análogos a AᵀA).",
                                "Estatística: PCA via SVD, unicidade em componentes principais.",
                                "Engenharia: Análise modal em vibrações (modos únicos para frequências distintas)."
                              ],
                              "realWorldApplication": "Em compressão de imagens via SVD truncada (JPEG2000), unicidade até sinal garante consistência em reconstruções aproximadas, essencial para processamento estável em visão computacional e recomendação (Netflix usa SVD low-rank)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.3",
                        "name": "Relação da SVD com Normas e Número de Condição",
                        "description": "Exploração das conexões algébricas entre os valores singulares e as normas induzidas de matriz (especialmente norma 2), pseudoinversa e número de condição κ₂(A) = σ₁/σ_min.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.3.1",
                            "name": "Derivar norma espectral via SVD",
                            "description": "Provar que a norma 2 de A é ||A||₂ = σ₁, o maior valor singular, e demonstrar com desigualdade σ₁ = max_{||x||=1} ||Ax||₂.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Fundamentais de Norma Espectral e Decomposição SVD",
                                  "subSteps": [
                                    "Defina a norma espectral (ou norma 2) de uma matriz A como ||A||₂ = sup_{x ≠ 0} ||Ax||₂ / ||x||₂, equivalente a max_{||x||₂=1} ||Ax||₂.",
                                    "Explique que esta norma é o maior valor próprio em módulo da matriz A*A ou AA*.",
                                    "Lembre a decomposição SVD: Para A m×n, A = U Σ V^H, onde Σ é diagonal com valores singulares σ₁ ≥ σ₂ ≥ ... ≥ σ_r ≥ 0.",
                                    "Identifique σ₁ como o maior valor singular de A.",
                                    "Discuta propriedades: U e V são unitárias, preservam normas euclidianas."
                                  ],
                                  "verification": "Escreva as definições exatas e identifique σ₁ em uma SVD exemplo simples.",
                                  "estimatedTime": "20 min",
                                  "materials": [
                                    "Notas de Álgebra Linear Computacional",
                                    "Calculadora ou software como MATLAB/Python (NumPy)"
                                  ],
                                  "tips": "Visualize a norma como alongamento máximo da elipse unitária por A.",
                                  "learningObjective": "Dominar definições precisas para base da derivação.",
                                  "commonMistakes": [
                                    "Confundir norma 2 com norma de Frobenius (√(soma σ_i²))",
                                    "Esquecer que SVD usa valores singulares não negativos",
                                    "Ignorar que normas são preservadas por unitárias"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Expressar ||Ax||₂ Usando a Decomposição SVD",
                                  "subSteps": [
                                    "Substitua A = U Σ V^H em ||Ax||₂ para ||x||₂=1.",
                                    "Compute ||Ax||₂ = ||U Σ V^H x||₂; como U e V^H unitárias, ||U Σ V^H x||₂ = ||Σ y||₂ onde y = V^H x e ||y||₂=1.",
                                    "Expresse ||Σ y||₂ = √(∑ σ_i² |y_i|²) ≤ σ₁ √(∑ |y_i|²) = σ₁, pela máxima σ₁.",
                                    "Mostre igualdade quando y é vetor unitário no primeiro componente (e_i com i=1).",
                                    "Conclua que max_{||x||=1} ||Ax||₂ ≤ σ₁."
                                  ],
                                  "verification": "Derive a desigualdade ||Ax||₂ ≤ σ₁ para ||x||₂=1, anotando passos.",
                                  "estimatedTime": "25 min",
                                  "materials": [
                                    "Papel e lápis para derivações",
                                    "Exemplo matriz 2x2 pré-computada SVD"
                                  ],
                                  "tips": "Use propriedades ||Uz||=||z|| para simplificar normas intermediárias.",
                                  "learningObjective": "Conectar SVD diretamente à norma via transformação unitária.",
                                  "commonMistakes": [
                                    "Esquecer que ||U z||₂ = ||z||₂ apenas se U unitária",
                                    "Não normalizar y corretamente",
                                    "Confundir ||Σ y||₂ com max σ_i |y_i| em vez de norma euclidiana"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar a Igualdade ||A||₂ = σ₁ via Vetor Diretor",
                                  "subSteps": [
                                    "Identifique o vetor singular direito v₁ (primeira coluna de V) com ||v₁||₂=1.",
                                    "Compute Ax para x = v₁: A v₁ = U Σ V^H v₁ = U Σ e₁ = σ₁ u₁, onde u₁ primeira coluna de U.",
                                    "Verifique ||A v₁||₂ = ||σ₁ u₁||₂ = σ₁ ||u₁||₂ = σ₁.",
                                    "Como ||v₁||₂=1, max_{||x||=1} ||Ax||₂ ≥ σ₁.",
                                    "Combine com desigualdade anterior: max = σ₁, logo ||A||₂ = σ₁."
                                  ],
                                  "verification": "Construa prova completa mostrando ≥ e ≤, confirmando igualdade.",
                                  "estimatedTime": "30 min",
                                  "materials": [
                                    "Software para SVD (ex: numpy.linalg.svd)",
                                    "Matriz teste como A = [[1,2],[3,4]]"
                                  ],
                                  "tips": "Verifique numericamente: compute SVD e norma 2 via np.linalg.norm(A,2).",
                                  "learningObjective": "Completar prova bidirecional usando vetores singulares.",
                                  "commonMistakes": [
                                    "Usar v errado (não o primeiro)",
                                    "Esquecer normalização de u₁/v₁",
                                    "Não mostrar explicitamente A v₁ = σ₁ u₁"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Generalizar com Exemplos Numéricos",
                                  "subSteps": [
                                    "Escolha matriz A, compute SVD para obter σ₁.",
                                    "Calcule ||A||₂ diretamente via max ||Ax|| ou np.linalg.norm.",
                                    "Teste com x = v₁ e confirme ||Ax||₂ = σ₁.",
                                    "Generalize para matrizes não quadradas e retangular.",
                                    "Discuta implicações para número de condição κ₂(A) = σ₁/σ_min."
                                  ],
                                  "verification": "Para matriz dada, mostrar numericamente σ₁ ≈ ||A||₂ com erro <1e-10.",
                                  "estimatedTime": "25 min",
                                  "materials": [
                                    "Python/Jupyter com NumPy/SciPy",
                                    "Matrizes exemplos variadas"
                                  ],
                                  "tips": "Use ord=2 em np.linalg.norm para norma espectral.",
                                  "learningObjective": "Validar teorema computacionalmente e estender conceitos.",
                                  "commonMistakes": [
                                    "Erro numérico por precisão flutuante (use tolerância)",
                                    "Testar apenas matrizes diagonais triviais",
                                    "Ignorar casos rank-deficientes onde σ_r=0"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[3, 0], [0, 2]], SVD dá Σ = diag(3,2), σ₁=3. Vetor v₁=[1,0], A v₁=[3,0], ||A v₁||₂=3. Norma 2 computada: max alongamento é 3. Em Python: import numpy as np; A=np.array([[3,0],[0,2]]); print(np.linalg.norm(A,2)) → 3.0.",
                              "finalVerifications": [
                                "Prova escrita completa bidirecional: ||Ax||₂ ≤ σ₁ e igualdade em v₁.",
                                "Cálculo numérico para 2 matrizes diferentes confirmando σ₁ = ||A||₂.",
                                "Explicação verbal da intuição geométrica (alongamento máximo).",
                                "Generalização para A retangular m×n.",
                                "Conexão com número de condição κ(A)=σ₁/σ_min.",
                                "Identificação de erros comuns em derivação."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática rigorosa na prova (bidirecional).",
                                "Clareza e organização dos passos/subpassos.",
                                "Precisão numérica em exemplos (erro <1e-12).",
                                "Uso correto de notação (||.||₂, σ₁, U,V).",
                                "Profundidade em generalizações e conexões.",
                                "Identificação proativa de pitfalls comuns."
                              ],
                              "crossCurricularConnections": [
                                "Computação Numérica: Estabilidade da SVD para cálculo de normas (QR vs SVD).",
                                "Machine Learning: SVD em PCA/redução dimensional; norma mede Lipschitz constante.",
                                "Engenharia de Controle: Análise de estabilidade sistemas lineares via normas.",
                                "Física Computacional: Simulações quânticas (matrizes densidade hermitianas).",
                                "Otimização: Dualidade em problemas ||Ax - b|| minimização."
                              ],
                              "realWorldApplication": "Em sistemas de recomendação (Netflix), SVD aproxima matrizes usuário-item; ||A||₂=σ₁ quantifica sensibilidade a perturbações de dados, essencial para robustez em grandes escalas e compressão de imagens/JPEG via truncada SVD."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.3.2",
                            "name": "Calcular número de condição usando SVD",
                            "description": "Computar κ₂(A) = σ_max / σ_min a partir da SVD e interpretar seu significado para sensibilidade de sistemas lineares Ax = b.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Realizar a Decomposição em Valores Singulares (SVD) da Matriz A",
                                  "subSteps": [
                                    "Selecione uma matriz A quadrada ou retangular adequada para análise (ex: 2x2 ou 3x3).",
                                    "Utilize uma biblioteca computacional como NumPy em Python (numpy.linalg.svd(A, compute_uv=True)) ou svd() no MATLAB.",
                                    "Extraia as matrizes U, Σ (vetor de valores singulares) e Vh da decomposição.",
                                    "Verifique se a reconstrução A ≈ U @ diag(Σ) @ Vh está correta dentro de tolerância numérica (ex: ||A - U@Σ@Vh|| < 1e-10).",
                                    "Ordene os valores singulares em ordem decrescente se necessário."
                                  ],
                                  "verification": "Confirme que a SVD reconstrói A com erro residual mínimo (norma Frobenius < 1e-12).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com NumPy",
                                    "Matriz A de exemplo",
                                    "Jupyter Notebook ou MATLAB"
                                  ],
                                  "tips": "Sempre use full_matrices=False para eficiência em matrizes não quadradas; normalize A se necessário para evitar overflow.",
                                  "learningObjective": "Dominar o processo computacional de obter a SVD de uma matriz.",
                                  "commonMistakes": [
                                    "Confundir ordem dos valores singulares (não ordenados)",
                                    "Ignorar o modo de computação (econômico vs full)",
                                    "Erro na reconstrução devido a slicing incorreto em Σ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar os Valores Singulares Máximo e Mínimo",
                                  "subSteps": [
                                    "Extraia o vetor Σ da SVD, que contém os valores singulares σ_i em ordem decrescente.",
                                    "Identifique σ_max como o primeiro elemento Σ[0] e σ_min como o último elemento não-zero Σ[-1].",
                                    "Ignore valores singulares próximos de zero (use tolerância 1e-12 * σ_max para rank).",
                                    "Registre os valores: ex. σ_max = 1.0, σ_min = 0.001.",
                                    "Plote o espectro singular (semilogarítmico) para visualização."
                                  ],
                                  "verification": "Liste σ_max e σ_min explicitamente e confirme σ_max >= σ_min > 0.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código Python/ MATLAB da SVD",
                                    "Ferramenta de plotagem (matplotlib)"
                                  ],
                                  "tips": "Use np.max(Σ) e np.min(Σ[Σ > 1e-12 * np.max(Σ)]) para robustez numérica.",
                                  "learningObjective": "Extrair e validar os valores singulares relevantes da SVD.",
                                  "commonMistakes": [
                                    "Considerar σ_min = 0 para matrizes rank-deficientes sem tolerância",
                                    "Não ordenar Σ",
                                    "Confundir Σ com autovalores"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Número de Condição Espectral κ₂(A)",
                                  "subSteps": [
                                    "Defina a fórmula κ₂(A) = σ_max / σ_min.",
                                    "Compute numericamente: kappa = Σ[0] / Σ[-1].",
                                    "Registre o valor: ex. κ₂(A) = 1000.",
                                    "Compare com normas: confirme κ₂(A) ≈ ||A||₂ * ||A⁻¹||₂ para A quadrada invertível.",
                                    "Avalie o regime: κ < 10² bem condicionado, > 10⁶ mal condicionado."
                                  ],
                                  "verification": "Cálculo exato coincide com função built-in como np.linalg.cond(A, p=2).",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Código da SVD",
                                    "Função np.linalg.cond para validação"
                                  ],
                                  "tips": "Log10(κ) é mais intuitivo para grandes valores; evite divisão por zero checando σ_min > eps.",
                                  "learningObjective": "Aplicar a fórmula do número de condição via SVD.",
                                  "commonMistakes": [
                                    "Usar σ_min = 0 levando a ∞",
                                    "Confundir com outras normas (1, ∞)",
                                    "Não validar com cond built-in"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar o Número de Condição para Sensibilidade em Ax = b",
                                  "subSteps": [
                                    "Explique: κ₂(A) amplifica erros relativos: ||δx||/||x|| ≤ κ₂(A) * (||δb||/||b|| + ||δA||/||A||).",
                                    "Teste numericamente: perturbe b e A por 1e-6 e observe amplificação em x.",
                                    "Classifique: baixo κ → estável; alto κ → sensível (ill-conditioned).",
                                    "Discuta implicações: pré-condicionamento ou refinamento iterativo para mitigação.",
                                    "Relacione com geometria: σ_min pequeno indica direção sensível."
                                  ],
                                  "verification": "Demonstre com perturbação que erro em x é ~κ vezes erro em b.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código para solver Ax=b (np.linalg.solve)",
                                    "Exemplo de perturbação"
                                  ],
                                  "tips": "Use relative error plots para visualização; considere pseudoinversa para rank-deficient.",
                                  "learningObjective": "Compreender e demonstrar a interpretação prática do número de condição.",
                                  "commonMistakes": [
                                    "Ignorar amplificação relativa",
                                    "Confundir sensibilidade em A vs b",
                                    "Não testar numericamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[1, 0], [0, 0.001]], SVD dá Σ = [1.0, 0.001], κ₂(A) = 1000. Resolvendo Ax = b com b = [1, 0.001], x = [1, 1]. Perturbe b por 1e-6 em segunda componente: δx/x ≈ 1000 * 1e-6, demonstrando alta sensibilidade.",
                              "finalVerifications": [
                                "SVD correta com reconstrução precisa.",
                                "σ_max e σ_min identificados corretamente.",
                                "κ₂(A) calculado e validado com np.linalg.cond.",
                                "Interpretação escrita: relação com erro relativo em Ax=b.",
                                "Teste numérico de sensibilidade com perturbações.",
                                "Classificação qualitativa do condicionamento."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica no cálculo de SVD e κ (erro < 1e-10).",
                                "Correta identificação e ordenação de valores singulares.",
                                "Fórmula κ₂(A) aplicada sem erros aritméticos.",
                                "Interpretação física/matemática precisa da sensibilidade.",
                                "Demonstração prática com exemplo numérico e plots.",
                                "Tratamento robusto de casos edge (σ_min pequeno)."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Estabilidade de algoritmos de solve linear.",
                                "Engenharia de Controle: Análise de estabilidade de sistemas dinâmicos.",
                                "Machine Learning: Condição de matrizes em PCA e regressão.",
                                "Física Computacional: Simulações de PDEs com discretização matricial.",
                                "Otimização: Sensibilidade em métodos quasi-Newton."
                              ],
                              "realWorldApplication": "Em computação científica, como simulações CFD ou finanças (modelos de risco), alto κ₂(A) indica necessidade de regularização ou refinamento para evitar propagação de erros de arredondamento em solvers de grandes sistemas lineares Ax=b."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.3.3",
                            "name": "Relacionar com pseudoinversa e normas",
                            "description": "Mostrar que a pseudoinversa A⁺ tem SVD com valores 1/σ_i para σ_i > 0, e derivar ||A⁺||₂ = 1/σ_min, ligando à análise de sensibilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar SVD e Definição da Pseudoinversa",
                                  "subSteps": [
                                    "Lembre-se da decomposição SVD: A = U Σ V^T, onde Σ é diagonal com σ_i ≥ 0 em ordem decrescente.",
                                    "Defina a pseudoinversa de Moore-Penrose A⁺ como a matriz que minimiza ||Ax - b||_2 para soluções de mínimos quadrados.",
                                    "Estabeleça a fórmula explícita: A⁺ = V Σ⁺ U^T, onde Σ⁺ tem 1/σ_i para σ_i > 0 e zeros nos demais.",
                                    "Verifique com uma matriz simples 2x2 rank-deficient para intuitar.",
                                    "Anote as propriedades: A A⁺ A = A e simétricas."
                                  ],
                                  "verification": "Escreva a SVD de A e construa Σ⁺ corretamente para uma matriz exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, calculadora matricial ou Python (NumPy)",
                                  "tips": "Sempre ordene σ_i decrescente para evitar confusões nos índices.",
                                  "learningObjective": "Compreender a relação fundamental entre SVD de A e sua pseudoinversa.",
                                  "commonMistakes": "Confundir Σ⁺ com Σ^{-1} sem truncar zeros; inverter U e V."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Forma SVD da Pseudoinversa A⁺",
                                  "subSteps": [
                                    "Partindo de A = U Σ V^T, substitua na fórmula A⁺ = V Σ⁺ U^T.",
                                    "Mostre que Σ⁺ é diagonal com entradas 1/σ_i para i onde σ_i > 0, e 0 caso contrário.",
                                    "Verifique que A⁺ = V Σ⁺ U^T é a SVD de A⁺, com valores singulares 1/σ_i (para σ_i > 0).",
                                    "Confirme que os vetores singulares esquerdos de A⁺ são as colunas de V e direitos de U.",
                                    "Calcule explicitamente para uma matriz A = [[1,0],[0,0]] para validar."
                                  ],
                                  "verification": "Escreva a SVD completa de A⁺ e liste seus valores singulares como 1/σ_i.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software NumPy/MATLAB para SVD, quadro branco",
                                  "tips": "Use notação matricial para manter clareza; visualize Σ como uma 'inversão seletiva'.",
                                  "learningObjective": "Derivar explicitamente a SVD da pseudoinversa a partir da SVD de A.",
                                  "commonMistakes": "Esquecer de truncar σ_i = 0 em Σ⁺; inverter os papéis de U e V na SVD de A⁺."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Norma 2 da Pseudoinversa ||A⁺||₂",
                                  "subSteps": [
                                    "Lembre que para qualquer matriz, ||B||₂ = maior valor singular de B (σ_max(B)).",
                                    "Para A⁺, os valores singulares são 1/σ_i (σ_i > 0), então σ_max(A⁺) = 1/σ_min(A), onde σ_min(A) é o menor σ_i > 0.",
                                    "Derive ||A⁺||₂ = max ||A⁺ x||_2 / ||x||_2 = 1 / σ_min(A).",
                                    "Prove usando o fato de que ||A⁺||₂ = sup_{||x||=1} ||A⁺ x||₂.",
                                    "Teste numericamente com uma matriz ill-conditioned."
                                  ],
                                  "verification": "Derive algebricamente ||A⁺||₂ = 1/σ_min(A) e confirme com exemplo numérico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python com svdvals() do NumPy, exemplos de matrizes",
                                  "tips": "Foquem no menor σ_i não-zero; use reciprocals para sensibilidade.",
                                  "learningObjective": "Estabelecer a relação direta entre norma da pseudoinversa e menor valor singular de A.",
                                  "commonMistakes": "Usar σ_max(A) ao invés de σ_min(A); ignorar singularidades (σ_min=0 implica ||A⁺||₂=∞)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ligar à Análise de Sensibilidade e Número de Condição",
                                  "subSteps": [
                                    "Defina o número de condição κ₂(A) = ||A||₂ ||A⁺||₂ = σ_max(A) / σ_min(A).",
                                    "Explique que ||A⁺||₂ grande (σ_min pequeno) implica alta sensibilidade em soluções de mínimos quadrados.",
                                    "Discuta implicações: pequenos erros em b amplificam em x⁺ = A⁺ b por fator ~1/σ_min.",
                                    "Compare com sistemas quadrados: sensibilidade similar via κ(A).",
                                    "Aplique a um exemplo de regressão linear ruidosa."
                                  ],
                                  "verification": "Explique verbalmente como ||A⁺||₂ afeta a estabilidade numérica e cite κ₂(A).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Gráficos de erro amplificado (Matplotlib), artigos sobre conditioning",
                                  "tips": "Pense em termos de 'amplificação de ruído': 1/σ_min é o ganho máximo.",
                                  "learningObjective": "Conectar normas e pseudoinversa à análise de sensibilidade em problemas lineares.",
                                  "commonMistakes": "Confundir sensibilidade de A com A⁺; ignorar que κ(A) = κ(A⁺)."
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 0.1], [0.1, 1]] (ill-conditioned). SVD dá σ1≈1.105, σ2≈0.995. Então A⁺ tem σ⁺1≈0.905, σ⁺2≈1.005, ||A⁺||₂≈1.005=1/σ_min. Simule x⁺ = A⁺ b com b ruidoso para ver amplificação ~1/σ_min.",
                              "finalVerifications": [
                                "Deriva corretamente SVD de A⁺ com valores 1/σ_i.",
                                "Calcula ||A⁺||₂ = 1/σ_min(A) para matriz dada.",
                                "Explica ligação com κ₂(A) = ||A||₂ ||A⁺||₂.",
                                "Identifica sensibilidade em exemplo numérico.",
                                "Aplica a um problema de least squares real.",
                                "Discute casos σ_min→0 (não-invertível)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação SVD de A⁺ (100% correto).",
                                "Correta identificação de ||A⁺||₂ como 1/σ_min.",
                                "Explicação clara de sensibilidade com exemplo quantitativo.",
                                "Uso apropriado de notação matricial e SVD.",
                                "Conexão explícita com número de condição κ₂.",
                                "Tratamento de casos rank-deficient."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Sensibilidade em regressão linear e PCA.",
                                "Engenharia: Estabilidade em controle de sistemas e processamento de sinais.",
                                "Computação: Análise numérica em solvers de otimização (SciPy).",
                                "Física: Modelagem de sistemas lineares com ruído (ex: imagens).",
                                "Machine Learning: Regularização em redes neurais via SVD."
                              ],
                              "realWorldApplication": "Em visão computacional, SVD da pseudoinversa resolve sistemas de câmeras calibradas com ruído, onde 1/σ_min quantifica sensibilidade a erros de medição, essencial para reconstrução 3D estável em robótica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.3.4",
                            "name": "Aplicar em análise de condição numérica",
                            "description": "Avaliar estabilidade numérica de uma matriz exemplo via SVD, calculando κ₂ e relacionando com erros em soluções de equações lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e analisar matriz exemplo",
                                  "subSteps": [
                                    "Escolha uma matriz quadrada A de tamanho pequeno (ex: 2x2 ou 3x3) que possa ser mal-condicionada, como uma matriz de Hilbert ou com valores singulares próximos de zero.",
                                    "Calcule a norma 2 da matriz A usando ||A||₂ = σ_max (maior valor singular).",
                                    "Defina um vetor b para o sistema Ax = b e introduza um pequeno erro δb em b.",
                                    "Registre as propriedades iniciais da matriz, como traço e determinante, para contexto.",
                                    "Verifique se a matriz é invertível computacionalmente."
                                  ],
                                  "verification": "Matriz A selecionada com dimensões definidas e b com erro δb preparado; normas iniciais calculadas.",
                                  "estimatedTime": "20 minutes",
                                  "materials": "Python (NumPy/SciPy), MATLAB ou calculadora matricial online.",
                                  "tips": "Comece com matrizes 2x2 para simplicidade; use funções prontas como np.linalg.norm.",
                                  "learningObjective": "Identificar matrizes candidatas a análise de condição e preparar dados de entrada.",
                                  "commonMistakes": "Escolher matrizes bem-condicionadas (κ≈1) que não demonstrem instabilidade; ignorar normalização de b."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar a Decomposição em Valores Singulares (SVD)",
                                  "subSteps": [
                                    "Aplique SVD: A = U Σ V^H, extraindo matrizes U, Σ (valores singulares σ1 ≥ σ2 ≥ ... ≥ σn) e V.",
                                    "Liste os valores singulares em ordem decrescente.",
                                    "Calcule a norma 2 da inversa aproximada: ||A^{-1}||₂ ≈ 1/σ_min.",
                                    "Visualize Σ para identificar gaps entre σ_max e σ_min.",
                                    "Confirme a reconstrução: ||A - U Σ V^H||₂ < ε (pequeno erro)."
                                  ],
                                  "verification": "SVD computada corretamente com σ_i listados e reconstrução com erro < 1e-10.",
                                  "estimatedTime": "25 minutes",
                                  "materials": "Python (np.linalg.svd), MATLAB (svd(A)) ou software equivalente.",
                                  "tips": "Use full_matrices=False para eficiência em Python; plote os σ_i em gráfico de barras.",
                                  "learningObjective": "Executar SVD e extrair componentes essenciais para análise de condição.",
                                  "commonMistakes": "Confundir σ_max com σ_min; não verificar reconstrução da SVD."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o número de condição κ₂",
                                  "subSteps": [
                                    "Compute κ₂(A) = ||A||₂ * ||A^{-1}||₂ = σ_max / σ_min.",
                                    "Compare κ₂ com thresholds: κ₂ < 10^3 (bem-condicionado), >10^6 (mal-condicionado).",
                                    "Calcule κ₂ para A + δA (pequena perturbação) e observe variação.",
                                    "Registre log10(κ₂) para escala logarítmica.",
                                    "Interprete: κ₂ indica amplificação máxima de erros por fator κ₂."
                                  ],
                                  "verification": "κ₂ calculado numericamente com valor exato e interpretação qualitativa fornecida.",
                                  "estimatedTime": "15 minutes",
                                  "materials": "Mesmas ferramentas de SVD; função np.linalg.cond(A, p=2).",
                                  "tips": "Use precisão dupla; evite inversão direta para ||A^{-1}||.",
                                  "learningObjective": "Quantificar condição numérica via SVD e interpretar seu significado.",
                                  "commonMistakes": "Usar norma errada (ex: Frobenius em vez de 2); ignorar que κ₂ ≥1 sempre."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar erros em soluções de equações lineares",
                                  "subSteps": [
                                    "Resolva Ax = b para x exato e (A + δA)x = b + δb para x perturbado.",
                                    "Calcule erro relativo: ||x - x_pert|| / ||x|| e compare com ||δA||/||A|| e ||δb||/||b||.",
                                    "Verifique se erro ≈ κ₂ * (||δA||/||A|| + ||δb||/||b||).",
                                    "Repita com diferentes magnitudes de δA e δb.",
                                    "Plote erro vs. log(κ₂) para visualização."
                                  ],
                                  "verification": "Erros calculados e relação com κ₂ demonstrada numericamente (erro amplificado por ≈κ₂).",
                                  "estimatedTime": "30 minutes",
                                  "materials": "Solucionadores lineares: np.linalg.solve; gráficos com Matplotlib.",
                                  "tips": "Use δA = 1e-10 * A para simular precisão máquina; normalize todos vetores.",
                                  "learningObjective": "Relacionar κ₂ com amplificação de erros em sistemas lineares.",
                                  "commonMistakes": "Não normalizar erros relativos; usar solve em matrizes singulares."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Concluir sobre estabilidade numérica",
                                  "subSteps": [
                                    "Resuma: se κ₂ grande, A é instável; recomende regularização ou preconditioning.",
                                    "Discuta implicações para iterações (ex: GMRES converge lento se mal-condicionado).",
                                    "Compare com outras normas de condição (1, ∞).",
                                    "Documente relatório com tabelas de σ_i, κ₂ e erros.",
                                    "Sugira matrizes alternativas para testes."
                                  ],
                                  "verification": "Relatório completo com conclusões sobre estabilidade e recomendações.",
                                  "estimatedTime": "20 minutes",
                                  "materials": "Editor de texto ou Jupyter Notebook para relatório.",
                                  "tips": "Inclua código reproduzível; cite referências como Golub-Van Loan.",
                                  "learningObjective": "Sintetizar análise SVD-κ₂ para avaliar estabilidade prática.",
                                  "commonMistakes": "Superestimar estabilidade se κ₂ moderado mas σ_min muito pequeno."
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 1], [1, 1+1e-10]] (mal-condicionada, κ₂ ≈ 1e10). SVD dá σ1≈√2, σ2≈1e-10. Para b=[2,2+ε], erro em x amplifica por κ₂, mostrando instabilidade em Ax=b.",
                              "finalVerifications": [
                                "SVD computada com reconstrução precisa (erro <1e-12).",
                                "κ₂ = σ_max/σ_min calculado corretamente.",
                                "Erro relativo em x_pert ≤ κ₂ * (||δA||/||A|| + ||δb||/||b||) + máquina.",
                                "Interpretação qualitativa: bem/mal-condicionado justificada.",
                                "Relatório inclui gráficos de σ_i e erros.",
                                "Código reproduzível sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica dos cálculos SVD e κ₂ (erro <1e-10).",
                                "Correta relação entre κ₂ e amplificação de erros demonstrada.",
                                "Uso apropriado de normas 2 e interpretação contextual.",
                                "Qualidade do exemplo prático e visualizações.",
                                "Relatório claro, com substeps seguidos e dicas aplicadas.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação em NumPy/SciPy para análise numérica.",
                                "Física: Análise de estabilidade em simulações de dinâmica (matrizes de rigidez).",
                                "Engenharia: Condição em modelos finitos elementos (FEM).",
                                "Estatística: Regressão linear e multicolinearidade via SVD."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, analisar condição de matrizes de massa/inércia via SVD para prever erros em simulações de voo; κ₂ alto indica necessidade de refinamento de malha ou regularização."
                            },
                            "estimatedTime": "1.25 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.3",
                    "name": "Formas da SVD (Completa e Econômica)",
                    "description": "Diferenças entre a SVD completa e as versões reduzida e econômica, com aplicações em matrizes de diferentes ranks.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.3.1",
                        "name": "Decomposição em Valores Singulares Completa",
                        "description": "A SVD completa de uma matriz A ∈ ℝ^{m×n} é dada por A = U Σ V^T, onde U é uma matriz ortogonal m×m, Σ é uma matriz m×n diagonal retangular com valores singulares σ_i ≥ 0 em ordem decrescente na diagonal principal, e V é uma matriz ortogonal n×n. Essa forma inclui todos os vetores singulares esquerdos e direitos, independentemente do rank.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.1.1",
                            "name": "Identificar dimensões e propriedades da SVD completa",
                            "description": "Determinar as dimensões exatas de U (m×m), Σ (m×n) e V (n×n), listar propriedades como U^T U = I_m, V^T V = I_n, Σ diagonal com entradas não-negativas decrescentes, e verificar que A = U Σ V^T reconstrói a matriz original exatamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar as dimensões exatas das matrizes na SVD completa",
                                  "subSteps": [
                                    "Dada uma matriz A de dimensões m × n, lembre que a SVD completa é A = U Σ V^T.",
                                    "Determine as dimensões de U: sempre quadrada m × m, independentemente de m e n.",
                                    "Determine as dimensões de Σ: retangular m × n, com diagonal principal contendo os valores singulares.",
                                    "Determine as dimensões de V: sempre quadrada n × n.",
                                    "Anote as dimensões em um diagrama esquemático para visualização."
                                  ],
                                  "verification": "Confirme escrevendo as dimensões para uma matriz exemplo m=3, n=2 e verificando consistência com a fórmula A = U Σ V^T.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora ou software como Python NumPy/MATLAB"
                                  ],
                                  "tips": "Sempre relacione as dimensões de A com U, Σ e V multiplicando para verificar compatibilidade.",
                                  "learningObjective": "Compreender e declarar precisamente as dimensões de cada componente da SVD completa.",
                                  "commonMistakes": [
                                    "Confundir com SVD econômica (U m×r, Σ r×r, V r×n)",
                                    "Esquecer que U e V são quadradas na forma completa"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Listar e entender as propriedades ortogonais de U e V",
                                  "subSteps": [
                                    "Verifique a ortogonalidade de U: calcule ou lembre que U^T U = I_m (identidade m×m).",
                                    "Verifique a ortogonalidade de V: calcule ou lembre que V^T V = I_n (identidade n×n).",
                                    "Entenda que colunas de U são autovetores esquerdos e de V são autovetores direitos.",
                                    "Discuta implicações: preservam normas e ângulos (bases ortonormais).",
                                    "Teste computacionalmente em uma matriz pequena."
                                  ],
                                  "verification": "Multiplique U^T U e V^T V manualmente ou via software e confirme identidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software NumPy ou MATLAB para SVD",
                                    "Matriz exemplo impressa"
                                  ],
                                  "tips": "Use np.linalg.svd() no Python com full_matrices=True para SVD completa.",
                                  "learningObjective": "Identificar e validar as propriedades ortogonais de U e V na SVD.",
                                  "commonMistakes": [
                                    "Pensar que U e V são unitárias apenas se m=n",
                                    "Confundir U^T U com U U^T (ambos I para quadrada)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar as propriedades da matriz Σ diagonal",
                                  "subSteps": [
                                    "Confirme que Σ é diagonal com entradas σ1 ≥ σ2 ≥ ... ≥ σk ≥ 0 (não-negativas e decrescentes).",
                                    "Identifique que fora da diagonal principal, Σ tem zeros.",
                                    "Para m ≠ n, os elementos extras são zeros (ex: se m > n, linhas extras zero).",
                                    "Explique o significado: valores singulares medem 'importância' das direções.",
                                    "Ordene os valores singulares em ordem decrescente."
                                  ],
                                  "verification": "Extraia Σ de uma SVD computada e verifique ordenação e zeros fora da diagonal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook Jupyter com NumPy",
                                    "Exemplos de matrizes variadas"
                                  ],
                                  "tips": "Visualize Σ como um 'heatmap' para ver a estrutura diagonal claramente.",
                                  "learningObjective": "Descrever precisamente as propriedades da matriz de valores singulares Σ.",
                                  "commonMistakes": [
                                    "Permitir valores negativos em Σ",
                                    "Não ordenar decrescentemente os singulares"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a reconstrução exata da matriz original A",
                                  "subSteps": [
                                    "Calcule o produto U Σ V^T usando multiplicação matricial.",
                                    "Compare elemento a elemento com a matriz A original.",
                                    "Confirme que a igualdade é exata (sem aproximações na SVD completa).",
                                    "Teste numericamente considerando precisão de ponto flutuante.",
                                    "Discuta por que isso prova a completude da decomposição."
                                  ],
                                  "verification": "Compute ||A - U @ Σ @ V.T|| (norma Frobenius < 1e-10) para confirmação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python/MATLAB script pronto para SVD e reconstrução",
                                    "Matriz A de teste"
                                  ],
                                  "tips": "Use loops ou broadcasting para verificação elemento a elemento em código.",
                                  "learningObjective": "Validar que a SVD completa reconstrói A exatamente.",
                                  "commonMistakes": [
                                    "Usar SVD econômica que aproxima",
                                    "Erros de transposição em V^T"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[3, 0], [0, 4]] (2x2):\nU (2x2) ortogonal, Σ = [[4,0],[0,3]] (2x2 diagonal decrescente), V (2x2) ortogonal.\nVerifique: U^T U = I_2, V^T V = I_2, A = U Σ V^T exatamente.",
                              "finalVerifications": [
                                "Declare dimensões corretas para A qualquer m×n.",
                                "Liste U^T U = I_m e V^T V = I_n.",
                                "Descreva Σ: diagonal, não-negativa, decrescente.",
                                "Confirme reconstrução exata A = U Σ V^T.",
                                "Diferencie de SVD econômica.",
                                "Explique implicações ortogonais."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas dimensões (100% correto).",
                                "Correta identificação de propriedades ortogonais (com provas).",
                                "Descrição completa de Σ (ordenamento e estrutura).",
                                "Verificação numérica de reconstrução (erro < 1e-10).",
                                "Uso de exemplos concretos e diagramas.",
                                "Diferenciação clara de formas SVD."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Base para Análise de Componentes Principais (PCA).",
                                "Ciência da Computação: Compressão de imagens e dados (JPEG).",
                                "Física: Decomposição em modais em mecânica quântica.",
                                "Machine Learning: Redução de dimensionalidade em embeddings."
                              ],
                              "realWorldApplication": "Em sistemas de recomendação (Netflix), SVD completa identifica padrões em matrizes usuário-item grandes, permitindo reconstrução exata para análise de similaridades e compressão eficiente de dados esparsos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.2",
                            "name": "Construir SVD completa a partir de valores e vetores singulares",
                            "description": "Dado os valores singulares σ_1 ≥ ... ≥ σ_p > 0 (p = min(m,n)) e os vetores singulares esquerdos (colunas de U) e direitos (colunas de V), montar as matrizes U, Σ e V completas, incluindo zeros em Σ e completando com base ortonormal para os autovetores nulos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar dimensões da matriz e componentes fornecidos",
                                  "subSteps": [
                                    "Determine m (linhas) e n (colunas) da matriz original A.",
                                    "Identifique p = min(m, n) e liste os valores singulares σ₁ ≥ ... ≥ σ_p > 0 fornecidos.",
                                    "Liste os vetores singulares esquerdos u₁, ..., u_p (colunas iniciais de U) e direitos v₁, ..., v_p (colunas iniciais de V).",
                                    "Verifique se os vetores fornecidos são unitários e ortogonais entre si.",
                                    "Calcule o número de vetores nulos necessários: m - p para U e n - p para V."
                                  ],
                                  "verification": "Confirme que dimensões m, n, p estão corretas e componentes listados sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora para normas",
                                    "Matriz A original se disponível"
                                  ],
                                  "tips": "Anote tudo em uma tabela para visualização clara: dimensões, σ's, u's, v's.",
                                  "learningObjective": "Compreender os componentes dados e dimensões para SVD completa.",
                                  "commonMistakes": [
                                    "Confundir m e n",
                                    "Esquecer que p = min(m,n)",
                                    "Não verificar ortogonalidade inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz Σ completa",
                                  "subSteps": [
                                    "Crie uma matriz m x n zerada.",
                                    "Preencha a diagonal principal com σ₁ a σ_p, começando do canto superior esquerdo.",
                                    "Deixe zeros em todas as outras posições, incluindo fora da diagonal e na parte 'nula'.",
                                    "Verifique se Σ é diagonal e não-negativa decrescente.",
                                    "Confirme dimensões: m linhas, n colunas."
                                  ],
                                  "verification": "Multiplique Σ por um vetor padrão e veja se só afeta as primeiras p componentes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software como Python/NumPy para protótipo"
                                  ],
                                  "tips": "Use notação Σ = diag(σ₁, ..., σ_p, 0, ..., 0) ajustada para retangular.",
                                  "learningObjective": "Montar corretamente a matriz diagonal retangular de valores singulares.",
                                  "commonMistakes": [
                                    "Colocar σ's fora da diagonal",
                                    "Esquecer zeros na parte inferior se m > n",
                                    "Invertar ordem decrescente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Completar a matriz U com base ortonormal para o núcleo esquerdo",
                                  "subSteps": [
                                    "Use as p colunas u₁ a u_p fornecidas como primeiras colunas de U (m x m).",
                                    "Encontre m - p vetores ortogonais a span{u₁,...,u_p} e unitários usando Gram-Schmidt ou autovalores.",
                                    "Aplique Gram-Schmidt em vetores candidatos (e.g., padrão basis) para ortogonalizar.",
                                    "Normalize cada novo vetor para comprimento 1.",
                                    "Verifique U completa: colunas ortogonais (U^T U = I_m)."
                                  ],
                                  "verification": "Compute U^T U e confirme identidade m x m.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Calculadora matricial",
                                    "Python com NumPy/SciPy para Gram-Schmidt",
                                    "Papel para cálculos manuais"
                                  ],
                                  "tips": "Comece com basis padrão e projete orthogonalmente ao span existente.",
                                  "learningObjective": "Estender vetores singulares esquerdos para base ortonormal completa de R^m.",
                                  "commonMistakes": [
                                    "Não normalizar novos vetores",
                                    "Gram-Schmidt em ordem errada",
                                    "Esquecer ortogonalidade com u's existentes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Completar a matriz V com base ortonormal para o núcleo direito",
                                  "subSteps": [
                                    "Use as p colunas v₁ a v_p como primeiras colunas de V (n x n).",
                                    "Encontre n - p vetores ortogonais a span{v₁,...,v_p} usando processo similar a U.",
                                    "Aplique Gram-Schmidt para ortogonalizar e normalize.",
                                    "Monte V completa e verifique V^T V = I_n.",
                                    "Confirme independência linear total."
                                  ],
                                  "verification": "Compute V^T V = identidade n x n.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Mesmos de step 3",
                                    "Software para verificação de ortogonalidade"
                                  ],
                                  "tips": "Reutilize código ou método do step 3 para eficiência.",
                                  "learningObjective": "Estender vetores singulares direitos para base de R^n.",
                                  "commonMistakes": [
                                    "Confundir esquerda/direita",
                                    "Não verificar ortogonalidade mútua",
                                    "Vetores não unitários"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Montar e verificar a SVD completa A = U Σ V^T",
                                  "subSteps": [
                                    "Compute V^T (transposta de V).",
                                    "Multiplique U * Σ * V^T e compare com A original.",
                                    "Verifique propriedades: ||A|| = max σ_i, rank(A) = p.",
                                    "Confirme que colunas de U são autovetores de A A^T, V de A^T A.",
                                    "Documente a SVD completa."
                                  ],
                                  "verification": "A reconstruída == A original (erro numérico < 10^-10).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software computacional obrigatório (NumPy/MATLAB)",
                                    "A original"
                                  ],
                                  "tips": "Use SVD built-in para benchmark.",
                                  "learningObjective": "Validar a construção da SVD completa.",
                                  "commonMistakes": [
                                    "Erro em transposta V^T",
                                    "Multiplicação matricial errada",
                                    "Ignorar erros numéricos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A 3x2 com σ₁=3, σ₂=1; u₁=[1,0,0]^T, u₂=[0,1,0]^T; v₁=[1,0]^T, v₂=[0,1]^T. Σ=[[3,0],[0,1],[0,0]]. Complete U com u₃=[0,0,1]^T (ortonormal). V já completa 2x2=I. SVD: U=[[1,0,0],[0,1,0],[0,0,1]], Σ como acima, V=I. Verifique A=UΣV^T.",
                              "finalVerifications": [
                                "U é m x m ortogonal (U^T U = I_m).",
                                "V é n x n ortogonal (V^T V = I_n).",
                                "Σ é m x n diagonal com σ_i decrescentes e zeros.",
                                "A = U Σ V^T exatamente.",
                                "Rank da SVD = p (número de σ>0).",
                                "Primeiras p colunas de U/V coincidem com fornecidas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de Σ (100% correto).",
                                "Ortogonalidade de U e V (erro < 10^-8).",
                                "Correta extensão de bases nulas.",
                                "Verificação de reconstrução A exata.",
                                "Eficiência e clareza nos subpassos.",
                                "Tratamento correto de casos m≠n."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementar em NumPy.linalg.svd(full_matrices=True).",
                                "Machine Learning: Base para PCA e redução dimensional.",
                                "Física: Análise de vibrações e decomposição modal.",
                                "Engenharia: Compressão de sinais e imagens."
                              ],
                              "realWorldApplication": "Na compressão de imagens (JPEG2000), SVD completa reconstrói imagens exatas mantendo bases ortonormais para processamento eficiente em visão computacional e recomendação (Netflix usa variantes SVD)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.3",
                            "name": "Calcular SVD completa para matrizes pequenas",
                            "description": "Aplicar o algoritmo para computar SVD completa de matrizes 2×2 ou 3×3, usando métodos como decomposição em autovalores de A^T A e A A^T, e verificar a reconstrução A ≈ U Σ V^T com precisão numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a matriz e calcular AᵀA e AAᵀ",
                                  "subSteps": [
                                    "Selecione uma matriz A de tamanho 2×2 ou 3×3 com entradas numéricas reais.",
                                    "Calcule a transposta Aᵀ manualmente, trocando linhas por colunas.",
                                    "Multiplique Aᵀ por A para obter AᵀA (matriz simétrica m×m).",
                                    "Multiplique A por Aᵀ para obter AAᵀ (matriz simétrica n×n).",
                                    "Verifique se as matrizes resultantes são simétricas (AᵀA = (AᵀA)ᵀ)."
                                  ],
                                  "verification": "Confirme que AᵀA e AAᵀ são simétricas e têm as dimensões corretas comparando com cálculos manuais ou software.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis ou calculadora matricial",
                                    "Software como MATLAB/Octave ou Python com NumPy (opcional)"
                                  ],
                                  "tips": "Use notação clara para evitar erros de transposição; comece com matrizes 2×2 para prática.",
                                  "learningObjective": "Dominar o cálculo de matrizes simétricas associadas para SVD.",
                                  "commonMistakes": [
                                    "Confundir AᵀA com AAᵀ",
                                    "Erros em multiplicação matricial",
                                    "Esquecer de verificar simetria"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar autovalores e autovetores de AᵀA para obter V e valores singulares iniciais",
                                  "subSteps": [
                                    "Resolva o polinômio característico det(AᵀA - λI) = 0 para encontrar autovalores λ₁ ≥ λ₂ ≥ ... ≥ 0.",
                                    "Para cada λ_i > 0, resolva (AᵀA - λ_i I)v_i = 0 para autovetor v_i.",
                                    "Normalize os autovetores para ||v_i|| = 1, formando as colunas de V.",
                                    "Calcule os valores singulares σ_i = √λ_i e ordene em ordem decrescente.",
                                    "Verifique ortogonalidade: VᵀV ≈ I."
                                  ],
                                  "verification": "Os autovetores formam uma base ortonormal e σ_i são não-negativos decrescentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora para raízes quadráticas/cúbicas",
                                    "Tabelas de polinômios ou solver simbólico como SymPy"
                                  ],
                                  "tips": "Para 2×2, use fórmula quadrática; ordene autovalores corretamente.",
                                  "learningObjective": "Aplicar decomposição espectral em matrizes simétricas para obter V e Σ.",
                                  "commonMistakes": [
                                    "Autovalores negativos (impossível para AᵀA)",
                                    "Normalização incorreta",
                                    "Não ordenar σ_i"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar autovalores e autovetores de AAᵀ para obter U",
                                  "subSteps": [
                                    "Resolva det(AAᵀ - λI) = 0; note que λ_i de AAᵀ coincidem com os de AᵀA (exceto zeros).",
                                    "Para cada λ_i > 0, resolva (AAᵀ - λ_i I)u_i = 0 para autovetor u_i.",
                                    "Normalize u_i para ||u_i|| = 1; para dimensões maiores, complete com base ortonormal para zeros.",
                                    "Ajuste sinais de u_i usando u_i = A v_i / σ_i para consistência.",
                                    "Verifique ortogonalidade: UᵀU ≈ I."
                                  ],
                                  "verification": "u_i = A v_i / σ_i satisfaz e U é unitária.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Mesmos da etapa anterior",
                                    "Matriz A original para verificação cruzada"
                                  ],
                                  "tips": "Use a relação u_i = A v_i / σ_i para evitar inconsistências de fase.",
                                  "learningObjective": "Construir U coerente com V e Σ via propriedades da SVD.",
                                  "commonMistakes": [
                                    "Ignorar ajuste de sinais",
                                    "Não completar U para rank < n",
                                    "Erros em sistemas lineares"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir a decomposição SVD e verificar reconstrução",
                                  "subSteps": [
                                    "Forme Σ diagonal com σ_i na diagonal principal e zeros elsewhere.",
                                    "Monte U (n×n unitária), Σ (n×m), Vᵀ (m×m unitária).",
                                    "Calcule o produto U Σ Vᵀ manualmente ou numericamente.",
                                    "Compare com A original: ||A - U Σ Vᵀ|| < ε (ex: 10^{-10}).",
                                    "Confirme propriedades: U e V unitárias, Σ diagonal não-negativa."
                                  ],
                                  "verification": "A ≈ U Σ Vᵀ com erro numérico pequeno e propriedades SVD satisfeitas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora matricial ou Python/NumPy para verificação numérica"
                                  ],
                                  "tips": "Use precisão de ponto flutuante; para exato, frações.",
                                  "learningObjective": "Validar a SVD completa através de reconstrução e propriedades.",
                                  "commonMistakes": [
                                    "Erros de arredondamento em produto",
                                    "Σ não diagonal",
                                    "V ao invés de Vᵀ"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[3, 1], [0, 2]]:\n- AᵀA = [[9, 3], [3, 5]], autovalores λ=10,4 → σ=√10≈3.162,2.\n- V colunas normalizadas de autovetores.\n- AAᵀ = [[9, 6], [6, 5]], u1 ajustado como A v1 / σ1 = [3,0]/3.162 ≈ [0.949,0], etc.\n- Reconstrução: U Σ Vᵀ ≈ A com erro <10^{-12}.",
                              "finalVerifications": [
                                "SVD reconstrói A com erro numérico <10^{-10}.",
                                "Colunas de U e V são ortonormais.",
                                "Σ tem valores singulares decrescentes não-negativos.",
                                "u_i = A v_i / σ_i para i=1..r.",
                                "Rank de A igual a número de σ_i >0.",
                                "Funciona para pelo menos 3 matrizes 2×2 e 1 de 3×3."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de autovalores/autovetores (erro <1%).",
                                "Correta normalização e ordenação de σ_i.",
                                "Ajuste consistente de sinais entre U e V.",
                                "Verificação de reconstrução com erro quantificado.",
                                "Explicação clara de cada passo e propriedades SVD.",
                                "Tratamento correto de casos com σ_i=0."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar SVD em Python/NumPy para automação.",
                                "Física: Análise de componentes principais em dados experimentais.",
                                "Estatística: Redução de dimensionalidade em PCA.",
                                "Engenharia: Compressão de sinais/imagens via SVD truncada."
                              ],
                              "realWorldApplication": "Em processamento de imagens, SVD completa permite compressão lossless para matrizes pequenas de pixels, ou em recomendadores (Netflix) para fatorar matrizes usuário-item em fatores latentes U e V."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.2",
                        "name": "Decomposição em Valores Singulares Econômica",
                        "description": "A SVD econômica (também chamada thin SVD) para A ∈ ℝ^{m×n} com k = min(m,n) é A = U_k Σ_k V_k^T, onde U_k é m×k com colunas ortonormais, Σ_k é k×k diagonal com os k maiores valores singulares, e V_k é n×k com colunas ortonormais. Reduz o custo de armazenamento e computação quando m ≠ n.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.2.1",
                            "name": "Diferenciar dimensões da SVD econômica em relação à completa",
                            "description": "Comparar dimensões: U_k (m×k), Σ_k (k×k), V_k (n×k) vs. completa, destacando economia de espaço (evita colunas extras de U e V) e equivalência em reconstrução para os k primeiros modos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a estrutura da SVD Completa",
                                  "subSteps": [
                                    "Lembre-se da definição: Para uma matriz A (m×n), SVD completa é A = U (m×m) * Σ (m×n) * V^T (n×n), onde U e V são ortogonais, Σ diagonal com valores singulares.",
                                    "Identifique as dimensões: U tem m colunas (todos os vetores singulares esquerdos), Σ tem min(m,n) valores singulares na diagonal e zeros fora, V tem n colunas.",
                                    "Esboce um exemplo simples: Considere A 3×2, dimensões U(3×3), Σ(3×2), V(2×2).",
                                    "Calcule o número total de elementos armazenados: m² + m*n + n².",
                                    "Anote as propriedades: Reconstrução exata A ≈ U*Σ*V^T."
                                  ],
                                  "verification": "Escreva as dimensões exatas para uma matriz A(m×n) e confirme com um exemplo numérico pequeno.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou caderno",
                                    "Calculadora ou software como MATLAB/Octave para SVD",
                                    "Referência: Livro de Álgebra Linear (ex: Strang)"
                                  ],
                                  "tips": "Use diagramas matriciais para visualizar as dimensões; foque em m ≥ n ou n ≥ m.",
                                  "learningObjective": "Entender precisamente as dimensões e estrutura da SVD completa.",
                                  "commonMistakes": [
                                    "Confundir Σ como sempre quadrada",
                                    "Esquecer que V é n×n mesmo se m > n"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a SVD Econômica (Truncated ou Thin SVD)",
                                  "subSteps": [
                                    "Defina SVD econômica: A = U_k (m×k) * Σ_k (k×k) * V_k^T (k×n), onde k ≤ min(m,n), focando nos k maiores valores singulares.",
                                    "Note as dimensões reduzidas: U_k só tem k colunas (primeiros k vetores), Σ_k quadrada k×k, V_k tem k linhas (primeiros k vetores de V).",
                                    "Compare armazenamento: m*k + k² + n*k vs. completo m² + m*n + n².",
                                    "Exemplo: Para A 3×2 com k=2, U_k(3×2), Σ_k(2×2), V_k(2×2).",
                                    "Verifique que para k = rank(A), é exata."
                                  ],
                                  "verification": "Escreva as dimensões da SVD econômica para o mesmo A 3×2 com k=2 e calcule elementos totais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmo caderno",
                                    "Software para computar svd econômica (ex: svd(A,'econ') no MATLAB)"
                                  ],
                                  "tips": "Sempre especifique k; comece com k = min(m,n) para full rank econômica.",
                                  "learningObjective": "Dominar as dimensões específicas da SVD econômica.",
                                  "commonMistakes": [
                                    "Pensar V_k como n×k ao invés de k×n",
                                    "Ignorar que Σ_k é sempre quadrada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Dimensões e Economia de Espaço",
                                  "subSteps": [
                                    "Liste diferenças lado a lado: Completa U(m×m), Econômica U_k(m×k); Σ(m×n) vs Σ_k(k×k); V(n×n) vs V_k(n×k).",
                                    "Calcule economia: Evita (m-k)*m em U e (n-k)*n em V; ganho significativo se k << min(m,n).",
                                    "Tabela comparativa: Para m=1000, n=500, k=10, calcule elementos (completa ~1M, econômica ~15k).",
                                    "Discuta quando usar: Sempre que k pequeno, como em dados de alta dimensão.",
                                    "Pratique com variação: m>n vs n>m."
                                  ],
                                  "verification": "Crie uma tabela comparando dimensões e contagem de elementos para m=100, n=50, k=5.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou papel para tabelas",
                                    "Calculadora para multiplicações"
                                  ],
                                  "tips": "Use notação matricial para alinhar colunas/linhas na multiplicação.",
                                  "learningObjective": "Diferenciar dimensões e quantificar economia de espaço.",
                                  "commonMistakes": [
                                    "Confundir V_k^T como k×n ao invés de n×k",
                                    "Subestimar economia quando m ou n grande"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Equivalência na Reconstrução",
                                  "subSteps": [
                                    "Mostre que A ≈ U_k * Σ_k * V_k^T recupera os k primeiros modos, igual à projeção da completa.",
                                    "Matematicamente: Os primeiros k colunas de U*Σ*V^T coincidem com econômica.",
                                    "Exemplo numérico: Compute SVD completa e econômica para A = [1 0; 0 2; 0 0], compare reconstruções.",
                                    "Discuta erro: ||A - U_k Σ_k V_k^T|| = sqrt(sum σ_i² para i>k).",
                                    "Confirme: Econômica é exata se k=rank(A)."
                                  ],
                                  "verification": "Compute reconstrução para um exemplo 3×2 e confirme igualdade nos k modos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software numérico (Python NumPy/MATLAB)",
                                    "Matriz de exemplo impressa"
                                  ],
                                  "tips": "Use comandos prontos como np.linalg.svd(A, full_matrices=False) para econômica.",
                                  "learningObjective": "Compreender por que dimensões reduzidas mantêm equivalência.",
                                  "commonMistakes": [
                                    "Achar que econômica perde informação nos k modos",
                                    "Não transpor V_k corretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para matriz A (3×2) = [[1,0],[0,2],[0,0]], SVD completa: U(3×3), Σ(3×2), V(2×2). Econômica k=2: U_k(3×2), Σ_k(2×2), V_k(2×2). Reconstrução A = U_k Σ_k V_k^T exata. Economia: Completa 9+6+4=19 elems, Econômica 6+4+4=14 elems (26% menos).",
                              "finalVerifications": [
                                "Explicar dimensões U, Σ, V para completa vs econômica sem erros.",
                                "Calcular corretamente número de elementos para dada m,n,k.",
                                "Demonstrar equivalência de reconstrução com exemplo numérico.",
                                "Identificar cenários onde economia >50%.",
                                "Diferenciar casos m>n vs n>m.",
                                "Confirmar que Σ_k é sempre k×k."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas dimensões (U m×k vs m×m, etc.): 100% correto.",
                                "Quantificação de economia de espaço com cálculos exatos.",
                                "Explicação clara da equivalência na reconstrução para k modos.",
                                "Uso correto de notação matricial em comparações.",
                                "Identificação de pelo menos 3 vantagens práticas da econômica.",
                                "Ausência de confusões comuns como dimensões de V_k."
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Otimização de memória em ML (ex: PCA reduzida).",
                                "Estatística: Redução dimensional em análise de dados principais.",
                                "Engenharia: Compressão de sinais/imagens (JPEG usa SVD-like).",
                                "Física: Modos principais em simulações dinâmicas.",
                                "Economia: Modelos de redução em big data financeiro."
                              ],
                              "realWorldApplication": "Em sistemas de recomendação (Netflix), SVD econômica com k~100 em matrizes usuário-item milhões×milhares economiza GBs de RAM, permitindo reconstrução aproximada rápida para sugestões personalizadas sem perda significativa de precisão."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.2.2",
                            "name": "Aplicar SVD econômica em matrizes retangulares",
                            "description": "Usar SVD econômica para matrizes com m >> n (ex.: dados altos), computando pseudoinversa A^+ = V_k Σ_k^{-1} U_k^T e verificando soluções de mínimos quadrados com economia computacional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a matriz retangular e definir parâmetros da SVD econômica",
                                  "subSteps": [
                                    "Verifique as dimensões da matriz A (m x n) confirmando m >> n.",
                                    "Escolha o rank k ≤ n baseado no problema (ex.: singular values decay).",
                                    "Normalize ou pré-processe A se necessário (ex.: centralizar dados).",
                                    "Defina o sistema Ax ≈ b para mínimos quadrados.",
                                    "Documente as dimensões e k escolhido."
                                  ],
                                  "verification": "Matriz A tem m >> n, k definido corretamente, e b é compatível.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Matriz de exemplo (NumPy array ou MATLAB matrix)",
                                    "Software: Python (NumPy/SciPy) ou MATLAB",
                                    "Papel e calculadora para casos pequenos"
                                  ],
                                  "tips": "Use np.linalg.matrix_rank() para estimar rank; visualize singular values para escolher k.",
                                  "learningObjective": "Identificar quando SVD econômica é apropriada e preparar dados adequadamente.",
                                  "commonMistakes": [
                                    "Confundir m e n",
                                    "Escolher k > n",
                                    "Ignorar pré-processamento como normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar a decomposição SVD econômica de A",
                                  "subSteps": [
                                    "Execute SVD econômica: A = U_k Σ_k V_k^T usando função built-in (np.linalg.svd(A, full_matrices=False)).",
                                    "Extraia U_k (m x k), Σ_k (k x k diagonal), V_k (n x k).",
                                    "Plote os singular values para validar decay e escolha de k.",
                                    "Verifique A ≈ U_k @ Σ_k @ V_k.T com erro pequeno.",
                                    "Salve os componentes para uso posterior."
                                  ],
                                  "verification": "Reconstrução A_recon = U_k Σ_k V_k^T satisfaz ||A - A_recon|| < 1e-10.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código Python/MATLAB pronto",
                                    "Gráficos (matplotlib/plot) para singular values"
                                  ],
                                  "tips": "full_matrices=False garante economia; truncate para k < n se needed.",
                                  "learningObjective": "Executar e validar SVD econômica computacionalmente.",
                                  "commonMistakes": [
                                    "Usar full SVD em vez de econômica",
                                    "Erro na ordem das matrizes (U Σ V^T)",
                                    "Não truncar para k adequado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a pseudoinversa econômica A^+",
                                  "subSteps": [
                                    "Inverta Σ_k: Σ_k_inv = diag(1/σ_i) para σ_i > threshold.",
                                    "Compute A^+ = V_k @ Σ_k_inv @ U_k.T.",
                                    "Verifique propriedades: A A^+ A ≈ A e A^+ A A^+ ≈ A^+.",
                                    "Compare com pseudoinversa full (np.linalg.pinv) para validação.",
                                    "Meça tempo computacional vs full SVD."
                                  ],
                                  "verification": "A @ A_plus @ A ≈ A e ||A_plus - np.linalg.pinv(A)|| pequeno.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código de SVD do step anterior",
                                    "Timer para benchmark"
                                  ],
                                  "tips": "Threshold para singular values pequenos (1e-10) evita instabilidade numérica.",
                                  "learningObjective": "Construir pseudoinversa via SVD econômica e validar suas propriedades.",
                                  "commonMistakes": [
                                    "Inverter Σ incorretamente",
                                    "Ordem errada: V Σ_inv U^T",
                                    "Não lidar com singular values zero"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar A^+ para solução de mínimos quadrados e verificar",
                                  "subSteps": [
                                    "Compute x = A^+ @ b como solução mínima norma.",
                                    "Calcule resíduo ||Ax - b||_2 e confirme é mínimo.",
                                    "Compare com solução normal equation se n pequeno.",
                                    "Analise economia: tempo/espaço vs full SVD.",
                                    "Teste com ruído em b para robustez."
                                  ],
                                  "verification": "||A x - b|| é mínimo e x tem norma mínima entre soluções.",
                                  "estimatedTime": "1 hora 15 minutos",
                                  "materials": [
                                    "Vetor b gerado ou real",
                                    "Métricas: np.linalg.norm()"
                                  ],
                                  "tips": "Para m>>n, SVD econômica é O(m n^2) vs O(m n^2 + n^3) full.",
                                  "learningObjective": "Usar SVD econômica para mínimos quadrados e quantificar benefícios.",
                                  "commonMistakes": [
                                    "Usar x = pinv(A) @ b sem SVD explícita",
                                    "Ignorar verificação de resíduo",
                                    "Confundir com LSQR iterativo"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado A (1000x5) matriz de dados de sensores (1000 medições, 5 features), b vetor de targets. Compute SVD econômica (k=3), A^+ e x = A^+ b para prever targets com mínimos quadrados, verificando economia em tempo (ex.: 0.1s vs 1s full SVD).",
                              "finalVerifications": [
                                "SVD econômica reconstrói A com erro < 1e-10.",
                                "Pseudoinversa satisfaz as 4 propriedades de Moore-Penrose.",
                                "Solução x minimiza ||Ax - b||_2 com norma mínima.",
                                "Tempo/espaço SVD econômica < full SVD para m>>n.",
                                "Singular values plot mostra decay justificando k.",
                                "Resíduo é menor que alternativas como normal equations."
                              ],
                              "assessmentCriteria": [
                                "Correção da SVD econômica e truncamento k.",
                                "Construção precisa de A^+ com inversão estável.",
                                "Validação numérica rigorosa (erros < 1e-10).",
                                "Análise de complexidade computacional.",
                                "Aplicação correta a mínimos quadrados.",
                                "Código limpo, comentado e reproduzível."
                              ],
                              "crossCurricularConnections": [
                                "Machine Learning: Base para PCA/Truncated SVD em redução dimensional.",
                                "Processamento de Sinais: Compressão e denoising de dados altos.",
                                "Estatística: Inferência em regressão com multicolinearidade.",
                                "Computação Científica: Otimização numérica em big data."
                              ],
                              "realWorldApplication": "Em análise de big data (ex.: genomics com milhares de genes mas poucas amostras), SVD econômica computa pseudoinversas para regressão robusta em sistemas de recomendação (Netflix) ou previsão meteorológica, economizando memória e tempo em clusters."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.3",
                        "name": "Decomposição em Valores Singulares Reduzida",
                        "description": "A SVD reduzida (compact SVD) para A ∈ ℝ^{m×n} de rank r < min(m,n) é A = U_r Σ_r V_r^T, onde U_r é m×r, Σ_r é r×r diagonal com σ_1 ≥ ... ≥ σ_r > 0, V_r é n×r. Captura apenas os componentes não-nulos, ideal para rank deficiente e aproximações.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.3.1",
                            "name": "Determinar rank e construir SVD reduzida",
                            "description": "Identificar r como número de σ_i > tolerância numérica, extrair U_r, Σ_r, V_r da SVD completa ou econômica, e verificar ||A - U_r Σ_r V_r^T|| ≈ 0 para matrizes de rank baixo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Computar a Decomposição em Valores Singulares (SVD) da matriz A",
                                  "subSteps": [
                                    "Carregue a matriz A em um ambiente computacional (ex: NumPy no Python).",
                                    "Decida entre SVD completa (U m x m, Σ m x n, V n x n) ou econômica (U m x min(m,n), etc.) baseada no tamanho de A.",
                                    "Execute a função SVD: em Python, np.linalg.svd(A, full_matrices=True/False).",
                                    "Armazene U, S (vetor de σ_i), Vh (V^T).",
                                    "Visualize os valores singulares σ_i em ordem decrescente."
                                  ],
                                  "verification": "Confirme que U @ diag(S) @ Vh ≈ A com norma do erro < 1e-10.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com NumPy",
                                    "Matriz A de exemplo (ex: 3x2)"
                                  ],
                                  "tips": "Use full_matrices=False para matrizes grandes para economizar memória.",
                                  "learningObjective": "Entender como obter os componentes básicos da SVD.",
                                  "commonMistakes": [
                                    "Confundir full_matrices=True (SVD completa) com False (econômica).",
                                    "Não ordenar σ_i corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar o rank numérico r usando tolerância",
                                  "subSteps": [
                                    "Defina uma tolerância numérica tol, tipicamente max(m,n) * eps * ||A||_2, onde eps=1e-15.",
                                    "Identifique o maior índice r tal que σ_r > tol e σ_{r+1} ≤ tol.",
                                    "Plote os σ_i em escala log para visualizar o 'joelho' (elbow).",
                                    "Registre r e os σ_i selecionados.",
                                    "Teste sensibilidade variando tol ligeiramente."
                                  ],
                                  "verification": "r deve coincidir com o rank teórico para matrizes de rank exato baixo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "NumPy/Matplotlib para plot",
                                    "Valores singulares S"
                                  ],
                                  "tips": "Use tol = np.spacing(np.linalg.norm(A)) * max(A.shape) para automação.",
                                  "learningObjective": "Aplicar critério numérico para rank em presença de ruído.",
                                  "commonMistakes": [
                                    "Escolher tol muito pequena (inclui ruído) ou muito grande (subestima rank).",
                                    "Ignorar normalização pela norma de A."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair as componentes da SVD reduzida: U_r, Σ_r, V_r",
                                  "subSteps": [
                                    "Selecione as r primeiras colunas de U: U_r = U[:, :r].",
                                    "Crie Σ_r como matriz diagonal r x r com σ_1 a σ_r.",
                                    "Selecione as r primeiras linhas de Vh: V_r^T = Vh[:r, :]; então V_r = V_r^T.T.",
                                    "Verifique dimensões: U_r (m x r), Σ_r (r x r), V_r (n x r).",
                                    "Armazene essas matrizes truncadas."
                                  ],
                                  "verification": "Dimensões corretas e Σ_r diagonal com valores positivos decrescentes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "NumPy arrays de U, S, Vh"
                                  ],
                                  "tips": "Use slicing eficiente: U_r = U[:, :r] para evitar cópias desnecessárias.",
                                  "learningObjective": "Construir truncamento exato da SVD para rank r.",
                                  "commonMistakes": [
                                    "Errar transposição de V_r (lembre: svd retorna Vh = V^T).",
                                    "Incluir colunas/linhas além de r."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e verificar a aproximação reduzida A_r = U_r Σ_r V_r^T",
                                  "subSteps": [
                                    "Compute A_r = U_r @ Σ_r @ V_r.T.",
                                    "Calcule o erro de reconstrução: err = np.linalg.norm(A - A_r, 'fro') / np.linalg.norm(A, 'fro').",
                                    "Verifique se err ≈ 0 (ou < tol relativa) para rank baixo.",
                                    "Compare com rank full se aplicável.",
                                    "Gere relatório com r, err e visualização de A vs A_r."
                                  ],
                                  "verification": "||A - A_r||_F / ||A||_F < 1e-8 para precisão numérica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "NumPy para multiplicação matricial",
                                    "Função norm"
                                  ],
                                  "tips": "Use norma Frobenius para erro relativo em SVD.",
                                  "learningObjective": "Validar a qualidade da aproximação reduzida.",
                                  "commonMistakes": [
                                    "Esquecer .T em V_r.T.",
                                    "Usar norma errada (L2 vs Frobenius para SVD)."
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = np.array([[1, 1, 1], [1, 1, 0], [1, 1, 0], [1, 0, 0]]).T (4x3, rank 2), SVD dá σ ≈ [2.3, 1.4, 1e-15]. Com tol=1e-10, r=2. U_2 (3x2), Σ_2 (2x2), V_2 (4x2). A_r reconstrói A com err < 1e-12.",
                              "finalVerifications": [
                                "Rank r determinado corretamente com σ_r > tol > σ_{r+1}.",
                                "Dimensões de U_r (m×r), Σ_r (r×r), V_r (n×r) corretas.",
                                "A_r = U_r Σ_r V_r^T satisfaz ||A - A_r||_F / ||A||_F < tol relativa.",
                                "SVD original reconstrói A perfeitamente.",
                                "Plot de σ_i mostra corte claro em r.",
                                "Teste com matriz de rank exato 1 confirma r=1."
                              ],
                              "assessmentCriteria": [
                                "Precisão na escolha de tol e determinação de r (90% acerto em exemplos).",
                                "Correta extração e dimensões das matrizes reduzidas.",
                                "Cálculo exato de A_r e verificação de erro < 1e-10.",
                                "Interpretação numérica do rank vs rank algébrico.",
                                "Eficiência computacional (econômica quando apropriado).",
                                "Relatório claro com plots e valores."
                              ],
                              "crossCurricularConnections": [
                                "Processamento de Imagens: Compressão via SVD reduzida (reduz armazenamento).",
                                "Machine Learning: PCA como SVD em matrizes centradas (redução dimensional).",
                                "Física Computacional: Modos principais em simulações (ex: mecânica dos fluidos).",
                                "Estatística: Análise de componentes principais para dados multivariados.",
                                "Ciência de Dados: Sistemas de recomendação (Netflix prize usa SVD baixa rank)."
                              ],
                              "realWorldApplication": "Em recomendação de produtos (Amazon), SVD reduzida aproxima matriz usuário-item esparsa para prever ratings ausentes, reduzindo dimensões de milhões para centenas, acelerando inferência em larga escala."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.3.2",
                            "name": "Aplicar SVD reduzida em matrizes de ranks variados",
                            "description": "Analisar diferenças em full rank (r = min(m,n)), rank deficiente (r < min(m,n)), e aplicações como detecção de dependências lineares, compressão de imagens e análise de sensibilidade em sistemas lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e computação da SVD reduzida",
                                  "subSteps": [
                                    "Revise a SVD completa: A = U Σ V^T, onde Σ tem dimensões m x n.",
                                    "Entenda a SVD econômica: remove linhas/cols zero em Σ.",
                                    "Defina SVD reduzida: para rank r, U (m x r), Σ (r x r), V (n x r).",
                                    "Aprenda a extrair componentes: identifique os r maiores valores singulares não-zero.",
                                    "Pratique computando manualmente para matriz 2x2 full rank."
                                  ],
                                  "verification": "Verifique se A ≈ U_r Σ_r V_r^T com erro mínimo e dimensões corretas (r = rank(A)).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Álgebra Linear Computacional",
                                    "Python com NumPy/SciPy",
                                    "Calculadora matricial"
                                  ],
                                  "tips": "Sempre ordene valores singulares em ordem decrescente para identificar os r principais.",
                                  "learningObjective": "Diferenciar SVD completa, econômica e reduzida, e saber como computá-la.",
                                  "commonMistakes": [
                                    "Incluir valores singulares zero em Σ_r",
                                    "Confundir dimensões de U e V na forma reduzida"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar SVD reduzida em matrizes de posto completo (full rank)",
                                  "subSteps": [
                                    "Selecione matriz A m x n com r = min(m,n).",
                                    "Compute SVD completa ou econômica usando software.",
                                    "Extraia Σ_r como diagonal completa sem zeros.",
                                    "Reconstrua A e verifique A = U_r Σ_r V_r^T exatamente.",
                                    "Analise: colunas de U_r formam base ortonormal do espaço coluna."
                                  ],
                                  "verification": "Reconstrução exata de A e verificação de ortogonalidade (U_r^T U_r = I_r).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python/Jupyter Notebook",
                                    "Matriz exemplo 4x3 full rank",
                                    "Documentação SciPy svd"
                                  ],
                                  "tips": "Use np.linalg.svd(A, full_matrices=False) para SVD econômica inicial.",
                                  "learningObjective": "Aplicar SVD reduzida corretamente em casos full rank e validar reconstrução.",
                                  "commonMistakes": [
                                    "Usar full_matrices=True desnecessariamente",
                                    "Ignorar verificação de ortogonalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar SVD reduzida em matrizes de posto deficiente",
                                  "subSteps": [
                                    "Selecione matriz A com r < min(m,n), ex: com linhas dependentes.",
                                    "Compute rank(A) via SVD completa (número de singulares > epsilon).",
                                    "Extraia apenas top-r: U_r (m x r), Σ_r (r x r), V_r (n x r).",
                                    "Reconstrua aproximação e note perda de informação nas direções nulas.",
                                    "Compare com full rank: dimensões menores em rank deficiente."
                                  ],
                                  "verification": "Erro de reconstrução baixo nas direções principais; rank(U_r) = r.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com NumPy",
                                    "Matrizes exemplo rank deficiente (ex: 3x3 com det=0)",
                                    "Gráficos de singular values"
                                  ],
                                  "tips": "Defina threshold epsilon=1e-10 para valores singulares 'zero'.",
                                  "learningObjective": "Identificar e aplicar SVD reduzida em rank deficiente, destacando diferenças.",
                                  "commonMistakes": [
                                    "Incluir singulares próximos de zero",
                                    "Não detectar dependências lineares via V_r"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar diferenças e aplicações práticas",
                                  "subSteps": [
                                    "Compare full rank vs deficiente: dimensões, info perdida, eficiência.",
                                    "Aplique em detecção de dependências: kernel via V_r cols nulas.",
                                    "Simule compressão de imagem: aproxime com k < r singulares.",
                                    "Analise sensibilidade: perturbações em singulares pequenos.",
                                    "Documente insights em relatório curto."
                                  ],
                                  "verification": "Relatório com exemplos numéricos e plots de singular values decay.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Imagem grayscale pequena (ex: 64x64)",
                                    "Python Matplotlib para plots",
                                    "Software SVD como MATLAB"
                                  ],
                                  "tips": "Para imagens, aplique SVD em vetores achatados ou blocos.",
                                  "learningObjective": "Analisar impactos do rank e aplicar em cenários reais como compressão e sensibilidade.",
                                  "commonMistakes": [
                                    "Ignorar normalização em imagens",
                                    "Confundir null space com range space"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere matriz A 5x3 representando pixels de imagem grayscale (rank 2 deficiente devido a redundâncias). Compute SVD reduzida (r=2): U_2 (5x2), Σ_2 (2x2), V_2 (3x2). Reconstrua com top-1 singular para compressão (reduz armazenamento de 15 para ~5 valores), preservando 90% variância.",
                              "finalVerifications": [
                                "Computa corretamente SVD reduzida para full rank e rank deficiente.",
                                "Identifica rank via valores singulares e threshold.",
                                "Reconstrói matriz com erro < 1e-10 nas direções principais.",
                                "Detecta dependências lineares via colunas de V_r.",
                                "Aplica compressão simples em dados matriciais.",
                                "Analisa sensibilidade qualitativamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na decomposição (erro de Frobenius < 1e-8).",
                                "Correta identificação de diferenças entre ranks.",
                                "Validação de ortogonalidade e reconstrução.",
                                "Profundidade na análise de aplicações.",
                                "Uso adequado de software e verificações numéricas.",
                                "Clareza em relatórios e plots."
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Compressão de dados e PCA em ML.",
                                "Processamento de Imagens: Redução dimensional em visão computacional.",
                                "Engenharia: Análise de estabilidade em sistemas dinâmicos.",
                                "Física: Análise de modos principais em vibrações.",
                                "Estatística: Análise de componentes principais."
                              ],
                              "realWorldApplication": "Compressão de imagens em JPEG2000 (mantém principais componentes), detecção de falhas em sensores (dependências lineares), análise de robustez em redes neurais lineares e redução de dimensionalidade em big data para machine learning."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.3.3",
                            "name": "Comparar formas da SVD e escolher com base no contexto",
                            "description": "Comparar completa (armazenamento total), econômica (eficiência para retangulares), reduzida (para rank baixo), e selecionar a forma adequada para aplicações como QR, mínimos quadrados e análise de condicionamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições das Formas da SVD",
                                  "subSteps": [
                                    "Estude a SVD completa: U (m x m), Σ (m x n), V (n x n)",
                                    "Analise a SVD econômica: U (m x r), Σ (r x r), V (n x r) onde r = min(m,n)",
                                    "Descreva a SVD reduzida: U (m x k), Σ (k x k), V (n x k) onde k = rank(A)",
                                    "Anote as dimensões para uma matriz A m x n com m >= n",
                                    "Compare visualmente com diagramas de blocos"
                                  ],
                                  "verification": "Escreva as dimensões exatas de U, Σ e V para cada forma em uma matriz exemplo 4x3",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas de álgebra linear",
                                    "Matriz exemplo 4x3",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use cores diferentes para U, Σ e V nos diagramas para facilitar a visualização",
                                  "learningObjective": "Dominar as definições e estruturas matriciais das três formas da SVD",
                                  "commonMistakes": [
                                    "Confundir dimensões da econômica com a reduzida",
                                    "Esquecer que Σ é diagonal em todas as formas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Comparar Requisitos de Armazenamento",
                                  "subSteps": [
                                    "Calcule o número total de elementos na SVD completa para A m x n",
                                    "Compute armazenamento da econômica:  m*r + r*r + n*r",
                                    "Calcule para reduzida: m*k + k*k + n*k com k <= r",
                                    "Compare percentuais de economia para matrizes retangulares (m >> n)",
                                    "Crie uma tabela comparativa de armazenamento"
                                  ],
                                  "verification": "Preencha tabela com armazenamento numérico para A 100x50 e rank=40",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou Python/NumPy para contagem",
                                    "Tabela em Excel ou papel"
                                  ],
                                  "tips": "Foquem em casos retangulares onde m > n para maximizar economia",
                                  "learningObjective": "Quantificar as diferenças de armazenamento entre as formas",
                                  "commonMistakes": [
                                    "Contar apenas não-zeros em Σ sem incluir zeros implícitos",
                                    "Ignorar overhead de armazenamento quadrado em V completa"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Eficiência Computacional",
                                  "subSteps": [
                                    "Discuta custo computacional de cada forma (O(m n^2) vs reduzido)",
                                    "Compare tempo de computação para SVD completa vs econômica em software como LAPACK",
                                    "Avalie impacto em multiplicações A = U Σ V^T",
                                    "Teste numericamente com código simples em Python",
                                    "Registre diferenças em tempo de execução"
                                  ],
                                  "verification": "Execute benchmark em código e anote tempos para matriz 1000x500",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Matriz gerada aleatoriamente"
                                  ],
                                  "tips": "Use %timeit no Jupyter para medições precisas",
                                  "learningObjective": "Entender trade-offs computacionais para seleção prática",
                                  "commonMistakes": [
                                    "Subestimar custo de fatoração completa em hardware limitado",
                                    "Confundir custo de SVD com custo de multiplicação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Aplicações e Contextos Específicos",
                                  "subSteps": [
                                    "Estude uso da completa em QR via SVD para sistemas quadrados",
                                    "Analise econômica para mínimos quadrados em retangulares overdetermined",
                                    "Discuta reduzida para análise de condicionamento em low-rank approximations",
                                    "Mapeie cenários: compressão (reduzida), estabilidade numérica (econômica)",
                                    "Liste prós/contras por aplicação"
                                  ],
                                  "verification": "Classifique 3 aplicações (QR, LS, cond.) com a forma ideal e justificativa",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Referências: Golub-Van Loan",
                                    "Exemplos de problemas reais"
                                  ],
                                  "tips": "Pense em precisão numérica: completa preserva info, reduzida aproxima",
                                  "learningObjective": "Associar formas da SVD a aplicações concretas",
                                  "commonMistakes": [
                                    "Recomendar reduzida sem verificar rank exato",
                                    "Usar completa em big data por hábito"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar Seleção Baseada em Contexto",
                                  "subSteps": [
                                    "Dado cenário 1: Matriz 1M x 10K, low-rank -> escolha e justifique",
                                    "Cenário 2: QR exata para n x n -> forma ideal",
                                    "Cenário 3: Mínimos quadrados overdetermined -> compare opções",
                                    "Resolva 3 problemas variados e documente decisão",
                                    "Autoavalie escolhas com critérios de eficiência/precisão"
                                  ],
                                  "verification": "Submeta relatório com 3 decisões corretas justificadas",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Problemas de prática impressos",
                                    "Software SVD (MATLAB/Python)"
                                  ],
                                  "tips": "Sempre pergunte: 'Qual o rank? Tamanho? Precisão necessária?'",
                                  "learningObjective": "Desenvolver intuição para escolher SVD ótima por contexto",
                                  "commonMistakes": [
                                    "Escolher completa por 'segurança' ignorando custo",
                                    "Não considerar rank aproximado"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma matriz de dados de sensores 5000x100 (m>>n, rank~50), use SVD reduzida para análise de condicionamento: compute σ_max/σ_min nos 50 singulares principais, economizando 90% armazenamento vs completa, ideal para detecção de falhas em tempo real.",
                              "finalVerifications": [
                                "Explicar diferenças dimensionais e de armazenamento com exemplo numérico",
                                "Selecionar forma correta para 3 cenários (QR, LS, low-rank) com justificativa",
                                "Calcular economia de espaço para matriz retangular grande",
                                "Benchmark tempo de computação em código real",
                                "Identificar quando reduzida falha (rank full)",
                                "Mapear aplicações a formas específicas"
                              ],
                              "assessmentCriteria": [
                                "Precisão nas dimensões e fórmulas de armazenamento (20%)",
                                "Correção nas comparações computacionais (20%)",
                                "Qualidade das justificativas para escolhas contextuais (25%)",
                                "Profundidade em aplicações práticas (20%)",
                                "Clareza em tabelas/diagramas/código (10%)",
                                "Identificação de erros comuns evitados (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação eficiente em NumPy/SciPy para ML",
                                "Estatística: PCA e redução dimensional via SVD reduzida",
                                "Engenharia: Análise de condicionamento em controle e signals",
                                "Física: Decomposição espectral em mecânica quântica",
                                "Economia: Modelos de recomendação em e-commerce"
                              ],
                              "realWorldApplication": "Em sistemas de recomendação Netflix-like, SVD reduzida em matrizes usuário-item gigantes (milhões x milhares) permite fatoração low-rank eficiente para predições, reduzindo armazenamento de TB para GB e acelerando inferência em produção."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.4",
                    "name": "Algoritmos Numéricos para SVD",
                    "description": "Métodos computacionais clássicos, como o algoritmo de Golub-Reinsch e baseados em QR iterativo.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.4.1",
                        "name": "Redução a Forma Bidiagonal",
                        "description": "Processo inicial nos algoritmos clássicos de SVD, como o de Golub-Reinsch, que utiliza transformações ortogonais (reflexões de Householder) para reduzir uma matriz m x n arbitrária a uma forma bidiagonal superior, preservando os valores singulares.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.1.1",
                            "name": "Compreender o papel da bidiagonalização no SVD",
                            "description": "Explicar como a redução a bidiagonal permite simplificar o problema de SVD para iterações eficientes, relacionando com a preservação de singularidades via similaridade ortogonal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de SVD e Matrizes Bidiagonais",
                                  "subSteps": [
                                    "Defina SVD: A = U Σ V^T onde U e V são ortogonais e Σ diagonal.",
                                    "Explique o que é uma matriz bidiagonal: não-zero apenas na diagonal principal e subdiagonal (ou superdiagonal).",
                                    "Discuta por que SVD completo é computacionalmente caro para matrizes grandes (O(n^3)).",
                                    "Introduza a ideia de reduzir A a forma bidiagonal B = P^T A Q, com P e Q ortogonais.",
                                    "Verifique singularidades: σ_i(A) = σ_i(B) pois similaridade ortogonal preserva valores singulares."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos chave e desenhe uma matriz bidiagonal de exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear Numérica (Golub & Van Loan)",
                                    "Bloco de notas",
                                    "Calculadora ou Python com NumPy"
                                  ],
                                  "tips": "Use diagramas para visualizar a estrutura bidiagonal; foque na preservação de normas.",
                                  "learningObjective": "Entender os componentes básicos de SVD e o formato bidiagonal como simplificação.",
                                  "commonMistakes": [
                                    "Confundir bidiagonal com diagonal",
                                    "Ignorar que P e Q preservam singularidades"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Processo de Bidiagonalização",
                                  "subSteps": [
                                    "Descreva o algoritmo de Householder para redução a bidiagonal: aplique reflexões para zerar elementos abaixo da subdiagonal.",
                                    "Implemente mentalmente em uma matriz 3x2: elimine colunas uma a uma.",
                                    "Discuta rotações Givens como alternativa para elementos específicos.",
                                    "Calcule explicitamente P e Q como produtos de Householder/Givens.",
                                    "Confirme: B = P^T A Q tem a mesma norma de Frobenius e valores singulares de A."
                                  ],
                                  "verification": "Aplique o processo em uma matriz 3x2 manualmente e verifique ||A||_F = ||B||_F.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software MATLAB/Python para verificação opcional",
                                    "Referência: Seção 5.4 de Golub"
                                  ],
                                  "tips": "Comece com matrizes pequenas; memorize que Householder preserva ortogonalidade.",
                                  "learningObjective": "Dominar como transformar A em B mantendo propriedades espectrais.",
                                  "commonMistakes": [
                                    "Esquecer acumular P e Q",
                                    "Não normalizar vetores Householder"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Simplificação Computacional no SVD Bidiagonal",
                                  "subSteps": [
                                    "Explique QR iteration para SVD bidiagonal: iterações convergem para Σ diagonal.",
                                    "Descreva divide-and-conquer ou Golub-Kahan-Lanczos para eficiência O(n^2).",
                                    "Compare complexidade: SVD full O(n^3) vs. bidiag O(n^2) + bidiagonalização O(n^3) mas dominante para n grande.",
                                    "Relacione: SVD(A) = P * SVD(B) * Q^T.",
                                    "Discuta estabilidade numérica devido a transformações ortogonais."
                                  ],
                                  "verification": "Esboce o fluxo: A → B → SVD(B) → SVD(A) e liste economias computacionais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo 'Computing the SVD' de Demmel",
                                    "Pseudocódigo de algoritmos SVD"
                                  ],
                                  "tips": "Pense em iterações como deflação para singularidades zero.",
                                  "learningObjective": "Compreender por que bidiagonalização acelera SVD iterativamente.",
                                  "commonMistakes": [
                                    "Subestimar custo da bidiagonalização inicial",
                                    "Confundir com eigen-decomposição"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Preservação e Eficiência Geral",
                                  "subSteps": [
                                    "Prove teoricamente: valores singulares invariantes sob multiplicação ortogonal (‖Px‖ = ‖x‖).",
                                    "Simule numéricamente: compare svd(A) e svd(P^T A Q) em software.",
                                    "Discuta aplicações: acelera SVD em PCA, compressão de imagens.",
                                    "Avalie trade-offs: custo upfront vs. ganhos em iterações.",
                                    "Conclua o papel pivotal: ponte entre SVD full e computação prática."
                                  ],
                                  "verification": "Responda: 'Por que bidiag é essencial para SVD eficiente?' em parágrafo coeso.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python/Jupyter com numpy.linalg.svd",
                                    "Matriz de teste aleatória"
                                  ],
                                  "tips": "Use np.allclose para verificar igualdade numérica de singular values.",
                                  "learningObjective": "Integrar conceitos para explicar o 'papel' da bidiagonalização holisticamente.",
                                  "commonMistakes": [
                                    "Ignorar acúmulo de P/Q para reconstruir U/V",
                                    "Não considerar estabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 2], [3, 4], [5, 0]] (3x2). Aplique Householder para obter B bidiagonal. Compute SVD(B) via QR iteration, então SVD(A) = P * SVD(B) * Q^T. Verifique singular values iguais (~6.89, 1.11) e use para rank revelation.",
                              "finalVerifications": [
                                "Explicar em palavras próprias como bidiag simplifica SVD.",
                                "Demonstrar preservação de singular values com prova simples.",
                                "Comparar complexidades O(n^3) vs. método bidiag.",
                                "Aplicar em matriz exemplo e verificar numericamente.",
                                "Discutir por que ortogonalidade é crucial.",
                                "Identificar quando método é preferível (matrizes retangulares grandes)."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: correto entendimento de preservação via ortogonalidade (30%)",
                                "Profundidade técnica: descrição precisa de Householder/Givens (25%)",
                                "Análise computacional: comparação de custos e eficiência (20%)",
                                "Exemplo prático: cálculo correto e verificação (15%)",
                                "Clareza explicativa: linguagem acessível e lógica (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementar em NumPy/SciPy (svd via LAPACK usa bidiag).",
                                "Física Computacional: Análise de dados em simulações (e.g., espectroscopia).",
                                "Machine Learning: PCA/SVD para redução dimensional eficiente.",
                                "Engenharia: Processamento de sinais (filtragem via SVD bidiag).",
                                "Estatística: Inferência em dados multivariados."
                              ],
                              "realWorldApplication": "Na compressão de imagens JPEG2000 ou análise de dados genômicos, SVD eficiente via bidiagonalização permite decompor matrizes gigantes (e.g., 10k x 10k) em minutos, revelando padrões latentes para denoising ou redução de dimensionalidade em tempo real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.2",
                            "name": "Implementar reflexões de Householder para bidiagonalização",
                            "description": "Construir e aplicar sequências de reflexões de Householder para zerar elementos abaixo da diagonal principal e superdiagonal em uma matriz, gerando as matrizes ortogonais U e V iniciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar teoria das reflexões de Householder e preparar implementação básica",
                                  "subSteps": [
                                    "Estude a definição de reflexão de Householder: H = I - 2uu^T / ||u||^2, onde u é vetor escolhido para zerar componentes desejadas.",
                                    "Revise como escolher u para zerar elementos abaixo de uma posição pivô em uma coluna de uma matriz A.",
                                    "Implemente uma função para computar o vetor u a partir de um subvetor x, usando norma euclidiana e evitando cancelamento numérico com sinal ajustado.",
                                    "Teste a função u em um vetor simples de 3 elementos para zerar o segundo e terceiro.",
                                    "Implemente a aplicação de H em uma matriz: multiplicação à esquerda para colunas."
                                  ],
                                  "verification": "Execute a função em um vetor teste e verifique se Hx tem os elementos abaixo do pivô zerados (tolerância 1e-10).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com NumPy",
                                    "Documentação NumPy para np.linalg.norm e np.outer",
                                    "Artigo ou notes sobre Householder reflections"
                                  ],
                                  "tips": "Use np.sign(x[0]) para escolher o sinal de u e evitar cancelamento; normalize u após construção.",
                                  "learningObjective": "Compreender e codificar o vetor Householder u para reflexão que zera subcomponentes de um vetor.",
                                  "commonMistakes": [
                                    "Esquecer de normalizar u corretamente levando a H não ortogonal",
                                    "Não ajustar sinal causando overflow numérico",
                                    "Usar multiplicação matricial ineficiente em vez de atualizações in-place"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar reflexão de Householder na primeira coluna para zerar abaixo da diagonal principal",
                                  "subSteps": [
                                    "Inicialize cópias de A como matriz de trabalho B, e listas vazias para armazenar Householders U_left e V_right.",
                                    "Para a primeira coluna de B, selecione pivô em (0,0), compute u para zerar B[1:,0].",
                                    "Gere H1 = I - 2uu^T e aplique H1 à esquerda em B[0:, 0:] (atualize submatriz inteira).",
                                    "Armazene u1 para posterior uso em construção de U.",
                                    "Verifique que B[1:,0] está próximo de zero."
                                  ],
                                  "verification": "Após aplicação, np.allclose(B[1:,0], 0, atol=1e-12) deve ser True.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código do Step 1",
                                    "NumPy arrays para B, identidade via np.eye"
                                  ],
                                  "tips": "Atualize B in-place com H aplicado apenas na submatriz relevante para eficiência: B[p:, :] -= 2 * np.outer(u, np.dot(u, B[p:, :])).",
                                  "learningObjective": "Implementar a primeira transformação Householder para introduzir zeros na primeira coluna abaixo da diagonal.",
                                  "commonMistakes": [
                                    "Aplicar H apenas na coluna em vez da submatriz inteira, corrompendo zeros futuros",
                                    "Índices off-by-one no subvetor x para u",
                                    "Não copiar A inicialmente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar reflexões Householder sequenciais nas subcolunas para bidiagonal superior",
                                  "subSteps": [
                                    "Para cada coluna j de 1 a n-2: aplique Householder à esquerda para zerar B[j+1:, j] (abaixo diagonal principal).",
                                    "Para cada coluna j de 0 a n-3: aplique Householder à direita para zerar B[j, j+2:] (direita da superdiagonal).",
                                    "Armazene todos os u_left para U e u_right para V.",
                                    "Atualize B iterativamente, respeitando submatrizes triangulares inferiores/superiores.",
                                    "Monitore a forma: após todas, B deve ser upper bidiagonal."
                                  ],
                                  "verification": "B deve satisfazer: zeros abaixo diagonal principal e à direita superdiagonal (verificar com loop ou mask).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código anterior",
                                    "Loops for com slices NumPy"
                                  ],
                                  "tips": "Use funções modulares para left_householder_apply e right_householder_apply para reutilização; limite aplicações a submatrizes para estabilidade.",
                                  "learningObjective": "Executar o ciclo completo de Householder para reduzir A a bidiagonal, diferenciando aplicações esquerda/direita.",
                                  "commonMistakes": [
                                    "Confundir ordem: esquerda primeiro para colunas, direita para linhas",
                                    "Não pular iterações finais onde subvetor tem tamanho <2",
                                    "Aplicar em submatrizes erradas, destruindo zeros já criados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir matrizes ortogonais U e V e validar a decomposição",
                                  "subSteps": [
                                    "Construa U acumulando produtos de Householders à esquerda: U = I, então U = H1 H2 ... Hk.",
                                    "Similar para V à direita: V = I, V = H1^T H2^T ... (mas como Householder é simétrico, mesmo).",
                                    "Eficiência: aplique Householders aos vetores identidade ou use produto reverso.",
                                    "Verifique ortogonalidade: np.allclose(U.T @ U, np.eye(m), atol=1e-10) e similar para V.",
                                    "Confirme: np.allclose(A, U @ B @ V.T, atol=1e-8)."
                                  ],
                                  "verification": "U e V ortogonais e A ≈ U B V^T com erro pequeno.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Todos códigos prévios",
                                    "np.dot para produtos matriciais"
                                  ],
                                  "tips": "Para eficiência em código real, armazene Householders compactos e aplique em vetores; aqui construa explícito para clareza.",
                                  "learningObjective": "Formar as matrizes ortogonais U e V a partir das sequências de Householder e validar a bidiagonalização.",
                                  "commonMistakes": [
                                    "Esquecer transposta em V (direita)",
                                    "Construir produto na ordem errada (deve ser reversa)",
                                    "Baixa precisão por produtos múltiplos: use QR-like acumulação"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = np.array([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], dtype=float). Após bidiagonalização, B será upper bidiagonal como [[a, b, 0, 0], [0, c, d, 0], [0,0,0,0], [0,0,0,0]] (aprox.), com U (4x4 ortogonal) e V (4x4) tal que A = U B V^T. Implemente e plote norms de resíduos.",
                              "finalVerifications": [
                                "Matriz B é upper bidiagonal: todos elementos abaixo diagonal principal e direita superdiagonal são <1e-10.",
                                "U e V são ortogonais: ||U^T U - I||_F < 1e-8 e similar para V.",
                                "Reconstrução fiel: ||A - U @ B @ V.T||_F / ||A||_F < 1e-8.",
                                "Código executa sem erros numéricos (no NaNs ou infs).",
                                "Tempo de execução razoável para matriz 100x100 (<1s).",
                                "Teste com matrizes simétricas e não-quadradas funciona."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erro de reconstrução <1e-10 para matrizes pequenas.",
                                "Eficiência: O(n^3) flops implícito, sem loops desnecessários.",
                                "Robustez: lida com casos edge (matrizes 2x2, rank-deficient).",
                                "Clareza do código: funções modulares, comentários em passos chave.",
                                "Validações internas: checks de zeros e ortogonalidade no código.",
                                "Generalidade: funciona para m>=n ou n>=m."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Uso avançado de NumPy para álgebra linear eficiente.",
                                "Análise Numérica: Estabilidade e condicionamento de transformações ortogonais.",
                                "Física Computacional: Preparação para simulações de autovalores em mecânica quântica.",
                                "Machine Learning: Base para SVD em PCA e redução dimensional."
                              ],
                              "realWorldApplication": "Essa bidiagonalização é o primeiro passo em algoritmos SVD como Golub-Kahan, usados em compressão de imagens (Netflix), recomendação (Amazon), análise de dados genômicos e processamento de sinais em engenharia (ex: radar Doppler)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.3",
                            "name": "Executar o algoritmo de redução completo",
                            "description": "Desenvolver pseudocódigo ou código para a redução completa de uma matriz retangular a bidiagonal, verificando estabilidade numérica com exemplos de matrizes de teste.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a matriz de entrada e revisar o algoritmo de redução bidiagonal",
                                  "subSteps": [
                                    "Selecione uma matriz retangular m x n com m >= n e valores reais aleatórios ou de teste.",
                                    "Revise o pseudocódigo do algoritmo Golub-Kahan: loop sobre colunas i=1 a n-1, aplicando Householder à esquerda para zerar A(i+1:m, i), depois à direita para zerar A(i, i+1:n).",
                                    "Defina convenções: bidiagonal superior, armazenamento in-place ou cópia.",
                                    "Implemente funções auxiliares para reflexão Householder (vetor x, norma, etc.).",
                                    "Inicialize arrays para os elementos bidiagonais (diagonal e superdiagonal)."
                                  ],
                                  "verification": "Matriz de entrada carregada corretamente e funções Householder testadas em vetor unitário (residuo < 1e-10).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com NumPy/SciPy, MATLAB ou pseudocódigo em papel; matriz de teste 5x3.",
                                  "tips": "Use np.linalg.norm para precisão; armazene Householder em formato compacto para eficiência.",
                                  "learningObjective": "Compreender a estrutura do algoritmo e preparar componentes reutilizáveis.",
                                  "commonMistakes": "Esquecer de normalizar o vetor Householder; confundir índices 0-based vs 1-based."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o loop principal de redução com Householder à esquerda",
                                  "subSteps": [
                                    "Para cada coluna i de 1 a n-1: isole submatriz A(i:m, i).",
                                    "Compute o vetor Householder para zerar entradas abaixo de A(i,i).",
                                    "Aplique a reflexão à esquerda na submatriz A(i:m, i:n).",
                                    "Atualize os elementos bidiagonais: alpha_i = norma da coluna modificada.",
                                    "Armazene o vetor Householder para uso futuro se necessário."
                                  ],
                                  "verification": "Após cada iteração i, verifique que A(i+1:m, i) ≈ 0 (norma < 1e-12 * ||A||).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ambiente de programação; debugger para inspecionar submatrizes.",
                                  "tips": "Evite recomputar normas desnecessariamente; use loops vetorizados onde possível.",
                                  "learningObjective": "Dominar a aplicação de Householder para triangularização parcial.",
                                  "commonMistakes": "Aplicar Householder apenas na coluna em vez da submatriz inteira; overflow em normas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Householder à direita e completar a bidiagonalização",
                                  "subSteps": [
                                    "Para cada i, após left Householder: isole linha A(i, i:n).",
                                    "Compute Householder à direita para zerar A(i, i+2:n) (acima da superdiagonal).",
                                    "Aplique à direita na submatriz A(i:m, i:n), atualizando também linhas futuras.",
                                    "Atualize superdiagonal beta_i = |A(i, i+1)| após aplicação.",
                                    "Repita até i = n-1 ou m-1, dependendo de m vs n."
                                  ],
                                  "verification": "Forma final: A(i,i+1) ≠ 0 apenas na superdiagonal, resto zero fora da banda (norma de resíduos < 1e-10).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Mesmos do step anterior; matrizes de teste variadas (rank-deficient, ill-conditioned).",
                                  "tips": "Atualize bidiagonais imediatamente após cada aplicação para evitar acumulação de erros.",
                                  "learningObjective": "Entender a alternância left-right para preservar a bidiagonalidade.",
                                  "commonMistakes": "Não atualizar submatrizes inferiores ao aplicar right Householder; confundir left/right."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar estabilidade numérica e testar com matrizes variadas",
                                  "subSteps": [
                                    "Gere matrizes de teste: aleatória, Hilbert (ill-conditioned), rank-deficient.",
                                    "Compare com SVD built-in (np.linalg.svd) para recompor A ≈ U B V^T, cheque ||A - U B V^T|| / ||A|| < 1e-10.",
                                    "Meça flutuações: perda de ortogonalidade em U/V (||I - U^T U|| < 1e-12).",
                                    "Analise tempo de execução e escalabilidade com tamanhos crescentes.",
                                    "Documente resultados em tabela: condição numérica, erro relativo."
                                  ],
                                  "verification": "Testes passam para 3+ matrizes; gráficos de resíduos se possível.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "NumPy/SciPy para svd; Jupyter notebook para visualização.",
                                  "tips": "Use cond(A) para prever instabilidade; teste com double precision.",
                                  "learningObjective": "Avaliar robustez numérica do algoritmo implementado.",
                                  "commonMistakes": "Usar matrizes bem-condicionadas apenas; ignorar recomposição para verificação."
                                }
                              ],
                              "practicalExample": "Para matriz A = [[1,2,3],[4,5,6],[7,8,9],[10,11,12]] (4x3), após redução: B ≈ [[13.19, 2.00, 0],[0, 1.30, 1.41],[0,0,0],[0,0,0]] (bidiagonal superior), com ||A - U B V^T|| / ||A|| ≈ 1e-14.",
                              "finalVerifications": [
                                "Matriz resultante possui zeros fora da diagonal e superdiagonal.",
                                "Ortogonalidade preservada: colunas de transformadores unitárias.",
                                "Erro de recomposição < 1e-12 * ||A|| para múltiplas matrizes.",
                                "Algoritmo converge em O(m n^2) flops como esperado.",
                                "Funciona para m > n e m ≈ n.",
                                "Estável para cond(A) até 1e6."
                              ],
                              "assessmentCriteria": [
                                "Pseudocódigo/código correto e comentado (100% das etapas implementadas).",
                                "Resíduos numéricos abaixo de 1e-10 em testes padrão.",
                                "Tratamento de casos edge (zero, singular) sem crashes.",
                                "Eficiência: tempo comparável a implementações otimizadas.",
                                "Documentação inclui análise de estabilidade.",
                                "Código modular e reutilizável."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de algoritmos numéricos em Python/MATLAB.",
                                "Análise Numérica: Estabilidade e condicionamento de matrizes.",
                                "Física Computacional: SVD em análise de dados experimentais (ex: espectroscopia).",
                                "Machine Learning: Pré-processamento para PCA/Truncated SVD.",
                                "Engenharia: Compressão de sinais via bidiagonalização."
                              ],
                              "realWorldApplication": "Usado em sistemas de recomendação (Netflix: SVD para predição de ratings), processamento de imagens (compressão JPEG2000 via SVD), análise de dados genômicos (redução dimensional em PCA), e simulações físicas (modos normais em mecânica)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.2",
                        "name": "Algoritmo de Golub-Reinsch",
                        "description": "Método clássico iterativo que aplica decomposições QR sucessivas em matrizes bidiagonais para deflacionar e convergir aos valores singulares e vetores singulares.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.2.1",
                            "name": "Descrever os passos do algoritmo Golub-Reinsch",
                            "description": "Detalhar as fases de iteração QR em bidiagonais, incluindo deflação de singularidades zero ou subdiagonais pequenas, e atualização das matrizes U e V.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Redução inicial da matriz A para forma bidiagonal",
                                  "subSteps": [
                                    "Aplicar transformações Householder de esquerda para zerar elementos abaixo da diagonal principal em cada coluna.",
                                    "Aplicar transformações Householder de direita para zerar elementos acima da subdiagonal em cada linha.",
                                    "Atualizar progressivamente as matrizes U e V acumulares.",
                                    "Obter a matriz bidiagonal B = U^T A V.",
                                    "Verificar numericamente a bidiagonalidade com tolerância epsilon."
                                  ],
                                  "verification": "A matriz resultante B tem zeros fora da diagonal principal e subdiagonal; ||A - U B V^T|| < epsilon.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Matriz A de exemplo (m x n), implementações de Householder em Python/NumPy ou MATLAB.",
                                  "tips": "Use reflexões Householder para estabilidade numérica em vez de rotações Givens iniciais.",
                                  "learningObjective": "Compreender e implementar a bidiagonalização de Golub-Kahan.",
                                  "commonMistakes": "Esquecer de acumular U e V corretamente, levando a perda de ortogonalidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicialização das matrizes e parâmetros iterativos",
                                  "subSteps": [
                                    "Definir tolerância para convergência (ex: eps = 1e-12) e limite máximo de iterações (ex: 100).",
                                    "Inicializar contadores de iterações e flags de deflação.",
                                    "Normalizar a diagonal principal de B se necessário.",
                                    "Preparar acumuladores para atualizações de U e V (iniciar como identidade).",
                                    "Verificar se B já está diagonal (caso trivial)."
                                  ],
                                  "verification": "Parâmetros definidos e B normalizada; diags(B) > 0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Pseudocódigo do algoritmo, calculadora ou software para normalização.",
                                  "tips": "Escolha tolerância baseada na norma de máquina para evitar falsos positivos em deflação.",
                                  "learningObjective": "Configurar corretamente os parâmetros para estabilidade das iterações QR.",
                                  "commonMistakes": "Tolerância muito pequena causando iterações excessivas ou overflow."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Execução das iterações QR na matriz bidiagonal",
                                  "subSteps": [
                                    "Rotacionar para tornar |b_{k+1,k}| pequeno (chase da subdiagonal).",
                                    "Aplicar decomposição QR implícita na bidiagonal via rotações Givens.",
                                    "Atualizar a diagonal principal com novos valores singulares sigma_i = |d_i|.",
                                    "Aplicar as rotações Q e R acumulando em V e atualizando B.",
                                    "Incrementar contador de iterações."
                                  ],
                                  "verification": "Subdiagonal diminui monotonicamente; max(|subdiags|) reduz a cada iteração.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Implementação de rotações Givens, matriz B bidiagonal.",
                                  "tips": "Use rotações Givens para eficiência O(1) por iteração em bidiagonais.",
                                  "learningObjective": "Dominar o ciclo QR implícito para convergência quadrática aos valores singulares.",
                                  "commonMistakes": "Aplicar rotações na ordem errada, invertendo Q e R."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detecção e deflação de singularidades zero ou subdiagonais pequenas",
                                  "subSteps": [
                                    "Verificar se subdiagonal e_{k} < eps * (sigma_k + sigma_{k+1}).",
                                    "Se deflação ocorrer, definir sigma_k = |d_k| e zerar e_k.",
                                    "Pular o índice k nas iterações subsequentes (shift para próximo bloco).",
                                    "Registrar valores singulares deflados.",
                                    "Atualizar flags para fim de convergência se todo o bloco deflacionado."
                                  ],
                                  "verification": "Lista de singularidades defladas corresponde a zeros detectados; rank reduzido corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Critério de deflação de Wilkinson, exemplos numéricos.",
                                  "tips": "Deflação implícita acelera convergência; monitore norma da subdiagonal residual.",
                                  "learningObjective": "Implementar deflação para eficiência computacional em SVD esparso.",
                                  "commonMistakes": "Deflação prematura em subdiagonais pequenas mas não-zero, perdendo precisão."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Atualização final das matrizes U e V e verificação de convergência",
                                  "subSteps": [
                                    "Aplicar todas as transformações acumuladas restantes em U e V.",
                                    "Ordenar valores singulares em ordem decrescente.",
                                    "Reconstruir A ≈ U Sigma V^T e computar erro residual.",
                                    "Parar se ||subdiags|| < eps * ||diags|| ou iterações excedidas.",
                                    "Output: Sigma (valores singulares), U e V ortogonais."
                                  ],
                                  "verification": "A = U Sigma V^T com erro < 1e-10; U e V ortogonais (UU^T = I).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Matrizes U e V parciais, função de verificação de ortogonalidade.",
                                  "tips": "Sempre re-ortogonalize U e V se necessário para precisão em alto condicionamento.",
                                  "learningObjective": "Finalizar o SVD completo com garantias numéricas.",
                                  "commonMistakes": "Não ordenar Sigma, resultando em SVD não-canônico."
                                }
                              ],
                              "practicalExample": "Para A = [[3, 0], [1, 2], [0, 1]] (3x2), a bidiagonalização dá B ≈ [[3.16, 0.95], [0, 1.87], [0, 0]] após Householder. Após 5 iterações QR com deflação na última subdiagonal <1e-12, Sigma = [3.32, 1.60], com U e V tal que ||A - U Sigma V^T|| < 1e-12.",
                              "finalVerifications": [
                                "Descreve corretamente a bidiagonalização e pelo menos 3 iterações QR.",
                                "Explica deflação com critério quantitativo (eps * (sigma_k + sigma_{k+1})).",
                                "Lista atualizações de U e V em cada fase.",
                                "Implementa pseudocódigo para matriz 3x3 com erro residual <1e-10.",
                                "Identifica convergência quadrática nas subdiagonais.",
                                "Verifica ortogonalidade final de U e V."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição dos passos (bidiagonalização, QR chase, deflação).",
                                "Correção numérica no exemplo prático (erro residual baixo).",
                                "Compreensão de estabilidade (Householder vs Givens).",
                                "Eficiência: menciona O(mn^2 + n^3) complexidade.",
                                "Tratamento de casos edge (matriz já diagonal, rank deficiente).",
                                "Clareza na explicação de atualizações matriciais."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em NumPy/SciPy (svd função usa variante).",
                                "Análise de Dados: Base para PCA e redução dimensional em ML.",
                                "Processamento de Sinais: Compressão espectral e filtragem adaptativa.",
                                "Física Computacional: Análise de modos em simulações dinâmicas."
                              ],
                              "realWorldApplication": "O algoritmo Golub-Reinsch é a base para SVD em bibliotecas como LAPACK, usado em sistemas de recomendação (Netflix fatorando matrizes usuário-filme), compressão de imagens (JPEG2000), e análise de principal components em genômica para identificar padrões genéticos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.2",
                            "name": "Analisar a convergência do método",
                            "description": "Explicar a convergência quadrática para o maior valor singular e linear para os demais, usando teoremas de Golub-Kahan e critérios de parada baseados em tolerâncias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Teoremas de Golub-Kahan sobre Convergência no Algoritmo de Golub-Reinsch",
                                  "subSteps": [
                                    "Estude a formulação do algoritmo de Golub-Reinsch para SVD, focando nas iterações bidiagonais.",
                                    "Leia e anote os teoremas de Golub-Kahan que descrevem as taxas de convergência dos valores singulares.",
                                    "Identifique as condições iniciais necessárias para a convergência, como matriz bidiagonal superior.",
                                    "Derive qualitativamente por que a convergência é superlinear para valores singulares extremos.",
                                    "Compare com métodos alternativos como QR para SVD para contextualizar."
                                  ],
                                  "verification": "Resuma os teoremas em um parágrafo e explique verbalmente ou por escrito as diferenças entre convergências quadrática e linear.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Matrix Computations' de Golub e Van Loan (capítulo SVD), notas de aula sobre SVD, calculadora simbólica como SymPy.",
                                  "tips": "Use diagramas de fluxo do algoritmo para visualizar as iterações de convergência.",
                                  "learningObjective": "Dominar os fundamentos teóricos dos teoremas que sustentam a análise de convergência.",
                                  "commonMistakes": "Confundir Golub-Kahan com outros teoremas de SVD; ignorar dependência na ordenação dos valores singulares."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Convergência Quadrática para o Maior Valor Singular",
                                  "subSteps": [
                                    "Revise a definição matemática de convergência quadrática: |e_{k+1}| ≤ C |e_k|^2.",
                                    "Aplique o teorema de Golub-Kahan ao maior σ1, derivando a taxa usando resíduos das iterações.",
                                    "Simule numericamente 5-10 iterações em uma matriz 3x3 com σ1 dominante.",
                                    "Plote o erro relativo log-log para confirmar o comportamento quadrático.",
                                    "Discuta fatores que aceleram essa convergência, como deflação precoce."
                                  ],
                                  "verification": "Produza um gráfico de erro mostrando inclinação 2 no log-log, com equação derivada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/SciPy para simulação, MATLAB ou Jupyter Notebook, matriz de exemplo conhecida.",
                                  "tips": "Escolha matrizes com gap grande entre σ1 e σ2 para observação clara da quadraticidade.",
                                  "learningObjective": "Explicar e demonstrar matematicamente a convergência quadrática do maior valor singular.",
                                  "commonMistakes": "Usar tolerâncias muito pequenas causando ruído numérico; não normalizar erros corretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar a Convergência Linear para os Demais Valores Singulares",
                                  "subSteps": [
                                    "Estude a taxa linear: |e_{k+1}| ≤ ρ |e_k| com 0 < ρ < 1 para σi (i>1).",
                                    "Use teoremas de Golub-Kahan para derivar ρ baseado em gaps espectrais adjacentes.",
                                    "Implemente iterações para valores singulares intermediários em uma matriz 5x5.",
                                    "Compare numericamente linear vs. quadrática via tabelas de erro por iteração.",
                                    "Analise impacto de clusters de valores singulares próximos na lentidão da convergência."
                                  ],
                                  "verification": "Gere tabela comparativa de erros para 20 iterações, confirmando ρ ≈ constante <1.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Código Python/MATLAB com SVD iterativo, gerador de matrizes randn com singular values especificados.",
                                  "tips": "Teste com matrizes rank-deficient para exagerar diferenças de convergência.",
                                  "learningObjective": "Diferenciar e quantificar a convergência linear para valores singulares não-extremos.",
                                  "commonMistakes": "Assumir quadraticidade universal; não considerar ordenação decrescente dos σi."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir e Aplicar Critérios de Parada Baseados em Tolerâncias",
                                  "subSteps": [
                                    "Defina tolerâncias: ε_machine, ε_user para resíduos ||A - UΣV^T|| e ||σ_new - σ_old||.",
                                    "Implemente critérios de parada no código do algoritmo de Golub-Reinsch.",
                                    "Teste sensibilidade variando ε de 1e-6 a 1e-15 em matrizes condicionadas.",
                                    "Avalie trade-offs: precisão vs. custo computacional (número de iterações).",
                                    "Documente deflação e parada precoce para singular values convergidos."
                                  ],
                                  "verification": "Execute simulação com diferentes ε, reportando iterações totais e erro final.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Código fonte do algoritmo (SciPy linalg.svd equivalente iterativo), relatório em LaTeX ou Markdown.",
                                  "tips": "Monitore flops por iteração para custo real; use cond=True para matrizes mal-condicionadas.",
                                  "learningObjective": "Implementar e justificar critérios práticos de parada para eficiência numérica.",
                                  "commonMistakes": "Parada prematura por tolerância fixa sem considerar gap espectral; ignorar stagnation."
                                }
                              ],
                              "practicalExample": "Considere a matriz A = [[4,0,0],[0,3,0],[0,0,1]] (singular values 4,3,1). No algoritmo de Golub-Reinsch, σ1=4 converge quadraticamente em ~5 iterações (erro ~1e-12), σ2=3 linearmente com ρ~0.75 (20 iterações para 1e-10), σ3=1 mais devagar devido a gap pequeno. Pare com tol=1e-12 no resíduo bidiagonal.",
                              "finalVerifications": [
                                "Derivar corretamente as taxas de convergência usando teoremas de Golub-Kahan.",
                                "Simular e plotar curvas de erro confirmando quadraticidade para σ1 e linearidade para outros.",
                                "Implementar critérios de parada que param em <50 iterações para matriz 10x10 com tol=1e-10.",
                                "Explicar impacto de gaps espectrais em uma apresentação de 5 minutos.",
                                "Comparar com SVD full (ex: np.linalg.svd) em precisão e tempo para matriz real.",
                                "Identificar e corrigir stagnation em simulação com valores singulares próximos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação teórica (80%+ acerto em fórmulas de ρ e quadraticidade).",
                                "Qualidade dos gráficos/simulações (curvas log-log claras, ρ estimado <5% erro).",
                                "Eficiência dos critérios de parada (iterações < teóricas +20%, erro < tol).",
                                "Profundidade na discussão de fatores influenciadores (gaps, conditioning).",
                                "Clareza na explicação oral/escrita de convergências diferenciadas.",
                                "Integração prática com código reproduzível e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Estabilidade e taxas de convergência em métodos iterativos gerais.",
                                "Programação Científica: Implementação eficiente em Python/MATLAB para SVD.",
                                "Estatística: Aplicação em PCA onde convergência afeta redução dimensional.",
                                "Otimização: Paralelos com gradiente descendente em taxas lineares/quadráticas."
                              ],
                              "realWorldApplication": "Em processamento de imagens (compressão JPEG2000 via SVD aproximado), convergência rápida do σ1 permite retenção de 90% energia com poucas iterações, reduzindo tempo de codificação em apps de ML como recomendação Netflix (fatores latentes) ou detecção de fraudes (PCA em dados transacionais)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.3",
                            "name": "Implementar iterações QR para SVD bidiagonal",
                            "description": "Codificar o loop iterativo com Givens rotations para QR em bidiagonais, acumulando transformações e testando em matrizes de dimensões variadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o algoritmo de iterações QR para SVD em matrizes bidiagonais",
                                  "subSteps": [
                                    "Estude a estrutura de uma matriz bidiagonal superior e seu papel no algoritmo Golub-Reinsch.",
                                    "Revise o conceito de iterações QR: aplicar QR decomposition repetidamente até convergência.",
                                    "Compreenda o uso de rotações de Givens para zeroar subdiagonais em bidiagonais.",
                                    "Analise como as iterações diagonalisam a matriz bidiagonal, aproximando os valores singulares.",
                                    "Leia pseudocódigo do algoritmo para identificar loops e condições de parada."
                                  ],
                                  "verification": "Resuma em um diagrama ou pseudocódigo próprio o fluxo do algoritmo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação NumPy/SciPy SVD",
                                    "Artigo Golub-Reinsch",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Comece com matrizes 2x2 para visualizar a convergência manualmente.",
                                  "learningObjective": "Compreender os princípios teóricos das iterações QR para SVD bidiagonal.",
                                  "commonMistakes": [
                                    "Confundir bidiagonal superior com inferior",
                                    "Ignorar acumulação de transformações ortogonais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar rotação de Givens para matrizes bidiagonais",
                                  "subSteps": [
                                    "Defina uma função para calcular ângulo c e s da rotação de Givens dados elementos (a, b).",
                                    "Implemente aplicação da rotação em uma matriz 2x2: multiplicação por Q e Q^T.",
                                    "Estenda para aplicar Givens em posições específicas de uma matriz bidiagonal maior.",
                                    "Teste a função em pares de elementos para garantir que zeroa o subdiagonal corretamente.",
                                    "Verifique ortogonalidade da matriz Givens gerada (Q Q^T = I)."
                                  ],
                                  "verification": "Aplique em uma matriz 2x2 e confirme que o off-diagonal é zero com norma residual < 1e-10.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python 3",
                                    "NumPy",
                                    "Editor de código (VSCode ou Jupyter)"
                                  ],
                                  "tips": "Use np.hypot(a,b) para estabilidade numérica no cálculo de r.",
                                  "learningObjective": "Codificar eficientemente rotações de Givens para eliminação em bidiagonais.",
                                  "commonMistakes": [
                                    "Divisão por zero em casos de b=0",
                                    "Perda de precisão em ângulos próximos de 90 graus"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Codificar o loop iterativo de iterações QR",
                                  "subSteps": [
                                    "Inicialize contadores de iterações e critérios de convergência (ex: max_iter=100, tol=1e-12).",
                                    "No loop principal, aplique Givens da direita para zeroar subdiagonais de baixo para cima.",
                                    "Aplique as mesmas rotações da esquerda para atualizar a bidiagonal.",
                                    "Implemente perseguição de bulges: aplique rotações subsequentes para manter bidiagonalidade.",
                                    "Monitore redução na subdiagonal e pare quando ||B_{i,i+1}|| < tol * ||diag(B)||."
                                  ],
                                  "verification": "Execute 10 iterações em uma matriz de teste e plote a evolução da subdiagonal.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "NumPy para operações matriciais",
                                    "Matplotlib para plots de convergência"
                                  ],
                                  "tips": "Vetorize operações quando possível, mas priorize clareza no loop.",
                                  "learningObjective": "Implementar o núcleo iterativo do algoritmo QR para SVD.",
                                  "commonMistakes": [
                                    "Não perseguir bulges corretamente, perdendo bidiagonalidade",
                                    "Loop infinito por critério de parada inadequado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Acumular transformações e testar em dimensões variadas",
                                  "subSteps": [
                                    "Inicialize matrizes U e V identidade com dimensões originais da matriz A.",
                                    "Atualize U e V multiplicando pelas rotações Givens acumuladas em cada sweep.",
                                    "Após convergência, extraia valores singulares da diagonal da B final.",
                                    "Teste com matrizes bidiagonais 3x3, 5x5 e 10x10 geradas aleatoriamente.",
                                    "Compare com np.linalg.svd() para validar precisão (erro < 1e-8)."
                                  ],
                                  "verification": "Para uma matriz conhecida, os valores singulares coincidem com SVD padrão.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "SciPy para SVD de referência",
                                    "Gerador de matrizes aleatórias bidiagonais"
                                  ],
                                  "tips": "Use laevy shifts para acelerar convergência em casos reais.",
                                  "learningObjective": "Completar implementação com acumulação e validação robusta.",
                                  "commonMistakes": [
                                    "Esquecer de atualizar U/V corretamente",
                                    "Testar apenas em dimensões pequenas"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente o algoritmo em Python para a matriz bidiagonal superior B (3x2): [[4.0, 3.0, 0.0], [1.0, 0.0, 1.0], [0.0, 0.0, 0.0]]. Após 20 iterações, deve convergir para singular values ≈ [4.47, 0.89], com U e V ortogonais.",
                              "finalVerifications": [
                                "A diagonal final contém valores singulares com erro relativo < 1e-10 vs. SVD padrão.",
                                "Matrizes U e V são ortogonais (U^T U ≈ I, V^T V ≈ I).",
                                "A reconstrução A ≈ U Σ V^T tem norma do erro < 1e-8.",
                                "O algoritmo converge em < 50 iterações para matrizes até 20x20.",
                                "Funciona corretamente para matrizes quadradas e retangulares bidiagonais.",
                                "Não há overflow/underflow em testes com escalas variadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erro em singular values < 1e-10.",
                                "Eficiência: tempo de execução escalável para n até 100.",
                                "Robustez: lida com casos degenerados (zero subdiagonal).",
                                "Clareza do código: bem comentado e modular.",
                                "Validação completa: testes unitários para cada componente.",
                                "Estabilidade: ausência de perda de precisão em iterações."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica (Python/NumPy para operações lineares)",
                                "Análise Numérica (estabilidade de algoritmos iterativos)",
                                "Processamento de Sinais (SVD em filtros e compressão)",
                                "Machine Learning (SVD em PCA e redução dimensional)"
                              ],
                              "realWorldApplication": "Essas iterações QR são fundamentais no algoritmo Golub-Reinsch para SVD eficiente, usado em compressão de imagens (JPEG2000), sistemas de recomendação (Netflix), análise de PCA em dados genômicos e estabilização de sistemas de controle."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.3",
                        "name": "Algoritmos Baseados em QR Iterativo e Análise",
                        "description": "Variações modernas e clássicas de métodos QR iterativos para SVD, incluindo análise de sensibilidade numérica e relação com decomposição QR e quadrados mínimos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.3.1",
                            "name": "Comparar variações do QR iterativo",
                            "description": "Discutir diferenças entre Golub-Reinsch clássico, versões com shifts e métodos como divide-and-conquer, destacando eficiência para matrizes grandes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Algoritmo QR Iterativo Clássico (Golub-Reinsch)",
                                  "subSteps": [
                                    "Ler a definição formal do algoritmo Golub-Reinsch para SVD via iterações QR.",
                                    "Estudar os passos principais: computar QR, multiplicar por A, deflação de singular values.",
                                    "Implementar pseudocódigo e analisar complexidade O(mn^2) por iteração.",
                                    "Visualizar o processo de deflação em uma matriz pequena (ex: 3x2).",
                                    "Executar exemplo numérico manual para matriz 4x3."
                                  ],
                                  "verification": "Implementar o algoritmo em Python e verificar convergência para uma matriz conhecida.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Matrix Computations' de Golub e Van Loan (Cap. 8)",
                                    "Python com NumPy/SciPy",
                                    "Pseudocódigo de referência"
                                  ],
                                  "tips": "Comece com matrizes pequenas para depurar; foque na deflação correta para evitar loops infinitos.",
                                  "learningObjective": "Compreender os fundamentos e limitações do QR clássico para SVD.",
                                  "commonMistakes": "Ignorar a deflação de singular values zero; confundir com QR para autovalores."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Variações com Shifts",
                                  "subSteps": [
                                    "Explicar o papel dos shifts de Wilkinson para acelerar convergência.",
                                    "Comparar QR sem shifts vs. com shifts em termos de número de iterações.",
                                    "Estudar implementação: shift = sigma^2 onde sigma é aproximação do singular value.",
                                    "Simular em código: aplicar shifts em iterações subsequentes.",
                                    "Avaliar estabilidade numérica e impacto em precisão."
                                  ],
                                  "verification": "Rodar simulações comparativas e medir iterações até convergência (tolerância 1e-12).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Artigo original de Golub-Reinsch (1969)",
                                    "SciPy source code para svd",
                                    "Jupyter Notebook para testes"
                                  ],
                                  "tips": "Use shifts adaptativos baseados em trace(A_k^T A_k)/n para melhores resultados iniciais.",
                                  "learningObjective": "Identificar como shifts melhoram eficiência sem sacrificar precisão.",
                                  "commonMistakes": "Aplicar shifts fixos em vez de adaptativos; superestimar aceleração em matrizes densas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Método Divide-and-Conquer para QR Iterativo",
                                  "subSteps": [
                                    "Descrever o paradigma divide-and-conquer: dividir bidiagonal em subproblemas.",
                                    "Estudar recursão: SVD de blocos + rotação para singular values médios.",
                                    "Analisar complexidade: O(n^2 log n) vs. O(n^3) do clássico para n grande.",
                                    "Implementar outline em pseudocódigo e testar em matriz bidiagonal.",
                                    "Comparar com QR clássico em termos de memória e paralelizabilidade."
                                  ],
                                  "verification": "Implementar versão simplificada e comparar flops com benchmark teórico.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "LAPACK documentation (xsvdc)",
                                    "Paper 'A Divide-and-Conquer Algorithm for the Unitary Eigenproblem' de Cuppen",
                                    "MATLAB/Python LAPACK wrappers"
                                  ],
                                  "tips": "Visualize a árvore de recursão para matrizes 8x8; priorize casos simétricos para simplicidade.",
                                  "learningObjective": "Dominar a estrutura recursiva e vantagens para matrizes grandes.",
                                  "commonMistakes": "Confundir com divide-and-conquer para eigenvalues; ignorar overhead de rotação de blocos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Eficiência e Trade-offs para Matrizes Grandes",
                                  "subSteps": [
                                    "Compilar tabela: flops, iterações, memória para clássico, shifts, divide-and-conquer.",
                                    "Executar benchmarks em matrizes 1000x1000 (densa/esparsa).",
                                    "Discutir cenários: clássico para pequenas, shifts para médias, D&C para grandes.",
                                    "Analisar estabilidade: cond number impacto e erros de arredondamento.",
                                    "Concluir recomendações baseadas em tamanho e hardware."
                                  ],
                                  "verification": "Gerar relatório com gráficos de tempo vs. tamanho da matriz (n=100 a 5000).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python (NumPy, SciPy, timeit)",
                                    "Cluster ou Google Colab para matrizes grandes",
                                    "Tabela comparativa template"
                                  ],
                                  "tips": "Use matrizes aleatórias com np.random.randn; normalize tempos por flops teóricos.",
                                  "learningObjective": "Avaliar criticamente variações para seleção ótima em aplicações reais.",
                                  "commonMistakes": "Testar apenas matrizes quadradas; negligenciar overhead de cache em benchmarks."
                                }
                              ],
                              "practicalExample": "Implemente as três variações em Python para SVD de uma matriz 2000x1000 de dados de imagem (ex: MNIST flatten). Meça tempo de execução, precisão (comparado a np.linalg.svd) e plote curvas de convergência. Observe que divide-and-conquer é 3x mais rápido para n>1000.",
                              "finalVerifications": [
                                "Explicar com precisão as diferenças em passos algorítmicos entre as variações.",
                                "Identificar corretamente a complexidade assintótica de cada método.",
                                "Demonstrar via benchmark que divide-and-conquer escala melhor para n>500.",
                                "Discutir impactos de shifts na convergência com exemplo numérico.",
                                "Listar 3 cenários onde cada variação é preferível.",
                                "Verificar estabilidade numérica em matrizes mal-condicionadas."
                              ],
                              "assessmentCriteria": [
                                "Profundidade na descrição de cada algoritmo (pseudocódigo incluso).",
                                "Precisão quantitativa em comparações de complexidade e benchmarks.",
                                "Análise crítica de trade-offs (tempo vs. precisão vs. memória).",
                                "Uso de evidências empíricas (benchmarks com dados reais).",
                                "Clareza na identificação de aplicações ótimas por tamanho de matriz.",
                                "Ausência de erros conceituais (ex: confundir SVD com EVD)."
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Implementação numérica e otimização de algoritmos (LAPACK).",
                                "Machine Learning: SVD em PCA e redução dimensional para big data.",
                                "Análise Numérica: Estabilidade e erros de propagação em floating-point.",
                                "Processamento de Sinais: Compressão via SVD em imagens/áudio."
                              ],
                              "realWorldApplication": "Em sistemas de recomendação (Netflix), SVD via QR divide-and-conquer processa matrizes usuário-item de milhões de linhas rapidamente, permitindo fatorização em tempo real para sugestões personalizadas; shifts aceleram convergência em dados esparsos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.3.2",
                            "name": "Avaliar sensibilidade numérica da SVD",
                            "description": "Analisar perturbações em valores singulares via análise de Wedin, relacionando com condição da matriz e estabilidade de algoritmos clássicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos da SVD e perturbações em matrizes",
                                  "subSteps": [
                                    "Estudar a decomposição SVD: A = U Σ V^T, identificando valores singulares σ_i.",
                                    "Analisar perturbações relativas: definir ||E|| / ||A|| para matrizes perturbadas A + E.",
                                    "Explorar impactos iniciais em valores singulares perturbados.",
                                    "Derivar bounds básicos para perturbações em σ_i usando normas.",
                                    "Implementar SVD em software para matrizes pequenas."
                                  ],
                                  "verification": "Computar SVD de uma matriz perturbada e comparar σ_i originais vs. perturbados.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro de Álgebra Linear Numérica (Golub/Van Loan), MATLAB/Python (NumPy/SciPy)",
                                  "tips": "Use normas Frobenius para simplificar cálculos iniciais.",
                                  "learningObjective": "Compreender como perturbações afetam SVD de forma qualitativa.",
                                  "commonMistakes": "Confundir perturbações em σ_i com as em autovalores."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar a análise de Wedin para bounds em subespaços",
                                  "subSteps": [
                                    "Ler teorema de Wedin: bounds para sin Θ entre subespaços de A + E e A.",
                                    "Definir gaps singulares e condições para aplicação.",
                                    "Derivar bounds para perturbações em valores singulares σ_i.",
                                    "Analisar premissas: separação de singular values.",
                                    "Provar um caso simples para k=1 (menor singular value)."
                                  ],
                                  "verification": "Reproduzir proof de Wedin para uma matriz diagonal perturbada.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Artigo original de Wedin (1972), notas de aula de Álgebra Numérica",
                                  "tips": "Foque em desigualdades de Davis-Kahan como base.",
                                  "learningObjective": "Aplicar teorema de Wedin para estimar erros em singular values.",
                                  "commonMistakes": "Ignorar gap entre singular values adjacentes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar sensibilidade com condição numérica da matriz",
                                  "subSteps": [
                                    "Definir número de condição κ(A) = σ_max / σ_min.",
                                    "Mostrar que bounds de Wedin escalam com κ(A).",
                                    "Analisar amplificação de erros por κ grande.",
                                    "Comparar com SVD de matrizes bem/ mal condicionadas.",
                                    "Calcular numericamente κ e bounds para exemplos."
                                  ],
                                  "verification": "Para matriz A com κ=10^6, verificar se erro em σ_min ~ κ * ||E||.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Software numérico (MATLAB eigvals), exemplos de matrizes Hilber",
                                  "tips": "Use log-scale para visualizar amplificação.",
                                  "learningObjective": "Quantificar sensibilidade via κ(A) nos bounds de Wedin.",
                                  "commonMistakes": "Confundir condição com rank da matriz."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar estabilidade de algoritmos clássicos para SVD",
                                  "subSteps": [
                                    "Revisar algoritmos QR iterativo e bidiagonalização (Golub-Kahan).",
                                    "Analisar estabilidade backward: erro ~ u * κ(A).",
                                    "Comparar com bounds de Wedin para forward stability.",
                                    "Simular erros de arredondamento em implementações.",
                                    "Discutir divide-and-conquer vs. QR para estabilidade."
                                  ],
                                  "verification": "Executar algoritmo QR em máquina finita e comparar com SVD exata.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Código LAPACK (dgesvd), documentação LAPACK stability",
                                  "tips": "Use eps máquina para quantificar erros.",
                                  "learningObjective": "Relacionar análise teórica com performance prática de algoritmos.",
                                  "commonMistakes": "Assumir estabilidade forward sem considerar κ."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar em exemplo numérico completo",
                                  "subSteps": [
                                    "Escolher matriz A (ex: 10x10 mal condicionada).",
                                    "Perturbar A + E com ||E|| pequeno.",
                                    "Computar SVDs e aplicar Wedin para prever erros.",
                                    "Verificar predições vs. erros reais.",
                                    "Analisar impacto em algoritmos clássicos."
                                  ],
                                  "verification": "Relatório com tabelas: bounds teóricos vs. observados (erro < 10%).",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python (SciPy SVD), Jupyter notebook",
                                  "tips": "Varie κ(A) para observar tendências.",
                                  "learningObjective": "Integrar conceitos em análise prática de sensibilidade.",
                                  "commonMistakes": "Escolha ruim de E (não aleatória unitária)."
                                }
                              ],
                              "practicalExample": "Considere A = [[1,0],[0,1e-6]], κ(A)=1e6. Perturbe E com ||E||=1e-10. Use Wedin para prever |Δσ_min| ≈ κ(A)*||E||=1e-4. Compute SVDs e verifique estabilidade do QR iterativo.",
                              "finalVerifications": [
                                "Derivar bound de Wedin para σ_1 de matriz 2x2.",
                                "Calcular κ(A) e prever amplificação de erro corretamente.",
                                "Simular perturbação e confirmar erro ≤ bound teórico.",
                                "Explicar por que QR é estável backward apesar de κ grande.",
                                "Identificar gap insuficiente em exemplo e ajustar análise.",
                                "Comparar estabilidade de dois algoritmos SVD clássicos."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos bounds derivados (erro <5%).",
                                "Correta relação com κ(A) em todos cálculos.",
                                "Análise qualitativa e quantitativa equilibrada.",
                                "Uso apropriado de normas e gaps singulares.",
                                "Interpretação correta de resultados numéricos.",
                                "Clareza na conexão com estabilidade algorítmica."
                              ],
                              "crossCurricularConnections": [
                                "Computação Científica: Implementação em LAPACK.",
                                "Análise Numérica: Teoria de erros e estabilidade.",
                                "Física Computacional: Sensibilidade em PCA para dados experimentais.",
                                "Engenharia: Análise de estabilidade em sistemas lineares."
                              ],
                              "realWorldApplication": "Em processamento de imagens, avaliar sensibilidade da SVD para compressão garante robustez a ruído; em finanças, analisar estabilidade de fatores de risco em modelos de portfólio via decomposições singulares."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.5",
                    "name": "Aplicações em Quadrados Mínimos e Pseudoinverso",
                    "description": "Uso da SVD para resolver sistemas lineares subdeterminados ou superdeterminados via pseudoinverso de Moore-Penrose.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.5.1",
                        "name": "Pseudoinverso de Moore-Penrose via SVD",
                        "description": "Definição e construção do pseudoinverso de Moore-Penrose de uma matriz A usando sua decomposição em valores singulares (SVD), dada por A⁺ = V Σ⁺ Uᵀ, onde Σ⁺ inverte os valores singulares não nulos e zera os demais, generalizando a inversa para matrizes retangulares ou singulares.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.1.1",
                            "name": "Compreender a definição e propriedades do pseudoinverso",
                            "description": "Explicar as quatro propriedades fundamentais que caracterizam o pseudoinverso de Moore-Penrose (A A⁺ A = A, A⁺ A A⁺ = A⁺, (A A⁺)ᵀ = A A⁺ e (A⁺ A)ᵀ = A⁺ A) e como elas se aplicam a matrizes m × n arbitrárias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Decomposição em Valores Singulares (SVD) e definição do pseudoinverso",
                                  "subSteps": [
                                    "Estude a decomposição SVD de uma matriz A m×n: A = U Σ Vᵀ, onde U e V são ortogonais e Σ é diagonal com valores singulares.",
                                    "Aprenda a definição do pseudoinverso via SVD: A⁺ = V Σ⁺ Uᵀ, onde Σ⁺ inverte os valores singulares não-nulos e zera os nulos.",
                                    "Entenda que isso funciona para matrizes arbitrárias m×n, não necessariamente quadradas ou invertíveis.",
                                    "Pratique escrevendo a fórmula para um exemplo simples 2×2.",
                                    "Discuta limitações: pseudoinverso não é único sem essas propriedades."
                                  ],
                                  "verification": "Escreva a definição de A⁺ via SVD e compute para uma matriz de exemplo simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Folha de anotações",
                                    "Calculadora ou Python (numpy.linalg.svd)",
                                    "Referência: Livro de Álgebra Linear Computacional"
                                  ],
                                  "tips": "Visualize Σ como uma 'inversão seletiva' apenas nos elementos não-nulos.",
                                  "learningObjective": "Dominar a construção do pseudoinverso a partir da SVD para qualquer matriz.",
                                  "commonMistakes": [
                                    "Confundir Σ⁺ com inversa total de Σ",
                                    "Esquecer transposições em U e V",
                                    "Aplicar SVD só a quadradas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender as propriedades idempotentes: A A⁺ A = A e A⁺ A A⁺ = A⁺",
                                  "subSteps": [
                                    "Analise a primeira propriedade: A A⁺ A = A, que mostra que A⁺ é uma 'inversa parcial à esquerda'.",
                                    "Prove usando SVD: substitua A e A⁺ e simplifique, verificando que os valores singulares não-nulos preservam A.",
                                    "Analise a segunda: A⁺ A A⁺ = A⁺, 'inversa parcial à direita'.",
                                    "Prove similarmente com SVD, notando idempotência.",
                                    "Compare com inversa comum em matrizes quadradas invertíveis."
                                  ],
                                  "verification": "Derive as duas propriedades para uma matriz rank-deficient via SVD.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel e lápis para provas",
                                    "Software como MATLAB ou Octave para verificação numérica"
                                  ],
                                  "tips": "Use propriedades de ortogonalidade: UᵀU = I, VᵀV = I para simplificar multiplicações.",
                                  "learningObjective": "Explicar e provar as propriedades que garantem idempotência do pseudoinverso.",
                                  "commonMistakes": [
                                    "Ignorar termos nulos em Σ",
                                    "Confundir ordem das multiplicações",
                                    "Não verificar para m ≠ n"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender as propriedades de simetria hermitiana: (A A⁺)ᵀ = A A⁺ e (A⁺ A)ᵀ = A⁺ A",
                                  "subSteps": [
                                    "Defina simetria hermitiana: uma matriz P tal que Pᵀ = P (para reais, simétrica).",
                                    "Prove (A A⁺)ᵀ = (V Σ⁺ Uᵀ U Σ Vᵀ)ᵀ = V Σ Uᵀ U Σ⁺ Vᵀ = A A⁺, usando ortogonalidade.",
                                    "Prove similarmente para (A⁺ A)ᵀ = A⁺ A.",
                                    "Discuta implicações: projetores ortogonais em espaços de colunas e linhas.",
                                    "Verifique numericamente com uma matriz não-simétrica."
                                  ],
                                  "verification": "Mostre algebraicamente que ambos os produtos são simétricos via SVD.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Exemplos de matrizes 3×2",
                                    "Ferramenta computacional para transposta e multiplicação"
                                  ],
                                  "tips": "Lembre que para reais, ᵀ é transposição; generalize para complexos se aplicável.",
                                  "learningObjective": "Entender por que os projetores A A⁺ e A⁺ A são ortogonais.",
                                  "commonMistakes": [
                                    "Esquecer que U e V são ortogonais",
                                    "Confundir A A⁺ com projetor em colunas de A",
                                    "Não testar transposta"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar propriedades em exemplos e matrizes arbitrárias",
                                  "subSteps": [
                                    "Escolha uma matriz m×n arbitrária, ex: A = [[1,0],[0,2],[1,1]], compute SVD e A⁺.",
                                    "Verifique numericamente as 4 propriedades com tolerância numérica.",
                                    "Analise casos especiais: full rank, rank-deficient, retangular.",
                                    "Discuta unicidade: essas 4 propriedades caracterizam unicamente A⁺.",
                                    "Resolva um sistema sobredeterminado Ax ≈ b usando A⁺."
                                  ],
                                  "verification": "Compute todas propriedades para pelo menos duas matrizes diferentes e confirme igualdade.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python com numpy (svd, pinv)",
                                    "Matrizes de teste pré-definidas"
                                  ],
                                  "tips": "Use np.allclose() para comparações numéricas devido a erros de ponto flutuante.",
                                  "learningObjective": "Aplicar e validar as propriedades em contextos práticos para matrizes gerais.",
                                  "commonMistakes": [
                                    "Não considerar tolerância numérica",
                                    "Usar pinv sem entender SVD",
                                    "Ignorar rank da matriz"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[1, 0], [0, 2], [1, 1]] (3×2, rank 2), SVD dá U (3×3), Σ (3×2), V (2×2). A⁺ = V Σ⁺ Uᵀ. Verifique A A⁺ A ≈ A e demais propriedades numericamente em Python, depois use x = A⁺ b para minimizar ||Ax - b|| em regressão.",
                              "finalVerifications": [
                                "Listar e explicar corretamente as quatro propriedades de Moore-Penrose.",
                                "Derivar pelo menos duas propriedades usando SVD.",
                                "Verificar numericamente as propriedades para uma matriz retangular.",
                                "Explicar a unicidade do pseudoinverso via essas propriedades.",
                                "Aplicar A⁺ a um problema de quadrados mínimos simples.",
                                "Discutir diferenças para matrizes invertíveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas provas das propriedades (80% correto).",
                                "Capacidade de computar SVD e A⁺ manualmente para matrizes pequenas.",
                                "Correta interpretação das propriedades idempotentes e hermitianas.",
                                "Validação numérica sem erros de implementação.",
                                "Conexão clara com aplicações em sistemas lineares.",
                                "Explicação fluida sem confusão entre termos."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação de SVD e pinv em Python/NumPy.",
                                "Estatística: Solução de regressão linear via pseudoinverso.",
                                "Machine Learning: Otimização em modelos lineares e PCA.",
                                "Engenharia: Análise de sinais e controle de sistemas.",
                                "Física Computacional: Modelagem de dados experimentais com ruído."
                              ],
                              "realWorldApplication": "O pseudoinverso é essencial em regressão linear para dados sobredeterminados, como em data science para prever preços de casas com múltiplas features, minimizando erros quadráticos em cenários onde equações não têm solução exata."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.2",
                            "name": "Calcular o pseudoinverso a partir da SVD",
                            "description": "Dada a SVD A = U Σ Vᵀ de uma matriz A, construir Σ⁺ trocando os valores singulares σ_i > 0 por 1/σ_i e zeros pelos demais, e computar A⁺ = V Σ⁺ Uᵀ manualmente para matrizes pequenas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Confirmar os componentes da decomposição SVD de A",
                                  "subSteps": [
                                    "Escreva a matriz A e sua SVD dada: A = U Σ Vᵀ.",
                                    "Identifique as dimensões: U (m×m ou m×r), Σ (m×n diagonal), V (n×n ou r×n).",
                                    "Liste os valores singulares σ_i na diagonal de Σ.",
                                    "Verifique se todos σ_i ≥ 0 e ordenados decrescentemente.",
                                    "Confirme multiplicando U Σ Vᵀ para reproduzir A (para matrizes pequenas)."
                                  ],
                                  "verification": "A = U Σ Vᵀ holds true via manual matrix multiplication.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Caneta",
                                    "Calculadora para multiplicações"
                                  ],
                                  "tips": "Anote dimensões primeiro para evitar erros de compatibilidade.",
                                  "learningObjective": "Identificar e validar corretamente os componentes U, Σ e V da SVD.",
                                  "commonMistakes": [
                                    "Confundir Vᵀ com V",
                                    "Ignorar zeros fora da diagonal em Σ",
                                    "Erros de transposição em Vᵀ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a pseudoinversa diagonal Σ⁺",
                                  "subSteps": [
                                    "Determine as dimensões de Σ⁺: n×m (transposta de Σ em estrutura).",
                                    "Para cada σ_i > 0 (na diagonal de Σ), defina o elemento correspondente em Σ⁺ como 1/σ_i.",
                                    "Preencha com zeros todos os elementos onde σ_i = 0 ou fora da diagonal.",
                                    "Mantenha Σ⁺ como matriz diagonal (ou retangular diagonal).",
                                    "Verifique simetria: Σ⁺ deve ser a 'inversão seletiva' de Σ."
                                  ],
                                  "verification": "Σ Σ⁺ Σ = Σ e dimensões corretas (n×m).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora para 1/σ_i"
                                  ],
                                  "tips": "Use tolerância numérica pequena (ex: >10^{-10}) para considerar σ_i > 0.",
                                  "learningObjective": "Criar corretamente Σ⁺ preservando estrutura diagonal e invertendo apenas singulares não-nulas.",
                                  "commonMistakes": [
                                    "Inverter todos σ_i incluindo zeros",
                                    "Esquecer transposição dimensional",
                                    "Erros aritméticos em 1/σ_i"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o produto intermediário V Σ⁺",
                                  "subSteps": [
                                    "Confirme dimensões: V (n×n) × Σ⁺ (n×m) resulta em (n×m).",
                                    "Multiplique linha por coluna: cada elemento (V Σ⁺)_{jk} = ∑ V_{ji} (Σ⁺)_{ik}.",
                                    "Como Σ⁺ é diagonal, simplifique: colunas de V escaladas por 1/σ_i onde aplicável.",
                                    "Calcule cada entrada manualmente para matrizes pequenas.",
                                    "Armazene o resultado como matriz B = V Σ⁺."
                                  ],
                                  "verification": "Dimensões n×m corretas e cálculos aritméticos exatos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora matricial opcional"
                                  ],
                                  "tips": "Aproveite diagonal de Σ⁺ para multiplicar apenas colunas relevantes de V.",
                                  "learningObjective": "Executar multiplicação matricial precisa respeitando estrutura diagonal.",
                                  "commonMistakes": [
                                    "Índices errados em multiplicação",
                                    "Confundir Σ⁺ com Σ",
                                    "Erros de sinal em escalares"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar A⁺ = (V Σ⁺) Uᵀ e validar",
                                  "subSteps": [
                                    "Confirme dimensões: B (n×m) × Uᵀ (m×m) resulta em (n×m) para A⁺.",
                                    "Multiplique B Uᵀ: cada elemento A⁺_{pq} = ∑ B_{pi} Uᵀ_{iq} = ∑ B_{pi} U_{qi}.",
                                    "Calcule todas as entradas manualmente.",
                                    "Verifique pelo menos uma propriedade: A A⁺ A ≈ A (para precisão numérica).",
                                    "Compare com pseudoinversa conhecida se disponível."
                                  ],
                                  "verification": "A⁺ tem dimensões n×m e satisfaz A A⁺ A = A.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora"
                                  ],
                                  "tips": "Uᵀ é transposição de U; calcule se necessário.",
                                  "learningObjective": "Finalizar A⁺ via multiplicação e validar propriedades iniciais.",
                                  "commonMistakes": [
                                    "Usar U ao invés de Uᵀ",
                                    "Índices trocados na transposição",
                                    "Arredondamentos prematuros"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[1, 1], [0, 0]] (2×2, rank 1). SVD: U = [[1,0],[0,1]], Σ = [[√2, 0],[0, 0]], Vᵀ = [[1/√2, 1/√2],[ -1/√2, 1/√2 ]]. Então Σ⁺ = [[1/√2, 0],[0, 0]] (2×2). V = transpose(Vᵀ). Compute V Σ⁺ = V escalado na primeira coluna por 1/√2. Então A⁺ = (V Σ⁺) Uᵀ = [[0.5, 0.5],[0.5, 0.5]] / algo ajustado; verifique A A⁺ A = A.",
                              "finalVerifications": [
                                "A A⁺ A = A",
                                "A⁺ A A⁺ = A⁺",
                                "(A A⁺)ᵀ = A A⁺",
                                "(A⁺ A)ᵀ = A⁺ A",
                                "Dimensões de A⁺ são n×m",
                                "A⁺ A é projetor ortogonal no range de Aᵀ"
                              ],
                              "assessmentCriteria": [
                                "Σ⁺ corretamente formada com 1/σ_i apenas para σ_i > 0",
                                "Multiplicações matriciais sem erros aritméticos",
                                "Dimensões preservadas em todos os passos",
                                "Valores singulares invertidos com precisão numérica adequada",
                                "Verificação de pelo menos duas propriedades Moore-Penrose",
                                "Explicação clara de cada substep"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em NumPy (np.linalg.pinv via svd)",
                                "Estatística: Solução de regressão linear via mínimos quadrados",
                                "Engenharia: Análise de estabilidade em sistemas lineares",
                                "Machine Learning: Regularização em redes neurais e PCA",
                                "Física: Inversão de matrizes de covariância em simulações"
                              ],
                              "realWorldApplication": "Calcular pseudoinversas via SVD resolve sistemas lineares overdetermined em mínimos quadrados, como ajuste de curvas em dados experimentais, compressão de imagens (ex: denoising), controle ótimo em robótica e processamento de sinais em telecomunicações."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.3",
                            "name": "Verificar propriedades computacionalmente",
                            "description": "Implementar em software numérico (ex.: MATLAB ou Python com NumPy) a verificação das propriedades do pseudoinverso para matrizes exemplos retangulares e singulares, analisando resíduos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e definir matrizes de exemplo",
                                  "subSteps": [
                                    "Instalar e importar bibliotecas necessárias: NumPy e, opcionalmente, SciPy para SVD.",
                                    "Definir uma matriz retangular não quadrada, ex.: A = np.array([[1, 2], [3, 4], [5, 6]]).",
                                    "Definir uma matriz singular retangular, ex.: B = np.array([[1, 2, 3], [2, 4, 6]]).",
                                    "Verificar dimensões e rank das matrizes usando np.linalg.matrix_rank().",
                                    "Preparar vetores b para least squares futuros."
                                  ],
                                  "verification": "Executar np.shape(A), np.linalg.matrix_rank(A) e confirmar saídas esperadas (ex.: shape (3,2), rank 2).",
                                  "estimatedTime": "20 min",
                                  "materials": "Python 3+, NumPy, Jupyter Notebook ou IDE como VS Code.",
                                  "tips": "Use np.random.seed(42) para reprodutibilidade em testes.",
                                  "learningObjective": "Configurar corretamente dados de entrada para análise numérica estável.",
                                  "commonMistakes": "Confundir dimensões de matrizes ou usar matrizes quadradas invertíveis por engano."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar Decomposição SVD e Pseudoinverso de Moore-Penrose",
                                  "subSteps": [
                                    "Calcular SVD: U, s, Vt = np.linalg.svd(A, full_matrices=True).",
                                    "Construir pseudoinverso manualmente: s_inv = 1/s onde s>epsilon, zero elsewhere; A_pinv = V @ diag(s_inv) @ U.T.",
                                    "Comparar com np.linalg.pinv(A) para validação.",
                                    "Repetir para matriz singular B.",
                                    "Armazenar pseudoinversos como A_plus e B_plus."
                                  ],
                                  "verification": "Verificar se np.allclose(A @ A_plus @ A, A) para uma propriedade básica.",
                                  "estimatedTime": "30 min",
                                  "materials": "NumPy (np.linalg.svd, np.linalg.pinv), epsilon=1e-15 para tolerância numérica.",
                                  "tips": "Use full_matrices=True para matrizes retangulares e defina tolerância para singular values pequenos.",
                                  "learningObjective": "Implementar SVD-based pseudoinverso numericamente com precisão.",
                                  "commonMistakes": "Ignorar valores singulares próximos de zero, levando a instabilidade numérica."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar as quatro propriedades do Pseudoinverso",
                                  "subSteps": [
                                    "Propriedade 1: Calcular A @ A_plus @ A e comparar com A (tol=1e-10).",
                                    "Propriedade 2: Calcular A_plus @ A @ A_plus e comparar com A_plus.",
                                    "Propriedade 3: Verificar se (A @ A_plus).T == A @ A_plus (hermitiana).",
                                    "Propriedade 4: Verificar se (A_plus @ A).T == A_plus @ A.",
                                    "Repetir para B e registrar resíduos: np.linalg.norm(diff)."
                                  ],
                                  "verification": "Todos os resíduos < 1e-10 via np.allclose com atol=1e-10.",
                                  "estimatedTime": "25 min",
                                  "materials": "NumPy (matrix operations, np.transpose, np.linalg.norm).",
                                  "tips": "Use np.allclose(A, computed, atol=1e-10, rtol=1e-10) para comparações flutuantes.",
                                  "learningObjective": "Validar teoricamente propriedades computacionalmente com análise de erro.",
                                  "commonMistakes": "Usar == em vez de np.allclose, falhando em precisão finita."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar resíduos em problema de Quadrados Mínimos",
                                  "subSteps": [
                                    "Definir b fora do espaço coluna de A, ex.: b = np.array([1,2,3]).",
                                    "Resolver x = A_plus @ b (solução mínima norma).",
                                    "Calcular resíduo: r = np.linalg.norm(A @ x - b).",
                                    "Comparar com solução least squares: np.linalg.lstsq(A, b).",
                                    "Plotar resíduos vs. singular values para insight (opcional com Matplotlib)."
                                  ],
                                  "verification": "Resíduo mínimo e x matches lstsq solution within tol.",
                                  "estimatedTime": "25 min",
                                  "materials": "NumPy (lstsq), Matplotlib para plots opcionais.",
                                  "tips": "Para matriz singular, note que solução não é única, mas pseudoinverso dá mínima norma.",
                                  "learningObjective": "Aplicar pseudoinverso em least squares e interpretar resíduos.",
                                  "commonMistakes": "Esquecer normalização de resíduos ou confundir com inversa padrão."
                                }
                              ],
                              "practicalExample": "Para A = [[1,0],[0,1],[1,1]] (retangular rank-deficient), compute A+ via SVD, verifique A A+ A == A (resíduo 1e-12), e resolva A x ≈ [1,1,2]^T com ||r|| ≈ 0 devido a consistência.",
                              "finalVerifications": [
                                "Todas propriedades validadas com resíduos < 1e-10 para ambas matrizes.",
                                "Pseudoinverso manual matches np.linalg.pinv().",
                                "Least squares solução tem resíduo mínimo e norma x mínima.",
                                "Rank e dimensões confirmadas.",
                                "Código executável e reprodutível com seed.",
                                "Relatório de resíduos impresso."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: resíduos < 1e-10 em todas verificações.",
                                "Correta implementação SVD-based pinv vs. built-in.",
                                "Análise completa das 4 propriedades com código e outputs.",
                                "Interpretação de resíduos em least squares.",
                                "Código limpo, comentado e com tolerâncias adequadas.",
                                "Uso correto de subSteps em matrizes retangulares/singulares."
                              ],
                              "crossCurricularConnections": [
                                "Programação: NumPy para computação científica e debugging numérico.",
                                "Estatística: Least squares em regressão linear.",
                                "Engenharia: Processamento de sinais via SVD.",
                                "Ciência de Dados: Redução dimensional e pseudoinversos em ML."
                              ],
                              "realWorldApplication": "Em machine learning, pseudoinverso resolve regressão linear para dados não invertíveis (ex.: multicolinearidade em features); em imagens, SVD-based pinv para restauração de fotos borradas minimizando resíduos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.2",
                        "name": "Quadrados Mínimos para Sistemas Superdeterminados",
                        "description": "Aplicação da SVD e pseudoinverso para resolver sistemas lineares superdeterminados Ax ≈ b, minimizando a norma ||Ax - b||₂ via x = A⁺ b, com interpretação dos valores singulares na estabilidade da solução.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.2.1",
                            "name": "Formular o problema de quadrados mínimos",
                            "description": "Dado um sistema Ax = b com m > n e A de posto completo ou não, formular o problema como min_x ||Ax - b||₂ e identificar a solução única de menor norma como x = A⁺ b.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender sistemas lineares superdeterminados",
                                  "subSteps": [
                                    "Defina um sistema Ax = b onde A é m x n com m > n (mais equações que incógnitas).",
                                    "Explique por que tais sistemas geralmente não têm solução exata devido a ruído ou inconsistências.",
                                    "Identifique o posto de A: completo se rank(A) = n, o que garante pelo menos uma solução mínima.",
                                    "Discuta o objetivo: encontrar x que minimize o erro de aproximação.",
                                    "Esboce um exemplo simples com m=3, n=2."
                                  ],
                                  "verification": "Construa um exemplo de sistema superdeterminado e verifique se m > n e descreva por que não tem solução exata.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Calculadora ou software como MATLAB/Octave"
                                  ],
                                  "tips": "Sempre verifique as dimensões de A primeiro para confirmar superdeterminação.",
                                  "learningObjective": "Reconhecer e caracterizar sistemas lineares superdeterminados e suas limitações.",
                                  "commonMistakes": [
                                    "Confundir com sistemas subdeterminados (m < n)",
                                    "Ignorar o impacto do posto de A"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular o problema de minimização de quadrados mínimos",
                                  "subSteps": [
                                    "Defina o resíduo r = Ax - b e o problema como encontrar x que minimize ||r||₂.",
                                    "Escreva matematicamente: min_x ||Ax - b||₂ onde ||.||₂ é a norma euclidiana.",
                                    "Explique que ||Ax - b||₂² = (Ax - b)^T (Ax - b) é a função objetivo (soma de quadrados dos erros).",
                                    "Verifique se a formulação é válida independentemente do posto de A.",
                                    "Reescreva para um exemplo numérico pequeno."
                                  ],
                                  "verification": "Escreva a formulação min_x ||Ax - b||₂ para um sistema dado e compute ||r||₂ para um x arbitrário.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matriz A e vetor b de exemplo",
                                    "Software de álgebra linear como Python com NumPy"
                                  ],
                                  "tips": "Lembre-se: é minimizar a norma L2 do resíduo, não L1 ou infinito.",
                                  "learningObjective": "Formular precisamente o problema de quadrados mínimos como uma otimização não restrita.",
                                  "commonMistakes": [
                                    "Escrever min ||x|| em vez de ||Ax-b||",
                                    "Confundir norma L2 com L1"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar condições para solução única e menor norma",
                                  "subSteps": [
                                    "Discuta: se rank(A) = n (posto completo), existe solução única x que minimiza ||Ax-b||₂.",
                                    "Introduza o conceito de soluções mínimas: entre minimizadores, escolha o de menor ||x||₂.",
                                    "Explique que condições de posto completo garantem unicidade do minimizador.",
                                    "Diferencie casos: posto completo vs. deficiente.",
                                    "Verifique com teorema: o minimizador único é x = A^+ b quando existe."
                                  ],
                                  "verification": "Para uma A com posto completo, afirme se a solução é única e identifique como obtê-la.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Teorema de pseudoinversa",
                                    "Exemplos de matrizes com diferentes postas"
                                  ],
                                  "tips": "Use rank(A) via decomposição SVD para checar posto completo.",
                                  "learningObjective": "Identificar condições para existência e unicidade da solução de quadrados mínimos.",
                                  "commonMistakes": [
                                    "Achar que sempre há solução única sem checar posto",
                                    "Ignorar a norma mínima de x"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar a solução via pseudoinversa",
                                  "subSteps": [
                                    "Defina a pseudoinversa de Moore-Penrose A^+ como a solução x = A^+ b.",
                                    "Explique propriedades: A^+ A = I se posto completo, e x minimiza ||Ax-b||₂ com menor norma.",
                                    "Compute A^+ conceitualmente via SVD: A = U Σ V^T, A^+ = V Σ^+ U^T.",
                                    "Aplique a um exemplo: calcule x = A^+ b e verifique ||Ax - b||₂.",
                                    "Confirme que é a solução de menor norma entre minimizadores."
                                  ],
                                  "verification": "Dado A e b, compute x = A^+ b e mostre que ||Ax - b||₂ é mínimo.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software com SVD (MATLAB, Python SciPy)",
                                    "Exemplo numérico"
                                  ],
                                  "tips": "Pseudoinversa resolve tanto superdeterminados quanto subdeterminados uniformemente.",
                                  "learningObjective": "Reconhecer x = A^+ b como a solução padrão de quadrados mínimos de menor norma.",
                                  "commonMistakes": [
                                    "Confundir A^+ com inversa A^{-1}",
                                    "Não verificar minimização da norma de x"
                                  ]
                                }
                              ],
                              "practicalExample": "Em regressão linear simples, A contém uma coluna de 1s (intercepto) e Xs (preditor), b são Ys observados (m > n pontos). Formule min ||A β - Y||₂ para estimar β, solução β = A^+ Y, usado em ajuste de linha reta com ruído.",
                              "finalVerifications": [
                                "Formula corretamente min_x ||Ax - b||₂ para sistema dado.",
                                "Identifica se posto(A)=n e afirma solução única.",
                                "Especifica x = A^+ b como solução de menor norma.",
                                "Aplica SVD conceitual para pseudoinversa.",
                                "Verifica numericamente em exemplo que ||Ax - b||₂ é minimizado.",
                                "Distingue de outros métodos como gradiente descendente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação matemática do problema.",
                                "Correta identificação de condições de posto completo.",
                                "Uso apropriado da pseudoinversa como solução.",
                                "Capacidade de aplicar a exemplos concretos.",
                                "Compreensão de normas e minimização de menor norma.",
                                "Clareza na distinção entre minimizador e menor norma."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Regressão linear e ajuste de mínimos quadrados.",
                                "Ciência de Dados: Machine Learning para predição com overfitting.",
                                "Engenharia: Processamento de sinais e filtragem.",
                                "Física: Ajuste de curvas experimentais.",
                                "Computação: Otimização numérica e álgebra linear computacional."
                              ],
                              "realWorldApplication": "Em machine learning, formula regressão linear para prever preços de casas com features (área, quartos) e dados ruidosos, usando x = A^+ b para estimadores robustos que minimizam erro quadrático médio em grandes datasets."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.2",
                            "name": "Resolver quadrados mínimos usando SVD",
                            "description": "Usando a SVD de A, computar x = V Σ⁺ Uᵀ b para sistemas superdeterminados, calculando o resíduo ||Ax - b||₂ e analisando o impacto de valores singulares pequenos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o sistema superdeterminado e computar a SVD de A",
                                  "subSteps": [
                                    "Identifique o sistema Ax = b onde A é m x n com m > n.",
                                    "Verifique as dimensões de A e b para confirmar superdeterminação.",
                                    "Use software para decompor A em U Σ Vᵀ.",
                                    "Extraia as matrizes U, Σ (diagonal com valores singulares) e V.",
                                    "Ordene os valores singulares em ordem decrescente."
                                  ],
                                  "verification": "Confirme que A ≈ U Σ Vᵀ com erro numérico pequeno (ex: norma < 1e-10).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python com NumPy/SciPy, MATLAB ou Octave; matriz A e vetor b de exemplo.",
                                  "tips": "Use np.linalg.svd() no Python para decomposição completa.",
                                  "learningObjective": "Compreender a estrutura da SVD para sistemas superdeterminados.",
                                  "commonMistakes": "Confundir ordem das matrizes (U Σ Vᵀ vs V Σ Uᵀ); ignorar valores singulares zero."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a pseudoinversa Σ⁺ a partir dos valores singulares",
                                  "subSteps": [
                                    "Inverta os valores singulares não-nulos: σ_i⁺ = 1/σ_i se σ_i > ε (threshold pequeno).",
                                    "Defina σ_i⁺ = 0 para σ_i ≤ ε para evitar amplificação de ruído.",
                                    "Crie Σ⁺ como diagonal com os valores invertidos, dimensões n x m.",
                                    "Escolha ε baseado no condicionamento de A (ex: 1e-10 * σ_max).",
                                    "Discuta o impacto de valores singulares pequenos na estabilidade."
                                  ],
                                  "verification": "Verifique Σ Σ⁺ ≈ I para os primeiros min(m,n) elementos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Mesmo software do Step 1; lista de valores singulares de Σ.",
                                  "tips": "Visualize o espectro singular com plot(log(σ)) para identificar pequenos valores.",
                                  "learningObjective": "Aplicar truncamento para pseudoinversa estável.",
                                  "commonMistakes": "Inverter todos σ_i sem threshold, causando instabilidade numérica."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a solução mínima dos quadrados x = V Σ⁺ Uᵀ b",
                                  "subSteps": [
                                    "Compute Uᵀ b.",
                                    "Multiplique por Σ⁺: Σ⁺ (Uᵀ b).",
                                    "Multiplique por V: x = V [Σ⁺ (Uᵀ b)].",
                                    "Verifique dimensões: x deve ser n x 1.",
                                    "Compare com solução por norma mínima se disponível."
                                  ],
                                  "verification": "Confirme ||A x - b||₂ é mínimo comparado a outras soluções.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Software computacional; resultados dos steps anteriores.",
                                  "tips": "Implemente como np.dot(V, np.dot(S_plus, np.dot(U.T, b))).",
                                  "learningObjective": "Executar a fórmula da pseudoinversa via SVD.",
                                  "commonMistakes": "Erro na ordem das multiplicações matriciais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular o resíduo e analisar o impacto de valores singulares pequenos",
                                  "subSteps": [
                                    "Compute r = A x - b.",
                                    "Calcule ||r||₂ = sqrt(rᵀ r).",
                                    "Analise contribuição de cada componente singular ao resíduo.",
                                    "Simule remoção de pequenos σ_i e re-compute x e resíduo.",
                                    "Interprete: pequenos σ_i indicam direções mal-condicionadas."
                                  ],
                                  "verification": "||r||₂ deve ser pequeno; variação com truncamento < 1%.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software; x e SVD de steps anteriores.",
                                  "tips": "Use norma 2 com np.linalg.norm(r, 2).",
                                  "learningObjective": "Avaliar qualidade da solução e sensibilidade numérica.",
                                  "commonMistakes": "Confundir resíduo com erro de arredondamento; ignorar análise de σ pequenos."
                                }
                              ],
                              "practicalExample": "Para dados de regressão linear: A = [1 0; 1 1; 1 2; 1 3] (m=4,n=2), b=[0;1;2;2.5]. SVD dá x ≈ [0.25; 0.85], resíduo ≈0.22. Valores singulares pequenos indicam multicolinearidade se adicionados.",
                              "finalVerifications": [
                                "SVD reconstrói A com erro <1e-10.",
                                "Pseudoinversa Σ⁺ lida corretamente com σ_i pequenos.",
                                "x minimiza ||Ax-b||₂.",
                                "Resíduo calculado corretamente.",
                                "Análise identifica impacto de σ pequenos via simulação.",
                                "Solução estável numéricamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na computação de SVD e pseudoinversa (erro <1e-8).",
                                "Correta aplicação do threshold para σ pequenos.",
                                "Cálculo exato de x e resíduo.",
                                "Análise qualitativa do condicionamento.",
                                "Implementação eficiente sem loops desnecessários.",
                                "Interpretação correta do impacto numérico."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Regressão linear ridge via truncamento SVD.",
                                "Machine Learning: Redução de dimensionalidade em PCA.",
                                "Engenharia: Solução de sistemas em controle e processamento de sinais.",
                                "Física: Ajuste de curvas em dados experimentais."
                              ],
                              "realWorldApplication": "Em data science, resolve regressão linear com multicolinearidade (ex: previsão de preços imobiliários); em imagens, compressão e denoising via SVD truncada."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.3",
                            "name": "Analisar sensibilidade em quadrados mínimos",
                            "description": "Interpretar como valores singulares pequenos afetam a sensibilidade da solução x aos erros em b, comparando com decomposição QR e discutindo truncagem para regularização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Solução de Quadrados Mínimos via Decomposição SVD",
                                  "subSteps": [
                                    "Lembre-se da decomposição SVD de A = U Σ V^T, onde Σ contém valores singulares σ_i.",
                                    "Escreva a solução x = V Σ^+ U^T b para min ||Ax - b||_2.",
                                    "Identifique o pseudoinverso Σ^+ com 1/σ_i para σ_i > 0.",
                                    "Discuta o papel dos valores singulares pequenos na amplificação de erros em b.",
                                    "Calcule cond(A) ≈ σ_max / σ_min para medir sensibilidade."
                                  ],
                                  "verification": "Construa SVD manualmente para uma matriz 2x2 e verifique x SVD coincide com solução conhecida.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy/SciPy, ou MATLAB; matriz de exemplo superdeterminada.",
                                  "tips": "Use np.linalg.svd() para prática rápida; foque em σ_i próximos de zero.",
                                  "learningObjective": "Compreender como SVD resolve quadrados mínimos e introduz sensibilidade via σ_i pequenos.",
                                  "commonMistakes": "Confundir Σ^+ com inversa de Σ; ignorar zeros em Σ para ranks deficientes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Sensibilidade da Solução x a Erros em b",
                                  "subSteps": [
                                    "Derive a perturbação δx ≈ V Σ^+ U^T δb para erro δb em b.",
                                    "Mostre que componentes de δx são amplificados por 1/σ_i pequenos.",
                                    "Calcule o fator de amplificação relativo ||δx|| / ||δb|| ≈ 1/σ_min.",
                                    "Compare sensibilidade com norma condicional cond(A).",
                                    "Simule numericamente adicionando ruído gaussiano a b e meça ||δx||."
                                  ],
                                  "verification": "Plote ||δx|| vs. σ_min variando ruído; observe amplificação quando σ_min diminui.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Jupyter Notebook com NumPy/Matplotlib; gerador de ruído np.random.normal().",
                                  "tips": "Escolha matrizes com σ_i decrescentes para visualizar efeito; normalize ||b||=1.",
                                  "learningObjective": "Quantificar como valores singulares pequenos tornam x sensível a erros em b.",
                                  "commonMistakes": "Esquecer normalização de normas; confundir erro em b com erro em A."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Sensibilidade com Decomposição QR",
                                  "subSteps": [
                                    "Revise solução QR: A = QR, x = R^{-1} Q^T b.",
                                    "Derive δx ≈ R^{-1} Q^T δb; note que cond(R) ≈ cond(A).",
                                    "Compare estabilidade: SVD revela σ_i individuais, QR agrupa em cond global.",
                                    "Simule mesmo exemplo com QR e SVD, medindo ||δx|| para δb.",
                                    "Discuta quando QR falha em ranks baixos vs. SVD."
                                  ],
                                  "verification": "Tabela comparativa: cond(SVD) vs. cond(QR), e simulações de erro para ambas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python: np.linalg.qr() e np.linalg.svd(); mesmo dataset do Step 2.",
                                  "tips": "Use ill-conditioned matrices (ex: Hilbert) para diferenças claras.",
                                  "learningObjective": "Contrastar análise de sensibilidade SVD (local por σ_i) vs. QR (global).",
                                  "commonMistakes": "Assumir QR sempre estável; ignorar pivoteamento em QR."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Truncagem de Valores Singulares para Regularização",
                                  "subSteps": [
                                    "Introduza truncagem: defina cutoff τ, ignore σ_i < τ em Σ^+.",
                                    "Formule x_τ = V Σ_τ^+ U^T b, reduzindo amplificação 1/σ_i.",
                                    "Escolha τ heurístico: τ ≈ ε_mach * σ_max ou gap em σ_i.",
                                    "Compare ||Ax_τ - b|| vs. ||x_τ|| e sensibilidade reduzida.",
                                    "Simule com ruído: meça melhoria em ||δx_τ||."
                                  ],
                                  "verification": "Gráfico de ||x_τ - x|| e cond efetivo vs. τ; valide redução de sensibilidade.",
                                  "estimatedTime": "55 minutos",
                                  "materials": "Código custom para SVD truncada; plots com Matplotlib.",
                                  "tips": "Teste τ = 10^{-k} * σ_max para k=3-6; avalie trade-off bias-variance.",
                                  "learningObjective": "Aplicar truncagem como regularização para mitigar sensibilidade.",
                                  "commonMistakes": "Truncar demais (underfit); não normalizar σ_i."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Análise e Verificar Compreensão",
                                  "subSteps": [
                                    "Resuma: SVD > QR para sensibilidade fina via σ_i.",
                                    "Discuta trade-offs: precisão vs. estabilidade com truncagem.",
                                    "Crie fluxograma: quando usar SVD vs. QR vs. truncada.",
                                    "Aplique a um problema real (ex: regressão com ruído).",
                                    "Autoavalie com perguntas chave sobre amplificação e regularização."
                                  ],
                                  "verification": "Responda relatório: 'Explique por que σ_min pequeno causa sensibilidade e como truncar.'",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel/lápis ou Markdown para fluxograma; exemplo final.",
                                  "tips": "Use analogia: σ_i pequenos como 'pilares fracos' em ponte.",
                                  "learningObjective": "Integrar conceitos para análise crítica de sensibilidade.",
                                  "commonMistakes": "Generalizar QR como sempre inferior; ignorar custo computacional SVD."
                                }
                              ],
                              "practicalExample": "Considere A (3x2) = [[1,1],[1,1.01],[1,1.02]], b = [1,1.01,1.02] + 0.01*ruído. SVD revela σ1≈2.45, σ2≈0.02 (pequeno). Sem truncagem, δx amplifica 50x; com τ=0.1, sensibilidade cai 10x, mantendo bom fit.",
                              "finalVerifications": [
                                "Calcule corretamente pseudoinverso truncado para matriz dada.",
                                "Simule δb e confirme amplificação ≈1/σ_min.",
                                "Compare erros ||δx|| em SVD vs. QR para mesmo ruído.",
                                "Escolha τ ótimo minimizando erro validado.",
                                "Explique verbalmente por que truncagem regulariza.",
                                "Crie tabela de sensibilidade vs. rank truncado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de δx (fórmula exata com Σ^+).",
                                "Correção numérica em simulações (erros <1e-10).",
                                "Profundidade na comparação SVD-QR (menciona σ_i locais).",
                                "Justificativa heurística para τ (baseada em ε_mach ou gap).",
                                "Análise qualitativa de trade-offs (estabilidade vs. precisão).",
                                "Clareza em relatórios e plots (legendas, escalas log)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Regularização em regressão linear ridge/LASSO.",
                                "Computação: Análise de estabilidade numérica e conditioning.",
                                "Física: Modelagem de sistemas overdetermined com ruído (ex: ajuste de curvas experimentais).",
                                "Engenharia: Processamento de sinais, redução de dimensionalidade via SVD truncada.",
                                "Data Science: Detecção de multicolinearidade em datasets."
                              ],
                              "realWorldApplication": "Em regressão linear para previsão de vendas com dados ruidosos, SVD truncada evita overfitting por features correlacionadas (σ_i pequenos), melhorando robustez a erros de medição, como em machine learning para finanças ou bioinformática."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.3",
                        "name": "Soluções de Mínima Norma para Sistemas Subdeterminados",
                        "description": "Uso da SVD para encontrar, em sistemas subdeterminados Ax = b (m < n), a solução x de menor norma euclidiana entre todas as soluções, dada por x = A⁺ b.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.3.1",
                            "name": "Formular soluções de mínima norma",
                            "description": "Para Ax = b com m < n, identificar o conjunto de soluções como x = A⁺ b + (I - A⁺ A) z para z arbitrário, e destacar que x = A⁺ b minimiza ||x||₂.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Sistemas Subdeterminados e Espaço de Soluções",
                                  "subSteps": [
                                    "Revise a definição de sistema linear Ax = b onde m < n (mais variáveis que equações).",
                                    "Identifique que tais sistemas têm infinitas soluções se consistentes.",
                                    "Descreva o conjunto de soluções gerais: x = x_p + Null(A), onde x_p é uma solução particular e Null(A) é o núcleo de A.",
                                    "Discuta graficamente para m=1, n=2: soluções formam uma reta.",
                                    "Verifique consistência usando ranqueamento de A e [A|b]."
                                  ],
                                  "verification": "Escreva a forma geral das soluções para um exemplo 1x2 e confirme infinitas soluções.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Matriz A de exemplo (ex: [1 1]x = [2])",
                                    "Calculadora ou papel para ranqueamento",
                                    "Notebook Jupyter para plotar soluções"
                                  ],
                                  "tips": "Sempre normalize b para visualizar melhor o hiperplano de soluções.",
                                  "learningObjective": "Compreender por que sistemas subdeterminados têm soluções infinitas e sua parametrização geral.",
                                  "commonMistakes": [
                                    "Confundir com sobredeterminado (m>n)",
                                    "Esquecer de verificar consistência antes de parametrizar"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a Pseudoinversa de Moore-Penrose (A⁺)",
                                  "subSteps": [
                                    "Defina A⁺ como a única matriz que satisfaz as 4 propriedades de Moore-Penrose.",
                                    "Lembre que para A m x n rank(A)=m, A⁺ = (A^T A)^{-1} A^T (fórmula esquerda).",
                                    "Explique computação via SVD: A = U Σ V^T, então A⁺ = V Σ⁺ U^T onde Σ⁺ inverte diagonais não-nulas.",
                                    "Calcule A⁺ para um exemplo simples usando SVD manual ou software.",
                                    "Verifique que A A⁺ A = A e propriedades idempotentes."
                                  ],
                                  "verification": "Compute A⁺ para A = [1 0; 0 2] (invertível) e confirme A A⁺ = I.",
                                  "estimatedTime": "60 min",
                                  "materials": [
                                    "Software NumPy/MATLAB para SVD",
                                    "Tabela de SVD passo-a-passo",
                                    "Exemplos de matrizes retangulares"
                                  ],
                                  "tips": "Use SVD para casos gerais; evite fórmulas diretas em matrizes grandes.",
                                  "learningObjective": "Dominar o conceito e cálculo da pseudoinversa via SVD.",
                                  "commonMistakes": [
                                    "Usar inversa comum em matrizes não-quadradas",
                                    "Ignorar zeros em Σ⁺"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a Solução de Mínima Norma",
                                  "subSteps": [
                                    "Mostre que x_min = A⁺ b é uma solução particular: A x_min = A A⁺ b = b (projetor).",
                                    "Derive a solução geral: x = A⁺ b + (I - A⁺ A) z, para z ∈ ℝ^n.",
                                    "Note que (I - A⁺ A) é o projetor ortogonal sobre Null(A).",
                                    "Prove que ||x_min||₂ é mínima: qualquer outra x = x_min + n com n ⊥ Range(A^T), então ||x||² = ||x_min||² + ||n||² ≥ ||x_min||².",
                                    "Implemente em código para validar."
                                  ],
                                  "verification": "Para Ax=b dado, compute x_min = A⁺ b e confirme A x_min = b e ||x_min|| mínima entre 3 soluções aleatórias.",
                                  "estimatedTime": "75 min",
                                  "materials": [
                                    "Código Python: import numpy.linalg.pinv",
                                    "Matriz exemplo subdeterminada: A 2x3, b 2x1",
                                    "Função para norma L2"
                                  ],
                                  "tips": "Sempre verifique A x = b primeiro; use pinv() no NumPy para rapidez.",
                                  "learningObjective": "Formular explicitamente x = A⁺ b + (I - A⁺ A) z e entender sua minimalidade.",
                                  "commonMistakes": [
                                    "Esquecer o termo (I - A⁺ A)z",
                                    "Confundir com norma mínima de resíduos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar Numericamente",
                                  "subSteps": [
                                    "Escolha um exemplo real: sinal com ruído ou regressão subdeterminada.",
                                    "Compute soluções múltiplas variando z e compare normas.",
                                    "Analise estabilidade numérica com SVD truncado.",
                                    "Compare com métodos alternativos (ex: QR para mínima norma).",
                                    "Discuta quando usar: preferir soluções esparsas ou com restrições."
                                  ],
                                  "verification": "Gere gráfico de normas vs. z para soluções parametrizadas, mostrando mínimo em z=0.",
                                  "estimatedTime": "50 min",
                                  "materials": [
                                    "Jupyter Notebook com plots matplotlib",
                                    "Dados sintéticos: A rand(3,5), b rand(3,1)"
                                  ],
                                  "tips": "Adicione pequeno ruído a A para testar robustez numérica.",
                                  "learningObjective": "Aplicar a formulação em exemplos computacionais e validar propriedades.",
                                  "commonMistakes": [
                                    "Não normalizar normas",
                                    "Ignorar precisão de ponto flutuante em SVD"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 0, 1], [0, 1, 1]] (2x3), b = [1, 1]. SVD dá A⁺ ≈ [[0.5, 0, 0.5], [0, 1, 0], [0.5, 0.5, 0]]. Então x_min = A⁺ b = [0.5, 1, 0.5], com ||x_min||₂ ≈ 1.5. Solução geral x = [0.5, 1, 0.5] + [[0,0,1],[0,0,0],[-1,0,1]] z. Norma mínima confirmada.",
                              "finalVerifications": [
                                "Escreva corretamente x = A⁺ b + (I - A⁺ A) z.",
                                "Prove que A x_min = b.",
                                "Demonstre ||x_min|| ≤ ||x|| para qualquer x em soluções.",
                                "Compute A⁺ via SVD para matriz 2x3.",
                                "Implemente em Python e plote normas.",
                                "Explique por que A⁺ A é projetor sobre Range(A^T)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da solução geral (100%).",
                                "Correta aplicação de pseudoinversa em exemplo numérico.",
                                "Prova rigorosa da minimalidade da norma L2.",
                                "Código funcional validando propriedades.",
                                "Identificação de erros numéricos potenciais.",
                                "Explicação clara de papéis de Range e Null."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de numpy.linalg.pinv em ML para feature selection.",
                                "Física: Reconstrução de sinais em tomografia com mínima energia.",
                                "Engenharia: Controle ótimo mínimo esforço em sistemas subatuados.",
                                "Estatística: Ridge regression como regularização para subdeterminados.",
                                "Ciência de Dados: Compressão de imagens via SVD mínimo norma."
                              ],
                              "realWorldApplication": "Em processamento de sinais, formula soluções de mínima norma para reconstruir vetores de alta dimensão a partir de medições escassas (ex: MRI), minimizando energia do sinal enquanto satisfaz dados observados; usado em GPS para posicionamento com poucos satélites."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.3.2",
                            "name": "Computar solução mínima via pseudoinverso",
                            "description": "Aplicar a SVD para calcular x = A⁺ b em sistemas subdeterminados, verificando que Ax = b e que ||x||₂ é mínima comparando com outras soluções.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Verificar se o sistema é subdeterminado e preparar os dados",
                                  "subSteps": [
                                    "Confirme que o número de colunas de A (n) é maior que o número de linhas (m), ou seja, n > m.",
                                    "Verifique o rank de A para garantir que é m (espaço coluna completo).",
                                    "Defina o vetor b com dimensão m x 1 compatível.",
                                    "Escolha ou crie uma matriz A e vetor b de exemplo.",
                                    "Anote dimensões e propriedades iniciais."
                                  ],
                                  "verification": "Sistema confirmado subdeterminado com rank(A) = m e dimensões anotadas corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matriz A m x n",
                                    "Vetor b m x 1",
                                    "Calculadora ou software (Python/NumPy, MATLAB)"
                                  ],
                                  "tips": "Use software para verificação rápida de dimensões e rank; evite matrizes com rank deficiente.",
                                  "learningObjective": "Identificar sistemas subdeterminados e preparar dados para SVD.",
                                  "commonMistakes": [
                                    "Confundir subdeterminado com superdeterminado",
                                    "Ignorar rank incompleto",
                                    "Dimensões incompatíveis de b"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a decomposição SVD de A",
                                  "subSteps": [
                                    "Compute A = U Σ V^T, onde U é m x m ortogonal, Σ é m x n diagonal com valores singulares σ_i decrescentes, V é n x n ortogonal.",
                                    "Ordene os valores singulares em ordem decrescente.",
                                    "Identifique os r valores singulares não-nulos (r = rank(A)).",
                                    "Verifique A ≈ U Σ V^T numericamente.",
                                    "Armazene U, Σ e V separadamente."
                                  ],
                                  "verification": "Reconstrução A = U Σ V^T com erro < 1e-10.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software SVD (np.linalg.svd em Python, svd em MATLAB)",
                                    "Matriz A preparada"
                                  ],
                                  "tips": "Use funções built-in para precisão numérica; full_matrices=True para matrizes completas.",
                                  "learningObjective": "Executar SVD corretamente em matrizes retangulares.",
                                  "commonMistakes": [
                                    "Ordem errada de σ_i",
                                    "Confundir U e V",
                                    "Não truncar zeros em Σ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o pseudoinverso A⁺ a partir da SVD",
                                  "subSteps": [
                                    "Inverta os r valores singulares não-nulos: Σ⁺ com 1/σ_i na diagonal.",
                                    "Transponha U e V: A⁺ = V Σ⁺ U^T.",
                                    "Preencha zeros em Σ⁺ para dimensões n x m.",
                                    "Verifique propriedades: A A⁺ A = A.",
                                    "Compare dimensões de A⁺ (n x m)."
                                  ],
                                  "verification": "A A⁺ = I_m (projetor) e dimensões corretas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "U, Σ, V da SVD",
                                    "Software para multiplicação matricial"
                                  ],
                                  "tips": "Σ⁺ tem zeros onde σ_i = 0; use pinv() para validação.",
                                  "learningObjective": "Derivar pseudoinverso Moore-Penrose via SVD.",
                                  "commonMistakes": [
                                    "Inverter todos σ_i incluindo zeros",
                                    "Erro em transpostas U^T vs V^T",
                                    "Dimensões trocadas em Σ⁺"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a solução x = A⁺ b e verificar consistência",
                                  "subSteps": [
                                    "Multiplique x = A⁺ b.",
                                    "Compute Ax e verifique ||Ax - b||₂ ≈ 0.",
                                    "Encontre outra solução x_alt tal que A x_alt = b (ex: x + null space).",
                                    "Calcule ||x||₂ e ||x_alt||₂, confirme ||x||₂ mínima.",
                                    "Documente todos os valores."
                                  ],
                                  "verification": "||Ax - b||₂ < 1e-10 e ||x||₂ < ||x_alt||₂ para soluções alternativas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "A⁺, b",
                                    "Base do kernel de A para x_alt",
                                    "Norma L2 função"
                                  ],
                                  "tips": "Use null_space de A para gerar x_alt = x + v onde v em ker(A); compare normas euclidianas.",
                                  "learningObjective": "Aplicar pseudoinverso para solução mínima norma e validar.",
                                  "commonMistakes": [
                                    "Não verificar consistência Ax=b",
                                    "Escolha errada de x_alt",
                                    "Norma errada (L1 ao invés de L2)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e documentar a minimidade da norma",
                                  "subSteps": [
                                    "Gere múltiplas soluções no conjunto {x | Ax=b}.",
                                    "Compare normas L2 de todas.",
                                    "Explique geometricamente: x é projeção ortogonal em col(A).",
                                    "Discuta estabilidade numérica da SVD.",
                                    "Registre relatório com plots se possível (ex: norma vs soluções)."
                                  ],
                                  "verification": "Relatório confirma x tem norma mínima entre soluções testadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Soluções x, x_alt",
                                    "Software plotting (opcional)"
                                  ],
                                  "tips": "Teorema garante unicidade da mínima norma; foque em compreensão.",
                                  "learningObjective": "Interpretar propriedades teóricas da solução mínima.",
                                  "commonMistakes": [
                                    "Ignorar componente no kernel",
                                    "Confundir com solução básica",
                                    "Análise qualitativa insuficiente"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 0, 1], [0, 1, 1]] (2x3), b = [1, 2]. SVD: U, Σ, V computados dão A⁺ ≈ [[0.5, 0], [0, 1], [0.5, 1]]. Então x = A⁺ b = [1, 2, 0]^T. Verifique Ax = [1,2]^T = b e ||x||₂ = sqrt(5) < ||[0,1,1]||₂ = sqrt(3) wait, corrija exemplo: real x_min=[1,1,0], norma sqrt(2) mínima vs [2,0, -1] norma sqrt(5).",
                              "finalVerifications": [
                                "SVD de A reconstruída com erro numérico mínimo.",
                                "Pseudoinverso satisfaz 4 propriedades Moore-Penrose.",
                                "Ax = b exatamente (dentro de tolerância).",
                                "||x||₂ é a menor entre pelo menos 2 soluções alternativas.",
                                "Rank e singular values corretos.",
                                "Dimensões consistentes em todos cálculos."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica em SVD e A⁺ (erro < 1e-10).",
                                "Correta identificação de solução mínima norma.",
                                "Verificação explícita de Ax=b e comparação de normas.",
                                "Explicação teórica clara da minimidade.",
                                "Uso correto de software sem erros de sintaxe.",
                                "Relatório completo com passos documentados."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em NumPy/SciPy para SVD.",
                                "Otimização: Relação com problemas de minimização quadrática.",
                                "Física: Soluções mínimas energia em sistemas lineares.",
                                "Machine Learning: Regressão Ridge e feature selection.",
                                "Estatística: Análise de componentes principais via SVD."
                              ],
                              "realWorldApplication": "Em engenharia de controle, encontrar comandos de mínima energia para satélites em órbita (sistemas subdeterminados); em processamento de sinais, reconstrução de sinais com mínima norma em redes sensores."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.3.3",
                            "name": "Comparar com métodos alternativos",
                            "description": "Contrastar a solução via SVD com projeções ortogonais ou QR para subdeterminados, destacando vantagens numéricas da SVD em casos de posto deficiente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os Fundamentos dos Métodos Alternativos",
                                  "subSteps": [
                                    "Relembre a fórmula da solução de mínima norma via projeção ortogonal: x = A^T (A A^T)^{-1} b para sistemas subdeterminados com posto completo nas linhas.",
                                    "Estude a decomposição QR para A (m x n, m < n): A = Q R, onde soluções envolvem R^{-1} Q^T b ajustado para mínima norma.",
                                    "Identifique limitações iniciais: ambos assumem posto completo e podem falhar numericamente em casos de posto deficiente.",
                                    "Compare conceitualmente com SVD: A = U Σ V^T, x = V Σ^+ U^T b.",
                                    "Anote diferenças chave em estabilidade numérica."
                                  ],
                                  "verification": "Crie um resumo escrito comparando fórmulas e premissas de cada método.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Álgebra Linear Numérica (ex: Golub & Van Loan)",
                                    "Notebook Jupyter ou MATLAB"
                                  ],
                                  "tips": "Use diagramas vetoriais para visualizar projeções ortogonais no espaço coluna.",
                                  "learningObjective": "Entender as bases teóricas dos métodos para comparação posterior.",
                                  "commonMistakes": [
                                    "Confundir sistemas superdeterminados com subdeterminados",
                                    "Ignorar a necessidade de posto completo nos métodos alternativos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e Testar em Caso de Posto Completo",
                                  "subSteps": [
                                    "Escolha um exemplo 2x3 subdeterminado com posto 2: A = [[1,0,1],[0,1,1]], b = [1,1].",
                                    "Calcule soluções usando projeção ortogonal, QR e SVD; verifique que todas dão x = [1,1, -1]^T (norma mínima).",
                                    "Meça erros numéricos adicionando ruído pequeno a A e compare sensibilidades.",
                                    "Registre tempos de computação e precisão condicional.",
                                    "Discuta por que todos performam bem aqui."
                                  ],
                                  "verification": "Execute código e confirme que soluções coincidem dentro de 1e-10.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Exemplo matricial impresso"
                                  ],
                                  "tips": "Use np.linalg.pinv para SVD e resolva QR via scipy.linalg.qr.",
                                  "learningObjective": "Demonstrar equivalência em casos ideais.",
                                  "commonMistakes": [
                                    "Não normalizar b adequadamente",
                                    "Usar QR em A ao invés de A^T para subdeterminados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Falhas em Casos de Posto Deficiente",
                                  "subSteps": [
                                    "Modifique exemplo para posto deficiente: A = [[1,0,1],[1,0,1]], b = [1,1] (inconsistente, mas foque em aproximação mínima norma).",
                                    "Tente projeção ortogonal: (A A^T) é singular, observe falha ou uso de pseudoinverso implícito.",
                                    "Aplique QR: R terá zeros, levando a instabilidade numérica.",
                                    "Use SVD: Σ^+ lida naturalmente com singular values zero, dando solução estável.",
                                    "Quantifique erros com ruído: compare ||x - x_true|| para cada método."
                                  ],
                                  "verification": "Gere tabela de erros numéricos mostrando SVD superior.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python do passo anterior",
                                    "Matrizes com ruído gerado por np.random"
                                  ],
                                  "tips": "Adicione ruído condicionado: A_noisy = A + 1e-8 * np.random.randn(m,n).",
                                  "learningObjective": "Destacar robustez da SVD em rank deficiency.",
                                  "commonMistakes": [
                                    "Assumir consistência no sistema deficiente",
                                    "Não checar condição de A A^T"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Vantagens Numéricas e Conclusões",
                                  "subSteps": [
                                    "Compile métricas: estabilidade (cond number), tempo, precisão em full/rank deficient.",
                                    "Explique por quê SVD é preferida: valores singulares revelam rank, evita inversões instáveis.",
                                    "Discuta custos: SVD O(m n^2) vs QR O(m n^2), mas SVD mais versátil.",
                                    "Crie infográfico comparativo.",
                                    "Responda: Em que cenários usar cada um?"
                                  ],
                                  "verification": "Escreva relatório de 1 página com tabela e gráfico de erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramenta de plot como Matplotlib",
                                    "Modelo de relatório"
                                  ],
                                  "tips": "Foco em 'SVD é gold standard para problemas mal-condicionados'.",
                                  "learningObjective": "Articular vantagens claras da SVD.",
                                  "commonMistakes": [
                                    "Superestimar velocidade de QR ignorando estabilidade",
                                    "Não mencionar aplicações híbridas"
                                  ]
                                }
                              ],
                              "practicalExample": "Sistema de compressão de sinal: Encontrar coeficientes mínimos (x) para reconstruir sinal b com base A (2 sensores, 3 frequências). Em ruído ou falha de sensor (posto deficiente), SVD recupera x estável, enquanto QR/projeção falha.",
                              "finalVerifications": [
                                "Explicar verbalmente por que SVD lida com singular values zero.",
                                "Implementar código que falha em outros métodos mas succeeds em SVD.",
                                "Identificar rank deficiency em matriz dada.",
                                "Comparar normas de soluções em exemplo numérico.",
                                "Listar 3 vantagens numéricas da SVD.",
                                "Prever performance em matriz mal-condicionada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de fórmulas (100% correta).",
                                "Demonstração prática com código funcional e resultados comparativos.",
                                "Análise quantitativa de erros numéricos (tabelas/gráficos).",
                                "Clareza na explicação de vantagens em posto deficiente.",
                                "Profundidade em limitações dos métodos alternativos.",
                                "Relatório conciso e bem estruturado."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação numérica em SciPy/NumPy.",
                                "Estatística: Regressão ridge como regularização similar a truncada SVD.",
                                "Engenharia: Otimização em controle de sistemas subdeterminados.",
                                "Física: Reconstrução de imagens em tomografia com rank deficiency."
                              ],
                              "realWorldApplication": "Em machine learning, SVD é usada no pseudoinverso para regressão linear subdeterminada em feature selection com multicolinearidade (posto deficiente), superando QR em estabilidade para previsão financeira ou processamento de imagens médicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.6",
                    "name": "Análise de Sensibilidade via SVD",
                    "description": "Avaliação da sensibilidade e condição de sistemas lineares através dos valores singulares menores.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.6.1",
                        "name": "Número de Condição de Matrizes via SVD",
                        "description": "Compreensão do número de condição cond(A) = σ_max / σ_min, onde σ_max e σ_min são os maiores e menores valores singulares obtidos pela decomposição SVD de A, e sua relação com a sensibilidade numérica de operações matriciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.1.1",
                            "name": "Calcular o número de condição usando SVD",
                            "description": "Dado uma matriz A, computar sua SVD e extrair σ_max e σ_min para determinar cond(A), interpretando valores altos como indicativos de ill-condicionamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a matriz A e o ambiente computacional",
                                  "subSteps": [
                                    "Escolha ou defina uma matriz A de dimensões mxn (ex: 2x2 ou 3x3 para testes iniciais).",
                                    "Verifique se A é quadrada ou retangular, e garanta que ela seja de posto completo se possível.",
                                    "Instale e importe bibliotecas necessárias, como NumPy no Python.",
                                    "Crie a matriz A usando np.array() e exiba-a para confirmação.",
                                    "Confirme os pré-requisitos: conhecimento de SVD teórica e programação básica."
                                  ],
                                  "verification": "Matriz A criada corretamente e exibida sem erros; shape e valores confirmados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python com NumPy instalado",
                                    "Editor de código (Jupyter Notebook recomendado)"
                                  ],
                                  "tips": "Use matrizes pequenas inicialmente para depuração rápida; sempre imprima A com np.linalg.norm(A) para checar.",
                                  "learningObjective": "Configurar ambiente e preparar dados para análise SVD.",
                                  "commonMistakes": [
                                    "Esquecer de importar numpy as np",
                                    "Definir matriz com dtype incorreto (use float64)",
                                    "Não verificar se A é não-singular"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar a decomposição SVD da matriz A",
                                  "subSteps": [
                                    "Utilize np.linalg.svd(A, full_matrices=False) para obter U, s, Vh.",
                                    "Armazene os resultados: U (matriz esquerda), s (vetor de valores singulares decrescentes), Vh (matriz direita hermitiana).",
                                    "Reconstrua A aproximada com np.dot(U, np.dot(np.diag(s), Vh)) e compare com original.",
                                    "Exiba os valores singulares s para inspeção inicial.",
                                    "Trate casos de matrizes retangulares ajustando dimensões."
                                  ],
                                  "verification": "Reconstrução de A tem erro norm < 1e-10; valores singulares exibidos e ordenados decrescentemente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código Python com NumPy",
                                    "Documentação np.linalg.svd"
                                  ],
                                  "tips": "Use full_matrices=False para eficiência; verifique ordenação de s com np.sort(s)[::-1].",
                                  "learningObjective": "Executar SVD numericamente e validar decomposição.",
                                  "commonMistakes": [
                                    "Confundir Vh com V (Vh é V^H)",
                                    "Não normalizar ou escalar A previamente",
                                    "Ignorar warnings de singularidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair σ_max e σ_min dos valores singulares",
                                  "subSteps": [
                                    "Identifique σ_max como s[0] (primeiro elemento do vetor s).",
                                    "Identifique σ_min como s[-1] (último elemento não-zero; verifique posto com np.linalg.matrix_rank(A)).",
                                    "Confirme que σ_min > 0 ou trate zeros como indicativo de singularidade.",
                                    "Calcule rácio preliminar σ_max / σ_min e exiba.",
                                    "Registre os valores para documentação."
                                  ],
                                  "verification": "σ_max e σ_min extraídos corretamente; rácio inicial computado e valores impressos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Código Python existente",
                                    "Função np.linalg.matrix_rank"
                                  ],
                                  "tips": "Para matrizes grandes, use np.min(s[s > 1e-12]) para evitar zeros numéricos.",
                                  "learningObjective": "Selecionar valores singulares relevantes para análise de condicionamento.",
                                  "commonMistakes": [
                                    "Pegar σ_min como s[0] por engano",
                                    "Não filtrar zeros numéricos",
                                    "Assumir posto completo sem checar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular o número de condição e interpretar resultados",
                                  "subSteps": [
                                    "Compute cond(A) = σ_max / σ_min.",
                                    "Avalie o valor: cond(A) < 10^3 bom; >10^6 mal-condicionado.",
                                    "Compare com np.linalg.cond(A) para validação.",
                                    "Interprete: alto cond indica sensibilidade a perturbações.",
                                    "Gere relatório com valores e conclusão."
                                  ],
                                  "verification": "cond(A) calculado bate com np.linalg.cond; interpretação escrita.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código Python",
                                    "Referência teórica de álgebra linear"
                                  ],
                                  "tips": "Log10(cond) é comum para escalas; teste com matrizes conhecidas (ex: Hilbert).",
                                  "learningObjective": "Interpretar número de condição no contexto de estabilidade numérica.",
                                  "commonMistakes": [
                                    "Dividir σ_min / σ_max",
                                    "Ignorar escala da matriz",
                                    "Não validar com função built-in"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 1], [1, 1+1e-10]]. SVD dá σ_max ≈ √2, σ_min ≈ 1e-10 / √2, cond(A) ≈ 1e10, indicando ill-condicionamento devido à quasi-singularidade.",
                              "finalVerifications": [
                                "Cálculo de cond(A) coincide com np.linalg.cond(A) em pelo menos 5 dígitos.",
                                "Reconstrução SVD tem erro relativo < 1e-12.",
                                "Interpretação correta: alto cond implica sensibilidade.",
                                "Teste com matriz bem-condicionada (ex: identidade) dá cond≈1.",
                                "Relatório inclui σ_max, σ_min e cond.",
                                "Código roda sem erros em matrizes 2x2 e 3x3."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica na SVD e extração de singulares (90%+ match com built-in).",
                                "Correta identificação e tratamento de σ_min (não-zero).",
                                "Interpretação qualitativa adequada (ill-condicionado se cond>10^6).",
                                "Validação cruzada com funções padrão.",
                                "Código limpo, comentado e reproduzível.",
                                "Tempo total dentro de 1 hora para exemplos variados."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Uso de NumPy/SciPy em análise linear.",
                                "Engenharia: Análise de estabilidade em sistemas lineares (controle, estruturas).",
                                "Física Computacional: Condicionamento em simulações de PDEs.",
                                "Machine Learning: Regularização em PCA/SVD para dados ruidosos."
                              ],
                              "realWorldApplication": "Em engenharia civil, avalia sensibilidade de matrizes de rigidez em simulações FEM; alto cond alerta para instabilidade numérica, evitando erros em análises de estruturas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.1.2",
                            "name": "Interpretar o impacto do cond(A) em operações lineares",
                            "description": "Analisar como cond(A) afeta a amplificação de erros relativos em multiplicações matriciais e inversões, usando exemplos numéricos com SVD.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição de cond(A) via Decomposição SVD",
                                  "subSteps": [
                                    "Lembre-se que para uma matriz A m×n, SVD é A = U Σ V^T, onde Σ tem valores singulares σ1 ≥ σ2 ≥ ... ≥ σr > 0.",
                                    "Defina cond(A) = σ1 / σ_min, onde σ_min é o menor valor singular não-nulo.",
                                    "Discuta que cond(A) = 1 indica matriz bem condicionada; cond(A) >> 1 indica mal condicionada.",
                                    "Calcule cond(A) para uma matriz de exemplo 2x2."
                                  ],
                                  "verification": "Conseguiu calcular cond(A) corretamente para uma matriz dada e explicar seu significado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou software como MATLAB/Python com numpy/scipy.",
                                  "tips": "Sempre normalize as matrizes para ||A||=1 ao comparar condições.",
                                  "learningObjective": "Compreender a interpretação geométrica e numérica de cond(A) via SVD.",
                                  "commonMistakes": "Confundir cond(A) com det(A) ou ignorar que cond(A) é sempre ≥1."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar amplificação de erros em multiplicações matriciais",
                                  "subSteps": [
                                    "Considere o erro relativo em y = A x, onde δx leva a δy ≈ A δx; assim ||δy||/||y|| ≤ cond(A) ||δx||/||x||.",
                                    "Para produto AB, cond(AB) ≤ cond(A) cond(B), mostrando amplificação cumulativa.",
                                    "Use SVD para decompor: o erro é amplificado pelo fator σ1/σ_min nos modos singulares pequenos.",
                                    "Simule numericamente com uma matriz mal condicionada."
                                  ],
                                  "verification": "Demonstre com números que um pequeno erro em x é amplificado por cond(A) em y.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de álgebra linear (Octave/MATLAB ou Jupyter com numpy).",
                                  "tips": "Escolha matrizes com σ1/σ_min = 10^3 para ver amplificação clara.",
                                  "learningObjective": "Quantificar como cond(A) bounda a amplificação de erros relativos em Ax.",
                                  "commonMistakes": "Ignorar normas consistentes (use norma 2 para SVD) ou confundir erro absoluto com relativo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar impacto em inversões matriciais",
                                  "subSteps": [
                                    "Para A^{-1}, cond(A^{-1}) = cond(A), e erro em b leva a δx ≈ cond(A) (||δb||/||b||) na solução x = A^{-1} b.",
                                    "Via SVD, A^{-1} = V Σ^{-1} U^T, onde Σ^{-1} amplifica 1/σ_min.",
                                    "Compare estabilidade: inversão é pior que multiplicação por cond(A)^2 em alguns casos.",
                                    "Calcule exemplo onde ruído em b é amplificado drasticamente se cond(A) alto."
                                  ],
                                  "verification": "Mostre que ||δx||/||x|| ≈ cond(A) ||δb||/||b|| em um exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesmos do passo anterior; inclua função svd() e inv().",
                                  "tips": "Evite inversão direta em software; use solve() para precisão.",
                                  "learningObjective": "Entender por que inversões são sensíveis e ligar diretamente a cond(A).",
                                  "commonMistakes": "Pensar que cond(A) afeta só multiplicação, ignorando simetria com inversa."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar com exemplos numéricos usando SVD",
                                  "subSteps": [
                                    "Gere matriz A com SVD controlada: Σ = diag(1, 10^{-k}), k=1 a 6.",
                                    "Aplique perturbação δx = 10^{-6} x e compute erros em Ax e A^{-1} b.",
                                    "Plote ||δy||/||y|| vs cond(A) para visualizar amplificação linear.",
                                    "Conclua: cond(A) prediz perda de dígitos precisão ≈ log10(cond(A))."
                                  ],
                                  "verification": "Gráfico ou tabela mostrando amplificação proporcional a cond(A).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python/MATLAB com plotting (matplotlib/plot).",
                                  "tips": "Use precisão dupla; adicione ruído gaussiano realista.",
                                  "learningObjective": "Integrar teoria com prática numérica para interpretação robusta.",
                                  "commonMistakes": "Usar matrizes simétricas só; teste não-simétricas para generalidade."
                                }
                              ],
                              "practicalExample": "Considere A = [[1,0],[0,1e-3]], SVD dá σ1=1, σ2=1e-3, cond(A)=1000. Para x=[1,1], δx=1e-6*[1,1], então em y=Ax, erro relativo amplificado ~1000 no segundo componente. Para b=Ax+δb com δb=1e-6, x_est = A^{-1}b tem erro ~1000x maior.",
                              "finalVerifications": [
                                "Explica verbalmente como cond(A) bounda amplificação em Ax e A^{-1}b.",
                                "Calcula cond(A) via SVD para nova matriz e prevê erro relativo.",
                                "Simula exemplo com cond(A)=10^4 e confirma perda de ~4 dígitos.",
                                "Distingue impacto em multiplicação vs inversão.",
                                "Identifica quando cond(A) alto torna operação numéricamente instável."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de SVD e cond(A) (erro <1%).",
                                "Correta derivação de bounds de erro relativo envolvendo cond(A).",
                                "Exemplos numéricos mostram amplificação quantitativa exata.",
                                "Interpretação qualitativa: liga cond(A) a estabilidade prática.",
                                "Uso adequado de normas e perturbações relativas.",
                                "Gráficos/tabelas claros e conclusivos."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Estabilidade de algoritmos de solve/inv.",
                                "Computação Científica: Condicionamento em simulações PDEs.",
                                "Engenharia: Sensibilidade em controle de sistemas lineares.",
                                "Física Computacional: Erros em reconstrução de imagens via SVD."
                              ],
                              "realWorldApplication": "Em processamento de sinais, imagens ruidosas são restauradas via SVD; alto cond(A) amplifica ruído, exigindo regularização. Em finanças, modelos lineares para portfólios sensíveis a cond(A) alto causam instabilidade em otimização sob perturbações de dados de mercado."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.1.3",
                            "name": "Comparar cond(A) com normas matriciais",
                            "description": "Relacionar o número de condição SVD com estimativas via normas 2, demonstrando equivalência e superioridade computacional da SVD.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definição de Número de Condição via Normas Matriciais",
                                  "subSteps": [
                                    "Defina o número de condição cond(A) = ||A||₂ * ||A⁻¹||₂ para matrizes invertíveis.",
                                    "Explique a norma 2 de uma matriz como o maior valor singular (σ_max).",
                                    "Discuta implicações: cond(A) alto indica sensibilidade a perturbações.",
                                    "Calcule ||A||₂ e ||A⁻¹||₂ para uma matriz simples usando propriedades espectrais.",
                                    "Estime cond(A) superior e inferior usando normas auxiliares (1, ∞)."
                                  ],
                                  "verification": "Resolva exercícios manuais para 2 matrizes 2x2, confirmando cond(A) ≈ σ_max/σ_min.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel, calculadora científica, tabela de normas matriciais.",
                                  "tips": "Use norma 2 sempre para precisão; evite normas inconsistentes.",
                                  "learningObjective": "Compreender e calcular cond(A) usando normas 2 diretamente.",
                                  "commonMistakes": "Confundir norma de vetor com norma de matriz; esquecer de inverter A corretamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Número de Condição via Decomposição SVD",
                                  "subSteps": [
                                    "Lembre SVD: A = U Σ V^*, onde Σ = diag(σ₁ ≥ σ₂ ≥ ... ≥ σ_n ≥ 0).",
                                    "Mostre que cond₂(A) = σ₁ / σ_n para A quadrada invertível.",
                                    "Implemente SVD numericamente em Python/MATLAB para uma matriz teste.",
                                    "Extraia σ_max e σ_min diretamente de Σ.",
                                    "Compare com autovalores para matrizes normais."
                                  ],
                                  "verification": "Compute SVD de A e confirme cond(A) = σ₁/σ_n com erro < 1e-10.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/SciPy ou MATLAB, matriz de teste 3x3.",
                                  "tips": "Use funções prontas como np.linalg.svd() para validar manualmente.",
                                  "learningObjective": "Calcular cond(A) precisamente via SVD sem inverter matriz.",
                                  "commonMistakes": "Ignorar σ_n = 0 para matrizes singulares; confundir σ com autovalores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar Equivalência Teórica entre Abordagens",
                                  "subSteps": [
                                    "Prove que ||A||₂ = σ₁ e ||A⁻¹||₂ = 1/σ_n via propriedades SVD.",
                                    "Mostre cond(A) = σ₁/σ_n ≡ ||A||₂ ||A⁻¹||₂.",
                                    "Discuta bounds: cond(A) ≤ ||A||_F ||A⁻¹||_F, mas norma 2 é exata.",
                                    "Analise estabilidade: SVD evita inversão explícita.",
                                    "Derive erro relativo |Δx|/|x| ≤ cond(A) |Δb|/|b| em ambos contextos."
                                  ],
                                  "verification": "Escreva prova curta (1 página) e verifique com contraexemplo.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Livro de Álgebra Linear Numérica (ex: Golub-Van Loan), quadro branco.",
                                  "tips": "Visualize com plot de singular values para intuição.",
                                  "learningObjective": "Provar matematicamente a equivalência das duas estimativas.",
                                  "commonMistakes": "Esquecer que SVD dá todos σ_i sem computar inversa."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Superioridade Computacional da SVD",
                                  "subSteps": [
                                    "Implemente ambas: norma2_inv = np.linalg.norm(A,2)*np.linalg.norm(np.linalg.inv(A),2).",
                                    "Versão SVD: np.linalg.cond(A,'euclidean') ou σ1/σn.",
                                    "Meça tempo e precisão para matrizes 10x10, 100x100 com ruído.",
                                    "Analise flops: O(n³) para inv vs O(n³) SVD mas estável.",
                                    "Teste ill-conditioned matrices (ex: Hilbert) para ver falhas na inversão."
                                  ],
                                  "verification": "Gere relatório com tempos, erros e plots de cond vs tamanho.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python/Octave com %timeit, matrizes geradas (Hilbert, random).",
                                  "tips": "Use cond=1e-15 para near-singular; compare com frobenius.",
                                  "learningObjective": "Demonstrar numericamente superioridade SVD em estabilidade e custo.",
                                  "commonMistakes": "Usar matrizes bem-condicionadas onde diferenças são pequenas."
                                }
                              ],
                              "practicalExample": "Para A = [[1, 0.1], [0.1, 1]], calcule cond(A) via normas: ||A||₂ ≈ 1.0488, ||A⁻¹||₂ ≈ 1.0488, cond≈1.1. Via SVD: σ₁≈1.0488, σ₂≈0.9512, cond=1.102. SVD é exata e evita instabilidade em A maior.",
                              "finalVerifications": [
                                "Calcula cond(A) via normas e SVD com concordância <1%.",
                                "Explica prova de equivalência σ₁/σ_n = ||A||₂||A⁻¹||₂.",
                                "Implementa código que compara tempos para n=50.",
                                "Identifica caso onde inversão falha mas SVD succeeds.",
                                "Discute aplicações em análise de sensibilidade.",
                                "Responde quiz: 'Por que SVD é preferida?'"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas provas (90% correto).",
                                "Correção e eficiência do código (sem erros numéricos).",
                                "Profundidade na análise comparativa (tempos, flops).",
                                "Clareza em exemplos e visualizações.",
                                "Compreensão de implicações numéricas (estabilidade).",
                                "Criatividade em testes (matrizes variadas)."
                              ],
                              "crossCurricularConnections": [
                                "Ciências da Computação: Algoritmos numéricos e estabilidade (LAPACK).",
                                "Física: Análise de erros em simulações diferenciais.",
                                "Engenharia: Estabilidade de sistemas lineares em controle.",
                                "Machine Learning: Condicionamento em regressão e PCA."
                              ],
                              "realWorldApplication": "Em image compression/processamento, SVD avalia sensibilidade de filtros; em finanças, modela risco em portfólios via matriz de covariância; em engenharia, verifica estabilidade de estruturas sob perturbações."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.6.2",
                        "name": "Sensibilidade de Soluções de Sistemas Lineares Ax = b",
                        "description": "Avaliação de como perturbações em A e b propagam para a solução x via SVD, com fórmulas de erro relativo boundeadas por cond(A).",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.2.1",
                            "name": "Derivar bounds de erro para perturbações em b",
                            "description": "Usar SVD para provar que ||δx|| / ||x|| ≤ cond(A) * ||δb|| / ||b||, aplicando em exemplos perturbados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Decomposição SVD e Solução de Sistemas Lineares",
                                  "subSteps": [
                                    "Lembre-se da decomposição SVD: A = U Σ V^T, onde U e V são ortogonais, Σ diagonal com singular values σ1 ≥ σ2 ≥ ... ≥ σn > 0.",
                                    "Expresse a solução x de Ax = b como x = V Σ^{-1} U^T b.",
                                    "Verifique as propriedades: ||U|| = ||V|| = 1 (norma 2), Σ^{-1} tem 1/σi.",
                                    "Calcule cond(A) = σ1 / σn.",
                                    "Pratique com uma matriz 2x2 simples para fixar."
                                  ],
                                  "verification": "Conseguir decompor uma matriz de teste via SVD e resolver Ax = b corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e lápis ou software como Python (NumPy) ou MATLAB.",
                                  "tips": "Use funções prontas de SVD para verificação numérica antes da prova manual.",
                                  "learningObjective": "Compreender como SVD resolve sistemas lineares e define cond(A).",
                                  "commonMistakes": "Confundir Σ^{-1} com inversa de A diretamente; ignorar que singular values podem ser zero."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar Expressão para Perturbação δx em b",
                                  "subSteps": [
                                    "Considere b + δb, então solução perturbada x + δx = V Σ^{-1} U^T (b + δb).",
                                    "Subtraia: δx = V Σ^{-1} U^T δb.",
                                    "Note que x = V Σ^{-1} U^T b.",
                                    "Expresse ||δx||_2 = ||V Σ^{-1} U^T δb||_2 ≤ ||Σ^{-1}||_2 ||δb||_2, pois ||V||=||U||=1.",
                                    "Identifique ||Σ^{-1}||_2 = 1 / σn."
                                  ],
                                  "verification": "Escrever δx explicitamente e calcular sua norma superior.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Folha de derivadas matriciais, calculadora simbólica opcional (SymPy).",
                                  "tips": "Sempre use normas induzidas compatíveis (norma 2 aqui).",
                                  "learningObjective": "Expressar e normar a perturbação δx usando propriedades SVD.",
                                  "commonMistakes": "Esquecer que U e V preservam normas; usar norma errada (ex: Frobenius em vez de 2)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar o Bound Relativo de Erro",
                                  "subSteps": [
                                    "Para ||δx|| / ||x||, note ||x|| ≥ σ1^{-1} ||b|| pois ||x|| = ||Σ^{-1} U^T b|| ≥ σn^{-1} ||U^T b|| wait, corrija para bounds precisos.",
                                    "||δx|| ≤ (1/σn) ||δb||.",
                                    "||x|| ≥ (1/σ1) ||b||.",
                                    "Assim, ||δx|| / ||x|| ≤ (σ1 / σn) * (||δb|| / ||b||) = cond(A) * (||δb|| / ||b||).",
                                    "Escreva a prova completa passo a passo."
                                  ],
                                  "verification": "Derivar a desigualdade ||δx|| / ||x|| ≤ cond(A) * ||δb|| / ||b|| simbolicamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Livro de Álgebra Linear (ex: Golub-Van Loan), notas de aula.",
                                  "tips": "Use desigualdades triangulares com cuidado; foque em normas 2 espectrais.",
                                  "learningObjective": "Provar rigorosamente o bound de erro relativo para perturbações em b.",
                                  "commonMistakes": "Inverter σ_max e σ_min; confundir cond(A) com trace ou det."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar em Exemplo Numérico Perturbado",
                                  "subSteps": [
                                    "Escolha A = [[2,0],[0,1]], b = [2,1], compute SVD e x = [1,1].",
                                    "Perturbe b com δb = [0.01, 0.005], compute x perturbado e δx.",
                                    "Calcule ||δx||/||x|| e cond(A)*||δb||/||b||, verifique se ≤.",
                                    "Teste com A ill-condicionada, ex: [[1,1],[1,1.0001]].",
                                    "Analise como cond(A) amplifica erro."
                                  ],
                                  "verification": "Resultados numéricos confirmam a desigualdade com tolerância 1e-10.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python/MATLAB com NumPy/SVD, planilha Excel para simples.",
                                  "tips": "Use np.linalg.cond() para checar cond(A).",
                                  "learningObjective": "Validar teorema numericamente e observar amplificação por cond(A).",
                                  "commonMistakes": "Erro de arredondamento em SVD numérica; não normalizar por ||x|| e ||b||."
                                }
                              ],
                              "practicalExample": "Para A = [[1, 0], [0, 0.01]], b = [1, 0.01], cond(A)=100. Perturbe b com δb=[0.001, 0], x=[1,1], δx≈[0.001, 0], ||δx||/||x||≈0.0007, cond(A)*||δb||/||b||≈0.01, confirma ≤.",
                              "finalVerifications": [
                                "Prova simbólica completa escrita.",
                                "Exemplo numérico com pelo menos duas matrizes (bem e mal condicionadas).",
                                "Cálculos de normas e cond(A) exatos.",
                                "Gráfico de erro relativo vs. perturbação.",
                                "Explicação verbal da amplificação por cond(A)."
                              ],
                              "assessmentCriteria": [
                                "Correção da derivação de δx e bound (100%).",
                                "Uso preciso de normas 2 e propriedades SVD (90%).",
                                "Exemplo numérico reproduzível e ilustrativo (85%).",
                                "Interpretação qualitativa do condicionamento (80%).",
                                "Clareza na prova e código (75%).",
                                "Identificação de limites (ex: A não quadrada)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementar SVD em Python/MATLAB.",
                                "Estatística: Análise de erro em regressão linear.",
                                "Engenharia: Sensibilidade em modelagem de sistemas.",
                                "Física Computacional: Propagação de erros em simulações."
                              ],
                              "realWorldApplication": "Em engenharia civil, b representa medições com ruído sensorial; bound ajuda a quantificar confiança na solução x (deslocamentos), evitando colapsos por amplificação de erros em matrizes ill-condicionadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.2.2",
                            "name": "Analisar sensibilidade para perturbações em A",
                            "description": "Computar e interpretar bounds como ||δx|| / ||x|| ≤ cond(A)^2 * ||δA|| / ||A|| usando decomposição SVD.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Realizar a decomposição SVD da matriz A",
                                  "subSteps": [
                                    "Escolha ou defina uma matriz A quadrada ou retangular adequada (ex: 2x2 para simplicidade).",
                                    "Use software numérico (Python com numpy.linalg.svd ou MATLAB svd) para computar U, Σ, Vh.",
                                    "Verifique que A = U @ Σ @ Vh, computando o produto e comparando com A original.",
                                    "Identifique os valores singulares σ1 ≥ σ2 ≥ ... ≥ σr > 0.",
                                    "Registre os valores singulares em ordem decrescente."
                                  ],
                                  "verification": "Confirme que o erro de reconstrução ||A - UΣVh|| < 1e-10 (norma Frobenius).",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Matriz A exemplo (ex: [[1, 0], [0, 0.01]]",
                                    "Python com numpy ou MATLAB"
                                  ],
                                  "tips": "Sempre normalize as normas das matrizes para evitar overflow numérico.",
                                  "learningObjective": "Dominar o cálculo e verificação da SVD de uma matriz.",
                                  "commonMistakes": "Confundir ordem dos valores singulares ou não verificar a reconstrução da matriz."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o número de condicionamento cond(A)",
                                  "subSteps": [
                                    "Extraia σ_max (primeiro valor singular) e σ_min (último não-zero).",
                                    "Compute cond(A) = σ_max / σ_min usando norma 2.",
                                    "Interprete: cond(A) ≈ 1 indica matriz bem condicionada; >10^6 indica ill-conditioned.",
                                    "Calcule cond(A)^2 para uso posterior na bound.",
                                    "Compare com cond(A) via norma (||A|| * ||A_inv||) para validação."
                                  ],
                                  "verification": "Verifique se cond(A) via SVD coincide com estimativa via inversa dentro de 1% de erro relativo.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Resultados SVD do Step 1",
                                    "Calculadora ou script Python/MATLAB"
                                  ],
                                  "tips": "Use log(cond) para valores grandes para evitar underflow em cond^2.",
                                  "learningObjective": "Compreender e calcular o condicionamento espectral via SVD.",
                                  "commonMistakes": "Usar σ_min = 0 para matrizes singulares sem truncar zeros numéricos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir perturbação δA e calcular normas relativas",
                                  "subSteps": [
                                    "Gere δA pequena (ex: δA = 1e-6 * randn(size(A)) ou perturbação direcionada).",
                                    "Compute ||A||_2 (σ_max) e ||δA||_2 via SVD de δA ou norma direta.",
                                    "Calcule perturbação relativa ε = ||δA|| / ||A||.",
                                    "Escolha b arbitrário, resolva x = A\\b e x_pert = (A+δA)\\b para referência numérica.",
                                    "Registre ε tipicamente < 1e-6 para simular erros de precisão máquina."
                                  ],
                                  "verification": "Confirme ε << 1 e resolva sistemas sem singularidade em A+δA.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Matriz A e SVD do Step 1",
                                    "Gerador de randn em Python/MATLAB"
                                  ],
                                  "tips": "Perturbe em direção de vetores singulares para maximizar impacto.",
                                  "learningObjective": "Quantificar perturbações relativas em matrizes.",
                                  "commonMistakes": "Usar norma errada (ex: Frobenius em vez de 2) ou δA muito grande."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar e interpretar o bound de sensibilidade",
                                  "subSteps": [
                                    "Aplique fórmula: bound = cond(A)^2 * ε.",
                                    "Compute erro real relativo ||δx|| / ||x|| via soluções numéricas.",
                                    "Verifique se erro real ≤ bound teórico.",
                                    "Interprete: Alto cond(A) amplifica erros em A para erros grandes em x.",
                                    "Escreva relatório: 'A é sensível se cond(A)^2 * ε > threshold (ex: 0.01)'."
                                  ],
                                  "verification": "Bound ≥ erro real e interpretação explica causa (rank deficiency via SVD).",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "cond(A), ε dos steps anteriores",
                                    "Soluções x e x_pert"
                                  ],
                                  "tips": "Compare bound com erro real para validar teoria vs prática.",
                                  "learningObjective": "Aplicar e interpretar bounds de sensibilidade usando SVD.",
                                  "commonMistakes": "Esquecer o ^2 no cond ou interpretar bound como igualdade exata."
                                }
                              ],
                              "practicalExample": "Para A = [[1, 0.1], [0.1, 1]], SVD dá σ1≈1.05, σ2≈0.95, cond(A)≈1.1. Perturbe δA=[[0,1e-6],[1e-6,0]], ε≈1e-6. Bound≈1.2*1e-6. Erro real em x para b=[1,1] é ~5e-7, confirmando bound conservador.",
                              "finalVerifications": [
                                "SVD de A computada e verificada corretamente.",
                                "cond(A) e cond(A)^2 calculados com precisão.",
                                "Perturbação δA gera ε correto e bound aplicado.",
                                "Erro real ≤ bound teórico em exemplo numérico.",
                                "Interpretação escrita identifica sensibilidade baseada em cond(A)."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica em todos cálculos (erro <1e-8).",
                                "Correta aplicação da fórmula de bound com cond^2.",
                                "Interpretação qualitativa e quantitativa da sensibilidade.",
                                "Validação cruzada com erro real vs bound.",
                                "Uso apropriado de normas e SVD em todos steps.",
                                "Relatório claro com gráficos de erros opcionais."
                              ],
                              "crossCurricularConnections": [
                                "Computação Científica: Implementação numérica estável de SVD.",
                                "Engenharia: Análise de estabilidade em sistemas lineares (ex: estruturas).",
                                "Física: Sensibilidade em equações diferenciais discretizadas.",
                                "Estatística: Condicionamento em regressão linear múltipla."
                              ],
                              "realWorldApplication": "Em modelagem financeira, analisar como pequenas perturbações nos coeficientes de matriz de covariância (devido a dados ruidosos) amplificam erros em portfólios otimizados, usando SVD para detectar e mitigar riscos de ill-conditioning."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.2.3",
                            "name": "Simular numericamente sensibilidade com SVD",
                            "description": "Implementar em software (ex: MATLAB/Python) perturbações aleatórias em A e b, comparando erros previstos por cond(A) com erros observados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de programação e definir o sistema linear original",
                                  "subSteps": [
                                    "Instale as bibliotecas necessárias: numpy, scipy e matplotlib via pip.",
                                    "Defina uma matriz A de tamanho n x n (ex: 3x3 mal condicionada, como A = np.array([[1, 1, 1], [1, 2, 3], [1, 3, 6]])).",
                                    "Crie o vetor b correspondente para uma solução exata conhecida x_exact = np.array([1, 2, 3]).",
                                    "Resolva o sistema original x = np.linalg.solve(A, b) e verifique se ||Ax - b|| < 1e-10.",
                                    "Salve A, b e x_exact em variáveis para uso posterior."
                                  ],
                                  "verification": "Executar o código resulta em x aproximando x_exact com erro relativo < 1e-12.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "NumPy",
                                    "SciPy",
                                    "Matplotlib"
                                  ],
                                  "tips": "Comece com matrizes pequenas para depuração rápida; use np.set_printoptions(precision=10) para visualização.",
                                  "learningObjective": "Preparar um sistema linear numérico estável para simulações de sensibilidade.",
                                  "commonMistakes": [
                                    "Escolher matrizes bem condicionadas (cond < 10),",
                                    "Erros em importações ou sintaxe de arrays.",
                                    "Não verificar a solução exata antes de prosseguir."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar decomposição SVD de A e calcular o número de condição",
                                  "subSteps": [
                                    "Compute a SVD: U, S, Vh = np.linalg.svd(A, full_matrices=False).",
                                    "Calcule o número de condição cond_A = S[0] / S[-1].",
                                    "Armazene os valores singulares S para análise posterior.",
                                    "Imprima cond_A e discuta se A é bem ou mal condicionada (cond_A > 1e6 indica mal condicionada).",
                                    "Visualize os valores singulares com plt.plot(S) para entender a distribuição."
                                  ],
                                  "verification": "cond_A calculado corretamente e plot de S gerado sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "NumPy",
                                    "Matplotlib"
                                  ],
                                  "tips": "Use full_matrices=False para eficiência em matrizes não quadradas; compare com np.linalg.cond(A).",
                                  "learningObjective": "Aplicar SVD para quantificar a sensibilidade inata da matriz A via número de condição.",
                                  "commonMistakes": [
                                    "Confundir S com sigma (S já são os valores singulares).",
                                    "Usar svdvals em vez de svd completa.",
                                    "Ignorar normalização dos valores singulares."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar perturbações aleatórias em A e b",
                                  "subSteps": [
                                    "Defina níveis de ruído eps = [1e-6, 1e-5, 1e-4, 1e-3] (4 níveis).",
                                    "Crie um loop para 100 simulações por eps: gere delta_A ~ N(0, eps * ||A||), delta_b ~ N(0, eps * ||b||).",
                                    "Forme A_pert = A + delta_A, b_pert = b + delta_b.",
                                    "Resolva x_pert = np.linalg.solve(A_pert, b_pert) para cada caso.",
                                    "Calcule erro relativo observado: err_obs = np.linalg.norm(x_pert - x_exact) / np.linalg.norm(x_exact)."
                                  ],
                                  "verification": "Arrays de err_obs para cada eps com 100 amostras cada, sem falhas de singularidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "NumPy",
                                    "SciPy"
                                  ],
                                  "tips": "Use np.random.normal(0, eps * np.linalg.norm(A), A.shape) para delta_A; vetorize loops se possível.",
                                  "learningObjective": "Simular ruído realista em dados de entrada para sistemas lineares.",
                                  "commonMistakes": [
                                    "Perturbações muito grandes causando singularidade.",
                                    "Norma errada (use norma 2).",
                                    "Poucas simulações levando a variância alta."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar erros observados com erros previstos pelo cond(A)",
                                  "subSteps": [
                                    "Calcule erro relativo previsto: err_pred = cond_A * eps para cada nível.",
                                    "Para cada eps, compute média e desvio padrão de err_obs.",
                                    "Plote log-log: eixo x = eps, y = err_obs (scatter) vs linha err_pred.",
                                    "Calcule correlação entre log(err_obs) e log(err_pred) (deve ser ~1).",
                                    "Analise resíduos: err_obs / err_pred ≈ 1 confirma teoria SVD."
                                  ],
                                  "verification": "Gráfico mostra boa concordância (slope ~1 em log-log) e correlação > 0.9.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "NumPy",
                                    "Matplotlib"
                                  ],
                                  "tips": "Use plt.loglog para escalas log; adicione legendas e títulos descritivos.",
                                  "learningObjective": "Validar teoricamente a análise de sensibilidade via SVD com dados empíricos.",
                                  "commonMistakes": [
                                    "Escala errada no plot (use log para tendências lineares).",
                                    "Esquecer de computar médias.",
                                    "Interpretar incorretamente desvios em matrizes muito mal condicionadas."
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = np.array([[1e0, 1e0, 1e0], [1e-6, 2e-6, 3e-6], [1e-12, 3e-12, 6e-12]]), b = A @ [1,2,3], cond_A ≈ 1e12. Simule eps=1e-8: err_pred ≈ 1e4, observe err_obs próxima disso em 100 runs, confirmando alta sensibilidade.",
                              "finalVerifications": [
                                "Código completo executa sem erros e gera plots corretos.",
                                "Número de condição cond_A > 1e6 para matriz ill-conditioned.",
                                "Correlação log(err_obs) vs log(err_pred) > 0.95.",
                                "Média de err_obs / err_pred ≈ 1 ± 0.5 para todos eps.",
                                "Gráficos mostram tendência linear em escala log-log.",
                                "Solução original verificada com erro < 1e-12."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erros relativos consistentes com teoria SVD.",
                                "Clareza e modularidade do código (funções bem definidas).",
                                "Visualizações informativas com labels, legends e escalas adequadas.",
                                "Análise estatística robusta (médias, desvios, correlações).",
                                "Tratamento de edge cases (singularidades evitadas).",
                                "Comentários explicando fórmulas de sensibilidade."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Uso de bibliotecas para álgebra linear.",
                                "Estatística: Análise de Monte Carlo e variância de erros.",
                                "Engenharia Computacional: Modelagem de sistemas ruidosos.",
                                "Processamento de Sinais: SVD em filtros e compressão.",
                                "Ciência de Dados: Avaliação de estabilidade em ML linear."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, simular sensibilidade de soluções de equilíbrio estrutural (Ax=b de Malha FEA) a ruídos de medição, prevendo falhas em modelos mal condicionados para otimizar designs estáveis."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.6.3",
                        "name": "Interpretação dos Valores Singulares Menores",
                        "description": "Análise do papel dos menores valores singulares na detecção de ill-condicionamento, rank deficiente e estabilidade de soluções.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.3.1",
                            "name": "Identificar ill-condicionamento via σ_min",
                            "description": "Examinar o espectro de valores singulares para detectar σ_min próximo de zero, diagnosticando problemas de sensibilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de SVD e Ill-condicionamento",
                                  "subSteps": [
                                    "Defina Decomposição em Valores Singulares (SVD): A = U Σ V^T, onde Σ contém os valores singulares σ_i em ordem decrescente.",
                                    "Explique σ_min como o menor valor singular (σ_n para matriz n x n).",
                                    "Descreva ill-condicionamento: ocorre quando σ_min ≈ 0, levando a alta sensibilidade a perturbações.",
                                    "Discuta o número de condição κ(A) = σ_max / σ_min; κ >> 1 indica ill-condicionamento.",
                                    "Relacione com sensibilidade: erros em b amplificam em soluções de Ax = b."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos chave e calcule κ para uma matriz identidade 2x2 (deve ser 1).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Álgebra Linear (ex: Strang), notas de aula sobre SVD.",
                                  "tips": "Use analogia: σ_min pequeno é como uma estrutura frágil que desaba com pequeno empurrão.",
                                  "learningObjective": "Compreender a relação entre σ_min e estabilidade numérica de matrizes.",
                                  "commonMistakes": "Confundir σ_min com autovalor mínimo; lembrar que SVD é para qualquer matriz."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar SVD de uma Matriz Exemplo",
                                  "subSteps": [
                                    "Selecione uma matriz de teste, ex: A = [[1, 1], [1, 1+ε]] com ε pequeno (0.001).",
                                    "Use software para decompor: em Python, import numpy.linalg.svd(A, compute_uv=True).",
                                    "Extraia o vetor de valores singulares S e identifique σ_max = S[0], σ_min = S[-1].",
                                    "Calcule o espectro: plote ou liste σ_i em ordem.",
                                    "Verifique numericamente: compare com matriz bem-condicionada como identidade."
                                  ],
                                  "verification": "Obtenha σ_min < 0.01 para a matriz ill-condicionada e κ > 1000.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python com NumPy (ou MATLAB/Octave), Jupyter Notebook.",
                                  "tips": "Sempre normalize matrizes ou use full_matrices=False para eficiência.",
                                  "learningObjective": "Executar SVD computacionalmente e extrair valores singulares com precisão.",
                                  "commonMistakes": "Ignorar precisão de ponto flutuante; use eps = np.spacing(1) para thresholds."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar σ_min e Detectar Ill-condicionamento",
                                  "subSteps": [
                                    "Compare σ_min com threshold: se σ_min < 10^{-10} * σ_max, suspeite de ill-condicionamento.",
                                    "Calcule κ(A) = σ_max / σ_min e classifique: κ < 10^4 bem-condicionado, >10^12 severo.",
                                    "Examine gap entre σ_min e σ_{min+1}: gap pequeno reforça diagnóstico.",
                                    "Teste sensibilidade: adicione ruído pequeno a A ou b e observe mudança em solução.",
                                    "Documente achados: anote valores exatos e interpretação."
                                  ],
                                  "verification": "Para matriz exemplo, diagnostique corretamente como ill-condicionada com evidência numérica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Mesmo ambiente computacional do Step 2, papel para anotações.",
                                  "tips": "Use log-scale para visualizar espectro: plt.semilogy(S).",
                                  "learningObjective": "Aplicar critérios quantitativos para diagnosticar ill-condicionamento via σ_min.",
                                  "commonMistakes": "Usar valor absoluto sem normalizar por σ_max; sempre compute ratio."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Diagnóstico e Propor Soluções",
                                  "subSteps": [
                                    "Explique implicações: soluções instáveis, ex: em regressão linear ou otimização.",
                                    "Sugira remédios: regularização (Tikhonov), truncada SVD, ou reformulação problema.",
                                    "Compare com múltiplas matrizes: uma bem e uma mal condicionada.",
                                    "Gere relatório: inclua σ_min, κ, e recomendação.",
                                    "Teste em caso real: aplique a uma matriz de dados reais (ex: de sensores)."
                                  ],
                                  "verification": "Escreva parágrafo diagnosticando e propondo fix para exemplo dado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ambiente computacional, template de relatório.",
                                  "tips": "Priorize truncada SVD: retenha k maiores σ_i onde gap é grande.",
                                  "learningObjective": "Traduzir análise SVD em ações práticas para problemas sensíveis.",
                                  "commonMistakes": "Concluir ill-condicionamento só por σ_min pequeno sem contexto de σ_max."
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 1], [1, 1.0001]]. SVD dá σ_max ≈ 2, σ_min ≈ 0.0001, κ ≈ 20.000. Adicione ruído δb = [0.001, 0], solução x muda drasticamente, confirmando sensibilidade.",
                              "finalVerifications": [
                                "Computou corretamente SVD e identificou σ_min para 2 matrizes teste.",
                                "Calculou κ(A) e classificou condicionamento adequadamente.",
                                "Demonstrou sensibilidade via perturbação numérica.",
                                "Propôs pelo menos uma solução para ill-condicionamento.",
                                "Explicou ligação entre σ_min próximo de zero e problemas reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de SVD e σ_min (100% match com software).",
                                "Interpretação correta de κ e thresholds (sem erros qualitativos).",
                                "Profundidade de análise: inclui gap spectral e testes de ruído.",
                                "Clareza na documentação e exemplos práticos.",
                                "Criatividade em conexões com aplicações reais.",
                                "Eficiência: completou em tempo estimado com materiais mínimos."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Estudo de erros de arredondamento em métodos iterativos.",
                                "Machine Learning: Diagnóstico de multicolinearidade em PCA/SVD para features.",
                                "Engenharia: Estabilidade em simulações finitas (FEA) e controle de sistemas.",
                                "Física Computacional: Modelagem de sistemas instáveis como dinâmica molecular."
                              ],
                              "realWorldApplication": "Em image processing, SVD com σ_min pequeno indica ruído dominante; truncate para denoising. Em finanças, detecta portfólios sensíveis a choques de mercado via matriz de covariância ill-condicionada."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.3.2",
                            "name": "Avaliar rank numérico usando tolerâncias",
                            "description": "Definir rank(A) como o número de σ_i > tol * σ_max, aplicando para análise de sensibilidade em sistemas reais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Decomposição em Valores Singulares (SVD) e Valores Singulares",
                                  "subSteps": [
                                    "Relembre a decomposição SVD: A = U Σ V^T, onde Σ contém os valores singulares σ_i em ordem decrescente.",
                                    "Identifique σ_max como o maior valor singular (σ_1).",
                                    "Entenda que valores singulares menores indicam direções de pouca contribuição para o rank efetivo da matriz.",
                                    "Pratique extraindo Σ de uma matriz exemplo pequena (2x2 ou 3x3).",
                                    "Discuta o conceito de rank exato vs. rank numérico em contextos computacionais."
                                  ],
                                  "verification": "Construa SVD manualmente para uma matriz 2x2 e liste os σ_i corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, calculadora científica ou software como MATLAB/Octave para verificação.",
                                  "tips": "Sempre ordene σ_i decrescentemente para facilitar a identificação de σ_max.",
                                  "learningObjective": "Compreender a estrutura SVD e o papel dos valores singulares no rank da matriz.",
                                  "commonMistakes": "Confundir σ_i com autovalores; lembrar que SVD é para matrizes retangulares."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Escolher Tolerância para Rank Numérico",
                                  "subSteps": [
                                    "Aprenda a fórmula: rank(A) = #{i | σ_i > tol * σ_max}, onde tol é tipicamente 10^{-6} a 10^{-12}.",
                                    "Estude critérios para escolher tol: baseado em precisão da máquina (eps) ou ruído esperado nos dados.",
                                    "Experimente diferentes tol em uma matriz diagonal com σ_i decaindo.",
                                    "Compare rank numérico com rank simbólico para matrizes bem condicionadas.",
                                    "Registre como tol afeta o rank em casos de singularidade numérica."
                                  ],
                                  "verification": "Para uma matriz dada, compute rank para tol=1e-6 e tol=1e-10, justificando diferenças.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha Excel ou Python com NumPy para testes rápidos.",
                                  "tips": "Use tol relativo a σ_max para normalizar, evitando dependência de escala da matriz.",
                                  "learningObjective": "Dominar a definição formal de rank numérico usando tolerâncias relativas.",
                                  "commonMistakes": "Usar tol absoluto em vez de relativo; ignorar normalização por σ_max."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Cálculo de Rank Numérico Computacionalmente",
                                  "subSteps": [
                                    "Instale/carrege biblioteca: NumPy (Python) ou svd() no MATLAB.",
                                    "Escreva código: Compute SVD, extraia σ, encontre σ_max, conte σ_i > tol * σ_max.",
                                    "Teste com matrizes conhecidas: identidade (rank=n), nula (rank=0), rank-deficiente.",
                                    "Adicione plot de σ_i vs. i para visualizar o 'joelho' (elbow) onde σ_i cai abruptamente.",
                                    "Valide código com funções built-in como np.linalg.matrix_rank()."
                                  ],
                                  "verification": "Execute código em 3 matrizes diferentes e confirme ranks com método alternativo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/SciPy, Jupyter Notebook para visualizações.",
                                  "tips": "Use np.linalg.svd(compute_uv=False) para eficiência, só pegando singular values.",
                                  "learningObjective": "Implementar algoritmo prático para avaliação de rank numérico via SVD.",
                                  "commonMistakes": "Esquecer de ordenar σ_i; usar tol muito pequeno levando a rank superestimado."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Análise de Sensibilidade de Sistemas Reais",
                                  "subSteps": [
                                    "Carregue dados reais: matriz de rigidez em engenharia ou covariance em ML.",
                                    "Compute rank numérico e interprete: quantas direções independentes efetivas?",
                                    "Analise sensibilidade: perturbe A e veja como rank muda com tol.",
                                    "Relacione com condição numérica: cond(A) ≈ σ_max / σ_min efetivo.",
                                    "Documente relatório: rank, tol usado, implicações para o sistema."
                                  ],
                                  "verification": "Gere relatório com rank, plot de σ_i e discussão de sensibilidade para dataset real.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Dataset exemplo (ex: de scikit-learn ou MATLAB File Exchange), código do Step 3.",
                                  "tips": "Escolha datasets com ruído natural para demonstrar utilidade do rank numérico.",
                                  "learningObjective": "Aplicar rank numérico na interpretação de sensibilidade em cenários reais.",
                                  "commonMistakes": "Ignorar contexto do problema; superestimar rank em dados ruidosos sem tol adequado."
                                }
                              ],
                              "practicalExample": "Considere a matriz de covariance de um dataset de imagens 100x100 pixels comprimidas. Compute SVD: σ_max=1500, σ_10=14.5, σ_11=1e-5. Com tol=1e-6, rank=10 (apenas 10 componentes principais retêm >99.999% da variância), útil para redução dimensional em visão computacional.",
                              "finalVerifications": [
                                "Calcula corretamente rank numérico para matrizes de teste com diferentes tol.",
                                "Implementa código funcional que reproduz np.linalg.matrix_rank().",
                                "Interpreta plot de singular values identificando o elbow.",
                                "Aplica em dataset real e justifica escolha de tol.",
                                "Discute impacto na sensibilidade do sistema.",
                                "Compara rank numérico vs. exato em casos edge."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de SVD e contagem de σ_i acima do threshold (100%).",
                                "Justificativa fundamentada para escolha de tol (baseada em eps ou ruído).",
                                "Código limpo, comentado e eficiente (<5 linhas principais).",
                                "Análise qualitativa correta de sensibilidade.",
                                "Visualizações claras (plots de σ_i).",
                                "Relatório conciso relacionando ao contexto real."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia: Análise de estabilidade em estruturas (matrizes de rigidez).",
                                "Ciência de Dados: Redução de dimensionalidade em PCA/SVD.",
                                "Física: Modos normais em vibrações (rank de matrizes massa/rigidez).",
                                "Computação: Otimização numérica e condicionamento de problemas."
                              ],
                              "realWorldApplication": "Em sistemas de controle aeroespaciais, avaliar rank numérico da matriz de dinâmica revela graus de liberdade efetivos, detectando singularidades numéricas causadas por modelagem imprecisa, permitindo ajustes para estabilidade em voo real."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.2",
                "name": "Sensibilidade de Sistemas de Equações Lineares",
                "description": "Análise da estabilidade e sensibilidade numérica na resolução de sistemas lineares Ax=b.",
                "totalSkills": 46,
                "atomicTopics": [
                  {
                    "id": "10.1.2.1",
                    "name": "Número de Condição de Matrizes",
                    "description": "Medida quantitativa da sensibilidade de uma matriz à perturbações, calculada como a razão entre os maiores e menores valores singulares.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.1.1",
                        "name": "Decomposição em Valores Singulares (SVD)",
                        "description": "Representação fundamental de uma matriz retangular como produto de matrizes ortogonais e uma matriz diagonal contendo os valores singulares, essencial para análise numérica.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.1.1",
                            "name": "Definir a decomposição SVD",
                            "description": "Explicar a forma canônica A = U Σ V^T, onde U e V são ortogonais e Σ é diagonal com valores singulares não negativos em ordem decrescente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos de Matrizes Ortogonais",
                                  "subSteps": [
                                    "Defina matriz ortogonal: uma matriz U tal que U^T U = I e U U^T = I.",
                                    "Explique que colunas (ou linhas) de U são vetores ortonormais.",
                                    "Verifique a propriedade preservando normas: ||Ux|| = ||x|| para qualquer x.",
                                    "Discuta o papel em rotações e reflexões no espaço.",
                                    "Pratique multiplicando uma matriz ortogonal por seu transposto."
                                  ],
                                  "verification": "Construa uma matriz ortogonal 2x2 simples e confirme U U^T = I.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou software como MATLAB/Octave",
                                    "Folha de papel e lápis",
                                    "Capítulo sobre ortogonalidade em livro de Álgebra Linear"
                                  ],
                                  "tips": "Lembre-se: ortogonal implica invertível, com inversa sendo o transposto.",
                                  "learningObjective": "Dominar propriedades de matrizes ortogonais usadas em U e V da SVD.",
                                  "commonMistakes": "Confundir ortogonal com simétrica; ortogonais não são necessariamente simétricas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Valores Singulares",
                                  "subSteps": [
                                    "Defina valores singulares como raízes quadradas dos autovalores de A^T A (ou A A^T).",
                                    "Explique que são sempre reais e não negativos.",
                                    "Ordene-os em ordem decrescente: σ1 ≥ σ2 ≥ ... ≥ σr > 0.",
                                    "Relacione com a norma da matriz: maior valor singular é a norma espectral.",
                                    "Compute autovalores de A^T A para uma matriz exemplo 2x2."
                                  ],
                                  "verification": "Para A = [[1,1],[0,1]], calcule σ1 e σ2 corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de álgebra linear (NumPy/Python ou MATLAB)",
                                    "Notas sobre autovalores"
                                  ],
                                  "tips": "A^T A é sempre simétrica positiva semidefinida, facilitando autovalores reais.",
                                  "learningObjective": "Compreender a origem e ordenação dos valores singulares em Σ.",
                                  "commonMistakes": "Esquecer de ordenar decrescentemente ou assumir negativos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir a Forma Canônica da SVD",
                                  "subSteps": [
                                    "Escreva a decomposição: A = U Σ V^T, onde A é m x n.",
                                    "Descreva U (m x m ortogonal), Σ (m x n diagonal com singulares), V (n x n ortogonal).",
                                    "Explique dimensões: Σ tem singulares na diagonal principal, zeros fora.",
                                    "Verifique multiplicação: confirme que U Σ V^T recupera A.",
                                    "Discuta unicidade (até sinais em colunas de U e V)."
                                  ],
                                  "verification": "Escreva a definição completa e identifique componentes para uma matriz genérica.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Quadro branco ou papel para diagramas",
                                    "Exemplos de matrizes de diferentes tamanhos"
                                  ],
                                  "tips": "Visualize Σ como 'esticando' ao longo de eixos definidos por V e U.",
                                  "learningObjective": "Articular precisamente a forma SVD e papéis de cada matriz.",
                                  "commonMistakes": "Escrever A = U V Σ^T em vez de A = U Σ V^T."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Propriedades e Verificação",
                                  "subSteps": [
                                    "Liste propriedades: rank(A) = número de singulares não-nulos.",
                                    "Explique condição do número: κ(A) = σ1 / σ_min.",
                                    "Verifique ortogonalidade: U^T U = I, V^T V = I.",
                                    "Discuta truncada SVD para aproximação.",
                                    "Aplique a uma matriz numérica pequena para validar."
                                  ],
                                  "verification": "Para uma matriz dada, extraia U, Σ, V e multiplique para obter A.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python com NumPy (np.linalg.svd)",
                                    "Matriz exemplo impressa"
                                  ],
                                  "tips": "Use computação para verificar manualmente em casos pequenos.",
                                  "learningObjective": "Aplicar e validar a SVD com propriedades chave.",
                                  "commonMistakes": "Ignorar que Σ pode ser retangular para m ≠ n."
                                }
                              ],
                              "practicalExample": "Para A = [[3, 0], [0, 2]], a SVD é U = [[1, 0], [0, 1]], Σ = [[3, 0], [0, 2]], V = [[1, 0], [0, 1]]. Verifique: U Σ V^T = A. Os valores singulares são 3 e 2, decrescentes.",
                              "finalVerifications": [
                                "Escreva corretamente A = U Σ V^T com propriedades de U, V e Σ.",
                                "Identifique valores singulares como diagonais de Σ, não-negativos e ordenados.",
                                "Explique ortogonalidade de U e V.",
                                "Diferencie dimensões para A quadrada vs. retangular.",
                                "Valide com multiplicação em um exemplo 2x2."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal da SVD (100% match com canônica).",
                                "Correta descrição de propriedades (ortogonalidade, ordenação, não-negatividade).",
                                "Capacidade de identificar componentes em exemplos simples.",
                                "Explicação clara de dimensões e estrutura de Σ.",
                                "Ausência de erros comuns como inversão de ordem."
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Redução de dimensionalidade em Machine Learning (PCA via SVD).",
                                "Processamento de Imagens: Compressão em JPEG2000 usando SVD truncada.",
                                "Física: Análise de vibrações e decomposição modal.",
                                "Estatística: Análise de componentes principais."
                              ],
                              "realWorldApplication": "A SVD é fundamental em sistemas de recomendação (Netflix usa para fatorar matrizes usuário-item), compressão de dados (imagens e vídeos), resolução de equações lineares subdeterminadas e análise de big data para extração de features principais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.2",
                            "name": "Calcular valores singulares",
                            "description": "Demonstrar que os valores singulares σ_i são as raízes quadradas dos autovalores de A^T A ou A A^T, ordenados σ_1 ≥ σ_2 ≥ ... ≥ σ_r > 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Construir as matrizes simétricas AᵀA e AAᵀ",
                                  "subSteps": [
                                    "Dada uma matriz A de dimensões m×n, identifique se m ≥ n ou n ≥ m para escolher a matriz menor (AᵀA se m ≥ n, AAᵀ caso contrário).",
                                    "Calcule a transposta Aᵀ manualmente ou usando software.",
                                    "Multiplique Aᵀ por A (ou A por Aᵀ) elemento a elemento, verificando simetria (elemento [i,j] = [j,i]).",
                                    "Confirme as dimensões: AᵀA é n×n, AAᵀ é m×m.",
                                    "Armazene a matriz resultante para o próximo passo."
                                  ],
                                  "verification": "Verifique se a matriz resultante é simétrica comparando elementos off-diagonal e confirme dimensões corretas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou lápis",
                                    "Calculadora matricial",
                                    "Software como Python (NumPy) ou MATLAB"
                                  ],
                                  "tips": "Sempre compute a versão menor para eficiência computacional; use funções prontas como np.dot(A.T, A) em NumPy.",
                                  "learningObjective": "Compreender a construção de matrizes simétricas associadas a A para extração de valores singulares.",
                                  "commonMistakes": [
                                    "Esquecer de transpor corretamente A",
                                    "Erro em multiplicação matricial (confundir linhas/colunas)",
                                    "Não verificar simetria"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os autovalores da matriz simétrica escolhida",
                                  "subSteps": [
                                    "Formule a equação característica det(B - λI) = 0, onde B é AᵀA ou AAᵀ.",
                                    "Para matrizes pequenas (2×2 ou 3×3), resolva o polinômio manualmente.",
                                    "Use métodos numéricos (ex: decomposição QR) ou bibliotecas como np.linalg.eig para matrizes maiores.",
                                    "Identifique todos os autovalores reais e não-negativos (propriedade das matrizes simétricas positivas semi-definidas).",
                                    "Ordene os autovalores em ordem decrescente temporariamente: λ₁ ≥ λ₂ ≥ ... ≥ λₙ ≥ 0."
                                  ],
                                  "verification": "Confirme que todos autovalores são reais e não-negativos somando-os (deve igualar traço de B).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora gráfica ou simbólica (Wolfram Alpha)",
                                    "Python com NumPy/SciPy",
                                    "Folha de papel para polinômios"
                                  ],
                                  "tips": "Para 2×2, use fórmula quadrática; evite arredondamentos prematuros em cálculos numéricos.",
                                  "learningObjective": "Dominar o cálculo de autovalores de matrizes simétricas como base para valores singulares.",
                                  "commonMistakes": [
                                    "Resolver equação característica incorretamente",
                                    "Ignorar autovalores zero",
                                    "Não ordenar inicialmente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair os valores singulares σ_i como raízes quadradas dos autovalores",
                                  "subSteps": [
                                    "Para cada autovalor λ_i > 0, compute σ_i = √λ_i usando raiz quadrada precisa.",
                                    "Ignore autovalores zero (σ_r > 0 onde r é o rank).",
                                    "Registre σ₁ = √λ₁, σ₂ = √λ₂, ..., σ_r = √λ_r.",
                                    "Verifique numericamente se σ_i² ≈ λ_i para todos i (tolerância 10^{-6}).",
                                    "Ajuste para precisão se usando aproximações numéricas."
                                  ],
                                  "verification": "Multiplique cada σ_i² e confirme igualdade com λ_i correspondente dentro de tolerância numérica.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora com funções sqrt",
                                    "Python (np.sqrt)",
                                    "Tabela de verificação"
                                  ],
                                  "tips": "Use sqrt em software para evitar erros manuais; sempre verifique σ_i² = λ_i.",
                                  "learningObjective": "Relacionar diretamente autovalores com valores singulares via raiz quadrada.",
                                  "commonMistakes": [
                                    "Pegar raiz quadrada de autovalores zero",
                                    "Erro de sinal (raiz sempre positiva)",
                                    "Arredondamento excessivo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ordenar os valores singulares em ordem decrescente e validar",
                                  "subSteps": [
                                    "Ordene os σ_i: σ₁ ≥ σ₂ ≥ ... ≥ σ_r > 0.",
                                    "Conte o número r de valores positivos (rank efetivo).",
                                    "Compare com propriedades conhecidas de SVD (ex: σ₁ ≤ ||A||₂).",
                                    "Teste em software completo como np.linalg.svd(A) para validação.",
                                    "Documente o resultado final com ordenação explícita."
                                  ],
                                  "verification": "Confirme σ₁ ≥ σ₂ ≥ ... ≥ σ_r > 0 e compare com SVD direto da matriz original.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Software de álgebra linear (NumPy, MATLAB)",
                                    "Matriz A de exemplo"
                                  ],
                                  "tips": "Use sort descending em arrays; valide com norma da matriz.",
                                  "learningObjective": "Finalizar o processo de cálculo garantindo ordenação e completude.",
                                  "commonMistakes": [
                                    "Ordenação crescente em vez de decrescente",
                                    "Incluir zeros como singulares",
                                    "Não validar com SVD completo"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[1, 2], [3, 4]] (2×2):\n- AᵀA = [[10, 14], [14, 20]]\n- Autovalores λ ≈ 29.873, 0.127\n- σ₁ ≈ √29.873 ≈ 5.468, σ₂ ≈ √0.127 ≈ 0.356\n- Ordenados: σ₁ ≥ σ₂ > 0. Valide com np.linalg.svd(A, compute_uv=False).",
                              "finalVerifications": [
                                "σ_i² equals autovalores positivos de AᵀA ou AAᵀ.",
                                "Valores ordenados corretamente em decrescente.",
                                "Número de σ_i > 0 matches rank de A.",
                                "Norma espectral ||A||₂ = σ₁.",
                                "Validação numérica com SVD library coincide.",
                                "Sem autovalores negativos ou imaginários."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de transposta e multiplicação (erro < 10^{-4}).",
                                "Correta resolução da equação característica ou uso de eig.",
                                "Extração precisa de raízes quadradas sem erros de sinal.",
                                "Ordenação e contagem de rank corretas.",
                                "Validações numéricas e comparação com SVD padrão.",
                                "Clareza na documentação dos passos."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Base para Análise de Componentes Principais (PCA).",
                                "Computação: Implementação eficiente em bibliotecas como LAPACK.",
                                "Física: Modos normais e análise de vibrações em sistemas lineares.",
                                "Engenharia: Condicionamento em simulações numéricas e controle.",
                                "Ciência de Dados: Redução dimensional em machine learning."
                              ],
                              "realWorldApplication": "Em compressão de imagens, SVD usa valores singulares ordenados para aproximar A por UΣVᵀ de baixo rank, reduzindo armazenamento mantendo qualidade visual (ex: JPEG2000)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.3",
                            "name": "Interpretar os valores singulares extremos",
                            "description": "Identificar σ_max como a norma 2 da matriz (maior alongamento) e σ_min como o recíproco da norma 2 da inversa (menor alongamento).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Decomposição em Valores Singulares (SVD) e Definições Básicas",
                                  "subSteps": [
                                    "Realize a SVD de uma matriz A: A = U Σ V^T, onde Σ é diagonal com σ_1 ≥ σ_2 ≥ ... ≥ σ_r > 0.",
                                    "Identifique os valores singulares σ_i como as raízes quadradas dos autovalores de A^T A.",
                                    "Lembre que σ_max = σ_1 (maior valor singular) e σ_min = σ_r (menor valor singular não-zero).",
                                    "Discuta o significado geométrico: σ_i representam fatores de alongamento nas direções dos vetores singulares direitos.",
                                    "Verifique com uma matriz simples 2x2."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os componentes da SVD e liste os valores singulares corretamente para uma matriz de exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora ou software como MATLAB/Python (NumPy), notas de aula sobre SVD.",
                                  "tips": "Comece com matrizes simétricas positivas definidas para simplificar os autovalores.",
                                  "learningObjective": "Compreender a estrutura da SVD e o papel dos valores singulares como alongamentos.",
                                  "commonMistakes": "Confundir valores singulares com autovalores da matriz original; lembrar que SVD é para qualquer matriz."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Conectar σ_max à Norma 2 da Matriz A",
                                  "subSteps": [
                                    "Defina a norma 2 de A: ||A||_2 = sup_{||x||=1} ||Ax||_2 = máximo alongamento de vetores unitários.",
                                    "Prove ou aceite que ||A||_2 = σ_max, o maior valor singular.",
                                    "Calcule ||A||_2 via SVD: máximo diagonal de Σ.",
                                    "Aplique a uma matriz de exemplo: encontre σ_max e verifique ||Ax|| para vetor singular direito correspondente.",
                                    "Visualize geometricamente: σ_max é o maior estiramento."
                                  ],
                                  "verification": "Calcule σ_max via SVD e confirme que ||A||_2 = σ_max com precisão numérica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software de álgebra linear (MATLAB svd(), Python numpy.linalg.svd()), papel e lápis para esboços.",
                                  "tips": "Use vetores unitários na direção do primeiro vetor coluna de V para maximizar ||Ax||.",
                                  "learningObjective": "Associar σ_max diretamente à norma 2 como o maior fator de alongamento.",
                                  "commonMistakes": "Usar norma Frobenius em vez de norma 2; norma 2 é o maior valor singular, não a raiz da soma."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Conectar σ_min ao Recíproco da Norma 2 da Inversa A^{-1}",
                                  "subSteps": [
                                    "Assuma A invertível; defina ||A^{-1}||_2 = sup_{||y||=1} ||A^{-1} y||_2.",
                                    "Mostre que ||A^{-1}||_2 = 1 / σ_min via propriedades da SVD.",
                                    "Derive: o menor alongamento de A corresponde ao maior de A^{-1}.",
                                    "Calcule para exemplo: encontre A^{-1}, sua SVD e confirme 1/σ_min = ||A^{-1}||_2.",
                                    "Interprete: σ_min mede a 'robustez' contra perturbações pequenas."
                                  ],
                                  "verification": "Compute σ_min e ||A^{-1}||_2; verifique igualdade numérica de 1/σ_min.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Mesmo software do passo anterior, matrizes invertíveis de teste (ex: A = [[2,1],[1,1]]).",
                                  "tips": "Escolha matrizes com σ_min claramente pequeno para cond. number alto.",
                                  "learningObjective": "Entender σ_min como 1 / ||A^{-1}||_2, ligando ao menor alongamento.",
                                  "commonMistakes": "Esquecer que para não-invertíveis σ_min=0 implica A^{-1} não existe; focar só em invertíveis."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Geometricamente os Valores Singulares Extremos",
                                  "subSteps": [
                                    "Desenhe elipse unitária transformada por A: semi-eixos σ_max e σ_min.",
                                    "Explique: σ_max alonga mais na direção v_1, σ_min menos em v_r.",
                                    "Conecte ao número de condição κ_2(A) = σ_max / σ_min ≈ ||A||_2 ||A^{-1}||_2.",
                                    "Aplique a exemplo visual: plote antes/depois da transformação.",
                                    "Discuta implicações: alto κ indica ill-conditioned, sensível a erros."
                                  ],
                                  "verification": "Crie diagrama ou simulação mostrando alongamentos extremos e explique interpretação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramenta de plotagem (Matplotlib, GeoGebra), exemplos matriciais.",
                                  "tips": "Use matriz de rotação + escala para visual claro: [[2,0],[0,0.5]].",
                                  "learningObjective": "Visualizar e interpretar σ_max e σ_min como alongamentos extremos.",
                                  "commonMistakes": "Ignorar direções (vetores singulares); alongamento é direcional, não isótropo."
                                }
                              ],
                              "practicalExample": "Para A = [[3, 0], [0, 1]], SVD dá Σ = diag(3,1), σ_max=3 (alonga eixo x por 3), σ_min=1. ||A||_2=3, A^{-1}=[[1/3,0],[0,1]], ||A^{-1}||_2=3=1/σ_min? Espera, σ_min=1, 1/1=1 mas ||A^{-1}||=1/σ_min correto? Erro: para esta A diagonal, ||A^{-1}||_2 = max(1/3,1)=1, mas σ_min=1? Não: σ_max=3, σ_min=1, 1/σ_min=1, sim ||A^{-1}||_2=1. Melhor: A=[[2,1],[1,1]], SVD σ_max≈2.618, σ_min≈0.382, κ≈6.828, ||A||_2≈2.618, ||A^{-1}||_2≈2.618.",
                              "finalVerifications": [
                                "Calcule corretamente σ_max e σ_min via SVD para matriz dada.",
                                "Confirme σ_max = ||A||_2 com vetor unitário maximizando ||Ax||.",
                                "Verifique 1/σ_min = ||A^{-1}||_2 numericamente.",
                                "Descreva geometricamente os alongamentos extremos.",
                                "Calcule número de condição κ_2 = σ_max/σ_min e interprete.",
                                "Identifique direções associadas (primeiro/último vetores singulares)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de SVD e normas (erro < 1e-10).",
                                "Explicação clara da relação σ_max = ||A||_2 e σ_min = 1/||A^{-1}||_2.",
                                "Interpretação geométrica correta com visualização.",
                                "Uso apropriado de exemplos e verificações numéricas.",
                                "Compreensão do impacto no condicionamento da matriz.",
                                "Identificação de erros comuns evitados nas respostas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Deformações em tensores de tensão/strain (alongamentos principais).",
                                "Ciência da Computação: Compressão de imagens via SVD (manter σ_max, truncar pequenos).",
                                "Engenharia: Análise de estabilidade estrutural (modos de falha por σ_min baixo).",
                                "Estatística: Análise de componentes principais (PCA via SVD)."
                              ],
                              "realWorldApplication": "Em análise numérica, interpretar σ_max e σ_min ajuda a avaliar sensibilidade de sistemas lineares a erros de arredondamento; em processamento de imagens, σ_max captura features principais para redução dimensional eficiente sem perda crítica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.2",
                        "name": "Definição do Número de Condição",
                        "description": "Quantidade adimensional que mede quanto pequenas perturbações na matriz ou no vetor direito se amplificam na solução de sistemas lineares.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.2.1",
                            "name": "Definir cond_2(A) via SVD",
                            "description": "Estabelecer que o número de condição na norma 2 é cond_2(A) = σ_max / σ_min para matrizes invertíveis, com cond_2(A) = ∞ se singular.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Decomposição em Valores Singulares (SVD)",
                                  "subSteps": [
                                    "Recordar que toda matriz A ∈ ℝ^{m×n} admite SVD: A = U Σ V^T, onde U e V são ortogonais, Σ é diagonal com entradas σ₁ ≥ σ₂ ≥ ... ≥ σ_r ≥ 0.",
                                    "Identificar os valores singulares σ_i como as raízes quadradas dos autovalores da matriz A A^T ou A^T A.",
                                    "Entender σ_max = σ₁ (maior valor singular) e σ_min = σ_min{r} (menor valor singular não-nulo, ou 0 se singular).",
                                    "Visualizar SVD geometricamente: rotações (U, V), escalas (Σ).",
                                    "Praticar decompondo uma matriz 2×2 simples manualmente."
                                  ],
                                  "verification": "Explicar os componentes de SVD e computar σ_max e σ_min para uma matriz exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Gilbert Strang)",
                                    "Calculadora ou software como MATLAB/Octave",
                                    "Papel e lápis para exemplos manuais"
                                  ],
                                  "tips": "Lembre-se: SVD generaliza autovalores para matrizes não-quadradas; foque nos valores singulares como 'tamanhos' das direções principais.",
                                  "learningObjective": "Compreender a estrutura e propriedades fundamentais da SVD.",
                                  "commonMistakes": [
                                    "Confundir valores singulares com autovalores",
                                    "Esquecer que σ_i são sempre não-negativos e ordenados decrescentemente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Relacionar a norma 2 com valores singulares",
                                  "subSteps": [
                                    "Definir norma 2 induzida: ||A||₂ = sup_{||x||₂=1} ||Ax||₂.",
                                    "Provar que ||A||₂ = σ_max(A), pois o máximo é alcançado no vetor singular direito correspondente.",
                                    "Verificar para A ortogonal: ||A||₂ = 1, σ_max = 1.",
                                    "Discutir norma 2 de vetores: ||x||₂ = √(x^T x).",
                                    "Computar ||A||₂ via SVD para uma matriz diagonal."
                                  ],
                                  "verification": "Calcular ||A||₂ usando definição e confirmar via σ_max para matriz 2×2.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software numérico (Python NumPy ou MATLAB)",
                                    "Exemplos de matrizes impressas"
                                  ],
                                  "tips": "Use o fato de que para x unitário alinhado com primeira coluna de V, ||Ax||₂ = σ₁.",
                                  "learningObjective": "Estabelecer ||A||₂ = σ_max via propriedades da SVD.",
                                  "commonMistakes": [
                                    "Confundir norma 2 com norma Frobenius (√(tr(A^T A)))",
                                    "Ignorar que norma induzida depende da direção de x"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a norma 2 da matriz inversa via SVD",
                                  "subSteps": [
                                    "Para A invertível (quadrada), derivar SVD de A^{-1}: A^{-1} = V Σ^{-1} U^T.",
                                    "Concluir ||A^{-1}||₂ = max 1/σ_i = 1/σ_min(A), pois Σ^{-1} tem 1/σ_min como maior entrada.",
                                    "Verificar que se σ_min → 0, ||A^{-1}||₂ → ∞.",
                                    "Discutir implicações: A 'fina' (σ_min pequeno) tem inverso 'gordo'.",
                                    "Computar exemplo: para A diagonal, inverso é direto."
                                  ],
                                  "verification": "Derivar e computar ||A^{-1}||₂ via SVD para matriz não-diagonal.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notebook Jupyter com NumPy/SciPy para svd()",
                                    "Matrizes de teste pré-definidas"
                                  ],
                                  "tips": "Inverta Σ diagonalmente: diagonais viram 1/σ_i; preserve ortogonalidade.",
                                  "learningObjective": "Compreender ||A^{-1}||₂ = 1/σ_min para matrizes invertíveis.",
                                  "commonMistakes": [
                                    "Esquecer de inverter apenas Σ e trocar U/V adequadamente",
                                    "Aplicar SVD diretamente ao inverso sem usar estrutura"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir o número de condição cond₂(A) via SVD",
                                  "subSteps": [
                                    "Recordar definição geral: cond₂(A) = ||A||₂ ||A^{-1}||₂ para A invertível.",
                                    "Substituir: cond₂(A) = σ_max / σ_min.",
                                    "Estender para singular: se rank(A) < n, σ_min = 0, cond₂(A) = ∞.",
                                    "Interpretar: cond₂ mede 'quão oblato' é A (razão de alongamentos).",
                                    "Verificar com exemplo: identidade tem cond=1; diagonal com entradas 1 e ε tem cond=1/ε."
                                  ],
                                  "verification": "Enunciar definição, provar via SVD e aplicar a matriz exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Resumo de fórmulas anotado",
                                    "Software para svdvals()"
                                  ],
                                  "tips": "cond₂ ≥ 1 sempre (propriedade de normas); =1 iff A é escalar múltiplo de ortogonal.",
                                  "learningObjective": "Formalizar cond₂(A) = σ_max/σ_min e casos especiais.",
                                  "commonMistakes": [
                                    "Definir cond como σ_max - σ_min em vez de razão",
                                    "Esquecer ∞ para singulares"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[3, 1], [1, 3]]. SVD: σ_max ≈ 3.162, σ_min ≈ 2.838, cond₂(A) ≈ 1.116. Perturbe A por ε na (1,1): nova cond₂ cresce pouco (bem condicionado). Para B = [[1, 0], [0, 0.01]], σ_max=1, σ_min=0.01, cond₂=100 (mal condicionado; pequenas mudanças amplificam erros).",
                              "finalVerifications": [
                                "Enunciar cond₂(A) = σ_max/σ_min para invertível e ∞ para singular.",
                                "Derivar ||A||₂ = σ_max e ||A^{-1}||₂ = 1/σ_min usando SVD.",
                                "Calcular cond₂ para matriz 2×2 dada via SVD numérico.",
                                "Explicar por que cond₂ mede sensibilidade.",
                                "Identificar quando cond₂=1.",
                                "Discutir limite σ_min→0."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação cond₂ = σ_max/σ_min via normas e SVD.",
                                "Correta manipulação de SVD para A^{-1}.",
                                "Tratamento adequado de casos singulares (∞).",
                                "Interpretação física/geométrica do número de condição.",
                                "Cálculos numéricos exatos ou com erro <1%.",
                                "Uso correto de terminologia (norma induzida, valores singulares)."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Estabilidade em solvers de sistemas lineares (ex: GMRES).",
                                "Machine Learning: SVD em PCA para redução dimensional e regularização.",
                                "Engenharia de Controle: Análise de sensibilidade em modelos lineares.",
                                "Processamento de Sinais: Compressão de imagens via truncada SVD.",
                                "Física Computacional: Simulações de dinâmica molecular com matrizes de Hessiana."
                              ],
                              "realWorldApplication": "Em computação científica, cond₂(A) prevê amplificação de erros em soluções de Ax=b; alto cond₂ indica necessidade de preconditioning ou métodos robustos, essencial em simulações climáticas, finanças (modelos de risco) e visão computacional (reconstrução 3D)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.2.2",
                            "name": "Relacionar com normas de matriz",
                            "description": "Provar que cond_p(A) = ||A||_p ||A^{-1}||_p para qualquer norma de matriz consistente, com foco na norma 2.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições de normas vetoriais e normas de matriz induzidas consistentes",
                                  "subSteps": [
                                    "Estudar a definição de norma vetorial ||x||_p para p=1,2,∞.",
                                    "Entender norma de matriz induzida ||A||_p = sup_{x≠0} ||Ax||_p / ||x||_p.",
                                    "Verificar propriedades de normas consistentes: submultiplicatividade ||AB|| ≤ ||A|| ||B|| e compatibilidade com norma vetorial.",
                                    "Explorar especificamente a norma 2: ||A||_2 = maior valor singular de A (raiz quadrada do maior autovalor de A^* A).",
                                    "Calcular exemplos simples de ||A||_p para matrizes 2x2."
                                  ],
                                  "verification": "Resumir em um parágrafo as propriedades chave e calcular ||A||_2 para uma matriz diagonal.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Livro de Álgebra Linear (ex: Strang), calculadora ou Python/NumPy para normas.",
                                  "tips": "Sempre normalize ||x||=1 para simplificar cálculos de supremo.",
                                  "learningObjective": "Compreender como normas de matriz são definidas a partir de normas vetoriais e suas propriedades essenciais.",
                                  "commonMistakes": "Confundir norma induzida com norma de Frobenius; esquecer submultiplicatividade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o número de condição usando ganhos máximo e mínimo",
                                  "subSteps": [
                                    "Definir o ganho máximo: ||A||_p = max_{||x||_p=1} ||Ax||_p.",
                                    "Definir o ganho mínimo: m_p(A) = min_{||x||_p=1} ||Ax||_p.",
                                    "Introduzir cond_p(A) = ||A||_p / m_p(A), a razão entre ganhos extremos.",
                                    "Mostrar para norma 2: ||A||_2 / m_2(A) = σ_max / σ_min, onde σ são valores singulares.",
                                    "Discutir por que isso mede sensibilidade a perturbações."
                                  ],
                                  "verification": "Escrever as definições formalmente e relacionar com valores singulares para norma 2.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Notas de aula, software SVD (MATLAB svd() ou numpy.linalg.svd).",
                                  "tips": "Visualize com elipses: A transforma esfera unitária em elipse com eixos σ_max e σ_min.",
                                  "learningObjective": "Dominar a interpretação geométrica e analítica do número de condição via ganhos.",
                                  "commonMistakes": "Invertir max e min; assumir cond=1 para matrizes bem condicionadas sem cálculo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar que o ganho mínimo m_p(A) = 1 / ||A^{-1}||_p",
                                  "subSteps": [
                                    "Assumir A invertível; considerar y = Ax com ||x||_p=1, então x = A^{-1} y.",
                                    "Mostrar m_p(A) = inf_{||x||=1} ||Ax||_p = inf_{||y||=||Ax||=1?} 1 / ||A^{-1} y||_p wait.",
                                    "Formal: m(A) ≥ 1/||A^{-1}|| porque ||Ax|| ≥ 1/||A^{-1}|| para ||x||=1 (pois ||x|| = ||A^{-1} Ax|| ≤ ||A^{-1}|| ||Ax||).",
                                    "Igualdade: tome x_0 maximizando ||A^{-1}||, i.e., ||A^{-1} z|| max com ||z||=1, set y=A x_0 = z ||A x_0||, normalizar.",
                                    "Verificar para norma 2: σ_min(A) = 1 / σ_max(A^{-1}) = 1 / ||A^{-1}||_2."
                                  ],
                                  "verification": "Derivar a desigualdade e igualdade em prova escrita, testando com matriz 2x2.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Papel e lápis para prova, SymPy ou MATLAB para verificação numérica.",
                                  "tips": "Use a submultiplicatividade: ||x|| = ||A^{-1} (A x)|| ≤ ||A^{-1}|| ||A x||.",
                                  "learningObjective": "Provar a relação chave entre ganho mínimo e norma do inverso.",
                                  "commonMistakes": "Esquecer normalização ||x||=1; confundir inf com sup na derivação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir a prova: cond_p(A) = ||A||_p ||A^{-1}||_p e foco na norma 2",
                                  "subSteps": [
                                    "Combinar: cond_p(A) = ||A||_p / m_p(A) = ||A||_p * ||A^{-1}||_p.",
                                    "Verificar consistência para qualquer p com norma induzida (consistente por construção).",
                                    "Aplicar à norma 2: cond_2(A) = σ_max(A) / σ_min(A) = ||A||_2 ||A^{-1}||_2.",
                                    "Discutir generalização para normas consistentes arbitrárias (não só induzidas).",
                                    "Exemplo numérico: matriz de Hilbert 2x2, calcular todos os termos."
                                  ],
                                  "verification": "Escrever prova completa e computar cond_2 para matriz exemplo, confirmando igualdade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Python/NumPy para cond, norm; tabela de propriedades de normas.",
                                  "tips": "Sempre confira numericamente: np.linalg.cond(A, p=2) == np.linalg.norm(A,2) * np.linalg.norm(np.linalg.inv(A),2).",
                                  "learningObjective": "Finalizar a prova e internalizar a fórmula fundamental do número de condição.",
                                  "commonMistakes": "Ignorar que igualdade requer norma consistente; erro em cálculo de inversa."
                                }
                              ],
                              "practicalExample": "Considere A = [[2,1],[1,1]] (matriz 2x2). Calcule ||A||_2 ≈ 2.414 (σ_max), A^{-1} = [[1,-1],[-1,2]], ||A^{-1}||_2 ≈ 1.618 (φ, razão áurea), cond_2(A) ≈ 3.909. Verifique: 2.414 * 1.618 ≈ 3.909. Use SVD para confirmar σ_max/σ_min.",
                              "finalVerifications": [
                                "Enunciar corretamente cond_p(A) = ||A||_p ||A^{-1}||_p para norma consistente.",
                                "Provar m_p(A) = 1/||A^{-1}||_p com desigualdade e igualdade.",
                                "Calcular cond_2 para matriz exemplo com precisão <1%.",
                                "Explicar relação com valores singulares na norma 2.",
                                "Identificar quando norma é consistente (submultiplicativa).",
                                "Discutir implicações para A mal condicionada (cond>>1)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da prova: desigualdades e igualdades corretas (40%).",
                                "Compreensão conceitual: ligação max/min com normas (25%).",
                                "Exemplos numéricos: cálculos exatos para norma 2 (20%).",
                                "Clareza na escrita: passos lógicos e notação consistente (10%).",
                                "Extensão à norma 2: uso de SVD/valores singulares (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Análise numérica em solvers de sistemas lineares (bibliotecas LAPACK).",
                                "Física: Estabilidade em modelagem diferencial (matrizes de rigidez).",
                                "Engenharia: Condicionamento em otimização e controle (norma 2 comum).",
                                "Estatística: Regressão linear e multicolinearidade (cond alta)."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, avalia-se cond_2 de matrizes de massa/inércia para simulações FEM; cond alto indica instabilidade numérica, levando a erros em predições de vibrações ou falhas estruturais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.2.3",
                            "name": "Calcular o número de condição",
                            "description": "Aplicar algoritmos numéricos ou SVD para computar cond(A) em exemplos 2x2 e 3x3, usando software como MATLAB ou Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definição e fórmulas do número de condição",
                                  "subSteps": [
                                    "Estude a definição: cond(A) = ||A|| * ||A^{-1}|| para norma 2 ou infinito.",
                                    "Aprenda a fórmula via SVD: cond_2(A) = σ_max / σ_min, onde σ são valores singulares.",
                                    "Recorde pré-requisitos: inversa de matriz, normas matriciais (especialmente norma 2).",
                                    "Identifique quando usar cada método: norma para 2x2 simples, SVD para maiores.",
                                    "Anote diferenças entre normas (2, Frobenius, infinito)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as duas fórmulas principais e dê um exemplo conceitual.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre normas e SVD",
                                    "Calculadora ou papel para anotações"
                                  ],
                                  "tips": "Comece com norma 2, pois é comum em álgebra numérica. Use diagramas para visualizar SVD.",
                                  "learningObjective": "Compreender conceitualmente o número de condição e suas representações equivalentes.",
                                  "commonMistakes": [
                                    "Confundir cond(A) com det(A)",
                                    "Esquecer que cond(I) = 1",
                                    "Ignorar que cond depende da norma"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular cond(A) manualmente via norma e inversa para matriz 2x2",
                                  "subSteps": [
                                    "Escolha matriz A 2x2, ex: A = [[2,1],[1,1]].",
                                    "Calcule A^{-1} usando fórmula adjunta/determinante.",
                                    "Compute ||A||_2 (maior valor singular ou sqrt(maior autovalor de A^T A)).",
                                    "Compute ||A^{-1}||_2 similarmente.",
                                    "Multiplique: cond(A) = ||A||_2 * ||A^{-1}||_2 e verifique com det(A)."
                                  ],
                                  "verification": "Mostre cálculos passo a passo com resultado numérico correto (ex: cond(A) ≈ 3.414 para exemplo).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de fórmulas de normas",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Para norma 2 em 2x2, use |λ_max| de A^T A. Verifique com software simples depois.",
                                  "learningObjective": "Executar cálculo analítico completo para matriz pequena.",
                                  "commonMistakes": [
                                    "Erro na inversa (dividir por det errado)",
                                    "Usar norma errada (ex: norma 1 em vez de 2)",
                                    "Arredondamento prematuro"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular cond(A) usando decomposição SVD para matrizes 2x2 e 3x3",
                                  "subSteps": [
                                    "Para 2x2: Compute SVD manualmente (A = U Σ V^T), encontre σ1 > σ2.",
                                    "Calcule cond_2(A) = σ1 / σ2.",
                                    "Para 3x3: Use propriedades (ex: A = [[1,0,0],[0,2,0],[0,0,0.1]]), liste singulares teoricamente.",
                                    "Compare cond via norma vs SVD para validar.",
                                    "Registre sensibilidade: pequenas mudanças em σ_min amplificam cond."
                                  ],
                                  "verification": "Forneça SVD de uma matriz 2x2 e cond correto; esboce para 3x3.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Folha com exemplo de SVD 2x2",
                                    "Software de cálculo simbólico opcional (SymPy)"
                                  ],
                                  "tips": "SVD revela ill-condicionamento diretamente. Foque em σ_min próximo de zero.",
                                  "learningObjective": "Aplicar SVD para estimar cond eficientemente.",
                                  "commonMistakes": [
                                    "Confundir autovalores com singulares",
                                    "Inverter ordem de σ_max/σ_min",
                                    "Esquecer normalização em U/V"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar cálculo de cond(A) em Python ou MATLAB",
                                  "subSteps": [
                                    "Instale NumPy/SciPy (Python) ou toolbox básica (MATLAB).",
                                    "Escreva código: np.linalg.cond(A, p=2) ou svdvals.",
                                    "Teste em matrizes 2x2 e 3x3 do passo anterior.",
                                    "Compare resultados numéricos com manuais e analise precisão.",
                                    "Gere gráfico de cond vs perturbação em A."
                                  ],
                                  "verification": "Execute código e mostre output matching cálculos manuais (erro < 1e-10).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy ou MATLAB",
                                    "Editor de código (Jupyter/VSCode)"
                                  ],
                                  "tips": "Use cond(A, '2') para norma 2. Sempre verifique com svd para confirmação.",
                                  "learningObjective": "Automatizar e validar cálculos numéricos com software.",
                                  "commonMistakes": [
                                    "Não importar bibliotecas",
                                    "Usar p='fro' em vez de 2",
                                    "Matriz singular (divisão por zero)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[1, 1], [1, 1.0001]] (2x2 ill-condicionada), calcule cond_2(A) ≈ 10000 via SVD (σ1≈1.414, σ_min≈0.0001414). Em Python: import numpy as np; A=np.array([[1,1],[1,1.0001]]); print(np.linalg.cond(A,2)). Resultado confirma alta sensibilidade.",
                              "finalVerifications": [
                                "Calculou cond corretamente para pelo menos duas matrizes 2x2 (manual e software).",
                                "Executou SVD para 3x3 e identificou σ_max/σ_min.",
                                "Comparou resultados de diferentes métodos com erro <1%.",
                                "Explicou por que cond alto indica instabilidade.",
                                "Implementou código funcional e testado."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos (erro <0.1%).",
                                "Correta aplicação de fórmulas (norma vs SVD).",
                                "Clareza nos passos e substeps documentados.",
                                "Validação cruzada entre métodos manuais e computacionais.",
                                "Identificação de ill-condicionamento e implicações.",
                                "Eficiência no uso de software (código limpo e comentado)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de bibliotecas NumPy/SciPy para computação científica.",
                                "Física: Análise de estabilidade em sistemas dinâmicos (ex: matrizes de rigidez).",
                                "Engenharia: Avaliação de erros em simulações numéricas.",
                                "Estatística: Sensibilidade em regressão linear multivariada."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, calcular cond de matrizes de massa/inércia para prever erros de arredondamento em simulações CFD; alto cond alerta para refinar malha ou modelo, evitando falhas como em análises de estabilidade de pontes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.3",
                        "name": "Sensibilidade de Sistemas Lineares",
                        "description": "Aplicação do número de condição para quantificar a propagação de erros relativos em soluções de Ax = b sob perturbações em A e b.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.3.1",
                            "name": "Analisar amplificação de erros em b",
                            "description": "Derivar a estimativa |δx|/|x| ≤ cond(A) |δb|/|b|, mostrando que o erro relativo na solução é amplificado pelo fator cond(A).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o sistema original e a perturbação em b",
                                  "subSteps": [
                                    "Recordar que o sistema original é Ax = b, onde A é invertível.",
                                    "Introduzir a perturbação: suponha b perturbado para b + δb, com ||δb|| pequeno.",
                                    "Definir a solução perturbada como x + δx, onde δx é o erro na solução.",
                                    "Escrever a equação do sistema perturbado: A(x + δx) = b + δb.",
                                    "Simplificar para obter a relação fundamental envolvendo δx."
                                  ],
                                  "verification": "Verificar se a equação A δx = δb foi derivada corretamente a partir da perturbação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora para normas",
                                    "Software como MATLAB ou Python (NumPy) para exemplos numéricos opcionais"
                                  ],
                                  "tips": "Sempre use normas consistentes (ex: norma 2 ou infinito) para matrizes e vetores.",
                                  "learningObjective": "Compreender como perturbações em b afetam o sistema linear.",
                                  "commonMistakes": "Esquecer de expandir A(x + δx) corretamente ou confundir δx com δb."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o bound para o erro absoluto δx usando normas",
                                  "subSteps": [
                                    "Da equação A δx = δb, multiplicar ambos os lados pela norma da inversa: ||δx|| ≤ ||A^{-1}|| ||δb||.",
                                    "Explicar por que isso vale: propriedade submultiplicativa das normas de matrizes.",
                                    "Calcular ||A^{-1}|| se possível, ou discutir seu significado.",
                                    "Verificar com um exemplo pequeno: escolha A 2x2, compute A^{-1} e teste.",
                                    "Discutir a dependência do bound na norma escolhida."
                                  ],
                                  "verification": "Resolver ||A δx|| = ||δb|| e confirmar ||δx|| ≤ ||A^{-1}|| ||δb|| com cálculo manual.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Matriz exemplo impressa ou no software",
                                    "Tabela de normas matriciais"
                                  ],
                                  "tips": "Lembre-se: ||AB|| ≤ ||A|| ||B|| para qualquer norma induzida.",
                                  "learningObjective": "Aplicar normas para obter bounds em erros absolutos.",
                                  "commonMistakes": "Confundir norma de vetor com norma de matriz ou ignorar a submultiplicatividade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar o erro absoluto com erros relativos e introduzir cond(A)",
                                  "subSteps": [
                                    "Do sistema original Ax = b, obter ||b|| ≤ ||A|| ||x||, logo ||x|| ≥ ||b|| / ||A||.",
                                    "Substituir no erro relativo: ||δx|| / ||x|| ≤ [||A^{-1}|| ||δb||] / (||b|| / ||A||) = ||A|| ||A^{-1}|| (||δb|| / ||b||).",
                                    "Definir cond(A) = ||A|| ||A^{-1}|| como o número de condição.",
                                    "Reescrever a estimativa final: ||δx|| / ||x|| ≤ cond(A) ||δb|| / ||b||.",
                                    "Interpretar: cond(A) amplifica o erro relativo em b para o de x."
                                  ],
                                  "verification": "Derivar passo a passo a inequação final e confirmar com substituição algébrica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis para derivação",
                                    "Software para calcular cond(A) de uma matriz exemplo"
                                  ],
                                  "tips": "Use desigualdades em vez de igualdades para bounds conservadores.",
                                  "learningObjective": "Construir a estimativa de erro relativo usando cond(A).",
                                  "commonMistakes": "Erro na manipulação de ||x|| ≥ ||b|| / ||A|| ou inverter cond(A)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar a amplificação e testar com exemplo numérico",
                                  "subSteps": [
                                    "Escolher matriz A com cond(A) alto (ex: ill-conditioned) e baixo.",
                                    "Computar x exato, perturbar b com δb pequeno, resolver novo sistema.",
                                    "Medir ||δx||/||x|| e ||δb||/||b||, verificar se amplificação ≈ cond(A).",
                                    "Discutir quando cond(A) >> 1 causa problemas numéricos.",
                                    "Generalizar para diferentes normas e contextos computacionais."
                                  ],
                                  "verification": "Em um exemplo, confirmar numericamente que o bound é satisfeito e amplificação observada.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software NumPy/Python ou MATLAB",
                                    "Matrizes de teste pré-definidas"
                                  ],
                                  "tips": "Use cond(A, infonorm) no MATLAB para checar; evite A singular.",
                                  "learningObjective": "Validar teoricamente e numericamente a amplificação de erros.",
                                  "commonMistakes": "Escolher δb muito grande ou A com cond(A)=1, mascarando o efeito."
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 1], [1, 1+ε]] com ε=10^{-6} (cond(A)≈10^6). b=[1,1]^T, x≈[0.5, 0.5]^T. Perturbe b com δb=10^{-8}[1,0]^T. Resolva novo sistema: erro relativo em x será ~10^{-2}, amplificado por cond(A).",
                              "finalVerifications": [
                                "Deriva corretamente A δx = δb do sistema perturbado.",
                                "Obtém ||δx|| ≤ ||A^{-1}|| ||δb|| usando normas.",
                                "Constrói ||δx||/||x|| ≤ cond(A) ||δb||/||b|| com passos algébricos precisos.",
                                "Explica o papel amplificador de cond(A) >1.",
                                "Valida com exemplo numérico onde amplificação é observada.",
                                "Discute limitações do bound (ex: worst-case)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação algébrica (sem erros em desigualdades).",
                                "Correta manipulação de normas e definição de cond(A).",
                                "Interpretação qualitativa da amplificação.",
                                "Exemplo numérico com cálculos verificáveis.",
                                "Clareza na explicação de implicações numéricas.",
                                "Identificação de casos onde bound é sharp."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em solvers lineares (ex: lu_factor no SciPy).",
                                "Engenharia Computacional: Análise de estabilidade em simulações FEM.",
                                "Física Computacional: Erros em modelos de equações diferenciais discretizadas.",
                                "Estatística: Sensibilidade em regressão linear mínima quadrados."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, perturbações em medições (δb) de sensores podem ser amplificadas por cond(A) alto em modelos estruturais, levando a designs inseguros se não analisado; usado para validar precisão de solvers em CFD."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.3.2",
                            "name": "Analisar sensibilidade a perturbações em A",
                            "description": "Explicar a bound |δx|/|x| ≤ cond(A) |δA|/|A| / (1 - cond(A) |δA|/|A|), destacando instabilidade para cond(A) grande.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o conceito de número de condição cond(A)",
                                  "subSteps": [
                                    "Defina cond(A) = ||A|| * ||A^{-1}|| para norma matricial compatível.",
                                    "Explique que cond(A) mede a sensibilidade da solução x a perturbações em b.",
                                    "Discuta que cond(A) ≥ 1 e valores grandes indicam ill-condição.",
                                    "Calcule cond(A) para matrizes simples como identidade e diagonal.",
                                    "Compare cond(A) para matrizes bem e mal condicionadas."
                                  ],
                                  "verification": "Calcule cond(A) para uma matriz 2x2 dada e interprete o resultado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora matricial, software como MATLAB/Octave ou Python (NumPy), notas de aula sobre normas.",
                                  "tips": "Use norma 2 ou infinito para simplicidade em cálculos manuais.",
                                  "learningObjective": "Compreender o papel do número de condição na amplificação de erros.",
                                  "commonMistakes": "Confundir cond(A) com det(A) ou ignorar que cond(A) é sempre ≥1."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a bound para perturbações em A",
                                  "subSteps": [
                                    "Comece com Ax = b, perturbado: (A + δA)(x + δx) = b.",
                                    "Negligencie termo de segunda ordem δA δx, aproximando A δx + δA x ≈ 0.",
                                    "Tome normas: ||δx|| ≤ cond(A) ||δA|| / ||A|| * ||x||.",
                                    "Inclua o denominador corretivo: divida por (1 - cond(A) ||δA||/||A||) para precisão.",
                                    "Derive formalmente a fórmula |δx|/|x| ≤ cond(A) |δA|/|A| / (1 - cond(A) |δA|/|A|)."
                                  ],
                                  "verification": "Escreva a derivação passo a passo em um caderno e verifique com referência teórica.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, livro de Álgebra Linear Numérica (ex: Golub-Van Loan), Python para validação simbólica (SymPy).",
                                  "tips": "Assuma ||δA||/||A|| << 1 para validade da aproximação.",
                                  "learningObjective": "Derivar analiticamente a bound de erro para perturbações em A.",
                                  "commonMistakes": "Esquecer o termo de segunda ordem ou o denominador corretivo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar a bound e analisar instabilidade",
                                  "subSteps": [
                                    "Explique que o numerador cond(A) |δA|/|A| amplifica o erro relativo em A.",
                                    "Mostre que para cond(A) grande, pequeno |δA|/|A| causa grande |δx|/|x|.",
                                    "Discuta o denominador: falha se cond(A) |δA|/|A| ≥1 (perturbação crítica).",
                                    "Compare com bound para perturbações em b: similar mas sem denominador.",
                                    "Gráficos: plote |δx|/|x| vs cond(A) para |δA|/|A| fixo."
                                  ],
                                  "verification": "Descreva verbalmente por que cond(A)>10^6 indica instabilidade prática.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Gráficos em Python/MATLAB, exemplos de matrizes ill-condicionadas (Hilbert).",
                                  "tips": "Use log-escala para visualizar amplificação exponencial.",
                                  "learningObjective": "Interpretar qualitativamente a instabilidade causada por cond(A) grande.",
                                  "commonMistakes": "Ignorar que a bound é uma upper bound, não exata."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a bound em exemplo numérico",
                                  "subSteps": [
                                    "Escolha A bem condicionada (ex: identidade) e ill-condicionada (ex: Hilbert 3x3).",
                                    "Perturbe A com δA pequeno (ex: 10^{-6} ||A||).",
                                    "Resolva Ax=b e (A+δA)(x+δx)=b numericamente.",
                                    "Calcule erros relativos e compare com a bound teórica.",
                                    "Analise: para qual cond(A) o erro explode?"
                                  ],
                                  "verification": "Tabela com erros observados vs bound prevista para duas matrizes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python (NumPy/SciPy para solve), MATLAB, planilha Excel para pequenos casos.",
                                  "tips": "Use np.linalg.cond() para cond(A) e np.linalg.solve() para soluções.",
                                  "learningObjective": "Validar a bound empiricamente e observar instabilidade.",
                                  "commonMistakes": "Arredondamento numérico mascarando erros; use precisão dupla."
                                }
                              ],
                              "practicalExample": "Considere A = [[1,1],[1,1+ε]] com ε=10^{-10}, b=[1,1]^T. cond(A)≈1/ε grande. Perturbe A adicionando δA=10^{-12} em (1,2). A solução x muda drasticamente apesar de δA minúsculo, ilustrando |δx|/|x| >> |δA|/|A| devido a cond(A) alto.",
                              "finalVerifications": [
                                "Deriva corretamente a bound completa.",
                                "Calcula cond(A) e aplica na bound para exemplo dado.",
                                "Explica instabilidade para cond(A)>10^4.",
                                "Valida numericamente com erro <10% da bound.",
                                "Identifica condição de falha do denominador.",
                                "Discute diferenças com perturbações em b."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação (fórmula exata: 100%)",
                                "Interpretação qualitativa clara (amplificação e instabilidade)",
                                "Cálculos numéricos corretos (cond(A), erros relativos)",
                                "Uso apropriado de normas matriciais",
                                "Análise de exemplo prático com gráficos/tabelas",
                                "Conexão com estabilidade geral de sistemas lineares"
                              ],
                              "crossCurricularConnections": [
                                "Computação: Análise de erros em algoritmos numéricos (ex: LU decomposition)",
                                "Física: Modelagem de sistemas dinâmicos sensíveis (ex: equações diferenciais discretizadas)",
                                "Engenharia: Simulações finitas em estruturas (mesh ill-condicionadas)",
                                "Estatística: Regressão linear e multicolinearidade"
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, matrizes de rigidez em análise finita de elementos são ill-condicionadas; perturbações numéricas em A (devido a precisão máquina) causam erros catastróficos em tensões preditas, exigindo pré-condicionadores ou refinamento de malha."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.3.3",
                            "name": "Interpretar e exemplificar condição",
                            "description": "Classificar matrizes como bem condicionadas (cond(A) ≈ 1) ou mal condicionadas (cond(A) >> 1), com exemplos numéricos e gráficos de perturbações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de número de condição",
                                  "subSteps": [
                                    "Defina o número de condição cond(A) como a razão entre a maior e menor norma singular de A, ou cond(A) = ||A|| * ||A^{-1}||.",
                                    "Explique que cond(A) ≈ 1 indica matriz bem condicionada (estável a perturbações).",
                                    "Discuta que cond(A) >> 1 indica mal condicionada (pequenas mudanças em A causam grandes erros na solução).",
                                    "Relacione com autovalores: cond_2(A) = |λ_max / λ_min| para matrizes simétricas positivas definidas.",
                                    "Estude a fórmula cond(A) ≤ κ para normas consistentes."
                                  ],
                                  "verification": "Resuma em suas palavras o significado de cond(A) ≈ 1 vs. cond(A) >> 1, com um exemplo verbal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Álgebra Linear Computacional, notas de aula, calculadora.",
                                  "tips": "Use analogia: cond(A) baixo é como uma mesa estável; alto é como uma torre instável.",
                                  "learningObjective": "Compreender conceitualmente o número de condição e sua interpretação.",
                                  "commonMistakes": "Confundir cond(A) com determinante; ignorar que cond depende da norma escolhida."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o número de condição para matrizes simples",
                                  "subSteps": [
                                    "Escolha norma 2: calcule autovalores de A^T A para singular values.",
                                    "Para matriz 2x2, compute A^{-1} manualmente e multiplique normas.",
                                    "Use software: em Python/NumPy, np.linalg.cond(A).",
                                    "Calcule para A = identidade 2x2 (esperado cond=1).",
                                    "Compare com A = [[1,0],[0,2]] (cond=2)."
                                  ],
                                  "verification": "Calcule cond para duas matrizes dadas e confira com software (erro <1%).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com NumPy, MATLAB ou Octave, papel para cálculos manuais.",
                                  "tips": "Sempre normalize matrizes para evitar overflow em normas grandes.",
                                  "learningObjective": "Dominar cálculo prático de cond(A) em normas comuns.",
                                  "commonMistakes": "Esquecer de usar a mesma norma para A e A^{-1}; erro em inversa manual."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Classificar matrizes como bem ou mal condicionadas",
                                  "subSteps": [
                                    "Defina thresholds: cond < 10^2 bem condicionada; >10^4 mal condicionada.",
                                    "Exemplo bem: A = [[1,0.1],[0.1,1]] (cond≈1.02).",
                                    "Exemplo mal: A = [[1,1],[1,1+10^{-6}]] (cond≈10^6).",
                                    "Calcule cond para 3 matrizes e classifique.",
                                    "Registre em tabela: matriz, cond, classificação."
                                  ],
                                  "verification": "Crie tabela com 3 matrizes classificadas corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha Excel ou Jupyter Notebook, exemplos de matrizes.",
                                  "tips": "Teste com eps=1e-6 para simular precisão máquina.",
                                  "learningObjective": "Classificar matrizes baseando-se em valores de cond(A).",
                                  "commonMistakes": "Usar threshold fixo sem contexto; confundir com rank."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Exemplificar perturbações numéricas e gráficas",
                                  "subSteps": [
                                    "Perturbe A com δA pequeno (||δA||/||A||=1e-6), resolva Ax=b e Ax+δA=b.",
                                    "Meça ||δx||/||x|| e compare com bound cond(A)*||δA||/||A||.",
                                    "Para mal condicionada, mostre amplificação.",
                                    "Gere gráfico: eixo x=ε perturbação, y=erro relativo em solução.",
                                    "Interprete: gráfico plano para bem cond., íngreme para mal cond."
                                  ],
                                  "verification": "Gere gráfico mostrando diferença clara entre bem e mal condicionada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python/MATLAB com matplotlib, matrizes de exemplo.",
                                  "tips": "Use logscale no eixo y para erros pequenos.",
                                  "learningObjective": "Demonstrar impacto de condição via perturbações e visualizações.",
                                  "commonMistakes": "Perturbações muito grandes invalidam aproximações lineares; gráfico sem log."
                                }
                              ],
                              "practicalExample": "Considere A_bem = [[1, 0],[0, 1]] (cond=1). Perturbe com δA=[[0,1e-6],[1e-6,0]], resolva Ax= [1,1]^T. Erro relativo ≈1e-6. Agora A_mal=[[1,1],[1,1.000001]] (cond≈1e6), mesmo δA/b causa erro relativo ≈0.5, mostrando amplificação.",
                              "finalVerifications": [
                                "Classificar corretamente 5 matrizes aleatórias como bem/mal condicionadas.",
                                "Calcular cond(A) manual e via software para 2x2 com precisão.",
                                "Gerar gráfico de perturbação mostrando amplificação para cond>>1.",
                                "Explicar verbalmente por que cond(A)=1 é ideal.",
                                "Aplicar bound de erro em um sistema perturbado."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de cond(A) (<5% erro).",
                                "Classificação coerente com thresholds padrão.",
                                "Gráficos claros e interpretados corretamente.",
                                "Exemplos numéricos com perturbações realistas.",
                                "Interpretação qualitativa precisa de sensibilidade.",
                                "Uso correto de normas e software."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação em NumPy/SciPy para análise numérica.",
                                "Engenharia: Avaliação de estabilidade em modelos finitos (FEM).",
                                "Física: Sensibilidade em simulações dinâmicas e orbitais.",
                                "Estatística: Condição em regressão linear múltipla."
                              ],
                              "realWorldApplication": "Em engenharia estrutural, matrizes de rigidez mal condicionadas levam a erros em análises de tensão; engenheiros usam cond(A) para refinar malhas FEM e garantir precisão em simulações de pontes ou aviões."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.3.4",
                            "name": "Relacionar com métodos numéricos",
                            "description": "Discutir impacto do cond(A) na precisão de decomposição QR, Gauss e métodos iterativos como GMRES.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos de número de condição e análise de erros em sistemas lineares",
                                  "subSteps": [
                                    "Defina o número de condição cond(A) = ||A|| * ||A^{-1}|| e sua interpretação como amplificador de erros.",
                                    "Explique a relação entre erro relativo no vetor solução e erro relativo no lado direito: |δx|/|x| ≈ cond(A) * |δb|/|b|.",
                                    "Discuta fontes de erro numérico: arredondamento em operações de ponto flutuante.",
                                    "Calcule cond(A) para matrizes bem e mal condicionadas usando normas 2 ou ∞.",
                                    "Interprete valores de cond(A): cond(A) < 10^3 (bem cond.), >10^6 (mal cond.)"
                                  ],
                                  "verification": "Resuma em um parágrafo a relação cond(A)-erro e calcule cond(A) para uma matriz exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Álgebra Linear Numérica (Golub/Van Loan), Python com NumPy/SciPy, Jupyter Notebook",
                                  "tips": "Use norma 2 para cond(A) em contextos espectrais; evite normas inconsistentes.",
                                  "learningObjective": "Compreender como cond(A) amplifica erros relativos em soluções de Ax=b.",
                                  "commonMistakes": "Confundir cond(A) com det(A); ignorar dependência da norma escolhida."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar impacto do cond(A) na eliminação de Gauss",
                                  "subSteps": [
                                    "Revise o processo de eliminação de Gauss com pivotação parcial.",
                                    "Discuta crescimento de elementos durante eliminação: bound cond(A)-dependente.",
                                    "Simule numericamente: resolva Ax=b para matriz mal-condicionada (ex: Hilbert) sem/s com pivotação.",
                                    "Compare erros relativos na solução com predição cond(A) * máquina eps.",
                                    "Conclua: métodos diretos como Gauss sofrem mais com alto cond(A) devido a subtrações canceladoras."
                                  ],
                                  "verification": "Gere gráfico de erro vs cond(A) para diferentes matrizes e métodos Gauss.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB ou Python (SciPy.linalg.lu), matrizes teste (Hilbert, Vandermonde)",
                                  "tips": "Sempre use pivotação; teste com eps máquina (1e-16).",
                                  "learningObjective": "Identificar limitações da eliminação de Gauss em matrizes mal-condicionadas.",
                                  "commonMistakes": "Omitir pivotação levando a singularidade numérica; superestimar estabilidade sem simulação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar impacto na decomposição QR",
                                  "subSteps": [
                                    "Explique decomposição QR via Householder ou Givens para estabilidade.",
                                    "Analise backward error: QR é mais estável que Gauss, erro ≈ máquina eps * cond(A).",
                                    "Implemente QR via Gram-Schmidt modificado e compare com lu_factor.",
                                    "Resolva Ax=b via QR: x = R^{-1} (Q^T b), avalie sensibilidade.",
                                    "Discuta: QR mitiga crescimento, mas ainda amplificado por cond(A)."
                                  ],
                                  "verification": "Compare resíduos ||Ax - b|| para Gauss vs QR em matriz cond(A)=10^8.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "SciPy (scipy.linalg.qr), exemplos de matrizes Frank ou Cauchy",
                                  "tips": "Prefira Householder para QR ortogonal estável.",
                                  "learningObjective": "Comparar estabilidade QR vs Gauss sob alto cond(A).",
                                  "commonMistakes": "Usar Gram-Schmidt clássico (instável); ignorar forward vs backward error."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar impacto em métodos iterativos como GMRES",
                                  "subSteps": [
                                    "Introduza GMRES: minimiza resíduo em Krylov subspace, convergência cond(A)-dependente.",
                                    "Discuta teoria: iterações ≈ sqrt(cond(A)) para CG, pior para GMRES não-simétrico.",
                                    "Simule GMRES em Ax=b mal-condicionado com pré-condicionadores.",
                                    "Compare curvas de convergência: alto cond(A) causa platô em resíduos.",
                                    "Síntese: iterativos toleram cond(A) alto se espectro clusterizado, mas geralmente lentos."
                                  ],
                                  "verification": "Plote número de iterações GMRES vs log(cond(A)) para família de matrizes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "SciPy (scipy.sparse.linalg.gmres), gerador de matrizes Toeplitz mal-condicionadas",
                                  "tips": "Use restart GMRES para memória; teste pré-condicionadores como ILU.",
                                  "learningObjective": "Avaliar trade-offs de métodos iterativos vs diretos em alto cond(A).",
                                  "commonMistakes": "Esquecer tolerância em resíduos; confundir convergência com precisão da solução."
                                }
                              ],
                              "practicalExample": "Considere matriz Hilbert 6x6 (cond(A)≈10^9): resolva Ax=b com b=ones(6). Use Gauss (erro~1e-5), QR (erro~1e-10), GMRES (200+ iterações para tol=1e-8). Observe amplificação de erros por cond(A).",
                              "finalVerifications": [
                                "Explicação correta de cond(A) como bound de erro relativo.",
                                "Simulações numéricas mostram impacto em Gauss, QR e GMRES.",
                                "Gráficos comparativos de erros/convergência gerados.",
                                "Discussão qualitativa alinhada com teoria (backward/forward error).",
                                "Identificação de quando métodos falham (cond(A)>1e12).",
                                "Sugestões de mitigação (pré-condicionadores, refinamento)."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: 30% (definições e teoremas corretos).",
                                "Análise numérica: 25% (simulações e gráficos válidos).",
                                "Comparação métodos: 20% (destaque diferenças cond(A)-dependentes).",
                                "Profundidade discussão: 15% (erros comuns e tips).",
                                "Síntese conclusiva: 10% (recomendações práticas)."
                              ],
                              "crossCurricularConnections": [
                                "Computação Científica: Implementação em Python/MATLAB.",
                                "Engenharia: Análise de elementos finitos (mal-condicionadas).",
                                "Física Computacional: Simulações CFD com operadores discretos.",
                                "Estatística: Regressão linear e multicolinearidade (cond(X))."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, resolver sistemas de elementos finitos para estruturas (matrizes mal-condicionadas por mesh fina); alto cond(A) exige QR ou GMRES pré-condicionado para precisão em tensões/forças."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.2",
                    "name": "Sensibilidade a Perturbações em b",
                    "description": "Análise do impacto de erros no vetor b na solução relativa de Ax=b.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.2.1.1",
                        "name": "Perturbações Relativas no Vetor b",
                        "description": "Compreensão das perturbações δb no vetor de lado direito b do sistema Ax = b e sua quantificação relativa via normas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.1.1",
                            "name": "Definir perturbação relativa em b",
                            "description": "Explicar o conceito de perturbação δb e calcular a medida relativa ||δb|| / ||b|| usando normas vetoriais apropriadas (como norma 2 ou infinito).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Normas Vetoriais Básicas",
                                  "subSteps": [
                                    "Defina norma vetorial como uma medida de tamanho de vetores.",
                                    "Estude norma 2 (Euclidiana): ||x||_2 = sqrt(sum x_i^2).",
                                    "Estude norma infinito: ||x||_∞ = max |x_i|.",
                                    "Calcule normas para vetores simples como [1,2] e [3,4].",
                                    "Compare normas 2 e ∞ em exemplos numéricos."
                                  ],
                                  "verification": "Resolva 3 exercícios de cálculo de normas e confira com calculadora ou software.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Folha de anotações",
                                    "Calculadora",
                                    "Referência de Álgebra Linear (capítulo de normas)"
                                  ],
                                  "tips": "Use Python/MATLAB para verificação rápida de normas.",
                                  "learningObjective": "Compreender e calcular normas vetoriais 2 e infinito com precisão.",
                                  "commonMistakes": [
                                    "Confundir norma 1 (soma absoluta) com norma 2",
                                    "Esquecer raiz quadrada na norma 2"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender Perturbação Absoluta δb",
                                  "subSteps": [
                                    "Defina perturbação absoluta δb como a diferença b' - b, onde b' é o vetor perturbado.",
                                    "Explique que δb representa erro de medição ou arredondamento.",
                                    "Meça ||δb|| usando normas aprendidas.",
                                    "Discuta contexto em sistemas Ax = b, onde b é perturbado.",
                                    "Identifique fontes comuns de perturbações em dados reais."
                                  ],
                                  "verification": "Desenhe diagrama vetorial mostrando b, b' e δb, e calcule ||δb|| para um exemplo.",
                                  "estimatedTime": "30 min",
                                  "materials": [
                                    "Papel e lápis para diagramas",
                                    "Exemplos de vetores de livros-texto"
                                  ],
                                  "tips": "Visualize vetores em R^2 para intuição geométrica.",
                                  "learningObjective": "Identificar e quantificar perturbações absolutas em vetores.",
                                  "commonMistakes": [
                                    "Confundir δb com perturbação relativa prematuramente",
                                    "Ignorar sinal em diferenças vetoriais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e Calcular Perturbação Relativa",
                                  "subSteps": [
                                    "Defina perturbação relativa como ||δb|| / ||b||, usando a mesma norma para numerador e denominador.",
                                    "Explique por que relativa é preferida: independe de escala.",
                                    "Calcule para norma 2: ||δb||_2 / ||b||_2.",
                                    "Calcule para norma ∞: ||δb||_∞ / ||b||_∞.",
                                    "Interprete valores: <1% é pequena perturbação."
                                  ],
                                  "verification": "Calcule perturbação relativa para 2 vetores exemplo e explique interpretação.",
                                  "estimatedTime": "40 min",
                                  "materials": [
                                    "Calculadora ou Python (numpy.linalg.norm)",
                                    "Planilha para cálculos"
                                  ],
                                  "tips": "Sempre especifique a norma usada para evitar ambiguidades.",
                                  "learningObjective": "Definir formalmente e computar perturbação relativa com normas apropriadas.",
                                  "commonMistakes": [
                                    "Usar normas diferentes no numerador e denominador",
                                    "Dividir por zero se ||b||=0"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Contextos de Sensibilidade",
                                  "subSteps": [
                                    "Relacione com solução de Ax = b: perturbação em b afeta x.",
                                    "Calcule exemplo numérico completo com A, b, δb.",
                                    "Compare perturbações relativas em diferentes normas.",
                                    "Discuta bounds de erro: ||δx|| / ||x|| ≤ cond(A) * ||δb|| / ||b||.",
                                    "Resolva exercício de sensibilidade simples."
                                  ],
                                  "verification": "Resolva problema completo e verifique se perturbação relativa é corretamente computada.",
                                  "estimatedTime": "50 min",
                                  "materials": [
                                    "Software como MATLAB/Python",
                                    "Matriz de exemplo 2x2"
                                  ],
                                  "tips": "Use norma consistente com o contexto do problema.",
                                  "learningObjective": "Aplicar conceito de perturbação relativa em análise de sensibilidade.",
                                  "commonMistakes": [
                                    "Esquecer fator de condição cond(A)",
                                    "Não normalizar corretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere b = [10, 20]^T com perturbação δb = [0.1, 0.2]^T. Calcule perturbação relativa: Norma 2: ||δb||_2 ≈ 0.2236, ||b||_2 ≈ 22.3607, relativa ≈ 0.01 (1%). Norma ∞: ||δb||_∞ = 0.2, ||b||_∞ = 20, relativa = 0.01.",
                              "finalVerifications": [
                                "Define corretamente perturbação relativa como ||δb|| / ||b||.",
                                "Calcula normas 2 e ∞ sem erros em exemplos.",
                                "Explica diferença entre perturbações absoluta e relativa.",
                                "Aplica em sistema linear simples com precisão.",
                                "Interpreta valores relativos (ex: 0.01 significa 1% de erro).",
                                "Identifica norma apropriada para contexto dado."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de normas (erro < 0.01%).",
                                "Definição formal correta sem ambiguidades.",
                                "Explicação clara da relevância em sensibilidade.",
                                "Uso consistente de normas no numerador e denominador.",
                                "Interpretação qualitativa adequada dos resultados.",
                                "Aplicação correta em exemplo de sistema linear."
                              ],
                              "crossCurricularConnections": [
                                "Computação Numérica: Análise de erros de arredondamento em solvers lineares.",
                                "Física: Erros de medição em vetores de forças ou posições.",
                                "Engenharia: Sensibilidade em modelos de simulação (ex: estruturas).",
                                "Estatística: Quantificação de ruído em dados observados."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, perturbações relativas em vetores de carga (b) são analisadas para avaliar sensibilidade de soluções de equilíbrio estrutural, garantindo segurança sob incertezas de medição."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.1.2",
                            "name": "Calcular normas relativas de perturbações",
                            "description": "Dado um vetor b e uma perturbação δb, computar ||δb|| / ||b|| para diferentes normas e interpretar o nível de ruído relativo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos de Normas Vetoriais",
                                  "subSteps": [
                                    "Defina norma de vetor como uma medida de seu 'tamanho' ou magnitude.",
                                    "Liste as normas comuns: norma 1 (soma absoluta dos componentes), norma 2 (raiz quadrada da soma dos quadrados), norma infinito (máximo absoluto dos componentes).",
                                    "Escreva as fórmulas matemáticas para cada norma: ||x||_1 = Σ|x_i|, ||x||_2 = √(Σx_i²), ||x||_∞ = max|x_i|.",
                                    "Discuta propriedades das normas: positividade, homogeneidade, desigualdade triangular.",
                                    "Pratique calculando normas simples para vetores exemplo."
                                  ],
                                  "verification": "Liste corretamente as três normas com fórmulas e calcule ||[1,2,3]|| para cada uma.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Calculadora ou software como Python/NumPy"
                                  ],
                                  "tips": "Use exemplos pequenos (2-3 dimensões) para praticar antes de vetores maiores.",
                                  "learningObjective": "Compreender e formular as definições de normas vetoriais comuns.",
                                  "commonMistakes": [
                                    "Confundir norma 1 com soma simples (esquecer absolutos)",
                                    "Esquecer raiz na norma 2"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Normas de b e δb",
                                  "subSteps": [
                                    "Identifique o vetor original b e a perturbação δb fornecidos no problema.",
                                    "Escolha uma norma específica (ex: norma 2) e compute ||b|| usando a fórmula apropriada.",
                                    "Compute ||δb|| da mesma forma para a mesma norma.",
                                    "Repita o cálculo para pelo menos uma outra norma (ex: norma infinito).",
                                    "Registre os valores numéricos com precisão decimal adequada."
                                  ],
                                  "verification": "Apresente cálculos passo a passo para ||b|| e ||δb|| em duas normas diferentes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Vetores b e δb exemplo",
                                    "Calculadora gráfica ou Python com NumPy.linalg.norm"
                                  ],
                                  "tips": "Automatize com código se possível para verificação rápida.",
                                  "learningObjective": "Executar cálculos precisos de normas para vetores dados.",
                                  "commonMistakes": [
                                    "Usar norma errada para δb",
                                    "Arredondar prematuramente nos cálculos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar a Razão Relativa de Perturbação",
                                  "subSteps": [
                                    "Calcule a razão relativa ρ = ||δb|| / ||b|| para cada norma escolhida.",
                                    "Garanta que ||b|| ≠ 0; caso contrário, avalie o caso especial.",
                                    "Compare ρ entre diferentes normas e anote diferenças.",
                                    "Expresse ρ em notação científica para valores pequenos.",
                                    "Crie uma tabela resumindo ρ para cada norma."
                                  ],
                                  "verification": "Forneça tabela com ρ calculado para pelo menos duas normas, com valores exatos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Resultados dos passos anteriores",
                                    "Planilha Excel ou papel para tabela"
                                  ],
                                  "tips": "Sempre divida perturbação pela original para relativizar o erro.",
                                  "learningObjective": "Calcular e tabular medidas relativas de perturbação.",
                                  "commonMistakes": [
                                    "Inverter numerador e denominador",
                                    "Ignorar norma zero"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar o Nível de Ruído Relativo",
                                  "subSteps": [
                                    "Classifique ρ: baixo ruído (<10^{-3}), moderado (10^{-3} a 10^{-1}), alto (>10^{-1}).",
                                    "Discuta implicações: baixo ρ sugere solução estável a perturbações em b.",
                                    "Compare interpretações entre normas (ex: norma inf sensível a picos).",
                                    "Relacione com contexto de sistemas lineares: impacto em solução x.",
                                    "Conclua com recomendação (ex: usar norma 2 para equilíbrio)."
                                  ],
                                  "verification": "Escreva parágrafo interpretando ρ e suas implicações para o problema.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de ρ do passo 3",
                                    "Referência rápida de análise numérica"
                                  ],
                                  "tips": "Pense em termos percentuais: ρ=0.01 é 1% de ruído relativo.",
                                  "learningObjective": "Interpretar quantitativamente o ruído relativo em contextos aplicados.",
                                  "commonMistakes": [
                                    "Interpretar ρ absoluto sem contexto",
                                    "Ignorar diferenças entre normas"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado b = [10, 20, 30]^T e δb = [0.1, 0.05, 0.2]^T. Calcule ρ_2 = ||δb||_2 / ||b||_2 ≈ 0.011 / 36.77 ≈ 0.0003 (baixo ruído). Para norma ∞: ρ_∞ = 0.2 / 30 ≈ 0.0067 (ainda baixo, mas destaca pico em δb_3). Interpretação: Perturbação mínima, solução numérica confiável.",
                              "finalVerifications": [
                                "Cálculos de ||b|| e ||δb|| corretos para todas normas usadas.",
                                "Razões relativas ρ computadas sem erros aritméticos.",
                                "Tabela comparativa de ρ por norma presente.",
                                "Interpretação qualitativa (baixo/moderado/alto) alinhada com thresholds padrão.",
                                "Discussão de pelo menos uma implicação em sistemas lineares.",
                                "Exemplo prático resolvido com valores numéricos precisos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de normas (erro < 10^{-6}).",
                                "Correta formulação e uso de múltiplas normas.",
                                "Clareza na tabulação e apresentação de resultados.",
                                "Profundidade na interpretação do ruído relativo.",
                                "Identificação de padrões ou diferenças entre normas.",
                                "Aplicação contextual a perturbações em equações lineares."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de erros em medições experimentais de vetores (ex: forças, velocidades).",
                                "Computação: Estabilidade numérica em solvers de álgebra linear (ex: NumPy, MATLAB).",
                                "Estatística: Quantificação de ruído relativo em dados observados.",
                                "Engenharia: Avaliação de sensibilidade em modelos de simulação."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, calcular ρ para perturbações em vetores de carga (b) devido a ruídos de sensores (δb), garantindo que soluções de equilíbrio estrutural permaneçam confiáveis apesar de imprecisões de medição."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.1.3",
                            "name": "Modelar erros em b numericamente",
                            "description": "Simular perturbações em b representando erros de arredondamento ou medição em contextos computacionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Sistema Linear Original",
                                  "subSteps": [
                                    "Escolha uma matriz A quadrada invertível (ex: 2x2 ou 3x3) com cond(A) conhecida.",
                                    "Defina o vetor b original sem perturbação.",
                                    "Resolva Ax = b para obter a solução x exata usando um solver numérico.",
                                    "Calcule a norma ||b|| para referência futura.",
                                    "Documente todos os valores em um relatório ou notebook."
                                  ],
                                  "verification": "Verifique se Ax = b dentro de tolerância 1e-10 e cond(A) > 1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python com NumPy/SciPy, Jupyter Notebook ou MATLAB.",
                                  "tips": "Use np.linalg.cond(A) para cond(A); prefira matrizes ill-condicionadas para demonstrar sensibilidade.",
                                  "learningObjective": "Compreender a configuração base de um sistema linear estável.",
                                  "commonMistakes": "Escolher A singular ou mal-condicionada sem calcular cond(A) previamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Perturbação Relativa em b",
                                  "subSteps": [
                                    "Defina o nível de perturbação relativa ε (ex: 1e-6 para erros de arredondamento).",
                                    "Gere Δb = ε * ||b|| * u, onde u é vetor unitário aleatório (use np.random.randn).",
                                    "Calcule b_pert = b + Δb.",
                                    "Verifique ||Δb|| / ||b|| ≈ ε.",
                                    "Registre ε e a direção da perturbação."
                                  ],
                                  "verification": "Confirme que a perturbação relativa é exatamente ε via norma euclidiana.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python com NumPy para geração aleatória e normas.",
                                  "tips": "Use semente fixa (np.random.seed(42)) para reprodutibilidade.",
                                  "learningObjective": "Modelar realisticamente erros de medição ou arredondamento em b.",
                                  "commonMistakes": "Confundir perturbação absoluta com relativa; sempre normalize por ||b||."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver o Sistema Perturbado",
                                  "subSteps": [
                                    "Resolva A x_pert = b_pert para obter x_pert.",
                                    "Calcule Δx = x_pert - x.",
                                    "Compute a perturbação relativa em x: ||Δx|| / ||x||.",
                                    "Compare com ||Δb|| / ||b||.",
                                    "Plote gráficos de x vs x_pert se dimensionalidade permitir."
                                  ],
                                  "verification": "A x_pert ≈ b_pert dentro de tolerância máquina.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Solver np.linalg.solve() ou equivalente.",
                                  "tips": "Monitore resíduos com np.linalg.norm(A @ x_pert - b_pert).",
                                  "learningObjective": "Quantificar o impacto da perturbação em b na solução x.",
                                  "commonMistakes": "Usar solver instável como inversa direta; prefira solve()."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Sensibilidade e Conclusões",
                                  "subSteps": [
                                    "Calcule o fator de amplificação: (||Δx|| / ||x||) / (||Δb|| / ||b||).",
                                    "Relacione com cond(A): verifique se ≈ cond(A) para sistemas sensíveis.",
                                    "Repita com 3-5 valores de ε e plote curvas de erro.",
                                    "Interprete resultados: discuta bounds teóricos (||Δx||/||x|| ≤ cond(A) * ||Δb||/||b||).",
                                    "Escreva um resumo com insights."
                                  ],
                                  "verification": "Fator de amplificação coerente com teoria (≤ cond(A)).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Matplotlib para plots, fórmulas teóricas de álgebra linear.",
                                  "tips": "Teste com A bem e mal condicionada para contraste.",
                                  "learningObjective": "Interpretar numericamente a sensibilidade de sistemas lineares a b.",
                                  "commonMistakes": "Ignorar o papel de cond(A); sempre comparar com bound teórico."
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 1], [1, 1+1e-6]], b = [3, 3+1e-6], solução x ≈ [1.5, 1.5]. Perturbe b com ε=1e-8: Δb gerado aleatoriamente. Resolva e observe ||Δx||/||x|| amplificado por cond(A)≈1e6, resultando em perda de precisão.",
                              "finalVerifications": [
                                "Sistema original resolvido com resíduo <1e-12.",
                                "Perturbação relativa em b exatamente ε.",
                                "Fator de amplificação ≤ cond(A).",
                                "Plots mostram amplificação para A ill-condicionada.",
                                "Relatório inclui interpretação teórica vs numérica.",
                                "Testes repetidos com sementes diferentes confirmam consistência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na geração de Δb relativa (erro <1%).",
                                "Correta computação de normas e fatores de sensibilidade.",
                                "Interpretação alinhada com teoria (cond(A) bound).",
                                "Uso apropriado de solvers numéricos estáveis.",
                                "Relatório claro com plots e conclusões acionáveis.",
                                "Reprodutibilidade via código comentado."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ruído em medições experimentais.",
                                "Estatística: Análise de erro propagado em regressão linear.",
                                "Ciência da Computação: Estabilidade numérica em algoritmos.",
                                "Engenharia: Simulação de sensores com erros de precisão."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, modela erros de sensores em sistemas de controle (Ax=b onde b são leituras ruidosas), prevendo instabilidades; em finanças, simula impactos de dados de mercado imprecisos em otimização de portfólios."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.1.2",
                        "name": "Impacto das Perturbações em b na Solução x",
                        "description": "Análise de como pequenas mudanças em b propagam para erros na solução x de Ax = b.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.2.1",
                            "name": "Resolver sistema com b perturbado",
                            "description": "Dado Ax = b e uma perturbação δb, resolver A(x + δx) = b + δb e isolar δx = A^{-1} δb.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o sistema original e introduzir a perturbação em b",
                                  "subSteps": [
                                    "Recordar que o sistema original é Ax = b, onde A é a matriz de coeficientes, x a solução e b o vetor de termos independentes.",
                                    "Definir a perturbação δb como uma pequena variação no vetor b, representando erros de medição ou ruído.",
                                    "Formular o sistema perturbado: A(x + δx) = b + δb, onde δx é a variação na solução x."
                                  ],
                                  "verification": "Escrever corretamente a equação do sistema perturbado a partir do original.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta ou software de álgebra como MATLAB/Octave",
                                    "Exemplo numérico simples de sistema 2x2"
                                  ],
                                  "tips": "Visualize δb como um vetor pequeno apontando na direção de b para intuitivamente entender o impacto.",
                                  "learningObjective": "Compreender conceitualmente como perturbações em b afetam x em sistemas lineares.",
                                  "commonMistakes": "Confundir δb com perturbação em A ou assumir que δx é proporcional diretamente a δb sem inversa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a expressão analítica para δx",
                                  "subSteps": [
                                    "Expandir a equação perturbada: Ax + A δx = b + δb.",
                                    "Subtrair Ax = b de ambos os lados para isolar A δx = δb.",
                                    "Concluir que δx = A^{-1} δb, assumindo A invertível."
                                  ],
                                  "verification": "Derivar passo a passo δx = A^{-1} δb sem erros algébricos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Quadro ou editor de texto para derivação",
                                    "Conhecimento prévio de propriedades de matrizes"
                                  ],
                                  "tips": "Lembre-se: multiplicar ambos os lados por A^{-1} da esquerda preserva a igualdade.",
                                  "learningObjective": "Dominar a derivação teórica da sensibilidade da solução a perturbações em b.",
                                  "commonMistakes": "Esquecer de subtrair o sistema original ou inverter a ordem na multiplicação matricial."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver numericamente o sistema para δx",
                                  "subSteps": [
                                    "Escolher ou receber um sistema Ax = b específico e δb.",
                                    "Resolver Ay = δb para y = δx, usando eliminação gaussiana, decomposição LU ou função de solver (ex: \\ em MATLAB).",
                                    "Calcular a solução perturbada x + δx e compará-la com x original."
                                  ],
                                  "verification": "Obter δx correto e verificar que A δx ≈ δb (com tolerância numérica).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora matricial ou software (Python NumPy, MATLAB)",
                                    "Matriz A invertível de tamanho pequeno (2x2 ou 3x3)"
                                  ],
                                  "tips": "Use solvers numéricos estáveis para evitar amplificação de erros.",
                                  "learningObjective": "Aplicar métodos numéricos para computar variações δx.",
                                  "commonMistakes": "Usar inversa explícita A^{-1} (instável numericamente); prefira solvers diretos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e interpretar o impacto da perturbação",
                                  "subSteps": [
                                    "Calcular normas: ||δx|| / ||x|| e ||δb|| / ||b|| para condição relativa.",
                                    "Discutir o fator de amplificação ||A^{-1}|| como medida de sensibilidade.",
                                    "Generalizar para perturbações aleatórias ou worst-case."
                                  ],
                                  "verification": "Interpretar corretamente se a perturbação é amplificada ou atenuada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software para normas de vetores/matrizes",
                                    "Gráficos de ||δx|| vs ||δb||"
                                  ],
                                  "tips": "Norma 2 é comum; teste com diferentes δb para ver direção-dependência.",
                                  "learningObjective": "Avaliar quantitativamente a sensibilidade do sistema.",
                                  "commonMistakes": "Ignorar que sensibilidade depende da direção de δb, não só magnitude."
                                }
                              ],
                              "practicalExample": "Considere A = [[2, 1], [1, 2]], b = [3, 3], então x = [1, 1]. Para δb = [0.1, 0.05], resolva A δx = δb obtendo δx ≈ [0.0333, 0.0167], e x_perturbado ≈ [1.0333, 1.0167]. Verifique A x_perturbado ≈ [3.1, 3.05].",
                              "finalVerifications": [
                                "Derivação correta de δx = A^{-1} δb.",
                                "Cálculo numérico preciso de δx para exemplo dado.",
                                "Análise qualitativa do fator de amplificação.",
                                "Verificação matricial A δx = δb com erro < 1e-10.",
                                "Interpretação correta da sensibilidade relativa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação teórica (100% correta).",
                                "Eficiência no uso de solvers numéricos (tempo < 5 min para 3x3).",
                                "Interpretação quantitativa com normas (erro < 5%).",
                                "Generalização para sistemas maiores sem perda de acurácia.",
                                "Capacidade de discutir limitações numéricas."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementar em Python/MATLAB para análise de estabilidade.",
                                "Física: Modelagem de erros de medição em sistemas dinâmicos.",
                                "Estatística: Análise de sensibilidade em regressão linear.",
                                "Engenharia: Avaliação de robustez em controle de sistemas."
                              ],
                              "realWorldApplication": "Em engenharia civil, perturbações em cargas (δb) devido a ventos ou erros de medição afetam deslocamentos (x); δx = A^{-1} δb quantifica risco de falha estrutural, essencial para design seguro de pontes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.2.2",
                            "name": "Quantificar erro relativo em x",
                            "description": "Calcular ||δx|| / ||x|| a partir de δb e relacionar com propriedades da matriz A.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o sistema linear e introduzir perturbação em b",
                                  "subSteps": [
                                    "Relembre o sistema Ax = b, onde A é invertível.",
                                    "Defina a perturbação: novo sistema A(x + δx) = b + δb.",
                                    "Simplifique para obter A δx = δb.",
                                    "Discuta normas vetoriais (ex: norma 2 ou infinito) para medir erros.",
                                    "Calcule ||δb|| / ||b|| como erro relativo em b."
                                  ],
                                  "verification": "Escreva a equação A δx = δb e defina ||δb|| / ||b|| corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha de papel, calculadora, notas de álgebra linear básica.",
                                  "tips": "Use norma euclidiana (||v||_2) para simplicidade em vetores.",
                                  "learningObjective": "Compreender como perturbações em b afetam x linearmente.",
                                  "commonMistakes": "Confundir δx com mudança em A; esquecer que A é fixa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a aproximação para δx",
                                  "subSteps": [
                                    "Multiplique ambos os lados de A δx = δb por A^{-1}.",
                                    "Obtenha δx = A^{-1} δb.",
                                    "Tome normas: ||δx|| ≤ ||A^{-1}|| ||δb||.",
                                    "Relacione com x: como Ax = b, ||x|| ≤ ||A^{-1}|| ||b||.",
                                    "Esboce a desigualdade inicial para ||δx|| / ||x||."
                                  ],
                                  "verification": "Derive e escreva δx = A^{-1} δb e a bound ||δx|| ≤ ||A^{-1}|| ||δb||.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora matricial ou software como MATLAB/Octave, exemplos de matrizes 2x2.",
                                  "tips": "Teste com matriz identidade para verificar (δx = δb).",
                                  "learningObjective": "Derivar a solução exata para δx em termos de A^{-1}.",
                                  "commonMistakes": "Esquecer o papel de A^{-1}; usar norma errada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o erro relativo ||δx|| / ||x||",
                                  "subSteps": [
                                    "Combine as bounds: ||δx|| / ||x|| ≤ (||A^{-1}|| ||δb||) / (||b|| / ||A||), assumindo ||Ax|| ≈ ||b||.",
                                    "Derive a forma completa: ||δx|| / ||x|| ≤ κ(A) * (||δb|| / ||b||), onde κ(A) = ||A|| ||A^{-1}||.",
                                    "Explique o papel amplificador do número de condição κ(A).",
                                    "Calcule κ(A) para uma matriz exemplo.",
                                    "Compare erros amplificados vs. não amplificados."
                                  ],
                                  "verification": "Escreva a fórmula final com κ(A) e prove a bound.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software para normas e inversas (Python NumPy, MATLAB), matrizes de teste.",
                                  "tips": "Para matrizes singulares próximas, κ grande amplifica erros.",
                                  "learningObjective": "Quantificar o erro relativo usando o número de condição.",
                                  "commonMistakes": "Inverter ||A|| e ||A^{-1}|| na definição de κ(A); ignorar aproximações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e verificar numericamente",
                                  "subSteps": [
                                    "Escolha uma matriz A 2x2 com κ moderado.",
                                    "Gere b, resolva x, perturbe b com δb pequeno.",
                                    "Resolva novo x', compute ||δx|| / ||x|| e compare com κ(A) * ||δb|| / ||b||.",
                                    "Teste com A mal-condicionada (ex: Hilbert).",
                                    "Analise como propriedades de A afetam o erro."
                                  ],
                                  "verification": "Execute simulação numérica e confirme que erro ≤ bound teórico.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Python com NumPy/SciPy ou MATLAB para simulações.",
                                  "tips": "Use np.linalg.cond() para calcular κ(A) rapidamente.",
                                  "learningObjective": "Validar teoricamente com experimentos numéricos.",
                                  "commonMistakes": "Escolha δb muito grande (use 10^{-6} * ||b||); erros de arredondamento."
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 1], [1, 1+ε]] com ε=0.001 (mal-condicionada, κ≈1000). b=[1,1]^T, x≈[0.5, 0.5]^T. Perturbe b com δb=10^{-5}[1,0]^T. Compute x novo, ||δx||/||x|| ≈ 0.005, enquanto κ*(||δb||/||b||)≈0.007, confirmando amplificação.",
                              "finalVerifications": [
                                "Deriva corretamente δx = A^{-1} δb.",
                                "Escreve ||δx|| / ||x|| ≤ κ(A) * (||δb|| / ||b||).",
                                "Calcula κ(A) = ||A|| ||A^{-1}|| para matriz dada.",
                                "Executa simulação numérica validando a bound.",
                                "Explica impacto de A mal-condicionada.",
                                "Identifica normas apropriadas (ex: 2-norma)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da bound (100% correto).",
                                "Correta definição e cálculo de κ(A).",
                                "Validação numérica com erro < 10% da bound teórica.",
                                "Explicação clara do papel amplificador de κ(A).",
                                "Uso consistente de normas vetoriais/matriciais.",
                                "Identificação de pelo menos 2 propriedades de A afetando sensibilidade."
                              ],
                              "crossCurricularConnections": [
                                "Computação Numérica: Análise de estabilidade em solvers lineares.",
                                "Física: Propagação de erros em medições experimentais (b como dados ruidosos).",
                                "Programação: Implementação em NumPy para análise de condicionamento.",
                                "Estatística: Erros relativos em regressão linear."
                              ],
                              "realWorldApplication": "Em engenharia civil, modelar estruturas com Ax=b onde b são cargas medidas com ruído; alto κ(A) pode amplificar erros, levando a designs inseguros. Em machine learning, sistemas lineares em otimização sofrem com dados perturbados, exigindo pré-condicionamento."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.1.3",
                        "name": "Teorema de Sensibilidade e Número de Condição",
                        "description": "Teorema que liga o erro relativo em x ao erro em b via o número de condição cond(A), com conexão à decomposição SVD.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.3.1",
                            "name": "Enunciar teorema de sensibilidade para b",
                            "description": "Estabelecer e provar que ||δx|| / ||x|| ≤ cond(A) ⋅ ||δb|| / ||b||, assumindo A não singular.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Sistema Linear e Perturbações em b",
                                  "subSteps": [
                                    "Lembre-se do sistema linear Ax = b, onde A é uma matriz n×n não singular.",
                                    "Considere uma pequena perturbação δb no vetor b, resultando no sistema perturbado A(x + δx) = b + δb.",
                                    "Derive a equação para a perturbação na solução: A δx = δb.",
                                    "Expresse δx = A⁻¹ δb.",
                                    "Discuta a importância de analisar o impacto relativo de δb em δx."
                                  ],
                                  "verification": "Escreva corretamente as equações Ax = b, A(x + δx) = b + δb e A δx = δb.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Notas de álgebra linear",
                                    "Definições de sistemas lineares",
                                    "Calculadora ou software como MATLAB/Octave"
                                  ],
                                  "tips": [
                                    "Sempre assuma A não singular para garantir A⁻¹ existe.",
                                    "Visualize graficamente para n=2 para intuição."
                                  ],
                                  "learningObjective": "Compreender o setup matemático de perturbações em b e sua relação com δx.",
                                  "commonMistakes": [
                                    "Confundir δx com δb.",
                                    "Esquecer a premissa de A não singular."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Normas Vetoriais/Matriciais e Número de Condição",
                                  "subSteps": [
                                    "Defina norma vetorial ||⋅|| (ex: norma 2 ou infinito) e norma matricial induzida ||A|| = sup ||Ax||/||x|| para x≠0.",
                                    "Defina o número de condição cond(A) = ||A|| ⋅ ||A⁻¹||.",
                                    "Explique que cond(A) ≥ 1 mede a sensibilidade de A a perturbações.",
                                    "Verifique propriedades: ||A⁻¹|| = sup ||A⁻¹ y||/||y|| para y≠0.",
                                    "Escolha uma norma consistente (submultiplicativa: ||AB|| ≤ ||A|| ||B||)."
                                  ],
                                  "verification": "Calcule cond(A) para uma matriz 2×2 simples e defina corretamente as normas.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Tabela de normas comuns",
                                    "Exemplos de matrizes",
                                    "Software para cálculo de normas (NumPy/MATLAB)"
                                  ],
                                  "tips": [
                                    "Use norma 2 para intuição geométrica (singular values).",
                                    "Lembre: cond(A) amplifica erros."
                                  ],
                                  "learningObjective": "Dominar definições precisas de normas e cond(A) para uso na prova.",
                                  "commonMistakes": [
                                    "Usar norma não induzida.",
                                    "Confundir cond(A) com det(A)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Enunciar o Teorema de Sensibilidade para b",
                                  "subSteps": [
                                    "Enuncie: Para Ax = b com A não singular, ||δx|| / ||x|| ≤ cond(A) ⋅ ||δb|| / ||b||.",
                                    "Explique o significado: erro relativo em x é no máximo cond(A) vezes erro relativo em b.",
                                    "Assuma normas consistentes e δb pequeno (para linearidade).",
                                    "Discuta que a desigualdade é afiada quando cond(A)=1.",
                                    "Escreva o teorema formalmente com todas as premissas."
                                  ],
                                  "verification": "Escreva o enunciado exato do teorema, incluindo assunções.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Folha para anotar teoremas",
                                    "Livro de álgebra linear (ex: Strang)"
                                  ],
                                  "tips": [
                                    "Memorize a forma: erro_x / ||x|| ≤ cond(A) * erro_b / ||b||.",
                                    "Relacione com 'regra dos 16 dígitos' em computação."
                                  ],
                                  "learningObjective": "Enunciar precisamente o teorema com contexto e limitações.",
                                  "commonMistakes": [
                                    "Omitir divisão por ||x|| ou ||b||.",
                                    "Esquecer cond(A)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar o Teorema Passo a Passo",
                                  "subSteps": [
                                    "De δx = A⁻¹ δb, tome normas: ||δx|| ≤ ||A⁻¹|| ⋅ ||δb||.",
                                    "Para ||x||: como b = A x, ||b|| ≤ ||A|| ⋅ ||x||, logo ||x|| ≥ ||b|| / ||A||.",
                                    "Substitua: ||δx|| / ||x|| ≤ (||A⁻¹|| ⋅ ||δb||) / (||b|| / ||A||) = ||A|| ⋅ ||A⁻¹|| ⋅ ||δb|| / ||b|| = cond(A) ⋅ ||δb|| / ||b||.",
                                    "Conclua a desigualdade ≤.",
                                    "Verifique se a norma é submultiplicativa."
                                  ],
                                  "verification": "Escreva a prova completa sem lacunas, verificando cada desigualdade.",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Papel e caneta para derivação",
                                    "Exemplos numéricos para teste"
                                  ],
                                  "tips": [
                                    "Use ≤ em todas as normas para direção correta.",
                                    "Pratique com norma específico (ex: ||⋅||_∞)."
                                  ],
                                  "learningObjective": "Derivar rigorosamente a prova do teorema.",
                                  "commonMistakes": [
                                    "Invertar desigualdade em ||x||.",
                                    "Esquecer fator ||A|| na denominação."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[2, 1], [1, 1]], b = [3, 2]^T, então x = [1, 1]^T. cond_2(A) ≈ 10.8. Perturbe δb = [0.01, 0]^T, calcule δx ≈ A⁻¹ δb = [0.0026, -0.0077]^T. Verifique: ||δx||_2 / ||x||_2 ≈ 0.0082 ≤ 10.8 * ||δb||_2 / ||b||_2 ≈ 10.8 * 0.005 / 2.236 ≈ 0.024.",
                              "finalVerifications": [
                                "Enuncie o teorema corretamente com todas as assunções.",
                                "Prove os passos principais sem erros aritméticos.",
                                "Calcule cond(A) e verifique desigualdade em um exemplo numérico.",
                                "Explique o papel de cond(A) na amplificação de erros.",
                                "Identifique quando a desigualdade é equality.",
                                "Discuta limitações para δb grandes."
                              ],
                              "assessmentCriteria": [
                                "Precisão no enunciado do teorema (100% match).",
                                "Correção na derivação de normas e cond(A).",
                                "Rigor na prova: todas as desigualdades justificadas.",
                                "Uso consistente de notação e normas.",
                                "Interpretação qualitativa da sensibilidade.",
                                "Exemplo numérico com cálculos verificáveis."
                              ],
                              "crossCurricularConnections": [
                                "Computação Numérica: Análise de erros de arredondamento em solvers lineares.",
                                "Engenharia: Sensibilidade em modelos de estruturas (ex: equilíbrio de forças).",
                                "Física: Perturbações em sistemas lineares como equações de movimento.",
                                "Estatística: Análise de sensibilidade em regressão linear."
                              ],
                              "realWorldApplication": "Em simulações de engenharia civil, analisar como erros de medição em cargas (δb) propagam para deformações estimadas (δx), usando cond(A) para avaliar confiabilidade do modelo e decidir se refinar medições ou modelo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.3.2",
                            "name": "Calcular número de condição via SVD",
                            "description": "Usar decomposição em valores singulares (SVD) de A para computar cond_2(A) = σ_max / σ_min e avaliar sensibilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a Matriz A e Configurar o Ambiente Computacional",
                                  "subSteps": [
                                    "Selecione ou crie uma matriz A de exemplo (quadrada ou retangular, ex: 2x2 ou 3x3).",
                                    "Instale e importe bibliotecas necessárias (NumPy no Python ou equivalente em MATLAB).",
                                    "Carregue a matriz A no ambiente de programação.",
                                    "Verifique as dimensões, tipo de dados e propriedades básicas como norma.",
                                    "Salve o código em um script para reutilização."
                                  ],
                                  "verification": "Matriz A é exibida corretamente com shape e valores esperados no console.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python 3+ com NumPy",
                                    "Editor de código (Jupyter Notebook ou VS Code)",
                                    "Matriz de exemplo impressa"
                                  ],
                                  "tips": "Comece com matrizes pequenas para facilitar depuração; use print() para inspecionar.",
                                  "learningObjective": "Configurar ambiente computacional pronto para SVD e validar entrada da matriz.",
                                  "commonMistakes": [
                                    "Importar biblioteca incorreta",
                                    "Definir matriz com tipo não numérico (string)",
                                    "Esquecer parênteses em np.array()"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar a Decomposição em Valores Singulares (SVD)",
                                  "subSteps": [
                                    "Aplique a função de SVD: U, S, Vh = np.linalg.svd(A, full_matrices=False).",
                                    "Armazene U (matriz esquerda), S (vetor de valores singulares) e Vh (matriz direita transposta).",
                                    "Reconstrua A aproximada: A_recon = U @ np.diag(S) @ Vh.",
                                    "Calcule o erro de reconstrução: np.linalg.norm(A - A_recon).",
                                    "Exiba U, S e Vh para inspeção inicial."
                                  ],
                                  "verification": "Erro de reconstrução < 1e-10 confirma SVD correto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "NumPy instalado",
                                    "Código do Step 1",
                                    "Calculadora para normas manuais opcionais"
                                  ],
                                  "tips": "Use full_matrices=False para economia computacional em matrizes não quadradas.",
                                  "learningObjective": "Executar SVD numericamente e validar decomposição pela reconstrução.",
                                  "commonMistakes": [
                                    "Confundir ordem de U, S, Vh",
                                    "Usar full_matrices=True desnecessariamente",
                                    "Ignorar normalização de colunas em U/V"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair e Ordenar os Valores Singulares",
                                  "subSteps": [
                                    "Identifique σ_max como o maior valor em S (S[0] pois SVD ordena decrescente).",
                                    "Identifique σ_min como o menor valor não-zero em S (último elemento > 1e-12).",
                                    "Crie uma lista ou array dos valores singulares ordenados.",
                                    "Plote os valores singulares (opcional: usando matplotlib) para visualização.",
                                    "Registre o rank aproximado contando σ > tolerância."
                                  ],
                                  "verification": "σ_max >= todos σ_i >= σ_min > 0 e lista corresponde a S.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "NumPy",
                                    "Matplotlib opcional para plot",
                                    "Resultados do Step 2"
                                  ],
                                  "tips": "Sempre ordene S decrescente; ignore σ=0 para condicional numérico.",
                                  "learningObjective": "Extrair σ_max e σ_min corretamente de SVD para análise de condição.",
                                  "commonMistakes": [
                                    "Usar σ_min=0 para matrizes rank-deficient",
                                    "Não filtrar zeros numéricos",
                                    "Confundir S com diagonal explícita"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular o Número de Condição e Avaliar Sensibilidade",
                                  "subSteps": [
                                    "Compute cond_2(A) = σ_max / σ_min.",
                                    "Interprete o valor: cond < 10^3 bem condicionado; >10^6 mal condicionado.",
                                    "Compare com cond_2 via norma (opcional: np.linalg.cond(A)).",
                                    "Teste perturbação em b e verifique teorema de sensibilidade.",
                                    "Documente interpretação em relatório curto."
                                  ],
                                  "verification": "cond_2 calculado bate com np.linalg.cond(A, p=2) dentro de tolerância.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código anterior",
                                    "NumPy para np.linalg.cond",
                                    "Exemplo de vetor b"
                                  ],
                                  "tips": "Use log10(cond) para escala; teste com A perturbada para validar.",
                                  "learningObjective": "Calcular cond_2(A) via SVD e relacionar à sensibilidade de sistemas lineares.",
                                  "commonMistakes": [
                                    "Dividir por σ=0",
                                    "Ignorar escala da matriz",
                                    "Confundir cond_1 com cond_2"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = np.array([[1, 1], [1, 1.0001]]), SVD dá σ ≈ [1.4143, 0.000707]; cond_2(A) ≈ 2000, indicando sensibilidade alta a perturbações em b.",
                              "finalVerifications": [
                                "Computa SVD corretamente com reconstrução precisa.",
                                "Identifica σ_max e σ_min excluindo zeros numéricos.",
                                "Calcula cond_2(A) = σ_max / σ_min com precisão.",
                                "Valida com np.linalg.cond(A).",
                                "Interpreta sensibilidade corretamente (ex: cond grande → instável).",
                                "Aplica a uma matriz de teste com perturbação em b."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica do SVD e reconstrução (<1e-10 erro).",
                                "Correta extração de σ_max/σ_min (sem divisão por zero).",
                                "Cálculo exato de cond_2 e comparação com função built-in.",
                                "Interpretação qualitativa da sensibilidade.",
                                "Código limpo, comentado e reproduzível.",
                                "Tratamento de casos edge (rank-deficient)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica (Python/NumPy para álgebra linear).",
                                "Análise Numérica (estabilidade e erros de arredondamento).",
                                "Engenharia Computacional (simulações finitas em mecânica).",
                                "Machine Learning (análise de covariância em PCA/SVD).",
                                "Física Computacional (sensibilidade em equações diferenciais)."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, avalia sensibilidade de sistemas lineares em controle de voo; em ML, detecta multicolinearidade em dados para evitar overfitting; em finanças, analisa estabilidade de modelos de risco."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.3.3",
                            "name": "Interpretar sensibilidade em exemplos",
                            "description": "Analisar numericamente um sistema Ax = b com perturbação em b, computar erros observados vs. bound teórico usando Golub & Van Loan.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o sistema linear original Ax = b",
                                  "subSteps": [
                                    "Selecione uma matriz A quadrada n x n (ex: 3x3 mal condicionada, como matriz de Hilbert truncada).",
                                    "Escolha um vetor b compatível e compute a solução exata x (usando inversa ou solver exato se possível).",
                                    "Verifique a consistência do sistema e compute normas iniciais: ||x||_2 e ||b||_2.",
                                    "Documente todos os valores com precisão numérica alta (mínimo 10 casas decimais).",
                                    "Salve os dados em um ambiente computacional (Python/MATLAB)."
                                  ],
                                  "verification": "Confirme que Ax = b exatamente (erro < 1e-12) e normas calculadas corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "MATLAB",
                                    "Papel e calculadora para matrizes pequenas"
                                  ],
                                  "tips": "Use matrizes clássicas mal condicionadas como A = [[1,1,1],[1,2,4],[1,4,10]] para demonstrar sensibilidade.",
                                  "learningObjective": "Preparar um exemplo numérico controlado para análise de sensibilidade.",
                                  "commonMistakes": [
                                    "Escolher A bem condicionada (cond(A) < 10), perdendo efeito de sensibilidade.",
                                    "Usar precisão baixa desde o início.",
                                    "Não normalizar normas adequadamente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o número de condição cond(A)",
                                  "subSteps": [
                                    "Compute os valores singulares de A via SVD: A = U Σ V^T.",
                                    "Identifique σ_max e σ_min (primeiro e último valores singulares).",
                                    "Calcule cond_2(A) = σ_max / σ_min.",
                                    "Compare com cond_∞ ou outras normas se relevante (ver Golub & Van Loan, Seção 2.5).",
                                    "Registre o valor exato e interprete qualitativamente (alto cond indica sensibilidade)."
                                  ],
                                  "verification": "Verifique cond(A) > 100 para exemplo sensível; valide com função built-in como np.linalg.cond().",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python NumPy.linalg.svd",
                                    "MATLAB svd()",
                                    "Referência: Golub & Van Loan Cap. 2"
                                  ],
                                  "tips": "Sempre use norma 2 para consistência com teorema de sensibilidade.",
                                  "learningObjective": "Dominar o cálculo e interpretação do número de condição como medida de sensibilidade.",
                                  "commonMistakes": [
                                    "Confundir cond(A) com det(A) ou trace.",
                                    "Ignorar normas consistentes.",
                                    "Não usar SVD para precisão."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir perturbação δb e resolver sistema perturbado",
                                  "subSteps": [
                                    "Gere δb com ||δb||_2 / ||b||_2 = ε pequeno (ex: 1e-6).",
                                    "Compute b' = b + δb.",
                                    "Resolva Ax' = b' numericamente para obter x' (usando solver estável como lu_factor).",
                                    "Calcule δx = x' - x.",
                                    "Documente todos os vetores com precisão."
                                  ],
                                  "verification": "Confirme ||A δx - δb||_2 < 1e-12 (residuo pequeno).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python SciPy.linalg.solve",
                                    "MATLAB backslash operator",
                                    "Gerador de ruído aleatório"
                                  ],
                                  "tips": "Escolha δb aleatório unitário escalado por ε para realismo.",
                                  "learningObjective": "Simular perturbações realistas em dados de entrada.",
                                  "commonMistakes": [
                                    "Perturbar A em vez de b.",
                                    "Usar solver instável como inversa direta.",
                                    "ε muito grande (>1e-3)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar erros relativos observados",
                                  "subSteps": [
                                    "Calcule erro relativo em b: rel_err_b = ||δb||_2 / ||b||_2.",
                                    "Calcule erro relativo em x: rel_err_x = ||δx||_2 / ||x||_2.",
                                    "Registre ambos com notação científica.",
                                    "Compare amplificação: rel_err_x / rel_err_b.",
                                    "Plote graficamente se possível (log-log de ε vs erros)."
                                  ],
                                  "verification": "rel_err_x ≈ cond(A) * rel_err_b dentro de fator 2-5.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "NumPy norm()",
                                    "Matplotlib para plots",
                                    "Planilha Excel alternativa"
                                  ],
                                  "tips": "Use log10 para visualizar ordens de magnitude.",
                                  "learningObjective": "Quantificar numericamente a propagação de erros.",
                                  "commonMistakes": [
                                    "Usar norma absoluta em vez de relativa.",
                                    "Dividir por zero (||x||=0).",
                                    "Normas inconsistentes."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar com bound teórico e interpretar",
                                  "subSteps": [
                                    "Recall bound de Golub & Van Loan: ||δx||/||x|| ≤ cond(A) * ||δb||/||b|| / (1 - cond(A)*||δb||/||b||) ≈ cond(A) * rel_err_b se pequeno.",
                                    "Compute bound superior teórico.",
                                    "Verifique se rel_err_x ≤ bound.",
                                    "Interprete: se próximo ao bound, sistema muito sensível; discuta implicações.",
                                    "Escreva relatório com conclusões."
                                  ],
                                  "verification": "Relatório mostra comparação quantitativa e interpretação qualitativa correta.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Referência Golub & Van Loan (equação 5.2.10 ou similar)",
                                    "Editor de texto"
                                  ],
                                  "tips": "Aproximação linear válida para perturbações pequenas.",
                                  "learningObjective": "Interpretar numericamente o teorema de sensibilidade.",
                                  "commonMistakes": [
                                    "Ignorar termo de segunda ordem no bound exato.",
                                    "Concluir insensibilidade se cond baixo.",
                                    "Não relacionar ao contexto prático."
                                  ]
                                }
                              ],
                              "practicalExample": "A = [[1, 1, 1], [1, 2, 4], [1, 4, 10]] (cond_2(A) ≈ 5.2e4), b = [4, 9, 21]^T, x = [1,2,3]^T exato. δb = 1e-6 * [0.1, 0.2, 0.3]^T normalizado. Compute x', erros e compare com bound ≈ 5.2e4 * 1e-6.",
                              "finalVerifications": [
                                "Erro relativo em x está dentro do bound teórico por fator <10.",
                                "Número de condição calculado corretamente via SVD.",
                                "Resíduos dos sistemas resolvidos <1e-12.",
                                "Interpretação correta: alto cond amplifica erros em b.",
                                "Gráfico ou tabela mostra amplificação observada vs teórica.",
                                "Relatório discute limitações da aproximação linear."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica em todos cálculos (erro <1e-10).",
                                "Uso correto de normas 2 e SVD.",
                                "Comparação quantitativa clara (tabelas/números).",
                                "Interpretação qualitativa alinhada ao teorema.",
                                "Documentação completa com código/reprodutível.",
                                "Identificação de fontes de erro numérico."
                              ],
                              "crossCurricularConnections": [
                                "Computação Científica: Implementação de SVD e solvers em Python/MATLAB.",
                                "Análise Numérica: Estudo de estabilidade e arredondamento.",
                                "Estatística: Sensibilidade em regressão linear (A=X).",
                                "Engenharia: Análise de erros em simulações finitas.",
                                "Física Computacional: Perturbações em equações de equilíbrio."
                              ],
                              "realWorldApplication": "Em modelagem de circuitos elétricos, pequenas imprecisões em medições de correntes (b) podem causar grandes erros nas tensões calculadas (x) se a matriz de admitância (A) for mal condicionada devido a geometria complexa, guiando decisões de refinamento de malha."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.3.4",
                            "name": "Comparar com outras decomposições",
                            "description": "Discutir como QR ou outras fatorizações auxiliam na avaliação indireta do condicionamento para sensibilidade em b.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos de sensibilidade a perturbações em b e número de condição",
                                  "subSteps": [
                                    "Relembrar o Teorema de Sensibilidade: δx / ||x|| ≤ κ(A) * (δb / ||b||).",
                                    "Explicar que κ(A) = ||A|| * ||A^{-1}|| mede a sensibilidade relativa.",
                                    "Diferenciar avaliação direta (computar κ exato) de indireta (usar decomposições).",
                                    "Discutir limitações da avaliação direta devido a erros numéricos.",
                                    "Estudar exemplos simples de matrizes bem e mal condicionadas."
                                  ],
                                  "verification": "Escrever um resumo de 100 palavras explicando a relação entre κ(A) e sensibilidade em b.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre Álgebra Linear",
                                    "Calculadora ou Python/MATLAB para exemplos numéricos"
                                  ],
                                  "tips": "Use normas consistentes (ex: norma 2) para evitar confusões.",
                                  "learningObjective": "Compreender a base teórica da sensibilidade a b e o papel central do número de condição.",
                                  "commonMistakes": "Confundir sensibilidade a perturbações em A com as em b; ignorar a dependência relativa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a decomposição QR para avaliação indireta do condicionamento",
                                  "subSteps": [
                                    "Realizar decomposição QR de A = QR, onde Q é ortogonal e R triangular superior.",
                                    "Examinar os elementos diagonais de R: |R_{ii}| aproximam valores singulares de A.",
                                    "Estimar κ(A) ≈ |R_{11}| / |R_{nn}| ou produto dos |R_{ii}| para insights sobre condicionamento.",
                                    "Aplicar a uma matriz exemplo e perturbar b para validar a sensibilidade prevista.",
                                    "Comparar precisão da estimativa QR com o κ exato."
                                  ],
                                  "verification": "Computar QR para uma matriz 3x3 e estimar κ; verificar com norma exata.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software numérico (Python com numpy/scipy ou MATLAB)",
                                    "Matriz de exemplo mal-condicionada"
                                  ],
                                  "tips": "Escolha pivotação em QR para estabilidade numérica.",
                                  "learningObjective": "Dominar como QR fornece estimativa indireta acessível de κ(A) para sensibilidade em b.",
                                  "commonMistakes": "Ignorar que QR sem pivotação pode falhar em matrizes mal-condicionadas; superestimar precisão da aproximação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar outras decomposições (LU, Cholesky, SVD) para comparação",
                                  "subSteps": [
                                    "Descrever decomposição LU: A = LU, e como max(|U_{ii}| / min(|U_{ii}|)) estima κ.",
                                    "Analisar Cholesky para matrizes simétricas positivas definidas: κ ≈ λ_max / λ_min via R.",
                                    "Estudar SVD: A = UΣV^T, onde κ(A) = σ_1 / σ_n exatamente.",
                                    "Comparar custos computacionais: QR O(n^3), SVD mais caro O(n^3) mas preciso.",
                                    "Testar cada uma em um exemplo comum para sensibilidade em b."
                                  ],
                                  "verification": "Listar prós e contras de cada decomposição em uma tabela.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software numérico",
                                    "Exemplos de matrizes de diferentes tipos"
                                  ],
                                  "tips": "Priorize SVD para precisão, mas QR para eficiência em grandes matrizes.",
                                  "learningObjective": "Identificar como cada decomposição auxilia na avaliação indireta de κ(A).",
                                  "commonMistakes": "Aplicar Cholesky a matrizes não simétricas; confundir estimativas com valores exatos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar decomposições e discutir aplicações práticas",
                                  "subSteps": [
                                    "Comparar precisão: SVD > QR > LU em geral para κ.",
                                    "Avaliar estabilidade numérica e requisitos (ortogonalidade em QR vs. triangular em LU).",
                                    "Discutir cenários: QR para sistemas grandes, SVD para análise detalhada.",
                                    "Analisar impacto na sensibilidade em b via exemplos numéricos comparativos.",
                                    "Concluir com recomendações baseadas em contexto (tamanho da matriz, simetria)."
                                  ],
                                  "verification": "Redigir um parágrafo comparativo destacando quando usar cada uma.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabelas comparativas preparadas",
                                    "Resultados dos passos anteriores"
                                  ],
                                  "tips": "Use gráficos de resíduos para visualizar sensibilidade.",
                                  "learningObjective": "Sintetizar vantagens e desvantagens para escolha informada.",
                                  "commonMistakes": "Super-generalizar: QR não é sempre melhor que LU para matrizes bem condicionadas."
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 1], [1, 1+ε]] com ε=10^{-6} (mal-condicionada). Compute QR: R diagonais mostram disparidade. Perturbe b = [1,1] em 1% e observe ||δx||/||x|| ≈ κ estimado por QR. Compare com SVD exato e LU para validar sensibilidade em b.",
                              "finalVerifications": [
                                "Explicar com precisão como QR estima κ(A) via diagonais de R.",
                                "Comparar corretamente QR, LU e SVD em termos de precisão e custo.",
                                "Aplicar a um exemplo numérico e prever sensibilidade em b.",
                                "Identificar cenários onde uma decomposição é preferível.",
                                "Discutir limitações da avaliação indireta.",
                                "Resumir em tabela prós/contras de cada método."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual sobre sensibilidade e κ(A) (25%)",
                                "Correta descrição e aplicação de QR para estimativa (20%)",
                                "Análise comparativa detalhada com outras decomposições (25%)",
                                "Uso de exemplos numéricos válidos e verificações (15%)",
                                "Clareza na síntese de recomendações práticas (10%)",
                                "Identificação de erros comuns e limitações (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Computação: Algoritmos numéricos e estabilidade em programação científica.",
                                "Física: Análise de estabilidade em modelagem de sistemas dinâmicos.",
                                "Engenharia: Avaliação de erros em simulações CFD e estruturas.",
                                "Estatística: Condicionamento em regressão linear múltipla."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, decomposições como QR são usadas para avaliar indiretamente a sensibilidade de soluções de sistemas lineares em simulações de fluxo (CFD), garantindo que pequenas perturbações em dados de entrada (b) não causem erros catastróficos em predições de forças aerodinâmicas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.3",
                    "name": "Sensibilidade a Perturbações em A",
                    "description": "Estudo do efeito de pequenas variações na matriz A sobre a solução do sistema linear.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.3.1",
                        "name": "Número de Condição da Matriz",
                        "description": "O número de condição cond(A) = ||A|| · ||A^{-1}|| quantifica a sensibilidade da solução de Ax = b a perturbações relativas na matriz A, medindo a amplificação máxima de erros.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.1.1",
                            "name": "Definir e calcular o número de condição",
                            "description": "Explicar a definição formal de cond(A) para normas induzidas (como norma 2, 1 ou ∞) e computar cond(A) para matrizes numéricas pequenas usando software ou manualmente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição formal do número de condição",
                                  "subSteps": [
                                    "Estude a definição: cond(A) = ||A|| * ||A^{-1}|| para uma norma induzida ||.||",
                                    "Entenda que cond(A) mede a sensibilidade de Ax=b a perturbações em A",
                                    "Revise propriedades: cond(A) >= 1, cond(I)=1, cond(kA)=cond(A)",
                                    "Analise o teorema de condicionamento: ||δx||/||x|| <= cond(A) * ||δA||/||A||",
                                    "Discuta interpretação: valores altos indicam problemas numéricos"
                                  ],
                                  "verification": "Escreva a definição e explique em suas palavras o significado de cond(A)=10",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear Numérica (ex: Golub-Van Loan)",
                                    "Notas de aula sobre sensibilidade"
                                  ],
                                  "tips": "Lembre-se: cond(A) amplifica erros relativos em A para erros em x",
                                  "learningObjective": "Definir formalmente cond(A) e interpretar seu valor",
                                  "commonMistakes": [
                                    "Confundir com determinante",
                                    "Ignorar que requer A invertível",
                                    "Esquecer multiplicação das normas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar normas induzidas (1, 2 e ∞)",
                                  "subSteps": [
                                    "Defina norma vetorial: ||x||_1 = sum |x_i|, ||x||_∞ = max |x_i|, ||x||_2 = sqrt(x^T x)",
                                    "Norma de matriz induzida: ||A||_p = sup_{x≠0} ||Ax||_p / ||x||_p",
                                    "Fórmulas explícitas: ||A||_1 = max_j sum_i |a_ij|, ||A||_∞ = max_i sum_j |a_ij|",
                                    "Para ||A||_2: valores singulares máximos (sigma_max)",
                                    "Pratique cálculo para vetores e matrizes 2x2"
                                  ],
                                  "verification": "Calcule ||A||_1 e ||A||_∞ para A = [[1,2],[3,4]]",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora ou papel para contas manuais",
                                    "Tabela de fórmulas de normas"
                                  ],
                                  "tips": "Use propriedades de submultiplicatividade: ||AB|| <= ||A|| ||B||",
                                  "learningObjective": "Calcular normas induzidas 1, 2 e ∞ para matrizes",
                                  "commonMistakes": [
                                    "Confundir colunas e linhas em normas 1/∞",
                                    "Usar norma euclidiana diretamente sem sigma_max para ||.||_2",
                                    "Esquecer normalização por ||x||"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular inversa e normas para matrizes pequenas",
                                  "subSteps": [
                                    "Para matriz 2x2 A = [[a,b],[c,d]], compute A^{-1} = 1/det(A) * [[d,-b],[-c,a]]",
                                    "Calcule ||A|| e ||A^{-1}|| usando a norma escolhida (ex: norma ∞)",
                                    "Verifique A * A^{-1} = I para confirmar inversa",
                                    "Discuta singularidade: se det(A)=0, cond(A)=∞",
                                    "Repita para norma 1 e compare valores"
                                  ],
                                  "verification": "Para A = [[1,1],[1,2]], calcule A^{-1}, ||A||_∞ e ||A^{-1}||_∞",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software como MATLAB ou Python (opcional)"
                                  ],
                                  "tips": "Escolha norma ∞ para cálculos manuais simples (máximos de somas)",
                                  "learningObjective": "Computar ||A|| e ||A^{-1}|| manualmente",
                                  "commonMistakes": [
                                    "Erro no sinal da inversa 2x2",
                                    "Dividir por det(A)=0",
                                    "Confundir ||A|| com ||A^T||"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar cond(A) e validar com software",
                                  "subSteps": [
                                    "Calcule cond(A) = ||A|| * ||A^{-1}|| para o exemplo",
                                    "Use Python (numpy.linalg.cond(A, p)) ou MATLAB cond(A,p) para norma p=1,2,inf",
                                    "Compare resultados manuais vs software (tolerância numérica)",
                                    "Analise: se cond(A)>10^6, considere ill-condicionada",
                                    "Teste com matriz mal-condicionada como Hilbert 4x4"
                                  ],
                                  "verification": "Execute código e confirme cond(A_2x2) ≈ valor manual",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python com numpy",
                                    "Jupyter Notebook ou MATLAB"
                                  ],
                                  "tips": "Para norma 2, use svd: cond_2 = sigma_max / sigma_min",
                                  "learningObjective": "Calcular cond(A) manual e computacionalmente",
                                  "commonMistakes": [
                                    "Ignorar precisão flutuante em software",
                                    "Usar p errado em cond(A,p)",
                                    "Confundir cond_2 com trace"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 1], [1, 2]] (norma ∞). Inversa A^{-1} = [[-2, 1], [1, 1]]. ||A||_∞ = 3, ||A^{-1}||_∞ = 3, cond(A) = 9. Interpretação: erros em A amplificados até 9x em x.",
                              "finalVerifications": [
                                "Define corretamente cond(A) para norma induzida",
                                "Calcula ||A||_∞ e ||A||_1 para matriz 2x2 dada",
                                "Computa inversa exata e cond(A) manualmente",
                                "Valida com software (numpy/MATLAB) com erro <1e-10",
                                "Explica por que cond(A)=1 para matrizes ortogonais",
                                "Identifica matriz ill-condicionada (cond>10^8)"
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos manuais (erro zero)",
                                "Correta interpretação conceitual de sensibilidade",
                                "Uso adequado de software com código comentado",
                                "Análise qualitativa de resultados (alto/baixo cond)",
                                "Clareza na explicação de fórmulas e passos",
                                "Identificação de erros numéricos potenciais"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em NumPy/SciPy para análise numérica",
                                "Física: Estabilidade em simulações dinâmicas (ex: equações diferenciais)",
                                "Engenharia: Análise de estruturas (matrizes de rigidez)",
                                "Estatística: Condicionamento em regressão linear",
                                "Ciência de Dados: Pré-processamento de features em ML"
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, verifica se matrizes de coeficientes em simulações CFD são bem-condicionadas para evitar erros catastróficos em predições de fluxo; em ML, avalia estabilidade de inversão de covariâncias em Gaussian Processes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.2",
                            "name": "Interpretar valores do número de condição",
                            "description": "Analisar o impacto de cond(A) pequeno (≈1, bem condicionado) versus grande (>10^6, il-condicionado) na precisão numérica da solução e prever perda de dígitos significativos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito fundamental do número de condição",
                                  "subSteps": [
                                    "Defina o número de condição cond(A) = ||A|| × ||A⁻¹|| para uma matriz invertível A.",
                                    "Explique o significado intuitivo: mede o fator de amplificação de erros relativos na solução de Ax = b.",
                                    "Discuta normas comuns usadas (ex: norma 2, norma Frobenius) e sua importância na interpretação.",
                                    "Relacione cond(A) com os valores singulares: cond₂(A) = σ_max / σ_min.",
                                    "Identifique que cond(A) ≥ 1 sempre, com igualdade para matrizes ortogonais."
                                  ],
                                  "verification": "Escreva a definição exata de cond(A) e explique seu significado em uma frase clara.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Álgebra Numérica (ex: Golub-Van Loan)",
                                    "Software MATLAB ou Python com NumPy"
                                  ],
                                  "tips": "Use exemplos simples como matriz identidade para fixar o conceito.",
                                  "learningObjective": "Dominar a definição e interpretação básica do número de condição.",
                                  "commonMistakes": [
                                    "Confundir cond(A) com det(A)",
                                    "Achar que cond(A) < 1 é possível",
                                    "Ignorar a dependência da norma"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar matrizes bem condicionadas (cond(A) ≈ 1)",
                                  "subSteps": [
                                    "Calcule cond(A) para A identidade: cond(I) = 1.",
                                    "Analise o impacto em Ax = b: perturbações em A ou b são amplificadas por fator ≈1.",
                                    "Simule numericamente: resolva sistema com ruído pequeno e observe estabilidade.",
                                    "Compare com matrizes ortogonais (ex: rotações), onde cond ≈1 garante precisão máxima.",
                                    "Conclua que sistemas bem condicionados mantêm precisão numérica próxima da máquina."
                                  ],
                                  "verification": "Demonstre com exemplo numérico que erro relativo na solução ≈ erro no dado para cond≈1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python/Jupyter Notebook com NumPy e SciPy",
                                    "Matriz identidade 3x3"
                                  ],
                                  "tips": "Sempre normalize os dados para evitar confusões com escalas.",
                                  "learningObjective": "Reconhecer e exemplificar estabilidade em matrizes bem condicionadas.",
                                  "commonMistakes": [
                                    "Subestimar que cond=1 é o ideal absoluto",
                                    "Não testar numericamente",
                                    "Confundir com simétricas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar matrizes il-condicionadas (cond(A) > 10⁶)",
                                  "subSteps": [
                                    "Gere exemplo de matriz mal condicionada (ex: matriz de Hilbert 5x5, cond≈10¹²).",
                                    "Calcule cond(A) usando função pronta (numpy.linalg.cond).",
                                    "Simule perturbação δA pequena (10^{-10}) e observe amplificação no erro da solução.",
                                    "Discuta limiares práticos: cond>10³ problemático, >10⁶ catastrófico em precisão dupla.",
                                    "Explique geometricamente: elipsoide de singular values muito achatado."
                                  ],
                                  "verification": "Mostre que para cond>10⁶, solução numérica diverge mesmo com entrada exata.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código Python para matriz Hilbert",
                                    "Calculadora de cond(A)"
                                  ],
                                  "tips": "Use precisão dupla e compare com exata para visualizar perda.",
                                  "learningObjective": "Identificar e quantificar instabilidade em matrizes il-condicionadas.",
                                  "commonMistakes": [
                                    "Usar matrizes grandes sem computar cond primeiro",
                                    "Ignorar overflow/underflow",
                                    "Achar que singular é o único caso ruim"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Prever perda de dígitos significativos e impacto na precisão",
                                  "subSteps": [
                                    "Lembre a estimativa: dígitos perdidos ≈ log₁₀(cond(A)).",
                                    "Para cond=10⁶, preveja perda de 6 dígitos (de 16 em double para 10 úteis).",
                                    "Aplique fórmula de bound: ||δx||/||x|| ≤ cond(A) × (||δA||/||A|| + ||δb||/||b||).",
                                    "Teste em exemplo: resolva Ax=b com ruído máquina e conte dígitos precisos.",
                                    "Discuta mitigação: refatoração, preconditioning ou métodos iterativos."
                                  ],
                                  "verification": "Calcule e preveja corretamente perda de dígitos para cond=10^k, k=1 a 8.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou script para log10(cond)",
                                    "Exemplos de sistemas lineares"
                                  ],
                                  "tips": "Sempre relacione com ε_machine ≈ 2×10^{-16} para double.",
                                  "learningObjective": "Quantificar perda de precisão e prever estabilidade numérica.",
                                  "commonMistakes": [
                                    "Esquecer log10 (usar ln)",
                                    "Não considerar norma relativa",
                                    "Superestimar precisão em teoria"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 1], [1, 1+10^{-6}]] (cond(A)≈10^6). Resolva Ax=b com b=[1,1]^T exato. Perturbe b em 10^{-10}: solução bem cond. fica estável, mas aqui perde ~6 dígitos, ilustrando amplificação de erro.",
                              "finalVerifications": [
                                "Explique verbalmente diferença entre cond≈1 e cond>10^6 com exemplo.",
                                "Calcule cond para matriz dada e classifique (bem/il-condicionada).",
                                "Preveja dígitos perdidos para cond=10^4 e valide numericamente.",
                                "Simule sistema il-condicionado e mostre instabilidade.",
                                "Descreva bound de erro para perturbação em A."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e fórmula de cond(A) (30%)",
                                "Correta interpretação qualitativa de valores pequenos/grandes (25%)",
                                "Cálculo e previsão quantitativa de perda de precisão (20%)",
                                "Uso de exemplos numéricos válidos e verificados (15%)",
                                "Clareza na explicação de impactos na solução (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementar cond() em NumPy/Python para análise de dados.",
                                "Física: Modelagem de sistemas dinâmicos onde A é matriz de rigidez.",
                                "Estatística: Regressão linear múltipla e multicolinearidade (cond alta).",
                                "Engenharia: Análise finita de elementos com meshes mal condicionadas."
                              ],
                              "realWorldApplication": "Em simulações de engenharia aeroespacial, matrizes de discretização CFD podem ter cond>10^9, causando perda de precisão em predições de fluxo; interpretar cond guia refatoração para evitar falhas em projetos reais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.3",
                            "name": "Computar cond(A) via decomposição SVD",
                            "description": "Utilizar a decomposição em valores singulares (SVD) para obter cond_2(A) = σ_max / σ_min e relacionar com a sensibilidade espectral da matriz.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos da decomposição SVD",
                                  "subSteps": [
                                    "Defina SVD como A = U Σ V^T, onde U e V são ortogonais e Σ é diagonal com valores singulares σ_i ≥ 0.",
                                    "Explique que os valores singulares σ_1 ≥ σ_2 ≥ ... ≥ σ_r > 0 representam 'autovalores' das raízes quadradas de AA^T e A^T A.",
                                    "Relacione cond_2(A) = σ_max / σ_min com a norma 2 da matriz.",
                                    "Discuta propriedades: cond(A) ≥ 1, cond(A) = 1 se A ortogonal.",
                                    "Estude o teorema de Eckart-Young para aproximações."
                                  ],
                                  "verification": "Resuma verbalmente ou por escrito os componentes da SVD e a fórmula de cond_2(A).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear Computacional (ex: Golub-Van Loan)",
                                    "Notas de aula sobre SVD",
                                    "Calculadora simbólica como SymPy"
                                  ],
                                  "tips": "Visualize U e V como rotações; Σ como escalas.",
                                  "learningObjective": "Compreender a estrutura matemática da SVD e sua relação direta com o número de condição.",
                                  "commonMistakes": [
                                    "Confundir valores singulares com autovalores",
                                    "Ignorar ordenação decrescente dos σ_i",
                                    "Esquecer que σ_min pode ser zero para matrizes singulares"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar decomposição SVD de uma matriz exemplo",
                                  "subSteps": [
                                    "Escolha uma matriz A 2x2 ou 3x3 não singular, ex: A = [[3, 1], [1, 3]].",
                                    "Use software numérico (Python numpy.linalg.svd ou MATLAB svd) para computar U, Σ, V.",
                                    "Verifique a reconstrução: recomponha A' = U @ Σ @ V.T e compare com A (erro < 1e-10).",
                                    "Extraia o vetor de valores singulares s = diag(Σ).",
                                    "Ordene s em ordem decrescente se necessário."
                                  ],
                                  "verification": "Execute o código e confirme ||A - UΣV^T||_2 < 1e-12.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Jupyter Notebook",
                                    "Matriz exemplo impressa"
                                  ],
                                  "tips": "Use full_matrices=False para economia computacional em matrizes retangulares.",
                                  "learningObjective": "Executar SVD computacionalmente e validar a decomposição.",
                                  "commonMistakes": [
                                    "Não verificar reconstrução",
                                    "Confundir compute_uv=True flags",
                                    "Usar svdvals em vez de svd para Σ completa"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o número de condição cond_2(A)",
                                  "subSteps": [
                                    "Identifique σ_max = s[0] e σ_min = s[-1] do vetor de valores singulares.",
                                    "Compute cond_2(A) = σ_max / σ_min (use np.max(s)/np.min(s) em código).",
                                    "Considere casos especiais: se σ_min ≈ 0, cond(A) → ∞ (matriz il-condicionada).",
                                    "Compare com cond(A) via norma 2 direta (np.linalg.cond(A, 2)).",
                                    "Registre o valor e classifique: cond < 10^3 (bem-condicionada), >10^6 (il-condicionada)."
                                  ],
                                  "verification": "Confirme que cond via SVD == cond via função built-in (erro relativo < 1e-10).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código Python do Step 2",
                                    "Documentação NumPy linalg.cond"
                                  ],
                                  "tips": "Evite divisão por zero: if σ_min == 0, cond = inf.",
                                  "learningObjective": "Extrair σ_max e σ_min para calcular precisamente cond_2(A).",
                                  "commonMistakes": [
                                    "Usar σ médio em vez de min/max",
                                    "Confundir cond_1 (norma 1) com cond_2",
                                    "Ignorar precisão numérica em σ_min pequeno"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar cond(A) com sensibilidade espectral",
                                  "subSteps": [
                                    "Lembre: para Ax = b, ||δx||/||x|| ≤ cond(A) ||δA||/||A|| (teorema de sensibilidade).",
                                    "Explique sensibilidade espectral: perturbações em autovalores escalam por cond(A).",
                                    "Simule: adicione ruído εA a A, resolva sistemas e meça amplificação de erro.",
                                    "Discuta implicações: alto cond(A) amplifica erros de arredondamento em solvers.",
                                    "Conclua: SVD é método robusto para cond(A) em álgebra numérica."
                                  ],
                                  "verification": "Simule perturbação e demonstre amplificação proporcional a cond(A).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código de simulação em Python",
                                    "Gráficos de erro vs. cond(A)"
                                  ],
                                  "tips": "Use np.random.randn para ruído; plote log(|δx|/|x|) vs log(|δA|/|A|).",
                                  "learningObjective": "Interpretar cond_2(A) via SVD no contexto de estabilidade numérica.",
                                  "commonMistakes": [
                                    "Confundir sensibilidade em A vs. b",
                                    "Subestimar erros de ponto flutuante",
                                    "Aplicar bounds sem normalização de normas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = np.array([[1, 2], [3, 4]]), SVD dá s ≈ [5.464, 0.365]. Então cond_2(A) ≈ 5.464 / 0.365 ≈ 14.97, indicando moderada il-condição. Simule δA = 1e-6 * A * np.random.randn(2,2); resolva (A+δA)x' = b vs Ax=b, observe ||x'-x||/||x|| ≈ 15 * ||δA||/||A||.",
                              "finalVerifications": [
                                "Decompor corretamente SVD de matriz 3x3 com erro de reconstrução <1e-12.",
                                "Calcular cond_2(A) via SVD coincidente com np.linalg.cond(A,2).",
                                "Classificar corretamente matrizes como bem-condicionadas (cond<10^3) ou il-condicionadas.",
                                "Simular perturbação e verificar bound de sensibilidade ||δx||/||x|| ≤ cond(A) ||δA||/||A||.",
                                "Explicar verbalmente relação SVD-cond-sensibilidade.",
                                "Aplicar em matriz retangular (m>n)."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erro em cond_2(A) < 1e-10.",
                                "Validação de reconstrução SVD: ||A - UΣV^T||_F / ||A||_F < 1e-12.",
                                "Correta identificação de σ_max/σ_min e handling de singularidade.",
                                "Interpretação qualitativa: impacto de cond em estabilidade (alto cond = sensível).",
                                "Simulação prática: gráfico demonstrando amplificação de erro.",
                                "Eficiência: uso correto de flags em svd para matrizes grandes."
                              ],
                              "crossCurricularConnections": [
                                "Programação Científica: Implementação em NumPy/SciPy ou MATLAB.",
                                "Análise Numérica: Estabilidade em solvers de equações lineares (LU, QR).",
                                "Machine Learning: Redução de dimensionalidade via SVD (PCA aproximada).",
                                "Engenharia de Controle: Análise de estabilidade em sistemas lineares.",
                                "Física Computacional: Modelagem de ruído em imagens/sinais."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, SVD computa cond(A) para matrizes de rigidez em FEM, detectando estruturas il-condicionadas sensíveis a fabricação; em ML, avalia estabilidade de features em regressão linear, evitando overfitting por amplificação de ruído."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.1.2",
                        "name": "Análise Perturbacional para Perturbações em A",
                        "description": "Estudo matemático do efeito de pequenas variações dA na matriz A sobre a solução x de Ax = b, com b fixo, incluindo aproximações e bounds rigorosos.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.1.2.1",
                            "name": "Derivar a aproximação de primeira ordem para dx",
                            "description": "Partir da equação (A + dA)(x + dx) = b, negligenciar termos quadráticos e obter dx ≈ -A^{-1} (dA x), com interpretação geométrica e algébrica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a equação linear original e introduzir a perturbação",
                                  "subSteps": [
                                    "Lembre-se da equação original: Ax = b, onde A é a matriz invertível.",
                                    "Introduza pequenas perturbações: A + dA na matriz e x + dx na solução.",
                                    "Escreva a equação perturbada: (A + dA)(x + dx) = b.",
                                    "Explique que dA e dx são perturbações infinitesimais.",
                                    "Discuta o contexto de análise perturbacional para sistemas lineares."
                                  ],
                                  "verification": "Escreva corretamente a equação perturbada sem erros tipográficos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Folha de papel",
                                    "Lápis",
                                    "Calculadora opcional para matrizes simples"
                                  ],
                                  "tips": "Visualize A como uma transformação linear e dA como um pequeno desvio.",
                                  "learningObjective": "Compreender a setup da perturbação em sistemas lineares.",
                                  "commonMistakes": [
                                    "Confundir dx com perturbação em b",
                                    "Esquecer que b permanece constante"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Expandir o produto da equação perturbada",
                                  "subSteps": [
                                    "Expanda (A + dA)(x + dx) usando distributividade: Ax + A dx + dA x + dA dx.",
                                    "Substitua Ax por b na expansão.",
                                    "Escreva a equação completa: b + A dx + dA x + dA dx = b.",
                                    "Simplifique subtraindo b de ambos os lados: A dx + dA x + dA dx = 0.",
                                    "Identifique os termos lineares e quadráticos na expansão."
                                  ],
                                  "verification": "Mostre a expansão completa com todos os quatro termos identificados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de papel",
                                    "Lápis"
                                  ],
                                  "tips": "Use notação matricial clara para evitar confusão com escalares.",
                                  "learningObjective": "Dominar a expansão algébrica de perturbações em equações lineares.",
                                  "commonMistakes": [
                                    "Esquecer o termo dA dx",
                                    "Não substituir Ax por b"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Negligenciar termos de segunda ordem e isolar dx",
                                  "subSteps": [
                                    "Reconheça que dA dx é um termo quadrático (produto de pequenas quantidades) e negligible para aproximação de primeira ordem.",
                                    "Aproxime: A dx + dA x ≈ 0.",
                                    "Reorganize: A dx ≈ - dA x.",
                                    "Multiplique ambos os lados por A^{-1} pela esquerda: dx ≈ - A^{-1} (dA x).",
                                    "Verifique a consistência da aproximação assumindo ||dA|| e ||dx|| pequenos."
                                  ],
                                  "verification": "Derive exatamente dx ≈ -A^{-1} (dA x) a partir da expansão simplificada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel",
                                    "Lápis",
                                    "Software de álgebra simbólica opcional como SymPy"
                                  ],
                                  "tips": "Pense em ordens de grandeza: termos quadráticos são o(ε²) onde ε é pequeno.",
                                  "learningObjective": "Aplicar a aproximação de primeira ordem negligenciando quadráticos.",
                                  "commonMistakes": [
                                    "Negligenciar o sinal negativo",
                                    "Inverter a ordem em A^{-1} (dA x)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar geometricamente e algebricamente a aproximação",
                                  "subSteps": [
                                    "Interpretação algébrica: dx é a correção na solução devido à perturbação dA aplicada a x.",
                                    "Interpretação geométrica: A^{-1} transforma o 'erro' dA x de volta ao espaço da solução.",
                                    "Visualize: perturbação em A desloca o hiperplano Ax=b, e dx corrige para o novo hiperplano.",
                                    "Discuta o papel do condicionamento de A na magnitude de dx.",
                                    "Compare com a fórmula exata para validar a aproximação."
                                  ],
                                  "verification": "Explique em palavras a interpretação geométrica e forneça um diagrama simples 2D.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de papel para esboços geométricos",
                                    "Lápis coloridos para vetores"
                                  ],
                                  "tips": "Use exemplo 2D com retas para visualizar o deslocamento do hiperplano.",
                                  "learningObjective": "Conectar a derivação algébrica a intuições geométricas.",
                                  "commonMistakes": [
                                    "Ignorar o condicionamento de A",
                                    "Confundir interpretação com perturbação em b"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[2, 0], [0, 1]], x = [1, 1]^T, b = [2, 1]^T. Perturbe dA = [[0.01, 0], [0, 0]]^T. Calcule dx ≈ -A^{-1} (dA x) = -[[0.5, 0], [0, 1]] * [[0.01, 0], [0, 0]] * [1,1] = [-0.005, 0]^T. Verifique resolvendo o sistema perturbado numericamente.",
                              "finalVerifications": [
                                "Deriva corretamente dx ≈ -A^{-1} (dA x) partindo de (A + dA)(x + dx) = b.",
                                "Explica por que dA dx é negligenciado.",
                                "Fornece interpretação geométrica com diagrama 2D.",
                                "Aplica a fórmula em um exemplo numérico 2x2 com erro <1%.",
                                "Discute limitações da aproximação de primeira ordem.",
                                "Compara com solução exata para validar."
                              ],
                              "assessmentCriteria": [
                                "Precisão na expansão e simplificação algébrica (40%).",
                                "Correta derivação da fórmula final (20%).",
                                "Qualidade das interpretações geométrica e algébrica (20%).",
                                "Exemplo prático resolvido corretamente (10%).",
                                "Identificação de erros comuns e limitações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de erros em sistemas dinâmicos lineares (ex: equações de movimento).",
                                "Computação: Análise de condicionamento numérico e estabilidade em solvers lineares.",
                                "Engenharia: Sensibilidade em modelos de estruturas e controle.",
                                "Economia: Perturbações em modelos de equilíbrio linear."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, avalia sensibilidade de soluções de equilíbrio estrutural a pequenas variações em propriedades de materiais (dA), prevendo deslocamentos corretivos (dx) sem resolver sistemas grandes repetidamente."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.2.2",
                            "name": "Estabelecer o bound de erro relativo",
                            "description": "Provar que ||dx|| / ||x|| ≤ cond(A) · ||dA|| / ||A|| para normas compatíveis, destacando o papel amplificador do condicionamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o problema e estabelecer a notação",
                                  "subSteps": [
                                    "Considere o sistema linear exato: A x = b, onde A é uma matriz invertível e x é a solução exata.",
                                    "Introduza a perturbação em A: considere o sistema perturbado (A + dA)(x + dx) = b, assumindo b fixo.",
                                    "Defina o número de condição cond(A) = ||A|| ⋅ ||A⁻¹|| para normas de matriz e vetor compatíveis (ex.: norma 2 ou ∞).",
                                    "Estabeleça as quantidades relativas de interesse: erro relativo em x como ||dx|| / ||x|| e perturbação relativa em A como ||dA|| / ||A||.",
                                    "Lembre que normas devem ser submultiplicativas e indutoras."
                                  ],
                                  "verification": "Escreva corretamente as equações exata e perturbada, definindo cond(A) e os erros relativos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta, calculadora científica, referência de álgebra linear (ex.: livro de Strang).",
                                  "tips": "Escolha normas consistentes desde o início para evitar incompatibilidades posteriores.",
                                  "learningObjective": "Compreender o setup perturbacional e a notação essencial para análise de sensibilidade.",
                                  "commonMistakes": "Confundir perturbação em A com perturbação em b; esquecer que A deve ser invertível."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a equação residual para dx",
                                  "subSteps": [
                                    "Expanda a equação perturbada: A x + A dx + dA x + dA dx = b.",
                                    "Subtraia a equação exata A x = b: A dx + dA x + dA dx = 0.",
                                    "Reorganize: A dx = -dA (x + dx).",
                                    "Note que o termo dA dx é um produto de segunda ordem, pequeno se ||dA|| e ||dx|| forem pequenos."
                                  ],
                                  "verification": "Obtenha e escreva a equação A dx = -dA (x + dx), destacando o termo de segunda ordem.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel para derivações algébricas, quadro branco se disponível.",
                                  "tips": "Mantenha a forma matricial exata sem aproximar prematuramente.",
                                  "learningObjective": "Derivar a relação perturbacional exata entre dx e dA.",
                                  "commonMistakes": "Ignorar o termo dA dx, levando a uma aproximação prematura; errar o sinal na equação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar desigualdades de normas",
                                  "subSteps": [
                                    "Aplique a norma em ambos os lados: ||A dx|| ≤ ||dA|| ⋅ ||x + dx||.",
                                    "Use a desigualdade triangular: ||x + dx|| ≤ ||x|| + ||dx||.",
                                    "Multiplique ambos os lados por ||A⁻¹||: ||dx|| ≤ ||A⁻¹|| ⋅ ||dA|| ⋅ (||x|| + ||dx||).",
                                    "Divida por ||x||: ||dx|| / ||x|| ≤ cond(A) ⋅ (||dA|| / ||A||) ⋅ (1 + ||dx|| / ||x||)."
                                  ],
                                  "verification": "Escreva as desigualdades passo a passo, chegando à forma ε ≤ cond(A) δ (1 + ε), onde ε = ||dx||/||x|| e δ = ||dA||/||A||.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel para manipulações de normas, tabela de propriedades de normas.",
                                  "tips": "Verifique submultiplicatividade da norma em cada passo: ||AB|| ≤ ||A|| ||B||.",
                                  "learningObjective": "Dominar a aplicação de normas para obter bounds quantitativos.",
                                  "commonMistakes": "Esquecer de dividir por ||A|| ao definir δ; usar normas incompatíveis."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Isolar o bound de erro relativo e destacar o condicionamento",
                                  "subSteps": [
                                    "Denote ε = ||dx|| / ||x|| e δ = ||dA|| / ||A||: ε ≤ cond(A) δ (1 + ε).",
                                    "Reorganize: ε (1 - cond(A) δ) ≤ cond(A) δ, assim ε ≤ [cond(A) δ] / [1 - cond(A) δ] (para cond(A) δ < 1).",
                                    "Para perturbações pequenas (δ pequeno), o bound aproxima-se para ||dx|| / ||x|| ≤ cond(A) ⋅ ||dA|| / ||A||.",
                                    "Interprete: cond(A) atua como fator amplificador; se cond(A) >> 1, erros são amplificados.",
                                    "Conclua a prova destacando a dependência linear em δ e o papel crítico do condicionamento."
                                  ],
                                  "verification": "Escreva o bound final e explique verbalmente o papel amplificador de cond(A).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel para álgebra final, exemplos numéricos simples para ilustração.",
                                  "tips": "Teste com δ = 0 para verificar trivialidade (ε=0).",
                                  "learningObjective": "Estabelecer o bound relativo e compreender o impacto do número de condição.",
                                  "commonMistakes": "Negligenciar a condição cond(A) δ < 1 para validade do bound; confundir bound exato com aproximado."
                                }
                              ],
                              "practicalExample": "Considere A = [[2, 1], [1, 1]], x = [1, 0]^T, b = A x = [2, 1]^T. cond(A)_2 ≈ 3.414. Perturbe dA = 0.001 * [[0,1],[0,0]], resolva (A + dA) x_new = b para x_new ≈ [0.9995, -0.0005]^T, dx ≈ [-0.0005, -0.0005]^T. Verifique: ||dx||_2 / ||x||_2 ≈ 0.000707, cond(A) * ||dA||_2 / ||A||_2 ≈ 3.414 * 0.001 ≈ 0.0034 > 0.000707, confirmando o bound.",
                              "finalVerifications": [
                                "Deriva corretamente a equação A dx = -dA (x + dx).",
                                "Aplica normas para obter ε ≤ cond(A) δ (1 + ε).",
                                "Isola o bound relativo ||dx|| / ||x|| ≤ cond(A) ⋅ ||dA|| / ||A|| (aproximação).",
                                "Explica o papel amplificador do cond(A) com exemplo numérico.",
                                "Identifica condições para validade (normas compatíveis, cond(A) δ < 1)."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na derivação da equação residual (sem erros de sinal).",
                                "Correta aplicação de propriedades de normas (submultiplicatividade e triangular).",
                                "Manipulação correta para isolar ε e obter o bound final.",
                                "Interpretação qualitativa do condicionamento como amplificador de erros.",
                                "Uso consistente de notação e verificação com contraexemplo se cond ruim."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Estimação de erros de arredondamento em solvers lineares.",
                                "Programação Computacional: Implementação em Python (NumPy) para computar cond e simular perturbações.",
                                "Engenharia: Análise de sensibilidade em modelos finitos de elementos.",
                                "Estatística: Propagação de erros em regressão linear matricial."
                              ],
                              "realWorldApplication": "Em simulações de engenharia aeroespacial, matrizes de rigidez mal condicionadas (alto cond(A)) amplificam erros de medição em sensores, podendo levar a falhas estruturais; o bound guia o controle de precisão numérica e refatoração de modelos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.1.2.3",
                            "name": "Verificar o bound em casos numéricos",
                            "description": "Aplicar a fórmula em matrizes 2x2 ou 3x3 com perturbações aleatórias pequenas, computar erros exatos e aproximados e comparar com o bound teórico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e configurar o sistema linear original",
                                  "subSteps": [
                                    "Escolha uma matriz A invertível de dimensão 2x2 ou 3x3 com elementos reais (ex: diagonal dominante para estabilidade).",
                                    "Defina um vetor b compatível, resolvendo x = A^{-1} b para obter a solução exata x.",
                                    "Calcule a norma da matriz ||A|| (use norma 2 ou Frobenius).",
                                    "Calcule o número de condicionamento cond(A) = ||A|| * ||A^{-1}||.",
                                    "Documente todos os valores iniciais em uma tabela."
                                  ],
                                  "verification": "Verifique se Ax = b exatamente (erro numérico < 1e-10) e se cond(A) está computado corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora científica ou software como MATLAB/Python (NumPy)",
                                    "Papel e lápis para matrizes pequenas"
                                  ],
                                  "tips": "Comece com matrizes 2x2 para simplicidade; use funções prontas como np.linalg.cond() em Python.",
                                  "learningObjective": "Entender a configuração inicial de um sistema linear estável e computar métricas básicas de sensibilidade.",
                                  "commonMistakes": [
                                    "Escolher matriz singular (det(A)=0)",
                                    "Confundir normas (use consistentemente a mesma norma)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar perturbação aleatória pequena em A",
                                  "subSteps": [
                                    "Gere δA com elementos aleatórios uniformes em [-ε, ε], onde ε = 10^{-3} * ||A|| para perturbação relativa pequena.",
                                    "Normalize δA para que ||δA|| / ||A|| ≈ 10^{-3} ou menor.",
                                    "Crie a matriz perturbada Ã = A + δA.",
                                    "Repita o processo 3-5 vezes para múltiplas perturbações e médias estatísticas.",
                                    "Registre ||δA|| / ||A|| para cada instância."
                                  ],
                                  "verification": "Confirme que ||δA|| / ||A|| < 10^{-2} e Ã é invertível (det(Ã) ≠ 0).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python com NumPy (np.random.uniform)",
                                    "Planilha Excel para registro"
                                  ],
                                  "tips": "Use semente fixa para reprodutibilidade: np.random.seed(42).",
                                  "learningObjective": "Dominar a geração controlada de perturbações relativas pequenas e realistas.",
                                  "commonMistakes": [
                                    "Perturbações grandes demais (quebra o bound)",
                                    "Não normalizar para relativa"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver o sistema perturbado e calcular erro exato",
                                  "subSteps": [
                                    "Resolva Ã y = b para obter y (use decomposição LU ou QR para precisão).",
                                    "Calcule o erro absoluto: e = ||x - y|| e relativo: rel_err = ||x - y|| / ||x||.",
                                    "Repita para todas as perturbações e compute média e desvio padrão dos erros.",
                                    "Compare erros absolutos e relativos em uma tabela.",
                                    "Visualize com gráfico de barras (opcional)."
                                  ],
                                  "verification": "Erro relativo deve ser pequeno (< 10^{-2}) e consistente com ε.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software NumPy/SciPy (np.linalg.solve)",
                                    "Matplotlib para plots"
                                  ],
                                  "tips": "Evite inversão direta de matrizes; prefira solve() para estabilidade numérica.",
                                  "learningObjective": "Aplicar solvers numéricos e quantificar erros de aproximação em sistemas perturbados.",
                                  "commonMistakes": [
                                    "Usar inversão explícita (amplifica erros)",
                                    "Esquecer normalização relativa do erro"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar o bound teórico e realizar comparação",
                                  "subSteps": [
                                    "Aplique a fórmula do bound: rel_err ≤ cond(A) * (||δA|| / ||A||).",
                                    "Calcule o lado direito do bound para cada perturbação.",
                                    "Compare: verifique se rel_err ≤ bound em todos os casos.",
                                    "Calcule a razão bound / rel_err para quantificar quão conservador é o bound.",
                                    "Analise se o bound é atingido (próximo de 1) em casos bem condicionados."
                                  ],
                                  "verification": "Em todos os testes, rel_err ≤ bound teórico deve holding true.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código Python para automação",
                                    "Tabela comparativa"
                                  ],
                                  "tips": "Teste com matrizes mal condicionales (ex: Hilbert) para ver bound apertado.",
                                  "learningObjective": "Validar teoremas perturbacionais numericamente e interpretar discrepâncias.",
                                  "commonMistakes": [
                                    "Confundir cond(A) com cond(Ã)",
                                    "Não usar a mesma norma em todo o cálculo"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar resultados e generalizar",
                                  "subSteps": [
                                    "Resuma observações: bound conservador? Dependência em cond(A)?",
                                    "Teste com ε variando (10^{-4} a 10^{-1}) para ver linearidade.",
                                    "Discuta limitações (aproximação de 1ª ordem).",
                                    "Escreva relatório com conclusões e gráficos.",
                                    "Proponha experimento com perturbações em b para comparação."
                                  ],
                                  "verification": "Relatório mostra pelo menos 80% dos casos satisfazendo o bound.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Jupyter Notebook para relatório",
                                    "Gráficos de erro vs bound"
                                  ],
                                  "tips": "Use log-escala para plots de erros pequenos.",
                                  "learningObjective": "Sintetizar experimentos numéricos e conectar teoria à prática.",
                                  "commonMistakes": [
                                    "Ignorar efeitos de arredondamento",
                                    "Generalizar de poucos testes"
                                  ]
                                }
                              ],
                              "practicalExample": "Matriz A = [[2, 1], [1, 2]], b = [3, 4], x = [1, 1]. Perturbe δA com ε=0.01: δA=[[0.005, -0.003],[0.002, 0.004]]. Ã=[[2.005,0.997],[1.002,2.004]], resolva para y≈[0.998, 1.002]. rel_err≈0.002, bound=cond(A)≈4.0 * 0.0025≈0.01 > rel_err.",
                              "finalVerifications": [
                                "Todos os sistemas originais e perturbados resolvidos com erro numérico <1e-10.",
                                "Pelo menos 5 perturbações testadas, com rel_err ≤ bound em 100% dos casos.",
                                "Tabelas e gráficos documentam erros exatos, aproximados e bounds.",
                                "Razão bound/rel_err computada e analisada (tipicamente 2-10).",
                                "Relatório resume achados com interpretação física.",
                                "Código reprodutível salvo (ex: Jupyter notebook)."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos: normas e cond consistentes (90%+ acurácia).",
                                "Cobertura de testes: múltiplas perturbações e dimensões (2x2 e 3x3).",
                                "Análise qualitativa: explicação de por quê o bound segura/falha.",
                                "Visualizações claras: plots de erro vs ε e vs cond(A).",
                                "Conexão teórica: citação correta da fórmula perturbacional.",
                                "Relatório estruturado e acionável."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/NumPy para automação numérica.",
                                "Estatística: Análise de médias e desvios em experimentos aleatórios.",
                                "Física/Engenharia: Modelagem de erros em simulações (ex: FEM).",
                                "Ciência de Dados: Condicionamento em regressão linear.",
                                "Computação Científica: Estabilidade de algoritmos lineares."
                              ],
                              "realWorldApplication": "Em engenharia estrutural, perturbações em matrizes de rigidez (devido a medições imprecisas) podem prever falhas em simulações finitas; verificar bounds garante confiança em soluções aproximadas para projetos reais como pontes ou aviões."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.1.3",
                        "name": "Interpretação Numérica e Exemplos Práticos",
                        "description": "Aplicação da teoria de sensibilidade em contextos computacionais reais, com exemplos de matrizes il-condicionadas e discussão de implicações em algoritmos.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.1.3.1",
                            "name": "Analisar sensibilidade em matrizes de Hilbert",
                            "description": "Estudar o sistema com matriz de Hilbert (conhecida por ser il-condicionada), calcular cond(H_n), aplicar perturbações e observar o crescimento exponencial do erro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Construir e compreender a matriz de Hilbert H_n",
                                  "subSteps": [
                                    "Defina a matriz de Hilbert H_n onde o elemento (i,j) é 1/(i+j-1) para i,j de 1 a n.",
                                    "Escolha um valor pequeno de n (ex: n=5) para cálculo manual inicial e n=10 para computacional.",
                                    "Implemente a geração da matriz em Python usando NumPy ou MATLAB.",
                                    "Verifique simetria e propriedades positivas definidas da matriz.",
                                    "Calcule o traço e a norma Frobenius para familiarização."
                                  ],
                                  "verification": "Matriz gerada corresponde à definição padrão e é simétrica; teste com n=2: [[1, 1/2], [1/2, 1/3]].",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "MATLAB ou Octave",
                                    "Papel e calculadora para n pequeno"
                                  ],
                                  "tips": "Use loop duplo ou função hilb() no MATLAB para eficiência; armazene como float64 para precisão.",
                                  "learningObjective": "Compreender a estrutura da matriz de Hilbert e sua geração programática.",
                                  "commonMistakes": [
                                    "Índices errados começando em 0 em vez de 1",
                                    "Usar inteiros em vez de floats levando a truncamento",
                                    "Confundir H_n com sua inversa"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o número de condição cond(H_n)",
                                  "subSteps": [
                                    "Escolha um vetor b aleatório ou unitário para o sistema H_n x = b.",
                                    "Compute cond(H_n) = ||H_n|| * ||H_n^{-1}|| usando normas 2 ou infinito.",
                                    "Use SVD (decomposição em valores singulares) para cond = σ_max / σ_min.",
                                    "Compare cond(H_n) para n=5,10,15 e observe crescimento exponencial aproximado O(n^4).",
                                    "Registre valores em tabela: ex. cond(H_5) ≈ 4.8e5, cond(H_10) ≈ 1.6e13."
                                  ],
                                  "verification": "Valores de cond(H_n) batem com literatura (cresce rapidamente); gráfico log(cond) vs n linear.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python: numpy.linalg.cond, svd",
                                    "MATLAB: cond(hilb(n))",
                                    "Planilha para tabela"
                                  ],
                                  "tips": "Prefira norma 2 via SVD para precisão; evite inversão direta para grandes n.",
                                  "learningObjective": "Avaliar o condicionamento numérico da matriz e sua dependência em n.",
                                  "commonMistakes": [
                                    "Usar norma errada (ex: 1 em vez de 2)",
                                    "Inversão direta causando overflow",
                                    "Ignorar precisão de máquina (eps=1e-16)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar perturbações em H_n e resolver sistemas lineares",
                                  "subSteps": [
                                    "Gere solução exata x_true aleatória e b = H_n @ x_true.",
                                    "Perturbe A: A_pert = H_n + δ * randn(n,n) com δ=1e-6 * ||H_n||.",
                                    "Resolva x_exact = solve(H_n, b) e x_pert = solve(A_pert, b).",
                                    "Repita para perturbações em b: b_pert = b + ε * randn(n) com ε=1e-6 * ||b||.",
                                    "Meça erros: err_A = ||x_pert - x_exact|| / ||x_exact||."
                                  ],
                                  "verification": "Erros relativos > cond(H_n) * δ_machine para perturbações pequenas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python/MATLAB com linalg.solve",
                                    "Gerador de números aleatórios seeded para reprodutibilidade"
                                  ],
                                  "tips": "Use np.random.seed(42); normalize perturbações pela norma da matriz/vetor.",
                                  "learningObjective": "Simular perturbações numéricas e resolver sistemas il-condicionados.",
                                  "commonMistakes": [
                                    "Perturbações não normalizadas",
                                    "Usar solve instável como gaussiana ingênua",
                                    "Esquecer de medir erro relativo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o crescimento exponencial do erro e interpretar resultados",
                                  "subSteps": [
                                    "Plote log(err) vs log(δ) para vários δ, observe inclinação ≈ cond(H_n).",
                                    "Compare erros teóricos: ||Δx||/||x|| ≤ cond * (||ΔA||/||A|| + ||Δb||/||b||).",
                                    "Teste para n crescentes e quantifique amplificação: err_pert / δ ≈ cond.",
                                    "Discuta instabilidade: perda de dígitos ≈ log10(cond).",
                                    "Conclua sobre por que Hilbert é benchmark para il-condicionamento."
                                  ],
                                  "verification": "Gráficos mostram crescimento linear em log-escala; conclusão escrita sobre sensibilidade extrema.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Matplotlib/Plots para gráficos",
                                    "Notebook Jupyter para relatório"
                                  ],
                                  "tips": "Use eixos log-log; inclua bound teórico como linha de referência.",
                                  "learningObjective": "Interpretar numericamente a sensibilidade e validar teoria de condicionamento.",
                                  "commonMistakes": [
                                    "Escalas lineares escondendo exponencialidade",
                                    "Ignorar bound relativo",
                                    "Concluir estabilidade por erro pequeno em x_true"
                                  ]
                                }
                              ],
                              "practicalExample": "Para n=5: H_5 tem cond≈4.8e5. Perturbe A com δ=1e-10: erro relativo em x ≈ 5e-5, amplificado por cond (perda de 5 dígitos). Código: import numpy as np; H=np.linalg.hilb(5); etc.",
                              "finalVerifications": [
                                "Matriz H_n gerada corretamente para n=5-15.",
                                "cond(H_n) calculado e cresce com n (ex: >1e10 para n=10).",
                                "Erros em perturbações amplificados por fator cond(H_n).",
                                "Gráficos log-log mostram relação linear esperada.",
                                "Relatório interpreta crescimento exponencial do erro.",
                                "Código reprodutível e comentado."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos (erro <1e-10 em casos exatos).",
                                "Correta interpretação de cond(H_n) como medida de sensibilidade.",
                                "Análise quantitativa de erros vs teoria (bound respeitado).",
                                "Uso apropriado de ferramentas numéricas estáveis (SVD, solve).",
                                "Clareza em gráficos e conclusões escritas.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Teorema de condicionamento de Wilkinson.",
                                "Programação Científica: Uso de bibliotecas LAPACK/BLAS.",
                                "Física Computacional: Modelos il-condicionados em mecânica quântica.",
                                "Machine Learning: Regularização em regressão com matrizes de covariância.",
                                "Estatística: Análise de multicolinearidade em dados."
                              ],
                              "realWorldApplication": "Em engenharia, simulações FEM com meshes finas geram matrizes il-condicionadas como Hilbert, causando falhas em predições; usado em ML para testar estabilidade de inversões de matrizes em otimização."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.1.3.2",
                            "name": "Relacionar com fatorizações QR e SVD",
                            "description": "Examinar como a sensibilidade em A afeta a estabilidade de decomposições QR e SVD, com referências à análise em Golub & Van Loan (Cap. 2 e 8).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Decomposições QR e SVD",
                                  "subSteps": [
                                    "Ler seções relevantes do Capítulo 2 (QR) e Capítulo 8 (SVD) de Golub & Van Loan.",
                                    "Implementar QR via Householder ou Givens em Python/MATLAB para uma matriz de teste A.",
                                    "Implementar SVD via bibliotecas (np.linalg.svd) e entender os componentes U, Σ, V.",
                                    "Calcular normas condicionais cond(A) = σ_max/σ_min para SVD.",
                                    "Discutir estabilidade básica: QR é backward stable, SVD é bem condicionado para matrizes normais."
                                  ],
                                  "verification": "Gerar relatório com implementações e saídas para A de 3x3, confirmando A ≈ Q*R e A ≈ U*Σ*V^T.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Golub & Van Loan (Cap. 2 e 8)",
                                    "Python com NumPy/SciPy",
                                    "MATLAB (opcional)"
                                  ],
                                  "tips": "Use matrizes pequenas inicialmente para depuração; visualize Q ortogonal com Q^T*Q = I.",
                                  "learningObjective": "Compreender as definições e propriedades numéricas básicas de QR e SVD.",
                                  "commonMistakes": [
                                    "Confundir QR com decomposição LU",
                                    "Ignorar normalização em fatores de Householder",
                                    "Não verificar ortogonalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Sensibilidade da Decomposição QR a Perturbações em A",
                                  "subSteps": [
                                    "Introduzir perturbação δA com ||δA|| pequeno, computar QR(A) e QR(A+δA).",
                                    "Calcular ||δQ|| e ||δR|| usando normas Frobenius ou 2-norma.",
                                    "Estudar teoremas de Golub & Van Loan (Cap. 2): ||δQ|| ≤ κ(A) * ||δA|| / ||A|| aproximadamente.",
                                    "Simular numericamente com diferentes níveis de perturbação e cond(A) alto/baixo.",
                                    "Comparar estabilidade: QR é backward stable independentemente de cond(A)."
                                  ],
                                  "verification": "Plotar gráficos de ||δQ|| vs. ||δA|| para cond(A)=10 e 1000, mostrando linearidade.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Golub & Van Loan Cap. 2",
                                    "Jupyter Notebook para simulações",
                                    "NumPy para normas"
                                  ],
                                  "tips": "Use random.seed para reprodutibilidade; foque em perturbações aleatórias uniformes.",
                                  "learningObjective": "Quantificar como perturbações em A propagam para Q e R na QR.",
                                  "commonMistakes": [
                                    "Usar norma errada (ex: 1-norma em vez de 2)",
                                    "Não escalar perturbações relativas",
                                    "Ignorar dependência em κ(A)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Sensibilidade da Decomposição SVD a Perturbações em A",
                                  "subSteps": [
                                    "Ler Golub & Van Loan Cap. 8 sobre estabilidade da SVD.",
                                    "Computar SVD(A) e SVD(A+δA), analisar δU, δΣ, δV.",
                                    "Aplicar teorema de Wedin: bounds em ||δΣ|| ≤ ||δA||, e para singular vectors com gap σ.",
                                    "Simular com matrizes mal-condicionadas (ex: Hilbert) e perturbações.",
                                    "Discutir: SVD é backward stable, mas singular vectors sensíveis se singular values próximos."
                                  ],
                                  "verification": "Tabela comparativa de erros em Σ e vectors para 5 perturbações crescentes.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Golub & Van Loan Cap. 8",
                                    "SciPy para SVD robusta",
                                    "Matrizes de teste (Hilbert)"
                                  ],
                                  "tips": "Monitore gaps entre singular values; use svd(full_matrices=False) para eficiência.",
                                  "learningObjective": "Entender propagação de erros em componentes SVD sob perturbações.",
                                  "commonMistakes": [
                                    "Confundir forward/backward error",
                                    "Não considerar gaps em singular values",
                                    "Usar SVD inexata em software"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Sensibilidade QR/SVD com Sistemas Lineares e Verificações",
                                  "subSteps": [
                                    "Ligar QR a least squares: min ||Ax-b|| via R y = Q^T b, analisar sensibilidade.",
                                    "Ligar SVD a pseudoinversa: A^+ = V Σ^+ U^T, sensibilidade amplificada por 1/σ_min.",
                                    "Comparar: perturbações em A afetam soluções via cond(A), similar a QR/SVD.",
                                    "Executar exemplo numérico completo: resolver Ax=b com QR/SVD antes/depois perturbação.",
                                    "Referenciar Golub & Van Loan para teoremas unificados."
                                  ],
                                  "verification": "Relatório final com exemplo onde δA causa erro em x via QR vs. SVD.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código dos steps anteriores",
                                    "Golub & Van Loan Caps. 2/8"
                                  ],
                                  "tips": "Escolha b = A x_true + noise para realismo; compare erros relativos.",
                                  "learningObjective": "Conectar estabilidade de fatorizações com sensibilidade de equações lineares.",
                                  "commonMistakes": [
                                    "Não usar pseudoinversa corretamente",
                                    "Ignorar amplificação por cond",
                                    "Comparar apples-to-oranges (normas)"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[1,1],[1,1+eps]] com eps=1e-10 (mal-condicionada). Perturbe δA = 1e-12 * randn(2,2). Compute QR e SVD antes/depois. Observe: QR mantém Q estável, mas R amplifica; SVD Σ sensível em σ2 ≈0, vectors rotacionam muito. Resolva A x = [1,1]^T: erro em x cresce com cond(A).",
                              "finalVerifications": [
                                "Explicar verbalmente como κ(A) afeta ||δQ|| mas não backward stability de QR.",
                                "Implementar simulação reproduzindo bound de Wedin para SVD.",
                                "Comparar erros em solução de least squares via QR vs. pseudoinversa SVD.",
                                "Identificar caso onde SVD vectors são instáveis (singular values próximos).",
                                "Citar teorema específico de Golub & Van Loan Cap. 8.",
                                "Gerar plot de erro vs. ||δA|| linear para ambos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na citação de teoremas (80% correto).",
                                "Qualidade dos gráficos/simulações (erros <1e-10 em testes).",
                                "Compreensão conceitual: distinguir forward/backward stability.",
                                "Relacionamento claro com sensibilidade de Ax=b.",
                                "Uso correto de normas e condições.",
                                "Relatório completo com referências."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação numérica em ML para PCA (SVD-based).",
                                "Engenharia: Análise de estabilidade em controle (QR para Kalman).",
                                "Física: Modelagem de ruído em dados experimentais (sensibilidade SVD).",
                                "Estatística: Regressão robusta via decomposições estáveis."
                              ],
                              "realWorldApplication": "Em processamento de sinais, SVD é usada para compressão de imagens; perturbações em A (ruído sensor) afetam singular vectors, levando a artefatos – análise de sensibilidade guia filtros. Em finanças, QR estabiliza otimização de portfólios sob dados ruidosos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.3"
                            ]
                          },
                          {
                            "id": "10.1.2.3.1.3.3",
                            "name": "Avaliar sensibilidade em problemas reais",
                            "description": "Discutir exemplos de aplicações (ex.: regressão linear mal-condicionada) e estratégias para mitigar sensibilidade, como reescalonamento de A.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Sensibilidade Numérica",
                                  "subSteps": [
                                    "Relembrar a definição do número de condição κ(A) = ||A|| * ||A⁻¹||.",
                                    "Explicar o teorema de sensibilidade: |δx|/||x|| ≤ κ(A) * |δA|/||A||.",
                                    "Discutir o que significa 'mal-condicionado' com exemplos matriciais simples.",
                                    "Relacionar sensibilidade com o espectro de autovalores de A.",
                                    "Calcular κ(A) para uma matriz 2x2 de exemplo."
                                  ],
                                  "verification": "Resolver e discutir um exemplo simples de matriz mal-condicionada, confirmando κ(A) > 10⁶.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora ou software (MATLAB/Python/Octave)",
                                    "Notas de aula sobre álgebra linear computacional"
                                  ],
                                  "tips": "Comece com matrizes pequenas para ganhar intuição antes de problemas reais.",
                                  "learningObjective": "Compreender a teoria por trás da sensibilidade a perturbações em A.",
                                  "commonMistakes": "Confundir número de condição com determinante zero ou ignorar normas adequadas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Configurar um Problema Real de Regressão Linear",
                                  "subSteps": [
                                    "Escolher dados para regressão polinomial de alto grau (ex.: Vandermonde com n=10 pontos).",
                                    "Construir a matriz A de Vandermonde: A_{ij} = x_i^{j-1}.",
                                    "Definir vetor b com ruído pequeno e resolver Ax = b para obter coeficientes.",
                                    "Calcular a solução inicial x sem perturbações.",
                                    "Visualizar os dados e a curva ajustada."
                                  ],
                                  "verification": "Gerar gráfico da regressão e confirmar que a solução inicial parece razoável.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software numérico (Python com NumPy/SciPy ou MATLAB)",
                                    "Conjunto de dados de exemplo (ex.: pontos de uma função senoidal)"
                                  ],
                                  "tips": "Use pontos x_i próximos de 1 para agravar a il-condição.",
                                  "learningObjective": "Montar um exemplo prático de problema mal-condicionado oriundo de aplicação real.",
                                  "commonMistakes": "Escolher graus baixos de polinômio, que não exibem sensibilidade clara."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar a Sensibilidade a Perturbações em A",
                                  "subSteps": [
                                    "Introduzir perturbação δA com norma pequena (ex.: 10^{-10} * ||A||).",
                                    "Resolver o sistema perturbado (A + δA)x' = b e calcular erro relativo ||x' - x||/||x||.",
                                    "Repetir para múltiplas perturbações aleatórias e computar κ(A).",
                                    "Comparar erro observado com bound teórico κ(A) * |δA|/||A||.",
                                    "Analisar resíduos e gráficos de soluções perturbadas."
                                  ],
                                  "verification": "Documentar que o erro relativo excede amplamente a perturbação inicial, confirmando alta sensibilidade.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Código pronto para perturbações (script Python/MATLAB)",
                                    "Gráficos comparativos"
                                  ],
                                  "tips": "Use semente fixa para reprodutibilidade nas perturbações aleatórias.",
                                  "learningObjective": "Quantificar numericamente a sensibilidade em um contexto prático.",
                                  "commonMistakes": "Usar perturbações muito grandes, mascarando o efeito relativo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Testar Estratégias de Mitigação",
                                  "subSteps": [
                                    "Reescalonar as colunas de A dividindo pela norma euclidiana de cada coluna.",
                                    "Resolver o sistema reescalonado e reescalar a solução x de volta.",
                                    "Repetir avaliação de sensibilidade na matriz reescalonada.",
                                    "Comparar κ(A_reescalonada) com κ(A_original) e erros relativos.",
                                    "Discutir outras estratégias como regularização ou decomposição SVD."
                                  ],
                                  "verification": "Mostrar redução de κ(A) em pelo menos 2 ordens de magnitude e erro estável.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Mesmo software do Step 2 e 3",
                                    "Funções de normalização (np.linalg.norm)"
                                  ],
                                  "tips": "Sempre normalize b junto com A para consistência.",
                                  "learningObjective": "Implementar e validar técnicas práticas para reduzir sensibilidade.",
                                  "commonMistakes": "Esquecer de reescalar a solução x após normalização de A."
                                }
                              ],
                              "practicalExample": "Em regressão linear para ajuste polinomial de grau 8 a 10 pontos x_i ∈ [0.9, 1.1], a matriz Vandermonde A resulta em κ(A) ≈ 10^{12}. Uma perturbação δA de 10^{-10} causa mudança nos coeficientes x de até 10^2, invalidando previsões.",
                              "finalVerifications": [
                                "Calcula corretamente κ(A) para o exemplo e interpreta seu valor.",
                                "Demonstra impacto de perturbações pequenas causando grandes erros em x.",
                                "Aplica reescalonamento reduzindo efetivamente a sensibilidade.",
                                "Compara soluções antes/depois da mitigação com gráficos e métricas.",
                                "Explica limitações das estratégias em cenários extremos.",
                                "Discute quando SVD ou regularização seriam preferíveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de números de condição e erros relativos (erro < 5%).",
                                "Clareza na análise qualitativa e quantitativa da sensibilidade.",
                                "Correta implementação de reescalonamento e verificação de redução de κ(A).",
                                "Uso apropriado de visualizações para ilustrar resultados.",
                                "Profundidade na discussão de erros comuns e estratégias alternativas.",
                                "Capacidade de generalizar para outros problemas reais."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de regressão e multicolinearidade.",
                                "Programação Computacional: Implementação numérica estável em Python/MATLAB.",
                                "Engenharia: Modelagem de sistemas físicos com dados ruidosos.",
                                "Análise de Dados: Pré-processamento para machine learning."
                              ],
                              "realWorldApplication": "Na previsão financeira (ex.: ajuste de curvas de juros), onde matrizes il-condicionadas de dados de mercado levam a estimativas instáveis de parâmetros; reescalonamento previne erros catastróficos em portfólios de investimento."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.4",
                    "name": "Estabilidade Numérica de Soluções",
                    "description": "Avaliação da propagação de erros de arredondamento na resolução numérica de sistemas lineares.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.4.1",
                        "name": "Número de Condição de Matrizes",
                        "description": "Conceito fundamental que mede a sensibilidade de uma matriz à perturbações, relacionando o condicionamento com a propagação de erros relativos na solução de sistemas lineares Ax = b.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.1.1",
                            "name": "Calcular o número de condição de uma matriz",
                            "description": "Computar o número de condição cond(A) = ||A|| * ||A^{-1}|| para normas como 2-norma ou norma do infinito, utilizando decomposição SVD para eficiência numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de número de condição e normas de matriz",
                                  "subSteps": [
                                    "Defina o número de condição cond(A) = ||A|| * ||A^{-1}|| para uma matriz invertível A.",
                                    "Revise normas comuns: norma do infinito (máxima soma de linhas absolutas), norma 1 (máxima soma de colunas), e 2-norma (valor singular máximo).",
                                    "Explique a relação com sensibilidade: cond(A) alto indica instabilidade numérica em soluções de Ax=b.",
                                    "Discuta limitações computacionais de calcular A^{-1} diretamente devido a erros de arredondamento.",
                                    "Identifique quando usar SVD: cond_2(A) = σ_max / σ_min, onde σ são valores singulares."
                                  ],
                                  "verification": "Resuma em suas palavras o significado de cond(A) e liste 3 normas com fórmulas; confira com referências.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear Numérica (ex: Golub & Van Loan)",
                                    "Notas de aula sobre normas",
                                    "Calculadora ou papel para exemplos manuais"
                                  ],
                                  "tips": "Comece com matrizes 2x2 para intuição visual; memorize que cond(A)=1 para A identidade.",
                                  "learningObjective": "Compreender a definição e importância do número de condição em estabilidade numérica.",
                                  "commonMistakes": [
                                    "Confundir norma de vetor com norma de matriz",
                                    "Ignorar que cond(A) ≥ 1 sempre",
                                    "Esquecer que SVD evita inversão explícita"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular número de condição usando normas explícitas (inf e 1-norma)",
                                  "subSteps": [
                                    "Escolha uma matriz A pequena (2x2 ou 3x3) e compute ||A||_∞ = max_i Σ_j |a_ij|.",
                                    "Calcule A^{-1} usando fórmula explícita ou Gauss-Jordan.",
                                    "Compute ||A^{-1}||_∞ da mesma forma e multiplique pelas normas.",
                                    "Repita para norma 1: ||A||_1 = max_j Σ_i |a_ij|.",
                                    "Compare resultados e note diferenças entre normas."
                                  ],
                                  "verification": "Para uma matriz dada, calcule cond_∞ e cond_1 corretamente, mostrando todos os passos intermediários.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Matriz de exemplo impressa ou em software como MATLAB/Octave",
                                    "Folha de cálculo para normas",
                                    "Documentação de inversão manual"
                                  ],
                                  "tips": "Use sympy ou frações exatas para matrizes pequenas para evitar erros numéricos iniciais.",
                                  "learningObjective": "Executar cálculo manual de cond(A) para normas 1 e ∞.",
                                  "commonMistakes": [
                                    "Erro na inversão (determinante zero)",
                                    "Soma errada nas normas de linha/coluna",
                                    "Arredondamento prematuro em cálculos manuais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar cálculo via Decomposição SVD para 2-norma",
                                  "subSteps": [
                                    "Lembre SVD: A = U Σ V^H, onde Σ tem valores singulares σ1 ≥ σ2 ≥ ... ≥ 0.",
                                    "Compute cond_2(A) = σ1 / σ_min (se rank cheio, σn).",
                                    "Use software: em Python/NumPy, np.linalg.svd(A, compute_uv=False) para singulares.",
                                    "Aplique a uma matriz mal-condicionada (ex: Hilbert matrix).",
                                    "Verifique consistência comparando com norma explícita para matrizes pequenas."
                                  ],
                                  "verification": "Gere código que computa SVD e cond_2(A); teste com input conhecido e output correto.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy instalado",
                                    "Jupyter Notebook",
                                    "Exemplos de matrizes Hilbert: scipy.linalg.hilb(n)"
                                  ],
                                  "tips": "Sempre normalize σ_min > 0; use full_matrices=False para eficiência.",
                                  "learningObjective": "Aplicar SVD para cond_2 eficiente e numericamente estável.",
                                  "commonMistakes": [
                                    "Usar svd sem extrair diagonais de Σ",
                                    "Confundir σ_max com det(A)",
                                    "Ignorar tolerância para σ_min ≈0"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e validar resultados numéricos",
                                  "subSteps": [
                                    "Compare cond de diferentes normas para a mesma A.",
                                    "Analise impacto: perturbe b em Ax=b e veja erro relativo em x.",
                                    "Teste estabilidade: resolva Ax=b com A perturbada e compare cond.",
                                    "Gere gráfico de cond vs tamanho para família de matrizes (ex: tridiagonal).",
                                    "Documente thresholds: cond<10^3 bom, >10^12 il-condicionado."
                                  ],
                                  "verification": "Produza relatório com tabela de cond para 3 matrizes e interpretação de estabilidade.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código Python do step 3",
                                    "Matplotlib para gráficos",
                                    "Dados de teste: matrizes bem/mal condicionadas"
                                  ],
                                  "tips": "Use np.linalg.cond(A, p=2) para verificação rápida.",
                                  "learningObjective": "Interpretar cond(A) em contextos de estabilidade e validação numérica.",
                                  "commonMistakes": [
                                    "Interpretar cond baixo como sempre estável (depende de normas)",
                                    "Não considerar máquina epsilon em validações",
                                    "Overlook singular matrices (cond=inf)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[1, 1], [1, 1+eps]] com eps=1e-10 (mal-condicionada):\n- ||A||_∞ ≈ 2, ||A^{-1}||_∞ ≈ 1e10, cond_∞ ≈ 2e10.\n- SVD: σ1≈2, σ2≈1e-10, cond_2≈2e10.\nCódigo Python: import numpy as np; A=np.array([[1,1],[1,1+1e-10]]); print(np.linalg.cond(A,2)).",
                              "finalVerifications": [
                                "Calcula corretamente cond_∞ e cond_1 para matriz 3x3 manualmente.",
                                "Implementa e executa código SVD para cond_2 em Python.",
                                "Identifica matriz mal-condicionada (cond>1e6) em conjunto de testes.",
                                "Explica relação cond(A) com bound de erro ||δx||/||x|| ≤ cond(A) * ||δb||/||b||.",
                                "Compara eficiência: tempo SVD vs inversão para n=100.",
                                "Valida com np.linalg.cond() built-in."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos manuais (erro <1%).",
                                "Código funcional e comentado para SVD.",
                                "Interpretação correta de valores altos/baixos de cond.",
                                "Uso apropriado de normas para contextos específicos.",
                                "Identificação de pitfalls numéricos (ex: overflow em inversa).",
                                "Relatório claro com exemplos e gráficos."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em NumPy/SciPy para Álgebra Computacional.",
                                "Física: Análise de estabilidade em simulações dinâmicas (ex: FEM).",
                                "Engenharia: Otimização de sistemas lineares em controle.",
                                "Estatística: Regressão linear e multicolinearidade (cond(X) alto)."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, calcular cond de matriz de rigidez em FEM para prever erros em simulações de tensão; cond alto sinaliza necessidade de refinar malha ou modelo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.2",
                            "name": "Interpretar bounds de erro baseados no condicionamento",
                            "description": "Aplicar a desigualdade |δx|/|x| ≤ cond(A) * (|δb|/|b| + |δA|/|A|) para estimar a amplificação de erros de entrada na solução de sistemas lineares perturbados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de número de condição cond(A)",
                                  "subSteps": [
                                    "Defina cond(A) = ||A|| * ||A⁻¹|| para norma compatível.",
                                    "Calcule cond(A) para matrizes simples 2x2 usando normas como ||.||∞ ou ||.||₂.",
                                    "Interprete cond(A) = 1 como matriz bem condicionada e cond(A) >> 1 como mal condicionada.",
                                    "Compare cond(A) com a amplificação relativa de erros."
                                  ],
                                  "verification": "Resolva exercício: calcule cond(A) para A = [[1,0],[0,1]] e A = [[1,1e-6],[1e-6,1]] e explique a diferença.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora científica, papel e lápis, software NumPy ou MATLAB para inversa.",
                                  "tips": "Use norma 2 para precisão; verifique simetria em matrizes SPD.",
                                  "learningObjective": "Explicar o papel do número de condição na sensibilidade de sistemas lineares.",
                                  "commonMistakes": "Confundir cond(A) com det(A); esquecer de calcular A⁻¹ corretamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar os componentes da desigualdade de bound de erro",
                                  "subSteps": [
                                    "Identifique os termos: |δx|/|x| (erro relativo na solução), |δb|/|b| (erro em b), |δA|/|A| (erro em A).",
                                    "Entenda cond(A) como fator de amplificação máxima.",
                                    "Reescreva a desigualdade: erro_saída ≤ cond(A) * (erro_b + erro_A).",
                                    "Discuta casos limites: δA=0 (apenas perturbação em b) vs. δb=0."
                                  ],
                                  "verification": "Para um sistema Ax=b, identifique qualitativamente como cond(A) afeta δx dado δb pequeno.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Quadro branco ou caderno para anotações, referência teórica (livro de Álgebra Numérica).",
                                  "tips": "Pense em cond(A) como 'multiplicador de risco' de erros de entrada.",
                                  "learningObjective": "Decompor a desigualdade e associar cada termo físico.",
                                  "commonMistakes": "Ignorar que é uma upper bound, não igualdade exata; confundir normas absolutas com relativas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a desigualdade em um exemplo numérico concreto",
                                  "subSteps": [
                                    "Escolha A mal condicionada, e.g., A = [[1,1],[1,1+ε]] com ε=1e-6; compute x exato para b=[2,2+ε].",
                                    "Introduza perturbações δb e δA pequenas (e.g., 1e-8 relativa).",
                                    "Resolva Ax≈b com perturbações usando eliminação gaussiana ou NumPy.",
                                    "Calcule bound superior: cond(A)*(|δb|/|b| + |δA|/|A|) e compare com |δx|/|x| real.",
                                    "Repita com A bem condicionada para contraste."
                                  ],
                                  "verification": "O bound previsto é maior ou igual ao erro observado? Registre valores numéricos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/SciPy, ou MATLAB; planilha Excel para cálculos manuais.",
                                  "tips": "Use np.linalg.cond() para cond(A); normalize perturbações para 1e-6 relativa.",
                                  "learningObjective": "Executar cálculo prático da desigualdade em sistemas perturbados.",
                                  "commonMistakes": "Usar norma errada (incompatível); arredondamentos em cálculos manuais sem double precision."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar bounds de erro e implicações práticas",
                                  "subSteps": [
                                    "Avalie se cond(A) alto implica perda de dígitos precisão: perda ≈ log10(cond(A)).",
                                    "Discuta trade-offs: refinar malha em FEM vs. usar pré-condicionadores.",
                                    "Compare bound teórico com erro real (geralmente conservador).",
                                    "Proponha estratégias de mitigação: escalonamento de A, escolha de normas.",
                                    "Resuma quando confiar ou não no bound."
                                  ],
                                  "verification": "Escreva relatório curto: 'Para cond(A)=1e6, erro 1e-8 em b vira ~1e-2 em x'.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de texto para relatório, gráficos de erro vs. cond(A) gerados em Python.",
                                  "tips": "Visualize com plots: erro real vs. bound em escala log.",
                                  "learningObjective": "Interpretar numericamente a amplificação e propor soluções.",
                                  "commonMistakes": "Superestimar precisão máquina (eps~1e-16); ignorar que bound é pessimista."
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 1], [1, 1+1e-6]], b = [2, 2+1e-6], x_exato ≈ [1,1]. Perturbe b' = b + 1e-8*[1,1]/||b|| e A' = A + 1e-8*A/||A||. cond(A)≈1e6. Bound: |δx|/|x| ≤ 1e6*(1e-8 + 1e-8)=2e-2. Solução perturbada mostra erro ~1e-2, confirmando amplificação.",
                              "finalVerifications": [
                                "Calcule cond(A) corretamente para pelo menos 3 matrizes teste.",
                                "Aplique a desigualdade em exemplo numérico e verifique bound ≥ erro real.",
                                "Explique verbalmente a amplificação de erros em 1 minuto.",
                                "Identifique quando cond(A) alto é problemático (e.g., >1e12).",
                                "Proponha 2 estratégias para reduzir impacto de cond alto.",
                                "Compare erro em A bem vs. mal condicionada graficamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de cond(A) (erro <1%).",
                                "Correta decomposição e aplicação da desigualdade (todos termos presentes).",
                                "Interpretação qualitativa e quantitativa coerente.",
                                "Uso apropriado de normas e precisão numérica.",
                                "Criatividade em exemplos e conexões práticas.",
                                "Relatório claro com verificações e gráficos."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementar em Python/MATLAB com análise de estabilidade.",
                                "Engenharia Computacional: Análise de erros em simulações FEM/CFD.",
                                "Física Computacional: Modelos diferenciais discretizados com matrizes mal condicionadas.",
                                "Estatística: Regressão linear e sensibilidade a multicolinearidade."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, ao resolver sistemas de equilíbrio de estruturas via FEM, matrizes mal condicionadas (alta cond>1e10) amplificam erros de medição em cargas (δb), levando a designs inseguros; o bound guia refinamento de malha ou regularização para garantir precisão em simulações de voo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.3",
                            "name": "Avaliar o impacto do condicionamento em exemplos numéricos",
                            "description": "Resolver numericamente sistemas lineares bem e mal condicionados, comparando erros relativos observados com os bounds teóricos fornecidos pelo número de condição.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular o Número de Condição de Matrizes Exemplo",
                                  "subSteps": [
                                    "Selecionar matrizes bem condicionadas (ex: matriz identidade 2x2, cond ≈1) e mal condicionadas (ex: matriz de Hilbert 3x3, cond >1000)",
                                    "Calcular a norma 2 da matriz A usando função np.linalg.norm(A, 2) em Python ou svd",
                                    "Computar a inversa A^{-1} e sua norma 2: np.linalg.norm(np.linalg.inv(A), 2)",
                                    "Calcular κ(A) = ||A||_2 * ||A^{-1}||_2 e usar np.linalg.cond(A) para verificação",
                                    "Interpretar valores: κ < 10^3 bem condicionado, κ > 10^6 mal condicionado"
                                  ],
                                  "verification": "Verificar se κ_bem ≈1 e κ_mal >10^4 com precisão de 1e-6",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy e SciPy",
                                    "Matrizes exemplo: identidade e Hilbert",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use decomposição SVD para normas precisas em matrizes grandes: cond = sigma_max / sigma_min",
                                  "learningObjective": "Dominar o cálculo e interpretação do número de condição κ(A)",
                                  "commonMistakes": "Usar norma errada (sempre 2-norm para cond); não lidar com singularidades aproximadas"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar Sistemas Lineares com Perturbações",
                                  "subSteps": [
                                    "Definir vetores b exatos para A x = b, com solução x exata conhecida (ex: x = [1,1]^T)",
                                    "Gerar perturbação δb ~ machine epsilon * ||b|| (ex: 1e-10 * ||b|| * randn)",
                                    "Formar sistema perturbado A x_pert = b + δb",
                                    "Escolher A_bem e A_mal dos passos anteriores",
                                    "Documentar soluções exatas x_true para ambas"
                                  ],
                                  "verification": "Confirmar ||δb|| / ||b|| ≈ 1e-10 e sistemas bem formados sem NaNs",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código Python anterior",
                                    "Funções randn/np.random.normal"
                                  ],
                                  "tips": "Fixe semente randômica np.random.seed(42) para reprodutibilidade",
                                  "learningObjective": "Preparar setups numéricos para análise de sensibilidade",
                                  "commonMistakes": "Perturbação muito grande/pequena; não normalizar δb corretamente"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver Sistemas Numericamente e Calcular Erros Relativos",
                                  "subSteps": [
                                    "Resolver x_num = np.linalg.solve(A, b) e x_pert_num = np.linalg.solve(A, b + δb)",
                                    "Calcular erro relativo observado: err_obs = ||x_pert_num - x_true|| / ||x_true||",
                                    "Repetir para A_bem e A_mal",
                                    "Registrar erros para ambos casos",
                                    "Visualizar com plot de barras comparando err_bem vs err_mal"
                                  ],
                                  "verification": "Erros computados com precisão relativa <1e-12; plots gerados",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "NumPy linalg.solve",
                                    "Matplotlib para plots"
                                  ],
                                  "tips": "Use condicionarização prévia se necessário, mas evite para pureza",
                                  "learningObjective": "Executar resoluções numéricas e quantificar erros observados",
                                  "commonMistakes": "Confundir x_num com x_pert; normalização errada no erro relativo"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Erros Observados com Bounds Teóricos",
                                  "subSteps": [
                                    "Recordar bound teórico: err_obs ≤ κ(A) * (||δb|| / ||b||) * κ(b/Ax) aproximado",
                                    "Calcular bound: upper_bound = κ(A) * eps_máq onde eps_máq ≈1e-16",
                                    "Comparar numericamente: se err_obs ≈ bound para mal condicionado",
                                    "Analisar amplificação: fator = err_obs / (||δb||/||b||)",
                                    "Concluir se bound é tight (atingido) para A_mal"
                                  ],
                                  "verification": "Tabela comparativa mostra err_obs < bound e amplificação ~κ para mal cond",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Cálculos anteriores",
                                    "Pandas para tabelas"
                                  ],
                                  "tips": "Log10 nos erros para visualizar ordens de magnitude",
                                  "learningObjective": "Validar teoria de sensibilidade via experimentos numéricos",
                                  "commonMistakes": "Ignorar fator ||A||/||x|| no bound completo; interpretação qualitativa errada"
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e Documentar o Impacto do Condicionamento",
                                  "subSteps": [
                                    "Resumir: A_bem tem err_obs ~ eps, A_mal tem err_obs ~ κ*eps",
                                    "Discutir implicações: perda de dígitos = log10(κ)",
                                    "Testar com κ variando (ex: adicionar ε à diagonal de Hilbert)",
                                    "Gerar relatório com tabelas, plots e conclusões",
                                    "Propor melhorias: pivoteamento, refinamento"
                                  ],
                                  "verification": "Relatório completo com análise quantitativa e qualitativa",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Todos códigos e resultados prévios",
                                    "LaTeX ou Markdown para relatório"
                                  ],
                                  "tips": "Quantifique perda de precisão em dígitos decimais",
                                  "learningObjective": "Sintetizar experimentos para avaliar impacto prático do condicionamento",
                                  "commonMistakes": "Generalizar demais sem dados; ignorar efeitos de arredondamento"
                                }
                              ],
                              "practicalExample": "Para A_mal = [[1, 1], [1, 1+1e-6]], κ≈1e6; b=[3,3+1e-6], x_true=[1,2]. Perturbe δb=1e-10*[1,1]. Erro observado ~1e-10 para bem cond, mas ~1e-4 para mal cond, matching bound κ*eps.",
                              "finalVerifications": [
                                "Número de condição κ calculado corretamente para ambos exemplos",
                                "Erros relativos observados computados com precisão numérica adequada",
                                "Comparação mostra amplificação por κ em caso mal condicionado",
                                "Bounds teóricos não violados (err_obs ≤ κ * eps)",
                                "Relatório inclui plots e tabela de comparação",
                                "Conclusão identifica corretamente impacto do condicionamento"
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de normas, inversas e κ (erro <1e-8)",
                                "Correta preparação e resolução de sistemas perturbados",
                                "Análise quantitativa rigorosa dos erros relativos vs bounds",
                                "Interpretação qualitativa do impacto (estabilidade/sensibilidade)",
                                "Qualidade de visualizações e documentação",
                                "Identificação de erros comuns e mitigações"
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação com NumPy/SciPy para análise computacional",
                                "Engenharia Computacional: Estabilidade em simulações FEM e CFD",
                                "Física: Modelagem de sistemas dinâmicos com matrizes mal condicionadas",
                                "Estatística: Análise de regressão linear sensível a multicolinearidade"
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, matrizes de rigidez em análises finitas elemento podem ser mal condicionadas por meshes finas, amplificando erros de medição em cargas para predições catastróficas de falhas estruturais; avaliação de κ guia refinamento ou regularização."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.2",
                        "name": "Propagação de Erros de Arredondamento",
                        "description": "Estudo detalhado de como os erros inerentes à aritmética de ponto flutuante se acumulam durante a resolução numérica de sistemas lineares.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.2.1",
                            "name": "Modelar erros de arredondamento em operações matriciais",
                            "description": "Representar erros em multiplicações e inversões matriciais usando o modelo de aritmética flutuante fl(a ⊕ b) = (a + b)(1 + ε) com |ε| ≤ u, onde u é a unidade máquina.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Fundamentos da Aritmética Flutuante e Unidade Máquina",
                                  "subSteps": [
                                    "Estude a representação IEEE 754 para números de ponto flutuante duplo.",
                                    "Defina a unidade máquina u como o menor ε tal que fl(1 + ε) > 1.",
                                    "Analise o modelo de arredondamento para soma: fl(a ⊕ b) = (a + b)(1 + ε), com |ε| ≤ u.",
                                    "Estenda para multiplicação: fl(a ⊗ b) = (a * b)(1 + δ), com |δ| ≤ u.",
                                    "Calcule u para precisão dupla (aprox. 2.22e-16) usando software."
                                  ],
                                  "verification": "Derive e justifique as fórmulas de erro para soma e produto escalares, confirmando com exemplo numérico onde fl(1 + u/2) = 1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação IEEE 754",
                                    "Python/MATLAB com np.finfo(float).eps",
                                    "Papel e calculadora"
                                  ],
                                  "tips": "Sempre normalize os operandos para expor o erro relativo claramente.",
                                  "learningObjective": "Compreender o modelo padrão de erros de arredondamento em operações elementares de flutuantes.",
                                  "commonMistakes": [
                                    "Confundir u com o erro absoluto em vez de relativo.",
                                    "Ignorar que o arredondamento pode ser para cima ou para baixo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelagem de Erros em Multiplicação Matricial",
                                  "subSteps": [
                                    "Represente a multiplicação C = A B como c_ij = ∑_k a_ik b_kj.",
                                    "Modele cada produto: fl(a_ik ⊗ b_kj) = a_ik b_kj (1 + δ_ik^j), |δ_ik^j| ≤ u.",
                                    "Inclua erros de soma acumulada: cada soma parcial com fl(s ⊕ t) = (s + t)(1 + ε_m), para m somas.",
                                    "Derive o erro relativo global: |fl(c_ij) - c_ij| / |c_ij| ≤ γ_n = n u / (1 - n u), aproximando O(n u) para n x n.",
                                    "Aplique a uma matriz 2x2 para ilustrar."
                                  ],
                                  "verification": "Escreva a expressão completa fl(A B) = A B + E, onde ||E|| ≤ f(n, u, ||A||, ||B||), e comprove numericamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Matrizes 2x2 de exemplo",
                                    "Python com numpy para multiplicação exata vs flutuante",
                                    "Referência: Higham's Accuracy and Stability"
                                  ],
                                  "tips": "Use normas compatíveis (ex: norma 1 ou Frobenius) para bounds mais simples.",
                                  "learningObjective": "Modelar a propagação de erros de arredondamento na multiplicação de matrizes.",
                                  "commonMistakes": [
                                    "Esquecer erros em somas sucessivas, subestimando O(n u).",
                                    "Não considerar o crescimento de erros condicionados por ||A|| e ||B||."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelagem de Erros em Inversão Matricial",
                                  "subSteps": [
                                    "Discuta que inversão via eliminação gaussiana envolve O(n^3) operações aritméticas.",
                                    "Modele erro em fatores LU: fl(P A) = L U + Δ, com ||Δ|| pequeno relativo.",
                                    "Para A^{-1}, erro relativo ||fl(A^{-1}) - A^{-1}|| / ||A^{-1}|| ≤ κ(A) γ_n + O(γ_n^2), onde κ é condição.",
                                    "Inclua propagação backward: fl(A x) = A x + δb, com ||δb|| pequeno.",
                                    "Simule numericamente com matriz mal condicionada."
                                  ],
                                  "verification": "Derive o bound de erro para inversão e verifique com exemplo onde cond(A) ≈ 1e6 amplifica erros.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Biblioteca SciPy para inv() e cond()",
                                    "Matriz Hilbert 5x5 para ill-cond",
                                    "Papel para derivação simbólica"
                                  ],
                                  "tips": "Foco em análise backward para estabilidade, não forward.",
                                  "learningObjective": "Aplicar modelo de flutuantes à propagação de erros em inversões matriciais.",
                                  "commonMistakes": [
                                    "Confundir estabilidade forward com backward.",
                                    "Ignorar dependência quadrática em γ_n para grandes n."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simulação e Análise Numérica de Erros",
                                  "subSteps": [
                                    "Implemente multiplicação e inversão em precisão dupla e compare com exata (mpmath alta precisão).",
                                    "Meça erros relativos e compare com bounds teóricos O(n u κ).",
                                    "Teste com matrizes bem/mal condicionadas.",
                                    "Analise sensibilidade variando u (ex: float32 vs float64).",
                                    "Documente observações sobre quando bounds são sharp."
                                  ],
                                  "verification": "Gere relatório com tabelas de erros observados vs preditos, confirmando modelo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python: numpy, scipy, mpmath",
                                    "Jupyter notebook para plots de erros"
                                  ],
                                  "tips": "Use random.seed para reprodutibilidade em testes.",
                                  "learningObjective": "Validar modelos teóricos através de experimentos computacionais.",
                                  "commonMistakes": [
                                    "Usar precisão insuficiente para 'exata'.",
                                    "Não normalizar erros por normas apropriadas."
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[1, 1], [1, 1+1e-10]], B = A, compute fl(A B) vs exata. Erro em det(fl(A B)) amplificado por cond(A)≈1e10, mostrando fl(det)≈0 em vez de 1e-10, modelado como O(u κ(A))≈1e-6.",
                              "finalVerifications": [
                                "Deriva corretamente fl(a ⊕ b) e fl(a ⊗ b).",
                                "Escreve modelo de erro para multiplicação n x n com bound O(n u).",
                                "Explica propagação em inversão via condição κ(A).",
                                "Simula numericamente e compara erros observados com teóricos.",
                                "Identifica quando usar análise forward vs backward.",
                                "Discute impacto de u em precisão dupla."
                              ],
                              "assessmentCriteria": [
                                "Precisão e rigor matemático nas derivações de bounds.",
                                "Correta aplicação do modelo ε a operações compostas.",
                                "Qualidade da simulação numérica e interpretação de resultados.",
                                "Identificação precisa de fatores amplificadores como n e κ(A).",
                                "Clareza na distinção entre erros absolutos e relativos.",
                                "Uso apropriado de normas matriciais nos bounds."
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Otimização de algoritmos numéricos em LAPACK/BLAS.",
                                "Engenharia: Análise de erros em simulações FEM e CFD.",
                                "Física Computacional: Estabilidade em solvers de equações diferenciais.",
                                "Estatística: Propagação de erros em regressão linear computacional."
                              ],
                              "realWorldApplication": "Em solvers de sistemas lineares como os usados em machine learning (ex: SVD em PCA) ou simulações climáticas, modelar esses erros permite prever perda de precisão em matrizes grandes/mal condicionadas, guiando escolhas de preconditioners ou precisão mista."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.2",
                            "name": "Analisar backward e forward stability",
                            "description": "Distinguir estabilidade forward (erro na solução) de backward stability (solução exata de sistema perturbado), aplicando a sistemas Ax = b com perturbações δA e δb.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Fundamentais de Estabilidade Forward e Backward",
                                  "subSteps": [
                                    "Leia definições formais: forward stability mede o erro na solução ||x_comp - x_exact|| relativo a perturbações no input.",
                                    "Estude backward stability: verifica se x_comp é solução exata de (A + δA)x_comp = b + δb com ||δA||/||A|| e ||δb||/||b|| pequenos.",
                                    "Compare os dois: forward foca em erro absoluto na saída, backward em quão próximo o problema perturbado está do original.",
                                    "Revise noções de normas matriciais (e.g., norma 2, norma Frobenius) e condição do sistema cond(A).",
                                    "Anote diferenças chave em um quadro comparativo."
                                  ],
                                  "verification": "Crie um resumo escrito distinguindo os conceitos com exemplos verbais corretos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Accuracy and Stability of Numerical Algorithms' de N. Higham (cap. 2-3)",
                                    "Notas de aula sobre Álgebra Linear Numérica"
                                  ],
                                  "tips": "Use analogias: forward é 'quanto o resultado final erra', backward é 'o problema foi ligeiramente alterado mas resolvido exatamente'.",
                                  "learningObjective": "Distinguir conceitualmente forward e backward stability em termos de erros propagados.",
                                  "commonMistakes": [
                                    "Confundir forward com backward (pensar que backward mede erro na solução)",
                                    "Ignorar normalização relativa nos erros"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Definições Matemáticas e Fórmulas para Sistemas Ax = b",
                                  "subSteps": [
                                    "Defina forward error: relerr_forward = ||x_comp - x|| / ||x||.",
                                    "Defina backward error: relerr_backward = max(||δA||/||A||, ||δb||/||b||), onde (A + δA)x_comp = b + δb.",
                                    "Aprenda bounds: para Gaussian elimination, backward stable se cond(A) pequeno; forward error ≤ cond(A) * relerr_backward.",
                                    "Estude perturbações δA e δb em decomposições LU ou QR.",
                                    "Derive um exemplo simples: para Ax = b exato, compute x_comp com arredondamento e verifique erros.",
                                    "Pratique com normas: compute ||r|| = ||b - A x_comp|| para residual (relacionado a backward)."
                                  ],
                                  "verification": "Resolva exercícios teóricos derivando bounds de erro para um sistema 2x2.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software MATLAB ou Python com NumPy/SciPy",
                                    "Folhas de exercícios de álgebra numérica"
                                  ],
                                  "tips": "Sempre normalize erros com ||x|| ou ||A|| para relatividade; use machine epsilon (eps) para estimar perturbações.",
                                  "learningObjective": "Formular matematicamente forward e backward errors para sistemas lineares perturbados.",
                                  "commonMistakes": [
                                    "Usar erro absoluto em vez de relativo",
                                    "Esquecer que backward stability não implica forward stability em matrizes ill-conditioned"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Análise a Exemplos Numéricos Simples",
                                  "subSteps": [
                                    "Escolha sistema 2x2 ill-conditioned: A = [[1,1],[1,1+eps]], b = [1,1].",
                                    "Resolva exato analiticamente e numericamente em double precision.",
                                    "Compute forward error: ||x_num - x_exact|| / ||x_exact||.",
                                    "Compute backward error: encontre δA, δb mínimos tal que (A+δA)x_num = b+δb exatamente.",
                                    "Compare: observe forward error grande apesar de backward pequeno.",
                                    "Repita com A bem-conditioned para contraste."
                                  ],
                                  "verification": "Gere relatório com valores numéricos de erros forward/backward para dois sistemas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python/Jupyter Notebook com numpy.linalg",
                                    "MATLAB (opcional)"
                                  ],
                                  "tips": "Use np.linalg.norm() para cálculos precisos; plote cond(A) vs erros para visualização.",
                                  "learningObjective": "Calcular e interpretar erros forward e backward em implementações numéricas.",
                                  "commonMistakes": [
                                    "Não considerar machine epsilon na perturbação",
                                    "Confundir residual ||b - Ax|| com backward error exato"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Propagação de Erros de Arredondamento e Conclusões",
                                  "subSteps": [
                                    "Simule erros de arredondamento adicionando ruído ~eps * ||A|| a A e b.",
                                    "Avalie estabilidade: método backward stable se backward error ~eps independentemente de cond(A).",
                                    "Discuta implicações: forward stability requer cond(A) pequeno.",
                                    "Teste algoritmos: Gaussian elim. vs. QR para mesmo sistema.",
                                    "Sintetize: quando usar análise backward para validar solvers numéricos.",
                                    "Crie gráfico de erros vs. cond(A)."
                                  ],
                                  "verification": "Explique em 1 página por que QR é forward stable em matrizes normais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python para simulações",
                                    "Referência: Demmel 'Applied Numerical Linear Algebra'"
                                  ],
                                  "tips": "Monitore ulp (units in last place) para precisão; evite singularidade forçando cond(A) alto.",
                                  "learningObjective": "Avaliar estabilidade numérica prática considerando propagação de erros de arredondamento.",
                                  "commonMistakes": [
                                    "Atribuir todo forward error a ill-conditioning sem checar backward",
                                    "Ignorar dependência em normas usadas"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o sistema ill-conditioned A = [[1, 1], [1, 1+1e-10]], b = [2, 2+1e-10]. Solução exata x_exact ≈ [1,1]. Em double precision, Gaussian elimination dá x_comp com forward error ~1 (catastrófico), mas backward error ~1e-16 (máquina eps), provando backward stability mas não forward devido a cond(A)≈1e10.",
                              "finalVerifications": [
                                "Define corretamente forward vs. backward stability sem confusão.",
                                "Calcula backward error para um sistema dado com precisão relativa <1e-10.",
                                "Identifica quando forward error é amplificado por cond(A).",
                                "Explica papel do residual na estimativa de backward error.",
                                "Compara estabilidade de dois solvers em exemplo numérico.",
                                "Discute limitações em matrizes não normais."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: distinção clara entre forward/backward (80% peso).",
                                "Cálculos numéricos corretos com normas apropriadas.",
                                "Interpretação qualitativa: liga erros a cond(A) e eps máquina.",
                                "Uso de exemplos concretos com valores quantificados.",
                                "Análise crítica: identifica cenários de falha forward apesar de backward.",
                                "Clareza na comunicação: gráficos e resumos concisos."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em NumPy/SciPy para análise de erros.",
                                "Física Computacional: Estabilidade em simulações de dinâmica molecular (e.g., forças perturbadas).",
                                "Engenharia: Análise de sensibilidade em controle de sistemas lineares.",
                                "Estatística: Propagação de erros em regressão linear múltipla.",
                                "Ciência de Dados: Validação de modelos em ML com features correlacionadas."
                              ],
                              "realWorldApplication": "Em simulações CFD (Computational Fluid Dynamics), analisar backward stability garante que discretizações de Navier-Stokes produzem soluções exatas de equações perturbadas por arredondamento, enquanto forward stability é crucial para predições precisas em engenharia aeroespacial, evitando erros catastróficos em condições turbulentas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.3",
                            "name": "Simular propagação de erros em código",
                            "description": "Implementar em software (ex: MATLAB ou Python) a resolução de sistemas com diferentes níveis de precisão flutuante, medindo e plotando a propagação de erros de arredondamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente e selecionar um sistema de equações lineares",
                                  "subSteps": [
                                    "Instale bibliotecas necessárias: NumPy e Matplotlib no Python (ou equivalente no MATLAB).",
                                    "Escolha um sistema de equações lineares ill-condicionado, como A = [[1, 1, 1], [1, 2, 3], [1, 3, 6]] com b = [3, 6, 10].",
                                    "Calcule a solução exata analiticamente ou com precisão infinita para referência.",
                                    "Defina níveis de precisão flutuante: double (64-bit), single (32-bit) e half (16-bit) usando np.float64, np.float32, np.float16.",
                                    "Armazene a matriz A e vetor b em diferentes tipos de precisão."
                                  ],
                                  "verification": "Confirme que o ambiente roda sem erros e que as matrizes são criadas corretamente imprimindo shapes e tipos de dados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com NumPy, Matplotlib; ou MATLAB; notebook Jupyter.",
                                  "tips": "Use Jupyter Notebook para interatividade e visualização imediata.",
                                  "learningObjective": "Entender como preparar dados numéricos com diferentes precisões para análise de estabilidade.",
                                  "commonMistakes": "Escolher sistemas bem-condicionados que não mostrem propagação clara de erros."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar resolução de sistemas com diferentes precisões",
                                  "subSteps": [
                                    "Implemente np.linalg.solve(A, b) para cada tipo de precisão flutuante.",
                                    "Repita a resolução com ruído adicionado ao vetor b (ex: 1e-10 * randn).",
                                    "Salve as soluções aproximadas em um dicionário ou array para comparação.",
                                    "Calcule o tempo de execução para cada precisão usando timeit.",
                                    "Registre resíduos normais ||Ax - b|| para validar soluções."
                                  ],
                                  "verification": "Execute o código e verifique que soluções são geradas para todos os níveis de precisão sem exceções.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código Python/MATLAB do Step 1; funções linalg.solve ou \\.",
                                  "tips": "Evite operações desnecessárias que possam introduzir erros extras.",
                                  "learningObjective": "Dominar a resolução numérica de sistemas lineares em múltiplas precisões.",
                                  "commonMistakes": "Não converter corretamente os tipos de precisão, levando a casts automáticos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Medir erros de arredondamento e propagação",
                                  "subSteps": [
                                    "Calcule erros relativos: ||x_approx - x_exact|| / ||x_exact|| para cada precisão.",
                                    "Meça a condição da matriz cond(A) em cada precisão.",
                                    "Simule propagação adicionando ruído crescente a b e meça sensibilidade.",
                                    "Registre estatísticas: média, desvio padrão dos erros sobre múltiplas runs.",
                                    "Compare com teoria: erro ≈ cond(A) * eps * ||x||."
                                  ],
                                  "verification": "Imprima tabela de erros mostrando aumento com precisão reduzida.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Soluções do Step 2; funções np.linalg.cond, np.linalg.norm.",
                                  "tips": "Use loops para múltiplas simulações estocásticas para robustez.",
                                  "learningObjective": "Quantificar matematicamente a propagação de erros de arredondamento.",
                                  "commonMistakes": "Confundir erro absoluto com relativo ou ignorar normalização."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar e analisar resultados da propagação de erros",
                                  "subSteps": [
                                    "Crie gráfico de erro relativo vs. precisão (log-log scale).",
                                    "Plote resíduos e cond(A) no mesmo gráfico para correlação.",
                                    "Gere plot de solução exata vs. aproximadas para visualização.",
                                    "Adicione legendas, títulos e anotações destacando picos de erro.",
                                    "Salve plots como PNG/PDF e interprete: explique por que erros crescem."
                                  ],
                                  "verification": "Visualize plots confirmando que erros aumentam com precisão menor e ruído.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Matplotlib ou MATLAB plotting; dados do Step 3.",
                                  "tips": "Use plt.loglog() para escalas adequadas a erros numéricos.",
                                  "learningObjective": "Visualizar e interpretar numericamente a estabilidade de soluções.",
                                  "commonMistakes": "Escalas lineares que mascaram diferenças em erros pequenos."
                                }
                              ],
                              "practicalExample": "Para o sistema A x = b com A = [[1e20, 1], [1, 1e-20]], b = [1, 2], em float16 o erro relativo explode para >1e5 devido à condição κ(A)≈1e40, enquanto em float64 fica <1e-10. Plot mostra colapso da precisão em baixa precisão.",
                              "finalVerifications": [
                                "Código executa sem erros para todas as precisões.",
                                "Erros relativos aumentam monotonicamente com precisão reduzida.",
                                "Plots exibem claramente propagação de erros com legenda e escalas adequadas.",
                                "Condição da matriz correlaciona com magnitude dos erros.",
                                "Resíduos ||Ax - b|| são pequenos para precisões altas.",
                                "Interpretação escrita explica resultados com referência à teoria."
                              ],
                              "assessmentCriteria": [
                                "Correção na implementação de precisões flutuantes (tipos de dados).",
                                "Precisão dos cálculos de erro relativo e condição da matriz.",
                                "Qualidade visual e informativa dos plots (escalas, labels).",
                                "Análise quantitativa alinhada com teoria de propagação de erros.",
                                "Eficiência do código (tempo de execução e clareza).",
                                "Robustez: testes com ruído e múltiplas execuções."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso avançado de NumPy/SciPy para computação científica.",
                                "Estatística: Análise de variância em erros estocásticos.",
                                "Física/Engenharia: Simulações numéricas em modelagem diferencial.",
                                "Ciência da Computação: Análise de complexidade numérica e floating-point.",
                                "Matemática Discreta: Teoria de perturbações e análise de sensibilidade."
                              ],
                              "realWorldApplication": "Em simulações de engenharia aeroespacial (ex: NASA usa MATLAB para modelar órbitas), onde erros de arredondamento em precisão single podem invalidar trajetórias; ou em finanças quantitativas, prevendo falhas em solvers de risco com dados de alta dimensão."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.3",
                        "name": "Estabilidade Numérica de Decomposições",
                        "description": "Comparação da robustez numérica de métodos diretos como LU, QR e SVD na resolução de sistemas lineares, focando na minimização de erros de arredondamento.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.3.1",
                            "name": "Comparar estabilidade da fatoração LU com pivoteamento",
                            "description": "Analisar como o pivoteamento parcial mitiga o crescimento de elementos durante a eliminação gaussiana, avaliando o fator de crescimento ρ = max |l_{ij}|.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Decomposição LU sem Pivoteamento",
                                  "subSteps": [
                                    "Explicar o processo de eliminação gaussiana para obter L e U.",
                                    "Realizar decomposição LU manualmente em uma matriz 3x3 triangular inferior dominante.",
                                    "Identificar os multiplicadores l_ij gerados durante a eliminação.",
                                    "Verificar que A = L * U.",
                                    "Discutir premissas de pivôs não-nulos."
                                  ],
                                  "verification": "Decompor corretamente uma matriz dada e confirmar A = L * U com erro < 1e-10.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software NumPy ou MATLAB para verificação"
                                  ],
                                  "tips": "Comece com matrizes pequenas e bem condicionadas para evitar divisões por zero.",
                                  "learningObjective": "Compreender o algoritmo básico de LU e os multiplicadores l_ij.",
                                  "commonMistakes": [
                                    "Ignorar a unitaridade da diagonal de L",
                                    "Confundir ordem de eliminação",
                                    "Não verificar recomposição A = L*U"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Instabilidade e Crescimento sem Pivoteamento",
                                  "subSteps": [
                                    "Escolher matrizes com pivôs pequenos na diagonal principal.",
                                    "Executar eliminação gaussiana e observar o crescimento de |l_ij| e elementos de U.",
                                    "Calcular o fator de crescimento ρ = max |l_ij| para diferentes matrizes.",
                                    "Medir o condicionamento da matriz original vs. elementos finais.",
                                    "Simular erros de arredondamento propagados."
                                  ],
                                  "verification": "Identificar ρ > 1 em pelo menos dois exemplos e explicar impacto na precisão.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Matrizes de exemplo problemáticas (ex: Hilbert 5x5)",
                                    "Python com NumPy para simulações"
                                  ],
                                  "tips": "Use precisão finita (float32) para simular erros reais de máquina.",
                                  "learningObjective": "Reconhecer como crescimento excessivo leva a instabilidade numérica.",
                                  "commonMistakes": [
                                    "Subestimar propagação de erros",
                                    "Usar matrizes simétricas positivas definidas",
                                    "Confundir ρ com norma da matriz"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir Pivoteamento Parcial e seu Mecanismo",
                                  "subSteps": [
                                    "Descrever o algoritmo de pivoteamento parcial: trocar linhas para maximizar pivô na coluna.",
                                    "Implementar LU com pivoteamento parcial em uma matriz instável.",
                                    "Comparar multiplicadores l_ij antes e depois do pivoteamento.",
                                    "Calcular novo ρ e observar redução.",
                                    "Verificar estabilidade com forward/backward substitution."
                                  ],
                                  "verification": "Aplicar pivoteamento a uma matriz e obter ρ ≤ n (dimensão da matriz).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python para LU com pivot (SciPy lu_factor)",
                                    "Matrizes de teste"
                                  ],
                                  "tips": "Registre a permutação P para A = P*L*U.",
                                  "learningObjective": "Dominar como pivoteamento parcial controla o crescimento de elementos.",
                                  "commonMistakes": [
                                    "Esquecer de aplicar permutação na verificação",
                                    "Pivotear apenas uma vez",
                                    "Não normalizar l_ij <1"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Estabilidade Quantitativamente",
                                  "subSteps": [
                                    "Selecionar matrizes representativas e computar ρ com/sem pivoteamento.",
                                    "Avaliar erro relativo na solução de Ax=b com ruído.",
                                    "Plotar ρ vs. tamanho da matriz para diferentes estratégias.",
                                    "Discutir teorema de bounded growth (ρ ≤ 2n-1 com pivot parcial).",
                                    "Concluir vantagens em termos de precisão e custo computacional."
                                  ],
                                  "verification": "Gerar tabela comparativa de ρ e erro relativo para 3 matrizes.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Jupyter Notebook",
                                    "Bibliotecas NumPy/SciPy/MATLAB"
                                  ],
                                  "tips": "Use matrizes de Galerkin ou Vandermonde para testes extremos.",
                                  "learningObjective": "Quantificar superioridade da LU com pivoteamento.",
                                  "commonMistakes": [
                                    "Ignorar custo extra do pivot (O(n) por coluna)",
                                    "Comparar com QR em vez de LU pura",
                                    "Não considerar erros de arredondamento"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a matriz A = [[1, 1, 1], [10^{-10}, 1, 1], [1, 1, 10^{-10}]]. Sem pivoteamento, ρ ≈ 10^{10} devido a crescimento explosivo em l_{32}. Com pivoteamento parcial, ρ ≈ 2, mantendo estabilidade e precisão na solução de Ax=b.",
                              "finalVerifications": [
                                "Explicar mecanismo de mitigação do crescimento pelo pivoteamento parcial.",
                                "Calcular ρ corretamente para uma matriz 4x4 dada sem e com pivot.",
                                "Simular erro em solução com ruído e comparar precisão relativa.",
                                "Citar bound teórico ρ ≤ 2n-1.",
                                "Implementar LU com pivot em código e verificar.",
                                "Discutir trade-offs computacionais."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de ρ (erro < 1e-6).",
                                "Correta identificação de crescimento em exemplos sem pivot.",
                                "Explicação clara do algoritmo de pivoteamento parcial.",
                                "Análise quantitativa comparativa com evidências numéricas.",
                                "Compreensão de impactos em erros de arredondamento.",
                                "Uso adequado de teoremas e bounds teóricos."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em Python/NumPy para solvers lineares.",
                                "Engenharia Computacional: Estabilidade em simulações FEM/CFD.",
                                "Ciência de Dados: Pré-condicionadores em métodos iterativos para ML.",
                                "Física Computacional: Modelagem de sistemas dinâmicos lineares."
                              ],
                              "realWorldApplication": "Em softwares de simulação como COMSOL ou ANSYS, a LU com pivoteamento garante soluções estáveis para sistemas lineares massivos em análises estruturais e fluidodinâmica, evitando falhas por overflow/underflow em hardware de precisão limitada."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.2",
                            "name": "Avaliar estabilidade da decomposição QR",
                            "description": "Demonstrar a backward stability da QR via Householder ou Givens, com ||ΔR|| / ||R|| ≤ O(n u) e impacto mínimo na solução de sistemas triangulares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Decomposição QR e Estabilidade Numérica",
                                  "subSteps": [
                                    "Relembrar a decomposição QR: A = QR onde Q é ortogonal (Q^T Q = I) e R é triangular superior.",
                                    "Definir estabilidade forward (erro na saída) versus backward (solução exata para dados perturbados).",
                                    "Explicar machine epsilon u ≈ 10^{-16} para double precision e acumulação de erros O(n u).",
                                    "Discutir por que QR é preferida para sistemas lineares sobre decomposição LU."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras definindo backward stability e seu papel na QR.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro 'Matrix Computations' de Golub-Van Loan (Cap. 5)",
                                    "Notas de aula sobre álgebra numérica"
                                  ],
                                  "tips": "Use diagramas para visualizar Q e R.",
                                  "learningObjective": "Compreender os conceitos pré-requisitos de estabilidade e QR.",
                                  "commonMistakes": "Confundir estabilidade forward (saída direta) com backward (dados perturbados)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Reflexões Householder e Rotações Givens para QR",
                                  "subSteps": [
                                    "Derivar reflexão Householder: v = x - α e_1, H = I - 2vv^T / ||v||^2 para zerar subdiagonal.",
                                    "Implementar Householder em pseudocódigo para uma coluna de A.",
                                    "Comparar com rotação Givens: G = [c s; -s c] para zerar elemento específico.",
                                    "Aplicar sequencialmente para obter QR completa, notando complexidade O(n^2) por passo.",
                                    "Verificar ortogonalidade: H^T H = I numericamente."
                                  ],
                                  "verification": "Aplique Householder manualmente a uma matriz 3x3 e verifique Q ortogonal.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy ou MATLAB",
                                    "Referência: Golub-Van Loan Sec. 5.1-5.2"
                                  ],
                                  "tips": "Comece com matrizes pequenas (2x2 ou 3x3) para depuração.",
                                  "learningObjective": "Dominar os transformadores ortogonais usados na QR.",
                                  "commonMistakes": "Esquecer normalização em Householder, levando a ||H|| ≠ 1."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar Backward Stability da QR com Bounds",
                                  "subSteps": [
                                    "Estudar teorema: QR computada satisfaz (Q + ΔQ)(R + ΔR) = A + ΔA com ||ΔA||_F ≤ O(n u) ||A||_F.",
                                    "Derivar bound específico para R: ||ΔR|| / ||R|| ≤ O(n u) via análise de crescimento de elementos.",
                                    "Comparar estabilidade de Householder (estável) vs. Givens (similar, mas mais rotações).",
                                    "Analisar propagação de erros em cada aplicação de H ou G.",
                                    "Simular numericamente: compute QR de A perturbada e compare."
                                  ],
                                  "verification": "Reproduza o outline da prova para ||ΔR|| / ||R|| ≤ O(n u) em um caderno.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel e lápis para derivações",
                                    "Código Python/MATLAB para simulação",
                                    "Higham 'Accuracy and Stability of Num. Alg.' Cap. 10"
                                  ],
                                  "tips": "Use norma Frobenius para simplicidade nas bounds.",
                                  "learningObjective": "Provar e quantificar a backward stability da QR.",
                                  "commonMistakes": "Ignorar fator O(n) de crescimento linear em n."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Impacto na Solução de Sistemas Triangulares via QR",
                                  "subSteps": [
                                    "Resolver Ax = b como QR x = b → R x = Q^T b (back-substitution).",
                                    "Mostrar que perturbações ΔR levam a erro relativo pequeno se cond(R) ≈ cond(A).",
                                    "Simular: adicione ruído O(n u) a R e meça erro em x.",
                                    "Comparar com estabilidade de solve triangular: O(n u) cond(R).",
                                    "Concluir que QR preserva estabilidade para least squares e sistemas."
                                  ],
                                  "verification": "Execute simulação numérica e confirme ||Δx|| / ||x|| ≤ O(n u) cond(A).",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código NumPy/MATLAB com qr() e np.linalg.solve",
                                    "Matriz ill-condicionada como Hilbert"
                                  ],
                                  "tips": "Use cond() para verificar conditioning.",
                                  "learningObjective": "Entender como estabilidade de QR afeta soluções práticas.",
                                  "commonMistakes": "Confundir cond(A) com cond(R); R herda conditioning de A."
                                }
                              ],
                              "practicalExample": "Para A = [[1,1],[1,1+1e-10]], compute QR via Householder. Perturbe A por ΔA com ||ΔA||/||A||=1e-15. Verifique que QR perturbada é backward estável e solve Rx = Q^T b dá x com erro < 1e-12.",
                              "finalVerifications": [
                                "Enuncie corretamente o bound ||ΔR|| / ||R|| ≤ O(n u).",
                                "Explique diferença entre Householder e Givens em estabilidade.",
                                "Simule QR em matriz 10x10 e confirme ortogonalidade ||I - Q^T Q|| < 1e-14.",
                                "Resolva sistema com R perturbado e meça erro relativo.",
                                "Discuta quando QR falha (e.g., A rank-deficient)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação do bound de estabilidade (90%+ correto).",
                                "Correção de implementações numéricas (erros < 1e-12).",
                                "Profundidade na análise de substeps (todos cobertos com exemplos).",
                                "Clareza em verificações e simulações.",
                                "Integração de teoria com prática numérica.",
                                "Identificação correta de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Algoritmos numéricos em bibliotecas como LAPACK.",
                                "Física Computacional: Simulações de dinâmica molecular com QR para projeções.",
                                "Engenharia: Otimização em controle de sistemas lineares.",
                                "Estatística: Regressão linear least-squares estável."
                              ],
                              "realWorldApplication": "Em machine learning, QR estabiliza soluções de mínimos quadrados para treinamento de modelos lineares (e.g., ridge regression em grandes datasets do Google ou NASA), evitando amplificação de ruído em dados reais com erros de medição."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.3",
                            "name": "Utilizar SVD para análise de sensibilidade",
                            "description": "Aplicar decomposição em valores singulares para quantificar sensibilidade em sistemas mal condicionados, identificando direções de máxima e mínima sensibilidade via vetores singulares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de SVD e Condicionamento de Matrizes",
                                  "subSteps": [
                                    "Estude a definição de SVD: A = U Σ V^T, onde U e V são ortogonais, Σ diagonal com valores singulares σ1 ≥ σ2 ≥ ... ≥ σn ≥ 0.",
                                    "Revise o número de condição cond(A) = σ1 / σn e seu significado para sistemas mal condicionados (cond >> 1).",
                                    "Entenda como valores singulares pequenos indicam direções de alta sensibilidade.",
                                    "Discuta a relação entre SVD e norma 2: ||A||_2 = σ1, e pseudoinversa.",
                                    "Pratique com matriz 2x2 simples manualmente."
                                  ],
                                  "verification": "Resuma em um parágrafo os componentes do SVD e explique verbalmente o impacto de σ_min na sensibilidade.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Álgebra Linear Numérica (ex: Golub & Van Loan)",
                                    "Notebook com Python/NumPy",
                                    "Papel e calculadora"
                                  ],
                                  "tips": "Comece com matrizes pequenas para intuição; visualize U, Σ, V como rotações e escalas.",
                                  "learningObjective": "Compreender a estrutura SVD e sua ligação com sensibilidade numérica.",
                                  "commonMistakes": [
                                    "Confundir valores singulares com autovalores",
                                    "Ignorar ordenação decrescente dos σ_i",
                                    "Esquecer que SVD existe para qualquer matriz retangular"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar SVD de uma Matriz Representativa",
                                  "subSteps": [
                                    "Selecione uma matriz A mal condicionada (ex: Hilbert 4x4 ou matriz de Vandermonde).",
                                    "Use software para calcular U, Σ, V (NumPy: np.linalg.svd(A, full_matrices=True)).",
                                    "Verifique a reconstrução: np.allclose(A, U @ np.diag(s) @ V.T).",
                                    "Extraia valores singulares e vetores singulares direitos/esquerdos.",
                                    "Calcule cond(A) = s[0]/s[-1]."
                                  ],
                                  "verification": "Execute o código e confirme que a reconstrução tem erro < 1e-10; imprima Σ e cond(A).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy e Matplotlib",
                                    "Jupyter Notebook",
                                    "Matrizes de teste pré-definidas"
                                  ],
                                  "tips": "Use full_matrices=False para eficiência em matrizes grandes; plote Σ para visualização.",
                                  "learningObjective": "Dominar o cálculo prático de SVD usando ferramentas computacionais.",
                                  "commonMistakes": [
                                    "Não verificar reconstrução",
                                    "Usar SVD econômico incorretamente",
                                    "Arredondamento em cálculos manuais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar Vetores Singulares para Direções de Sensibilidade",
                                  "subSteps": [
                                    "Identifique direção máxima sensibilidade: vetor singular direito v1 (maior σ1).",
                                    "Direção mínima sensibilidade: vn (menor σn).",
                                    "Analise perturbações: δx ≈ (1/σn) * ||u_n|| * δb em Ax=b.",
                                    "Visualize com plot: colunas de V como eixos sensíveis.",
                                    "Compare com autovalores para matrizes quadradas simétricas."
                                  ],
                                  "verification": "Descreva as direções max/min para sua matriz e justifique com σ_i; plote vetores.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Matplotlib para plots",
                                    "Notebook anterior",
                                    "Documentação NumPy SVD"
                                  ],
                                  "tips": "Pense em V como base ortonormal adaptada à matriz; teste com pequenas perturbações.",
                                  "learningObjective": "Interpretar SVD para quantificar e localizar sensibilidade direcional.",
                                  "commonMistakes": [
                                    "Confundir vetores esquerdos/direitos",
                                    "Ignorar normalização",
                                    "Não relacionar com norma de perturbações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar SVD à Análise de Sensibilidade em Sistemas Lineares",
                                  "subSteps": [
                                    "Considere Ax = b mal condicionado; resolva x = A^+ b via pseudoinversa de SVD.",
                                    "Quantifique sensibilidade: ||δx|| / ||x|| ≈ cond(A) * ||δb|| / ||b||.",
                                    "Simule ruído em direções v1 e vn; meça amplificação.",
                                    "Regeneração regularizada: SVD truncado para reduzir sensibilidade.",
                                    "Documente relatório com gráficos de erro vs. ruído."
                                  ],
                                  "verification": "Gere relatório mostrando amplificação em direção mínima > 100x; compare com solução direta.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python expandido",
                                    "Exemplo de matriz estrutural ou de sinais"
                                  ],
                                  "tips": "Use np.linalg.pinv para pseudoinversa; adicione ruído gaussiano controlado.",
                                  "learningObjective": "Aplicar SVD para análise prática de estabilidade numérica em equações lineares.",
                                  "commonMistakes": [
                                    "Não escalar perturbações adequadamente",
                                    "Usar solver direto sem SVD para comparação",
                                    "Esquecer regularização em σ pequenos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em engenharia aeroespacial, aplique SVD à matriz de rigidez de uma asa deformável para identificar modos de vibração sensíveis a fabricação imprecisa: direções de máxima sensibilidade (v1) guiam tolerâncias de design, minimizando falhas estruturais.",
                              "finalVerifications": [
                                "SVD computada corretamente com reconstrução precisa.",
                                "Número de condição calculado e interpretado (>10^3 indica mal condicionado).",
                                "Direções max/min sensibilidade identificadas via v1 e vn.",
                                "Simulação de perturbações confirma amplificação teórica.",
                                "Relatório inclui plots de vetores singulares e erros.",
                                "Pseudoinversa usada para solução estável."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos SVD (erro <1e-12).",
                                "Correta interpretação de sensibilidade direcional.",
                                "Uso apropriado de software com verificações.",
                                "Análise qualitativa/quantitativa de exemplos.",
                                "Clareza no relatório com visualizações.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia: Análise de estruturas e controle.",
                                "Ciência de Dados: Redução de dimensionalidade (PCA via SVD).",
                                "Física Computacional: Modos normais em dinâmica.",
                                "Processamento de Sinais: Compressão e denoising.",
                                "Machine Learning: Regularização em regressão."
                              ],
                              "realWorldApplication": "Na indústria farmacêutica, SVD analisa sensibilidade em modelos de difusão de drogas em tecidos mal condicionados, identificando parâmetros críticos para otimizar formulações e reduzir incertezas em simulações clínicas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.5",
                    "name": "Uso da Decomposição SVD na Sensibilidade",
                    "description": "Aplicação da decomposição em valores singulares para diagnosticar condicionamento e sensibilidade de sistemas Ax=b.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.5.1.1",
                        "name": "Decomposição em Valores Singulares (SVD)",
                        "description": "Representação de uma matriz A como A = U Σ V^T, onde U e V são matrizes ortogonais e Σ é diagonal com valores singulares não-negativos em ordem decrescente, fundamental para análise numérica estável.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.1.1.1",
                            "name": "Identificar componentes da SVD",
                            "description": "Reconhecer e descrever os papéis de U, Σ e V^T na decomposição SVD de uma matriz retangular m x n, incluindo propriedades ortogonais de U e V.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a forma geral da decomposição SVD",
                                  "subSteps": [
                                    "Revise a definição de SVD para uma matriz retangular A de tamanho m x n: A = U Σ V^T.",
                                    "Identifique as dimensões: U é m x m, Σ é m x n diagonal, V^T é n x n.",
                                    "Entenda que SVD generaliza a decomposição em autovalores para matrizes não quadradas.",
                                    "Esboce um exemplo visual de uma matriz 2x3 e suas componentes.",
                                    "Memorize que os valores singulares em Σ são não-negativos e ordenados decrescentemente."
                                  ],
                                  "verification": "Escreva a equação SVD completa com dimensões corretas para uma matriz 3x2.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou quadro branco",
                                    "Calculadora ou software como MATLAB/Octave",
                                    "Referência: Livro de Álgebra Linear (ex: Strang)"
                                  ],
                                  "tips": [
                                    "Use diagramas para visualizar as multiplicações matriciais.",
                                    "Comece com matrizes pequenas para intuição."
                                  ],
                                  "learningObjective": "Reconhecer a estrutura e dimensões dos componentes SVD.",
                                  "commonMistakes": [
                                    "Confundir dimensões de U e V.",
                                    "Esquecer que Σ é retangular para m ≠ n."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o papel e propriedades de U",
                                  "subSteps": [
                                    "Defina U como matriz ortogonal m x m: colunas são vetores singulares esquerdos.",
                                    "Verifique ortogonalidade: U^T U = I_m.",
                                    "Entenda que U captura a base ortonormal para o espaço-coluna de A.",
                                    "Calcule U para uma matriz simples usando software.",
                                    "Discuta como U rotaciona/reflete o espaço de entrada."
                                  ],
                                  "verification": "Prove que U^T U = I para uma SVD conhecida e descreva seu papel geométrico.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software NumPy/Python ou MATLAB",
                                    "Matriz de exemplo 2x2",
                                    "Notas sobre ortogonalidade"
                                  ],
                                  "tips": [
                                    "Pense em U como uma rotação no espaço de linhas de A.",
                                    "Use svd() em Python para validar."
                                  ],
                                  "learningObjective": "Descrever funções e propriedades ortogonais de U.",
                                  "commonMistakes": [
                                    "Confundir U com autovetores de A A^T.",
                                    "Ignorar que U é quadrada mesmo se A não for."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o papel e estrutura de Σ",
                                  "subSteps": [
                                    "Identifique Σ como matriz diagonal m x n com valores singulares σ_i ≥ 0 na diagonal.",
                                    "Explique que σ_i = sqrt(autovalores de A A^T ou A^T A).",
                                    "Discuta ordenação decrescente e zeros para ranks menores.",
                                    "Calcule os valores singulares de uma matriz exemplo.",
                                    "Entenda o papel de Σ na 'escala' ou alongamento dos eixos singulares."
                                  ],
                                  "verification": "Liste os valores singulares de uma matriz 3x2 e explique sua relação com o rank.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora matricial",
                                    "Exemplos de matrizes com ranks diferentes",
                                    "Tabela de SVD pré-computada"
                                  ],
                                  "tips": [
                                    "Valores singulares pequenos indicam direção de pouca importância.",
                                    "Ordene sempre σ1 ≥ σ2 ≥ ..."
                                  ],
                                  "learningObjective": "Reconhecer Σ como os 'ganhos' singulares e suas propriedades.",
                                  "commonMistakes": [
                                    "Permitir valores negativos em Σ.",
                                    "Confundir Σ com autovalores diretos de A."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar V^T e integrar propriedades ortogonais",
                                  "subSteps": [
                                    "Defina V como matriz ortogonal n x n: colunas são vetores singulares direitos.",
                                    "Verifique V^T V = I_n e role de V^T na rotação do espaço-coluna.",
                                    "Integre: A = U (Σ V^T) ou (U Σ) V^T para compreensão.",
                                    "Verifique reconstrução: multiplique componentes para recuperar A.",
                                    "Resuma propriedades: U e V preservam normas (isometrias)."
                                  ],
                                  "verification": "Reconstrua uma matriz A a partir de U, Σ, V^T e confirme ||A x|| = ||Σ V^T x|| para vetores.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software para SVD (svd(A) em Python)",
                                    "Matriz exemplo completa",
                                    "Gráficos de vetores singulares"
                                  ],
                                  "tips": [
                                    "V captura o espaço de A^T.",
                                    "Sempre teste multiplicação U Σ V^T == A."
                                  ],
                                  "learningObjective": "Descrever V^T e propriedades ortogonais conjuntas de U e V.",
                                  "commonMistakes": [
                                    "Esquecer o transposto em V^T.",
                                    "Não verificar ortogonalidade numericamente."
                                  ]
                                }
                              ],
                              "practicalExample": "Para a matriz A = [[3, 0], [0, 2]] (2x2), SVD é U = I_2, Σ = [[3,0],[0,2]], V^T = I_2. U e V rotacionam identidade, Σ escala eixos. Para A = [[1,2],[3,4],[5,6]] (3x2), compute svd(A) no Python: U (3x3), Σ (3x2), V^T (2x2); verifique A ≈ U @ Σ @ V.T.",
                              "finalVerifications": [
                                "Explique verbalmente os papéis de U, Σ, V^T em 1 minuto.",
                                "Escreva dimensões corretas para SVD de m x n arbitrária.",
                                "Reconstrua A de componentes SVD com erro < 1e-10.",
                                "Identifique propriedades ortogonais: U^T U = I, V^T V = I.",
                                "Liste 3 aplicações da SVD baseadas nos componentes.",
                                "Diferencie SVD de EVD para matrizes não quadradas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição dimensional e equação SVD (20%)",
                                "Correta identificação de papéis geométricos/álgebraicos (25%)",
                                "Demonstração de ortogonalidade com prova ou exemplo (20%)",
                                "Explicação de valores singulares e ordenação (15%)",
                                "Integração e reconstrução prática (10%)",
                                "Uso correto de terminologia (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Redução de dimensionalidade em PCA/ML.",
                                "Física: Modos normais em vibrações (vetores singulares).",
                                "Engenharia: Análise de estabilidade em sistemas lineares.",
                                "Estatística: Análise de componentes principais via SVD."
                              ],
                              "realWorldApplication": "Na compressão de imagens (JPEG), Σ permite truncar valores singulares pequenos para aproximar A com menos dados; em sistemas de recomendação (Netflix), SVD fatoriza matrizes usuário-item para prever preferências, com U/Σ/V capturando latente factors."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.1.2",
                            "name": "Calcular SVD para matrizes pequenas",
                            "description": "Realizar o cálculo manual da SVD para matrizes 2x2 ou 3x3, determinando valores singulares via autovalores de A^T A e autovetores correspondentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a matriz e calcular AᵀA",
                                  "subSteps": [
                                    "Escolha ou defina uma matriz A de tamanho 2x2 ou 3x3.",
                                    "Calcule a transposta Aᵀ manualmente, trocando linhas por colunas.",
                                    "Multiplique Aᵀ por A para obter a matriz simétrica AᵀA.",
                                    "Verifique se AᵀA é simétrica (AᵀA = (AᵀA)ᵀ).",
                                    "Anote os elementos de AᵀA com precisão decimal ou fracionária."
                                  ],
                                  "verification": "Confirme que AᵀA é simétrica e todos os cálculos de multiplicação estão corretos comparando com uma calculadora.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora básica para verificação",
                                    "Matriz A exemplo impressa"
                                  ],
                                  "tips": "Use frações exatas para evitar erros de arredondamento precoce.",
                                  "learningObjective": "Dominar o cálculo de transposta e produto matricial para obter AᵀA.",
                                  "commonMistakes": [
                                    "Confundir transposta com inversa",
                                    "Erros em índices durante multiplicação",
                                    "Arredondar prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular autovalores de AᵀA",
                                  "subSteps": [
                                    "Escreva a equação característica det(AᵀA - λI) = 0.",
                                    "Para 2x2: resolva o polinômio quadrático λ² - tr(AᵀA)λ + det(AᵀA) = 0.",
                                    "Para 3x3: resolva o polinômio cúbico ou use método de Cardano simplificado.",
                                    "Calcule as raízes λ₁ ≥ λ₂ ≥ ... (ordenadas decrescentes).",
                                    "Verifique somando as raízes iguais à traço de AᵀA."
                                  ],
                                  "verification": "As autovalores somam o traço de AᵀA e o produto é o determinante.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Tabela de fórmulas de autovalores",
                                    "Calculadora para raízes"
                                  ],
                                  "tips": "Ordene autovalores em ordem decrescente para Σ diagonal.",
                                  "learningObjective": "Resolver equações características para matrizes pequenas.",
                                  "commonMistakes": [
                                    "Erro no sinal da equação característica",
                                    "Não ordenar autovalores",
                                    "Confundir traço com determinante"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar autovetores direitos (V) e valores singulares (Σ)",
                                  "subSteps": [
                                    "Para cada λ_i, resolva (AᵀA - λ_i I)v_i = 0 para encontrar v_i.",
                                    "Normalizar v_i para ||v_i|| = 1.",
                                    "Forme a matriz V com colunas v_i ordenadas.",
                                    "Calcule σ_i = √λ_i para cada i.",
                                    "Construa Σ diagonal com σ_i na diagonal principal."
                                  ],
                                  "verification": "Verifique VᵀV = I (ortogonalidade) e Σ² = autovalores de AᵀA.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de fórmulas de normalização",
                                    "Calculadora para raízes quadradas"
                                  ],
                                  "tips": "Escolha sinal positivo para autovetores para consistência.",
                                  "learningObjective": "Calcular autovetores normalizados e valores singulares.",
                                  "commonMistakes": [
                                    "Não normalizar vetores",
                                    "Erros em sistemas lineares homogêneos",
                                    "Sinal inconsistente nos vetores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular autovetores esquerdos (U) e verificar a decomposição",
                                  "subSteps": [
                                    "Calcule u_i = (1/σ_i) A v_i para cada i.",
                                    "Normalizar u_i se necessário e forme U com colunas u_i.",
                                    "Verifique A = U Σ Vᵀ multiplicando as matrizes.",
                                    "Confirme ortogonalidade: UᵀU = I e VᵀV = I.",
                                    "Ajuste sinais se u_i · (A v_i / ||A v_i||) < 0."
                                  ],
                                  "verification": "Multiplicação U Σ Vᵀ resulta exatamente em A (com tolerância numérica mínima).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora matricial para verificação final",
                                    "Papel para multiplicações"
                                  ],
                                  "tips": "Use a relação u_i = A v_i / σ_i para eficiência.",
                                  "learningObjective": "Completar SVD e validar a decomposição.",
                                  "commonMistakes": [
                                    "Esquecer normalização de U",
                                    "Erros de sinal em U",
                                    "Não verificar A ≈ UΣVᵀ"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[3, 0], [0, 2]]: AᵀA = [[9,0],[0,4]], autovalores λ=9,4 → σ=3,2. V=I, U=I. SVD: A = [[3,0],[0,2]] [[3,0],[0,2]] Iᵀ. Verifique multiplicando.",
                              "finalVerifications": [
                                "AᵀA tem autovalores corretos e autovetores ortonormais.",
                                "Σ tem valores singulares √λ_i ordenados decrescentemente.",
                                "U e V são ortogonais (UᵀU = VᵀV = I).",
                                "A = U Σ Vᵀ exatamente.",
                                "Todos os vetores estão normalizados (norma euclidiana =1).",
                                "Sinais dos vetores são consistentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de AᵀA e autovalores (erro < 0.01).",
                                "Correta normalização e ortogonalidade de U e V.",
                                "Validação completa da decomposição SVD.",
                                "Eficiência nos subpassos (sem redundâncias).",
                                "Uso correto de frações exatas onde possível.",
                                "Identificação e correção de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação numérica em Python (numpy.linalg.svd).",
                                "Física: Análise de vibrações modais em mecânica.",
                                "Engenharia: Compressão de dados em processamento de sinais.",
                                "Estatística: Análise de componentes principais (PCA).",
                                "Machine Learning: Redução de dimensionalidade."
                              ],
                              "realWorldApplication": "Usado em compressão de imagens (JPEG), recomendação de sistemas (Netflix), análise de estabilidade em engenharia aeroespacial e resolução de sistemas lineares mal-condicionados em simulações científicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.1.1.3",
                            "name": "Interpretar valores singulares",
                            "description": "Explicar como os valores singulares indicam o 'ganho' das direções principais da matriz e sua relação com o rank e a invertibilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Decomposição SVD e identificar os valores singulares",
                                  "subSteps": [
                                    "Lembre-se da forma SVD: A = U Σ V^T, onde Σ é diagonal com valores singulares σ1 ≥ σ2 ≥ ... ≥ σ_min(m,n) ≥ 0.",
                                    "Compute ou visualize a matriz Σ para uma matriz exemplo usando software como Python (numpy.linalg.svd).",
                                    "Identifique os valores singulares não-nulos e ordene-os em ordem decrescente.",
                                    "Anote a posição dos zeros em Σ, se houver.",
                                    "Compare σi com as normas das colunas de U e V correspondentes."
                                  ],
                                  "verification": "Confirme que Σ foi corretamente extraída e os σi estão ordenados corretamente em uma matriz de teste.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software Python com NumPy e SciPy",
                                    "Matriz exemplo 2x2 ou 3x3"
                                  ],
                                  "tips": "Sempre ordene os valores singulares em ordem decrescente para facilitar a interpretação.",
                                  "learningObjective": "Compreender a estrutura da SVD e localizar os valores singulares na matriz Σ.",
                                  "commonMistakes": [
                                    "Confundir valores singulares com autovalores",
                                    "Não ordenar os σi corretamente",
                                    "Ignorar zeros em Σ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar valores singulares como 'ganhos' nas direções principais",
                                  "subSteps": [
                                    "Entenda que σi representa o fator de alongamento (ganho) aplicado pela matriz A na direção do vetor singular direito vi (coluna de V).",
                                    "Visualize geometricamente: A vi = σi ui, onde ui é coluna de U.",
                                    "Calcule ||A v|| / ||v|| para v = vi e verifique que é σi.",
                                    "Compare diferentes σi: σ1 é o maior ganho (direção de máxima estiramento), σ_min é o menor.",
                                    "Plote vetores antes e depois da transformação A para ilustrar."
                                  ],
                                  "verification": "Para um vi, compute A vi e confirme que ||A vi|| = σi ||vi|| assumindo ||vi||=1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python/MATLAB para computar SVD e plotar vetores",
                                    "Ferramenta de visualização como Matplotlib"
                                  ],
                                  "tips": "Pense em A como uma transformação elíptica: eixos definidos por V, comprimentos por Σ.",
                                  "learningObjective": "Associar cada σi ao ganho direcional específico da matriz.",
                                  "commonMistakes": [
                                    "Confundir ganho com direção de U em vez de V",
                                    "Esquecer normalização dos vetores singulares",
                                    "Interpretar σi como ângulo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar valores singulares com o rank da matriz",
                                  "subSteps": [
                                    "Defina rank(A) como o número de σi > 0 (ou tolerância numérica pequena).",
                                    "Conte os σi não-nulos em Σ para uma matriz rank-deficient.",
                                    "Verifique que rank(A) = dim(imagem(A)) = número de colunas não-nulas de Σ.",
                                    "Compare com rank por autovalores de A^T A (σi^2 são autovalores).",
                                    "Teste com matrizes de rank 1 e full rank."
                                  ],
                                  "verification": "Altere um σi para zero e confirme que rank cai usando np.linalg.matrix_rank().",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python NumPy para rank e SVD",
                                    "Exemplos de matrizes rank-deficient"
                                  ],
                                  "tips": "Use tolerância como 1e-10 para σi ≈ 0 em computação numérica.",
                                  "learningObjective": "Usar contagem de σi > 0 para determinar o rank.",
                                  "commonMistakes": [
                                    "Contar todos σi incluindo zeros",
                                    "Ignorar precisão numérica",
                                    "Confundir com dimensão de U ou V"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar invertibilidade e sensibilidade via valores singulares",
                                  "subSteps": [
                                    "Para A quadrada n x n, A invertível iff todos σi > 0 (rank n).",
                                    "Calcule o número de condição κ(A) = σ1 / σ_min para medir sensibilidade.",
                                    "Interprete: se σ_min pequeno, A é mal-condicionada (pequenos erros amplificados).",
                                    "Discuta pseudoinversa: usa 1/σi para σi > 0.",
                                    "Aplique a uma matriz quase singular e observe efeitos."
                                  ],
                                  "verification": "Verifique se σ_min > 0 implica det(A) ≠ 0 e κ(A) finito.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código para cond(A) e pseudoinversa",
                                    "Matrizes Hilbert ou Vandermonde mal-condicionadas"
                                  ],
                                  "tips": "κ(A) > 10^6 indica problemas numéricos graves.",
                                  "learningObjective": "Ligar σi à invertibilidade e estabilidade numérica.",
                                  "commonMistakes": [
                                    "Achar invertível se rank < n",
                                    "Confundir σ_min com det(A)",
                                    "Ignorar que κ usa σ1/σ_min"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[3, 0], [0, 1]]. SVD: σ1=3, σ2=1. σ1 indica ganho máximo na direção e1 (alonga por 3), σ2 ganho na e2 (por 1). Rank=2 (ambos >0), invertível. Se alterar para [[3,0],[0,0.001]], σ2=0.001 pequeno → mal-condicionada, sensível a perturbações.",
                              "finalVerifications": [
                                "Explique o significado de σ1 como ganho máximo.",
                                "Identifique rank a partir de Σ para uma matriz dada.",
                                "Diga quando A é invertível baseado em σi.",
                                "Calcule κ(A) e interprete seu valor.",
                                "Dê um exemplo onde σ_min pequeno causa problemas.",
                                "Relacione σi^2 com autovalores de A^T A."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de ganho direcional (correto para 80% dos σi).",
                                "Correta contagem de rank via σi > tolerância.",
                                "Explicação clara de invertibilidade (todos σi >0 para full rank).",
                                "Cálculo correto de κ(A) = σ_max / σ_min.",
                                "Uso de exemplo prático com interpretação numérica.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: PCA usa SVD para componentes principais (σi como variâncias).",
                                "Física: Modos normais de vibração (ganhos em direções principais).",
                                "Ciência da Computação: Compressão de imagens via truncada SVD.",
                                "Engenharia: Análise de estabilidade em sistemas lineares."
                              ],
                              "realWorldApplication": "Em processamento de imagens, valores singulares grandes retêm energia principal para compressão (ex: JPEG2000); em finanças, SVD analisa risco de portfólios via singular values para detectar direções de alta volatilidade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.1.2",
                        "name": "Número de Condição via SVD",
                        "description": "Medida de condicionamento cond(A) = σ₁ / σₙ, onde σ₁ é o maior e σₙ o menor valor singular, quantificando a sensibilidade da matriz a perturbações.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.1.2.1",
                            "name": "Calcular o número de condição",
                            "description": "Extrair σ_max e σ_min da decomposição Σ para computar cond(A) e cond(A^{-1}), comparando com normas 2.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Realizar a decomposição SVD da matriz A",
                                  "subSteps": [
                                    "Obtenha a matriz A do contexto do problema.",
                                    "Use uma biblioteca computacional como NumPy (Python) ou svd() no MATLAB para decompor A em U, Σ, V^T.",
                                    "Verifique se a decomposição é correta multiplicando U * Σ * V^T e comparando com A (erro < 1e-10).",
                                    "Armazene as matrizes resultantes.",
                                    "Registre os valores singulares em ordem decrescente."
                                  ],
                                  "verification": "Confirme que A ≈ U * Σ * V^T com norma do erro residual menor que 1e-12.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python com NumPy (np.linalg.svd), MATLAB ou calculadora simbólica como SymPy.",
                                  "tips": "Sempre use singular values em ordem decrescente; normalize se necessário.",
                                  "learningObjective": "Compreender e aplicar a decomposição SVD para extrair componentes singulares de uma matriz.",
                                  "commonMistakes": "Confundir ordem dos valores singulares ou não transpor V adequadamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair σ_max e σ_min da matriz diagonal Σ",
                                  "subSteps": [
                                    "Identifique a diagonal de Σ, que contém os valores singulares σ1 ≥ σ2 ≥ ... ≥ σn.",
                                    "Selecione σ_max = σ1 (maior valor) e σ_min = σn (menor valor não-zero).",
                                    "Confirme que σ_min > 0 para matrizes invertíveis.",
                                    "Registre os valores com precisão de pelo menos 6 casas decimais.",
                                    "Visualize Σ para garantir que está diagonal."
                                  ],
                                  "verification": "Liste explicitamente σ_max e σ_min e verifique se σ_max ≥ todos os outros σ_i ≥ σ_min.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Mesmos da Step 1; editor de código ou planilha para anotar valores.",
                                  "tips": "Ignore zeros em Σ para rank-deficient matrices, mas foque em σ_min > 0 aqui.",
                                  "learningObjective": "Identificar corretamente os valores singulares extremos para análise de condicionamento.",
                                  "commonMistakes": "Escolher σ_min como zero em matrizes cheias de rank ou inverter max/min."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar cond(A) e cond(A^{-1}) usando σ_max e σ_min",
                                  "subSteps": [
                                    "Calcule cond_2(A) = σ_max / σ_min.",
                                    "Note que para A^{-1}, os singulares são 1/σ_i, então cond_2(A^{-1}) = (1/σ_min) / (1/σ_max) = cond_2(A).",
                                    "Registre ambos os valores (devem ser iguais).",
                                    "Use precisão de ponto flutuante dupla para evitar erros de arredondamento.",
                                    "Compare com definição teórica: cond_2(A) = ||A||_2 * ||A^{-1}||_2."
                                  ],
                                  "verification": "Verifique se cond(A) = cond(A^{-1}) e se é um número positivo maior que 1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora ou código Python/MATLAB para divisão precisa.",
                                  "tips": "cond(A) ≥ 1 sempre; valores próximos de 1 indicam bom condicionamento.",
                                  "learningObjective": "Aplicar fórmula do número de condição via SVD e entender simetria com inversa.",
                                  "commonMistakes": "Esquecer que cond(A^{-1}) = cond(A) ou usar norma errada."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com número de condição via normas 2",
                                  "subSteps": [
                                    "Calcule ||A||_2 = σ_max diretamente da SVD.",
                                    "Compute A^{-1} usando inv(A) ou V * inv(Σ) * U^T.",
                                    "Calcule ||A^{-1}||_2 = 1 / σ_min.",
                                    "Verifique cond_2(A) = ||A||_2 * ||A^{-1}||_2 ≈ σ_max / σ_min.",
                                    "Quantifique a diferença (deve ser < 1e-10)."
                                  ],
                                  "verification": "A comparação deve mostrar igualdade numérica entre métodos SVD e normas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Bibliotecas np.linalg.norm ou norm() no MATLAB.",
                                  "tips": "Use np.linalg.norm(A, 2) para norma 2 exata.",
                                  "learningObjective": "Validar o cálculo SVD comparando com definição por normas.",
                                  "commonMistakes": "Usar norma 1 ou inf em vez de 2; erro em inversa."
                                }
                              ],
                              "practicalExample": "Para A = [[4, 1], [1, 4]], SVD dá Σ = diag(4.272, 3.728). Então σ_max=4.272, σ_min=3.728, cond(A)=1.146. cond(A^{-1})=1.146. Via normas: ||A||_2=4.272, ||A^{-1}||_2=0.268, produto=1.146 (igual).",
                              "finalVerifications": [
                                "σ_max e σ_min extraídos corretamente de Σ.",
                                "cond(A) = σ_max / σ_min calculado com precisão.",
                                "cond(A^{-1}) equals cond(A).",
                                "Comparação com normas 2 confirma igualdade (erro < 1e-10).",
                                "SVD reconstrói A com precisão alta.",
                                "Valores singulares em ordem decrescente."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos valores singulares (erro < 1e-8).",
                                "Correção da fórmula cond = σ_max / σ_min.",
                                "Validação de cond(A^{-1}).",
                                "Comparação válida com normas 2.",
                                "Explicação clara da relação teórica.",
                                "Uso adequado de ferramentas computacionais."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Estabilidade de algoritmos.",
                                "Machine Learning: Redução de dimensionalidade via SVD/PCA.",
                                "Engenharia Computacional: Modelagem de sistemas lineares.",
                                "Física: Simulações de dinâmica linear."
                              ],
                              "realWorldApplication": "Em engenharia estrutural, calcular cond via SVD avalia sensibilidade de matrizes de rigidez a erros de medição, prevenindo falhas em simulações de pontes ou edifícios onde condicionamento ruim amplifica erros de arredondamento em soluções de equações lineares."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.1.3"
                            ]
                          },
                          {
                            "id": "10.1.2.5.1.2.2",
                            "name": "Avaliar ill-condicionamento",
                            "description": "Diagnosticar matrizes mal condicionadas (cond(A) >> 1) usando valores singulares próximos de zero e discutir implicações numéricas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos de Decomposição SVD e Número de Condição",
                                  "subSteps": [
                                    "Explique a decomposição SVD: A = U Σ V^T, onde Σ contém valores singulares σ1 ≥ σ2 ≥ ... ≥ σn ≥ 0.",
                                    "Defina o número de condição cond(A) = σ1 / σn para matrizes quadradas invertíveis.",
                                    "Discuta que cond(A) >> 1 indica ill-condicionamento, com σn próximo de zero.",
                                    "Compare com norma 2: cond2(A) = ||A||2 * ||A^{-1}||2.",
                                    "Pratique com matriz identidade: cond(I) = 1 (bem condicionada)."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e calcule cond para uma matriz simples manualmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis; Notebook com Python/NumPy ou MATLAB.",
                                  "tips": "Lembre-se: valores singulares ordenados decrescentes facilitam identificação do menor σn.",
                                  "learningObjective": "Compreender a relação entre SVD e cond(A) para diagnóstico de condicionamento.",
                                  "commonMistakes": "Confundir σ1 (maior) com σn (menor); ignorar que SVD é para qualquer matriz."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Decomposição SVD de uma Matriz Exemplo",
                                  "subSteps": [
                                    "Escolha uma matriz A de 3x3 ou 2x2, ex: A = [[1,1],[1,1+ε]] com ε pequeno.",
                                    "Use software para computar SVD: em Python, np.linalg.svd(A, compute_uv=True).",
                                    "Extraia Σ e identifique σ_max = σ1 e σ_min = σn.",
                                    "Calcule cond(A) = σ1 / σn.",
                                    "Repita para ε variando de 10^{-1} a 10^{-10}."
                                  ],
                                  "verification": "Gere output com valores singulares e cond(A); plote σi vs i.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python com NumPy/SciPy; ou MATLAB; planilha para ε manual.",
                                  "tips": "Use full_matrices=False para eficiência em SVD numérica.",
                                  "learningObjective": "Executar SVD computacionalmente e extrair valores singulares relevantes.",
                                  "commonMistakes": "Não ordenar σi corretamente; usar norma errada (ex: Frobenius em vez de 2)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diagnosticar Ill-Condicionamento",
                                  "subSteps": [
                                    "Defina threshold: cond(A) > 10^6 ou 10^12 como ill-condicionado (depende da precisão máquina).",
                                    "Analise: se σn ≈ 0 ou σn / σ1 < 10^{-k}, marque como ill.",
                                    "Teste estabilidade: resolva Ax=b com b=Ax0 + ruído pequeno e verifique ||x - x0||.",
                                    "Compare múltiplas matrizes: uma bem condicionada vs ill.",
                                    "Documente diagnóstico em tabela: matriz, σn, cond(A), status."
                                  ],
                                  "verification": "Crie tabela com 3 matrizes diagnosticadas corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código Python/MATLAB estendido; exemplos de matrizes pré-definidas.",
                                  "tips": "Considere precisão de ponto flutuante (~10^{-16}) para thresholds realistas.",
                                  "learningObjective": "Aplicar critérios quantitativos para classificar condicionamento.",
                                  "commonMistakes": "Usar threshold fixo sem contexto numérico; ignorar simetria da matriz."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Implicações Numéricas do Ill-Condicionamento",
                                  "subSteps": [
                                    "Explique amplificação de erros: ||δx|| / ||x|| ≤ cond(A) * ||δb|| / ||b||.",
                                    "Discuta perda de precisão em solvers lineares (ex: Gaussian elimination).",
                                    "Sugira regularização: truncar SVD pequeno σi para pseudo-inversa.",
                                    "Analise impacto em aplicações: sensibilidade em otimização ou ML.",
                                    "Escreva relatório curto com exemplos numéricos de falha."
                                  ],
                                  "verification": "Redija 200 palavras sobre implicações com referência ao exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Documentos ou slides; referências como Golub-Van Loan.",
                                  "tips": "Ligue cond(A) diretamente a bound de erro relativo para clareza.",
                                  "learningObjective": "Interpretar cond(A) em termos de estabilidade numérica e soluções práticas.",
                                  "commonMistakes": "Subestimar impacto em hardware real; confundir ill-cond com singularidade."
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 1], [1, 1 + 10^{-10}]]. SVD dá σ1 ≈ √2, σ2 ≈ 10^{-10}, cond(A) ≈ 10^{10}. Resolver Ax = [2, 2]^T dá x impreciso devido a ruído de máquina, ilustrando perda de dígitos significativos.",
                              "finalVerifications": [
                                "Calcula corretamente cond(A) via SVD para 3 matrizes teste.",
                                "Identifica σn próximo de zero e classifica ill-condicionamento.",
                                "Demonstra amplificação de erro em simulação numérica.",
                                "Explica implicações em estabilidade de solvers lineares.",
                                "Propõe mitigação como SVD-truncada.",
                                "Documenta tudo em relatório coerente."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de SVD e cond(A) (90%+ correção).",
                                "Diagnóstico correto de ill-condicionamento com thresholds adequados.",
                                "Análise qualitativa/quantitativa de implicações numéricas.",
                                "Uso apropriado de software e verificação de resultados.",
                                "Clareza na discussão de erros e soluções práticas.",
                                "Conexão explícita entre teoria SVD e prática computacional."
                              ],
                              "crossCurricularConnections": [
                                "Computação Científica: Implementação em NumPy/SciPy para análise numérica.",
                                "Engenharia: Análise de sensibilidade em estruturas (matrizes de rigidez).",
                                "Machine Learning: Condicionamento em regressão linear e PCA.",
                                "Física Computacional: Estabilidade em simulações dinâmicas."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, matrizes de massa/rigidez ill-condicionadas causam erros em análises modais; SVD diagnostica e regulariza para simulações precisas de vibrações em aviões."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.1.2.3",
                            "name": "Comparar com outras decomposições",
                            "description": "Contrastar o condicionamento via SVD com o obtido por decomposição QR, destacando vantagens da SVD para rank-deficiente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Decomposição QR e Cálculo do Número de Condição",
                                  "subSteps": [
                                    "Lembre-se da decomposição QR: A = QR, onde Q é ortogonal e R é triangular superior.",
                                    "Calcule o número de condição κ(A) ≈ κ(R) = |R(1,1)/R(n,n)| para matrizes bem condicionadas.",
                                    "Discuta limitações: QR assume rank completo e pode falhar em matrizes rank-deficientes.",
                                    "Implemente QR em software para uma matriz 3x3 de rank completo.",
                                    "Analise o impacto de perturbações nos elementos diagonais de R."
                                  ],
                                  "verification": "Construa uma tabela comparando κ via QR para matrizes normais e perturbadas.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Software NumPy/MATLAB, matrizes de exemplo (ex: Hilbert 3x3), notas de aula sobre QR.",
                                  "tips": "Sempre normalize colunas em Q para evitar erros numéricos.",
                                  "learningObjective": "Entender como QR estima condicionamento em casos ideais.",
                                  "commonMistakes": "Ignorar que QR não lida bem com rank-deficiência, assumindo sempre rank completo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar Decomposição SVD e Número de Condição",
                                  "subSteps": [
                                    "Lembre-se da SVD: A = UΣV^T, com Σ diagonal de valores singulares σ1 ≥ σ2 ≥ ... ≥ σn.",
                                    "Calcule κ(A) = σ1 / σ_min, onde σ_min é o menor valor singular não-nulo.",
                                    "Identifique rank via número de σ_i > tolerância.",
                                    "Implemente SVD para a mesma matriz 3x3 usada em QR.",
                                    "Compare os valores singulares com elementos de R."
                                  ],
                                  "verification": "Verifique que κ_SVD ≈ κ_QR para matriz rank-completa.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Software SciPy/Octave, mesma matriz de exemplo, tolerância para σ_min (ex: 1e-10).",
                                  "tips": "Use tolerância relativa para detectar rank em SVD.",
                                  "learningObjective": "Dominar o cálculo preciso de condicionamento via SVD.",
                                  "commonMistakes": "Confundir valores singulares com autovalores, ignorando propriedades de A não quadrada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Condicionamento via QR e SVD em Casos Gerais",
                                  "subSteps": [
                                    "Escolha matrizes rank-completas e rank-deficientes (ex: A = [1 0; 0 0]).",
                                    "Calcule κ_QR e κ_SVD para ambas.",
                                    "Observe que QR falha ou dá κ infinito em rank-deficiente, enquanto SVD dá κ finito.",
                                    "Plote gráfico de σ_i vs perturbações.",
                                    "Discuta estabilidade numérica: SVD é mais robusta."
                                  ],
                                  "verification": "Crie relatório com tabelas e gráficos mostrando diferenças numéricas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Matrizes rank-deficientes geradas (ex: via Python), software de plotagem (Matplotlib).",
                                  "tips": "Teste com ruído gaussiano para simular erros reais.",
                                  "learningObjective": "Contrastar comportamentos em cenários variados.",
                                  "commonMistakes": "Não testar rank-deficiência, focando só em casos ideais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Destacar Vantagens da SVD para Matrizes Rank-Deficientes",
                                  "subSteps": [
                                    "Liste vantagens: SVD detecta rank exato, filtra ruído via truncagem.",
                                    "Compare sensibilidade: perturbações em SVD preservam estrutura.",
                                    "Exemplo: pseudoinversa via SVD vs QR.",
                                    "Discuta custo computacional: SVD O(n^3), mas mais precisa.",
                                    "Conclua com quando usar cada uma."
                                  ],
                                  "verification": "Escreva parágrafo resumindo 3 vantagens chave da SVD sobre QR.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Artigos sobre SVD (ex: Golub-Van Loan), caderno para resumo.",
                                  "tips": "Enfatize aplicações em dados reais com ruído.",
                                  "learningObjective": "Identificar cenários onde SVD é superior.",
                                  "commonMistakes": "Subestimar custo da SVD, ignorando precisão ganha."
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 1.0001], [1, 1.0002]] (rank-deficiente aproximada). QR dá R com R(2,2)≈0.0001, κ_QR instável. SVD dá σ1≈1.414, σ2≈1e-4, κ_SVD=1.414e4 preciso, permitindo truncagem para rank-1.",
                              "finalVerifications": [
                                "Explicar por que SVD é preferida em rank-deficiente.",
                                "Calcular κ para nova matriz rank-deficiente via ambos métodos.",
                                "Identificar rank via SVD corretamente.",
                                "Comparar estabilidade numérica com perturbações.",
                                "Listar 2 limitações da QR vs SVD."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de κ_SVD e κ_QR (erro <1%).",
                                "Correta identificação de rank-deficiência.",
                                "Análise qualitativa clara das vantagens SVD.",
                                "Uso correto de software sem erros numéricos.",
                                "Relatório com tabelas/gráficos bem estruturados.",
                                "Conexão com sensibilidade de sistemas lineares."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação em NumPy para análise de dados.",
                                "Estatística: Detecção de multicolinearidade em regressão.",
                                "Engenharia: Análise de estabilidade em controle de sistemas.",
                                "Física: Compressão de sinais em processamento de imagens."
                              ],
                              "realWorldApplication": "Em machine learning, SVD via PCA lida com features correlacionadas (rank-deficiente), evitando overfitting, enquanto QR falharia em datasets reais com ruído, como imagens médicas ou dados financeiros."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.1.3",
                        "name": "Sensibilidade de Sistemas Ax=b via SVD",
                        "description": "Aplicação da SVD para boundar erros relativos em soluções x sob perturbações δA e δb, usando cond(A) e decomposição explícita.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.1.3.1",
                            "name": "Derivar bounds de erro",
                            "description": "Aplicar teoremas de sensibilidade: ||δx||/||x|| ≤ cond(A) (||δA||/||A|| + ||δb||/||b||), interpretando via SVD.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Decomposição SVD e Condicionamento de Matrizes",
                                  "subSteps": [
                                    "Lembre-se da decomposição SVD: A = U Σ V^T, onde Σ é diagonal com singular values σ1 ≥ σ2 ≥ ... ≥ σn > 0.",
                                    "Calcule o número de condicionamento cond(A) = σ1 / σn.",
                                    "Entenda que cond(A) mede a sensibilidade de A a perturbações.",
                                    "Pratique decompondo uma matriz 2x2 simples usando software ou manualmente.",
                                    "Verifique se cond(A) é alto para matrizes mal-condicionadas."
                                  ],
                                  "verification": "Decompor corretamente uma matriz dada e calcular cond(A) com precisão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou Python (NumPy/SciPy)",
                                    "Matriz de exemplo 2x2"
                                  ],
                                  "tips": "Sempre normalize as normas para ||A|| = σ1.",
                                  "learningObjective": "Compreender os componentes da SVD e seu papel no condicionamento.",
                                  "commonMistakes": [
                                    "Confundir σ_max com σ_min",
                                    "Esquecer transposição em V^T"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Teorema de Sensibilidade para Sistemas Ax=b",
                                  "subSteps": [
                                    "Estude a fórmula: ||δx||/||x|| ≤ cond(A) (||δA||/||A|| + ||δb||/||b||).",
                                    "Interprete: erro relativo em x é amplificado por cond(A) vezes erros em A e b.",
                                    "Derive intuitivamente: perturbações em A e b propagam para x via inversa de A.",
                                    "Compare com caso δA=0: ||δx||/||x|| ≤ cond(A) ||δb||/||b||.",
                                    "Discuta normas adequadas (ex: norma 2)."
                                  ],
                                  "verification": "Reescrever e explicar a fórmula em suas próprias palavras.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Notas de aula sobre sensibilidade",
                                    "Livro de Álgebra Numérica (ex: Golub-Van Loan)"
                                  ],
                                  "tips": "Pense em cond(A) como fator de amplificação de erros.",
                                  "learningObjective": "Dominar a interpretação qualitativa do teorema de sensibilidade.",
                                  "commonMistakes": [
                                    "Ignorar o termo ||δA||",
                                    "Usar norma errada (ex: 1 em vez de 2 para SVD)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar Bounds de Erro Usando SVD",
                                  "subSteps": [
                                    "Expresse x = A^{-1} b = V Σ^{-1} U^T b.",
                                    "Perturbe: δx ≈ V Σ^{-1} U^T δb + perturbação de A via aproximação.",
                                    "Use aproximação de primeira ordem para δ(Ax) = δA x + A δx ≈ δb.",
                                    "Aplique normas: ||δx|| ≤ cond(A) ||δb|| + termos de δA.",
                                    "Complete a derivação: prove ||δx||/||x|| ≤ cond(A) (||δA||/||A|| + ||δb||/||b||)."
                                  ],
                                  "verification": "Derivar a fórmula passo a passo em um caderno.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software para SVD (MATLAB/Python)"
                                  ],
                                  "tips": "Use propriedades de normas subordinadas: ||A||_2 = σ1.",
                                  "learningObjective": "Derivar rigorosamente o bound usando SVD.",
                                  "commonMistakes": [
                                    "Erros em aproximações diferenciais",
                                    "Confundir normas de vetores e matrizes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Bounds via SVD e Aplicar em Exemplo",
                                  "subSteps": [
                                    "Analise singular values: pequenos σ indicam alta sensibilidade.",
                                    "Para δA pequeno, bound domina por cond(A) ||δb||/||b||.",
                                    "Compute numericamente: SVD de A, perturbe A e b, compare ||δx||/||x|| com bound.",
                                    "Interprete: se cond(A)>10^6, evite solução direta.",
                                    "Discuta mitigação: use métodos regularizados como Tikhonov."
                                  ],
                                  "verification": "Aplicar em matriz exemplo e verificar se bound >= erro real.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Matriz de exemplo mal-condicionada"
                                  ],
                                  "tips": "Gere matrizes com np.linalg.svd e adicione ruído gaussiano.",
                                  "learningObjective": "Interpretar e validar bounds computacionalmente.",
                                  "commonMistakes": [
                                    "Perturbações muito grandes violam linearidade",
                                    "Normas inconsistentes"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[1,1],[1,1+ε]] com ε=10^{-6}, b=[1,1]^T. Compute SVD, cond(A)≈1/ε. Perturbe b por 10^{-8}, derive bound e compare com erro real em x.",
                              "finalVerifications": [
                                "Derivar corretamente o bound para um sistema dado.",
                                "Calcular cond(A) via SVD com precisão.",
                                "Interpretar se o sistema é sensível (cond(A)>10^4?).",
                                "Validar numericamente: erro simulado < bound.",
                                "Explicar impacto de singular values pequenos.",
                                "Propor alternativa para A mal-condicionado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática (80% dos passos corretos).",
                                "Correta interpretação qualitativa do bound.",
                                "Implementação numérica sem erros de norma.",
                                "Análise de sensibilidade coerente com SVD.",
                                "Criatividade em exemplos e conexões reais.",
                                "Clareza na documentação dos cálculos."
                              ],
                              "crossCurricularConnections": [
                                "Computação Científica: Implementação em NumPy/SciPy.",
                                "Engenharia: Análise de estabilidade em modelos finitos.",
                                "Estatística: Propagação de erros em regressão linear.",
                                "Física Computacional: Sensibilidade em simulações dinâmicas."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, derivar bounds para sistemas de equações em análise estrutural garante que pequenas imprecisões em medições (δb) ou modelo (δA) não causem falhas catastróficas em predições de tensão."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.2.2"
                            ]
                          },
                          {
                            "id": "10.1.2.5.1.3.2",
                            "name": "Diagnosticar sistemas via SVD",
                            "description": "Usar SVD para identificar componentes sensíveis em Ax=b, como pseudoinversa e soluções de quadrados mínimos para casos rank-deficientes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos da Decomposição em Valores Singulares (SVD)",
                                  "subSteps": [
                                    "Revise a definição de SVD: A = U Σ V^T, onde U e V são ortogonais e Σ é diagonal com valores singulares σ_i não negativos e decrescentes.",
                                    "Identifique os componentes: colunas de U (vetores singulares esquerdos), valores singulares em Σ e linhas de V^T (vetores singulares direitos).",
                                    "Discuta rank da matriz: número de σ_i > 0.",
                                    "Explore condição numérica: κ(A) = σ_max / σ_min para A full-rank.",
                                    "Pratique com matriz 2x2 simples para visualizar."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os três componentes da SVD e compute manualmente para uma matriz 2x2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Álgebra Linear (ex: Strang), calculadora ou Python/MATLAB com numpy.linalg.svd.",
                                  "tips": "Sempre normalize os vetores singulares para verificar ortogonalidade.",
                                  "learningObjective": "Dominar a estrutura teórica da SVD e sua interpretação geométrica.",
                                  "commonMistakes": "Confundir U e V; ignorar que σ_i são não negativos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar SVD a uma matriz A de um sistema Ax=b",
                                  "subSteps": [
                                    "Escolha ou gere uma matriz A m x n (ex: rank-deficiente).",
                                    "Compute SVD usando software: [U, S, Vt] = svd(A).",
                                    "Extraia Σ como diagonal de S, truncando zeros.",
                                    "Verifique A ≈ U Σ V^T para precisão numérica.",
                                    "Identifique o gap nos valores singulares (σ_k >> σ_{k+1})."
                                  ],
                                  "verification": "Confirme que ||A - U Σ V^T|| < 1e-10 e liste os 3 maiores σ_i.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python (NumPy/SciPy), MATLAB ou Octave.",
                                  "tips": "Use svd(full) para matrizes retangulares; plot S para visualizar decay.",
                                  "learningObjective": "Executar computação SVD prática e validar resultados.",
                                  "commonMistakes": "Usar svd econômica sem full para rank baixo; não checar reconstrução."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diagnosticar sensibilidade usando valores singulares",
                                  "subSteps": [
                                    "Calcule o rank efetivo: k onde σ_k / σ_1 > ε (ex: 1e-12).",
                                    "Avalie condição: se κ(A) > 1e6, sistema é ill-conditioned.",
                                    "Identifique componentes sensíveis: direções associadas a σ_i pequenos (colunas de V correspondentes).",
                                    "Analise pseudorank e impacto em soluções Ax=b.",
                                    "Compare com norma 2: ||A||_2 = σ_max."
                                  ],
                                  "verification": "Classifique o sistema como well-conditioned, ill-conditioned ou rank-deficiente com justificativa numérica.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Mesmo software do step 2, planilha para log(σ_i).",
                                  "tips": "Use threshold relativo σ_i / σ_1 para robustez numérica.",
                                  "learningObjective": "Interpretar σ_i para diagnosticar problemas de sensibilidade.",
                                  "commonMistakes": "Ignorar ruído numérico em σ_i pequenos; usar rank algébrico exato."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir pseudoinversa e soluções de mínimos quadrados",
                                  "subSteps": [
                                    "Compute pseudoinversa A^+ = V Σ^+ U^T, onde Σ^+ inverte σ_i > ε e zera outros.",
                                    "Para Ax=b consistente: x = A^+ b.",
                                    "Para rank-deficiente: solução mínima norma entre infinitas.",
                                    "Para overdetermined: mínimos quadrados ||Ax - b||_2 mínimo.",
                                    "Avalie sensibilidade da solução: perturbações em b/A afetam x via 1/σ_i."
                                  ],
                                  "verification": "Resolva Ax=b com A^+ e verifique ||A x - b|| pequeno e ||x|| mínima.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Software com pinv(A) para validação; compare com lsqr.",
                                  "tips": "Regularize Σ^+ com Tikhonov se σ_min muito pequeno.",
                                  "learningObjective": "Aplicar SVD para soluções robustas em casos problemáticos.",
                                  "commonMistakes": "Inverter todos σ_i incluindo zeros; não usar Σ^+ truncada."
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 1, 0], [1, 1, 0], [0, 0, 1]], b = [2.1, 1.9, 1]. SVD revela σ = [1.73, 1.73, 1, 0], rank=3 mas σ pequeno indica sensibilidade na direção [1,-1,0]. Pseudoinversa dá x ≈ [1,1,1], diagnosticando nulidade na segunda coluna.",
                              "finalVerifications": [
                                "Decompor corretamente SVD de A 3x3 rank-deficiente.",
                                "Identificar corretamente valores singulares pequenos e gap.",
                                "Calcular A^+ precisa e resolver Ax=b.",
                                "Explicar verbalmente por que o sistema é sensível.",
                                "Validar solução com ||Ax - b|| e ||x|| mínima.",
                                "Comparar com solução direta (backslash) e notar diferenças numéricas."
                              ],
                              "assessmentCriteria": [
                                "Precisão da SVD: erro de reconstrução < 1e-12.",
                                "Interpretação correta de sensibilidade via κ(A) e gap σ.",
                                "Correta construção de A^+ e solução mínima norma.",
                                "Identificação precisa de componentes sensíveis (direções V).",
                                "Análise qualitativa robusta para casos reais com ruído.",
                                "Eficiência computacional: tempo < 1s para A 100x100."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: PCA via SVD para redução dimensional.",
                                "Machine Learning: Regularização em regressão via truncada SVD.",
                                "Engenharia: Análise de estabilidade em controle de sistemas.",
                                "Física Computacional: Compressão de sinais e imagens."
                              ],
                              "realWorldApplication": "Em engenharia civil, diagnosticar sensibilidade em modelos finitos de estruturas (A grande e ill-conditioned) para prever falhas sob carga incerta; em IA, melhorar estabilidade de regressão linear em datasets ruidosos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.1.3.3",
                            "name": "Implementar análise numérica",
                            "description": "Simular em software (ex: MATLAB/Python) perturbações em A e b, computar SVD e verificar bounds de sensibilidade empiricamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente de software e definir sistema linear original",
                                  "subSteps": [
                                    "Instale bibliotecas necessárias: NumPy e SciPy para Python (ou equivalente em MATLAB).",
                                    "Defina uma matriz A (ex: 3x3 mal-condicionada) e vetor b representando Ax = b.",
                                    "Compute a solução exata x = np.linalg.solve(A, b).",
                                    "Salve valores originais para referência futura.",
                                    "Teste o resíduo ||Ax - b|| para validar."
                                  ],
                                  "verification": "Execute o código e confirme que x satisfaz Ax ≈ b com resíduo < 1e-10.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Editor de código (Jupyter Notebook recomendado)",
                                    "Documentação SVD NumPy"
                                  ],
                                  "tips": "Use Jupyter para visualização interativa; comece com matrizes pequenas para depuração.",
                                  "learningObjective": "Configurar ambiente computacional e validar sistema linear básico.",
                                  "commonMistakes": [
                                    "Esquecer importações",
                                    "Matriz singular (verifique cond(A))",
                                    "Usar solve em vez de lstsq para sistemas não quadrados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar SVD da matriz A original e bounds teóricos de sensibilidade",
                                  "subSteps": [
                                    "Compute SVD: U, s, Vh = np.linalg.svd(A, full_matrices=False).",
                                    "Calcule condição numérica κ = s[0]/s[-1].",
                                    "Derive bounds teóricos: ||Δx||/||x|| ≤ κ ||ΔA||/||A|| + κ ||Δb||/||b|| (aproximação de primeira ordem).",
                                    "Armazene singular values e bounds para comparação posterior.",
                                    "Plote singular values para visualizar condicionamento."
                                  ],
                                  "verification": "Confirme κ > 1e6 para matriz mal-condicionada e bounds >0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código Python do Step 1",
                                    "Referência teórica SVD (notas de aula)"
                                  ],
                                  "tips": "Use log-scale para plot de singular values; normalize perturbações como fração relativa (ε=1e-6).",
                                  "learningObjective": "Aplicar SVD para quantificar sensibilidade teórica de sistemas lineares.",
                                  "commonMistakes": [
                                    "Confundir full_matrices=True",
                                    "Índices errados em s (maior é s[0])",
                                    "Ignorar normalização relativa"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar e aplicar perturbações aleatórias em A e b",
                                  "subSteps": [
                                    "Defina níveis de perturbação ε = [1e-6, 1e-4, 1e-2].",
                                    "Gere ΔA ~ N(0, ε||A||), Δb ~ N(0, ε||b||) usando np.random.normal.",
                                    "Crie N=100 instâncias de A_pert = A + ΔA, b_pert = b + Δb.",
                                    "Armazene perturbações em listas ou arrays para loop eficiente.",
                                    "Valide normas: confirme ||ΔA||/||A|| ≈ ε."
                                  ],
                                  "verification": "Imprima estatísticas: média(||ΔA||/||A||) deve ser ≈ ε para cada nível.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código anterior",
                                    "np.random para geração aleatória"
                                  ],
                                  "tips": "Use seed para reprodutibilidade: np.random.seed(42); vetorize para N grande.",
                                  "learningObjective": "Simular ruído realista em dados de entrada de sistemas lineares.",
                                  "commonMistakes": [
                                    "Perturbações não normalizadas",
                                    "ΔA rank-deficient levando a singularidade",
                                    "Poucas amostras (use N>=50)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver sistemas perturbados e calcular erros empíricos",
                                  "subSteps": [
                                    "Para cada par (A_pert, b_pert), compute x_pert = np.linalg.solve(A_pert, b_pert).",
                                    "Calcule erro relativo: rel_err_x = ||x_pert - x|| / ||x||.",
                                    "Compute SVD de A_pert e verifique bound empírico κ_pert * (||ΔA||/||A|| + ||Δb||/||b||).",
                                    "Colete estatísticas: média, max, std de rel_err_x por ε.",
                                    "Registre casos de falha (cond>1e12)."
                                  ],
                                  "verification": "rel_err_x deve crescer com ε e κ.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Loops ou vetorização NumPy",
                                    "Tratamento de exceções para singularidade"
                                  ],
                                  "tips": "Use try-except para solves falhos; plote boxplots de erros vs ε.",
                                  "learningObjective": "Quantificar sensibilidade empírica via simulações numéricas.",
                                  "commonMistakes": [
                                    "Propagação de erros em solve instável",
                                    "Não tratar NaN/inf",
                                    "Confundir Δx com resíduo"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar resultados e verificar bounds empiricamente",
                                  "subSteps": [
                                    "Compare média(rel_err_x) vs bound teórico para cada ε.",
                                    "Plote log-log: log(rel_err_x) vs log(ε), superponha bound.",
                                    "Calcule razão empírico/teórico e confirme ≤1 na média.",
                                    "Interprete: discuta il-condicionamento se razão ~1.",
                                    "Gere relatório com plots e conclusões."
                                  ],
                                  "verification": "Plots mostram erros empíricos abaixo ou iguais aos bounds teóricos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Matplotlib/Seaborn para plots",
                                    "Código compilado"
                                  ],
                                  "tips": "Use plt.loglog para escalas; adicione legenda e labels claros.",
                                  "learningObjective": "Validar teoria SVD via experimentos numéricos e visualização.",
                                  "commonMistakes": [
                                    "Escalas erradas em plots",
                                    "Média enviesada por outliers",
                                    "Ignorar variância em amostras"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = np.array([[1e-6, 1], [1, 1]]), b = [1, 2], κ≈1e6. Simule ε=1e-4, resolva 100x, observe rel_err_x ≈1e-2 alinhado com bound κ*2ε≈2e0.",
                              "finalVerifications": [
                                "Código completo executa sem erros para N=100 perturbações.",
                                "Bounds teóricos calculados corretamente (κ*soma perturbações relativas).",
                                "Erros empíricos médios ≤ bounds teóricos em todos ε.",
                                "Plots mostram tendência log-log linear com slope≈1.",
                                "Relatório discute pelo menos 2 casos: bem-condicionado vs mal-condicionado.",
                                "SVD computado para A original e pelo menos 5 A_pert."
                              ],
                              "assessmentCriteria": [
                                "Precisão: erros relativos <1e-8 para ε=0 (numérico).",
                                "Completude: todos steps implementados com N>=50.",
                                "Análise: comparação quantitativa (razões, stats) entre empírico/teórico.",
                                "Visualização: plots claros, legíveis, com escalas apropriadas.",
                                "Robustez: código trata singularidades e usa seeds reprodutíveis.",
                                "Interpretação: explica impacto de condicionamento em aplicações."
                              ],
                              "crossCurricularConnections": [
                                "Programação Científica: NumPy/SciPy para computação linear.",
                                "Estatística: Análise de Monte Carlo para variância de erros.",
                                "Engenharia Computacional: Modelagem de incertezas em simulações.",
                                "Física: Sensibilidade em sistemas dinâmicos discretizados.",
                                "Data Science: Pré-processamento robusto de dados ruidosos."
                              ],
                              "realWorldApplication": "Em processamento de imagens (SVD para denoising com ruído), finanças (sensibilidade de portfólios a dados de mercado imprecisos) ou engenharia aeroespacial (análise de estabilidade de matrizes de rigidez com tolerâncias de fabricação)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.3.1",
                              "10.1.2.5.1.1.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.3",
                "name": "Ortogonalização e Decomposição QR",
                "description": "Técnicas de ortogonalização como Gram-Schmidt e fatoração QR para matrizes retangulares.",
                "totalSkills": 57,
                "atomicTopics": [
                  {
                    "id": "10.1.3.1",
                    "name": "Processo de Gram-Schmidt Clássico",
                    "description": "Algoritmo para ortogonalizar um conjunto de vetores linearmente independentes gerando uma base ortogonal.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.1.1",
                        "name": "Fundamentos de Ortogonalidade e Projeção",
                        "description": "Conceitos básicos necessários para compreender o processo de Gram-Schmidt, incluindo definições de ortogonalidade e projeção ortogonal em espaços vetoriais euclidianos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.1",
                            "name": "Definir vetores ortogonais e base ortogonal",
                            "description": "Explicar a definição de dois vetores ortogonais como aqueles cujo produto interno é zero e estender para uma base ortogonal como um conjunto linearmente independente de vetores mutuamente ortogonais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Conceito de Produto Interno",
                                  "subSteps": [
                                    "Lembre-se da definição do produto interno em espaços euclidianos: para vetores u = (u1, u2, ..., un) e v = (v1, v2, ..., vn), <u, v> = u1*v1 + u2*v2 + ... + un*vn.",
                                    "Entenda as propriedades: simetria (<u,v> = <v,u>), linearidade e norma (<u,u> = ||u||^2).",
                                    "Calcule exemplos simples em R^2 e R^3 para fixar.",
                                    "Discuta o significado geométrico: produto interno zero indica ângulo de 90 graus.",
                                    "Pratique com vetores unitários e não unitários."
                                  ],
                                  "verification": "Calcule corretamente o produto interno de pelo menos 5 pares de vetores dados e interprete os resultados geometricamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou caderno",
                                    "Calculadora opcional",
                                    "Referência de álgebra linear (capítulo de produto escalar)"
                                  ],
                                  "tips": [
                                    "Visualize vetores como setas no plano para entender o ângulo.",
                                    "Sempre verifique se os vetores estão no mesmo espaço vetorial."
                                  ],
                                  "learningObjective": "Compreender o produto interno como base para ortogonalidade.",
                                  "commonMistakes": [
                                    "Confundir produto interno com produto vetorial.",
                                    "Esquecer de somar todos os componentes.",
                                    "Ignorar propriedades como simetria."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Vetores Ortogonais",
                                  "subSteps": [
                                    "Defina formalmente: dois vetores u e v são ortogonais se <u, v> = 0.",
                                    "Prove que vetores ortogonais têm ângulo reto (90 graus) usando a fórmula cosθ = <u,v> / (||u|| ||v||).",
                                    "Classifique pares de vetores como ortogonais ou não, calculando o produto interno.",
                                    "Explore ortogonalidade em dimensões diferentes: R^2 (ex: eixos x e y) e R^3.",
                                    "Discuta ortogonalidade para mais de dois vetores: todos os pares devem ser ortogonais."
                                  ],
                                  "verification": "Identifique corretamente 10 pares de vetores como ortogonais ou não, justificando com cálculos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de vetores impressos ou listados",
                                    "Software como GeoGebra ou MATLAB para visualização (opcional)"
                                  ],
                                  "tips": [
                                    "Normalize vetores para simplificar cálculos iniciais.",
                                    "Desenhe os vetores para confirmar visualmente o ângulo reto."
                                  ],
                                  "learningObjective": "Aplicar a definição de ortogonalidade via produto interno.",
                                  "commonMistakes": [
                                    "Assumir ortogonalidade sem calcular o produto interno.",
                                    "Confundir com paralelismo (produto interno máximo).",
                                    "Esquecer vetores nulos (ortogonais a tudo)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Base Ortogonal",
                                  "subSteps": [
                                    "Defina: uma base ortogonal é um conjunto {v1, v2, ..., vk} linearmente independente onde <vi, vj> = 0 para i ≠ j.",
                                    "Diferencie de base ortonormal (adiciona ||vi|| = 1).",
                                    "Verifique se um conjunto dado é base ortogonal: teste ortogonalidade mútua e independência linear.",
                                    "Construa exemplos simples: base canônica em R^n é ortogonal.",
                                    "Discuta extensão para subespaços: base ortogonal para um subespaço vetorial."
                                  ],
                                  "verification": "Construa ou valide pelo menos 3 conjuntos como bases ortogonais, mostrando cálculos completos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de conjuntos de vetores para teste",
                                    "Matriz para teste de independência linear"
                                  ],
                                  "tips": [
                                    "Use matriz de Gram para verificar ortogonalidade de múltiplos vetores eficientemente.",
                                    "Lembre-se: independência linear é essencial, não só ortogonalidade."
                                  ],
                                  "learningObjective": "Entender bases ortogonais como ferramentas para decomposições.",
                                  "commonMistakes": [
                                    "Omitir teste de independência linear.",
                                    "Confundir base ortogonal com ortonormal.",
                                    "Permitir vetores não nulos com <vi,vi> ≠ norma esperada."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Propriedades e Aplicações Iniciais",
                                  "subSteps": [
                                    "Liste propriedades: bases ortogonais preservam normas em projeções, facilitam coordenadas.",
                                    "Conecte com Gram-Schmidt: processo gera bases ortogonais a partir de bases quaisquer.",
                                    "Resolva exercícios: encontre vetores ortogonais a um dado vetor em R^3.",
                                    "Discuta unicidade: bases ortogonais não são únicas para um subespaço.",
                                    "Pratique projeções ortogonais básicas usando bases."
                                  ],
                                  "verification": "Resolva 5 problemas variados envolvendo definições e propriedades de ortogonalidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exercícios de livro-texto ou online (Khan Academy)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": [
                                    "Sempre normalize após Gram-Schmidt para ortonormal.",
                                    "Use diagramas para visualizar bases em baixas dimensões."
                                  ],
                                  "learningObjective": "Integrar definições em contextos práticos como preparação para ortogonalização.",
                                  "commonMistakes": [
                                    "Ignorar dependência linear em conjuntos ortogonais.",
                                    "Confundir projeção ortogonal com componente paralelo.",
                                    "Não escalar vetores adequadamente."
                                  ]
                                }
                              ],
                              "practicalExample": "Em R^2, os vetores u = (1, 0) e v = (0, 1) formam uma base ortogonal pois <u,v> = 1*0 + 0*1 = 0, e são linearmente independentes. Qualquer vetor (x,y) = x*u + y*v, facilitando cálculos em gráficos cartesianos.",
                              "finalVerifications": [
                                "Explicar verbalmente a definição de vetores ortogonais usando produto interno.",
                                "Calcular produto interno e classificar ortogonalidade corretamente em 10 exemplos.",
                                "Validar um conjunto de 3 vetores como base ortogonal com testes completos.",
                                "Diferenciar base ortogonal de ortonormal com exemplos.",
                                "Aplicar em projeção simples: proj_u v para vetores ortogonais.",
                                "Discutir papel em decomposição QR."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (produto interno = 0 e independência linear).",
                                "Correção em cálculos de produto interno e verificações.",
                                "Profundidade na interpretação geométrica (ângulos retos).",
                                "Capacidade de gerar exemplos concretos e contraexemplos.",
                                "Integração com conceitos prévios como bases e subespaços.",
                                "Clareza na distinção entre ortogonal, ortonormal e outras bases."
                              ],
                              "crossCurricularConnections": [
                                "Física: Forças perpendiculares (trabalho nulo quando F · d = 0).",
                                "Computação: Algoritmos de processamento de sinais (bases de Fourier ortogonais).",
                                "Engenharia: Análise de estruturas com componentes ortogonais de tensão.",
                                "Estatística: Regressão múltipla com preditores ortogonais."
                              ],
                              "realWorldApplication": "Em visão computacional, bases ortogonais são usadas em transformadas para comprimir imagens (JPEG), permitindo representação eficiente de dados sem perda de ortogonalidade, otimizando armazenamento e processamento em dispositivos móveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.2",
                            "name": "Calcular o produto interno e norma euclidiana",
                            "description": "Computar o produto interno <u,v> = u^T v e a norma ||u|| = sqrt(<u,u>) para vetores em R^n, aplicando em exemplos simples de 2 ou 3 dimensões.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição e Fórmula do Produto Interno",
                                  "subSteps": [
                                    "Revise a representação de vetores em R^n como colunas ou linhas.",
                                    "Aprenda a fórmula <u,v> = u^T v, onde u^T é a transposta de u.",
                                    "Entenda o produto interno como soma de produtos componentes: Σ u_i * v_i.",
                                    "Explore interpretação geométrica: |u||v|cosθ.",
                                    "Identifique propriedades: simetria, linearidade em cada argumento."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a fórmula e uma propriedade para um par de vetores simples.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Notebook Jupyter com NumPy (opcional)"
                                  ],
                                  "tips": "Visualize vetores como setas no plano para entender o ângulo θ.",
                                  "learningObjective": "Definir precisamente o produto interno e suas propriedades básicas.",
                                  "commonMistakes": [
                                    "Confundir com produto externo (cruzado)",
                                    "Esquecer a transposta u^T",
                                    "Ignorar normalização para ângulo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Produto Interno para Vetores em R^2",
                                  "subSteps": [
                                    "Escolha vetores u = [u1, u2], v = [v1, v2] em R^2.",
                                    "Compute cada termo: u1*v1 + u2*v2.",
                                    "Verifique com multiplicação matricial: u^T (1x2) * v (2x1).",
                                    "Teste com exemplos: u=[1,2], v=[3,4] → <u,v>=11.",
                                    "Registre 3 cálculos manuais e valide com software."
                                  ],
                                  "verification": "Apresente 3 cálculos corretos de <u,v> para vetores aleatórios em R^2.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora científica",
                                    "Python/NumPy para verificação"
                                  ],
                                  "tips": "Use notação linha-coluna para evitar erros de dimensão.",
                                  "learningObjective": "Executar cálculos precisos de produto interno em 2D manualmente e via software.",
                                  "commonMistakes": [
                                    "Erro aritmético em soma",
                                    "Usar produto componente a componente sem soma",
                                    "Confundir ordem u,v (não comutativo em geral, mas simétrico)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Norma Euclidiana Usando Produto Interno",
                                  "subSteps": [
                                    "Defina ||u|| = sqrt(<u,u>), raiz quadrada do produto interno consigo mesmo.",
                                    "Para R^2: ||u|| = sqrt(u1² + u2²).",
                                    "Calcule para exemplos: u=[3,4] → <u,u>=25 → ||u||=5.",
                                    "Compare com distância da origem no plano.",
                                    "Pratique com 4 vetores, incluindo zero vector (norma 0)."
                                  ],
                                  "verification": "Compute ||u|| para 4 vetores dados e confirme sqrt(<u,u>).",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Calculadora com sqrt",
                                    "Tabela de raízes quadradas",
                                    "GeoGebra para visualização"
                                  ],
                                  "tips": "Lembre que norma é sempre não-negativa; use aproximações para raízes não perfeitas.",
                                  "learningObjective": "Relacionar norma à auto-projeção via produto interno.",
                                  "commonMistakes": [
                                    "Esquecer sqrt (deixar como soma quadrados)",
                                    "Raiz de soma errada",
                                    "Norma negativa"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Vetores R^3 e Verificar Consistência",
                                  "subSteps": [
                                    "Estenda para R^3: u=[u1,u2,u3], <u,v>=u1v1+u2v2+u3v3.",
                                    "Calcule <u,v> e ||u|| para u=[1,1,1], v=[1,0,1].",
                                    "Verifique propriedades: <u,u> ≥ 0, ||u||=0 iff u=0.",
                                    "Compare resultados manuais vs. computacionais (MATLAB/Python).",
                                    "Resolva 2 problemas mistos: produto e norma juntos."
                                  ],
                                  "verification": "Resolva um exercício completo em R^3 com ambos cálculos corretos.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software NumPy/MATLAB",
                                    "Lista de exercícios pré-prontos"
                                  ],
                                  "tips": "Expanda gradualmente de 2D para 3D para construir confiança.",
                                  "learningObjective": "Generalizar cálculos para R^3 e validar propriedades.",
                                  "commonMistakes": [
                                    "Índices errados em 3D",
                                    "Esquecer termos na soma",
                                    "Erro em transposta para vetores coluna"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado u = [1, 2, 3] e v = [4, -1, 0] em R^3: <u,v> = 1*4 + 2*(-1) + 3*0 = 4 - 2 + 0 = 2; ||u|| = sqrt(1² + 2² + 3²) = sqrt(14) ≈ 3.74; ||v|| = sqrt(16 + 1 + 0) = sqrt(17) ≈ 4.12.",
                              "finalVerifications": [
                                "Calcula corretamente <u,v> para vetores em R^2 e R^3.",
                                "Computa ||u|| com sqrt(<u,u>) exata ou aproximada.",
                                "Identifica vetor nulo (norma 0).",
                                "Verifica simetria: <u,v> = <v,u>.",
                                "Aplica em 5 pares de vetores sem erros aritméticos.",
                                "Explica relação geométrica (projeção/ângulo)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos aritméticos (100% correto).",
                                "Correta aplicação da fórmula u^T v e sqrt.",
                                "Demonstração de propriedades (simetria, positividade).",
                                "Eficiência: tempo < estimado sem erros.",
                                "Interpretação conceitual além do cálculo.",
                                "Uso adequado de ferramentas (manual/software)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Produto escalar para trabalho (F·d).",
                                "Ciência da Computação: Similaridade vetorial em busca (cosθ = <u,v>/(||u||||v||)).",
                                "Engenharia: Projeções ortogonais em sinais.",
                                "Estatística: Correlação linear entre variáveis.",
                                "Gráficos: Iluminação difusa (N·L vetor normal-luz)."
                              ],
                              "realWorldApplication": "Em Machine Learning, mede similaridade entre documentos (TF-IDF vetores) ou recomendações; em Física Computacional, calcula distâncias euclidianas para simulações de partículas; em Processamento de Imagens, normaliza vetores de pixels para filtros."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.3",
                            "name": "Realizar projeção ortogonal de um vetor sobre outro",
                            "description": "Derivar e calcular a projeção proj_u v = (<v,u>/||u||^2) u, demonstrando geometricamente que é o componente paralelo de v sobre u.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais: Produto Escalar e Norma de Vetor",
                                  "subSteps": [
                                    "Defina o produto escalar <v, u> = v1*u1 + v2*u2 + ... + vn*un para vetores em R^n.",
                                    "Calcule a norma ||u|| = sqrt(<u, u>), representando o comprimento do vetor u.",
                                    "Verifique propriedades: <v, u> = ||v|| ||u|| cosθ, onde θ é o ângulo entre v e u.",
                                    "Pratique com exemplos simples: <[1,2], [3,4]> e ||[3,4]||.",
                                    "Desenhe vetores para visualizar o ângulo e a decomposição."
                                  ],
                                  "verification": "Resolva 3 exercícios de produto escalar e norma corretamente, com desenhos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora",
                                    "Software GeoGebra ou similar para visualização"
                                  ],
                                  "tips": "Sempre normalize vetores unitários para simplificar cálculos iniciais.",
                                  "learningObjective": "Compreender como o produto escalar mede similaridade direcional e a norma mede magnitude.",
                                  "commonMistakes": [
                                    "Confundir produto escalar com produto vetorial",
                                    "Esquecer raiz quadrada na norma",
                                    "Ignorar dimensão dos vetores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Fórmula da Projeção Ortogonal",
                                  "subSteps": [
                                    "Considere v como soma de componente paralelo a u (proj_u v) e perpendicular (v - proj_u v).",
                                    "Exija que o erro e = v - proj_u v seja ortogonal a u: <e, u> = 0.",
                                    "Substitua e na equação: <v - proj_u v, u> = 0 → <v, u> = <proj_u v, u>.",
                                    "Assuma proj_u v = k u, resolva para k: k = <v, u> / ||u||^2.",
                                    "Escreva a fórmula final: proj_u v = (<v, u> / ||u||^2) u."
                                  ],
                                  "verification": "Derive a fórmula do zero e justifique cada equação algebricamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel quadriculado",
                                    "Livro de Álgebra Linear (capítulo de espaços vetoriais)"
                                  ],
                                  "tips": "Use setas para rastrear substituições na derivação para evitar erros algébricos.",
                                  "learningObjective": "Derivar matematicamente a projeção usando ortogonalidade.",
                                  "commonMistakes": [
                                    "Esquecer de dividir por ||u||^2",
                                    "Confundir k com <v,u>/||u||",
                                    "Não verificar <proj_u v, u - proj_u v> = 0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Projeções Ortogonais Numericamente",
                                  "subSteps": [
                                    "Escolha vetores v = [3, 4] e u = [1, 0].",
                                    "Calcule <v, u> = 3*1 + 4*0 = 3.",
                                    "Calcule ||u||^2 = 1^2 + 0^2 = 1.",
                                    "Encontre proj_u v = (3/1) [1, 0] = [3, 0].",
                                    "Verifique: componente perpendicular [0, 4], e <[3,0], [0,4]> = 0."
                                  ],
                                  "verification": "Calcule projeções para 2 pares de vetores diferentes e confirme ortogonalidade.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora gráfica",
                                    "Planilha Excel ou Python (NumPy)"
                                  ],
                                  "tips": "Automatize com código para múltiplos testes: proj = (np.dot(v,u)/np.dot(u,u)) * u.",
                                  "learningObjective": "Aplicar a fórmula com precisão numérica em exemplos concretos.",
                                  "commonMistakes": [
                                    "Erro aritmético em <v,u>",
                                    "Dividir por ||u|| ao invés de ||u||^2",
                                    "Não verificar ortogonalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar Interpretação Geométrica",
                                  "subSteps": [
                                    "Desenhe u e v no plano, marcando o ponto mais próximo de v na linha de u.",
                                    "Mostre que proj_u v é a sombra de v sobre u (analogia com luz perpendicular).",
                                    "Calcule o comprimento da projeção: ||proj_u v|| = |<v,u>| / ||u||.",
                                    "Visualize decomposição: v = proj_u v + (v - proj_u v), com ângulos retos.",
                                    "Use software para animar a projeção e rotacionar vetores."
                                  ],
                                  "verification": "Crie um diagrama rotulado mostrando decomposição e propriedades geométricas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "GeoGebra",
                                    "Desenhos à mão",
                                    "Vídeos tutoriais de visualização vetorial"
                                  ],
                                  "tips": "Pense em 'drop perpendicular' da ponta de v para a linha u.",
                                  "learningObjective": "Visualizar a projeção como componente paralelo geometricamente.",
                                  "commonMistakes": [
                                    "Confundir com reflexão",
                                    "Ignorar direção de u (projeção é no sentido de u)",
                                    "Desenhos não proporcionais"
                                  ]
                                }
                              ],
                              "practicalExample": "Projetar v = [2, 3, 6] sobre u = [1, 0, 1]: <v,u> = 2+0+6=8, ||u||^2=1+0+1=2, proj_u v = (8/2)[1,0,1] = [4, 0, 4]. Geometricamente, é a sombra de v na direção de u.",
                              "finalVerifications": [
                                "proj_u v é escalar múltiplo de u.",
                                "<v - proj_u v, u> = 0 (ortogonalidade).",
                                "||proj_u v|| = |<v,u>| / ||u||.",
                                "Para u unitário, proj_u v = <v,u> u.",
                                "Decomposição v = proj_u v + perpendicular é única.",
                                "Fórmula funciona em qualquer dimensão R^n."
                              ],
                              "assessmentCriteria": [
                                "Derivação correta da fórmula sem erros algébricos (peso 25%).",
                                "Cálculos numéricos precisos com verificação de ortogonalidade (peso 25%).",
                                "Diagrama geométrico claro e rotulado (peso 20%).",
                                "Explicação verbal da intuição geométrica (peso 15%).",
                                "Generalização para n-dimensões (peso 10%).",
                                "Uso correto de notação vetorial (peso 5%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Decomposição de forças em componentes paralelas/perpendiculares.",
                                "Computação: Projeções em gráficos 3D e ray tracing.",
                                "Engenharia: Análise de sinais e filtros ortogonais.",
                                "Estatística: Projeções em regressão linear e PCA."
                              ],
                              "realWorldApplication": "Em gráficos computacionais, projeções ortogonais são usadas para mapear objetos em telas 2D a partir de vistas 3D; em machine learning, no PCA para redução de dimensionalidade projetando dados em direções principais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.2",
                        "name": "Algoritmo do Processo de Gram-Schmidt Clássico",
                        "description": "Descrição detalhada dos passos iterativos do algoritmo clássico para transformar uma base linearmente independente em uma base ortogonal.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.2.1",
                            "name": "Descrever a inicialização do processo",
                            "description": "Definir q1 = a1 / ||a1|| como o primeiro vetor ortonormal da base {a1, ..., an} linearmente independente, justificando a normalização para obter base ortonormal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o objetivo da inicialização no Processo de Gram-Schmidt",
                                  "subSteps": [
                                    "Relembrar que o Processo de Gram-Schmidt transforma uma base linearmente independente {a1, ..., an} em uma base ortonormal {q1, ..., qn}.",
                                    "Identificar que a inicialização começa com o primeiro vetor para garantir ortogonalidade e normalização desde o início.",
                                    "Explicar verbalmente ou por escrito o papel de q1 como base para os vetores subsequentes.",
                                    "Diferenciar base ortogonal de base ortonormal, enfatizando a norma unitária."
                                  ],
                                  "verification": "Escrever uma definição clara do objetivo da inicialização e confirmar com um colega ou autoavaliação.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta ou editor de texto; referência ao livro de Álgebra Linear.",
                                  "tips": "Use analogias como 'q1 é o primeiro pilar reto e de tamanho padrão em uma construção'.",
                                  "learningObjective": "Entender o propósito fundamental da normalização inicial no algoritmo.",
                                  "commonMistakes": "Confundir ortogonalidade com normalização; ignorar que a base original é linearmente independente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e representar o primeiro vetor a1 da base",
                                  "subSteps": [
                                    "Listar os vetores da base original {a1, a2, ..., an} dada.",
                                    "Confirmar que a1 ≠ 0 (não nulo), pois é linearmente independente.",
                                    "Representar a1 em coordenadas, por exemplo, a1 = [x1, x2, ..., xm] em R^m.",
                                    "Verificar dimensionalidade consistente com o espaço vetorial."
                                  ],
                                  "verification": "Desenhar ou anotar a1 corretamente e afirmar que ||a1|| > 0.",
                                  "estimatedTime": "5 minutos",
                                  "materials": "Folha de exercícios ou software como MATLAB/Octave para visualização.",
                                  "tips": "Sempre anote a base completa para contexto futuro no processo.",
                                  "learningObjective": "Identificar corretamente o vetor inicial da base fornecida.",
                                  "commonMistakes": "Escolher vetor nulo ou inverter ordem dos vetores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a norma euclidiana ||a1||",
                                  "subSteps": [
                                    "Aplicar a fórmula ||a1|| = sqrt(a1^T * a1) ou sqrt(∑ xi^2).",
                                    "Realizar os cálculos componentes: somar quadrados das coordenadas.",
                                    "Extrair a raiz quadrada e arredondar se necessário para precisão numérica.",
                                    "Verificar se o resultado é positivo e não zero."
                                  ],
                                  "verification": "Comparar cálculo manual com calculadora ou função norm() em software.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Calculadora científica; planilha Excel ou Python (numpy.linalg.norm).",
                                  "tips": "Use precisão de 4 casas decimais para evitar erros de propagação.",
                                  "learningObjective": "Dominar o cálculo da norma L2 de um vetor.",
                                  "commonMistakes": "Esquecer a raiz quadrada; usar norma errada (ex: L1 ou L-infinito)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir q1 = a1 / ||a1||",
                                  "subSteps": [
                                    "Dividir cada componente de a1 pela norma calculada.",
                                    "Escrever explicitamente q1 com coordenadas normalizadas.",
                                    "Confirmar que q1 é unitário: ||q1|| = 1.",
                                    "Verificar se direção é preservada (sentido igual a a1)."
                                  ],
                                  "verification": "Calcular ||q1|| e confirmar que é aproximadamente 1 (erro < 10^-10).",
                                  "estimatedTime": "8 minutos",
                                  "materials": "Mesmos da norma; software para verificação matricial.",
                                  "tips": "Mantenha frações exatas quando possível, ex: 1/sqrt(2) em vez de 0.7071.",
                                  "learningObjective": "Construir o primeiro vetor ortonormal unitário.",
                                  "commonMistakes": "Dividir pela norma ao quadrado; inverter sinal."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Justificar a normalização para base ortonormal",
                                  "subSteps": [
                                    "Explicar que divisão por ||a1|| garante ||q1|| = 1, essencial para base ortonormal.",
                                    "Discutir que ortogonalidade será induzida nos passos seguintes via projeções.",
                                    "Relacionar com propriedades: <qi, qj> = δij (delta de Kronecker).",
                                    "Argumentar estabilidade numérica e aplicações em algoritmos."
                                  ],
                                  "verification": "Redigir um parágrafo de justificativa e autoavaliar clareza.",
                                  "estimatedTime": "12 minutos",
                                  "materials": "Livro-texto de Álgebra Linear; vídeo tutorial sobre Gram-Schmidt.",
                                  "tips": "Use equações: ||a1 / ||a1||| = ||a1|| / ||a1|| = 1.",
                                  "learningObjective": "Articular racionalmente a necessidade da normalização.",
                                  "commonMistakes": "Confundir com ortogonalização sem normalização (base ortogonal apenas)."
                                }
                              ],
                              "practicalExample": "Dada a base {a1 = [3, 4], a2 = [1, 2]} em R^2: Calcule ||a1|| = sqrt(9+16) = 5; q1 = [3/5, 4/5] = [0.6, 0.8]. Verifique: 0.6^2 + 0.8^2 = 1. Justificativa: Garante vetor unitário para projeções subsequentes em a2.",
                              "finalVerifications": [
                                "q1 é calculado corretamente com norma unitária.",
                                "Justificativa escrita explica normalização para ||q1||=1.",
                                "Base original é identificada como linearmente independente.",
                                "Verificação numérica de ||q1|| ≈ 1 realizada.",
                                "Conexão com passos subsequentes do Gram-Schmidt explicitada.",
                                "Exemplo prático resolvido sem erros aritméticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo da norma (erro < 0.01).",
                                "Clareza na definição de q1 com componentes corretas.",
                                "Justificativa completa e correta (mínimo 3 razões válidas).",
                                "Uso apropriado de notação matemática (vetores, norma).",
                                "Verificações independentes realizadas e documentadas.",
                                "Explicação verbal ou escrita fluida e sem ambiguidades."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação em Python/MATLAB para decomposição QR.",
                                "Física: Vetores unitários em mecânica (direções normalizadas).",
                                "Estatística: Projeções ortogonais em regressão linear.",
                                "Engenharia: Processamento de sinais com bases ortonormais."
                              ],
                              "realWorldApplication": "Na decomposição QR usada em algoritmos de busca como PageRank do Google, resolução numérica de sistemas lineares em engenharia, e redução de dimensionalidade em machine learning para análise de dados de imagens ou áudio."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1.3"
                            ]
                          },
                          {
                            "id": "10.1.3.1.2.2",
                            "name": "Executar iterações subsequentes para ortogonalização",
                            "description": "Para k=2 a n, calcular uk = ak - sum_{j=1}^{k-1} (<ak, qj> qj), removendo componentes paralelos aos qj anteriores, e então qk = uk / ||uk||.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os vetores para a iteração k",
                                  "subSteps": [
                                    "Identifique o índice k (de 2 até n) na sequência do processo.",
                                    "Selecione o vetor coluna ak da matriz A original.",
                                    "Liste todos os vetores qj ortonormais já computados (j = 1 até k-1).",
                                    "Confirme que todos os qj anteriores têm norma unitária (||qj|| = 1).",
                                    "Anote os vetores em uma tabela ou workspace para facilitar os cálculos."
                                  ],
                                  "verification": "Verifique se ak e a lista de qj estão corretamente identificados e anotados sem erros de indexação.",
                                  "estimatedTime": "5 minutos",
                                  "materials": "Matriz A, papel e calculadora, ou software como Python (NumPy) ou MATLAB.",
                                  "tips": "Mantenha uma tabela organizada com colunas para ak, q1, q2, ..., q_{k-1}.",
                                  "learningObjective": "Preparar com precisão os insumos necessários para evitar erros propagados nas iterações subsequentes.",
                                  "commonMistakes": "Usar qk em vez de ak ou esquecer de verificar a normalização dos qj anteriores."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os coeficientes de projeção <ak, qj>",
                                  "subSteps": [
                                    "Para cada j de 1 até k-1, compute o produto interno <ak, qj> = soma_{i=1}^m ak_i * qj_i.",
                                    "Anote cada coeficiente r_{j k} = <ak, qj> em uma lista.",
                                    "Verifique o sinal e a precisão decimal de cada produto interno.",
                                    "Registre os valores em uma tabela ao lado dos vetores qj.",
                                    "Confirme que os cálculos são exatos ou com precisão numérica adequada (ex: 4 casas decimais)."
                                  ],
                                  "verification": "Compare os produtos internos com um cálculo manual ou função de software para validar todos os r_{j k}.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Calculadora ou função dot() em NumPy/Python.",
                                  "tips": "Use multiplicação escalar-vetor mentalmente para vetores pequenos para agilizar.",
                                  "learningObjective": "Dominar o cálculo preciso de produtos internos para projeções ortogonais.",
                                  "commonMistakes": "Invertar a ordem no produto interno ou ignorar componentes negativos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar a soma das projeções sum_{j=1}^{k-1} (<ak, qj> qj)",
                                  "subSteps": [
                                    "Para cada j, multiplique r_{j k} pelo vetor qj (escalar por vetor).",
                                    "Some todos os vetores resultantes: proj_k = soma_{j=1}^{k-1} r_{j k} qj.",
                                    "Realize a soma componente a componente (uma por dimensão).",
                                    "Arredonde apenas no final e verifique a soma zero em componentes irrelevantes.",
                                    "Anote o vetor proj_k completo."
                                  ],
                                  "verification": "Verifique se proj_k está na subespaço gerado pelos qj anteriores somando linearmente.",
                                  "estimatedTime": "8 minutos",
                                  "materials": "Papel quadriculado ou editor de vetores em software.",
                                  "tips": "Faça a soma coluna por coluna para evitar erros de alinhamento.",
                                  "learningObjective": "Construir corretamente a projeção de ak sobre o subespaço ortonormal anterior.",
                                  "commonMistakes": "Esquecer de multiplicar o escalar em todas as componentes ou somar errado os índices."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular o vetor residual uk = ak - proj_k",
                                  "subSteps": [
                                    "Subtraia componente a componente: uk_i = ak_i - proj_k_i para cada i.",
                                    "Confirme que uk ≠ 0 (não colinear com subespaço anterior).",
                                    "Verifique ortogonalidade preliminar: <uk, qj> ≈ 0 para j < k.",
                                    "Anote uk com precisão adequada.",
                                    "Registre a norma ||uk|| para o próximo passo."
                                  ],
                                  "verification": "Compute <uk, qj> para cada j < k; deve ser próximo de zero (erro numérico < 10^{-10}).",
                                  "estimatedTime": "5 minutos",
                                  "materials": "Mesmos do passo anterior.",
                                  "tips": "Use subtração vetorial em software para precisão.",
                                  "learningObjective": "Obter o componente ortogonal de ak removendo projeções paralelas.",
                                  "commonMistakes": "Subtrair na ordem errada (proj_k - ak) ou alinhar componentes incorretamente."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Normalizar uk para obter qk",
                                  "subSteps": [
                                    "Calcule a norma euclidiana ||uk|| = sqrt(soma uk_i^2).",
                                    "Divida cada componente: qk_i = uk_i / ||uk||.",
                                    "Verifique se ||qk|| = 1.",
                                    "Confirme ortogonalidade final com qj anteriores.",
                                    "Adicione qk à lista de vetores ortonormais."
                                  ],
                                  "verification": "||qk|| = 1 e <qk, qj> = 0 para todo j < k.",
                                  "estimatedTime": "7 minutos",
                                  "materials": "Função norm() em software.",
                                  "tips": "Evite divisão por zero checando ||uk|| > epsilon (ex: 10^{-12}).",
                                  "learningObjective": "Produzir um vetor unitário ortogonal aos anteriores.",
                                  "commonMistakes": "Erro no cálculo da norma (esquecer sqrt) ou normalizar ak em vez de uk."
                                }
                              ],
                              "practicalExample": "Considere vetores em R^2 com q1 = [1, 0]^T (unitário), ak = a2 = [1, 1]^T. Calcule <a2, q1> = 1. Proj = 1*[1,0]^T = [1,0]^T. uk = [1,1]^T - [1,0]^T = [0,1]^T. ||uk||=1, q2=[0,1]^T. Verificações: <q2,q1>=0, ||q2||=1.",
                              "finalVerifications": [
                                "||qk|| = 1 (norma unitária).",
                                "<qk, qj> = 0 para todos j = 1 até k-1.",
                                "<ak, qk> = ||uk|| (componente residual correto).",
                                "uk é ortogonal ao subespaço span{q1,...,q_{k-1}}.",
                                "Todos os cálculos com erro numérico inferior a 10^{-8}.",
                                "qk span{a1,...,ak} junto com q1..q_{k-1}."
                              ],
                              "assessmentCriteria": [
                                "Precisão em todos os produtos internos e somas (erro < 0.01).",
                                "Correta remoção de componentes paralelos (ortogonalidade verificada).",
                                "Normalização exata do vetor residual.",
                                "Eficiência nos passos sem redundâncias desnecessárias.",
                                "Explicação clara dos cálculos intermediários.",
                                "Aplicação correta em exemplo numérico fornecido."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em loop for no NumPy/Python para automação do Gram-Schmidt.",
                                "Física: Bases ortonormais em mecânica quântica para estados independentes.",
                                "Computação Gráfica: Ortogonalização para transformações de coordenadas e rotação.",
                                "Estatística: Projeções em regressão linear múltipla."
                              ],
                              "realWorldApplication": "Essas iterações são cruciais na decomposição QR para resolver sistemas lineares Ax=b via Q^{-1}Ry=b (estabilidade numérica), em mínimos quadrados para ajuste de dados experimentais, e em algoritmos de compressão de sinais/imagens via bases ortogonais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1.3",
                              "10.1.3.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.1.2.3",
                            "name": "Verificar independência linear no processo",
                            "description": "Explicar por que o processo preserva a independência linear, mostrando que uk ≠ 0 se {a1,...,ak} é independente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Construção de uk no Processo de Gram-Schmidt",
                                  "subSteps": [
                                    "Lembre-se da fórmula do Processo de Gram-Schmidt clássico: uk = ak - ∑_{j=1}^{k-1} (⟨ak, uj⟩ / ⟨uj, uj⟩) uj.",
                                    "Identifique que uk é ak menos sua projeção ortogonal sobre o span(u1, ..., u_{k-1}).",
                                    "Note que span(u1, ..., u_{k-1}) = span(a1, ..., a_{k-1}), pois o processo preserva o span.",
                                    "Entenda que uk é ortogonal ao span anterior se não for zero.",
                                    "Escreva a fórmula explicitamente para k=2 como exemplo inicial: u2 = a2 - (⟨a2, u1⟩ / ⟨u1, u1⟩) u1."
                                  ],
                                  "verification": "Escreva a fórmula de uk corretamente e explique verbalmente o que representa a subtração.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Livro ou notas de Álgebra Linear (capítulo Gram-Schmidt)",
                                    "Calculadora para produto interno"
                                  ],
                                  "tips": [
                                    "Visualize geometricamente: uk é o resíduo perpendicular à subespaço anterior.",
                                    "Use notação vetorial para clareza."
                                  ],
                                  "learningObjective": "Compreender a estrutura algébrica de uk como resíduo de projeção.",
                                  "commonMistakes": [
                                    "Confundir span(u1..uk-1) com span(a1..ak-1) - eles são iguais.",
                                    "Esquecer a normalização no coeficiente de projeção."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Assumir Independência Linear do Conjunto Original {a1, ..., ak}",
                                  "subSteps": [
                                    "Defina independência linear: α1 a1 + ... + αk ak = 0 implica αi = 0 para todo i.",
                                    "Explique que {a1, ..., a_{k-1}} é independente por hipótese indutiva.",
                                    "Afirme que ak não está no span(a1, ..., a_{k-1}), pois caso contrário haveria dependência.",
                                    "Conecte isso à ideia de que projeção de ak sobre span anterior não pode ser ak inteiro.",
                                    "Esboce um contra-exemplo rápido: se independente, ak fora do hiperplano anterior."
                                  ],
                                  "verification": "Forneça a definição formal e dê um exemplo de 2 vetores independentes em R^2.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Exemplos de vetores em R^2 ou R^3",
                                    "Software como GeoGebra para visualização geométrica"
                                  ],
                                  "tips": [
                                    "Pense indutivamente: assume verdadeiro para k-1, prove para k.",
                                    "Desenhe vetores para intuição geométrica."
                                  ],
                                  "learningObjective": "Reconhecer que independência implica ak ∉ span(a1..a_{k-1}).",
                                  "commonMistakes": [
                                    "Confundir independência com ortogonalidade.",
                                    "Ignorar hipótese indutiva."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar por Contrapositiva: uk = 0 Implica Dependência Linear",
                                  "subSteps": [
                                    "Suponha uk = 0: ak = ∑_{j=1}^{k-1} (⟨ak, uj⟩ / ⟨uj, uj⟩) uj.",
                                    "Substitua uj pelos aj correspondentes, mostrando ak ∈ span(a1, ..., a_{k-1}).",
                                    "Conclua que existe combinação linear não-trivial: ak - soma coef * aj = 0.",
                                    "Isso contradiz a independência de {a1, ..., ak}.",
                                    "Formalize: os coeficientes não são todos zero pois uk=0 só se projeção cobre ak."
                                  ],
                                  "verification": "Escreva a prova por contrapositiva em 4-5 linhas e verifique logicamente.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Papel para prova escrita",
                                    "Referência: teorema de preservação de independência em Gram-Schmidt"
                                  ],
                                  "tips": [
                                    "Use prova por contradição: assume uk=0 e derive absurdum.",
                                    "Verifique com produto interno zero."
                                  ],
                                  "learningObjective": "Dominar a prova de que uk=0 leva a dependência linear.",
                                  "commonMistakes": [
                                    "Não expressar de volta em termos de aj.",
                                    "Esquecer que coeficientes derivam de projeções não-zero."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir Preservação da Independência Linear no Processo",
                                  "subSteps": [
                                    "Pelo contrapositiva: se {a1,...,ak} independente, então uk ≠ 0.",
                                    "Assim, {u1, ..., uk} é independente, pois u1..u_{k-1} já eram e uk ∉ span anterior.",
                                    "Indução: base k=1 trivial (u1=a1≠0 assumido), passo indutivo ok.",
                                    "Verifique numericamente em um exemplo simples.",
                                    "Discuta implicações: processo para até detectar dependência (uk=0)."
                                  ],
                                  "verification": "Resuma a prova completa e aplique a um exemplo numérico.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Exemplo numérico resolvido",
                                    "Python/MATLAB para computar uk (opcional)"
                                  ],
                                  "tips": [
                                    "Sempre termine com indução para generalidade.",
                                    "Teste com k=3 para confiança."
                                  ],
                                  "learningObjective": "Explicar completamente por que Gram-Schmidt preserva independência.",
                                  "commonMistakes": [
                                    "Parar na contrapositiva sem concluir preservação.",
                                    "Assumir normalização afeta independência (não afeta)."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a1 = [1, 0]^T, a2 = [1, 1]^T em R^2 (independentes). u1 = a1. u2 = a2 - (⟨a2,u1⟩/⟨u1,u1⟩)u1 = [1,1] - (1/1)[1,0] = [0,1] ≠ 0. Se a2=[1,0] (dependente), u2=[0,0]. Isso ilustra: independência original → uk ≠0.",
                              "finalVerifications": [
                                "Explique verbalmente a prova da contrapositiva sem olhar notas.",
                                "Aplique a um novo par de vetores e verifique uk ≠0.",
                                "Identifique onde uk=0 indicaria falha de independência.",
                                "Escreva a indução formal para preservação.",
                                "Discuta o que acontece se ||ak||=0 (caso degenerado)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula de uk e projeção (100% correto).",
                                "Correta aplicação da contrapositiva e ausência de erros lógicos.",
                                "Uso apropriado de indução e conexão span(u) = span(a).",
                                "Exemplo prático resolvido com cálculos exatos.",
                                "Explicação clara e concisa da preservação de independência.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar Gram-Schmidt em Python/NumPy para detectar dependência numérica.",
                                "Física: Bases ortonormais em mecânica quântica (estados independentes).",
                                "Estatística: Decomposição QR em regressão linear e PCA.",
                                "Computação Gráfica: Ortogonalização para transformações lineares estáveis."
                              ],
                              "realWorldApplication": "No software de álgebra computacional (ex: MATLAB qr()), detecta dependência linear em dados reais para evitar instabilidades numéricas em simulações de engenharia, machine learning (redução dimensional) e processamento de sinais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.2.2"
                            ]
                          },
                          {
                            "id": "10.1.3.1.2.4",
                            "name": "Relacionar com a decomposição QR",
                            "description": "Identificar que as colunas de Q = [q1,...,qn] formam uma base ortonormal e R é upper triangular com r_{jj} = ||uj|| e r_{ij} = <ai, qj> para i>j.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Processo de Gram-Schmidt Clássico",
                                  "subSteps": [
                                    "Lembre-se da sequência: para cada coluna a_j de A, compute u_j = a_j - ∑_{k=1}^{j-1} ⟨a_j, q_k⟩ q_k.",
                                    "Em seguida, normalize q_j = u_j / ||u_j||.",
                                    "Colete as q_j em Q = [q1, q2, ..., qn].",
                                    "Identifique os coeficientes r_{k j} = ⟨a_j, q_k⟩ para k < j e r_{j j} = ||u_j||.",
                                    "Verifique que as colunas de Q são ortonormais: ⟨q_i, q_j⟩ = δ_{ij}."
                                  ],
                                  "verification": "Escreva os passos do algoritmo para uma matriz A de 3x2 e confirme ortonormalidade de Q.",
                                  "estimatedTime": "15 minutes",
                                  "materials": [
                                    "Papel e caneta",
                                    "Matriz de exemplo A = [[1,1],[0,1],[0,0]]"
                                  ],
                                  "tips": "Use notação vetorial clara e compute inner products passo a passo.",
                                  "learningObjective": "Compreender os passos exatos do Gram-Schmidt e como Q emerge.",
                                  "commonMistakes": [
                                    "Confundir u_j com q_j",
                                    "Esquecer subtrair projeções anteriores",
                                    "Não normalizar corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Propriedades da Matriz Q",
                                  "subSteps": [
                                    "Confirme que as colunas q1 a qn formam uma base ortonormal para o espaço coluna de A.",
                                    "Verifique Q^T Q = I (propriedade ortonormal).",
                                    "Note que Q tem as mesmas dimensões de A (m x n, com m >= n).",
                                    "Discuta que Q é isométrica: ||Q x|| = ||x|| para vetores x.",
                                    "Compare com a base original das colunas de A."
                                  ],
                                  "verification": "Compute Q^T Q para seu exemplo e confirme identidade.",
                                  "estimatedTime": "10 minutes",
                                  "materials": [
                                    "Calculadora ou software como Python/NumPy",
                                    "Matriz Q do passo anterior"
                                  ],
                                  "tips": "Aproveite simetria: só compute elementos necessários.",
                                  "learningObjective": "Reconhecer Q como matriz com colunas ortonormais.",
                                  "commonMistakes": [
                                    "Assumir Q quadrada",
                                    "Ignorar que é base para col(A)",
                                    "Erro em transposição"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e Analisar a Matriz R Upper Triangular",
                                  "subSteps": [
                                    "Defina r_{j j} = ||u_j|| para a diagonal.",
                                    "Defina r_{i j} = ⟨a_i, q_j⟩ para i < j? Não: para fixed j, r_{k j} = ⟨a_j, q_k⟩ k=1 to j-1, r_{j j}=||u_j||.",
                                    "Preencha zeros abaixo da diagonal.",
                                    "Verifique dimensionalidade: R é n x n.",
                                    "Note que R captura os coeficientes de projeção."
                                  ],
                                  "verification": "Construa R explicitamente para o exemplo e confirme upper triangular.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Valores de u_j e inner products do passo 1"
                                  ],
                                  "tips": "Lembre: inner product ⟨a_j, q_k⟩ é o coeficiente para projeção em q_k.",
                                  "learningObjective": "Entender como R é formada a partir de Gram-Schmidt.",
                                  "commonMistakes": [
                                    "Índices errados: r_{i j} com i>j",
                                    "Usar ||q_j|| em vez de ||u_j||",
                                    "Confundir a_j com u_j"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a Decomposição A = Q R",
                                  "subSteps": [
                                    "Multiplique Q R e compare com A original.",
                                    "Verifique coluna por coluna: j-ésima coluna de QR = ∑_{k=1}^j r_{k j} q_k = a_j.",
                                    "Confirme que isso reproduz o processo de Gram-Schmidt.",
                                    "Discuta estabilidade numérica (clássico vs modificado).",
                                    "Generalize para qualquer A com colunas linearmente independentes."
                                  ],
                                  "verification": "Compute QR e veja se iguala A numericamente (erro < 1e-10).",
                                  "estimatedTime": "15 minutes",
                                  "materials": [
                                    "Software MATLAB/Python para multiplicação",
                                    "Q e R construídas"
                                  ],
                                  "tips": "Verifique coluna por coluna para insight algébrico.",
                                  "learningObjective": "Estabelecer a equivalência entre Gram-Schmidt e QR.",
                                  "commonMistakes": [
                                    "Erro de multiplicação matricial",
                                    "Ignorar dependência linear",
                                    "Confundir ordem das colunas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[3, 1], [1, 2], [0, 1]]^T (3x2): Gram-Schmidt dá q1 = [3,1,0]/√10, u2 = [1,2,0] - proj, etc. Então Q = [q1 q2], R = [[√10, <a2,q1>], [0, ||u2||]]. Verifique A = QR.",
                              "finalVerifications": [
                                "Explica verbalmente como Q é ortonormal e R upper triangular.",
                                "Constrói QR para nova matriz 3x3.",
                                "Identifica r_{jj} = ||u_j|| em exemplo dado.",
                                "Confirma A = QR coluna por coluna.",
                                "Discute propriedades sem usar software.",
                                "Responde quiz: 'Por que R é upper triangular?'"
                              ],
                              "assessmentCriteria": [
                                "Identificação correta de Q ortonormal: 25%",
                                "Construção precisa de R com r_{jj} e r_{ij}: 30%",
                                "Verificação A=QR exata: 20%",
                                "Explicação das relações ⟨a_i, q_j⟩: 15%",
                                "Generalização e propriedades: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação numérica em NumPy para QR.",
                                "Física: Projeções ortogonais em mecânica quântica.",
                                "Estatística: Regressão least squares via QR.",
                                "Engenharia: Estabilização de sistemas lineares."
                              ],
                              "realWorldApplication": "Na resolução estável de sistemas lineares Ax=b via substituição forward/backward em QR, evitando ill-conditioned A; usado em Google PageRank, processamento de imagens e machine learning para fatoração SVD aproximada."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.3",
                        "name": "Implementação e Análise Prática",
                        "description": "Aplicação do algoritmo em exemplos numéricos e considerações iniciais sobre estabilidade numérica no contexto computacional.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.3.1",
                            "name": "Implementar pseudocódigo do Gram-Schmidt clássico",
                            "description": "Escrever pseudocódigo para o algoritmo em MATLAB ou Python, incluindo loops para k=1 a n e computação de projeções.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a estrutura da função e inicializar variáveis",
                                  "subSteps": [
                                    "Escreva a assinatura da função em pseudocódigo: função Q = GramSchmidt(A), onde A é uma matriz m x n com m >= n e colunas linearmente independentes.",
                                    "Inicialize a matriz Q como uma matriz m x n de zeros.",
                                    "Adicione comentários explicando as dimensões e suposições (ex.: colunas de A são linearmente independentes).",
                                    "Defina variáveis auxiliares se necessário, como contadores para k e j.",
                                    "Especifique o retorno: matriz Q cujas colunas são ortonormais."
                                  ],
                                  "verification": "Verifique se a função tem assinatura correta, Q inicializada com dimensões m x n e comentários presentes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE (MATLAB, Python/Jupyter)",
                                    "Documentação do algoritmo Gram-Schmidt"
                                  ],
                                  "tips": "Use pseudocódigo genérico antes de adaptar para MATLAB ou Python para focar na lógica.",
                                  "learningObjective": "Compreender os inputs, outputs e inicialização necessária para o algoritmo.",
                                  "commonMistakes": [
                                    "Esquecer de especificar dimensões de A e Q",
                                    "Não assumir independência linear das colunas",
                                    "Inicializar Q incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o loop externo para k = 1 até n",
                                  "subSteps": [
                                    "Inicie o loop for k = 1 to n.",
                                    "Dentro do loop, defina uk = coluna k de A (A[:,k]).",
                                    "Para k=1, prossiga diretamente para normalização (sem projeções).",
                                    "Estruture o código para acomodar o loop interno posteriormente.",
                                    "Adicione comentário: 'Computar vetor ortogonal não normalizado uk'."
                                  ],
                                  "verification": "Execute mentalmente para k=1: uk deve ser igual a A[:,1] sem modificações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para esboçar loops",
                                    "Exemplo de matriz pequena para teste mental"
                                  ],
                                  "tips": "Use notação matricial como A[:,k] para clareza em pseudocódigo.",
                                  "learningObjective": "Dominar a iteração sobre as colunas de A no loop principal.",
                                  "commonMistakes": [
                                    "Índices errados (começar k=0)",
                                    "Confundir uk com qk prematuramente",
                                    "Loop de k=2 a n sem tratar k=1"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o loop interno para computar projeções",
                                  "subSteps": [
                                    "Adicione loop interno for j = 1 to k-1.",
                                    "Calcule a projeção: proj = (Q[:,j]^T * uk) (produto escalar).",
                                    "Subtraia a projeção: uk = uk - proj * Q[:,j].",
                                    "Feche o loop interno após a subtração.",
                                    "Adicione comentário: 'Ortogonalizar uk em relação a q1 até q_{k-1}'."
                                  ],
                                  "verification": "Para k=2, uk deve ser A[:,2] - (Q[:,1]^T * A[:,2]) * Q[:,1].",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou MATLAB/Python para validar fórmula de projeção",
                                    "Folha com notação vetorial"
                                  ],
                                  "tips": "Lembre-se: projeção é coeficiente <qj, ak> * qj, mas aqui uk é atualizado.",
                                  "learningObjective": "Implementar corretamente a ortogonalização sequencial via projeções.",
                                  "commonMistakes": [
                                    "Usar norma em vez de produto interno",
                                    "Índice j até k ao invés de k-1",
                                    "Ordem errada: subtrair antes de calcular proj"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar normalização e finalizar o pseudocódigo",
                                  "subSteps": [
                                    "Após loops, calcule a norma: rkk = norma euclidiana de uk (||uk||).",
                                    "Normalize: Q[:,k] = uk / rkk.",
                                    "Adicione verificação condicional se rkk ≈ 0 (dependência linear, opcional).",
                                    "Feche o loop externo e adicione return Q.",
                                    "Inclua comentários finais sobre propriedades de Q."
                                  ],
                                  "verification": "Confirme que todas colunas Q são unitárias e o código cobre k=1 corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de funções norm() em MATLAB/Python"
                                  ],
                                  "tips": "Use norma L2 (euclidiana) para vetores.",
                                  "learningObjective": "Garantir que Q tenha colunas ortonormais via normalização.",
                                  "commonMistakes": [
                                    "Normalizar antes das projeções",
                                    "Dividir por zero sem check",
                                    "Esquecer de atualizar Q[:,k]"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 1], [0, 1]] (m=2, n=2).\n- k=1: uk=[1,0], r11=norm(uk)=1, Q[:,1]=[1,0].\n- k=2: uk=[1,1], proj=Q1^T*uk=1, uk= [1,1] -1*[1,0]=[0,1], r22=1, Q[:,2]=[0,1].\nPseudocódigo produz Q identidade, verificando ortonormalidade.",
                              "finalVerifications": [
                                "Colunas de Q têm norma unitária (||Q[:,k]|| = 1 para todo k).",
                                "Colunas são ortogonais (Q[:,i]^T * Q[:,j] = 0 para i ≠ j).",
                                "Espaço colunar de Q igual ao de A (QA ≈ A com erro numérico pequeno).",
                                "Pseudocódigo executa sem loops infinitos ou erros de índice.",
                                "Para k=1, nenhuma projeção é subtraída.",
                                "Normalização ocorre após todas projeções."
                              ],
                              "assessmentCriteria": [
                                "Estrutura de loops aninhados correta (externo k=1:n, interno j=1:k-1).",
                                "Fórmula de projeção exata: coef = Qj^T * uk, subtração uk -= coef * Qj.",
                                "Normalização precisa: Qk = uk / ||uk|| após ortogonalização.",
                                "Tratamento correto do caso k=1 (sem loop interno).",
                                "Comentários claros e notação consistente (ex.: A[:,k]).",
                                "Ausência de erros comuns como divisão por zero não tratada."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Loops aninhados e manipulação de matrizes em Python/MATLAB.",
                                "Análise Numérica: Estabilidade do Gram-Schmidt clássico vs. modificado.",
                                "Cálculo Vetorial: Produtos internos e normas euclidianas.",
                                "Ciência de Dados: Pré-processamento para PCA ou regressão linear."
                              ],
                              "realWorldApplication": "O pseudocódigo é base para decomposição QR, usada em resolução de sistemas lineares superdeterminados (mínimos quadrados), eigenvalores, compressão de imagens e machine learning (ex.: ortonormalização em redes neurais ou SVD aproximado)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.2.2"
                            ]
                          },
                          {
                            "id": "10.1.3.1.3.2",
                            "name": "Aplicar em exemplo numérico de dimensão baixa",
                            "description": "Executar o processo manualmente para uma matriz 3x3 com vetores linearmente independentes, computando Q e R e verificando A = QR.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a matriz A 3x3 e verificar independência linear das colunas",
                                  "subSteps": [
                                    "Escolha uma matriz 3x3 cujas colunas sejam linearmente independentes, como A = [[1, 1, 0], [1, 0, 1], [0, 1, 1]]",
                                    "Liste as colunas: a₁ = [1, 1, 0]ᵀ, a₂ = [1, 0, 1]ᵀ, a₃ = [0, 1, 1]ᵀ",
                                    "Verifique independência calculando det(A) ≈ 2 ≠ 0 ou testando se apenas a solução trivial satisfaz A x = 0",
                                    "Calcule a norma euclidiana de a₁: ||a₁|| = √(1² + 1² + 0²) = √2 ≈ 1.414",
                                    "Escreva todas as componentes com precisão decimal se necessário"
                                  ],
                                  "verification": "Matriz A transcrita corretamente, colunas listadas e independência confirmada por determinante ou teste de nulidade.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Caneta",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Use matrizes com números inteiros pequenos para facilitar cálculos manuais.",
                                  "learningObjective": "Preparar o conjunto de vetores iniciais e confirmar condições para Gram-Schmidt.",
                                  "commonMistakes": [
                                    "Escolher matriz singular (det=0)",
                                    "Erros na transcrição das colunas",
                                    "Confundir linhas com colunas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar o primeiro vetor ortonormal q₁",
                                  "subSteps": [
                                    "Defina u₁ = a₁ = [1, 1, 0]ᵀ",
                                    "Calcule ||u₁|| = √2",
                                    "Normalize: q₁ = u₁ / ||u₁|| = [1/√2, 1/√2, 0]ᵀ ≈ [0.707, 0.707, 0]ᵀ",
                                    "Verifique ||q₁|| = 1 e escreva com 3 casas decimais para precisão",
                                    "Confirme q₁ · q₁ = 1"
                                  ],
                                  "verification": "q₁ unitário: ||q₁||² = 1 e componentes corretas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Mantenha frações exatas como 1/√2 até o final para evitar erros de arredondamento.",
                                  "learningObjective": "Aplicar normalização ao primeiro vetor sem projeções.",
                                  "commonMistakes": [
                                    "Esquecer de dividir pela norma",
                                    "Erro no cálculo da norma (esquecer raiz)",
                                    "Arredondar prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar o segundo vetor ortonormal q₂",
                                  "subSteps": [
                                    "Calcule o produto interno r₁₂ = q₁ · a₂ = (1/√2)(1) + (1/√2)(0) + 0(1) = 1/√2 ≈ 0.707",
                                    "Projete: proj_{q₁} a₂ = r₁₂ q₁ ≈ [0.5, 0.5, 0]ᵀ",
                                    "Subtraia: u₂ = a₂ - proj_{q₁} a₂ = [1, 0, 1]ᵀ - [0.5, 0.5, 0]ᵀ = [0.5, -0.5, 1]ᵀ",
                                    "Calcule ||u₂|| = √(0.25 + 0.25 + 1) = √1.5 = √(3/2) ≈ 1.225",
                                    "Normalize: q₂ = u₂ / ||u₂|| ≈ [-0.408, 0.408, -0.816]ᵀ (sinais corretos)"
                                  ],
                                  "verification": "q₁ · q₂ = 0 (ortogonalidade) e ||q₂|| = 1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Anote produtos internos em tabela para rastrear r_ij.",
                                  "learningObjective": "Realizar projeção e ortogonalização para o segundo vetor.",
                                  "commonMistakes": [
                                    "Sinal errado na subtração da projeção",
                                    "Erro no produto interno",
                                    "Normalizar vetor não ortogonalizado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar o terceiro vetor ortonormal q₃",
                                  "subSteps": [
                                    "Calcule r₁₃ = q₁ · a₃ ≈ 0.707, r₂₃ = q₂ · a₃ ≈ -0.408",
                                    "Projete: proj = r₁₃ q₁ + r₂₃ q₂ ≈ [0.289, 0.289, 0] + [-0.333, 0.333, -0.666] ≈ [-0.044, 0.622, -0.666]",
                                    "Subtraia: u₃ = a₃ - proj ≈ [0,1,1] - [-0.044, 0.622, -0.666] ≈ [0.044, 0.378, 1.666]",
                                    "||u₃|| ≈ √(0.002 + 0.143 + 2.775) ≈ √2.92 ≈ 1.709",
                                    "q₃ = u₃ / ||u₃|| ≈ [0.026, 0.221, 0.975]ᵀ (valores aproximados; use exatos)"
                                  ],
                                  "verification": "q₁ · q₃ = 0, q₂ · q₃ = 0 e ||q₃|| = 1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Use aproximações consistentes ou frações para manter precisão.",
                                  "learningObjective": "Estender ortogonalização sequencial ao terceiro vetor.",
                                  "commonMistakes": [
                                    "Esquecer uma projeção",
                                    "Erros de sinal em subtrações múltiplas",
                                    "Cálculo incorreto de múltiplas normas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Construir Q e R, e verificar a decomposição A = QR",
                                  "subSteps": [
                                    "Forme Q = [q₁ q₂ q₃] (matriz 3x3 com colunas q_i)",
                                    "Compute R = Qᵀ A, onde r_{ij} = q_i · a_j (triangular superior)",
                                    "Multiplique Q R e compare com A original componente a componente",
                                    "Verifique ortonormalidade: Qᵀ Q ≈ I (identidade)",
                                    "Registre discrepâncias numéricas devidas a arredondamento (<10^{-3})"
                                  ],
                                  "verification": "Q R = A (exato ou com erro pequeno) e Q ortonormal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Compute R usando produtos internos em vez de multiplicação completa para eficiência.",
                                  "learningObjective": "Finalizar decomposição e validar o processo Gram-Schmidt.",
                                  "commonMistakes": [
                                    "Trocar linhas/colunas em Q",
                                    "Erro em Qᵀ A",
                                    "Ignorar verificação de ortonormalidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[1,1,0],[1,0,1],[0,1,1]], obtém-se q₁ ≈ [0.707,0.707,0], q₂ ≈ [-0.408,0.408,-0.816], q₃ ≈ [0.026,0.221,0.975]; R ≈ [[1.414,0.707,0.707],[0,1.225,-0.408],[0,0,1.709]]; multiplicação Q R recupera A com erro numérico mínimo.",
                              "finalVerifications": [
                                "Colunas de Q são unitárias: ||q_i|| = 1 para i=1,2,3",
                                "Colunas de Q são ortogonais: q_i · q_j = 0 para i ≠ j",
                                "R é triangular superior com diagonais positivas",
                                "A = Q R exatamente (ou erro < 10^{-3})",
                                "Todos produtos internos r_ij computados corretamente",
                                "Independência linear preservada na base ortonormal"
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de normas e produtos internos (erro < 0.01)",
                                "Correta aplicação sequencial das projeções em cada step",
                                "Verificações de ortogonalidade e unitariedade explícitas",
                                "Construção correta de Q e R com validação A = QR",
                                "Clareza na documentação de sub-passos e valores intermediários",
                                "Identificação e correção de erros numéricos comuns"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar Gram-Schmidt em Python/NumPy para automação",
                                "Física: Bases ortonormais em mecânica quântica e vetores de onda",
                                "Engenharia: Decomposição QR em processamento de sinais e controle",
                                "Estatística: Pré-processamento para análise de componentes principais (PCA)"
                              ],
                              "realWorldApplication": "A decomposição QR via Gram-Schmidt é fundamental em solvers numéricos para sistemas lineares (ex: Google PageRank), regressão linear com mínimos quadrados, compressão de imagens em JPEG e estabilização numérica em simulações de engenharia."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.1.3.3",
                            "name": "Verificar ortogonalidade numericamente",
                            "description": "Calcular Q^T Q ≈ I e ||A - QR|| ≈ 0 para validar o resultado, discutindo tolerâncias numéricas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar as matrizes Q, R e A para verificação",
                                  "subSteps": [
                                    "Carregue a matriz original A usada no processo de Gram-Schmidt.",
                                    "Recupere as matrizes Q e R obtidas da decomposição QR.",
                                    "Verifique as dimensões: Q deve ser m x n com colunas ortonormais, R n x n superior triangular.",
                                    "Confirme que A ≈ Q R multiplicando manualmente para uma submatriz pequena.",
                                    "Salve as matrizes em variáveis no ambiente de programação."
                                  ],
                                  "verification": "Dimensões corretas e A inicial == Q R aproximado visualmente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Ambiente Python com NumPy ou MATLAB; matrizes Q, R, A.",
                                  "tips": "Use np.linalg.norm para normas iniciais rápidas.",
                                  "learningObjective": "Entender a relação fundamental A = QR na decomposição.",
                                  "commonMistakes": "Confundir dimensões de Q (não quadrada) com I identidade quadrada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular e analisar Q^T Q",
                                  "subSteps": [
                                    "Compute Q transpose (Q.T) e multiplique por Q: resultado = Q.T @ Q.",
                                    "Inspecione a matriz resultante: diagonais devem ser ≈1, off-diagonais ≈0.",
                                    "Calcule a norma Frobenius ou máxima de (Q.T @ Q - I).",
                                    "Plote ou imprima a matriz para visualização.",
                                    "Registre os valores máximos de off-diagonais."
                                  ],
                                  "verification": "||Q^T Q - I|| < 1e-10 (tolerância típica).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "NumPy/MATLAB; função np.dot ou @ para multiplicação.",
                                  "tips": "Use np.eye para identidade I do tamanho correto (n x n).",
                                  "learningObjective": "Verificar ortogonalidade das colunas de Q numericamente.",
                                  "commonMistakes": "Esquecer de usar identidade do tamanho das colunas de Q, não linhas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e analisar a norma de A - QR",
                                  "subSteps": [
                                    "Compute o produto QR: produto = Q @ R.",
                                    "Subtraia da original: residuo = A - produto.",
                                    "Calcule normas: ||residuo||_2, ||residuo||_F ou máxima.",
                                    "Compare com normas de A para normalizar: erro relativo = ||A - QR|| / ||A||.",
                                    "Interprete: erro deve ser pequeno, indicando preservação da decomposição."
                                  ],
                                  "verification": "Erro relativo < 1e-12.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "NumPy funções np.linalg.norm(A - Q@R, 'fro') ou similar.",
                                  "tips": "Use diferentes normas (2, fro, inf) para insights variados.",
                                  "learningObjective": "Validar que a decomposição QR reconstrói A com precisão.",
                                  "commonMistakes": "Usar norma absoluta sem relativa, ignorando escala de A."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir tolerâncias numéricas e interpretar resultados",
                                  "subSteps": [
                                    "Defina tolerâncias baseadas em precisão de máquina (eps ≈1e-16).",
                                    "Compare erros com eps * cond(A) * ||A|| para Gram-Schmidt.",
                                    "Analise causas: acumulação de erros em Gram-Schmidt clássico.",
                                    "Teste com matrizes mal-condicionadas para ver falhas.",
                                    "Documente conclusões e sugestões de melhorias (ex: Householder)."
                                  ],
                                  "verification": "Relatório escrito com erros < tolerância esperada e explicação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "np.finfo(float64).eps; matrizes de teste variadas.",
                                  "tips": "Para cond(A) alto, espere erros maiores; use np.linalg.cond.",
                                  "learningObjective": "Compreender impactos numéricos e limites de algoritmos.",
                                  "commonMistakes": "Ignorar condição da matriz, assumindo tolerância fixa."
                                }
                              ],
                              "practicalExample": "Para A = [[1,1],[0,1],[0,0]] (3x2), após Gram-Schmidt: Q ≈ [[1,0],[0,1],[0,0]], R ≈ [[1,1],[0,1]]. Compute Q.T@Q ≈ [[1,0],[0,1]], ||A-QR|| ≈ 1e-15.",
                              "finalVerifications": [
                                "Q^T Q tem diagonais dentro de [1-1e-12, 1+1e-12] e off-diagonais <1e-12.",
                                "||A - QR||_F / ||A||_F < 1e-10.",
                                "Erro relativo considerado com condição de A.",
                                "Relatório discute tolerâncias baseadas em precisão flutuante.",
                                "Testes com pelo menos duas matrizes diferentes passam.",
                                "Identificação correta de potenciais falhas numéricas."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos matriciais (sem erros de indexação).",
                                "Uso correto de normas e tolerâncias relativas.",
                                "Interpretação qualitativa dos resultados numéricos.",
                                "Documentação clara com valores exatos reportados.",
                                "Análise de erros comuns em Gram-Schmidt clássico.",
                                "Sugestões de validação para casos edge."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica (NumPy/MATLAB para álgebra linear).",
                                "Análise Numérica (erros de arredondamento e estabilidade).",
                                "Ciência de Computação (decomposições em machine learning).",
                                "Física Computacional (simulações com vetores ortogonais)."
                              ],
                              "realWorldApplication": "Em solvers de sistemas lineares (ex: Google search algorithms), regressão least-squares (machine learning), compressão de imagens (QR em processamento de sinais), garantindo precisão em simulações científicas apesar de erros numéricos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.3.2"
                            ]
                          },
                          {
                            "id": "10.1.3.1.3.4",
                            "name": "Identificar limitações do método clássico",
                            "description": "Discutir sensibilidade à perda de ortogonalidade devido a erros de arredondamento em aritmética de ponto flutuante, referenciando Golub & Van Loan.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Processo de Gram-Schmidt Clássico",
                                  "subSteps": [
                                    "Relembre os passos do algoritmo clássico: para cada vetor q_k, subtraia projeções nos q_j anteriores.",
                                    "Implemente o algoritmo em Python ou MATLAB usando uma matriz de teste pequena (ex: 3x3).",
                                    "Calcule manualmente os coeficientes de projeção para entender a subtração sequencial.",
                                    "Verifique ortogonalidade exata em aritmética simbólica (ex: SymPy).",
                                    "Discuta dependência sequencial que amplifica erros."
                                  ],
                                  "verification": "Os vetores Q resultantes satisfazem Q^T Q = I em aritmética exata.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notebook Jupyter, bibliotecas NumPy/SymPy, notas de aula sobre Gram-Schmidt.",
                                  "tips": "Use matrizes com elementos racionais para evitar erros iniciais.",
                                  "learningObjective": "Compreender a estrutura sequencial do algoritmo clássico.",
                                  "commonMistakes": "Confundir Gram-Schmidt clássico com modificado; ignorar normalização."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Erros de Arredondamento em Ponto Flutuante",
                                  "subSteps": [
                                    "Estude o modelo de aritmética de ponto flutuante IEEE 754 e máquina epsilon (eps).",
                                    "Analise como operações básicas (soma, subtração) introduzem erros relativos.",
                                    "Simule subtração catastrófica de valores próximos usando flt = a + (-a + eps).",
                                    "Calcule propagação de erros em multiplicações e somas sequenciais.",
                                    "Relacione com perda de precisão em projeções ortogonais."
                                  ],
                                  "verification": "Explique e demonstre numericamente o crescimento de erros em uma soma acumulada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação IEEE 754, np.finfo(float64).eps no NumPy, exemplos de Higham 'Accuracy and Stability'.",
                                  "tips": "Visualize erros com plots de resíduos vs. iterações.",
                                  "learningObjective": "Identificar fontes de erros numéricos em operações aritméticas.",
                                  "commonMistakes": "Subestimar impacto de erros em somas; confundir erro absoluto com relativo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Observar Perda de Ortogonalidade Numericamente",
                                  "subSteps": [
                                    "Gere matrizes A mal-condicionadas (ex: Vandermonde ou Hilbert) com cond(A) > 1e10.",
                                    "Aplique Gram-Schmidt clássico e compute ||I - Q^T Q||_F (norma Frobenius do erro).",
                                    "Compare com aritmética exata e observe crescimento do erro com n (dimensão).",
                                    "Teste com diferentes precisions (float32 vs float64).",
                                    "Registre ||q_k|| - 1 para cada k, notando desvio em vetores posteriores."
                                  ],
                                  "verification": "Erro de ortogonalidade > 1e-10 para n>10 em double precision.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código Python/MATLAB, funções np.linalg.norm e scipy.linalg.hilb.",
                                  "tips": "Use loop para variar n de 5 a 50 e plote erros logarítmicos.",
                                  "learningObjective": "Demonstrar empiricamente a sensibilidade à perda de ortogonalidade.",
                                  "commonMistakes": "Usar matrizes bem-condicionadas; não normalizar Q adequadamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Teoricamente com Referência a Golub & Van Loan",
                                  "subSteps": [
                                    "Leia seções 5.2.8-5.2.9 de Golub & Van Loan (Matrix Computations, 4ª ed.) sobre análise de erro.",
                                    "Estude bound de erro: ||delta Q|| ~ n * eps * cond(A) para Gram-Schmidt clássico.",
                                    "Compare com Householder QR, que tem bound ~ eps * cond(A).",
                                    "Discuta perda de independência em subespaços devido a cancelamento.",
                                    "Resuma limitações: instável para n grande ou A il-condicionada."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o bound de erro e por que é pior que QR.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro Golub & Van Loan (PDF ou acesso), resumo de análise de estabilidade.",
                                  "tips": "Anote equações chave: erro relativo em projeções r_{jk} = q_j^T a_k.",
                                  "learningObjective": "Aplicar análise teórica para quantificar limitações.",
                                  "commonMistakes": "Ignorar fator n no bound; confundir com erro de arredondamento forward/backward."
                                }
                              ],
                              "practicalExample": "Considere a matriz Hilbert 15x15 (cond ~ 1e13). Aplicando Gram-Schmidt clássico em double precision, o erro ||I - Q^T Q||_F atinge ~1e-5 nos vetores finais, enquanto Householder QR mantém ~1e-14, demonstrando perda de ortogonalidade.",
                              "finalVerifications": [
                                "Calcule e interprete ||I - Q^T Q||_F < 1e-12 para casos estáveis.",
                                "Identifique quando erro > machine eps * n.",
                                "Explique impacto em R (triangular superior).",
                                "Compare resultados com QR padrão (np.linalg.qr).",
                                "Resuma em relatório: causas e magnitude esperada.",
                                "Teste re-ortogonalização parcial como mitigação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de subtração catastrófica em projeções.",
                                "Uso correto de normas para medir perda de ortogonalidade.",
                                "Referência adequada a Golub & Van Loan com citação de bounds.",
                                "Demonstração numérica com exemplos il-condicionados.",
                                "Explicação clara da dependência sequencial vs. métodos diretos.",
                                "Proposta de alternativas (ex: Gram-Schmidt modificado)."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Estabilidade e condicionamento de algoritmos.",
                                "Programação Científica: Implementação robusta em NumPy/SciPy.",
                                "Matemática Pura: Espaços vetoriais e bases ortonormais.",
                                "Física Computacional: Simulações com autovalores sensíveis."
                              ],
                              "realWorldApplication": "Em simulações CFD ou machine learning (PCA), Gram-Schmidt clássico falha em dados high-dimensional, levando a autovalores espúrios; use QR estável para eigen-decomposições em engenharia aeroespacial."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.2",
                    "name": "Processo de Gram-Schmidt Modificado",
                    "description": "Versão numericamente estável do Gram-Schmidt clássico para evitar erros de arredondamento em computações.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.2.1",
                        "name": "Limitações do Processo de Gram-Schmidt Clássico",
                        "description": "Compreender os problemas numéricos inerentes ao processo clássico de Gram-Schmidt, especialmente a perda de ortogonalidade causada por erros de arredondamento em aritmética de ponto flutuante, o que compromete a qualidade da base ortogonal gerada.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.1.1",
                            "name": "Executar Gram-Schmidt clássico em exemplo numérico",
                            "description": "Aplicar manualmente o processo clássico de Gram-Schmidt a uma matriz 3x3 mal-condicionada, calculando os vetores ortogonais e medindo a perda de ortogonalidade via norma do produto interno off-diagonal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a matriz exemplo mal-condicionada",
                                  "subSteps": [
                                    "Escolha uma matriz 3x3 cujas colunas sejam quase linearmente dependentes, como A = [[1, 1, 1], [1, 1+ε, 1+2ε], [1, 1+2ε, 1+4ε]] com ε = 10^{-10}.",
                                    "Escreva explicitamente os vetores colunas a1 = [1,1,1]^T, a2 = [1,1+ε,1+2ε]^T, a3 = [1,1+2ε,1+4ε]^T.",
                                    "Calcule as normas euclidianas iniciais de cada ai para referência futura.",
                                    "Anote todos os valores com precisão suficiente (pelo menos 12 casas decimais).",
                                    "Verifique o cond(A) aproximadamente para confirmar mal-condicionamento."
                                  ],
                                  "verification": "Matriz A e vetores colunas anotados corretamente com ε pequeno.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora científica",
                                    "Software numérico (Python/NumPy ou MATLAB) para verificação opcional"
                                  ],
                                  "tips": "Use ε = 1e-10 para simular erros de ponto flutuante reais sem overflow.",
                                  "learningObjective": "Compreender como matrizes mal-condicionadas revelam instabilidades numéricas no Gram-Schmidt clássico.",
                                  "commonMistakes": [
                                    "Escolher ε muito grande (ex: 0.1), perdendo o efeito de perda de ortogonalidade",
                                    "Confundir linhas com colunas da matriz",
                                    "Ignorar precisão numérica nos cálculos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar o primeiro vetor ortonormal q1",
                                  "subSteps": [
                                    "Defina u1 = a1.",
                                    "Calcule o produto interno u1 · u1 = ||u1||^2.",
                                    "Compute ||u1|| = sqrt(u1 · u1).",
                                    "Calcule q1 = u1 / ||u1|| componente a componente.",
                                    "Verifique que q1 · q1 ≈ 1 com precisão numérica."
                                  ],
                                  "verification": "||q1|| = 1 dentro de erro de arredondamento (ex: < 1e-15).",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora para raízes e divisões precisas"
                                  ],
                                  "tips": "Mantenha todos os cálculos com pelo menos 15 dígitos para simular double precision.",
                                  "learningObjective": "Executar normalização do primeiro vetor sem erros aritméticos.",
                                  "commonMistakes": [
                                    "Erro no sinal da raiz quadrada",
                                    "Dividir incorretamente os componentes",
                                    "Arredondar prematuramente os valores"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ortogonalizar e normalizar o segundo vetor q2",
                                  "subSteps": [
                                    "Calcule o coeficiente de projeção proj = a2 · q1.",
                                    "Compute u2 = a2 - proj * q1 (subtraia componente a componente).",
                                    "Calcule ||u2|| = sqrt(u2 · u2).",
                                    "Defina q2 = u2 / ||u2||.",
                                    "Verifique q1 · q2 ≈ 0 e ||q2|| ≈ 1."
                                  ],
                                  "verification": "|q1 · q2| < 1e-14 e ||q2|| ≈ 1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora para produtos internos precisos"
                                  ],
                                  "tips": "Calcule produtos internos com soma explícita para evitar erros de associação.",
                                  "learningObjective": "Aplicar corretamente a subtração de projeção para ortogonalidade.",
                                  "commonMistakes": [
                                    "Inverter o sinal na subtração u2 = a2 - proj q1",
                                    "Usar q2 não normalizado",
                                    "Erro de arredondamento em proj amplificando em u2 pequeno"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ortogonalizar e normalizar o terceiro vetor q3",
                                  "subSteps": [
                                    "Calcule proj1 = a3 · q1 e proj2 = a3 · q2.",
                                    "Compute u3 = a3 - proj1 * q1 - proj2 * q2.",
                                    "Calcule ||u3|| = sqrt(u3 · u3); note se ||u3|| é muito pequeno devido a cancelamento.",
                                    "Defina q3 = u3 / ||u3||.",
                                    "Verifique q1 · q3 ≈ 0, q2 · q3 ≈ 0 e ||q3|| ≈ 1."
                                  ],
                                  "verification": "Produtos internos off-diagonal < 1e-10 (mostrando perda).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora ou software para subtrações precisas"
                                  ],
                                  "tips": "A subtração em u3 causa cancelamento catastrófico; observe ||u3|| pequeno.",
                                  "learningObjective": "Identificar acumulação de erros em passos subsequentes.",
                                  "commonMistakes": [
                                    "Esquecer uma projeção em u3",
                                    "Normalizar u3=0 (divisão por zero)",
                                    "Arredondamentos que mascaram perda de ortogonalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Medir a perda de ortogonalidade",
                                  "subSteps": [
                                    "Forme a matriz Q = [q1 q2 q3].",
                                    "Compute Q^T Q manualmente: diagonais devem ser 1, off-diagonais 0.",
                                    "Calcule os elementos off-diagonal: q1·q2, q1·q3, q2·q3.",
                                    "Compute a norma da perda: ||Q^T Q - I||_F = sqrt( sum (off-diag)^2 ).",
                                    "Compare com expectativa: perda significativa (~1e-5 ou maior)."
                                  ],
                                  "verification": "||Q^T Q - I||_F >> máquina epsilon (ex: >1e-8).",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software para confirmação exata (opcional)"
                                  ],
                                  "tips": "Use norma Frobenius para quantificar perda global.",
                                  "learningObjective": "Quantificar numericamente a instabilidade do Gram-Schmidt clássico.",
                                  "commonMistakes": [
                                    "Confundir Q^T Q com QQ^T",
                                    "Norma errada (use Frobenius não max)",
                                    "Ignorar que perda é inevitável em mal-condicionadas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[1,1,1],[1,1+1e-10,1+2e-10],[1,1+2e-10,1+4e-10]], após Gram-Schmidt clássico, |q2 · q3| ≈ 1e-5, enquanto máquina epsilon é 2e-16, demonstrando perda de ortogonalidade.",
                              "finalVerifications": [
                                "Todos q_i têm norma unitária ||q_i|| ≈ 1.",
                                "Produtos internos off-diagonal |q_i · q_j| << 1 para i≠j idealmente, mas >1e-10 aqui.",
                                "Matriz Q formada corretamente com colunas q1,q2,q3.",
                                "Norma ||Q^T Q - I||_F calculada e > epsilon máquina.",
                                "Identificada causa: cancelamento em u3 devido a dependência linear.",
                                "Cálculos manuais coincidem com software até precisão usada."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de projeções e normalizações (erro <1e-12 por passo).",
                                "Correta identificação de cancelamento numérico em u2/u3.",
                                "Quantificação precisa da perda de ortogonalidade via norma.",
                                "Uso consistente de aritmética de alta precisão.",
                                "Explicação clara da instabilidade observada.",
                                "Verificações intermediárias realizadas em cada step."
                              ],
                              "crossCurricularConnections": [
                                "Computação Numérica: Estabilidade numérica e análise de erros de arredondamento.",
                                "Programação: Implementação em Python/NumPy para comparar manual vs. flutuante.",
                                "Física: Bases ortonormais em mecânica quântica ou análise modal.",
                                "Estatística: Decomposição QR em regressão linear e mínimos quadrados."
                              ],
                              "realWorldApplication": "O Gram-Schmidt clássico é instável para matrizes mal-condicionadas, como em dados ruidosos de sensores; motiva uso de Householder reflections em solvers LAPACK para sistemas lineares Ax=b e mínimos quadrados em engenharia e machine learning."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.2",
                            "name": "Identificar erros de arredondamento",
                            "description": "Analisar um exemplo computacional onde o Gram-Schmidt clássico falha, quantificando o erro relativo na ortogonalidade e relacionando-o à condição da matriz original.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar uma matriz de exemplo mal-condicionada",
                                  "subSteps": [
                                    "Pesquise ou construa uma matriz A de dimensão 3x3 ou 4x4 com alta condição (cond(A) > 10^10)",
                                    "Use uma matriz de Hilbert ou uma similar, como H = [[1,1/2,1/3],[1/2,1/3,1/4],[1/3,1/4,1/5]]",
                                    "Calcule a condição da matriz usando SVD ou normais (cond(A) = ||A|| * ||A^{-1}||)",
                                    "Verifique que a matriz é mal-condicionada imprimindo o valor de cond(A)",
                                    "Documente os autovalores para entender a sensibilidade"
                                  ],
                                  "verification": "Confirme que cond(A) é maior que 10^12 e anote o valor exato",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python com NumPy e SciPy, ou MATLAB",
                                  "tips": "Comece com matrizes pequenas para depuração rápida",
                                  "learningObjective": "Compreender como a condição afeta a estabilidade numérica",
                                  "commonMistakes": "Escolher matrizes bem-condicionadas por engano; sempre verificar cond(A)"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Processo de Gram-Schmidt Clássico",
                                  "subSteps": [
                                    "Escreva o código para Gram-Schmidt clássico: para cada coluna j, q_j = (a_j - sum_{i=1}^{j-1} (q_i^T a_j) q_i) / norma",
                                    "Use aritmética de ponto flutuante double precision (eps ~ 1e-16)",
                                    "Aplique sequencialmente às colunas de A para obter Q",
                                    "Normalize cada q_j após subtração das projeções",
                                    "Salve Q e R (opcionalmente, para QR)"
                                  ],
                                  "verification": "Execute o código e verifique que Q tem colunas unitárias (norma ~1)",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código (Jupyter Notebook), NumPy",
                                  "tips": "Implemente em loop explícito para observar acumulação de erros",
                                  "learningObjective": "Dominar a implementação clássica suscetível a erros",
                                  "commonMistakes": "Esquecer normalização ou usar Gram-Schmidt modificado acidentalmente"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar a Ortogonalidade dos Vetores Resultantes",
                                  "subSteps": [
                                    "Calcule a matriz de Gram: G = Q^T * Q",
                                    "O ideal é G ≈ I (identidade); compute E = G - I",
                                    "Meça o erro relativo: max(|E|_{ij}) / ||I|| ou ||Q^T Q - I||_F / sqrt(n)",
                                    "Use norma Frobenius ou norma espectral para quantificar",
                                    "Compare com precisão máquina (eps * cond(A))"
                                  ],
                                  "verification": "Erro relativo > 10^-8 apesar de double precision",
                                  "estimatedTime": "25 minutos",
                                  "materials": "NumPy para matrizes e normas",
                                  "tips": "Plote off-diagonais de G para visualização",
                                  "learningObjective": "Quantificar perda de ortogonalidade numericamente",
                                  "commonMistakes": "Usar norma absoluta em vez de relativa; ignorar escala"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Erro à Condição da Matriz Original",
                                  "subSteps": [
                                    "Relembre que erro esperado ~ eps * cond(A) * ||A||",
                                    "Compare erro medido com bound teórico: ||Q^T Q - I|| ≤ C * eps * cond(A)",
                                    "Teste com Gram-Schmidt modificado para contraste (erro pequeno)",
                                    "Varie o tamanho ou condição e observe o padrão",
                                    "Conclua graficamente ou tabularmente a relação"
                                  ],
                                  "verification": "Demonstre que erro cresce com cond(A) via tabela ou gráfico",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Matplotlib para plots, SciPy para cond",
                                  "tips": "Teste múltiplas matrizes para robustez",
                                  "learningObjective": "Conectar análise numérica à estabilidade algorítmica",
                                  "commonMistakes": "Confundir cond(A) com kappa_2(A); usar single precision"
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e Refletir sobre as Limitações",
                                  "subSteps": [
                                    "Registre valores: cond(A), erro ortogonalidade, bound teórico",
                                    "Explique por que clássico falha (acumulação de erros em subtrações)",
                                    "Sugira Householder ou Givens como alternativas estáveis",
                                    "Crie relatório com código, outputs e conclusões",
                                    "Discuta impacto em aplicações reais"
                                  ],
                                  "verification": "Relatório completo com gráficos e quantificações",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Notebook Jupyter para relatório integrado",
                                  "tips": "Use markdown cells para explicações claras",
                                  "learningObjective": "Sintetizar análise em insights acionáveis",
                                  "commonMistakes": "Omitir comparação com método estável"
                                }
                              ],
                              "practicalExample": "Considere a matriz de Hilbert 3x3: A = [[1, 0.5, 1/3], [0.5, 1/3, 0.25], [1/3, 0.25, 0.2]]. cond(A) ≈ 5e5. Após Gram-Schmidt clássico em double, ||Q^T Q - I||_F ≈ 1e-9, muito maior que eps=2e-16, correlacionado à alta condição.",
                              "finalVerifications": [
                                "Código Gram-Schmidt clássico implementado corretamente sem modificações",
                                "Erro relativo na ortogonalidade quantificado (> eps * cond(A))",
                                "Condição da matriz calculada e relacionada ao erro",
                                "Comparação com método estável (ex: QR via Householder) mostra falha",
                                "Relatório documenta todos os valores numéricos e plots",
                                "Reflexão identifica causa raiz: subtrações catastróficas"
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação do algoritmo clássico (sem bugs)",
                                "Correta quantificação de erros (normas relativas usadas)",
                                "Análise teórica relacionando cond(A) ao erro observado",
                                "Uso apropriado de ferramentas numéricas (NumPy/SciPy)",
                                "Clareza no relatório com visualizações e conclusões",
                                "Identificação de limitações e sugestões de melhorias"
                              ],
                              "crossCurricularConnections": [
                                "Computação Científica: Implementação numérica e análise de estabilidade",
                                "Programação: Desenvolvimento e depuração de algoritmos em Python",
                                "Análise Numérica: Teoria de erros de arredondamento e bounds",
                                "Física Computacional: Aplicações em simulações com matrizes il-condicionadas"
                              ],
                              "realWorldApplication": "Em solvers de sistemas lineares (ex: Google PageRank), PCA em machine learning ou simulações CFD, onde Gram-Schmidt clássico causa instabilidade em matrizes mal-condicionadas de dados reais, levando a Householder QR para precisão em supercomputadores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.3",
                            "name": "Comparar sensibilidade numérica",
                            "description": "Discutir qualitativamente por que matrizes com colunas quase paralelas amplificam erros no Gram-Schmidt clássico, usando conceitos de análise de sensibilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Processo de Gram-Schmidt Clássico",
                                  "subSteps": [
                                    "Relembre a definição: dado A com colunas a1, a2, ..., an, compute q1 = a1 / ||a1||, qk = (ak - proj_{span(q1..qk-1)} ak) / norma.",
                                    "Escreva o fórmula explícita para projeção: proj_q ak = (qk^T ak) qk.",
                                    "Implemente manualmente para uma matriz 2x2 simples com colunas ortogonais.",
                                    "Observe como subtrações ocorrem apenas componentes ortogonais.",
                                    "Discuta o papel das operações de ponto interno e normalização."
                                  ],
                                  "verification": "Escreva o pseudocódigo do algoritmo e aplique a uma matriz exemplo sem erros evidentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta ou software como MATLAB/Python (NumPy), notas de aula sobre Gram-Schmidt.",
                                  "tips": "Desenhe vetores graficamente para visualizar projeções.",
                                  "learningObjective": "Entender o mecanismo passo a passo do Gram-Schmidt clássico e identificar operações suscetíveis a erros.",
                                  "commonMistakes": "Confundir Gram-Schmidt clássico com modificado; ignorar normalização após subtração."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Conceitos de Análise de Sensibilidade Numérica",
                                  "subSteps": [
                                    "Defina erro absoluto vs relativo: ε_abs = |x_comp - x_exato|, ε_rel = ε_abs / |x_exato|.",
                                    "Explique arredondamento em floating-point: máquina epsilon (eps ≈ 2e-16).",
                                    "Discuta condicionamento: κ(A) = ||A|| ||A^{-1}||, amplifica erros de entrada em saídas.",
                                    "Relacione a ângulos entre vetores: sen(θ) pequeno implica condição ruim.",
                                    "Calcule κ para submatrizes no processo de Gram-Schmidt."
                                  ],
                                  "verification": "Calcule ε_rel para uma soma simples como 1 + eps e explique perda de precisão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora ou Python para eps, referências como 'Numerical Linear Algebra' de Trefethen.",
                                  "tips": "Use log10(κ) para medir severidade do condicionamento.",
                                  "learningObjective": "Dominar métricas básicas de sensibilidade e seu impacto em algoritmos lineares.",
                                  "commonMistakes": "Confundir erro de entrada com saída; ignorar que subtrações diferem de multiplicações em sensibilidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Matrizes com Colunas Quase Paralelas",
                                  "subSteps": [
                                    "Construa exemplo: A = [1, 1+δ; 0, eps] onde δ pequeno, simule colunas quase paralelas.",
                                    "Compute manualmente q2 = (a2 - (q1^T a2) q1) / ||...||, note que q1^T a2 ≈ 1, subtração ≈ δ -1.",
                                    "Observe cancelamento: termo subtraído quase cancela a2, deixando resíduo pequeno contaminado por eps.",
                                    "Meça ângulo θ entre colunas: cosθ ≈1, senθ ≈ δ pequeno.",
                                    "Compare com colunas ortogonais: sem cancelamento significativo."
                                  ],
                                  "verification": "Execute computação numérica em software e compare ||Q^T Q - I|| antes/depois.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python/MATLAB com código Gram-Schmidt, matrizes de teste.",
                                  "tips": "Escolha δ = 1e-8 para simular floating-point real.",
                                  "learningObjective": "Identificar como alinhamento de colunas leva a subtrações il-condicionadas.",
                                  "commonMistakes": "Usar δ muito grande/pequeno; não normalizar q1 corretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Qualitativamente a Amplificação de Erros",
                                  "subSteps": [
                                    "Explique: projeção (q1^T a2) tem erro relativo pequeno, mas multiplicado por q1 (grande) e subtraído de a2 amplifica.",
                                    "Relacione a perda de dígitos: número de dígitos perdidos ≈ -log10(sinθ).",
                                    "Compare sensibilidade: Gram-Schmidt clássico O(κ(A)^2) vs Householder O(κ(A)).",
                                    "Descreva propagação: erro em q1 propaga para todas qk subsequentes.",
                                    "Conclua por que modificado (normalizar antes projeção) mitiga."
                                  ],
                                  "verification": "Escreva parágrafo explicando 'por quê' com termos como 'cancelamento catastrófico' e 'condicionamento angular'.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Exemplos numéricos do step 3, quadro branco para diagrama.",
                                  "tips": "Use analogia: subtrair dois números próximos como 1000000.00 - 999999.99 = 0.01, mas com ruído perde precisão.",
                                  "learningObjective": "Articular qualitativamente a conexão entre geometria (paralelismo) e análise numérica.",
                                  "commonMistakes": "Atribuir erro só a floating-point sem ligar a geometria; ignorar ordem das colunas."
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 1+1e-8], [0, 1e-16]]. No Gram-Schmidt clássico, q1 = [1,0]^T, q1^T a2 ≈1+1e-8, subtração dá [1e-8, 1e-16]^T, mas erro em q1^T a2 amplifica o 1e-16 para q2 com ||q2|| poluído, resultando em Q não ortonormal (||Q^T Q - I|| ~1e-8 ao invés de 1e-16).",
                              "finalVerifications": [
                                "Pode derivar qualitativamente a perda de precisão como função de sinθ?",
                                "Implementa Gram-Schmidt em código e observa perda de ortogonalidade para θ pequeno?",
                                "Explica diferença entre clássico e modificado em termos de subtrações?",
                                "Identifica operações mais sensíveis (ponto interno vs normalização)?",
                                "Compara com decomposição QR estável?",
                                "Discute impacto em aplicações como autovalores?"
                              ],
                              "assessmentCriteria": [
                                "Clareza na explicação qualitativa do cancelamento (4/5 pontos).",
                                "Correto uso de conceitos: condicionamento angular, erro relativo (3/5).",
                                "Exemplo numérico preciso mostrando amplificação (4/5).",
                                "Conexão explícita entre geometria vetorial e estabilidade numérica (5/5).",
                                "Identificação de mitigações como reortogonalização (3/5).",
                                "Profundidade: menciona propagação de erros para passos subsequentes (4/5)."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Estudo de estabilidade de algoritmos (Higham).",
                                "Programação Computacional: Implementação em Python/MATLAB com análise de erros.",
                                "Física Computacional: Bases em simulações de dinâmica molecular com vetores quase colineares.",
                                "Estatística: Análise de componentes principais (PCA) sensível a colinearidade."
                              ],
                              "realWorldApplication": "Em processamento de sinais, imagens quase colineares em SVD/QR levam a artefatos; engenharia aeroespacial usa QR estável para controle de sistemas com modos quase degenerados, evitando instabilidade numérica em simulações."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.2",
                        "name": "Algoritmo do Processo de Gram-Schmidt Modificado",
                        "description": "Descrever e implementar o algoritmo modificado, que corrige a subtração de projeções para maior estabilidade numérica, garantindo que os resíduos sejam computados antes da normalização.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.2.1",
                            "name": "Derivar os passos do algoritmo modificado",
                            "description": "Escrever o pseudocódigo do Gram-Schmidt modificado para uma matriz A m x n, destacando a ordem: computar projeções, subtrair do vetor atual e normalizar apenas o último.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a matriz de entrada e inicializar estruturas",
                                  "subSteps": [
                                    "Defina a matriz A de dimensões m x n, onde m >= n e as colunas são os vetores a_1, a_2, ..., a_n.",
                                    "Inicialize uma lista vazia ou matriz Q para armazenar os vetores ortonormais q_1, q_2, ..., q_n.",
                                    "Revise os conceitos de produto interno (q_i^T a_j) e norma euclidiana (||u|| = sqrt(u^T u)).",
                                    "Confirme que o processo visa produzir Q ortonormal tal que A = Q R.",
                                    "Anote as diferenças do Gram-Schmidt clássico: projeções computadas sequencialmente, subtração imediata e normalização apenas do vetor resultante final por iteração."
                                  ],
                                  "verification": "Escreva a inicialização em pseudocódigo e verifique se menciona dimensões, Q vazia e fórmulas básicas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, calculadora para normas, referência de Álgebra Linear.",
                                  "tips": "Sempre especifique que Q será m x n com colunas ortonormais.",
                                  "learningObjective": "Compreender o setup inicial e os componentes matemáticos fundamentais do algoritmo.",
                                  "commonMistakes": "Confundir dimensões m e n; esquecer que normalização ocorre apenas após subtração completa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o loop principal para cada coluna j",
                                  "subSteps": [
                                    "Inicie um loop for j = 1 to n: selecione o vetor atual a_j.",
                                    "Dentro do loop, prepare para computar u_j como uma cópia inicial de a_j.",
                                    "Planeje os blocos subsequentes: computar projeções, subtrair e normalizar.",
                                    "Note que para j=1, não há projeções anteriores, então u_1 = a_1 diretamente.",
                                    "Estruture o pseudocódigo com indentação clara para o loop."
                                  ],
                                  "verification": "Pseudocódigo mostra loop for j=1 to n com seleção de a_j e menção a u_j.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel para esboçar loop, editor de texto simples.",
                                  "tips": "Use pseudocódigo legível como 'for j in 1..n:' para clareza.",
                                  "learningObjective": "Estruturar o fluxo iterativo principal do algoritmo.",
                                  "commonMistakes": "Iniciar normalização antes do loop ou pular j=1."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar todas as projeções sobre vetores anteriores",
                                  "subSteps": [
                                    "Para cada i = 1 to j-1, calcule o coeficiente de projeção r_{i j} = q_i^T a_j.",
                                    "Em seguida, compute a projeção proj_i = r_{i j} * q_i.",
                                    "Acumule a soma de todas as projeções: sum_proj = soma_{i=1}^{j-1} proj_i.",
                                    "Destaque que todas projeções são computadas usando o a_j original, antes de qualquer modificação.",
                                    "Anote isso como o passo chave do 'modificado': projeções primeiro, sem atualizar intermediariamente."
                                  ],
                                  "verification": "Pseudocódigo inclui loop interno for i=1 to j-1 com r_ij = q_i^T * a_j e soma de proj.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora matricial ou software como Octave/MATLAB para testar scalar products.",
                                  "tips": "Use variáveis temporárias como r_ij para clareza em implementações numéricas.",
                                  "learningObjective": "Derivar o cálculo sequencial das projeções sem alterar o vetor atual prematuramente.",
                                  "commonMistakes": "Usar a_j modificado nas projeções (erro do clássico); confundir q_i com u_i."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Subtrair projeções do vetor atual para obter u_j",
                                  "subSteps": [
                                    "Defina u_j = a_j - sum_proj, onde sum_proj é a soma das projeções anteriores.",
                                    "Verifique dimensionalmente: u_j permanece em R^m.",
                                    "Confirme que u_j é ortogonal a todos q_i para i < j.",
                                    "Não normalize ainda; guarde u_j para o próximo passo.",
                                    "Atualize o pseudocódigo adicionando esta subtração após o loop de projeções."
                                  ],
                                  "verification": "Pseudocódigo tem u_j = a_j - sum_{i=1}^{j-1} (q_i^T a_j) q_i explicitamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel para vetores simbólicos, ferramenta de álgebra como SymPy.",
                                  "tips": "Teste com j=1: sum_proj=0, u_1=a_1.",
                                  "learningObjective": "Isolar o componente ortogonal residual após remoção de projeções.",
                                  "commonMistakes": "Subtrair de q's em vez de a_j; normalizar aqui prematuramente."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Normalizar u_j e finalizar o pseudocódigo",
                                  "subSteps": [
                                    "Calcule a norma ||u_j|| = sqrt(u_j^T u_j).",
                                    "Defina q_j = u_j / ||u_j|| apenas agora, destacando 'normalizar apenas o último'.",
                                    "Adicione q_j à matriz Q (coluna j).",
                                    "Opcionalmente, armazene r_{j j} = ||u_j|| para formar R.",
                                    "Compile o pseudocódigo completo e verifique ortonormalidade: Q^T Q = I."
                                  ],
                                  "verification": "Pseudocódigo termina com q_j = u_j / ||u_j|| e Q atualizada; testa Q^T Q ≈ I.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software numérico para validar norma e ortogonalidade.",
                                  "tips": "Trate ||u_j||=0 como singularidade (rank deficient).",
                                  "learningObjective": "Completar a iteração com normalização pontual e pseudocódigo acionável.",
                                  "commonMistakes": "Normalizar a cada projeção; esquecer divisão por norma zero."
                                }
                              ],
                              "practicalExample": "Para A = [[3, 1], [4, 1], [0, 1]] (3x2):\n- j=1: u1 = [3,4,0], ||u1||=5, q1=[3/5,4/5,0]\n- j=2: r12=q1^T a2=1/5*3 + 4/5*1 +0=23/25? Wait, calc: q1^T [1,1,1]=(3/5 +4/5 +0)=7/5, proj=(7/5)q1, u2=[1,1,1] - (7/5)[0.6,0.8,0]= compute numerically: q1=[0.6,0.8,0], proj=[0.84,1.12,0], u2=[1-0.84,1-1.12,1-0]=[0.16,-0.12,1], ||u2||≈1.016, q2≈[0.157,-0.118,0.985]. Pseudocódigo captura isso passo a passo.",
                              "finalVerifications": [
                                "Pseudocódigo inicializa Q corretamente e loops aninhados.",
                                "Projeções usam a_j original e são somadas antes subtração.",
                                "u_j é definido como a_j menos soma de projeções.",
                                "Normalização q_j = u_j / ||u_j|| ocorre apenas após subtração.",
                                "Comentários destacam ordem: projeções → subtração → normalizar último.",
                                "Teste com matriz 2x2 simples produz Q ortonormal."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática: projeções e subtração seguem definição exata.",
                                "Estrutura do pseudocódigo: clara, indentada, com loops corretos.",
                                "Destaque da ordem modificada: projeções primeiro, normalização pontual.",
                                "Tratamento de casos base (j=1) e edge (||u_j||=0).",
                                "Clareza e completude: todos passos derivados logicamente.",
                                "Validação: simulação manual ou numérica confirma ortogonalidade."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Implementar em Python com NumPy para QR.",
                                "Análise Numérica: Estabilidade numérica vs Gram-Schmidt clássico.",
                                "Engenharia de Sinais: Bases ortonormais para transformadas (ex: Fourier aproximado).",
                                "Machine Learning: Redução de dimensionalidade via QR em PCA.",
                                "Física Computacional: Ortogonalização em mecânica quântica (bases)."
                              ],
                              "realWorldApplication": "O algoritmo modificado é fundamental na decomposição QR para resolver sistemas lineares Ax=b via Q^{-1} (ortogonal), mínimos quadrados em regressão, compressão de imagens/vídeos (bases ortonormais), e estabilidade numérica em simulações científicas como previsão climática ou finanças quantitativas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.2.2",
                            "name": "Implementar em exemplo manual",
                            "description": "Aplicar o algoritmo modificado passo a passo a uma matriz exemplo, calculando Q e R e verificando A = QR com precisão numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a matriz exemplo e inicializar variáveis",
                                  "subSteps": [
                                    "Escolha uma matriz A de dimensões m x n com m >= n, preferencialmente uma matriz 3x2 para simplicidade manual: A = [[3, 1], [2, 1], [1, 1]].",
                                    "Identifique as colunas: a1 = [3, 2, 1]^T, a2 = [1, 1, 1]^T.",
                                    "Calcule a norma euclidiana de a1: ||a1|| = sqrt(3^2 + 2^2 + 1^2) = sqrt(14) ≈ 3.7417.",
                                    "Prepare uma tabela ou folha para anotar vetores qk, uk e coeficientes r_ij.",
                                    "Inicie Q como matriz vazia e R como matriz n x n zero."
                                  ],
                                  "verification": "Confirme que a matriz A está corretamente anotada e normas iniciais calculadas sem erros aritméticos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado, lápis, calculadora científica para raízes e potências.",
                                  "tips": "Use notação vetorial clara e mantenha todos os valores exatos (frações ou sqrt) até o final para precisão.",
                                  "learningObjective": "Entender a estrutura de entrada do algoritmo e preparar dados para iterações.",
                                  "commonMistakes": "Escolher matriz singular ou com colunas linearmente dependentes; arredondar prematuramente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar a primeira coluna ortonormal q1",
                                  "subSteps": [
                                    "Calcule q1 = a1 / ||a1|| = [3/sqrt(14), 2/sqrt(14), 1/sqrt(14)] ≈ [0.8018, 0.5345, 0.2673].",
                                    "Defina r11 = ||a1|| = sqrt(14).",
                                    "Verifique ||q1|| = 1 calculando q1^T q1 ≈ 1.",
                                    "Anote q1 na primeira coluna de Q.",
                                    "Confirme ortogonalidade trivial (uma coluna só)."
                                  ],
                                  "verification": "Norma de q1 deve ser exatamente 1 (erro < 10^-10 se numérico).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel quadriculado, calculadora.",
                                  "tips": "Mantenha sqrt(14) simbólico: q1 = [3/sqrt(14), 2/sqrt(14), 1/sqrt(14)].",
                                  "learningObjective": "Dominar normalização do primeiro vetor base.",
                                  "commonMistakes": "Confundir norma L1 ou L-infinito com L2; inverter divisão (||a1|| / a1)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar a segunda coluna ortonormal q2 usando projeções",
                                  "subSteps": [
                                    "Calcule o coeficiente de projeção r12 = q1^T a2 = (3*1 + 2*1 + 1*1)/sqrt(14) = 6/sqrt(14) ≈ 1.6036.",
                                    "Compute u2 = a2 - r12 * q1 = [1,1,1]^T - (6/sqrt(14)) * [3/sqrt(14), 2/sqrt(14), 1/sqrt(14)].",
                                    "Simplifique: u2 = [1 - 18/14, 1 - 12/14, 1 - 6/14] = [1 - 9/7, 1 - 6/7, 1 - 3/7] = [-2/7, 1/7, 4/7].",
                                    "Calcule ||u2|| = sqrt( (-2/7)^2 + (1/7)^2 + (4/7)^2 ) = sqrt(21/49) = sqrt(3/7) ≈ 0.6547.",
                                    "q2 = u2 / ||u2|| ≈ [-0.7454, 0.1491, 0.5964]; r22 = ||u2||."
                                  ],
                                  "verification": "Verifique q1^T q2 ≈ 0 (ortogonalidade) e ||q2|| ≈ 1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel quadriculado, calculadora para multiplicações matriciais.",
                                  "tips": "Use frações exatas: 14=14, 49=7^2 para evitar erros de arredondamento.",
                                  "learningObjective": "Aplicar subtração de projeções para ortogonalizar vetores subsequentes.",
                                  "commonMistakes": "Usar a_k em vez de q_j na projeção; esquecer transposição em produto interno."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir as matrizes Q e R completas",
                                  "subSteps": [
                                    "Monte Q = [q1 | q2] = [[3/sqrt(14), -2/sqrt(42)], [2/sqrt(14), 1/sqrt(42)], [1/sqrt(14), 4/sqrt(42)]] (note sqrt(42)=sqrt(6*7)=sqrt(6)/sqrt(7) mas use numérico se preciso).",
                                    "Monte R = [[sqrt(14), 6/sqrt(14)], [0, sqrt(3/7)]].",
                                    "Verifique que R é triangular superior.",
                                    "Calcule numericamente Q ≈ [[0.8018, -0.7454], [0.5345, 0.1491], [0.2673, 0.5964]] e R ≈ [[3.7417, 1.6036], [0, 0.6547]].",
                                    "Confirme dimensões: Q 3x2, R 2x2."
                                  ],
                                  "verification": "Q tem colunas unitárias e ortogonais; R triangular superior.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel para montagem matricial.",
                                  "tips": "Escreva Q e R lado a lado para visualização.",
                                  "learningObjective": "Assemblar decomposição QR a partir de q's e r's.",
                                  "commonMistakes": "Colocar valores errados em R (ex: r12 ao invés de q1^T a2); inverter colunas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar a decomposição A = QR com precisão numérica",
                                  "subSteps": [
                                    "Compute QR: primeira coluna r11*q1 + 0*q2 deve igualar a1.",
                                    "Segunda coluna: r12*q1 + r22*q2 deve igualar a2.",
                                    "Multiplique matrizes: QR = [[3.7417*0.8018 + 1.6036*(-0.7454)*0, ...]] resultando em A aproximado.",
                                    "Calcule erro: ||A - QR||_F < 10^-10 (norma de Frobenius).",
                                    "Compare exato vs aproximado e discuta perda numérica."
                                  ],
                                  "verification": "||A - QR|| < epsilon (ex: 1e-10); colunas de QR coincidem com A.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora ou software simples para verificação matricial (opcional).",
                                  "tips": "Use 10 casas decimais para multiplicação; verifique coluna por coluna primeiro.",
                                  "learningObjective": "Validar corretude da decomposição e entender estabilidade numérica.",
                                  "commonMistakes": "Arredondamento excessivo levando a erro >1e-8; multiplicação matricial incorreta."
                                }
                              ],
                              "practicalExample": "Para A = [[3,1],[2,1],[1,1]], obtemos Q ≈ [[0.8018,-0.7454],[0.5345,0.1491],[0.2673,0.5964]] e R ≈ [[3.7417,1.6036],[0,0.6547]], com QR ≈ A exato em aritmética simbólica e erro ~1e-14 numérico.",
                              "finalVerifications": [
                                "Colunas de Q são unitárias: ||q_k|| = 1 para todo k.",
                                "Q é ortogonal: q_i^T q_j = 0 para i ≠ j.",
                                "R é triangular superior com diagonais positivas.",
                                "A = QR holds numericamente: ||A - QR||_F < 1e-10.",
                                "Todos coeficientes r_ij = q_i^T a_j para i ≤ j.",
                                "Nenhuma perda de ortogonalidade devido a cancelamentos."
                              ],
                              "assessmentCriteria": [
                                "Precisão aritmética: erros < 1e-8 em normas e produtos internos.",
                                "Corretude algorítmica: projeções subtraídas corretamente em cada u_k.",
                                "Uso de representações exatas: frações/sqrts preferidas sobre decimais iniciais.",
                                "Verificação completa: ortogonalidade, unitariedade e multiplicação QR testadas.",
                                "Clareza na documentação: passos anotados com valores intermediários.",
                                "Eficiência: tempo dentro do estimado sem recalcular desnecessariamente."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python/NumPy para comparar manual vs automático.",
                                "Física: Aplicar em bases ortogonais para coordenadas em mecânica vetorial.",
                                "Estatística: Preparar para regressão linear via least squares (A^T A).",
                                "Ciência da Computação: Entender estabilidade numérica em decomposições."
                              ],
                              "realWorldApplication": "Usado em resolução de sistemas lineares sobrecondicionados (ex: navegação GPS), compressão de dados em machine learning (PCA aproximada), e processamento de sinais para filtragem ortogonal em telecomunicações."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.2.3",
                            "name": "Codificar em pseudolinguagem",
                            "description": "Escrever um algoritmo em pseudocódigo ou MATLAB-like para o Gram-Schmidt modificado, incluindo tratamento para colunas linearmente dependentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Algoritmo Gram-Schmidt Modificado e Delinear Estrutura Geral",
                                  "subSteps": [
                                    "Estude a definição do processo Gram-Schmidt modificado: para uma matriz A m x n, construir Q ortogonal e R triangular superior.",
                                    "Identifique componentes chave: inicialização de Q e R, loop sobre colunas de A, projeções, subtração, normalização e detecção de dependência linear (norma < epsilon).",
                                    "Esboce o pseudocódigo em alto nível: função GramSchmidtMod(A, epsilon), inicializar Q = zeros(m,n), R = zeros(n,n), loop for j=1 to n.",
                                    "Anote condições para colunas linearmente dependentes: se norma do vetor residual < epsilon, defina q_j = 0 e r_jj = 0.",
                                    "Desenhe fluxograma simples no papel para visualizar o loop principal."
                                  ],
                                  "verification": "Pseudocódigo delineado cobre inicialização, loop principal e tratamento de dependência sem lacunas lógicas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, referência do algoritmo Gram-Schmidt modificado (livro ou PDF de Álgebra Linear Computacional).",
                                  "tips": "Use indentação consistente para representar blocos de código desde o início.",
                                  "learningObjective": "Compreender a estrutura lógica do algoritmo antes de codificar detalhes.",
                                  "commonMistakes": "Ignorar o tratamento de dependência linear ou confundir índices de matrizes (linhas vs colunas)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Inicialização e Estruturas de Dados em Pseudocódigo",
                                  "subSteps": [
                                    "Defina a função: function [Q, R] = GramSchmidtMod(A, epsilon) onde A é m x n.",
                                    "Inicialize Q como matriz m x n de zeros, R como n x n de zeros.",
                                    "Defina epsilon como tolerância pequena (ex: 1e-10).",
                                    "Adicione declaração de entrada: assuma A tem colunas linearmente independentes ou não.",
                                    "Inclua comentários explicando dimensões: m >= n assumido."
                                  ],
                                  "verification": "Código inicial compila semanticamente e inicializa Q e R corretamente sem erros de sintaxe.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de texto simples (Notepad++, VS Code) ou papel para pseudocódigo.",
                                  "tips": "Use convenções MATLAB-like: colchetes para funções, = para atribuição.",
                                  "learningObjective": "Configurar corretamente as estruturas de dados para o algoritmo.",
                                  "commonMistakes": "Inicializar Q com tamanho errado (deve ser m x n, não n x n)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Codificar o Loop Principal: Projeções e Subtração de Componentes",
                                  "subSteps": [
                                    "Inicie loop: for j = 1 to n",
                                    "Copie a_j para v = A(:,j)",
                                    "Para cada k=1 to j-1: compute projeção r_kj = q_k' * v, então v = v - r_kj * q_k",
                                    "Após subtrações, compute norma_v = norm(v)",
                                    "Adicione verificação: if norma_v < epsilon, defina q_j = 0, r_jj = 0, else prossiga."
                                  ],
                                  "verification": "Simule manualmente com vetor 2D pequeno: projeções subtraem corretamente componentes anteriores.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de texto, calculadora para verificação manual de norma.",
                                  "tips": "Use notação vetorizada: q_k' * v para produto interno eficiente.",
                                  "learningObjective": "Implementar a ortogonalização via subtração de projeções.",
                                  "commonMistakes": "Usar produto escalar errado (v' * q_k em vez de q_k' * v) ou esquecer loop interno k=1 to j-1."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar Normalização, Preenchimento de R e Encerramento",
                                  "subSteps": [
                                    "No else do if: r_jj = norma_v, q_j = v / norma_v, Q(:,j) = q_j",
                                    "Preencha R: para k=1 to j-1, R(k,j) = q_k' * A(:,j) (ou use r_kj já computado)",
                                    "R(j,j) = norma_v (ou 0 se dependente)",
                                    "Feche loops e retorne [Q, R]",
                                    "Adicione comentários em cada linha chave e indentação consistente."
                                  ],
                                  "verification": "Pseudocódigo completo roda sem erros lógicos em simulação mental com exemplo 2x2.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de texto, exemplo de matriz de teste.",
                                  "tips": "Salve versões intermediárias para comparar com referência.",
                                  "learningObjective": "Completar o algoritmo com normalização e matriz R triangular.",
                                  "commonMistakes": "Esquecer de preencher R(k,j) para k < j ou normalizar incorretamente."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Revisar, Testar Sintaxe e Adicionar Tratamento de Erros",
                                  "subSteps": [
                                    "Leia todo o pseudocódigo em voz alta para checar fluxo lógico.",
                                    "Teste sintaxe simulando execução com MATLAB-like interpreter mental.",
                                    "Adicione verificação inicial: if m < n, erro 'Matriz não adequada'.",
                                    "Inclua output para dependências: vetor de flags indicando colunas dependentes.",
                                    "Formate com espaçamento e comentários padronizados."
                                  ],
                                  "verification": "Pseudocódigo é legível, comentado e cobre todos os casos (independente e dependente).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de texto, referência MATLAB para sintaxe.",
                                  "tips": "Use 'end' para loops em estilo MATLAB.",
                                  "learningObjective": "Polir o código para clareza e robustez.",
                                  "commonMistakes": "Não tratar caso n=1 ou matrizes quadradas singulares."
                                }
                              ],
                              "practicalExample": "Para A = [1 1; 0 1; 0 0] (3x2), epsilon=1e-10: Após Gram-Schmidt mod, Q(:,1)=[1;0;0], R(1,1)=1, Q(:,2)=[0;1;0], R(1,2)=1, R(2,2)=1. Se terceira coluna [1;1;0] adicionada, detecta dependência pois residual=[0;0;0].",
                              "finalVerifications": [
                                "Pseudocódigo implementa loop com projeções corretas e subtração.",
                                "Tratamento de colunas dependentes: norma < epsilon leva a q_j=0.",
                                "Q tem colunas ortonormais (Q'*Q ≈ I para colunas independentes).",
                                "R é triangular superior com diagonais normais ou zero.",
                                "Comentários explicam cada seção principal.",
                                "Sintaxe consistente (pseudocódigo ou MATLAB-like sem erros)."
                              ],
                              "assessmentCriteria": [
                                "Correção lógica: algoritmo produz Q e R válidos para Gram-Schmidt mod.",
                                "Tratamento de dependência: corretamente identifica e pula normalização.",
                                "Clareza: títulos de passos, indentação e comentários presentes.",
                                "Completude: todos elementos (inicialização, loops, normalização, retorno) incluídos.",
                                "Eficiência: usa produto interno vetorizado, sem loops desnecessários.",
                                "Robustez: lida com casos edge (n=1, dependentes iniciais)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Estruturas de controle (loops, condicionais) em pseudocódigo.",
                                "Cálculo Numérico: Estabilidade numérica e tolerâncias (epsilon).",
                                "Ciência de Computação: Decomposição QR para resolução de sistemas lineares.",
                                "Física: Ortogonalização em bases vetoriais para mecânica quântica."
                              ],
                              "realWorldApplication": "Usado em software de machine learning (ex: scikit-learn QR para regressão), compressão de imagens via SVD aproximado, e simulações de engenharia para análise modal estável numericamente."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.3",
                        "name": "Estabilidade Numérica e Aplicações",
                        "description": "Analisar a superioridade numérica do processo modificado em termos de erro backward e preservação de ortogonalidade, relacionando-o à decomposição QR estável.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.3.1",
                            "name": "Verificar ortogonalidade pós-modificação",
                            "description": "Computar numericamente a norma de Q^T Q - I para bases geradas pelo método modificado versus clássico, demonstrando maior estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar ambiente computacional e matriz de teste",
                                  "subSteps": [
                                    "Instale bibliotecas necessárias: NumPy e optionally SciPy para normas matriciais.",
                                    "Gere uma matriz A m×n (ex: 5x4) com condição numérica alta usando np.linalg.cond para verificar ill-conditioning.",
                                    "Defina uma semente aleatória com np.random.seed(42) para reprodutibilidade.",
                                    "Salve a matriz A e imprima sua condição numérica para documentar o teste."
                                  ],
                                  "verification": "Confirme que np.linalg.cond(A) > 1e10 e que A está salva corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python 3+, Jupyter Notebook, NumPy",
                                  "tips": "Use matrizes com entradas aleatórias próximas de 1 para simular perda de ortogonalidade.",
                                  "learningObjective": "Configurar um ambiente numérico estável para testes de estabilidade.",
                                  "commonMistakes": "Esquecer de fixar a semente, levando a resultados não reproduzíveis; usar matrizes bem condicionadas que mascaram instabilidades."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Processo de Gram-Schmidt Clássico",
                                  "subSteps": [
                                    "Defina função gs_classic(A) que inicializa Q = A.copy().",
                                    "Para cada coluna j de 1 a n-1: subtraia projeções de q_j sobre q_0 a q_{j-1}, normalize q_j.",
                                    "Use loops explícitos sem otimizações para simular implementação ingênua.",
                                    "Retorne Q_classic e teste com print(Q_classic.shape)."
                                  ],
                                  "verification": "Q_classic deve ter shape (m,n) e colunas unitárias aproximadas (norma ~1).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Código Python com NumPy",
                                  "tips": "Implemente projeções como (q_k.T @ q_j) * q_k para clareza.",
                                  "learningObjective": "Codificar o algoritmo clássico passo a passo.",
                                  "commonMistakes": "Acumular erros de arredondamento em loops sem reortogonalização; normalizar antes de subtrair projeções."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Processo de Gram-Schmidt Modificado",
                                  "subSteps": [
                                    "Defina função gs_modified(A) similar ao clássico, mas adicione reortogonalização: após subtrair projeções iniciais, subtraia projeções residuais sobre todas q_0 a q_{j-1}.",
                                    "Garanta normalização apenas no final de cada coluna.",
                                    "Implemente com loops duplos para clareza na reortogonalização.",
                                    "Teste retornando Q_modified."
                                  ],
                                  "verification": "Comparar shapes e normas de colunas unitárias de Q_modified.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código Python com NumPy",
                                  "tips": "A reortogonalização corrige erros: r = r - sum((Q[:j].T @ r) * Q[:j], axis=0).",
                                  "learningObjective": "Entender e codificar a modificação que melhora estabilidade.",
                                  "commonMistakes": "Pular reortogonalização, tornando-o idêntico ao clássico; erros de indexação em slices Q[:j]."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar e Comparar Normas de Ortogonalidade",
                                  "subSteps": [
                                    "Calcule QtQ_classic = Q_classic.T @ Q_classic; erro_classic = np.linalg.norm(QtQ_classic - np.eye(n)).",
                                    "Repita para Q_modified: erro_modified = np.linalg.norm(Q_modified.T @ Q_modified - np.eye(n)).",
                                    "Imprima erros e razão erro_classic / erro_modified.",
                                    "Plote histogramas de off-diagonais de QtQ para visualização.",
                                    "Repita com múltiplas matrizes A para estatísticas médias."
                                  ],
                                  "verification": "erro_modified << erro_classic (ex: < 1e-12 vs 1e-8).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "NumPy, Matplotlib para plots opcionais",
                                  "tips": "Use np.linalg.norm(..., 'fro') para norma Frobenius robusta.",
                                  "learningObjective": "Quantificar numericamente a superioridade do método modificado.",
                                  "commonMistakes": "Usar norma errada (ex: L1 em vez de 2); esquecer eye(n) com n correto."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Resultados e Documentar Estabilidade",
                                  "subSteps": [
                                    "Compare condições de A com erros observados.",
                                    "Teste com κ(A) crescente para demonstrar perda de ortogonalidade clássica.",
                                    "Escreva relatório curto: tabelas de erros vs κ(A).",
                                    "Discuta implicações para aplicações QR."
                                  ],
                                  "verification": "Relatório mostra erro_classic cresce com κ(A), enquanto modified permanece estável.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Jupyter para relatório",
                                  "tips": "Gere A escalonada para pior caso.",
                                  "learningObjective": "Interpretar resultados numéricos em contexto de estabilidade.",
                                  "commonMistakes": "Ignorar dependência em κ(A); superestimar estabilidade sem testes variados."
                                }
                              ],
                              "practicalExample": "Gere A = np.array([[1e-10, 1], [1, 1], [1, 1+1e-10]]).T (cond > 1e10). Aplique GS clássico: ||Q^T Q - I|| ~1e-5; modificado: ~1e-14, mostrando 9 dígitos extras de precisão.",
                              "finalVerifications": [
                                "||Q_modified^T Q_modified - I|| < 1e-12 para A com cond=1e12.",
                                "Razão de erros (classic/modified) > 1e4 consistentemente.",
                                "Colunas de Q têm norma euclidiana unitária dentro de 1e-14.",
                                "Testes repetidos com 5 matrizes aleatórias confirmam tendência.",
                                "Visualizações de QtQ mostram diagonais ~1 e off-diagonais ~0 para modified.",
                                "Relatório documenta κ(A) e erros tabelados."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erros computed corretamente com norma apropriada (90%).",
                                "Implementação correta: GS modified inclui reortogonalização explícita (80%).",
                                "Análise comparativa: demonstra estabilidade superior quantitativamente (85%).",
                                "Robustez: testes com múltiplas A ill-conditioned (75%).",
                                "Documentação: código comentado e relatório claro (70%).",
                                "Eficiência: tempo de execução similar entre métodos (60%)."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Erros de arredondamento e condicionamento.",
                                "Programação Científica: Implementação eficiente em NumPy.",
                                "Estatística: Testes de hipótese em estabilidade via repetições.",
                                "Física Computacional: QR em simulações de autovalores."
                              ],
                              "realWorldApplication": "Em solvers de sistemas lineares overdetermined (least squares) via QR, onde Gram-Schmidt modified previne perda de ortogonalidade em matrizes ill-conditioned de dados experimentais, como em image processing ou machine learning feature extraction."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.2",
                            "name": "Analisar erro de arredondamento",
                            "description": "Explicar o erro backward forward stable do Gram-Schmidt modificado, citando resultados de Golub & Van Loan sobre equivalência a fatores triangulares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Processo de Gram-Schmidt Modificado (MGS)",
                                  "subSteps": [
                                    "Ler a definição formal do MGS para uma matriz A m x n.",
                                    "Implementar o pseudocódigo do MGS, destacando a normalização após cada projeção.",
                                    "Comparar com o Gram-Schmidt Clássico (CGS), identificando a ordem das operações.",
                                    "Executar manualmente para uma matriz 2x2 simples.",
                                    "Verificar ortogonalidade dos vetores q_i gerados."
                                  ],
                                  "verification": "Gerar vetores ortonormais para uma matriz de teste e confirmar ||Q^T Q - I|| < epsilon.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Matrix Computations' de Golub & Van Loan (Capítulo 5)",
                                    "Python com NumPy ou MATLAB",
                                    "Matriz de teste 3x3"
                                  ],
                                  "tips": "Sempre normalize após subtrair projeções para minimizar perda de ortogonalidade.",
                                  "learningObjective": "Compreender a mecânica sequencial do MGS e sua diferença para o CGS.",
                                  "commonMistakes": "Confundir a ordem: subtrair antes de normalizar no CGS leva a instabilidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Conceituar Estabilidade Numérica: Erros Forward e Backward",
                                  "subSteps": [
                                    "Definir erro forward: ||\tilde{Q} \tilde{R} - A|| / ||A||.",
                                    "Definir erro backward: ||A - \tilde{Q} \tilde{R}|| / ||A|| pequeno, mas \tilde{Q}, \tilde{R} exatos para matriz perturbada.",
                                    "Explicar estabilidade backward: algoritmo é estável se erro backward é pequeno independentemente de cond(A).",
                                    "Discutir componente de arredondamento fl(a) ≈ eps * ||op||.",
                                    "Relacionar com norma espectral e cond(A)."
                                  ],
                                  "verification": "Escrever definições em um relatório e exemplificar com equação numérica simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de aula sobre análise numérica",
                                    "Referência Higham 'Accuracy and Stability of Numerical Algorithms'",
                                    "Folha de papel ou editor de texto"
                                  ],
                                  "tips": "Lembre-se: backward stable significa que o erro é como se A fosse perturbado por machine epsilon.",
                                  "learningObjective": "Dominar definições precisas de forward e backward errors no contexto de ortogonalização.",
                                  "commonMistakes": "Confundir forward error (saída errada) com backward (entrada efetivamente perturbada)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Erros de Arredondamento no MGS vs CGS",
                                  "subSteps": [
                                    "Estudar perda de ortogonalidade no CGS devido a subtração catastrófica.",
                                    "Explicar como MGS mitiga isso normalizando cedo, mas ainda suscetível a erros forward grandes.",
                                    "Citar resultados: MGS é backward stable, mas não forward stable para cond(A) grande.",
                                    "Computar numericamente erro forward para matriz ill-conditioned.",
                                    "Comparar com Householder QR (forward e backward stable)."
                                  ],
                                  "verification": "Rodar simulação numérica mostrando ||Q^T Q - I|| pequeno no MGS vs grande no CGS.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código Python/MATLAB para CGS e MGS",
                                    "Matriz Vandermonde ill-conditioned",
                                    "Gráficos de erros"
                                  ],
                                  "tips": "Use cond(A) > 1/eps para demonstrar sensibilidade.",
                                  "learningObjective": "Identificar por que MGS é backward stable apesar de erros forward.",
                                  "commonMistakes": "Acreditar que MGS é forward stable; ele só melhora ortogonalidade relativa."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Citar e Compreender Resultados de Golub & Van Loan",
                                  "subSteps": [
                                    "Localizar Teorema 5.2.3 ou similar sobre estabilidade backward do MGS.",
                                    "Explicar que MGS computa QR exata para A + ΔA com ||ΔA|| ≤ O(n eps) ||A||.",
                                    "Discutir forward error: O(eps cond(A)) para ||QR - A||.",
                                    "Relacionar com análise de Wilkinson sobre crescimento de elementos.",
                                    "Anotar citações exatas do livro."
                                  ],
                                  "verification": "Escrever parágrafo resumindo teorema com citação precisa e implicações.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Golub & Van Loan 4ª ed. (seções 5.2-5.3)",
                                    "PDF ou livro físico",
                                    "Marcadores"
                                  ],
                                  "tips": "Foco na prova baseada em análise de flutuação de operações elementares.",
                                  "learningObjective": "Aplicar resultados teóricos de referência padrão para validar estabilidade.",
                                  "commonMistakes": "Ignorar dependência em n (dimensão) nos bounds de erro."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Explorar Equivalência a Fatores Triangulares",
                                  "subSteps": [
                                    "Explicar como MGS equivale a fatoração A = Q R com R upper triangular.",
                                    "Mostrar que operações de projeção acumulam em R como fatores triangulares.",
                                    "Citar Golub & Van Loan sobre similaridade algébrica com Givens/Householder.",
                                    "Verificar em exemplo: extrair R das atualizações no MGS.",
                                    "Discutir implicações para estabilidade global."
                                  ],
                                  "verification": "Derivar manualmente R para matriz 3x3 via MGS e confirmar A = Q R.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Matriz exemplo 4x4",
                                    "Calculadora simbólica como SymPy",
                                    "Papel quadriculado"
                                  ],
                                  "tips": "Pense em R como produto de atualizações triangulares reversas.",
                                  "learningObjective": "Conectar MGS clássico a interpretações triangulares modernas.",
                                  "commonMistakes": "Confundir fatores triangulares com decomposição LQ ou similar."
                                }
                              ],
                              "practicalExample": "Considere A = [[1,1],[1e-10,1e-10+1e-8],[1,1+1e-8]] (ill-conditioned). Compute QR via MGS em double precision. Meça forward error ||QR - A||/||A|| ≈ cond(A) eps ≈ 1e8 * 1e-16 = 1e-8, e backward ||ΔA||/||A|| ≈ n eps = 1e-15. Compare com CGS onde ortogonalidade falha.",
                              "finalVerifications": [
                                "Explicar corretamente backward stability do MGS com bound O(n eps).",
                                "Citar precisamente Golub & Van Loan (ex: Thm 5.2.3).",
                                "Demonstrar numericamente forward error dependente de cond(A).",
                                "Mostrar equivalência QR via extração de R triangular.",
                                "Comparar estabilidade com métodos diretos como Householder.",
                                "Verificar ortogonalidade residual ||Q^T Q - I|| < sqrt(n) eps."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual em forward vs backward errors (20%)",
                                "Correção na citação e interpretação de Golub & Van Loan (25%)",
                                "Qualidade da análise numérica em exemplo prático (20%)",
                                "Clareza na derivação de fatores triangulares (15%)",
                                "Profundidade na discussão de limitações/estabilidade (10%)",
                                "Uso correto de notação matemática e normas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Implementação em bibliotecas como LAPACK (dgeqrf).",
                                "Física Computacional: Simulações de autovalores em mecânica quântica.",
                                "Engenharia: Solvers de elementos finitos onde QR é base para fatoração.",
                                "Estatística: Análise de componentes principais (PCA) via QR estável."
                              ],
                              "realWorldApplication": "Em softwares de álgebra linear como MATLAB ou SciPy, o MGS backward stable é usado em pré-condicionadores para sistemas lineares em simulações de engenharia (ex: CFD), evitando amplificação de erros em matrizes mal-condicionadas de malhas finitas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.3",
                            "name": "Aplicar em decomposição QR",
                            "description": "Usar o Gram-Schmidt modificado para obter QR de uma matriz e resolver um problema de quadrados mínimos, comparando com métodos Householder.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o problema de mínimos quadrados e revisar Gram-Schmidt modificado",
                                  "subSteps": [
                                    "Escolha uma matriz A (m x n, m > n) e vetor b representando um sistema sobredeterminado.",
                                    "Revise o processo de Gram-Schmidt modificado: para cada coluna a_j, subtraia projeções das anteriores e normalize.",
                                    "Lembre-se da modificação para estabilidade: normalizar após subtração para evitar cancelamento.",
                                    "Defina o objetivo: encontrar x que minimiza ||Ax - b||_2 via QR.",
                                    "Prepare ferramentas para cálculos numéricos."
                                  ],
                                  "verification": "Verifique se a matriz A tem rank completo e b está definido corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matriz exemplo 3x2",
                                    "Papel e lápis ou software como Python/NumPy ou MATLAB"
                                  ],
                                  "tips": "Use uma matriz pequena inicialmente para facilitar cálculos manuais.",
                                  "learningObjective": "Compreender o setup do problema e os princípios do Gram-Schmidt modificado.",
                                  "commonMistakes": [
                                    "Esquecer m > n",
                                    "Confundir Gram-Schmidt clássico com modificado",
                                    "Não verificar independência linear"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Gram-Schmidt modificado para obter decomposição QR",
                                  "subSteps": [
                                    "Inicialize Q como matriz identidade n x n e R como zero.",
                                    "Para j=1 a n: compute projeções de a_j sobre q_1 a q_{j-1}, subtraia para obter u_j.",
                                    "Normalize u_j para q_j = u_j / ||u_j|| e atualize R.",
                                    "Verifique ortogonalidade: Q^T Q ≈ I.",
                                    "Compute R = Q^T A."
                                  ],
                                  "verification": "Confirme que A = QR, ||q_i||=1 e q_i^T q_j = 0 para i≠j.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Software NumPy ou MATLAB para verificação"
                                  ],
                                  "tips": "Implemente em loop para evitar erros de arredondamento manuais.",
                                  "learningObjective": "Executar a decomposição QR com Gram-Schmidt modificado de forma precisa.",
                                  "commonMistakes": [
                                    "Normalizar antes da subtração",
                                    "Erros em projeções escalares",
                                    "Ignorar perda de ortogonalidade numérica"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver o problema de mínimos quadrados usando QR",
                                  "subSteps": [
                                    "Compute c = Q^T b.",
                                    "Resolva R x = c por substituição retroativa (R superior triangular).",
                                    "Calcule o resíduo r = ||b - A x||_2.",
                                    "Verifique se x minimiza o erro.",
                                    "Compare com solução direta via normal equations (A^T A x = A^T b)."
                                  ],
                                  "verification": "Resíduo pequeno e x consistente com método alternativo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmos do passo anterior",
                                    "Função de solver triangular"
                                  ],
                                  "tips": "Use precisão dupla em software para estabilidade.",
                                  "learningObjective": "Aplicar QR para solução estável de mínimos quadrados.",
                                  "commonMistakes": [
                                    "Resolver Q x = c em vez de R x = c",
                                    "Não triangularizar R corretamente",
                                    "Confundir com LSQR"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com método Householder QR",
                                  "subSteps": [
                                    "Revise Householder: reflexões para zerar subdiagonal sem introduzir ortogonalidade perdida.",
                                    "Aplique Householder para triangularizar A em R, com Q produto de refletores.",
                                    "Resolva mínimos quadrados com Householder QR.",
                                    "Compare resíduos, tempo computacional e sensibilidade a erros de arredondamento.",
                                    "Discuta vantagens: Householder mais estável para ill-conditioned matrices."
                                  ],
                                  "verification": "Householder QR mais preciso em casos numéricos instáveis.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Biblioteca SciPy (qr_householder) ou MATLAB",
                                    "Matriz condicionada mal para teste"
                                  ],
                                  "tips": "Teste com matriz A mal condicionado para ver diferenças.",
                                  "learningObjective": "Analisar estabilidade numérica e comparar métodos QR.",
                                  "commonMistakes": [
                                    "Confundir Householder com Givens",
                                    "Não medir conditioning number",
                                    "Ignorar fill-in em sparse matrices"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 1], [1, 2], [1, 3]] (3x2), b = [1, 2, 3]^T. Aplique Gram-Schmidt modificado: q1 = [1,1,1]/sqrt(3), etc., obtenha R, resolva Rx = Q^T b para x ≈ [0.5, 0.5]. Com Householder, compare resíduos ~0.816.",
                              "finalVerifications": [
                                "Decomposição QR correta com Gram-Schmidt (A = QR verificado).",
                                "Solução x de mínimos quadrados com resíduo mínimo.",
                                "Comparação numérica: Householder superior em estabilidade.",
                                "Ortogonalidade preservada (Q^T Q = I dentro de eps).",
                                "Tempo e precisão medidos para ambas abordagens.",
                                "Análise de conditioning number de A."
                              ],
                              "assessmentCriteria": [
                                "Precisão da decomposição QR (erro < 1e-10).",
                                "Correção da solução de mínimos quadrados (resíduo mínimo).",
                                "Qualidade da comparação (gráficos de resíduos/condicionamento).",
                                "Explicação clara de estabilidade numérica.",
                                "Implementação eficiente sem erros comuns.",
                                "Uso adequado de ferramentas computacionais."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementar em Python/NumPy ou MATLAB.",
                                "Estatística: Regressão linear least-squares.",
                                "Engenharia: Otimização em sistemas lineares overdetermined.",
                                "Física Computacional: Modelagem de dados experimentais.",
                                "Machine Learning: Pré-processamento para PCA ou regressão."
                              ],
                              "realWorldApplication": "Em processamento de sinais para ajuste de curvas em dados ruidosos, regressão linear em machine learning, e solução de sistemas em engenharia civil (análise estrutural) onde Householder é preferido por estabilidade em matrizes grandes e ill-conditioned."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.3",
                    "name": "Fatoração QR via Gram-Schmidt",
                    "description": "Decomposição de uma matriz A em A = QR, onde Q é ortogonal e R é triangular superior, usando ortogonalização.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.3.1",
                        "name": "Processo de Ortogonalização Gram-Schmidt",
                        "description": "O processo clássico de Gram-Schmidt para ortogonalizar um conjunto de vetores linearmente independentes, gerando uma base ortogonal a partir de uma base qualquer.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.1.1",
                            "name": "Entender os passos do algoritmo Gram-Schmidt",
                            "description": "Compreender os passos sequenciais do processo Gram-Schmidt clássico: projeção ortogonal de cada vetor sobre os anteriores e subtração para obter ortogonalidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de ortogonalidade e projeção",
                                  "subSteps": [
                                    "Defina produto interno e explique sua relação com a ortogonalidade (produto interno zero).",
                                    "Descreva a fórmula da projeção ortogonal de um vetor v sobre u: proj_u v = (v · u / ||u||²) u.",
                                    "Explique o que é uma base ortonormal e por que ela é útil em Álgebra Linear.",
                                    "Diferencie base ortogonal de ortonormal.",
                                    "Resolva um exemplo simples de projeção em R²."
                                  ],
                                  "verification": "Responda corretamente a 5 perguntas sobre definições e fórmulas, sem consulta.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear (capítulo de produtos internos)",
                                    "Calculadora ou software como MATLAB/Octave",
                                    "Folha de papel e caneta"
                                  ],
                                  "tips": "Visualize geometricamente: projeção é a 'sombra' do vetor sobre a direção de u.",
                                  "learningObjective": "Dominar os pré-requisitos teóricos para o algoritmo Gram-Schmidt.",
                                  "commonMistakes": [
                                    "Confundir produto interno com norma euclidiana.",
                                    "Esquecer de dividir por ||u||² na projeção.",
                                    "Ignorar que ortogonalidade não implica normalização."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o tratamento do primeiro vetor",
                                  "subSteps": [
                                    "Identifique o primeiro vetor v₁ da base linearmente independente.",
                                    "Calcule a norma ||v₁|| usando a fórmula √(v₁ · v₁).",
                                    "Defina o primeiro vetor ortogonal u₁ = v₁ / ||v₁||.",
                                    "Verifique que ||u₁|| = 1.",
                                    "Explique por que este passo garante que u₁ seja unitário."
                                  ],
                                  "verification": "Aplique a um vetor exemplo e confirme ||u₁|| = 1 com cálculo exato.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplos de vetores em R² ou R³",
                                    "Calculadora gráfica"
                                  ],
                                  "tips": "Sempre normalize para evitar erros de escala em passos subsequentes.",
                                  "learningObjective": "Compreender a normalização inicial como base do processo.",
                                  "commonMistakes": [
                                    "Esquecer a normalização, deixando ||u₁|| ≠ 1.",
                                    "Usar norma L1 em vez de L2.",
                                    "Confundir v₁ com u₁."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Processar vetores subsequentes: subtração de projeções",
                                  "subSteps": [
                                    "Para o k-ésimo vetor v_k (k ≥ 2), calcule as projeções sobre u₁ até u_{k-1}: proj_{u_i} v_k = (v_k · u_i) u_i.",
                                    "Subtraia a soma das projeções: w_k = v_k - Σ_{i=1}^{k-1} proj_{u_i} v_k.",
                                    "Verifique que w_k é ortogonal a todos u_i anteriores (produto interno zero).",
                                    "Normalize: u_k = w_k / ||w_k||.",
                                    "Repita para todos vetores da base."
                                  ],
                                  "verification": "Mostre ortogonalidade calculando u_i · u_k = 0 para i < k em um exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Matriz de vetores exemplo 3x2",
                                    "Software simbólico como SymPy ou papel quadriculado"
                                  ],
                                  "tips": "Mantenha os vetores unitários para simplificar cálculos de produto interno.",
                                  "learningObjective": "Dominar a iteração principal do algoritmo para ortogonalidade.",
                                  "commonMistakes": [
                                    "Usar v_i em vez de u_i nas projeções.",
                                    "Esquecer de somar todas as projeções anteriores.",
                                    "Não verificar ortogonalidade intermediária."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o algoritmo completo e validar resultados",
                                  "subSteps": [
                                    "Escolha uma base linearmente independente em R³ e aplique todos os passos sequencialmente.",
                                    "Construa a matriz Q cujas colunas são os u_k.",
                                    "Verifique que Q é ortonormal: Q^T Q = I.",
                                    "Discuta estabilidade numérica (sensibilidade a erros de arredondamento).",
                                    "Compare com decomposição QR clássica."
                                  ],
                                  "verification": "Gere uma base ortonormal correta e comprove Q^T Q = I numericamente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exemplo numérico completo",
                                    "Python com NumPy ou MATLAB"
                                  ],
                                  "tips": "Use aritmética exata (frações) para pequenos exemplos para evitar erros.",
                                  "learningObjective": "Executar e validar o algoritmo Gram-Schmidt de ponta a ponta.",
                                  "commonMistakes": [
                                    "Perder ortogonalidade por erros de cálculo acumulados.",
                                    "Confundir processo clássico com modificado.",
                                    "Não normalizar o último vetor."
                                  ]
                                }
                              ],
                              "practicalExample": "Dada a base em R²: v₁ = (3, 4), v₂ = (1, 2). Passo 1: u₁ = (3/5, 4/5). Passo 2: proj_{u₁} v₂ = (29/25)(3/5, 4/5) = (87/125, 116/125). w₂ = (1,2) - proj = (38/125, 84/125). u₂ = (19/62, 42/62). Verifique: u₁ · u₂ = 0 e normas = 1.",
                              "finalVerifications": [
                                "Descreva verbalmente os 3 passos principais do algoritmo.",
                                "Aplique corretamente a um exemplo em R² sem erros de cálculo.",
                                "Prove ortogonalidade entre u_i e u_j (i ≠ j).",
                                "Explique o papel da normalização.",
                                "Identifique quando o processo falha (dependência linear).",
                                "Compare Gram-Schmidt clássico vs. modificado."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na descrição sequencial dos passos (80%).",
                                "Correção matemática em exemplos práticos (90%).",
                                "Compreensão conceitual de projeções e ortogonalidade.",
                                "Capacidade de verificação independente (Q^T Q = I).",
                                "Identificação de erros comuns e limitações.",
                                "Clareza na explicação oral ou escrita."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação em algoritmos numéricos para decomposição QR.",
                                "Física: Bases ortonormais em mecânica quântica e análise de Fourier.",
                                "Engenharia: Processamento de sinais e compressão de imagens via wavelet.",
                                "Estatística: Regressão linear e mínimos quadrados."
                              ],
                              "realWorldApplication": "O algoritmo Gram-Schmidt é fundamental na decomposição QR, usada em solvers de sistemas lineares, otimização, reconhecimento de padrões em machine learning e simulações físicas como dinâmica de fluidos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.2",
                            "name": "Aplicar Gram-Schmidt a vetores em R^n",
                            "description": "Executar manualmente o processo Gram-Schmidt em conjuntos de 2 ou 3 vetores em R^2 ou R^3, calculando os coeficientes de projeção e normalizando os vetores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os vetores e inicializar o primeiro vetor ortonormal",
                                  "subSteps": [
                                    "Liste os vetores de entrada u₁, u₂ (, u₃) em R² ou R³.",
                                    "Calcule a norma euclidiana de u₁: ||u₁|| = √(u₁x² + u₁y² + ...).",
                                    "Defina e₁ = u₁ / ||u₁||.",
                                    "Verifique se ||e₁|| = 1."
                                  ],
                                  "verification": "Confirme que ||e₁|| ≈ 1 (com tolerância numérica de 0.01).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora científica",
                                    "Software opcional: Python com NumPy"
                                  ],
                                  "tips": "Use frações exatas quando possível para evitar erros de arredondamento.",
                                  "learningObjective": "Entender a normalização do primeiro vetor para iniciar a base ortonormal.",
                                  "commonMistakes": [
                                    "Esquecer de dividir pela norma",
                                    "Erro no cálculo da norma (esquecer raiz quadrada)",
                                    "Não verificar a norma final"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Ortogonalizar o segundo vetor em relação ao primeiro",
                                  "subSteps": [
                                    "Calcule o produto interno u₂ · e₁.",
                                    "Calcule a projeção: proj_{e₁} u₂ = (u₂ · e₁) * e₁.",
                                    "Subtraia: v₂ = u₂ - proj_{e₁} u₂.",
                                    "Normalize: e₂ = v₂ / ||v₂||.",
                                    "Verifique e₁ · e₂ ≈ 0."
                                  ],
                                  "verification": "Confirme ortogonalidade: e₁ · e₂ = 0 e ||e₂|| = 1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora científica",
                                    "Software opcional: Python com NumPy"
                                  ],
                                  "tips": "Distribua os cálculos em componentes para evitar erros algébricos.",
                                  "learningObjective": "Dominar o cálculo de projeção e subtração para obter ortogonalidade.",
                                  "commonMistakes": [
                                    "Erro no sinal da subtração (subtrair em vez de adicionar)",
                                    "Usar u₁ em vez de e₁ na projeção",
                                    "Esquecer normalização de v₂"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ortogonalizar o terceiro vetor (se aplicável) em relação aos anteriores",
                                  "subSteps": [
                                    "Calcule as projeções: proj_{e₁} u₃ = (u₃ · e₁) * e₁ e proj_{e₂} u₃ = (u₃ · e₂) * e₂.",
                                    "Subtraia: v₃ = u₃ - proj_{e₁} u₃ - proj_{e₂} u₃.",
                                    "Normalize: e₃ = v₃ / ||v₃||.",
                                    "Verifique ortogonalidades: e₁ · e₃ ≈ 0 e e₂ · e₃ ≈ 0.",
                                    "Confirme ||e₃|| = 1."
                                  ],
                                  "verification": "Para três vetores, todas as ortogonalidades e normas unitárias devem ser satisfeitas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora científica",
                                    "Software opcional: Python com NumPy"
                                  ],
                                  "tips": "Anote cada projeção separadamente para rastrear erros.",
                                  "learningObjective": "Generalizar o processo para múltiplos vetores subsequentes.",
                                  "commonMistakes": [
                                    "Esquecer uma projeção anterior",
                                    "Erro acumulado de arredondamento em normas",
                                    "Não somar todas as projeções na subtração"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a base ortonormal completa e validar o span",
                                  "subSteps": [
                                    "Calcule todos os produtos internos entre e_i e e_j (i ≠ j).",
                                    "Confirme todas as normas ||e_i|| = 1.",
                                    "Verifique se a combinação linear dos e_i reproduz os u_i originais.",
                                    "Compare o determinante ou volume do paralelipípedo (opcional para R²/R³).",
                                    "Documente os resultados finais."
                                  ],
                                  "verification": "Base é ortonormal se P(e_i, e_j) = δ_{ij} (1 se i=j, 0 caso contrário).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora científica",
                                    "Software opcional: Python com NumPy"
                                  ],
                                  "tips": "Use tolerância de 10^{-3} para verificações numéricas.",
                                  "learningObjective": "Validar matematicamente a correção do processo Gram-Schmidt.",
                                  "commonMistakes": [
                                    "Ignorar erros numéricos pequenos que invalidam ortogonalidade",
                                    "Não verificar span equivalente",
                                    "Confundir ortogonal com ortonormal"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere u₁ = [1, 1], u₂ = [1, 0] em R². e₁ = [1/√2, 1/√2]. proj_{e₁} u₂ = [0.5, 0.5]. v₂ = [0.5, -0.5]. e₂ = [1/√2, -1/√2]. Verificações: e₁ · e₂ = 0, ||e₁|| = ||e₂|| = 1.",
                              "finalVerifications": [
                                "Todos os vetores e_i têm norma unitária (||e_i|| = 1).",
                                "Vetores são mutuamente ortogonais (e_i · e_j = 0 para i ≠ j).",
                                "A base {e_i} gera o mesmo subespaço que {u_i}.",
                                "Coeficientes de projeção calculados corretamente.",
                                "Cálculos manuais sem erros aritméticos significativos.",
                                "Processo documentado passo a passo."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos produtos internos e normas (erro < 0.01).",
                                "Correta subtração de todas as projeções relevantes.",
                                "Normalização aplicada a todos os v_i.",
                                "Verificações de ortogonalidade e unitariedade completas.",
                                "Generalização correta para 2 ou 3 vetores.",
                                "Clareza na documentação dos cálculos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Bases ortonormais em mecânica quântica para autovetores.",
                                "Computação: Implementação numérica em decomposição QR para resolução de sistemas lineares.",
                                "Estatística: Pré-processamento em Análise de Componentes Principais (PCA).",
                                "Engenharia: Processamento de sinais com filtros ortogonais."
                              ],
                              "realWorldApplication": "Usado em machine learning para estabilizar algoritmos de otimização (ex: gradiente descendente), em compressão de imagens via wavelets ortogonais e em simulações físicas para coordenadas cartesianas ortonormais eficientes."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.3",
                            "name": "Verificar ortogonalidade e normalização",
                            "description": "Verificar se o conjunto resultante é ortonormal, computando produtos internos e normas dos vetores obtidos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os vetores e recordar definições de ortogonalidade e normalização",
                                  "subSteps": [
                                    "Liste todos os vetores obtidos após o processo de Gram-Schmidt.",
                                    "Recorde que vetores ortogonais satisfazem <u_i, u_j> = 0 para i ≠ j.",
                                    "Recorde que vetores normalizados têm norma ||u_i|| = 1.",
                                    "Defina uma tolerância numérica pequena, como 10^{-10}, para erros de arredondamento.",
                                    "Anote a matriz de vetores para referência visual."
                                  ],
                                  "verification": "Confirme que todos os vetores estão listados corretamente e definições foram recordadas sem erros.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora ou software como Python/NumPy ou MATLAB"
                                  ],
                                  "tips": "Use notação vetorial clara para evitar confusão entre índices.",
                                  "learningObjective": "Entender os critérios matemáticos exatos para um conjunto ortonormal.",
                                  "commonMistakes": "Esquecer tolerâncias numéricas ou confundir ortogonalidade com normalização."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar produtos internos para verificar ortogonalidade",
                                  "subSteps": [
                                    "Para cada par i < j, calcule o produto interno <u_i, u_j> = u_i · u_j.",
                                    "Use a fórmula de produto escalar: soma de produtos componentes.",
                                    "Compare cada resultado com zero, considerando a tolerância definida.",
                                    "Registre todos os valores em uma tabela de matriz simétrica.",
                                    "Identifique qualquer par que viole a ortogonalidade."
                                  ],
                                  "verification": "Todos os produtos internos off-diagonal devem estar dentro da tolerância de zero.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software computacional para matrizes",
                                    "Planilha ou tabela impressa"
                                  ],
                                  "tips": "Automatize com loops em Python para conjuntos grandes de vetores.",
                                  "learningObjective": "Dominar o cálculo preciso de produtos internos em contextos numéricos.",
                                  "commonMistakes": "Calcular <u_i, u_i> em vez de pares distintos ou ignorar erros de ponto flutuante."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar normas para verificar normalização",
                                  "subSteps": [
                                    "Para cada vetor u_k, calcule a norma euclidiana ||u_k|| = sqrt(<u_k, u_k>).",
                                    "Eleve ao quadrado o produto interno consigo mesmo para evitar raízes desnecessárias inicialmente.",
                                    "Compare cada norma com 1, usando a tolerância numérica.",
                                    "Liste todas as normas em uma tabela ao lado dos produtos internos.",
                                    "Ajuste se necessário, normalizando manualmente para prática."
                                  ],
                                  "verification": "Todas as normas devem estar dentro da tolerância de 1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Biblioteca NumPy ou similar"
                                  ],
                                  "tips": "Verifique <u_k, u_k> = 1 diretamente antes da raiz para eficiência.",
                                  "learningObjective": "Aplicar a definição de norma e interpretar desvios numéricos.",
                                  "commonMistakes": "Confundir norma L1 ou L-infinito com norma L2 euclidiana."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e concluir sobre ortonormalidade",
                                  "subSteps": [
                                    "Revise a tabela completa de produtos internos e normas.",
                                    "Confirme que todas as condições são satisfeitas dentro da tolerância.",
                                    "Se houver violações, identifique a origem (ex: erro no Gram-Schmidt).",
                                    "Escreva uma declaração conclusiva: 'O conjunto é ortonormal' ou 'Não é'.",
                                    "Discuta implicações para a decomposição QR."
                                  ],
                                  "verification": "Declaração conclusiva apoiada por todos os cálculos verificados.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela de resultados anterior"
                                  ],
                                  "tips": "Sempre documente a tolerância usada para reprodutibilidade.",
                                  "learningObjective": "Sintetizar verificações para validar processos algébricos.",
                                  "commonMistakes": "Concluir prematuramente sem checar todos os pares ou normas."
                                }
                              ],
                              "practicalExample": "Dado o conjunto após Gram-Schmidt: u1 = [1, 0], u2 = [0, 1]. Compute <u1,u2> = 0, ||u1||=1, ||u2||=1. Conclusão: ortonormal. Para numérico: u1 ≈ [0.9999, 0.001], verifique com tol=1e-4.",
                              "finalVerifications": [
                                "Todos <u_i, u_j> ≈ 0 para i ≠ j.",
                                "Todas ||u_i|| ≈ 1.",
                                "Tolerância numérica explicitamente definida e aplicada.",
                                "Tabela de resultados completa e sem erros aritméticos.",
                                "Conclusão lógica baseada em todos os cálculos.",
                                "Ausência de vetores zero ou lineares dependentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de produtos internos (erro < 1e-10).",
                                "Correta aplicação de normas euclidianas.",
                                "Uso apropriado de tolerâncias numéricas.",
                                "Clareza na documentação e tabelas.",
                                "Identificação correta de ortonormalidade.",
                                "Explicação de qualquer desvio observado."
                              ],
                              "crossCurricularConnections": [
                                "Física: Bases ortonormais em mecânica quântica e coordenadas cartesianas.",
                                "Computação: Verificação em algoritmos numéricos e machine learning (PCA).",
                                "Estatística: Ortonormalidade em análise de componentes principais.",
                                "Engenharia: Decomposição QR em controle de sistemas lineares."
                              ],
                              "realWorldApplication": "Em processamento de imagens, a fatoração QR garante bases ortonormais para compressão eficiente sem perda de informação; em machine learning, verifica embeddings ortonormais para melhor generalização de modelos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.2",
                        "name": "Construção da Decomposição QR via Gram-Schmidt",
                        "description": "Aplicação do processo Gram-Schmidt às colunas de uma matriz A para obter A = QR, onde Q tem colunas ortonormais e R é triangular superior.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.2.1",
                            "name": "Implementar Gram-Schmidt para matrizes m x n",
                            "description": "Aplicar o algoritmo Gram-Schmidt às colunas de uma matriz A (m x n, com posto n) para construir as colunas de Q e os elementos de R.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a matriz de entrada e inicializar estruturas de dados",
                                  "subSteps": [
                                    "Receba a matriz A de dimensões m x n com m >= n e posto completo n.",
                                    "Verifique as dimensões de A usando shape ou size.",
                                    "Inicialize Q como uma matriz m x n zerada.",
                                    "Inicialize R como uma matriz n x n zerada.",
                                    "Defina uma tolerância numérica pequena (ex: 1e-10) para evitar divisões por zero."
                                  ],
                                  "verification": "Matrizes Q e R inicializadas com dimensões corretas e tolerância definida.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ambiente de programação (Python com NumPy ou MATLAB)",
                                    "Matriz A de exemplo (ex: 3x2)"
                                  ],
                                  "tips": "Use bibliotecas vetoriais como NumPy para operações eficientes em arrays.",
                                  "learningObjective": "Configurar corretamente os dados de entrada e estruturas para o algoritmo Gram-Schmidt.",
                                  "commonMistakes": [
                                    "Confundir dimensões m x n (linhas x colunas)",
                                    "Não inicializar R como quadrada n x n"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Processar a primeira coluna para obter q1 e r11",
                                  "subSteps": [
                                    "Extraia a primeira coluna a1 = A[:, 0].",
                                    "Calcule a norma euclidiana r11 = ||a1|| usando sqrt(dot(a1, a1)).",
                                    "Se r11 < tolerância, sinalize falha (matriz singular).",
                                    "Normalize q1 = a1 / r11.",
                                    "Armazene q1 em Q[:, 0]."
                                  ],
                                  "verification": "||q1|| ≈ 1 e Q[:, 0] == q1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Função de norma (np.linalg.norm ou manual)"
                                  ],
                                  "tips": "Use operações vetorizadas para calcular normas e evitar loops desnecessários.",
                                  "learningObjective": "Implementar a normalização da primeira coluna base do processo Gram-Schmidt.",
                                  "commonMistakes": [
                                    "Esquecer de verificar se ||a1|| é zero",
                                    "Dividir por norma sem normalizar corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o loop principal para colunas subsequentes (cálculo de uk)",
                                  "subSteps": [
                                    "Para cada k de 1 a n-1 (índice 1-based):",
                                    "Extraia ak = A[:, k].",
                                    "Inicialize uk = ak.",
                                    "Para cada i de 0 a k-1: calcule rij = dot(Q[:, i], uk).",
                                    "Subtraia uk = uk - rij * Q[:, i]."
                                  ],
                                  "verification": "Para cada k, uk é ortogonal às q_i anteriores (dot(Q[:, i], uk) ≈ 0 para i < k).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Loop aninhado para projeções"
                                  ],
                                  "tips": "O loop interno realiza ortogonalização progressiva; mantenha uk atualizado.",
                                  "learningObjective": "Ortogonalizar colunas subsequentes subtraindo projeções sobre bases anteriores.",
                                  "commonMistakes": [
                                    "Índices errados no loop (off-by-one)",
                                    "Usar ak em vez de uk atualizado nas projeções"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Normalizar qk, preencher R e finalizar",
                                  "subSteps": [
                                    "Ainda no loop para k=1 a n-1: após uk, calcule rkk = ||uk||.",
                                    "Se rkk < tolerância, sinalize singularidade.",
                                    "Normalize qk = uk / rkk e armazene em Q[:, k].",
                                    "Preencha R[i, k] = dot(Q[:, i], ak) para i <= k (ou use rij calculados).",
                                    "Após loop, verifique A ≈ Q @ R numericamente."
                                  ],
                                  "verification": "Q tem colunas unitárias e ortogonais; R superior triangular; ||A - Q@R|| < 1e-8.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Operador de multiplicação matricial (@ ou matmul)"
                                  ],
                                  "tips": "Preencha R durante o loop para eficiência; rkk vai na diagonal.",
                                  "learningObjective": "Completar a normalização e triangularização superior de R.",
                                  "commonMistakes": [
                                    "Normalizar com ||ak|| em vez de ||uk||",
                                    "Não preencher diagonal de R corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Realizar verificações finais da decomposição QR",
                                  "subSteps": [
                                    "Verifique normas das colunas de Q: todas ≈1.",
                                    "Verifique ortogonalidade: Q^T Q ≈ I (identidade).",
                                    "Verifique se R é triangular superior (elementos abaixo diagonal ≈0).",
                                    "Calcule erro de reconstrução: ||A - Q R|| / ||A|| < tolerância.",
                                    "Teste com matriz conhecida para validar."
                                  ],
                                  "verification": "Todas verificações passam com tolerância numérica.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Funções de verificação (norm, eye)"
                                  ],
                                  "tips": "Use tolerância relativa para comparações flutuantes.",
                                  "learningObjective": "Validar a corretão da implementação Gram-Schmidt.",
                                  "commonMistakes": [
                                    "Ignorar erros de ponto flutuante",
                                    "Verificar exatidão em vez de aproximação"
                                  ]
                                },
                                {
                                  "practicalExample": "Considere A = [[1, 0], [1, 1], [0, 1]] (3x2).\nApós Gram-Schmidt:\nq1 ≈ [0.707, 0.707, 0], r11 ≈ 1.414\nuk2 = [0,1,1] - 0.707*[0.707,0.707,0] ≈ [-0.5, 0.5, 1]\n||uk2|| ≈ 1.2247, q2 ≈ [-0.408, 0.408, 0.816]\nR = [[1.414, 0.707], [0, 1.2247]]\nVerifique A ≈ Q R."
                                },
                                "finalVerifications=["
                              ],
                              "Q tem colunas de norma 1 (||q_k|| = 1 para todo k).[\"Q é ortogonal (Q^T Q = I).[\"R é triangular superior (r_ij = 0 para i > j).[\"Reconstrução exata: A = Q R (até erro numérico).[\"Não há singularidades detectadas (diagonal de R > tol).[\"Ortogonalidade de uk durante processo (dot(q_i, uk) = 0).[\"Eficiência: tempo de execução razoável para m,n médios.": [
                                "Implementação correta produz Q e R com propriedades exatas (erro < 1e-10).",
                                "Código lida com casos edge (norma zero).",
                                "Estrutura de dados eficiente (O(mn^2) operações).",
                                "Comentários e variáveis claras.",
                                "Testes unitários passam para exemplos conhecidos.",
                                "Tratamento numérico robusto (tolerâncias)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de vetores, loops aninhados e operações lineares em NumPy/Python.",
                                "Física: Projeções ortogonais em espaços vetoriais para análise de forças.",
                                "Ciência de Dados: Pré-processamento para PCA ou regressão linear via least squares.",
                                "Engenharia: Solução numérica de sistemas sobredeterminado.",
                                "Computação Gráfica: Bases ortonormais para transformações."
                              ],
                              "realWorldApplication": "A decomposição QR via Gram-Schmidt é fundamental para resolver mínimos quadrados (ex: regressão linear em machine learning), computar autovalores via QR algorithm, estabilizar soluções numéricas em simulações físicas e engenharia, e em compressão de dados/sinal onde bases ortogonais reduzem dimensionalidade."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.2",
                            "name": "Calcular os elementos da matriz R",
                            "description": "Determinar os coeficientes r_{ij} como produtos internos entre colunas de A e Q durante o processo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar as matrizes A e Q para cálculo de R",
                                  "subSteps": [
                                    "Identifique as dimensões da matriz A (m x n) e confirme que Q é m x n com colunas ortonormais.",
                                    "Extraia e liste todas as colunas de A como vetores coluna: a_1, a_2, ..., a_n.",
                                    "Extraia e liste todas as colunas de Q: q_1, q_2, ..., q_n.",
                                    "Verifique ortonormalidade de Q calculando alguns produtos internos q_i^T q_k ≈ δ_{ik} (delta de Kronecker).",
                                    "Prepare uma matriz vazia R de tamanho n x n, inicializando zeros abaixo da diagonal."
                                  ],
                                  "verification": "Colunas listadas corretamente e Q^T Q ≈ I (identidade) com tolerância numérica 10^{-10}.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Matriz A e Q do processo Gram-Schmidt anterior, calculadora, papel quadriculado ou software (Python/NumPy/MATLAB).",
                                  "tips": "Trate colunas como vetores coluna; use transposição explícita q_i^T para produtos internos.",
                                  "learningObjective": "Compreender a relação A = QR e preparar dados para produtos internos.",
                                  "commonMistakes": "Confundir linhas com colunas de A/Q; ignorar verificação de ortonormalidade de Q."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular elementos r_{ij} acima da diagonal (i < j)",
                                  "subSteps": [
                                    "Para cada coluna j de 2 até n:",
                                    "Para cada i de 1 até j-1, compute r_{ij} = q_i^T a_j = ∑_{k=1}^m q_{ki} * a_{kj}.",
                                    "Registre o valor em R[i,j]; garanta precisão numérica com casas decimais adequadas.",
                                    "Verifique um cálculo manual para j=2, i=1 contra software.",
                                    "Anote qualquer valor complexo se aplicável (para campos reais, deve ser real)."
                                  ],
                                  "verification": "Valores r_{ij} coincidem com q_i^T a_j computado independentemente (erro < 10^{-8}).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Listas de colunas de A e Q, calculadora matricial ou código NumPy (np.dot(q_i, a_j)).",
                                  "tips": "Implemente em loop: for j in range(1,n): for i in range(j): r[i,j] = np.dot(Q[:,i], A[:,j]).",
                                  "learningObjective": "Dominar cálculo de coeficientes de projeção ortogonal via produto interno.",
                                  "commonMistakes": "Usar produto escalar incorreto (não transpor q_i); arredondamento prematuro."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular elementos da diagonal r_{jj} (i = j)",
                                  "subSteps": [
                                    "Para cada j de 1 até n, compute r_{jj} = q_j^T a_j = ∑_{k=1}^m q_{kj} * a_{kj}.",
                                    "Garanta que r_{jj} > 0 (absorva sinal na normalização de Gram-Schmidt modificado se necessário).",
                                    "Registre em R[j,j]; compare com norma esperada da projeção ortogonal.",
                                    "Para matrizes reais, confirme que |r_{jj}| ≈ || componente ortogonal de a_j ||.",
                                    "Salve valores para verificação posterior."
                                  ],
                                  "verification": "r_{jj} = ||a_j - ∑_{i<j} r_{ij} q_i|| (do processo Gram-Schmidt), com erro pequeno.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Colunas de Q e A, software para dot product eficiente.",
                                  "tips": "Na prática, r_{jj} captura a 'novidade' da coluna a_j após ortogonalização.",
                                  "learningObjective": "Entender o papel da diagonal como fatores de escala nas bases ortonormais.",
                                  "commonMistakes": "Negar r_{jj} (deve ser positivo por convenção); confundir com norma de a_j."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar R completa e verificar a decomposição QR",
                                  "subSteps": [
                                    "Preencha a matriz R triangular superior com todos r_{ij} calculados e zeros abaixo da diagonal.",
                                    "Compute o produto Q R e compare elemento a elemento com A original.",
                                    "Calcule o resíduo ||A - Q R||_F (norma de Frobenius) < 10^{-10}.",
                                    "Verifique propriedades: R upper triangular, diag(R) > 0, Q^T Q = I.",
                                    "Documente R final e resíduo para relatório."
                                  ],
                                  "verification": "||A - Q R||_F ≈ 0 e R satisfaz triangularidade e positividade diagonal.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Matriz R parcial, Q, A, software para multiplicação matricial (np.matmul(Q, R)).",
                                  "tips": "Use laço ou broadcasting em NumPy para eficiência em matrizes grandes.",
                                  "learningObjective": "Validar a decomposição QR via reconstrução e propriedades algébricas.",
                                  "commonMistakes": "Esquecer zeros abaixo diagonal; erros de propagação numérica em Q."
                                }
                              ],
                              "practicalExample": "Para A = [[1, 1], [0, 1]] (colunas a1=[1,0]^T, a2=[1,1]^T), após Gram-Schmidt Q = [[1, 0], [0, 1]]. Então r11 = [1,0]·[1,0]=1, r12=[1,0]·[1,1]=1, r22=[0,1]·[1,1]=1. R=[[1,1],[0,1]], e QR=A exatamente.",
                              "finalVerifications": [
                                "Todos r_{ij} (i≤j) calculados como q_i^T a_j com precisão numérica.",
                                "Matriz R é triangular superior com diagonal positiva.",
                                "Produto Q R reproduz A com resíduo ||A - QR|| < 10^{-10}.",
                                "Propriedades preservadas: colunas Q ortonormais, R upper triangular.",
                                "Cálculos manuais batem com implementação computacional.",
                                "Documentação inclui valores exatos e verificações."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos produtos internos (erro < 10^{-12}).",
                                "Correta identificação de posições i≤j em R.",
                                "Verificação robusta de QR ≈ A com métrica de norma.",
                                "Uso eficiente de ferramentas computacionais.",
                                "Explicação clara do processo e propriedades algébricas.",
                                "Tratamento de casos edge (matrizes singulares ou mal-condicionadas)."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação numérica estável em bibliotecas como LAPACK.",
                                "Física: Projeções ortogonais em mecânica quântica e análise de modos normais.",
                                "Engenharia: Solvers para sistemas lineares em controle e simulações.",
                                "Estatística: Base para PCA e regressão least-squares."
                              ],
                              "realWorldApplication": "A matriz R da decomposição QR é essencial para solvers numéricos estáveis de Ax=b (back-substitution em R), minimização least-squares em machine learning, e compressão de dados em processamento de sinais/imagens."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.3",
                            "name": "Normalizar colunas para obter Q ortogonal",
                            "description": "Normalizar os vetores ortogonais obtidos para formar a matriz Q unitária (ortogonal).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e listar os vetores ortogonais obtidos",
                                  "subSteps": [
                                    "Liste todos os vetores ortogonais u₁, u₂, ..., uₖ produzidos pelo processo Gram-Schmidt anterior",
                                    "Verifique a ortogonalidade pairwise: compute uᵢ · uⱼ = 0 para todo i ≠ j",
                                    "Confirme que nenhum vetor uᵢ é o vetor nulo (||uᵢ|| > 0)",
                                    "Anote as dimensões de cada vetor (deve ser m x 1 para matriz m x k)",
                                    "Organize em uma tabela ou matriz para visualização clara"
                                  ],
                                  "verification": "Lista confirmada com vetores ortogonais não nulos e pairwise ortogonais.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Papel ou caderno",
                                    "Calculadora científica",
                                    "Software como Python/NumPy ou MATLAB (opcional)"
                                  ],
                                  "tips": "Use notação vetorial consistente (colunas) e rotule cada uᵢ claramente para evitar confusões.",
                                  "learningObjective": "Compreender o estado inicial dos vetores ortogonais antes da normalização.",
                                  "commonMistakes": [
                                    "Confundir vetores ortogonais com os originais de A",
                                    "Ignorar vetores nulos que invalidam o processo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a norma euclidiana de cada vetor ortogonal",
                                  "subSteps": [
                                    "Para cada uᵢ, aplique a fórmula ||uᵢ|| = √(∑_{j=1}^m u_{ji}²) ou √(uᵢᵀ uᵢ)",
                                    "Compute o produto escalar uᵢᵀ uᵢ somando os quadrados dos componentes",
                                    "Extraia a raiz quadrada para obter a norma",
                                    "Registre todas as normas em uma lista: r₁ = ||u₁||, r₂ = ||u₂||, ..., rₖ = ||uₖ||",
                                    "Verifique que todas as normas são positivas e finitas"
                                  ],
                                  "verification": "Normas calculadas corretamente com valores > 0, confirmados por recálculo manual de pelo menos uma.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Planilha Excel ou Python para somas rápidas",
                                    "Referência de fórmula de norma euclidiana"
                                  ],
                                  "tips": "Use a forma matricial uᵀu para eficiência computacional em software.",
                                  "learningObjective": "Dominar o cálculo preciso da norma euclidiana em vetores.",
                                  "commonMistakes": [
                                    "Esquecer a raiz quadrada",
                                    "Usar norma L1 ou L∞ por engano",
                                    "Erros aritméticos em somas de quadrados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Normalizar cada vetor dividindo pela sua norma",
                                  "subSteps": [
                                    "Para cada i, compute qᵢ = uᵢ / ||uᵢ|| = uᵢ / rᵢ",
                                    "Divida componente por componente: q_{ji} = u_{ji} / rᵢ para j=1 a m",
                                    "Repita para todos os vetores u₁ a uₖ",
                                    "Verifique manualmente a norma de pelo menos um qᵢ: deve ser exatamente 1",
                                    "Armazene os qᵢ em formato de colunas para formar Q"
                                  ],
                                  "verification": "Cada qᵢ tem ||qᵢ|| = 1, confirmado por cálculo de norma.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Calculadora de alta precisão",
                                    "Software NumPy para divisão vetorial"
                                  ],
                                  "tips": "Mantenha precisão numérica; use frações exatas se possível antes de decimalizar.",
                                  "learningObjective": "Aplicar normalização para obter vetores unitários a partir de ortogonais.",
                                  "commonMistakes": [
                                    "Dividir pela norma errada (ex: usar rⱼ em vez de rᵢ)",
                                    "Inverter divisão (multiplicar)",
                                    "Perder precisão em divisões decimais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir a matriz Q e validar ortogonalidade",
                                  "subSteps": [
                                    "Forme a matriz Q com colunas q₁, q₂, ..., qₖ (m x k)",
                                    "Compute Qᵀ Q e verifique se resulta na identidade k x k (ou diagonal com 1s se rank <k)",
                                    "Confirme colunas unitárias: ||qᵢ|| = 1 para todos i",
                                    "Verifique multiplicação A ≈ Q R, onde R tem diagonais rᵢ",
                                    "Documente as propriedades: Q ortogonal/unitária"
                                  ],
                                  "verification": "Qᵀ Q = I e cada coluna unitária, com erro numérico < 10^{-10}.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Software MATLAB/Python para multiplicação matricial",
                                    "Papel para Q pequena"
                                  ],
                                  "tips": "Use tolerâncias numéricas em software para erros de arredondamento.",
                                  "learningObjective": "Validar a matriz Q como base ortonormal.",
                                  "commonMistakes": [
                                    "Colocar linhas em vez de colunas",
                                    "Esquecer transposição em Qᵀ Q",
                                    "Não verificar identidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[1, 1], [1, 0]] (Gram-Schmidt dá u₁ = [1,1]ᵀ, ||u₁||=√2; u₂ = [0, -1]ᵀ + projeção ajustada, mas simplificado: q₁ = [1/√2, 1/√2]ᵀ, q₂ = [1/√2, -1/√2]ᵀ. Q = [[1/√2, 1/√2], [1/√2, -1/√2]]. Verifique Qᵀ Q = I₂.",
                              "finalVerifications": [
                                "Cada coluna de Q tem norma euclidiana exatamente 1",
                                "Produto escalar entre colunas distintas é zero",
                                "Qᵀ Q resulta na matriz identidade",
                                "A = Q R aproximadamente, com R superior triangular",
                                "Nenhuma norma original era zero",
                                "Preservação da ortogonalidade do processo anterior"
                              ],
                              "assessmentCriteria": [
                                "Precisão aritmética nos cálculos de normas (erro < 0.01)",
                                "Correção na normalização componente a componente",
                                "Validação completa de Qᵀ Q = I",
                                "Uso apropriado de ferramentas numéricas",
                                "Explicação clara de cada passo",
                                "Identificação e correção de erros comuns"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em NumPy (linalg.norm e divisão)",
                                "Física: Vetores unitários em coordenadas normalizadas",
                                "Estatística: Bases ortonormais em Análise de Componentes Principais (PCA)",
                                "Engenharia: Estabilização numérica em solvers lineares"
                              ],
                              "realWorldApplication": "A matriz Q ortonormal é essencial na decomposição QR para resolver sistemas lineares Ax=b de forma numericamente estável, usada em otimização, machine learning (ex: regressão least squares) e processamento de sinais (ex: filtros QR em áudio)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.4",
                            "name": "Verificar a decomposição A = QR",
                            "description": "Multiplicar Q e R e confirmar que o resultado é igual à matriz A original.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar as matrizes Q e R da decomposição",
                                  "subSteps": [
                                    "Recupere a matriz A original e suas dimensões (m x n)",
                                    "Confirme que Q é uma matriz m x n com colunas ortonormais (Q^T Q ≈ I)",
                                    "Verifique que R é uma matriz n x n triangular superior sem zeros na diagonal principal",
                                    "Armazene Q e R em formato numérico adequado (ex: array NumPy)",
                                    "Defina uma tolerância numérica epsilon (ex: 1e-10) para comparações"
                                  ],
                                  "verification": "Q e R estão prontos, com dimensões corretas e propriedades iniciais confirmadas",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Matriz A original",
                                    "Matrizes Q e R computadas",
                                    "Software: Python com NumPy ou MATLAB"
                                  ],
                                  "tips": "Sempre normalize colunas de Q para garantir ortonormalidade exata",
                                  "learningObjective": "Identificar e validar as propriedades fundamentais de Q e R na decomposição QR",
                                  "commonMistakes": [
                                    "Ignorar erros de arredondamento em Q",
                                    "Confundir dimensões reduzida vs completa",
                                    "Usar R não triangular"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar o produto matricial Q * R",
                                  "subSteps": [
                                    "Implemente a multiplicação matricial usando função built-in (np.dot(Q, R))",
                                    "Verifique dimensões: resultado deve ser m x n como A",
                                    "Calcule elemento por elemento se manual, priorizando computacional",
                                    "Armazene o produto em uma nova matriz chamada QR_computed",
                                    "Registre o tempo de computação para análise de eficiência"
                                  ],
                                  "verification": "Matriz QR_computed gerada sem erros de shape ou overflow",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Biblioteca NumPy ou MATLAB",
                                    "Q e R do passo anterior"
                                  ],
                                  "tips": "Use multiplicação otimizada BLAS para grandes matrizes",
                                  "learningObjective": "Executar multiplicação matricial precisa em contexto computacional",
                                  "commonMistakes": [
                                    "Erro de ordem: R*Q ao invés de Q*R",
                                    "Não lidar com precisão de ponto flutuante",
                                    "Sobrecarga computacional em matrizes grandes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar QR_computed com A original",
                                  "subSteps": [
                                    "Calcule a norma da diferença: diff = np.linalg.norm(A - QR_computed, 'fro')",
                                    "Compare diff com epsilon: se diff < epsilon, decomposição é válida",
                                    "Inspecione elementos individuais para discrepâncias visuais",
                                    "Plote heatmaps de A, QR e diff para análise qualitativa",
                                    "Registre o valor exato de diff para relatório"
                                  ],
                                  "verification": "Norma da diferença abaixo da tolerância definida",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "NumPy/MATLAB para normas e plots",
                                    "Matplotlib para visualização"
                                  ],
                                  "tips": "Use norma Frobenius para comparação global; norma 2 para vetores",
                                  "learningObjective": "Avaliar numericamente a exatidão da decomposição QR",
                                  "commonMistakes": [
                                    "Tolerância muito rigorosa ignorando erros flutuantes",
                                    "Comparação elemento a elemento sem norma",
                                    "Ignorar escala da matriz"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir e documentar a verificação",
                                  "subSteps": [
                                    "Se válido, confirme 'Decomposição QR correta'; senão, identifique fonte de erro",
                                    "Verifique propriedades extras: Q^T Q ≈ I e R diagonal positiva",
                                    "Gere relatório com diff, tempo e plots",
                                    "Salve resultados em arquivo para reutilização",
                                    "Discuta implicações numéricas da verificação"
                                  ],
                                  "verification": "Relatório completo com conclusão clara (válida/inválida)",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de texto ou Jupyter Notebook"
                                  ],
                                  "tips": "Automatize em script para verificações repetidas",
                                  "learningObjective": "Interpretar resultados e comunicar achados da verificação",
                                  "commonMistakes": [
                                    "Não verificar ortonormalidade de Q",
                                    "Concluir sem análise de erro",
                                    "Omitir documentação"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 3], [1, 1], [0, 1]] (3x2). Após Gram-Schmidt: Q ≈ [[0.707, 0.707], [0.707, -0.707], [0, 1]], R ≈ [[1.414, 2.828], [0, 1.414]]. Compute QR: np.dot(Q, R) deve igualar A com diff < 1e-10.",
                              "finalVerifications": [
                                "||A - QR||_F < 1e-10",
                                "Q^T Q = I (ortonormalidade das colunas)",
                                "R é triangular superior com diagonal positiva",
                                "Nenhum NaN ou Inf no produto QR",
                                "Tempo de verificação razoável para tamanho de A",
                                "Plots confirmam similaridade visual"
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica correta na multiplicação e comparação",
                                "Uso adequado de tolerâncias para erros flutuantes",
                                "Verificação completa de propriedades QR",
                                "Interpretação correta de discrepâncias",
                                "Documentação clara e reproduzível",
                                "Eficiência computacional demonstrada"
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica (implementação em Python/NumPy)",
                                "Análise Numérica (estabilidade e condicionamento)",
                                "Machine Learning (pré-processamento em regressão linear)",
                                "Física Computacional (simulações dinâmicas)"
                              ],
                              "realWorldApplication": "Em solvers de sistemas lineares Ax=b, onde QR acelera backward substitution; em least squares para regressão; compressão de imagens e processamento de sinais para garantir estabilidade numérica em aplicações de engenharia."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.3",
                        "name": "Propriedades e Considerações Numéricas da QR via Gram-Schmidt",
                        "description": "Propriedades da decomposição QR e análise de estabilidade numérica do processo clássico Gram-Schmidt.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.3.1",
                            "name": "Identificar propriedades de Q e R",
                            "description": "Reconhecer que Q é ortogonal (Q^T Q = I) e R é triangular superior com diagonais positivas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Processo de Gram-Schmidt e a Decomposição QR",
                                  "subSteps": [
                                    "Recordar a definição de decomposição QR: A = QR, onde Q é ortogonal e R é triangular superior.",
                                    "Relembrar os passos do processo Gram-Schmidt para ortogonalizar colunas de A: u1 = a1, e1 = u1 / ||u1||, u2 = a2 - proj_e1 a2, etc.",
                                    "Entender como Q é formada pelas colunas normalizadas (ortonormais) e R pelos coeficientes de projeção.",
                                    "Esboçar um exemplo simples de matriz 2x2 para visualizar Q e R."
                                  ],
                                  "verification": "Capacidade de escrever os passos do Gram-Schmidt e formar Q e R manualmente para uma matriz pequena.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora ou software como Python/NumPy"
                                  ],
                                  "tips": "Comece com uma matriz simples para evitar erros de cálculo.",
                                  "learningObjective": "Compreender a origem das matrizes Q e R no contexto do Gram-Schmidt.",
                                  "commonMistakes": "Confundir normalização com ortogonalização; esquecer de subtrair projeções em passos subsequentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar Ortogonalidade de Q (Q^T Q = I)",
                                  "subSteps": [
                                    "Computar Q^T manualmente multiplicando Q transposta por Q.",
                                    "Verificar se o resultado é a matriz identidade I (diagonal 1s, off-diagonal 0s).",
                                    "Entender matematicamente por que as colunas de Q são ortonormais: produto interno zero e norma 1.",
                                    "Testar numericamente com tolerância para flutuações em computação (ex: ||Q^T Q - I|| < 1e-10)."
                                  ],
                                  "verification": "Q^T Q resulta em I dentro de precisão numérica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matriz de exemplo",
                                    "Software de álgebra linear (MATLAB, Octave ou Jupyter Notebook)"
                                  ],
                                  "tips": "Use propriedades de ortonormalidade: q_i^T q_j = δ_ij (delta de Kronecker).",
                                  "learningObjective": "Reconhecer e provar que Q é uma matriz ortogonal.",
                                  "commonMistakes": "Ignorar erros de arredondamento em cálculos manuais; assumir exatidão perfeita em flutuantes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Estrutura Triangular Superior de R e Diagonais Positivas",
                                  "subSteps": [
                                    "Identificar elementos abaixo da diagonal em R como zero por construção do Gram-Schmidt.",
                                    "Verificar que a diagonal de R contém normas das projeções ortogonais, que são positivas (||u_k|| > 0 assumindo A de posto completo).",
                                    "Computar R = Q^T A e confirmar triangularidade superior.",
                                    "Discutir o que acontece se uma diagonal for zero (coluna linearmente dependente)."
                                  ],
                                  "verification": "R tem zeros abaixo da diagonal e diagonais > 0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Mesma matriz de exemplo",
                                    "Ferramentas computacionais"
                                  ],
                                  "tips": "Lembre-se: sinal positivo nas diagonais vem da normalização e1 = u1 / ||u1|| com ||u1|| > 0.",
                                  "learningObjective": "Identificar as propriedades estruturais exatas de R.",
                                  "commonMistakes": "Confundir R com triangular inferior; não verificar positividade das diagonais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar Propriedades em um Exemplo Numérico Completo",
                                  "subSteps": [
                                    "Escolher uma matriz A 3x2 ou 3x3 e computar QR via Gram-Schmidt passo a passo.",
                                    "Verificar A = QR multiplicando e checando igualdade.",
                                    "Computar Q^T Q e diagonais de R explicitamente.",
                                    "Discutir considerações numéricas: perda de ortogonalidade em Gram-Schmidt clássico devido a cancelamentos."
                                  ],
                                  "verification": "Verificação completa: Q ortogonal, R triangular superior com diag > 0, e A ≈ QR.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notebook Jupyter com NumPy",
                                    "Matrizes de teste pré-definidas"
                                  ],
                                  "tips": "Use Householder para comparação, mas foque em Gram-Schmidt.",
                                  "learningObjective": "Integrar todas as propriedades em uma verificação prática.",
                                  "commonMistakes": "Erros de propagação numérica levando a Q não exatamente ortogonal; pivotação ausente."
                                }
                              ],
                              "practicalExample": "Para A = [[3, 1, 1], [2, 2, 1], [1, 1, 2]], aplique Gram-Schmidt: q1 = [3,2,1]/√14, etc. Verifique Q^T Q = I e R = [[√14, ...], [0, ...], [0,0,...]] com diagonais positivas.",
                              "finalVerifications": [
                                "Q^T Q = I (ou próximo dentro de 1e-12).",
                                "R é estritamente triangular superior (zeros abaixo da diagonal).",
                                "Diagonais de R são positivas.",
                                "A = QR com erro residual mínimo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de ortogonalidade (90%+).",
                                "Correta descrição da estrutura de R (triangular, diag >0).",
                                "Uso correto de verificações numéricas (normas, tolerâncias).",
                                "Explicação clara das propriedades matemáticas subjacentes.",
                                "Aplicação prática sem erros computacionais graves."
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Implementação numérica estável em bibliotecas como LAPACK.",
                                "Física: Bases ortonormais em mecânica quântica (autovetores).",
                                "Engenharia: Solução de sistemas lineares em controle e simulações.",
                                "Estatística: Redução de dimensionalidade em PCA via QR."
                              ],
                              "realWorldApplication": "Em machine learning, QR é usada para regressão linear least-squares estável (R^(-1) b via back-substitution); em gráficos computacionais para rotações ortogonais preservando normas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.3.2",
                            "name": "Analisar sensibilidade numérica do Gram-Schmidt clássico",
                            "description": "Entender os problemas de perda de ortogonalidade devido a erros de arredondamento e quando o processo falha.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o algoritmo Gram-Schmidt clássico teoricamente",
                                  "subSteps": [
                                    "Relembrar a definição de base ortonormal e o objetivo do processo Gram-Schmidt.",
                                    "Descrever os passos do algoritmo clássico: projeção e subtração ortogonal para cada vetor.",
                                    "Derivar matematicamente a fórmula de projeção: proj_u(v) = (v · q_k) q_k.",
                                    "Explicar propriedades ideais: ortogonalidade e normalização exata em aritmética exata.",
                                    "Discutir pré-condições: linear independência dos vetores de entrada."
                                  ],
                                  "verification": "Escrever o pseudocódigo completo do Gram-Schmidt clássico e verificar ortogonalidade simbólica para um exemplo 2D.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Folha de papel, livro de Álgebra Linear (ex: Strang), calculadora simbólica como SymPy.",
                                  "tips": "Use notação vetorial clara para evitar confusão entre escalares e vetores.",
                                  "learningObjective": "Compreender o funcionamento exato do algoritmo em aritmética ideal.",
                                  "commonMistakes": "Confundir Gram-Schmidt clássico com o modificado; esquecer a normalização após subtração."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir erros de arredondamento em operações fundamentais",
                                  "subSteps": [
                                    "Explicar o modelo de aritmética de ponto flutuante (IEEE 754) e erro relativo fl(a ± b) ≈ machine epsilon.",
                                    "Analisar erros na multiplicação escalar-vetor e produto interno.",
                                    "Estudar propagação de erros na subtração ortogonal: catastrófica quando vetores são quase paralelos.",
                                    "Calcular bound de erro para produto interno usando ||e|| ≤ n ε ||x|| ||y||.",
                                    "Simular numericamente um produto interno com números condicionados."
                                  ],
                                  "verification": "Computar manualmente um produto interno com ε = 10^-16 e comparar com exato.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software Python/MATLAB com numpy, tabela de ε_machine.",
                                  "tips": "Sempre normalize vetores de entrada para isolar efeitos de magnitude.",
                                  "learningObjective": "Identificar fontes primárias de erro numérico no algoritmo.",
                                  "commonMistakes": "Ignorar que erros se acumulam quadraticamente em iterações subsequentes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar perda de ortogonalidade experimentalmente",
                                  "subSteps": [
                                    "Implementar Gram-Schmidt clássico em código numérico.",
                                    "Aplicar a uma matriz bem-condicionada e medir ||Q^T Q - I||_F (norma de Frobenius).",
                                    "Aplicar a uma matriz mal-condicionada (ex: Hilbert ou vetores quase colineares).",
                                    "Plotar perda de ortogonalidade vs. condição da matriz.",
                                    "Comparar com QR exata via Householder para benchmark."
                                  ],
                                  "verification": "Gerar plot onde ||Q^T Q - I|| > 10^-10 indica perda significativa.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python (numpy, matplotlib), MATLAB ou Octave.",
                                  "tips": "Use cond(A) para quantificar condicionamento antes da análise.",
                                  "learningObjective": "Observar empiricamente a degradação da ortogonalidade.",
                                  "commonMistakes": "Usar precisão dupla sem testar single para exagerar erros."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar condições de falha e sensibilidade geral",
                                  "subSteps": [
                                    "Derivar bound teórico para perda de ortogonalidade: O(κ(A)^2 ε).",
                                    "Identificar gatilhos de falha: ângulos pequenos entre vetores consecutivos.",
                                    "Discutir re-ortogonalização como mitigação parcial.",
                                    "Comparar sensibilidade com Gram-Schmidt modificado.",
                                    "Avaliar impacto em aplicações downstream como resolução de sistemas lineares."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito por que falha para κ(A) >> 1/ε.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Artigos sobre análise numérica QR (ex: Golub-Van Loan), software para bounds.",
                                  "tips": "Foquem em exemplos 3D para visualizar perda geométrica.",
                                  "learningObjective": "Quantificar quando e por que o processo falha numericamente.",
                                  "commonMistakes": "Atribuir falha só a produto interno, ignorando normalização."
                                }
                              ],
                              "practicalExample": "Considere a matriz A = [[1, 1, 1], [ε, ε+δ, ε+2δ], [ε^2, ε^2 + ε δ, ε^2 + 2 ε δ]] com ε=1e-8, δ=1e-16. Aplique Gram-Schmidt clássico: observe que q2 e q3 perdem ortogonalidade com q1, pois ||q1^T q2|| ≈ 1e-8 >> ε, devido a cancelamento na subtração.",
                              "finalVerifications": [
                                "Explicar o mecanismo de perda de ortogonalidade por cancelamento catastrófico.",
                                "Implementar e rodar exemplo numérico mostrando ||Q^T Q - I|| > 1e-10.",
                                "Identificar que falha ocorre quando tan(θ) < ε, com θ ângulo entre vetores.",
                                "Comparar erro com bound teórico O(κ^2 ε).",
                                "Propor pelo menos duas alternativas numéricamente estáveis (ex: Householder).",
                                "Discutir impacto em least squares: resíduos inflados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de erros de arredondamento (90% correto).",
                                "Correta implementação e interpretação de experimentos numéricos.",
                                "Quantificação adequada de sensibilidade via normas e cond(A).",
                                "Identificação clara de condições de falha.",
                                "Conexão teórica com aplicações práticas.",
                                "Uso correto de terminologia numérica (ε_machine, condicionamento)."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Estabilidade de algoritmos iterativos.",
                                "Programação Científica: Implementação em bibliotecas como LAPACK.",
                                "Física Computacional: Simulações com bases ortogonais (ex: FEM).",
                                "Estatística: Regressão linear via QR estável."
                              ],
                              "realWorldApplication": "Em solvers de equações diferenciais parciais (ex: CFD), onde QR é usada para preconditioning; perda de ortogonalidade causa instabilidade e erros acumulados em simulações de longa duração, como previsão climática ou design aerodinâmico."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.3.3",
                            "name": "Comparar com métodos modificados",
                            "description": "Discutir brevemente a necessidade do Gram-Schmidt modificado para maior estabilidade numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Gram-Schmidt Clássico e Seus Problemas Numéricos",
                                  "subSteps": [
                                    "Recordar os passos principais do algoritmo Gram-Schmidt clássico para ortogonalização de uma base.",
                                    "Identificar fontes de instabilidade, como acumulação de erros de arredondamento na subtração ortogonal.",
                                    "Analisar como a perda de ortogonalidade ocorre em matrizes il-condicionadas.",
                                    "Executar um exemplo numérico simples manualmente para visualizar o erro.",
                                    "Discutir o impacto na decomposição QR resultante."
                                  ],
                                  "verification": "Reproduzir o algoritmo clássico e listar pelo menos três problemas numéricos associados, com um exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas de aula sobre Gram-Schmidt, calculadora ou planilha para cálculos manuais",
                                  "tips": "Use aritmética de precisão finita simulada (ex: 4 dígitos decimais) para observar erros reais.",
                                  "learningObjective": "Compreender as limitações numéricas inerentes ao Gram-Schmidt clássico.",
                                  "commonMistakes": "Ignorar o efeito da ordem das colunas na perda de ortogonalidade; confundir erro de arredondamento com erro algébrico."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Gram-Schmidt Modificado",
                                  "subSteps": [
                                    "Descrever os passos do algoritmo Gram-Schmidt modificado, destacando a projeção reordenada.",
                                    "Comparar pseudocódigos lado a lado dos algoritmos clássico e modificado.",
                                    "Explicar matematicamente por que a modificação reduz a sensibilidade a erros de arredondamento.",
                                    "Implementar o algoritmo modificado em pseudocódigo.",
                                    "Testar com uma matriz 2x2 para validar ortogonalidade."
                                  ],
                                  "verification": "Escrever pseudocódigo correto do método modificado e demonstrar preservação de ortogonalidade em um teste simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta para pseudocódigo, acesso a documentação de álgebra linear numérica",
                                  "tips": "Sempre normalize após projeções para minimizar propagação de erros.",
                                  "learningObjective": "Dominar o algoritmo Gram-Schmidt modificado e suas diferenças fundamentais.",
                                  "commonMistakes": "Confundir a ordem de projeções no modificado; esquecer normalização em cada iteração."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Estabilidade Numérica dos Dois Métodos",
                                  "subSteps": [
                                    "Selecionar uma matriz de teste il-condicionada (ex: Vandermonde).",
                                    "Implementar ambos os métodos em software numérico (Python/NumPy).",
                                    "Calcular métricas de estabilidade: ||Q^T Q - I|| e condição da matriz Q.",
                                    "Analisar e tabular os resultados para diferentes tamanhos de matriz.",
                                    "Visualizar graficamente a perda de ortogonalidade."
                                  ],
                                  "verification": "Gerar uma tabela comparativa com métricas numéricas mostrando superioridade do modificado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy, Jupyter Notebook ou MATLAB",
                                  "tips": "Use np.linalg.norm para métricas precisas e compare com diferentes epsilons de máquina.",
                                  "learningObjective": "Realizar comparação quantitativa de estabilidade entre os métodos.",
                                  "commonMistakes": "Usar matrizes bem-condicionadas que mascaram diferenças; erros na implementação do clássico."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Necessidade e Implicações do Método Modificado",
                                  "subSteps": [
                                    "Resumir vantagens numéricas do modificado sobre o clássico.",
                                    "Identificar cenários onde o clássico é aceitável e onde o modificado é essencial.",
                                    "Referenciar implementações padrão como Householder ou Givens como alternativas.",
                                    "Conectar com aplicações em decomposição QR robusta.",
                                    "Escrever uma conclusão breve sobre a escolha do método."
                                  ],
                                  "verification": "Redigir um parágrafo explicando quando e por que usar o Gram-Schmidt modificado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Artigos ou livros sobre análise numérica (ex: Golub-Van Loan)",
                                  "tips": "Considere custo computacional: modificado é similar em complexidade O(n^2).",
                                  "learningObjective": "Avaliar criticamente a necessidade do método modificado em contextos práticos.",
                                  "commonMistakes": "Superestimar estabilidade do clássico; ignorar trade-offs computacionais."
                                }
                              ],
                              "practicalExample": "Considere a matriz A = [[1, 1, 1], [1, 1+ε, 1+2ε], [1, 1+ε, 1]] com ε=10^{-10}. No Gram-Schmidt clássico, a terceira coluna de Q perde ortogonalidade (||Q^T Q - I|| ≈ 10^{-8}), enquanto no modificado permanece <10^{-14}, preservando precisão em ponto flutuante duplo.",
                              "finalVerifications": [
                                "Explicar verbalmente a principal modificação e seu benefício numérico.",
                                "Demonstrar com código NumPy a diferença de estabilidade em uma matriz il-condicionada.",
                                "Identificar pelo menos dois cenários reais onde o clássico falha.",
                                "Citar uma referência bibliográfica sobre o tema.",
                                "Propor uma métrica personalizada para avaliar ortogonalidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na descrição dos algoritmos (20%).",
                                "Análise quantitativa correta de estabilidade (30%).",
                                "Clareza e profundidade na comparação (20%).",
                                "Uso adequado de exemplos numéricos (15%).",
                                "Conexões com implicações práticas (15%)."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Estudo de estabilidade e erros de arredondamento.",
                                "Programação Científica: Implementação eficiente em NumPy/SciPy.",
                                "Engenharia Computacional: Decomposições em simulações físicas.",
                                "Machine Learning: Pré-processamento de dados via QR para regressão."
                              ],
                              "realWorldApplication": "Em aplicações como resolução de sistemas lineares superdeterminados em processamento de imagens ou simulações climáticas, onde matrizes il-condicionadas são comuns, o Gram-Schmidt modificado garante precisão na fatoração QR, evitando amplificação de erros que poderia invalidar previsões ou reconstruções."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.4",
                    "name": "Refletores de Householder",
                    "description": "Transformações ortogonais para triangularizar matrizes e computar a fatoração QR de forma estável.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.4.1",
                        "name": "Definição e Propriedades dos Refletores de Householder",
                        "description": "Os refletores de Householder são transformações ortogonais definidas por H = I - 2uu^T / (u^T u), onde u é um vetor não nulo, que realizam reflexões sobre o hiperplano ortogonal a u, preservando normas e introduzindo zeros seletivamente em matrizes.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.1.1",
                            "name": "Reconhecer a forma matricial do refletor",
                            "description": "Identificar e escrever a matriz H = I - β uu^T, com β = 2 / (u^T u), e verificar suas propriedades algébricas básicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de refletor de Householder e o vetor u",
                                  "subSteps": [
                                    "Revise a definição de reflexão ortogonal em espaços vetoriais.",
                                    "Identifique o vetor u como u = x - αe, onde α = ||x|| e e é o vetor canônico.",
                                    "Entenda que o refletor reflete x sobre o hiperplano perpendicular a u.",
                                    "Esboce geometricamente a reflexão para um vetor em R²."
                                  ],
                                  "verification": "Desenhe o diagrama da reflexão e rotule u, x e o hiperplano corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora"
                                  ],
                                  "tips": "Visualize u como normal ao hiperplano de reflexão para fixar a intuição.",
                                  "learningObjective": "Entender o papel geométrico do vetor u na reflexão.",
                                  "commonMistakes": "Confundir u com o vetor a ser refletido; lembre que u é a direção da reflexão."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o escalar β",
                                  "subSteps": [
                                    "Calcule u^T u, o produto escalar de u consigo mesmo.",
                                    "Divida 2 por u^T u para obter β = 2 / (u^T u).",
                                    "Verifique se β é positivo e seu impacto na escala da projeção.",
                                    "Teste com um vetor u simples, como u = [1, 1]^T."
                                  ],
                                  "verification": "Confirme que β está correto comparando com cálculo manual.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Folha de exercícios"
                                  ],
                                  "tips": "Normalize u se possível para simplificar, mas use a fórmula exata.",
                                  "learningObjective": "Dominar o cálculo de β para normalizar a projeção.",
                                  "commonMistakes": "Esquecer o denominador u^T u ou inverter a divisão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a matriz H = I - β uu^T",
                                  "subSteps": [
                                    "Escreva a matriz identidade I do tamanho apropriado (ex: 2x2 ou 3x3).",
                                    "Calcule a matriz externa uu^T multiplicando u por u^T.",
                                    "Multiplique por β e subtraia de I para obter H.",
                                    "Escreva H explicitamente para um u dado."
                                  ],
                                  "verification": "Multiplique H por um vetor teste e veja se reflete corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software como Python/NumPy (opcional)"
                                  ],
                                  "tips": "Use notação matricial para evitar erros aritméticos em dimensões altas.",
                                  "learningObjective": "Construir a representação matricial explícita do refletor.",
                                  "commonMistakes": "Confundir uu^T com u u (escalar); é produto externo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar propriedades algébricas básicas de H",
                                  "subSteps": [
                                    "Calcule H^T e confirme que H é simétrica (H^T = H).",
                                    "Compute H² e verifique que H² = I.",
                                    "Verifique que det(H) = -1 ou 1 dependendo da paridade.",
                                    "Teste ortogonalidade: confirme que H preserva normas."
                                  ],
                                  "verification": "Todos os cálculos algébricos devem coincidir com as propriedades esperadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora matricial",
                                    "Python/MATLAB para verificação"
                                  ],
                                  "tips": "Use propriedades de uu^T para simplificar H² = I - 2β uu^T + β² (uu^T)^2.",
                                  "learningObjective": "Validar as propriedades essenciais do refletor.",
                                  "commonMistakes": "Erro em H² por não usar (uu^T)^2 = (u^T u) uu^T."
                                }
                              ],
                              "practicalExample": "Para u = [1, 1]^T em R²: u^T u = 2, β = 1, uu^T = [[1,1],[1,1]], H = [[1,0],[0,1]] - [[1,1],[1,1]] = [[0,-1],[-1,0]]. Verifique: H [1,0]^T = [-0,1]^T (reflexão sobre y=x).",
                              "finalVerifications": [
                                "Escreve corretamente H para qualquer u dado.",
                                "Calcula β sem erros aritméticos.",
                                "Demonstra H² = I manualmente.",
                                "Identifica H como simétrica e unitária.",
                                "Aplica H a um vetor e interpreta geometricamente.",
                                "Explica o papel de β na fórmula."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de uu^T e β (90% correto).",
                                "Correção das propriedades algébricas verificadas.",
                                "Explicação clara da geometria da reflexão.",
                                "Uso correto de notação matricial.",
                                "Identificação de erros comuns evitados.",
                                "Aplicação em exemplo numérico sem falhas."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar H em NumPy para decomposição QR.",
                                "Física: Modelar reflexões em ondas e óptica.",
                                "Computação Gráfica: Transformações de reflexão em gráficos 3D.",
                                "Estatística: Normalização em PCA via Householder."
                              ],
                              "realWorldApplication": "Refletores de Householder são fundamentais na decomposição QR estável numericamente, usada em solvers de sistemas lineares, otimização e machine learning para fatorar matrizes grandes com precisão."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.2",
                            "name": "Verificar ortogonalidade e simetria",
                            "description": "Demonstrar que H é ortogonal (H^T H = I) e simétrica (H = H^T), calculando explicitamente para vetores u unitários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definição e preparar vetor u unitário",
                                  "subSteps": [
                                    "Lembre a fórmula do refletor de Householder: H = I - 2 u u^T, onde u é um vetor coluna unitário (||u|| = 1).",
                                    "Escolha ou defina um vetor u e normalize-o: compute ||u|| = sqrt(u^T u) e u_normalized = u / ||u||.",
                                    "Escreva explicitamente I (matriz identidade do tamanho apropriado) e u u^T como produto externo.",
                                    "Confirme u^T u = 1 para garantir unitariedade."
                                  ],
                                  "verification": "Verifique que u^T u = 1 e escreva H explicitamente em termos matriciais.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora ou Python/MATLAB para normalização"
                                  ],
                                  "tips": "Sempre comece normalizando u para evitar erros de escala.",
                                  "learningObjective": "Compreender os pré-requisitos algébricos para manipular H.",
                                  "commonMistakes": [
                                    "Esquecer de normalizar u (u^T u ≠ 1)",
                                    "Confundir u u^T (matriz) com u^T u (escalar)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provar simetria: demonstrar H = H^T",
                                  "subSteps": [
                                    "Compute H^T = (I - 2 u u^T)^T = I^T - 2 (u u^T)^T.",
                                    "Note que I^T = I e (u u^T)^T = (u^T)^T u^T = u u^T (simetria do produto externo).",
                                    "Conclua H^T = I - 2 u u^T = H.",
                                    "Escreva a igualdade H = H^T explicitamente."
                                  ],
                                  "verification": "Mostre algebricamente que cada termo transposto retorna à forma original de H.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de álgebra linear para referência de propriedades de transposta"
                                  ],
                                  "tips": "Lembre que transposta de soma é soma de transpos tas e de produto é reverso.",
                                  "learningObjective": "Dominar propriedades de transposta para matrizes simétricas.",
                                  "commonMistakes": [
                                    "Errar a transposta de u u^T (deve ser u u^T, não u^T u)",
                                    "Ignorar o fator -2 na transposta"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar ortogonalidade: demonstrar H^T H = I",
                                  "subSteps": [
                                    "Como H é simétrica, H^T = H, então compute H H = (I - 2 u u^T)^2.",
                                    "Expanda: H^2 = I - 4 u u^T + 4 u u^T u u^T.",
                                    "Simplifique u u^T u u^T = u (u^T u) u^T = u (1) u^T = u u^T (pois u unitário).",
                                    "Resultado: H^2 = I - 4 u u^T + 4 u u^T = I."
                                  ],
                                  "verification": "Confirme que os termos -4 u u^T e +4 u u^T cancelam, deixando I.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software como Python (numpy) para testar expansão"
                                  ],
                                  "tips": "Substitua u^T u = 1 o mais cedo possível para simplificar.",
                                  "learningObjective": "Aplicar expansão quadrática e propriedades de unitariedade para ortogonalidade.",
                                  "commonMistakes": [
                                    "Esquecer u^T u = 1 no meio da expansão",
                                    "Expandir incorretamente (u u^T)^2 como u^2 (u^T)^2)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar numericamente e sintetizar propriedades",
                                  "subSteps": [
                                    "Escolha u = [1/sqrt(2), 1/sqrt(2)]^T em R^2 e compute H explicitamente.",
                                    "Calcule H^T H e verifique se resulta em I (com tolerância numérica ~1e-10).",
                                    "Confirme H = H^T numericamente comparando elementos.",
                                    "Discuta implicações: H é uma reflexão ortogonal preservando normas."
                                  ],
                                  "verification": "Matrices computadas satisfazem H = H^T e H^T H ≈ I.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Python com numpy ou MATLAB",
                                    "Calculadora matricial"
                                  ],
                                  "tips": "Use np.allclose() em Python para comparações numéricas.",
                                  "learningObjective": "Integrar prova algébrica com validação computacional.",
                                  "commonMistakes": [
                                    "Erros de arredondamento sem tolerância",
                                    "Não testar em dimensão baixa primeiro"
                                  ]
                                }
                              ],
                              "practicalExample": "Para u = [1/sqrt(2), 1/sqrt(2)]^T em R^2: u u^T = [[0.5, 0.5], [0.5, 0.5]], H = [[1,0],[0,1]] - 2*uu^T = [[0, -1], [-1, 0]]. Verifique H^T = H e H H = I.",
                              "finalVerifications": [
                                "H = H^T confirmado algebricamente e numericamente.",
                                "H^T H = I com expansão exata e exemplo numérico.",
                                "u unitário: u^T u = 1.",
                                "Todos elementos de H^T H iguais a I dentro de 1e-12.",
                                "Norma de colunas de H é 1.",
                                "H preserva norma de vetor teste: ||H v|| = ||v||."
                              ],
                              "assessmentCriteria": [
                                "Correção da prova algébrica de simetria (pontos por passos claros).",
                                "Expansão precisa de H^2 com simplificação usando u^T u =1.",
                                "Exemplo numérico correto com verificação matricial.",
                                "Identificação de erros comuns evitados.",
                                "Síntese clara das propriedades (ortogonal e simétrica).",
                                "Validação computacional com tolerância apropriada."
                              ],
                              "crossCurricularConnections": [
                                "Física: Reflexões especulares e preservação de comprimento (mecânica quântica).",
                                "Computação: Estabilidade numérica em algoritmos QR.",
                                "Estatística: Transformações ortogonais em PCA.",
                                "Engenharia: Processamento de sinais com filtros ortogonais."
                              ],
                              "realWorldApplication": "Refletores de Householder são usados na decomposição QR para resolver sistemas lineares Ax=b de forma numéricamente estável, em aplicações como machine learning (regressão), simulações físicas e otimização."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.3",
                            "name": "Aplicar refletor a um vetor simples",
                            "description": "Computar Hx para um vetor x dado, interpretando geometricamente como reflexão sobre o hiperplano perpendicular a u.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir e normalizar o vetor u",
                                  "subSteps": [
                                    "Identifique o vetor u fornecido, que define o hiperplano perpendicular.",
                                    "Calcule a norma euclidiana de u usando ||u|| = sqrt(u^T u).",
                                    "Crie o vetor unitário û = u / ||u||.",
                                    "Verifique se ||û|| = 1 para confirmar normalização.",
                                    "Anote os componentes de û para uso posterior."
                                  ],
                                  "verification": "Confirme que a soma dos quadrados dos componentes de û é aproximadamente 1 (erro numérico aceitável < 10^-10).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora ou Python com NumPy"
                                  ],
                                  "tips": "Use frações exatas quando possível para evitar erros de arredondamento.",
                                  "learningObjective": "Compreender a importância da normalização para a fórmula do refletor.",
                                  "commonMistakes": [
                                    "Esquecer de dividir por ||u||",
                                    "Confundir norma L1 com L2"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz refletora H",
                                  "subSteps": [
                                    "Calcule o termo escalar beta = 2 / (û^T û), que é sempre 2 pois û é unitário.",
                                    "Compute o produto externo uu^T substituindo u por û (matriz rank-1).",
                                    "Multiplique por beta: H = I - beta * û û^T, onde I é a matriz identidade do tamanho apropriado.",
                                    "Escreva explicitamente os elementos de H para dimensões baixas (ex: 2x2 ou 3x3).",
                                    "Verifique se H é simétrica: H^T = H."
                                  ],
                                  "verification": "Confirme H * û = -û (reflexão de u em si mesmo) e trace(H) = n-2 para dimensão n.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software como MATLAB ou Jupyter Notebook"
                                  ],
                                  "tips": "Para vetores pequenos, compute manualmente; para maiores, use código vetorizado.",
                                  "learningObjective": "Dominar a construção explícita da matriz Householder.",
                                  "commonMistakes": [
                                    "Usar u não normalizado diretamente",
                                    "Erro no sinal: usar + em vez de -"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o refletor ao vetor x: calcular Hx",
                                  "subSteps": [
                                    "Escreva o vetor x dado.",
                                    "Compute o produto escalar alpha = û^T x.",
                                    "Calcule Hx = x - beta * alpha * û (fórmula otimizada rank-1 update).",
                                    "Alternativamente, faça multiplicação matricial completa H * x e compare resultados.",
                                    "Arredonde se necessário, mas mantenha precisão.",
                                    "Registre o vetor resultante Hx."
                                  ],
                                  "verification": "Verifique ||Hx|| ≈ ||x|| (preserva norma) e û^T Hx ≈ - û^T x (componente oposta).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora gráfica",
                                    "Python com NumPy para validação"
                                  ],
                                  "tips": "Sempre prefira a forma rank-1 para eficiência computacional.",
                                  "learningObjective": "Aplicar eficientemente a transformação de reflexão sem multiplicação completa.",
                                  "commonMistakes": [
                                    "Multiplicar matriz-vetor incorretamente",
                                    "Esquecer o fator beta"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar geometricamente o resultado",
                                  "subSteps": [
                                    "Desenhe o hiperplano perpendicular a u.",
                                    "Projete x no hiperplano e na direção de u.",
                                    "A reflexão Hx deve ter a projeção na direção u invertida, mantendo a componente no hiperplano.",
                                    "Meça ângulos: ângulo entre x e u deve igualar entre Hx e u, mas lados opostos.",
                                    "Confirme que o ponto médio de x e Hx está no hiperplano."
                                  ],
                                  "verification": "Visualize ou compute: (x + Hx)/2 perpendicular a u, i.e., û^T (x + Hx) = 0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado para desenho",
                                    "GeoGebra ou Desmos para visualização 2D/3D"
                                  ],
                                  "tips": "Comece em 2D para intuição antes de generalizar para dimensões maiores.",
                                  "learningObjective": "Conectar cálculo algébrico com interpretação geométrica da reflexão.",
                                  "commonMistakes": [
                                    "Confundir reflexão com projeção",
                                    "Ignorar a inversão apenas na direção normal"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere R^2 com u = [1, 1]^T e x = [1, 0]^T. Norma ||u|| = sqrt(2), û = [1/sqrt(2), 1/sqrt(2)]^T. beta=2. H = I - 2 û û^T = [[0, -1], [-1, 0]]. Então Hx = [0, -1]^T. Geometricamente, reflete x sobre a linha y=x, invertendo a componente perpendicular.",
                              "finalVerifications": [
                                "||Hx|| = ||x|| com tolerância 10^-10.",
                                "û^T Hx = - û^T x.",
                                "(x + Hx)/2 perpendicular a û: û^T (x + Hx) = 0.",
                                "H é simétrica e H^2 = I.",
                                "Hx ≠ x a menos que x perpendicular a u.",
                                "Componente paralela a u é invertida na reflexão."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica no cálculo de Hx (erro < 10^-8).",
                                "Correta normalização de u.",
                                "Uso eficiente da atualização rank-1.",
                                "Interpretação geométrica precisa com diagrama.",
                                "Verificação de propriedades (unitariedade, simetria).",
                                "Explicação clara da reflexão como operação ortogonal."
                              ],
                              "crossCurricularConnections": [
                                "Física: Reflexões em óptica e mecânica (lei de reflexão).",
                                "Computação: Algoritmos numéricos para decomposição QR e eigenvalores.",
                                "Gráficos Computacionais: Transformações lineares em rendering 3D.",
                                "Estatística: Análise de componentes principais via Householder.",
                                "Engenharia: Processamento de sinais e filtros adaptativos."
                              ],
                              "realWorldApplication": "Refletores de Householder são fundamentais na decomposição QR para resolver sistemas lineares Ax=b numericamente estáveis, usados em machine learning (ex: SVD em PCA), simulações físicas (dinâmica molecular) e compressão de imagens."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.2",
                        "name": "Construção do Refletor de Householder para um Vetor",
                        "description": "Dado um vetor x ∈ ℝ^n, construir u = x ± α e_1, com α = ±||x||_2 (escolha de sinal para estabilidade), de modo que Hx seja múltiplo do primeiro vetor canônico, zerando os componentes subsequentes.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.2.1",
                            "name": "Calcular o vetor u normalizado",
                            "description": "Dado x, computar σ = sign(x_1) ||x||_2, u = x - σ e_1, e β = 2 / (u^T u), evitando cancelamento numérico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular a norma euclidiana L2 do vetor x",
                                  "subSteps": [
                                    "Identifique todas as componentes do vetor x = [x₁, x₂, ..., xₙ]ᵀ.",
                                    "Compute a soma dos quadrados: ∑(xᵢ²) para i=1 até n.",
                                    "Aplique a raiz quadrada: ||x||₂ = √(∑(xᵢ²)).",
                                    "Verifique numericamente usando uma função de norma se disponível.",
                                    "Registre o valor com precisão adequada (ex: 10 casas decimais)."
                                  ],
                                  "verification": "Confirme que ||x||₂² ≈ ∑(xᵢ²) dentro de tolerância 1e-10.",
                                  "estimatedTime": "3 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Papel e lápis",
                                    "Software como Python/NumPy (opcional)"
                                  ],
                                  "tips": "Para vetores grandes, use funções built-in para evitar overflow em somas de quadrados.",
                                  "learningObjective": "Dominar o cálculo preciso da norma L2, base para normalizações.",
                                  "commonMistakes": "Esquecer a raiz quadrada ou usar norma L1 (soma absoluta) por engano."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar o escalar σ com sinal correto",
                                  "subSteps": [
                                    "Extraia a primeira componente x₁ do vetor x.",
                                    "Determine o sinal: sign(x₁) = 1 se x₁ ≥ 0, -1 se x₁ < 0.",
                                    "Multiplique: σ = sign(x₁) × ||x||₂.",
                                    "Confirme que |σ| = ||x||₂.",
                                    "Anote σ com o mesmo nível de precisão de ||x||₂."
                                  ],
                                  "verification": "Verifique sign(σ) = sign(x₁) e |σ| = ||x||₂.",
                                  "estimatedTime": "2 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Papel e lápis"
                                  ],
                                  "tips": "O sinal garante que u₁ seja pequeno, evitando cancelamento numérico.",
                                  "learningObjective": "Compreender a escolha de σ para estabilidade numérica.",
                                  "commonMistakes": "Usar abs(x₁) em vez de sign(x₁), perdendo o ajuste de sinal."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o vetor e₁ e calcular u = x - σ e₁",
                                  "subSteps": [
                                    "Defina e₁ como vetor com 1 na primeira posição e zeros nas demais: e₁ = [1, 0, ..., 0]ᵀ.",
                                    "Compute σ e₁ (multiplicação escalar-vetor).",
                                    "Subtraia componente a componente: uᵢ = xᵢ - σ δ_{i1}, onde δ é delta de Kronecker.",
                                    "Verifique que u₁ ≈ 0 ou muito pequeno.",
                                    "Armazene u com precisão floating-point dupla."
                                  ],
                                  "verification": "|u₁| << |x₁| (tipicamente < 1e-10 × ||x||₂).",
                                  "estimatedTime": "4 minutos",
                                  "materials": [
                                    "Calculadora ou software vetorial (MATLAB/Python)",
                                    "Papel para vetores pequenos"
                                  ],
                                  "tips": "Implemente como u = x.copy(); u[0] -= sigma para eficiência.",
                                  "learningObjective": "Aplicar subtração vetorial para formar u estável.",
                                  "commonMistakes": "Erro no índice de e₁ (começa em 1, não 0 em algumas linguagens)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular β = 2 / (uᵀ u)",
                                  "subSteps": [
                                    "Compute o produto escalar uᵀ u = ∑(uᵢ²).",
                                    "Verifique que uᵀ u > 0 e estável (não próximo de zero).",
                                    "Calcule β = 2 / (uᵀ u).",
                                    "Confirme β > 0.",
                                    "Teste a normalização implícita: β (uᵀ u) / 2 ≈ 1."
                                  ],
                                  "verification": "β × (uᵀ u) = 2 dentro de tolerância numérica.",
                                  "estimatedTime": "3 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Software para produto escalar"
                                  ],
                                  "tips": "uᵀ u é sempre positivo por construção de σ.",
                                  "learningObjective": "Finalizar a normalização escalar β para o refletor.",
                                  "commonMistakes": "Dividir por ||u||₂² diretamente sem o 2, ou usar norma L1."
                                }
                              ],
                              "practicalExample": "Para x = [1.0, 1.0, 1.0]ᵀ: ||x||₂ = √3 ≈ 1.732, sign(1)=1, σ=1.732, e₁=[1,0,0]ᵀ, u=[1-1.732,1,1]ᵀ≈[-0.732,1,1]ᵀ, uᵀu≈0.536+1+1=2.536, β=2/2.536≈0.788. Verifique: u normalizado implicitamente via β.",
                              "finalVerifications": [
                                "sign(σ) = sign(x₁) e |σ| = ||x||₂.",
                                "|u₁| é pequeno (evita cancelamento: |u₁| / ||x||₂ < 1e-10).",
                                "uᵀ u > 0 e β > 0.",
                                "Recupere x ≈ u + σ e₁.",
                                "||u||₂ = √(2/β) implicitamente.",
                                "Teste numérico: aplique refletor H = I - β u uᵀ em x dá e₁ ||x||₂."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erros relativos < 1e-12.",
                                "Correção do sinal em σ.",
                                "Estabilidade: |u₁| pequeno comparado a ||x||₂.",
                                "Eficiência computacional no cálculo de normas e produtos.",
                                "Ausência de divisão por zero ou overflow/underflow.",
                                "Implementação correta em código (se aplicável)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em NumPy/MATLAB para vetores grandes.",
                                "Física: Normas de vetores em mecânica quântica e eletromagnetismo.",
                                "Estatística: Normalização em análise de dados multivariados.",
                                "Ciência da Computação: Otimização numérica em machine learning (PCA)."
                              ],
                              "realWorldApplication": "Essencial na decomposição QR estável para resolver sistemas lineares Ax=b em engenharia (simulações CFD), compressão de imagens (JPEG) e aprendizado de máquina (redução de dimensionalidade), evitando erros numéricos em computadores finitos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.2.2",
                            "name": "Formar a matriz H explícita",
                            "description": "Montar H = I - β uu^T para dimensão pequena (n≤4) e verificar que Hx = σ e_1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os componentes necessários para a matriz H",
                                  "subSteps": [
                                    "Identifique a dimensão n (≤4) e o vetor x dado.",
                                    "Confirme os valores de σ (normalmente ±||x||), u = x - σ e_1 e β = 2 / (u^T u).",
                                    "Construa a matriz identidade I de tamanho n x n.",
                                    "Escreva explicitamente o vetor coluna u como uma matriz n x 1.",
                                    "Verifique que ||u|| ≠ 0 para evitar divisão por zero."
                                  ],
                                  "verification": "Todos os componentes (I, u, β, σ, e_1) estão listados corretamente e numericamente precisos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora ou Python/NumPy para verificação opcional"
                                  ],
                                  "tips": "Use frações exatas para evitar erros de arredondamento em cálculos manuais.",
                                  "learningObjective": "Entender e preparar os pré-requisitos exatos para formar H.",
                                  "commonMistakes": [
                                    "Confundir σ com ||x|| sem sinal",
                                    "Esquecer de normalizar u corretamente",
                                    "Erro na construção de I (diagonal não unitária)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o produto externo uu^T",
                                  "subSteps": [
                                    "Transpose u para obter u^T (linha 1 x n).",
                                    "Multiplique u (coluna n x 1) por u^T (linha 1 x n) para formar matriz n x n.",
                                    "Calcule cada entrada (i,j) como u_i * u_j.",
                                    "Verifique simetria: (uu^T)^T = uu^T.",
                                    "Anote a matriz uu^T explicitamente com valores numéricos."
                                  ],
                                  "verification": "A matriz uu^T é simétrica e cada entrada corresponde a u_i * u_j.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora"
                                  ],
                                  "tips": "Para n=3 ou 4, tabule os produtos em uma grade para evitar confusão.",
                                  "learningObjective": "Dominar o cálculo de produtos externos para formar rank-1 updates.",
                                  "commonMistakes": [
                                    "Confundir u u^T com u^T u (escalar)",
                                    "Erros aritméticos em multiplicações cruzadas",
                                    "Não verificar simetria"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escalonar uu^T por β e subtrair de I para obter H",
                                  "subSteps": [
                                    "Multiplique cada entrada de uu^T por β para obter β uu^T.",
                                    "Subtraia β uu^T de I entrada por entrada: H_{ii} = 1 - β u_i^2, H_{ij} = -β u_i u_j para i≠j.",
                                    "Escreva a matriz H completa numericamente.",
                                    "Confirme que a diagonal é 1 - β u_i^2 e off-diagonal -β u_i u_j.",
                                    "Verifique se H é simétrica."
                                  ],
                                  "verification": "H = I - β uu^T elemento a elemento, e H é simétrica.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora"
                                  ],
                                  "tips": "Mantenha traços decimais consistentes ou use frações para exatidão.",
                                  "learningObjective": "Executar a operação rank-1 update corretamente para formar H.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo em off-diagonais",
                                    "Erro em subtração na diagonal",
                                    "Perder simetria por cálculo errado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar que Hx = σ e_1",
                                  "subSteps": [
                                    "Multiplique H (n x n) por x (n x 1) para obter vetor resultado.",
                                    "Calcule cada componente do produto matricial.",
                                    "Forme σ e_1 explicitamente (e_1 tem 1 na primeira posição, zeros depois).",
                                    "Compare o resultado com σ e_1 componente por componente.",
                                    "Confirme propriedades adicionais: H é ortogonal (H^T H = I) se possível."
                                  ],
                                  "verification": "Hx = σ e_1 exatamente, com todas as componentes iguais.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora ou Python para validação"
                                  ],
                                  "tips": "Pela construção, Hx deve mapear x para o eixo e_1; use isso para debug.",
                                  "learningObjective": "Validar a construção do refletor Householder numericamente.",
                                  "commonMistakes": [
                                    "Erro na multiplicação matricial",
                                    "Confundir ordem de multiplicação",
                                    "Ignorar discrepâncias por arredondamento"
                                  ]
                                }
                              ],
                              "practicalExample": "Para n=3, x = [3, 4, 0]^T, ||x||=5, tome σ=-5, e_1=[1,0,0]^T. Então u=[8,4,0]^T, ||u||^2=80, β=2/80=0.025. uu^T = [[64,32,0],[32,16,0],[0,0,0]], β uu^T ≈ [[1.6,0.8,0],[0.8,0.4,0],[0,0,0]], H = [[-0.6,-0.8,0],[-0.8,0.6,0],[0,0,1]]. Verifique Hx = [-5,0,0]^T.",
                              "finalVerifications": [
                                "H é simétrica (H = H^T).",
                                "Hx = σ e_1 exatamente.",
                                "H é idempotente ou H^2 ≈ I (propriedade de refletor).",
                                "Traço de H = n - β ||u||^2 = n - 2.",
                                "Off-diagonais H_{ij} = -β u_i u_j para i≠j.",
                                "Hx ⊥ u (dot product zero, propriedade intrínseca)."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica em todos os cálculos (erro < 10^{-3}).",
                                "Correta formação de uu^T e escalonamento por β.",
                                "Verificação Hx = σ e_1 sem discrepâncias.",
                                "Identificação de simetria e propriedades de H.",
                                "Eficiência no uso de tempo e materiais.",
                                "Explicação clara de cada passo se questionado."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em NumPy/Python para n grande.",
                                "Física: Refletores em óptica e mecânica quântica.",
                                "Computação Científica: Passo chave na decomposição QR.",
                                "Estatística: Projeções em análise de dados multivariados."
                              ],
                              "realWorldApplication": "Usado em decomposições QR para resolver sistemas lineares estáveis numericamente em software como MATLAB ou bibliotecas LAPACK, essenciais em machine learning (ex: PCA), simulações físicas e processamento de imagens."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.2.3",
                            "name": "Aplicar H por multiplicação otimizada",
                            "description": "Implementar aplicação de H a vetores ou matrizes sem formar H explicitamente, usando y = x - β (u^T x) u para eficiência O(n).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a fórmula otimizada de aplicação do refletor H",
                                  "subSteps": [
                                    "Revise a definição do refletor de Householder: H = I - β u u^T, onde β = 2 / (u^T u) e ||u||=1 opcionalmente.",
                                    "Derive a fórmula de multiplicação: Hx = x - β (u^T x) u, evitando formação explícita de H (O(n^2) para O(n)).",
                                    "Identifique os componentes: vetor u normalizado ou não, escalar β pré-computado.",
                                    "Calcule manualmente u^T x para um vetor simples.",
                                    "Verifique propriedades: H é simétrico, H^2 = I, u é autovetor com autovalor -1."
                                  ],
                                  "verification": "Resuma a fórmula em suas palavras e comprove Hx ≈ x - β (u^T x) u para um exemplo 2D.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, lápis, calculadora ou software simbólico como SymPy.",
                                  "tips": "Sempre normalize u para evitar erros numéricos em β.",
                                  "learningObjective": "Entender matematicamente por que a multiplicação é O(n) em vez de O(n^2).",
                                  "commonMistakes": "Confundir β com 1/(u^T u); esquecer que u pode não ser unitário."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar aplicação de H a um vetor único",
                                  "subSteps": [
                                    "Defina funções para computar u^T x (produto escalar).",
                                    "Implemente a subtração: y = x - β * (u^T x) * u.",
                                    "Teste com vetor x = [5, 12]^T, u = [-8/13, 12/13]^T (unitário), β=2, espere y ≈ [13, 0]^T.",
                                    "Repita para vetor 3D: x = [1,1,1]^T, u = [1-√3,1,1]/norm.",
                                    "Meça tempo de execução para n=1000 vs. multiplicação explícita Hx."
                                  ],
                                  "verification": "Compare y com H explícito (I - β u u^T) x; erro < 1e-10.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com NumPy ou MATLAB.",
                                  "tips": "Use operações vetorizadas para eficiência.",
                                  "learningObjective": "Codificar a multiplicação vetor-vetor de forma eficiente e precisa.",
                                  "commonMistakes": "Erro de sinal em β ou na subtração; não escalar corretamente u^T x."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estender para aplicação de H a uma matriz A",
                                  "subSteps": [
                                    "Aplique H a cada coluna de A: para j=1 a m, A[:,j] = H * A[:,j].",
                                    "Implemente loop ou vetorizado: Hy = Y - β (U^T Y), onde Y=A colunas.",
                                    "Exemplo: A 3x2 com colunas [3,4; 4,3; 0,0], aplique H para primeira coluna.",
                                    "Otimize para BLAS-like: u^T A é linha vetor, depois outer product escalado.",
                                    "Teste para A identidade, verifique HA ≈ A se u=0."
                                  ],
                                  "verification": "||HA - H_explicito * A|| < 1e-12; complexidade O(n m) com m colunas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python/NumPy, timer de performance.",
                                  "tips": "Evite loops internos; use dot products vetorizados.",
                                  "learningObjective": "Generalizar para matrizes, mantendo eficiência O(n^2) total para n x n.",
                                  "commonMistakes": "Aplicar errado às linhas em vez de colunas; overflow em grandes n."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar, testar e otimizar a implementação",
                                  "subSteps": [
                                    "Compare com biblioteca (scipy.linalg.householder? ou QR steps).",
                                    "Teste casos edge: u=0, x paralelo a u, n=1.",
                                    "Analise estabilidade numérica: cond(H)=1, mas roundoff em β grande.",
                                    "Profile performance: n=1e3 a 1e5, confirme O(n).",
                                    "Adicione docstring e unit tests para reutilização."
                                  ],
                                  "verification": "Todos testes passam; speedup >10x vs. explícito para n>100.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Jupyter notebook, pytest ou unittest.",
                                  "tips": "Use np.allclose para comparações flutuantes.",
                                  "learningObjective": "Garantir robustez e eficiência na prática computacional.",
                                  "commonMistakes": "Ignorar normalização de u levando a ill-conditioning; testes insuficientes."
                                }
                              ],
                              "practicalExample": "Para x = [5, 12]^T, u = [-8/13, 12/13]^T (||u||=1), β=2: u^T x = -8/13*5 + 12/13*12 = 64/13, y = [5,12] - 2*(64/13)*[-8/13,12/13] ≈ [13, 0]^T. Para matriz A = [[5,1],[12,2],[0,3]], HA tem primeira coluna [13,0,0]^T.",
                              "finalVerifications": [
                                "Hx ⊥ u (u^T Hx = 0).",
                                "||Hx|| = ||x|| (preserva norma).",
                                "H^2 x = x (idempotente).",
                                "Erro relativo ||Hx_otimiz - Hx_expl|| / ||x|| < 1e-12.",
                                "Tempo O(n) confirmado por benchmark.",
                                "Funciona para n=1 até 1e6 sem crash."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática: fórmula aplicada sem erros.",
                                "Eficiência: complexidade temporal O(n) ou O(n m).",
                                "Precisão numérica: erro < máquina epsilon.",
                                "Robustez: lida com casos degenerados (u=0, n=1).",
                                "Clareza código: comentado, vetorizado.",
                                "Performance: speedup mensurável vs. explícito."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Otimização de algoritmos numéricos (NumPy, BLAS).",
                                "Física: Refleções em mecânica quântica ou óptica.",
                                "Ciência de Dados: Pré-processamento em PCA ou SVD.",
                                "Engenharia: Solvers lineares em simulações FEM."
                              ],
                              "realWorldApplication": "Essencial no algoritmo QR para decomposição de matrizes em solvers de sistemas lineares (ex: Google PageRank), compressão de sinais em áudio/imagens (JPEG2000), e machine learning (redução de dimensionalidade via eigen decomposições estáveis)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1.3"
                            ]
                          },
                          {
                            "id": "10.1.3.4.2.4",
                            "name": "Escolha de sinal para estabilidade numérica",
                            "description": "Explicar e justificar a escolha σ = -sign(x_1) ||x||_2 para maximizar ||u||_2 e evitar subtração catastrófica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o contexto do refletor de Householder e o vetor u",
                                  "subSteps": [
                                    "Revise a definição do refletor de Householder: H = I - 2uu^T / ||u||^2, onde u = x - σ e_1 e σ = ± ||x||_2.",
                                    "Identifique que o objetivo é mapear x para um múltiplo de e_1, preservando a norma.",
                                    "Explique por que u deve ser escolhido para evitar perda de precisão numérica.",
                                    "Discuta o papel de σ na subtração x - σ e_1.",
                                    "Calcule ||u||_2^2 = ||x||_2^2 + σ^2 - 2 σ x_1 para entender a dependência em x_1."
                                  ],
                                  "verification": "Escreva a fórmula de u e explique verbalmente o risco de cancelamento numérico.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Calculadora ou software como MATLAB/Python para normas"
                                  ],
                                  "tips": "Desenhe vetores x e e_1 graficamente para visualizar a reflexão.",
                                  "learningObjective": "Compreender a construção básica de u no refletor de Householder.",
                                  "commonMistakes": "Confundir σ com ||x||_2 diretamente sem considerar o sinal; ignorar que ||u||_2 depende do sinal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o problema de subtração catastrófica",
                                  "subSteps": [
                                    "Defina subtração catastrófica: perda de dígitos significativos quando subtraindo números próximos.",
                                    "Mostre que se sign(σ) = sign(x_1), então |x_1 - σ| é pequeno se x_1 ≈ ||x||_2.",
                                    "Calcule um exemplo numérico com x = [1-ε, δ]^T onde ε pequeno, mostrando perda de precisão.",
                                    "Explique impacto: u_1 pequeno leva a ||u||_2 subestimado e instabilidade em H.",
                                    "Compare com precisão em aritmética exata vs. flutuante."
                                  ],
                                  "verification": "Simule subtração em Python/MATLAB com máquina de ponto flutuante e observe perda de precisão.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Python ou MATLAB com numpy",
                                    "Exemplo numérico impresso"
                                  ],
                                  "tips": "Use eps (machine epsilon) para quantificar o erro.",
                                  "learningObjective": "Reconhecer quando e por que ocorre cancelamento numérico em u_1.",
                                  "commonMistakes": "Achar que subtração sempre causa problema; não diferenciar sinais opostos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a norma euclidiana ||x||_2 e sign(x_1)",
                                  "subSteps": [
                                    "Lembre a fórmula ||x||_2 = sqrt(∑ x_i^2), computada de forma estável (sem sqrt inicial).",
                                    "Extraia x_1, o primeiro componente de x.",
                                    "Determine sign(x_1): 1 se x_1 > 0, -1 se x_1 < 0, 0 se x_1 = 0 (raro).",
                                    "Defina σ_candidato = ||x||_2.",
                                    "Discuta por que computar ||x||_2 primeiro é estável (soma de quadrados positiva)."
                                  ],
                                  "verification": "Implemente função para calcular ||x||_2 e sign(x_1) para vetor teste.",
                                  "estimatedTime": "15 minutes",
                                  "materials": [
                                    "Código Python/MATLAB pronto",
                                    "Vetor exemplo x = [0.8, 0.6]^T"
                                  ],
                                  "tips": "Evite sqrt desnecessário; use hypot em linguagens para estabilidade.",
                                  "learningObjective": "Dominar cálculo preciso de componentes chave para σ.",
                                  "commonMistakes": "Usar norma L1 ou L∞ por engano; tratar x_1=0 sem cuidado."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar a escolha σ = -sign(x_1) ||x||_2",
                                  "subSteps": [
                                    "Mostre que σ = -sign(x_1) ||x||_2 faz sign(σ) oposto a sign(x_1), maximizando |x_1 - σ| ≈ 2 ||x||_2.",
                                    "Derive ||u||_2^2 = 2(||x||_2^2 - sign(x_1) x_1 ||x||_2) e prove que é maximizado.",
                                    "Calcule u_1 = x_1 - σ = x_1 + sign(x_1) ||x||_2 ≈ 2 |x_1| se x_1 dominante.",
                                    "Verifique que ||u||_2 = sqrt(2(||x||_2 - |x_1|)) ||x||_2, evitando cancelamento.",
                                    "Confirme que isso minimiza erro relativo em ||u||_2."
                                  ],
                                  "verification": "Compare ||u||_2 para ambos sinais em exemplo numérico e meça erro.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Papel para derivação",
                                    "Software para validação numérica"
                                  ],
                                  "tips": "Assuma x_1 dominante para intuição: σ oposto cancela menos.",
                                  "learningObjective": "Explicar matematicamente por que essa escolha garante estabilidade.",
                                  "commonMistakes": "Escolher σ = +||x||_2 sempre; confundir maximização de ||u||_2 com minimização."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e verificar a escolha em um refletor completo",
                                  "subSteps": [
                                    "Construa u completo: u = x - σ e_1.",
                                    "Normalize para v = u / ||u||_2 e forme H.",
                                    "Teste Hx = σ e_1.",
                                    "Compare estabilidade com escolha errada via cond(H) ou erro em decomposição QR.",
                                    "Documente a justificativa em pseudocódigo."
                                  ],
                                  "verification": "Execute código de Householder com ambas escolhas e compare resíduos ||Hx - σ e_1||.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Implementação de Householder em Python/MATLAB"
                                  ],
                                  "tips": "Use vetores com componentes desiguais para realçar diferença.",
                                  "learningObjective": "Integrar a escolha de sinal em algoritmo completo e validar.",
                                  "commonMistakes": "Esquecer normalizar u; não testar com x_1 próximo a ||x||_2."
                                }
                              ],
                              "practicalExample": "Para x = [0.9, 0.435889894354][T] (onde ||x||_2 ≈1), sign(x_1)=1, σ=-1. Se σ=+1, u_1=0.9-1=-0.1 (cancelamento); com σ=-1, u_1=0.9-(-1)=1.9 (estável). ||u||_2 ≈1.9 vs. pequeno.",
                              "finalVerifications": [
                                "Calcule σ corretamente para 3 vetores teste variados.",
                                "Demonstre ausência de cancelamento em u_1 para x_1 dominante.",
                                "Mostre ||u||_2 maximizado comparado à escolha oposta.",
                                "Implemente em código e verifique Hx = σ e_1 com erro <1e-12.",
                                "Explique verbalmente a justificativa em 1 minuto.",
                                "Compare erros numéricos em QR parcial com bibliotecas padrão."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de ||u||_2^2 e maximização.",
                                "Identificação correta de subtração catastrófica com exemplo.",
                                "Implementação numérica estável sem erros de sinal.",
                                "Explicação clara da escolha σ = -sign(x_1) ||x||_2.",
                                "Validação com testes que mostram superioridade numérica.",
                                "Uso correto de normas e signs em código."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Estabilidade de algoritmos e análise de erro.",
                                "Programação Computacional: Implementação em NumPy/SciPy para QR.",
                                "Física Computacional: Simulações estáveis em mecânica quântica.",
                                "Estatística: Decomposições em PCA e regressão robusta."
                              ],
                              "realWorldApplication": "Em decomposição QR estável para resolução de sistemas lineares em engenharia (ex: simulações CFD), evitando acumulação de erros em grandes matrizes, como em software NASA ou bibliotecas LAPACK."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.3",
                        "name": "Triangularização QR usando Refletores de Householder",
                        "description": "Aplicar refletores sequencialmente nas colunas de A para obter Q^T A = R triangular superior, com Q ortogonal, garantindo estabilidade numérica superior a Gram-Schmidt.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.3.1",
                            "name": "Descrever o algoritmo Householder QR",
                            "description": "Explicar os passos: para k=1 a m-1, construir H_k para zerar abaixo da diagonal na coluna k, aplicar à submatriz restante.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Refletor de Householder",
                                  "subSteps": [
                                    "Defina um refletor de Householder como H = I - 2uu^T / ||u||^2, onde u é um vetor não nulo.",
                                    "Explique que H é simétrico, ortogonal (H^T H = I) e envolve uma reflexão sobre o hiperplano perpendicular a u.",
                                    "Discuta como Hx reflete o vetor x sobre esse hiperplano.",
                                    "Revise a propriedade chave: Hv = v - 2 proj_u v, permitindo zerar componentes específicas."
                                  ],
                                  "verification": "Escreva a fórmula de H e prove que H^2 = I manualmente para um vetor u simples (ex: u=[1,1]^T).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora ou software simbólico como SymPy"
                                  ],
                                  "tips": "Visualize geometricamente: desenhe vetores em 2D para intuitivamente entender a reflexão.",
                                  "learningObjective": "Dominar a definição matemática e propriedades geométricas do refletor de Householder.",
                                  "commonMistakes": "Confundir com rotação (Householder é reflexão); esquecer normalização de u."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o Vetor Householder para uma Coluna",
                                  "subSteps": [
                                    "Para uma subcoluna x = A(k+1:m, k), defina sigma = sign(x1) ||x|| para escolher o sinal.",
                                    "Compute u1 = x1 + sigma, ui = xi para i>1, então u = [u1; u2:...;um-k]/||u|| (normalizar).",
                                    "Verifique que Hu1 = -sigma e Hui=0 para i>1, zerando abaixo da diagonal.",
                                    "Ajuste para evitar cancelamento numérico usando o sinal de x1."
                                  ],
                                  "verification": "Para x=[3,4]^T, compute u e H explicitamente e aplique Hx para confirmar zeros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Python com NumPy para verificação numérica"
                                  ],
                                  "tips": "Sempre escolha o sinal para maximizar |x1 + sigma| e evitar subtração catastrófica.",
                                  "learningObjective": "Saber construir u_k para introduzir exatamente um zero abaixo da diagonal na posição (k+1,k).",
                                  "commonMistakes": "Esquecer de normalizar u; escolher sinal errado levando a instabilidade numérica."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o Refletor à Submatriz Restante",
                                  "subSteps": [
                                    "Aplique H_k à submatriz A(k:m, k:n) pela esquerda: A(k:m, k:n) := H_k A(k:m, k:n).",
                                    "Note que isso preserva os zeros já introduzidos nas colunas anteriores.",
                                    "Atualize também Q se rastreando a decomposição completa (Q := Q H_k).",
                                    "Eficiência: O(n^2) operações por k, total O(m n^2 - n^3/3)."
                                  ],
                                  "verification": "Implemente em código para uma matriz 4x3 e verifique que apenas a subcoluna k tem zero em (k+1,k).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python/Jupyter Notebook com NumPy",
                                    "Matriz de exemplo impressa"
                                  ],
                                  "tips": "Armazene H_k implicitamente via u_k para economizar espaço e operações.",
                                  "learningObjective": "Entender como aplicar H_k à submatriz sem afetar partes triangulares superiores.",
                                  "commonMistakes": "Aplicar H_k à matriz inteira em vez da submatriz; não atualizar Q corretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Iterar o Processo e Descrever o Algoritmo Completo",
                                  "subSteps": [
                                    "Para k=1 até min(m-1,n)-1: construa u_k da subcoluna A(k+1:m,k), aplique H_k à A(k:m,k:n).",
                                    "Após todos k, A(1:min(m,n),1:n) é triangular superior R.",
                                    "A decomposição é A = Q R com Q ortogonal produto de H_k.",
                                    "Discuta estabilidade: backward stable, preserva norma 2."
                                  ],
                                  "verification": "Escreva pseudocódigo completo e rode para matriz de teste 3x2, confirmando ||A - Q R|| < 1e-12.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Pseudocódigo template",
                                    "Software MATLAB/Python para teste"
                                  ],
                                  "tips": "Comece com m=n quadrada para simplicidade antes de retangular.",
                                  "learningObjective": "Descrever o loop principal e resultados finais do algoritmo Householder QR.",
                                  "commonMistakes": "Loop até m em vez de min(m,n); esquecer que para m<n, R é trapezoidal."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Propriedades e Variações",
                                  "subSteps": [
                                    "Explique por que Householder é preferido a Givens: menos operações, mais estável para vetores longos.",
                                    "Discuta armazenamento: guardar u_k em A subdiagonal para reconstruir H_k.",
                                    "Mencione extensões: QR com pivoteamento para rank revelador.",
                                    "Compare complexidade com Gram-Schmidt clássico (instável)."
                                  ],
                                  "verification": "Liste 3 vantagens sobre métodos alternativos e prove estabilidade com exemplo numérico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Artigo ou notas sobre LAPACK dgeqrf",
                                    "Tabela de complexidades"
                                  ],
                                  "tips": "Relacione com BLAS: usa Level 2/3 para eficiência em hardware vetorizado.",
                                  "learningObjective": "Compreender contexto numérico e implementacional do algoritmo.",
                                  "commonMistakes": "Ignorar questões de precisão flutuante; confundir com QR de Gram-Schmidt."
                                }
                              ],
                              "practicalExample": "Para A = [[4,1],[-1,-2],[1,1]] (m=3,n=2):\n- k=1: x=[-1,1]^T, sigma=-√2, u=[-1-√2,1]^T normalizado, H1 zera A(2:3,1).\n- A torna-se [[*,*],[0,*],[0,*]].\n- k=2 não roda (min(m,n)=2). Resultado: R superior trapezoidal, Q=H1.",
                              "finalVerifications": [
                                "Pode escrever pseudocódigo completo sem olhar notas?",
                                "Explica construção de u_k com fórmula exata?",
                                "Verifica zeros introduzidos após cada k em exemplo 3x3?",
                                "Descreve como obter Q explicitamente?",
                                "Discute estabilidade numérica corretamente?"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na descrição de H_k e u_k (peso 30%)",
                                "Clareza na sequência de aplicação à submatriz (25%)",
                                "Correta identificação do loop e limites (20%)",
                                "Inclusão de considerações numéricas (15%)",
                                "Uso de notação consistente (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em Python/NumPy ou Fortran LAPACK.",
                                "Análise Numérica: Estudo de erros de arredondamento e estabilidade.",
                                "Machine Learning: Pré-processamento para PCA e regressão linear.",
                                "Engenharia: Simulações dinâmicas e controle ótimo."
                              ],
                              "realWorldApplication": "Usado em solvers de equações lineares (via RQ^{-1}), mínimos quadrados (A x ≈ b), eigenvalores (QR iterativo), e bibliotecas como LAPACK para HPC em física, finanças e bioinformática."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.2",
                            "name": "Escrever pseudocódigo do QR Householder",
                            "description": "Implementar pseudocódigo completo para A m×n, armazenando Householders de forma compacta (vetores u_k e β_k).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Refletor de Householder Básico",
                                  "subSteps": [
                                    "Revise a definição de um refletor de Householder: H = I - β u u^T, onde ||u||=1 e β=2.",
                                    "Estude como escolher u para zerar os elementos abaixo da diagonal em uma coluna x ∈ ℝ^{m-k+1}: defina σ = ||x(2:m)||, α = -sign(x(1)) σ, u(1) = x(1) - α, u(2:m) = x(2:m), então normalize u e β = 2 / (u^T u).",
                                    "Pratique computando manualmente u e β para um vetor x simples de dimensão 3.",
                                    "Verifique que H x = α e_1, confirmando que zera as entradas abaixo da primeira.",
                                    "Anote a forma compacta: armazenar apenas u_k (com u_k(1)=1 implicitamente) e β_k."
                                  ],
                                  "verification": "Conseguiu computar u e β corretamente para um vetor exemplo e verificar H x ≈ [α, 0, ..., 0]^T.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Papel e calculadora",
                                    "Referência: Golub & Van Loan, Matrix Computations (Capítulo 5)",
                                    "Notebook Jupyter para simulações numéricas"
                                  ],
                                  "tips": "Sempre use sign(x(1)) para evitar cancelamento numérico; teste com x(1) próximo de zero.",
                                  "learningObjective": "Compreender a construção e propriedades do refletor Householder para introduzir zeros em vetores.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo em α = -sign(x(1)) ||x(2:end)||",
                                    "Normalizar u incorretamente (lembre: β incorpora a normalização)",
                                    "Confundir β = 2 / ||u||^2 com u não normalizado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar e Armazenar Householder para uma Coluna",
                                  "subSteps": [
                                    "Para a k-ésima coluna de A(k:m, k), extraia x = A(k:m, k).",
                                    "Compute σ = norma euclidiana de x(2:m), α = -sign(x(1)) σ.",
                                    "Forme u(1) = x(1) - α, u(2:m) = x(2:m); normalize u ← u / ||u||, β_k = 2.",
                                    "Armazene compactamente: A(k+1:m, k) ← u(2:m), guarde β_k separadamente; defina A(k,k) implicitamente como 1 para u.",
                                    "Aplique H_k à coluna k: A(k:m, k) ← α e_1 (mas na prática, só o primeiro elemento muda)."
                                  ],
                                  "verification": "Implementou computação manual para uma matriz 4x3 exemplo, verificando que subcoluna k fica com zeros abaixo de k.",
                                  "estimatedTime": "1.5-2.5 hours",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software como MATLAB/Octave ou Python (NumPy) para validar normas",
                                    "Exemplo de matriz de teste"
                                  ],
                                  "tips": "Use norma estável: σ = sqrt(sum(x(2:m).^2)) para evitar overflow/underflow.",
                                  "learningObjective": "Dominar o cálculo e armazenamento compacto de um único refletor Householder em uma coluna de A.",
                                  "commonMistakes": [
                                    "Armazenar u inteiro em vez de compacto (só abaixo da diagonal)",
                                    "Esquecer de atualizar A(k,k) para o valor diagonal correto após aplicação",
                                    "Erro no cálculo de σ: incluir x(1) incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Householder à Submatriz Restante",
                                  "subSteps": [
                                    "Após armazenar u_k e β_k, aplique H_k à submatriz A(k:m, k+1:n): para cada coluna j = k+1 to n, v = A(k:m, j), w = β_k (u^T v) u, A(k:m,j) ← v - w.",
                                    "Otimize: compute essencial = β_k * dot(u, A(k:m,j)), então subtraia essencial * u.",
                                    "Note que H_k é simétrico e unitário: H_k A(k:m, :) atualiza toda a sublinha.",
                                    "Para eficiência, aplique também à direita se necessário, mas para QR padrão, só left-multiplication.",
                                    "Verifique numericamente: submatriz abaixo de k na coluna k deve ser zero."
                                  ],
                                  "verification": "Aplicou manualmente a uma submatriz 3x2 exemplo, confirmando zeros introduzidos sem alterar o progresso anterior.",
                                  "estimatedTime": "2-3 hours",
                                  "materials": [
                                    "Planilha Excel ou Python script para multiplicações matriciais",
                                    "Referência: Trefethen & Bau, Numerical Linear Algebra (Lecture 10)"
                                  ],
                                  "tips": "Implemente dot products eficientemente; evite formar H explícita para economizar O(m^2) espaço.",
                                  "learningObjective": "Implementar a aplicação eficiente de Householder reflectors à trailing submatrix.",
                                  "commonMistakes": [
                                    "Aplicar H_k à toda A em vez de só submatriz A(k:m, k:n)",
                                    "Esquecer fator β_k no produto escalar",
                                    "Atualizar colunas anteriores (k < j)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estruturar o Loop Principal e Escrever Pseudocódigo Completo",
                                  "subSteps": [
                                    "Escreva o loop: for k=1 to min(m,n)-1: compute x=A(k:m,k), σ=norm(x(2:end)), etc., aplique H_k à A(k:m,k:n).",
                                    "Após loop, R está na parte upper triangular de A(1:n,1:n), Householders em A(n+1:m,1:n) e vetor β.",
                                    "Inclua casos especiais: se ||x(2:end)||=0, skip; para m<n ou n<m.",
                                    "Adicione comentários no pseudocódigo para clareza: inputs A m×n, outputs R=A upper, vetores u_k, β_k.",
                                    "Teste com matriz 3x2: A = [[1,2],[3,4],[5,6]], execute passos manualmente."
                                  ],
                                  "verification": "Pseudocódigo escrito roda corretamente em pseudocódigo ou código real, produzindo R tal que ||A - Q R|| < ε.",
                                  "estimatedTime": "2-3 hours",
                                  "materials": [
                                    "Editor de texto para pseudocódigo",
                                    "Python/Octave para validação completa com qr() built-in",
                                    "Matriz de teste impressa"
                                  ],
                                  "tips": "Use min(m-1,n) para loop; armazene β como array separado de tamanho n.",
                                  "learningObjective": "Construir o algoritmo QR completo via Householder com armazenamento compacto.",
                                  "commonMistakes": [
                                    "Loop até m em vez de min(m,n)",
                                    "Não tratar caso σ=0 (pular iteração)",
                                    "Confundir índices: A(k:m,k) vs A(k,k:m)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[1, 2], [3, 4], [5, 6]] (3x2):\n- k=1: x=[1,3,5], σ=sqrt(34)≈5.83, α≈-5.83, u≈[6.83,3,5]/norm, β=2, aplique H1 a A(1:3,1:2) → zeros em A(2:3,1).\nResultado final: R upper em A(1:2,1:2), u2 em A(3,1), β=[β1,β2]. Verifique com qr(A).",
                              "finalVerifications": [
                                "Subdiagonal de A(1:min(m,n),1:min(m,n)) é numericamente zero.",
                                "R = triu(A(1:n,:)) satisfaz ||A - Q R||_F < 1e-12.",
                                "Todos u_k e β_k armazenados corretamente e recuperáveis.",
                                "Algoritmo lida com m ≠ n e casos degenerados (coluna zero).",
                                "Pseudocódigo é legível, comentado e O(m n^2) flops.",
                                "Testado em pelo menos 3 matrizes de tamanhos variados."
                              ],
                              "assessmentCriteria": [
                                "Correção na escolha de α com sign(x(1)) para estabilidade numérica.",
                                "Armazenamento compacto: apenas vetores u_k abaixo diagonal e β_k.",
                                "Eficiência na aplicação: usa produto escalar + saxpy, não forma H explícita.",
                                "Tratamento de bordas: k até min(m-1,n), skip se σ=0.",
                                "Clareza do pseudocódigo: variáveis bem nomeadas, loop correto.",
                                "Validação: matches output de função QR padrão."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Implementar em Python/Julia para análise numérica.",
                                "Física Computacional: QR em decomposições para simulações de dinâmica molecular.",
                                "Machine Learning: Pré-condicionadores em least squares para regressão linear.",
                                "Engenharia: Solução de sistemas overdetermined em controle de sistemas."
                              ],
                              "realWorldApplication": "Usado em solvers de equações lineares (e.g., back-substitution após QR para Ax=b), ajuste de curvas em dados científicos, compressão de imagens via SVD (que usa QR internamente), e otimização em portfólios financeiros via least squares."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.3",
                              "10.1.3.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.3",
                            "name": "Analisar complexidade computacional",
                            "description": "Calcular custo total: ≈ 2mn^2 - 2n^3/3 flops para m≥n, comparando com Gram-Schmidt.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Algoritmo de Triangularização QR com Refletores de Householder",
                                  "subSteps": [
                                    "Identificar as etapas principais: para k=1 até n, computar o refletor Householder para a subcoluna k, aplicá-lo à submatriz restante.",
                                    "Descrever a computação do vetor u: normalizar x_k - ||x_k|| e_1 para obter o refletor.",
                                    "Explicar a aplicação: multiplicar H_k pela submatriz A(k:m,k:n).",
                                    "Revisar a estrutura triangular superior R resultante."
                                  ],
                                  "verification": "Esboçar o pseudocódigo do algoritmo e confirmar que introduz zeros abaixo da diagonal em cada coluna.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência: notas de aula ou livro de Álgebra Linear Numérica (ex: Golub & Van Loan)"
                                  ],
                                  "tips": "Foque nas operações matriciais e vetoriais custosas: normalizações e multiplicações.",
                                  "learningObjective": "Compreender a sequência de operações no algoritmo para identificar contagens de flops.",
                                  "commonMistakes": "Confundir a aplicação do refletor apenas na parte inferior com toda a matriz."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Flops para Computação dos Refletores Householder",
                                  "subSteps": [
                                    "Para cada k=1 a n: computar normas e subtrações em x = A(k:m,k), custa ~2(m-k+1) flops.",
                                    "Normalizar para obter u = x / ||x||, adicionando ~2(m-k+1) flops.",
                                    "Contar precisamente: inner products para norma (~2(m-k+1)), scaling e subtração."
                                  ],
                                  "verification": "Derivar soma total de flops para todos refletores: ∑_{k=1}^n 4(m-k+1) ≈ 4mn - 2n(n+1).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB para somas simbólicas",
                                    "Planilha para somar séries"
                                  ],
                                  "tips": "Use somas aritméticas: ∑(m-k+1) = n m - n(n+1)/2.",
                                  "learningObjective": "Quantificar precisamente o custo de gerar cada vetor Householder.",
                                  "commonMistakes": "Esquecer flops na normalização ou contar apenas multiplicações, ignorando adições."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Flops para Aplicação dos Refletores às Submatrizes Restantes",
                                  "subSteps": [
                                    "Para cada k, aplicar H_k a A(k:m, k:n): isso é ~4(m-k+1)(n-k+1) flops (2 para H*v e 2 para v+Hv).",
                                    "Somar sobre k: total ≈ ∑ 4(m-k+1)(n-k+1).",
                                    "Expandir: aproximar para m>>n como 2 m n^2 - (2/3) n^3."
                                  ],
                                  "verification": "Computar a soma exata e aproximar para m≥n: 2mn^2 - (2/3)n^3 + termos menores.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software simbólico como SymPy ou papel para somas duplas"
                                  ],
                                  "tips": "Aproxime somas por integrais para insights: ∫(m-x)(n-x) dx.",
                                  "learningObjective": "Dominar contagem de flops em aplicações de transformações elementares.",
                                  "commonMistakes": "Contar apenas uma multiplicação por coluna, ignorando o custo simétrico do Householder."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Somar Custos Totais e Comparar com Processo de Gram-Schmidt",
                                  "subSteps": [
                                    "Adicionar flops de refletores (~2mn) + aplicações (~2mn^2 - 2n^3/3) = total ≈ 2mn^2 - 2n^3/3.",
                                    "Recordar custo Gram-Schmidt clássico: ~2 m n^2 flops.",
                                    "Comparar: Householder economiza ~ n^3/3 para m>>n, mais estável numericamente."
                                  ],
                                  "verification": "Para m=100, n=50, calcular numérico: Householder vs GS, mostrar economia.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python para exemplos numéricos"
                                  ],
                                  "tips": "Use Big-O para discussão qualitativa após exato.",
                                  "learningObjective": "Interpretar complexidade total e vantagens sobre métodos alternativos.",
                                  "commonMistakes": "Inverter termos ou esquecer que GS tem custo similar mas menos estável."
                                }
                              ],
                              "practicalExample": "Para A 4x3: k=1, x=[a11,a21,a31,a41], ||x||~8 flops, u~8 flops; aplicar a 4x3 submatriz ~4*3*4=48 flops. Repetir para k=2,3; total ~150 flops. GS similar matriz: ~2*4*9=72, mas compute exato para ver.",
                              "finalVerifications": [
                                "Derivar fórmula exata: 2mn^2 - 2n^3/3 + O(mn).",
                                "Calcular para m=2n: economia de ~16% vs GS.",
                                "Explicar por que Householder é preferido em software (LAPACK).",
                                "Identificar operações dominantes: aplicações de refletores."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de flops por etapa (>95% correto).",
                                "Correta derivação da soma total e aproximação assintótica.",
                                "Comparação quantitativa e qualitativa com Gram-Schmidt.",
                                "Clareza na explicação de estabilidade numérica."
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Análise de Algoritmos e Otimização.",
                                "Análise Numérica: Estabilidade e Condicionamento.",
                                "Física Computacional: Simulações de Sistemas Lineares em Dinâmica.",
                                "Engenharia: Processamento de Sinais e Controle."
                              ],
                              "realWorldApplication": "Em machine learning para regressão linear (least squares), onde QR resolve Ax=b estável; usado em bibliotecas como NumPy/SciPy para grandes datasets em análise de dados e simulações científicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.4",
                            "name": "Discutir estabilidade numérica",
                            "description": "Explicar por que Householder QR é backward stable (erro relativo O(ε_mach) independentemente de A), citando referências como Golub & Van Loan.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Básicos de Estabilidade Numérica",
                                  "subSteps": [
                                    "Definir estabilidade forward, backward e mista em computação numérica.",
                                    "Explicar o significado de erro relativo O(ε_mach), onde ε_mach é a precisão de máquina.",
                                    "Discutir o papel de ε_mach na análise de erros de arredondamento.",
                                    "Diferenciar estabilidade numérica do condicionamento da matriz (κ(A)).",
                                    "Exemplificar com uma operação simples como soma de flutuantes."
                                  ],
                                  "verification": "Escrever um resumo de 100 palavras definindo backward stability e erro O(ε_mach).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro 'Matrix Computations' de Golub & Van Loan (Capítulo 2 ou 3)",
                                    "Notas sobre análise numérica básica"
                                  ],
                                  "tips": "Lembre-se: backward stability foca no input perturbado, não na saída exata.",
                                  "learningObjective": "Compreender os fundamentos teóricos de estabilidade numérica.",
                                  "commonMistakes": "Confundir forward stability (erro na saída) com backward stability (perturbação no input)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar o Algoritmo de Triangularização QR com Refletores de Householder",
                                  "subSteps": [
                                    "Descrever o refletor de Householder: v = x - α e_1, H = I - 2vv^T / ||v||^2.",
                                    "Explicar a aplicação sequencial para zerar a subdiagonal coluna por coluna.",
                                    "Escrever pseudocódigo para o processo completo QR = Householder(A).",
                                    "Simular manualmente para uma matriz 3x3 pequena.",
                                    "Discutir como Q é produto de refletores e R é upper triangular."
                                  ],
                                  "verification": "Executar o algoritmo à mão para uma matriz 3x3 e verificar Q*R ≈ A.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pseudocódigo de Householder QR de notas de aula",
                                    "Papel e calculadora para exemplo manual",
                                    "MATLAB/Python para verificação opcional"
                                  ],
                                  "tips": "Cada refletor é aplicado apenas abaixo da diagonal para eficiência.",
                                  "learningObjective": "Dominar os passos exatos do algoritmo Householder QR.",
                                  "commonMistakes": "Esquecer de normalizar v corretamente ou aplicar H em todo A em vez de submatriz."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Fontes de Erro no Algoritmo Householder QR",
                                  "subSteps": [
                                    "Identificar operações principais: produto escalar (dot), saxpy (escalar*vetor + vetor), norma euclidiana.",
                                    "Estimar erros de arredondamento usando o modelo de máquina padrão: fl(a⊕b)=(a⊕b)(1+δ), |δ|≤ε_mach.",
                                    "Analisar propagação de erros em cada reflexão Householder.",
                                    "Quantificar erro acumulado sobre n colunas: O(n ε_mach ||A||).",
                                    "Comparar com operações em decomposições alternativas."
                                  ],
                                  "verification": "Listar 4 fontes de erro principais com bounds estimados O(· ε_mach).",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "'Accuracy and Stability of Numerical Algorithms' de Higham (Capítulo 8)",
                                    "Folha de análise de erro com modelo fl"
                                  ],
                                  "tips": "Dot products em vetores longos amplificam erros por O(n ε_mach), mas Householder mitiga isso.",
                                  "learningObjective": "Identificar e quantificar erros numéricos específicos no Householder QR.",
                                  "commonMistakes": "Ignorar crescimento de erros em produtos escalares para matrizes grandes ou subestimar O(n) fator."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar Backward Stability e Citar Referências",
                                  "subSteps": [
                                    "Mostrar que o algoritmo computa Q_hat R_hat tal que |A + ΔA = Q_hat R_hat|, ||ΔA||/||A|| = O(ε_mach).",
                                    "Argumentar independência do κ(A) para backward error.",
                                    "Citar Theorem 8.5.1 de Golub & Van Loan (4ª ed.) ou equivalente.",
                                    "Comparar estabilidade com Givens rotations (semelhante mas Householder mais cache-friendly).",
                                    "Discutir implicações para solve de mínimos quadrados."
                                  ],
                                  "verification": "Redigir explicação de 200 palavras com citação e bound matemático.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Golub & Van Loan, 'Matrix Computations', 4ª ed., Seção 8.5",
                                    "Artigo original de Householder (1958) para contexto histórico"
                                  ],
                                  "tips": "Backward stability é 'componentwise' em alguns análises, ainda melhor.",
                                  "learningObjective": "Explicar rigorosamente por que Householder QR é backward stable.",
                                  "commonMistakes": "Afirmar estabilidade sem bound explícito ou confundir com forward error em ||x - x_exact||."
                                }
                              ],
                              "practicalExample": "Em MATLAB, implemente Householder QR para a matriz Hilbert 10x10 (mal-condicionada, κ≈10^13). Compute fl_QR = householder_qr(A); erro_backward = norm(A - fl_QR.Q * fl_QR.R, 'fro') / norm(A, 'fro'); Verifique erro ≈ 10^{-15} (O(ε_mach)), independente de κ(A). Compare com qr(A) built-in.",
                              "finalVerifications": [
                                "Pode definir backward stability e erro O(ε_mach) corretamente?",
                                "Explica as fontes de erro e sua propagação no Householder QR?",
                                "Cita referências como Golub & Van Loan com teorema específico?",
                                "Demonstra independência da estabilidade em relação a κ(A)?",
                                "Discute vantagens sobre métodos alternativos como Givens?",
                                "Verifica numericamente com exemplo mal-condicionado?",
                                "Relaciona à estabilidade em aplicações como least squares?"
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual e definições corretas (25%)",
                                "Análise rigorosa de erros com bounds matemáticos (30%)",
                                "Uso correto de referências e teoremas (20%)",
                                "Clareza e estrutura da explicação (15%)",
                                "Exemplo prático ou verificação numérica (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Modelos de arredondamento e análise de erro",
                                "Programação Científica: Implementação estável em NumPy/SciPy/LAPACK",
                                "Ciência de Computação: Otimização de algoritmos BLAS-level",
                                "Física Computacional: Simulações diferenciais com decomposições estáveis",
                                "Estatística Computacional: Regressão robusta e PCA numérica"
                              ],
                              "realWorldApplication": "Em machine learning, para regressão linear ou PCA em datasets grandes/mal-condicionados (e.g., imagens de alta dimensão), Householder QR garante soluções backward stable em solvers de mínimos quadrados, evitando amplificação de erros por κ(A) alto, essencial em aplicações como recomendação Netflix ou processamento de imagens médicas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.4",
                              "10.1.3.4.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.5",
                    "name": "Rotações de Givens",
                    "description": "Rotações elementares para introduzir zeros em matrizes e obter a decomposição QR.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.5.1",
                        "name": "Definição e Propriedades da Matriz de Rotação de Givens",
                        "description": "A matriz de rotação de Givens é uma matriz ortogonal elementar que atua como uma rotação no plano bidimensional definido por duas linhas ou colunas específicas de uma matriz, preservando a norma euclidiana e sendo usada para introduzir zeros de forma estável numericamente.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.1.1",
                            "name": "Identificar a forma padrão da matriz de Givens",
                            "description": "Reconhecer e escrever a matriz de rotação de Givens G(i,j,θ) para índices i e j, com elementos c = cos(θ) na diagonal e s = sin(θ) nas posições off-diagonal (i,j) e (j,i), e identidade nos demais lugares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a matriz identidade como base",
                                  "subSteps": [
                                    "Revise a estrutura de uma matriz identidade n x n, onde todos os elementos da diagonal principal são 1 e os demais são 0.",
                                    "Identifique as posições (k,k) para k=1 a n como os elementos da diagonal.",
                                    "Pratique escrevendo matrizes identidade para n=3 e n=4 manualmente.",
                                    "Confirme que I * v = v para qualquer vetor v, ilustrando a propriedade neutra.",
                                    "Anote as dimensões típicas usadas em contextos de Álgebra Linear Computacional (n ≥ i,j)."
                                  ],
                                  "verification": "Escreva corretamente a matriz identidade 3x3 e multiplique por um vetor simples para obter o vetor original.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora ou software como MATLAB/Octave para verificação opcional"
                                  ],
                                  "tips": "Sempre comece pela identidade para evitar confusões nas posições off-diagonal.",
                                  "learningObjective": "Dominar a base da matriz identidade como ponto de partida para modificações.",
                                  "commonMistakes": [
                                    "Confundir linhas e colunas ao indexar",
                                    "Esquecer zeros off-diagonal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Localizar e destacar as posições i e j na matriz",
                                  "subSteps": [
                                    "Escolha índices i < j em uma matriz n x n (ex: i=2, j=4 para n=5).",
                                    "Marque as posições (i,i), (j,j), (i,j) e (j,i) na matriz identidade.",
                                    "Visualize o plano i-j como um subespaço 2D dentro da matriz nD.",
                                    "Desenhe um diagrama destacando apenas o bloco 2x2 de i-j e o resto como identidade.",
                                    "Repita para diferentes pares (i,j) para internalizar a localização."
                                  ],
                                  "verification": "Para n=4, i=1, j=3, circule corretamente as 4 posições relevantes em uma matriz desenhada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Marcadores coloridos para destacar posições"
                                  ],
                                  "tips": "Use cores diferentes: verde para diagonal (i,i e j,j), vermelho para off-diagonal (i,j e j,i).",
                                  "learningObjective": "Precisamente identificar as posições modificadas pela rotação de Givens.",
                                  "commonMistakes": [
                                    "Trocar i e j",
                                    "Marcar posições simétricas incorretamente como (i,j) e (i,i)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inserir os elementos c e s nas posições corretas",
                                  "subSteps": [
                                    "Calcule c = cos(θ) e s = sin(θ) para um θ dado (ex: θ=π/4, c=s=√2/2).",
                                    "Substitua (i,i) e (j,j) por c, mantendo o sinal positivo.",
                                    "Coloque s em (i,j) e s em (j,i), conforme a forma padrão especificada.",
                                    "Mantenha todos os outros elementos como na identidade (1 na diagonal restante, 0 elsewhere).",
                                    "Escreva a matriz completa e verifique visualmente as posições."
                                  ],
                                  "verification": "Escreva G(2,3,π/6) para n=4, com c≈0.866, s≈0.5 nas posições corretas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Tabela de valores trigonométricos"
                                  ],
                                  "tips": "Lembre-se: c na diagonal i e j, s nas off-diagonais (i,j) e (j,i) – sem sinal negativo a menos que especificado.",
                                  "learningObjective": "Corretamente popular as posições com cos(θ) e sin(θ).",
                                  "commonMistakes": [
                                    "Usar -s em (j,i)",
                                    "Colocar c em off-diagonal",
                                    "Esquecer de alterar ambas as diagonais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e praticar a forma geral da matriz",
                                  "subSteps": [
                                    "Escreva a notação simbólica G(i,j,θ) com c e s nas posições exatas.",
                                    "Teste com 3 exemplos diferentes: n=3 i=1j=2; n=4 i=1j=4; n=5 i=2j=3.",
                                    "Confirme que para θ=0, G=I (c=1, s=0).",
                                    "Multiplique G por um vetor unitário nos eixos i e j para ver a rotação.",
                                    "Compare com documentação ou software para validação."
                                  ],
                                  "verification": "Produza 3 matrizes Givens corretas para parâmetros variados e explique cada uma.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software NumPy/MATLAB para multiplicação matricial",
                                    "Papel para anotações"
                                  ],
                                  "tips": "Sempre verifique se G é quase-identidade exceto no bloco i-j.",
                                  "learningObjective": "Reconhecer e reproduzir a forma padrão de qualquer G(i,j,θ).",
                                  "commonMistakes": [
                                    "Índices começando de 0 em vez de 1",
                                    "Confundir convenções de sinal em s"
                                  ]
                                }
                              ],
                              "practicalExample": "Para n=3, i=1, j=2, θ=π/4: G = [[√2/2, -√2/2, 0], [√2/2, √2/2, 0], [0, 0, 1]] (nota: ajustado para convenção ortogonal comum com -s em (1,2), mas siga s positivo conforme descrito; exemplo computacional em QR para zerar a(2,1) em uma matriz A.)",
                              "finalVerifications": [
                                "Escreve corretamente G(1,3,θ) para n=3 sem erros de posição.",
                                "Identifica instantaneamente as 4 posições alteradas em qualquer G(i,j,θ).",
                                "Confirma que elementos fora de i-j são identidade.",
                                "Calcula valores numéricos precisos para c e s dado θ.",
                                "Explica verbalmente a estrutura em menos de 1 minuto.",
                                "Distingue G de matrizes de Householder."
                              ],
                              "assessmentCriteria": [
                                "Precisão 100% nas posições de c e s (sem transposições).",
                                "Correção dos valores trigonométricos (erro <0.01).",
                                "Manutenção da identidade nos demais elementos.",
                                "Uso consistente de índices i < j.",
                                "Capacidade de generalizar para qualquer n ≥ j.",
                                "Clareza na notação simbólica."
                              ],
                              "crossCurricularConnections": [
                                "Física: Rotações em mecânica quântica e dinâmica de partículas.",
                                "Computação: Implementação em algoritmos QR para eigenvalores.",
                                "Engenharia: Processamento de sinais e filtros digitais.",
                                "Gráficos Computacionais: Transformações de rotação em 3D."
                              ],
                              "realWorldApplication": "Usado em decomposição QR para resolver sistemas lineares numericamente estáveis, compressão de imagens JPEG, e simulações em machine learning para estabilizar gradientes em otimizadores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.2",
                            "name": "Verificar propriedades ortogonais",
                            "description": "Demonstrar que G^T G = I, calculando o produto e confirmando que a matriz é unitária, e entender implicações para preservação de normas em vetores e matrizes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Construir uma matriz de rotação de Givens exemplo",
                                  "subSteps": [
                                    "Escolha dimensões apropriadas, como 2x2 ou nx n com zeros para rotação em posições i,j.",
                                    "Defina o ângulo θ de rotação e compute c = cos(θ), s = sin(θ).",
                                    "Monte a matriz G preenchendo c e s nas posições corretas (diagonal i e j com c, off-diagonal com ±s), e 1s na diagonal restante.",
                                    "Verifique visualmente se G é uma matriz de rotação simétrica ou conforme definição."
                                  ],
                                  "verification": "A matriz G gerada corresponde à forma padrão de rotação de Givens para o ângulo e posições escolhidas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e lápis ou calculadora gráfica",
                                    "Software como Python (NumPy) ou MATLAB para verificação opcional"
                                  ],
                                  "tips": "Use um ângulo simples como θ=π/4 para c=s=√2/2, facilitando cálculos manuais.",
                                  "learningObjective": "Construir corretamente uma matriz de rotação de Givens a partir de parâmetros dados.",
                                  "commonMistakes": "Confundir sinais de s (um +s e outro -s para rotação padrão); esquecer de preencher 1s nas outras diagonais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a transposta da matriz G (G^T)",
                                  "subSteps": [
                                    "Identifique as posições simétricas da matriz G.",
                                    "Troque elementos off-diagonal: posição (i,j) vai para (j,i) e vice-versa.",
                                    "Mantenha diagonal inalterada, pois rotação de Givens é frequentemente simétrica (G^T = G^{-1}).",
                                    "Escreva explicitamente G^T para o exemplo numérico."
                                  ],
                                  "verification": "G^T é igual à matriz com elementos transpostos e corresponde à rotação no ângulo -θ.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Matriz G do passo anterior"
                                  ],
                                  "tips": "Lembre-se que para rotações de Givens, G^T = G(-θ), o que simplifica reconhecimento.",
                                  "learningObjective": "Computar corretamente a transposta de uma matriz de rotação de Givens.",
                                  "commonMistakes": "Erros de transposição em off-diagonais; assumir simetria sem verificar."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar o produto matricial G^T G",
                                  "subSteps": [
                                    "Divida o produto em blocos: foque nas posições i,j e resto.",
                                    "Calcule produtos linha-coluna para elementos relevantes: diagonal deve dar 1s, off-diagonais 0s.",
                                    "Use identidades trigonométricas: c^2 + s^2 = 1 para provar algebraicamente.",
                                    "Verifique numericamente com valores do exemplo.",
                                    "Confirme que o resultado é a matriz identidade I."
                                  ],
                                  "verification": "Cada elemento do produto G^T G equals δ_{kl} (1 na diagonal, 0 fora).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora para multiplicação matricial",
                                    "Software NumPy/MATLAB para automação e checagem"
                                  ],
                                  "tips": "Prove simbolicamente primeiro (c^2 + s^2 =1), depois numérico para confirmação.",
                                  "learningObjective": "Executar multiplicação matricial e demonstrar G^T G = I.",
                                  "commonMistakes": "Erros aritméticos em produtos; esquecer termos cruzados que cancelam."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar implicações da ortogonalidade",
                                  "subSteps": [
                                    "Explique que G ortogonal implica ||G v|| = ||v|| para qualquer vetor v (preservação de norma).",
                                    "Estenda para matrizes: normas de colunas/linhas unitárias e ortogonais entre si.",
                                    "Discuta inversa: G^{-1} = G^T, útil em algoritmos numéricos.",
                                    "Aplique a um vetor exemplo: compute norma antes/depois multiplicação por G.",
                                    "Conclua propriedades unitária preservando ângulos e comprimentos."
                                  ],
                                  "verification": "Demonstrar numericamente ||G v|| ≈ ||v|| e explicar simbolicamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Vetores de teste",
                                    "Norma euclidiana formula"
                                  ],
                                  "tips": "Use norma L2: √(x^T x); prove ||G x||^2 = x^T G^T G x = x^T x.",
                                  "learningObjective": "Entender e demonstrar preservação de normas e propriedades unitárias.",
                                  "commonMistakes": "Confundir norma de vetor com norma de matriz; ignorar precisão numérica."
                                }
                              ],
                              "practicalExample": "Para G 2x2 com θ=π/6: G = [[√3/2, -1/2], [1/2, √3/2]]. Compute G^T = [[√3/2, 1/2], [-1/2, √3/2]], então G^T G = [[1,0],[0,1]]=I. Norma de v=[1,0] preservada: ||G v||=1.",
                              "finalVerifications": [
                                "G^T G resulta exatamente na matriz identidade I.",
                                "Norma euclidiana de vetores de teste é preservada após multiplicação por G.",
                                "Explicação correta de G^{-1}=G^T.",
                                "Identificação simbólica usando c^2 + s^2=1.",
                                "Verificação numérica sem erros de arredondamento significativos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos matriciais (100% correto).",
                                "Explicação clara das implicações ortogonais (preservação de norma/ângulo).",
                                "Uso apropriado de identidades trigonométricas.",
                                "Profundidade na análise de propriedades unitárias.",
                                "Aplicação correta a exemplos numéricos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Rotações preservam comprimento em mecânica (vetores posição/velocidade).",
                                "Computação: Essencial em decomposição QR para resolução de sistemas lineares.",
                                "Processamento de Sinais: Filtros ortogonais em transformadas (ex: DCT).",
                                "Estatística: Preservação de variância em PCA.",
                                "Engenharia: Estabilização numérica em simulações."
                              ],
                              "realWorldApplication": "Em algoritmos de decomposição QR para resolução de equações lineares em machine learning e simulações físicas, onde preservação de normas evita amplificação de erros numéricos em grandes matrizes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.3",
                            "name": "Aplicar rotação a um vetor 2D",
                            "description": "Multiplicar um vetor [a, b]^T por uma rotação de Givens para zerar o segundo componente, calculando c = a / sqrt(a² + b²) e s = -b / sqrt(a² + b²).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular a norma euclidiana do vetor 2D",
                                  "subSteps": [
                                    "Identifique o vetor dado como [a, b]^T.",
                                    "Calcule a² + b².",
                                    "Extraia a raiz quadrada: r = √(a² + b²).",
                                    "Verifique se r ≠ 0 (caso especial se vetor nulo).",
                                    "Registre o valor de r com precisão adequada."
                                  ],
                                  "verification": "Confirme que r² = a² + b² exatamente ou com erro numérico mínimo.",
                                  "estimatedTime": "3-5 minutos",
                                  "materials": [
                                    "Calculadora ou software de cálculo (ex: Python, MATLAB)",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Mantenha r positiva; use frações exatas se a e b forem inteiros.",
                                  "learningObjective": "Dominar o cálculo da magnitude de um vetor 2D como base para normalização.",
                                  "commonMistakes": "Esquecer a raiz quadrada; usar norma L1 (|a| + |b|) em vez de L2; não tratar a=0 ou b=0."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar os coeficientes c e s da rotação de Givens",
                                  "subSteps": [
                                    "Calcule c = a / r.",
                                    "Calcule s = -b / r.",
                                    "Verifique numericamente se c² + s² ≈ 1.",
                                    "Anote os valores de c e s com precisão decimal suficiente.",
                                    "Considere casos especiais: se b=0, s=0 e c=sgn(a); se a=0, c=0 e s=-sgn(b)."
                                  ],
                                  "verification": "c² + s² = 1 (verificar ortogonalidade dos coeficientes).",
                                  "estimatedTime": "4-6 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Papel para anotações"
                                  ],
                                  "tips": "Use s = -b/r para garantir a convenção que zera o segundo componente.",
                                  "learningObjective": "Entender como c e s derivam da normalização para formar uma rotação unitária.",
                                  "commonMistakes": "Invertar o sinal de s (usar +b/r); divisão por r=0; perda de precisão em cálculos decimais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a matriz de rotação de Givens G",
                                  "subSteps": [
                                    "Posicione c na diagonal: G_{1,1} = c e G_{2,2} = c.",
                                    "Posicione -s em G_{1,2}.",
                                    "Posicione s em G_{2,1}.",
                                    "Escreva a matriz completa: G = [[c, -s], [s, c]].",
                                    "Opcional: Verifique det(G) = c² + s² = 1."
                                  ],
                                  "verification": "A matriz está na forma correta e é simétrica em magnitude.",
                                  "estimatedTime": "3-4 minutos",
                                  "materials": [
                                    "Papel quadriculado ou editor de matriz (ex: LaTeX, Excel)"
                                  ],
                                  "tips": "Lembre-se: -s em (1,2) garante a rotação correta para zerar b.",
                                  "learningObjective": "Construir a matriz explícita de uma rotação de Givens 2D.",
                                  "commonMistakes": "Confundir posições: colocar s em (1,2) ao invés de -s; esquecer a forma antissimétrica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a rotação ao vetor e verificar o resultado",
                                  "subSteps": [
                                    "Calcule a primeira componente: c * a + (-s) * b.",
                                    "Calcule a segunda componente: s * a + c * b.",
                                    "Confirme que a segunda componente é zero (ou ≈0 numericamente).",
                                    "Verifique que a primeira componente ≈ r.",
                                    "Opcional: Confirme ||G v|| = ||v||."
                                  ],
                                  "verification": "Vetor resultante tem segundo componente zero e norma preservada.",
                                  "estimatedTime": "5-7 minutos",
                                  "materials": [
                                    "Calculadora matricial",
                                    "Software como NumPy ou MATLAB"
                                  ],
                                  "tips": "Faça multiplicação matricial coluna por coluna para evitar erros aritméticos.",
                                  "learningObjective": "Executar multiplicação matriz-vetor e validar a eliminação do componente.",
                                  "commonMistakes": "Erros de sinal na multiplicação; não verificar o zero numericamente; ignorar preservação da norma."
                                }
                              ],
                              "practicalExample": "Para o vetor v = [3, 4]^T: r = √(9+16) = 5, c = 3/5 = 0.6, s = -4/5 = -0.8. Matriz G = [[0.6, 0.8], [-0.8, 0.6]]. Então G v = [0.6*3 + 0.8*4, -0.8*3 + 0.6*4] = [1.8 + 3.2, -2.4 + 2.4] = [5, 0]^T.",
                              "finalVerifications": [
                                "O segundo componente do vetor resultante é zero.",
                                "A norma do vetor resultante equals r.",
                                "c² + s² = 1.",
                                "A matriz G satisfaz G G^T = I (ortogonalidade).",
                                "Preservação da norma: ||G v|| = ||v||.",
                                "Correção dos sinais em c e s."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de r (erro < 10^{-6}).",
                                "Coeficientes c e s corretos com sinal de s negativo.",
                                "Matriz G montada na forma exata [[c, -s], [s, c]].",
                                "Multiplicação matricial sem erros aritméticos.",
                                "Verificação completa de zero no segundo componente e norma preservada.",
                                "Tratamento de casos especiais (ex: b=0)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em algoritmos QR (Python/NumPy).",
                                "Física: Rotações em sistemas 2D (mecânica, vetores de velocidade).",
                                "Gráficos Computacionais: Transformações de rotação em imagens 2D.",
                                "Estatística: Normalização em análise de componentes principais (PCA)."
                              ],
                              "realWorldApplication": "Essa técnica é fundamental na decomposição QR para resolver sistemas lineares Ax=b de forma numericamente estável, usada em simulações científicas, processamento de imagens, machine learning (ex: regressão linear) e otimização, evitando instabilidades em computadores de ponto flutuante."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.2",
                        "name": "Construção de Rotações para Introduzir Zeros",
                        "description": "Determinação dos parâmetros c e s de uma rotação de Givens para zerar um elemento específico em uma posição (j,k) de uma matriz, atuando sobre linhas ou colunas i e j.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.2.1",
                            "name": "Calcular parâmetros c e s para zerar elemento",
                            "description": "Dado elementos a = A(i,i), b = A(j,i) em uma coluna, computar r = sqrt(a² + b²), c = a/r, s = -b/r, evitando cancelamento numérico com fórmulas estáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e extrair os elementos a e b da matriz",
                                  "subSteps": [
                                    "Localize a coluna i da matriz A onde o zero será introduzido.",
                                    "Identifique o elemento pivô a = A(i,i) na posição diagonal.",
                                    "Identifique o elemento b = A(j,i) na posição a ser zerada (j ≠ i).",
                                    "Registre os valores exatos de a e b, considerando precisão numérica.",
                                    "Anote as posições i e j para referência futura."
                                  ],
                                  "verification": "Confirme que a e b foram extraídos corretamente comparando com a matriz original.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Matriz A impressa ou em software (ex: Python/MATLAB)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Sempre use índices baseados em 1 para clareza em descrições manuais.",
                                  "learningObjective": "Compreender a seleção correta de elementos em uma matriz para rotação de Givens.",
                                  "commonMistakes": "Confundir linhas e colunas; usar A(i,j) em vez de A(j,i)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o raio r de forma numericamente estável",
                                  "subSteps": [
                                    "Calcule a² = a * a e b² = b * b usando multiplicação direta.",
                                    "Some os quadrados: temp = a² + b².",
                                    "Compute r = sqrt(temp), preferencialmente usando função hypot(a,b) se disponível em software.",
                                    "Se |a| < |b|, use r = |b| * sqrt(1 + (a/b)²) para evitar underflow.",
                                    "Verifique se r > 0; caso r=0, a rotação é identidade."
                                  ],
                                  "verification": "r deve satisfazer r ≥ max(|a|, |b|) e ser positivo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora científica ou software (numpy.hypot)",
                                    "Tabela de valores de sqrt"
                                  ],
                                  "tips": "Use funções built-in como hypot para estabilidade automática em programação.",
                                  "learningObjective": "Aplicar fórmulas estáveis para evitar perda de precisão em sqrt(a² + b²).",
                                  "commonMistakes": "Calcular sqrt(a² + b²) diretamente com a pequeno e b grande, causando underflow."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar os parâmetros c e s",
                                  "subSteps": [
                                    "Calcule c = a / r.",
                                    "Calcule s = -b / r.",
                                    "Arredonde apenas no final, mantendo precisão durante cálculos intermediários.",
                                    "Confirme que c² + s² ≈ 1 (dentro de tolerância numérica).",
                                    "Ajuste sinal de s para garantir que a rotação seja adequada (ortogonal)."
                                  ],
                                  "verification": "Verifique c² + s² = 1 e a*c + b*s = 0.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora ou software para divisão precisa",
                                    "Papel para cálculos manuais"
                                  ],
                                  "tips": "Mantenha pelo menos 10 dígitos decimais em cálculos numéricos.",
                                  "learningObjective": "Derivar c e s garantindo que a rotação zere b e preserve norma.",
                                  "commonMistakes": "Esquecer o sinal negativo em s; dividir por r=0."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar os parâmetros e preparar aplicação",
                                  "subSteps": [
                                    "Aplique a rotação manualmente: novo_a = a*c + b*s (deve ser 0), novo_b = -a*s + b*c (=r).",
                                    "Compare com valores esperados teóricos.",
                                    "Teste estabilidade comparando com implementação em software.",
                                    "Documente c, s e r para uso na matriz completa.",
                                    "Identifique potenciais issues numéricos (ex: NaN ou Inf)."
                                  ],
                                  "verification": "A aplicação resulta em zero exato no elemento (j,i) e norma preservada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Software de álgebra linear (MATLAB/Python)",
                                    "Matriz de teste 2x2"
                                  ],
                                  "tips": "Implemente em código para automação e testes múltiplos.",
                                  "learningObjective": "Garantir que c e s formem uma rotação de Givens válida e estável.",
                                  "commonMistakes": "Não verificar ortogonalidade (c² + s² ≠ 1 devido a erros de arredondamento)."
                                }
                              ],
                              "practicalExample": "Considere A = [[3.0, 1.0], [4.0, 2.0]], coluna i=1, i=1 (linha1), j=2 (linha2). Então a=3.0, b=4.0. r = sqrt(9+16)=5.0, c=3/5=0.6, s=-4/5=-0.8. Aplicando: nova_coluna1 = [3*0.6 + 4*(-0.8), -3*(-0.8) + 4*0.6] = [0, 5].",
                              "finalVerifications": [
                                "r = sqrt(a² + b²) é computado corretamente sem underflow.",
                                "c = a/r e s = -b/r satisfazem c² + s² = 1.",
                                "a*c + b*s = 0 (elemento zerado).",
                                "-a*s + b*c = r (norma preservada).",
                                "Resultados coincidem com função hypot(a,b) em software.",
                                "Nenhum NaN ou Inf em casos edge (a=0 ou b=0)."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erro relativo < 1e-10.",
                                "Uso de fórmulas estáveis (hypot ou equivalente).",
                                "Correção de c e s com sinal apropriado.",
                                "Verificação de propriedades ortogonais.",
                                "Explicação clara de passos e justificativa numérica.",
                                "Aplicação correta em exemplo prático."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Uso de numpy.hypot em Python para estabilidade.",
                                "Física: Rotações em mecânica quântica e transformações de coordenadas.",
                                "Computação Científica: Integração em algoritmos QR para eigenvalores.",
                                "Estatística: Pré-processamento em PCA via decomposição QR."
                              ],
                              "realWorldApplication": "Esses parâmetros são cruciais na decomposição QR para resolver sistemas lineares superdeterminados (mínimos quadrados), usados em machine learning (regressão linear), processamento de sinais (filtros) e simulações físicas (dinâmica molecular)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.3"
                            ]
                          },
                          {
                            "id": "10.1.3.5.2.2",
                            "name": "Aplicar rotação a linhas ou colunas de matriz",
                            "description": "Multiplicar matriz A pela esquerda (Q^T A) ou direita (A Q) com Givens para introduzir zero abaixo da diagonal em uma coluna específica, atualizando apenas as linhas/colunas afetadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar posição alvo e calcular parâmetros da rotação Givens",
                                  "subSteps": [
                                    "Selecione a coluna j e a posição i+1 abaixo da diagonal onde o zero será introduzido em A[i+1, j].",
                                    "Extraia os elementos relevantes: a = A[i, j], b = A[i+1, j].",
                                    "Calcule a norma r = sqrt(a² + b²); se r ≈ 0, pule ou trate como zero.",
                                    "Compute c = a / r (cos θ) e s = -b / r (sin θ).",
                                    "Verifique que c² + s² = 1 (dentro de tolerância numérica)."
                                  ],
                                  "verification": "Parâmetros c e s satisfeitos c² + s² ≈ 1 e r > 0.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matriz A impressa ou em software (Python/NumPy, MATLAB)",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Use arctan2 para ângulo se preferir, mas fórmula direta é mais estável numericamente.",
                                  "learningObjective": "Calcular precisamente os coeficientes cosseno e seno para uma rotação Givens que zera um elemento específico.",
                                  "commonMistakes": [
                                    "Omitir o sinal negativo em s = -b/r",
                                    "Dividir por r=0 sem verificação",
                                    "Confundir índices i e i+1"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz de rotação Givens Q ou Q^T",
                                  "subSteps": [
                                    "Para multiplicação à esquerda (Q^T A, afeta linhas i e i+1): crie Q como identidade n x n, com Q[i,i] = c, Q[i+1,i+1] = c, Q[i,i+1] = s, Q[i+1,i] = -s.",
                                    "Para multiplicação à direita (A Q, afeta colunas j e k): ajuste para Q[j,j] = c, Q[k,k] = c, Q[j,k] = -s, Q[k,j] = s.",
                                    "Note que Q é ortogonal: Q^T Q = I.",
                                    "Implemente como matriz esparsa ou vetores para eficiência.",
                                    "Teste Q em vetores unitários para validar ortogonalidade."
                                  ],
                                  "verification": "Multiplicar Q^T Q resulta em identidade nas posições relevantes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software de álgebra linear (NumPy, MATLAB)",
                                    "Papel para matriz identidade"
                                  ],
                                  "tips": "Armazene apenas c, s e índices para economia de espaço, evitando matriz full.",
                                  "learningObjective": "Construir matriz de rotação elementar Givens para linhas ou colunas específicas.",
                                  "commonMistakes": [
                                    "Trocar posições de s e -s",
                                    "Confundir Q vs Q^T para esquerda/direita",
                                    "Esquecer identidade fora das posições i,i+1"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar rotação à matriz A atualizando apenas linhas/colunas afetadas",
                                  "subSteps": [
                                    "Para Q^T A (esquerda): atualize apenas linhas i e i+1 de A: nova_linha_i = c * linha_i + s * linha_{i+1}, nova_linha_{i+1} = -s * linha_i + c * linha_{i+1}.",
                                    "Para A Q (direita): atualize colunas j e k similarmente.",
                                    "Execute as 2 multiplicações escalares-vetor para cada linha/coluna afetada.",
                                    "Substitua as linhas/colunas originais pelas novas.",
                                    "Confirme que apenas 2 linhas ou colunas foram modificadas."
                                  ],
                                  "verification": "Elemento A[i+1, j] ≈ 0 e outras entradas na coluna j atualizadas corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código ou planilha para multiplicações matriciais",
                                    "Matriz A inicial"
                                  ],
                                  "tips": "Evite multiplicação full matrix-vector; use loops apenas nas 2 linhas/colunas para O(n) tempo.",
                                  "learningObjective": "Aplicar rotação Givens eficientemente, preservando norma e atualizando seletivamente.",
                                  "commonMistakes": [
                                    "Atualizar toda a matriz desnecessariamente",
                                    "Erro de sinal nas combinações lineares",
                                    "Não preservar o resto da matriz"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar resultado e analisar preservação de propriedades",
                                  "subSteps": [
                                    "Confira se A[i+1, j] está dentro de tolerância de máquina (e.g., 1e-12).",
                                    "Calcule norma da coluna j antes/depois: deve ser preservada.",
                                    "Verifique ortogonalidade parcial se aplicando múltiplas rotações.",
                                    "Compare com multiplicação full Q A para validação.",
                                    "Documente mudanças em linhas/colunas afetadas."
                                  ],
                                  "verification": "Zero introduzido, norma da coluna j inalterada, precisão mantida.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Funções de norma (norm() em NumPy/MATLAB)",
                                    "Matriz A original copiada"
                                  ],
                                  "tips": "Use tolerâncias relativas para comparações numéricas.",
                                  "learningObjective": "Validar a aplicação da rotação quanto a zeros, normas e estabilidade numérica.",
                                  "commonMistakes": [
                                    "Ignorar erros de arredondamento acumulando",
                                    "Não checar norma preservada",
                                    "Confundir tolerância absoluta vs relativa"
                                  ]
                                }
                              ],
                              "practicalExample": "Dada A = [[3.0, 2.0], [4.0, 0.0]] (2x2), introduza zero em A[2,1]: a=3, b=4, r=5, c=3/5=0.6, s=-4/5=-0.8. Q^T = [[0.6, 0.8], [-0.8, 0.6]]. A' = Q^T A = [[5.0, 1.2], [0.0, -3.2]]. Norma coluna 1: sqrt(9+16)=5 antes/depois.",
                              "finalVerifications": [
                                "Elemento alvo A[i+1,j] é zero dentro de 1e-12.",
                                "Norma euclidiana da coluna j (ou linhas afetadas) é preservada.",
                                "Apenas linhas i,i+1 ou colunas j,k foram alteradas.",
                                "Ortogonalidade: Q^T Q = I nas subposições.",
                                "Sem perda significativa de precisão numérica.",
                                "Resultado coincide com multiplicação full matrix (se computada)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de c, s e r (erro < 1e-10).",
                                "Eficiência: atualizações O(n) em vez de O(n²).",
                                "Correta distinção entre multiplicação esquerda (linhas) e direita (colunas).",
                                "Preservação exata de normas e introdução de zero.",
                                "Validação completa com verificações numéricas.",
                                "Clareza na documentação de passos e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/NumPy para QR Householder-Givens.",
                                "Física: Rotações em sistemas quânticos ou mecânica (matrizes de Pauli).",
                                "Engenharia: Processamento de sinais (filtros FIR ortogonais).",
                                "Ciência de Dados: Redução de dimensionalidade em PCA via QR."
                              ],
                              "realWorldApplication": "Essencial na decomposição QR para resolução de sistemas lineares Ax=b, mínimos quadrados e autovalores; usado em software como LAPACK, compressão de imagens JPEG e simulações numéricas em CFD (dinâmica de fluidos computacional)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.2.3",
                            "name": "Tratar casos especiais de singularidade",
                            "description": "Gerenciar situações onde r é pequeno ou zero, usando versões modificadas para evitar divisão por zero e manter estabilidade numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição padrão de rotações de Givens e identificar o problema da singularidade",
                                  "subSteps": [
                                    "Revise a fórmula padrão: r = √(a² + b²), c = a/r, s = b/r.",
                                    "Analise o caso r = 0 (a = b = 0), que causa divisão por zero.",
                                    "Discuta instabilidade numérica quando r é pequeno (próximo de epsilon da máquina).",
                                    "Visualize geometricamente: rotação para alinhar vetor (a, b) ao eixo x.",
                                    "Estude impactos na ortogonalização QR: perda de precisão ou NaN."
                                  ],
                                  "verification": "Explique em um parágrafo os riscos da divisão por r = 0 ou pequeno.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de Álgebra Linear Numérica",
                                    "Calculadora ou Python com NumPy",
                                    "Exemplos de matrizes 2x2"
                                  ],
                                  "tips": "Use epsilon_machine ≈ 1e-16 para contextualizar 'pequeno'.",
                                  "learningObjective": "Reconhecer os casos especiais de singularidade e seus efeitos numéricos.",
                                  "commonMistakes": [
                                    "Assumir r sempre > 0 sem verificação",
                                    "Ignorar underflow em r pequeno",
                                    "Confundir singularidade com ill-conditioning da matriz"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Classificar e detectar condições de singularidade numericamente",
                                  "subSteps": [
                                    "Defina critérios: r == 0 (exato) vs. r < tol (tol = 1e-12 * max(|a|,|b|)).",
                                    "Implemente teste if (abs(a) < tol && abs(b) < tol).",
                                    "Use normas relativas para detecção robusta: norm = √(a² + b²) / max(1, √(a² + b² + 1)).",
                                    "Teste com valores: a=0, b=0; a=1e-15, b=1e-15.",
                                    "Registre flags para logging em implementações maiores."
                                  ],
                                  "verification": "Escreva uma função de detecção que retorne true/false e teste com 5 casos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ambiente Python/Julia com NumPy/JuMP",
                                    "Lista de casos de teste"
                                  ],
                                  "tips": "Escolha tol adaptativa baseada na magnitude de a e b.",
                                  "learningObjective": "Implementar detecção confiável de singularidade.",
                                  "commonMistakes": [
                                    "Usar tol fixo sem considerar escala",
                                    "Comparar com zero absoluto em floating-point",
                                    "Não testar com underflow"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir tratamento para caso exato de singularidade (r = 0)",
                                  "subSteps": [
                                    "Defina rotação como identidade: c = 1, s = 0.",
                                    "Justifique: vetor nulo não precisa rotação; preserva ortogonalidade.",
                                    "Atualize código: if (r == 0) { c=1; s=0; return; }.",
                                    "Verifique multiplicação: G * [a; b] = [a; 0] trivialmente.",
                                    "Integre em loop de QR: pule rotação ou aplique identidade."
                                  ],
                                  "verification": "Aplique rotação identidade a vetor zero e confirme resultado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código base de Givens rotation",
                                    "Matriz de teste singular"
                                  ],
                                  "tips": "Sempre normalize c² + s² = 1 mesmo no caso identidade.",
                                  "learningObjective": "Gerenciar r=0 sem divisão por zero.",
                                  "commonMistakes": [
                                    "Definir c=0, s=0 (não ortogonal)",
                                    "Não retornar cedo, causando NaN",
                                    "Esquecer de tratar em ambos os off-diagonais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar formulação estável para r pequeno",
                                  "subSteps": [
                                    "Use versão escalar: if (|a| >= |b|) { t = b/a; c = 1/√(1+t²); s = c*t; } else { t=a/b; s=1/√(1+t²); c=s*t; }.",
                                    "Evite computar r explicitamente para prevenir under/overflow.",
                                    "Ajuste sinal: c = sign(a) * c se necessário para consistência.",
                                    "Teste estabilidade: compare com r explícito em r=1e-10.",
                                    "Integre detecção: se r pequeno mas detectado, fallback para escalar."
                                  ],
                                  "verification": "Compare normas de G resultante: ||G^T G - I|| < 1e-14.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Implementação Python de Givens",
                                    "Gerador de casos underflow"
                                  ],
                                  "tips": "Prefira o braço com maior denominador para precisão.",
                                  "learningObjective": "Aplicar rotações estáveis numericamente.",
                                  "commonMistakes": [
                                    "Esquecer sinal de c/s",
                                    "Usar atan2 desnecessariamente (mais caro)",
                                    "Não verificar ortogonalidade pós-tratamento"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e validar a implementação completa em contexto QR",
                                  "subSteps": [
                                    "Aplique sequência de Givens em matriz QR com entradas pequenas.",
                                    "Meça erro: ||A - Q R|| / ||A|| < tol.",
                                    "Compare com biblioteca (LAPACK/scipy.linalg.qr).",
                                    "Profile performance e estabilidade em matrizes ill-conditioned.",
                                    "Documente thresholds usados."
                                  ],
                                  "verification": "Execute QR em 3 matrizes problemáticas e confira resíduos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código QR householder/Givens",
                                    "Matrizes de teste (Hilbert, Vandermonde pequena)"
                                  ],
                                  "tips": "Use cond(A) > 1e10 para testar robustez.",
                                  "learningObjective": "Garantir estabilidade global na decomposição QR.",
                                  "commonMistakes": [
                                    "Testar só casos normais",
                                    "Ignorar acumulação de erros em múltiplas rotações",
                                    "Não comparar com referências padrão"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere zeroar a(2,1) em matriz A = [[1e-10, 1], [1e-10, 2]]. Sem tratamento: r≈1.41e-10, c/s instáveis. Com tratamento escalar: t=1, c=1/√2≈0.707, s=0.707, resultando em Q ortogonal precisa e R estável.",
                              "finalVerifications": [
                                "Função retorna c=1, s=0 para a=b=0 sem NaN.",
                                "Para r=1e-12, ||G^T G - I|| < 1e-14.",
                                "QR de matriz 4x4 com entradas 1e-10 converge sem perda de precisão.",
                                "Comparação com scipy.linalg.qr: resíduos relativos < 1e-12.",
                                "Nenhum underflow/overflow em 100 testes aleatórios.",
                                "Logging detecta corretamente 80% dos casos borderline."
                              ],
                              "assessmentCriteria": [
                                "Correção: ausência de divisão por zero ou NaN.",
                                "Estabilidade: erro ortogonalidade < machine epsilon.",
                                "Eficiência: tempo similar à implementação padrão.",
                                "Robustez: funciona para |a|,|b| de 1e-20 a 1e20.",
                                "Documentação: explica thresholds e casos.",
                                "Integração: pluga seamless em loop QR."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: controle de exceções floating-point (CS).",
                                "Análise Numérica: estabilidade de algoritmos (Matemática).",
                                "Física Computacional: rotações em simulações quânticas (Física).",
                                "Engenharia de Software: testes unitários para edge cases (Engenharia).",
                                "Machine Learning: pré-processamento estável de dados (IA)."
                              ],
                              "realWorldApplication": "Em solvers de sistemas lineares (ex: GPS em aviônica) com dados ruidosos/sensores falhos, previne crashes por NaN em decomposições QR usadas em filtros Kalman ou otimização convexa."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.3",
                        "name": "Aplicação Sequencial na Decomposição QR",
                        "description": "Uso de uma sequência de rotações de Givens para triangularizar uma matriz A m×n, obtendo Q ortogonal e R triangular superior, com ênfase em eficiência computacional e estabilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.3.1",
                            "name": "Executar algoritmo de QR via Givens",
                            "description": "Aplicar rotações sucessivas para zerar subdiagonal de cada coluna, de baixo para cima, acumulando Q como produto de Givens ou via Householder para comparação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inicializar a matriz e preparar o algoritmo",
                                  "subSteps": [
                                    "Selecione uma matriz A de tamanho m x n (m ≥ n) com elementos numéricos.",
                                    "Copie A para uma matriz de trabalho R, que será triangularizada.",
                                    "Inicialize Q como a matriz identidade m x m.",
                                    "Defina os índices: para cada coluna k de 1 até n-1, e para cada i de k+1 até m.",
                                    "Prepare ferramentas para calcular c = cosθ e s = sinθ: r = sqrt(R(k,k)^2 + R(i,k)^2), c = R(k,k)/r, s = R(i,k)/r."
                                  ],
                                  "verification": "Matriz R igual a A inicial, Q identidade, e índices anotados corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis ou software (Python/NumPy, MATLAB)",
                                    "Matriz de exemplo impressa"
                                  ],
                                  "tips": "Use precisão de ponto flutuante; evite divisões por zero verificando se r ≠ 0.",
                                  "learningObjective": "Configurar corretamente o ambiente para iterações do algoritmo QR via Givens.",
                                  "commonMistakes": [
                                    "Confundir cópia de A para R",
                                    "Índices off-by-one em k e i",
                                    "Esquecer de inicializar Q como identidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar rotações Givens para zerar subdiagonal da coluna k",
                                  "subSteps": [
                                    "Para coluna k fixa (ex: k=1), inicie loop i = k+1 até m.",
                                    "Para cada i, calcule r, c e s como acima.",
                                    "Crie matriz Givens G(i,k) com c na diagonal (k,k) e (i,i), s em (i,k), -s em (k,i).",
                                    "Aplique G à esquerda em R: R = G * R (atualize apenas linhas k e i, colunas k a n).",
                                    "Acumule Q = Q * G (ou armazene G para multiplicação reversa posterior)."
                                  ],
                                  "verification": "Após rotações para k, todos elementos abaixo da diagonal em coluna k são zero (exceto precisão numérica).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora para cosseno/seno",
                                    "Planilha ou código para multiplicações matriciais"
                                  ],
                                  "tips": "Atualize apenas linhas afetadas para eficiência; armazene Gs em lista para Q.",
                                  "learningObjective": "Executar uma iteração completa de Givens para uma coluna, zerando subdiagonal.",
                                  "commonMistakes": [
                                    "Sinais errados em s e -s",
                                    "Aplicar G à direita em vez de esquerda",
                                    "Atualizar colunas erradas além de n"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Iterar sobre colunas subsequentes até completar R",
                                  "subSteps": [
                                    "Repita o processo de Step 2 para k = 2 até n-1.",
                                    "Para cada k novo, ignore elementos já zerados (subdiagonal anterior permanece zero).",
                                    "Aplique rotações apenas abaixo de k em coluna k, preservando triangularidade anterior.",
                                    "Continue acumulando Gs em Q após cada aplicação.",
                                    "Monitore normas para estabilidade numérica."
                                  ],
                                  "verification": "R final é superior triangular (subdiagonal toda zero), com diagonal positiva.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Mesmo do Step 2",
                                    "Gráfico ou tabela para tracking de zeros"
                                  ],
                                  "tips": "Prossiga de baixo para cima na coluna (i=m downto k+1) se preferir ordem reversa.",
                                  "learningObjective": "Generalizar o loop principal do algoritmo para todas as colunas.",
                                  "commonMistakes": [
                                    "Reintroduzir zeros em colunas anteriores",
                                    "Esquecer loop em k",
                                    "Não preservar triangularidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir Q final e verificar a decomposição QR",
                                  "subSteps": [
                                    "Multiplique Q pelas Gs na ordem reversa das aplicações (produto Q = G1 G2 ... Gp).",
                                    "Verifique ortogonalidade: compute Q^T Q ≈ I.",
                                    "Compute Q * R e confirme igual a A original (erro < 1e-10).",
                                    "Opcional: compare com QR via Householder para validação.",
                                    "Documente todos os θs usados e elementos de R."
                                  ],
                                  "verification": "A ≈ Q R, Q unitária, R upper triangular.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software para multiplicação matricial",
                                    "Função de norma de Frobenius para erro"
                                  ],
                                  "tips": "Use QR econômico se m >> n; armazene Q implicitamente como produto de Gs.",
                                  "learningObjective": "Finalizar Q e validar a decomposição QR completa.",
                                  "commonMistakes": [
                                    "Ordem errada das Gs (deve ser reversa)",
                                    "Esquecer normalização de diagonal R",
                                    "Erro numérico por acumulação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[12, -51, 4], [6, 167, -68], [-4, 24, -41]] (exemplo clássico):\n- k=1, i=2: r=sqrt(12^2+6^2)=13.89, c=0.857, s=0.515 → zera A(2,1).\n- k=1, i=3: r=sqrt(12^2+(-4)^2)=12.65, c=0.949, s=-0.316 → zera A(3,1).\n- k=2, i=3: calcule e aplique para zerar abaixo em col 2.\nResultado: R triangular, Q produto das 3 Gs.",
                              "finalVerifications": [
                                "Subdiagonal de R é exatamente zero (dentro de tolerância numérica).",
                                "Q é ortogonal: colunas unitárias e mutuamente ortogonais.",
                                "A = Q R com erro residual mínimo (<1e-12).",
                                "Diagonal de R tem elementos positivos.",
                                "Algoritmo converge sem perda de rank.",
                                "Comparação com Householder QR idêntica."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de c, s e r (erro <1e-6).",
                                "Correta aplicação sequencial de Givens sem perturbar zeros prévios.",
                                "Eficiência: atualizações apenas em linhas/colunas relevantes.",
                                "Validação completa: ortogonalidade e reconstrução de A.",
                                "Explicação clara do processo e escolhas de índices.",
                                "Tratamento de casos edge (ex: elemento já zero)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python/NumPy para simulações numéricas.",
                                "Física: Rotações em mecânica quântica e processamento de sinais.",
                                "Engenharia: Otimização em controle de sistemas e compressão de dados.",
                                "Estatística: Regressão least squares via QR estável."
                              ],
                              "realWorldApplication": "Decomposição QR via Givens é crucial em álgebra numérica para solução estável de sistemas lineares overdetermined (least squares), computação de autovalores via QR algorithm iterativo, processamento de imagens (ex: JPEG), simulações em CFD e machine learning (PCA robusta)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.2.2"
                            ]
                          },
                          {
                            "id": "10.1.3.5.3.2",
                            "name": "Analisar custo computacional",
                            "description": "Calcular complexidade O(m n²) para QR de m×n, comparando com Gram-Schmidt e destacando vantagens em cache e paralelismo das Givens.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Algoritmo de Rotações de Givens para Decomposição QR",
                                  "subSteps": [
                                    "Estude a definição de rotação de Givens: uma matriz 2x2 que zera um elemento abaixo da diagonal.",
                                    "Entenda a aplicação sequencial: aplique rotações coluna por coluna para triangularizar a matriz m×n.",
                                    "Identifique o número de rotações necessárias: aproximadamente (m - k) por coluna k, para k=1 a n.",
                                    "Revise como as rotações são aplicadas à matriz inteira Q e R.",
                                    "Anote a estrutura geral do algoritmo pseudocódigo."
                                  ],
                                  "verification": "Escreva um resumo de 1 parágrafo explicando o fluxo do algoritmo Givens QR.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notas de aula sobre Álgebra Linear Computacional, pseudocódigo de Givens QR, calculadora.",
                                  "tips": "Desenhe diagramas visuais das rotações sendo aplicadas a uma matriz pequena para melhor compreensão.",
                                  "learningObjective": "Compreender os passos fundamentais do algoritmo Givens QR para análise de custo.",
                                  "commonMistakes": "Confundir rotações de Givens com Householder; ignorar que Givens zera um elemento por vez."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o Custo Computacional das Rotações de Givens",
                                  "subSteps": [
                                    "Conte o número total de rotações: soma de (m - k) para k=1 até n, aproximando para O(m n).",
                                    "Calcule flops por rotação: cada rotação envolve 4 multiplicações e 4 somas para gerar c e s, mais 4 m n operações para aplicar à matriz.",
                                    "Some os custos: custo dominante é O(4 m n²) flops para aplicação das rotações.",
                                    "Simplifique para complexidade assintótica O(m n²).",
                                    "Verifique com uma matriz exemplo 4x3 contando manualmente os flops."
                                  ],
                                  "verification": "Derive e anote a fórmula O(2 m n²) ou similar, confirmando com literatura padrão.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel quadriculado, lápis, referência de análise de complexidade (ex: Golub & Van Loan).",
                                  "tips": "Use somatórios: ∑_{k=1}^n (m - k) * 4m ≈ 2 m n² flops.",
                                  "learningObjective": "Derivar precisamente a complexidade O(m n²) para Givens QR.",
                                  "commonMistakes": "Contar apenas geração da rotação, esquecendo aplicação à matriz inteira; confundir m e n."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Revisar e Calcular Custo do Processo Gram-Schmidt Clássico",
                                  "subSteps": [
                                    "Lembre o Gram-Schmidt: para cada coluna k, subtrair projeções das anteriores.",
                                    "Conte inner products: k-1 por coluna k, cada um O(m).",
                                    "Some normalizações: O(m) por coluna.",
                                    "Total: O(m n²) flops, similar mas com constantes diferentes.",
                                    "Compare contagens exatas: Gram-Schmidt ~ 2 m n² flops."
                                  ],
                                  "verification": "Escreva as fórmulas de custo para Gram-Schmidt e confirme igualdade assintótica O(m n²).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Tabela comparativa em planilha, livro de Álgebra Numérica.",
                                  "tips": "Foque em operações ponto-interno como bottleneck principal.",
                                  "learningObjective": "Quantificar custo do Gram-Schmidt para baseline de comparação.",
                                  "commonMistakes": "Esquecer normalizações ou subtrações escalares; superestimar diferenças assintóticas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Complexidades e Destacar Vantagens de Givens",
                                  "subSteps": [
                                    "Compare flops totais: ambos O(m n²), mas Givens tem mais constantes (cerca de 4x).",
                                    "Discuta cache efficiency: Givens acessa linhas locais, melhor localidade vs. Gram-Schmidt global.",
                                    "Analise paralelismo: Givens permite rotação independente por elemento zeroável.",
                                    "Cite evidências: Givens superior em arquiteturas modernas com cache hierárquico.",
                                    "Resuma tabela: flops, cache misses, paralelismo."
                                  ],
                                  "verification": "Crie uma tabela comparativa com pelo menos 3 métricas e conclusões.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Planilha Excel/Google Sheets para tabela, artigos sobre BLAS/LAPACK.",
                                  "tips": "Pesquise benchmarks reais para validar claims qualitativos.",
                                  "learningObjective": "Identificar por que Givens é preferível apesar de custo similar.",
                                  "commonMistakes": "Ignorar fatores não-assintóticos como cache; afirmar superioridade errada em flops."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar Análise com Exemplo Numérico e Discussão",
                                  "subSteps": [
                                    "Implemente Givens QR em código simples para matriz pequena e conte flops reais.",
                                    "Compare runtime com Gram-Schmidt na mesma matriz.",
                                    "Meça cache misses usando profiler se possível.",
                                    "Discuta limitações: Givens mais estável numericamente também.",
                                    "Conclua relatório curto."
                                  ],
                                  "verification": "Execute código e anote resultados matching a análise teórica.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "MATLAB/Python/Julia com profiler (ex: numpy, timeit), matriz teste 100x50.",
                                  "tips": "Use matrizes densas e evite otimizações built-in para contagem pura.",
                                  "learningObjective": "Conectar teoria à prática através de experimentação.",
                                  "commonMistakes": "Usar bibliotecas otimizadas que mascaram custos; ignorar estabilidade numérica."
                                }
                              ],
                              "practicalExample": "Para uma matriz A 5x3, aplique Givens sequencialmente: 2 rotações na col1 (zeros em (2,1),(3,1),(4,1),(5,1) mas sequencial), conte ~4*5*3=60 flops principais vs. Gram-Schmidt ~2*5*3²/2=45 flops, observe cache hits em linhas adjacentes.",
                              "finalVerifications": [
                                "Deriva corretamente O(m n²) para Givens QR com contagem de flops precisa.",
                                "Compara assintoticamente com Gram-Schmidt, notando constantes maiores em Givens.",
                                "Explica vantagens em cache locality devido a acessos locais.",
                                "Destaca potencial de paralelismo em Givens por independência de rotações.",
                                "Valida com exemplo numérico pequeno mostrando matching teórico-prático.",
                                "Discute trade-offs como estabilidade numérica favorável a Givens."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de complexidade (80% flops corretos).",
                                "Qualidade da comparação quantitativa e qualitativa (tabela clara).",
                                "Profundidade na análise de cache e paralelismo (exemplos concretos).",
                                "Correção em exemplo prático (código/execução sem erros).",
                                "Clareza e estrutura do relatório final.",
                                "Identificação de limitações e contextos de uso."
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Análise de Algoritmos e Otimização de Performance.",
                                "Engenharia de Computação: Arquitetura de Cache e Programação Paralela (OpenMP/CUDA).",
                                "Física Computacional: Simulações que usam QR para eigenproblemas.",
                                "Machine Learning: Pré-processamento de dados via QR em PCA/SVD."
                              ],
                              "realWorldApplication": "Em solvers de sistemas lineares densos (LAPACK), processamento de sinais (beamforming), e machine learning (redução de dimensionalidade), onde Givens QR é usado em hardware com caches limitados ou GPUs para eficiência prática apesar de custo teórico similar ao Gram-Schmidt."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.3.3",
                            "name": "Implementar em pseudocódigo",
                            "description": "Escrever pseudocódigo para QR via Givens, incluindo loops para colunas e linhas, e atualização de elementos afetados sem armazenar todas as Q.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos da decomposição QR via rotações de Givens",
                                  "subSteps": [
                                    "Revise a definição de decomposição QR: A = QR, onde Q é ortogonal e R é triangular superior.",
                                    "Estude rotações de Givens: matrizes 2x2 que rotacionam vetores para alinhar com eixos.",
                                    "Entenda o processo sequencial: zerar elementos abaixo da diagonal coluna por coluna.",
                                    "Note a estratégia de não armazenar Q: aplique rotações diretamente em A para obter R.",
                                    "Identifique os loops necessários: externo por colunas k=1 a min(m,n)-1, interno por linhas i=k+1 a m."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo o algoritmo em palavras próprias, confirmando loops e estratégia de atualização in-place.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas de aula sobre Álgebra Linear Computacional, Wikipedia 'Givens rotation', pseudocódigo de referência QR.",
                                  "tips": "Desenhe uma matriz 4x3 pequena e marque os elementos a zerar sequencialmente para visualizar.",
                                  "learningObjective": "Dominar a lógica conceitual do algoritmo QR sem armazenamento explícito de Q.",
                                  "commonMistakes": "Confundir QR com Householder; assumir armazenamento de todas as Qs; ignorar limites de loops (min(m,n))."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Esboçar a estrutura principal de loops no pseudocódigo",
                                  "subSteps": [
                                    "Inicie o pseudocódigo com declaração da matriz A[m][n].",
                                    "Adicione loop externo: for k = 1 to min(m,n)-1.",
                                    "Dentro, adicione loop interno: for i = k+1 to m.",
                                    "Identifique colunas afetadas: da k à n para aplicação da rotação.",
                                    "Adicione placeholders para cálculo e aplicação da rotação."
                                  ],
                                  "verification": "O esboço deve ter loops aninhados corretos sem erros de índice; teste mental com m=3, n=2.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de texto ou papel para pseudocódigo, matriz de exemplo 3x2.",
                                  "tips": "Use pseudocódigo indentado para clareza; comece com 'ALGORITMO QR_Givens(A)'",
                                  "learningObjective": "Construir o esqueleto iterativo do algoritmo com loops precisos.",
                                  "commonMistakes": "Loop externo até n em vez de min(m,n)-1; incluir i=k no loop interno; índices off-by-one."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o cálculo da rotação de Givens",
                                  "subSteps": [
                                    "Para elementos a = A[k][k], b = A[i][k], calcule r = sqrt(a² + b²).",
                                    "Se r == 0, pule; senão, c = a/r, s = -b/r (cos e sin).",
                                    "Armazene temporariamente c e s para uso na aplicação.",
                                    "Verifique estabilidade numérica: evite divisão por zero ou underflow.",
                                    "Integre no loop interno após seleção de i."
                                  ],
                                  "verification": "Aplique manualmente a um par (a,b) = (3,4); deve dar c=0.6, s=-0.8, r=5.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora ou Python para testar fórmulas, referência matemática Givens.",
                                  "tips": "Use sinal negativo em s para convenção padrão; considere r=0 para singularidade.",
                                  "learningObjective": "Calcular parâmetros da rotação que zeram especificamente A[i][k].",
                                  "commonMistakes": "Esquecer sinal em s; calcular r incorretamente (sem sqrt); não tratar r=0."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar a aplicação da rotação aos elementos afetados",
                                  "subSteps": [
                                    "Para cada coluna j = k to n: aplique rotação às linhas k e i.",
                                    "Atualize A[k][j] = c*A[k][j] - s*A[i][j]",
                                    "Atualize A[i][j] = s*A[k][j] + c*A[i][j] (use temp para evitar overwrite).",
                                    "Confirme que A[i][k] vira zero após aplicação.",
                                    "Otimize usando variáveis temporárias para A[k][j] e A[i][j]."
                                  ],
                                  "verification": "Simule aplicação em submatriz 2x3 com valores conhecidos; verifique A[i][k]=0 e preservação de normas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Matriz de exemplo escrita à mão, calculadora para verificação manual.",
                                  "tips": "Sempre use temp1 = c*A[k][j] - s*A[i][j]; temp2 = s*A[k][j] + c*A[i][j]; então atribua.",
                                  "learningObjective": "Atualizar in-place a matriz para triangular superior sem perder ortogonalidade implícita.",
                                  "commonMistakes": "Atualizar sem temporárias (corrompe valores); aplicar só até j=k; esquecer j loop até n."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Finalizar, validar e otimizar o pseudocódigo completo",
                                  "subSteps": [
                                    "Compile todo o pseudocódigo em um bloco coeso com comentários.",
                                    "Adicione verificações: diagonais de R positivas, subdiagonal zero.",
                                    "Teste logicamente com matriz 3x2: A = [[1,2],[3,4],[5,6]]; compute R manualmente.",
                                    "Otimize: mencione vetorização possível ou paralelizações.",
                                    "Documente pré-condições (A real) e pós-condições (A vira R)."
                                  ],
                                  "verification": "Pseudocódigo roda sem erros lógicos em simulação manual; R obtido correto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de pseudocódigo, MATLAB/Python para validar implementação real.",
                                  "tips": "Inclua comentários em cada seção; formate com indentação consistente.",
                                  "learningObjective": "Produzir pseudocódigo robusto, testável e bem documentado.",
                                  "commonMistakes": "Faltam comentários; não testar com exemplo; ignorar casos edge como m<n ou singular."
                                }
                              ],
                              "practicalExample": "Para A = [[12, 6, -4], [0, -4, 0], [30, 0, 2]] (3x3):\n- k=1, i=2: já zero, pule.\n- k=1, i=3: a=12, b=30, r=sqrt(1444)=38, c=12/38≈0.316, s=-30/38≈-0.789. Aplicar j=1 a 3 nas linhas 1 e 3.\nResultado parcial: zera A[3][1]. Continue para k=2. Final R triangular.",
                              "finalVerifications": [
                                "Todos elementos abaixo da diagonal em A (agora R) são zero.",
                                "Normas das colunas preservadas: ||A col j|| = ||original col j|| para todo j.",
                                "Diagonais de R são positivas.",
                                "Pseudocódigo lida com m ≠ n corretamente.",
                                "Nenhum armazenamento extra de Qs; só variáveis c, s, temp.",
                                "Casos edge (r=0, matriz singular) tratados sem crash."
                              ],
                              "assessmentCriteria": [
                                "Loops aninhados corretos com limites exatos (k=1:min(m,n)-1, i=k+1:m, j=k:n).",
                                "Cálculo preciso de c, s com r=sqrt(a²+b²) e tratamento r=0.",
                                "Aplicação da rotação usa temporárias corretamente para update in-place.",
                                "Pseudocódigo claro, comentado e indentado profissionalmente.",
                                "Validação lógica com exemplo pequeno demonstra correção.",
                                "Eficiência: O(n²) operações sem storage extra para Q."
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Algoritmos numéricos e programação iterativa.",
                                "Física: Rotações em mecânica quântica e processamento de sinais.",
                                "Engenharia: Solvers de sistemas lineares em simulações estruturais.",
                                "Estatística: Regressão linear e PCA via QR."
                              ],
                              "realWorldApplication": "Usado em software como LAPACK/MATLAB para fatoração QR estável numericamente em machine learning (ex: least squares), compressão de imagens (JPEG2000), e simulações físicas (CFD) onde estabilidade sem pivoteamento é crítica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.2.1",
                              "10.1.3.5.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.6",
                    "name": "Aplicações da Decomposição QR",
                    "description": "Uso da QR em resolução de sistemas lineares e problemas de quadrados mínimos lineares.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.6.1",
                        "name": "Resolução de Sistemas Lineares via Decomposição QR",
                        "description": "Exploração da aplicação da decomposição QR para resolver sistemas lineares Ax = b de maneira numericamente estável, evitando a propagação de erros como na eliminação gaussiana direta, especialmente para matrizes quadradas bem condicionadas.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.6.1.1",
                            "name": "Compreender o processo de resolução por substituição retroativa",
                            "description": "Explicar passo a passo como, após obter A = QR com Q ortogonal e R triangular superior, resolver Rx = Q^T b por substituição retroativa, destacando a estabilidade devido à ortogonalidade de Q.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Decomposição QR e a Transformação do Sistema Linear",
                                  "subSteps": [
                                    "Lembre-se que A = QR, onde Q é ortogonal (Q^T Q = I) e R é triangular superior.",
                                    "Dado Ax = b, multiplique ambos os lados por Q^T: Q^T A x = Q^T b, que simplifica para R x = Q^T b.",
                                    "Verifique as propriedades: Q^T preserva a norma do vetor b (||Q^T b|| = ||b|| devido à ortogonalidade).",
                                    "Identifique c = Q^T b como o vetor de lado direito para o sistema Rx = c.",
                                    "Confirme que R é triangular superior com diagonais positivas (de Gram-Schmidt modificado)."
                                  ],
                                  "verification": "Escreva a equação Rx = Q^T b a partir de Ax = b e justifique usando Q^T Q = I.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou caderno",
                                    "Calculadora ou software como MATLAB/Octave",
                                    "Exemplo de matriz A 3x3"
                                  ],
                                  "tips": "Sempre normalize Q para evitar confusões com fatores de escala.",
                                  "learningObjective": "Compreender como a decomposição QR transforma o sistema original em um sistema triangular.",
                                  "commonMistakes": [
                                    "Esquecer de multiplicar b por Q^T",
                                    "Confundir Q com R nas propriedades",
                                    "Ignorar que Q é ortogonal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Estrutura da Substituição Retroativa em Matriz Triangular Superior",
                                  "subSteps": [
                                    "Observe que R é triangular superior: elementos abaixo da diagonal são zero.",
                                    "O sistema Rx = c tem equações onde x_n depende apenas de c_n e elementos de R na última linha.",
                                    "Comece resolvendo a última equação: x_n = c_n / R_{nn}.",
                                    "Prossiga retroativamente: para i = n-1 até 1, x_i = (c_i - sum_{j=i+1}^n R_{ij} x_j) / R_{ii}.",
                                    "Garanta que diagonais R_{ii} ≠ 0 para evitar divisão por zero."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito o processo genérico para uma matriz 3x3.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matriz R exemplo triangular 3x3",
                                    "Caneta e papel para diagrama"
                                  ],
                                  "tips": "Visualize a matriz R e marque os zeros abaixo da diagonal para facilitar.",
                                  "learningObjective": "Dominar a fórmula recursiva da substituição retroativa.",
                                  "commonMistakes": [
                                    "Iniciar pela primeira equação em vez da última",
                                    "Esquecer o sinal negativo na soma",
                                    "Dividir por zero sem checar diagonais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a Substituição Retroativa Passo a Passo",
                                  "subSteps": [
                                    "Calcule c = Q^T b multiplicando a matriz Q^T pelo vetor b.",
                                    "Inicie pelo último componente: x_n = c_n / R_{nn}.",
                                    "Para cada i de n-1 a 1: calcule a soma S = sum_{j=i+1}^n R_{ij} x_j, então x_i = (c_i - S) / R_{ii}.",
                                    "Registre todos os valores de x e verifique se Ax ≈ b (erro numérico pequeno).",
                                    "Repita com precisão decimal para observar estabilidade."
                                  ],
                                  "verification": "Resolva um sistema Rx = c numérico e confira com solução direta de Ax = b.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo numérico completo",
                                    "Software NumPy/Python ou calculadora matricial"
                                  ],
                                  "tips": "Use variáveis simbólicas inicialmente para clareza antes de números.",
                                  "learningObjective": "Aplicar o algoritmo de substituição retroativa com precisão.",
                                  "commonMistakes": [
                                    "Erro de sinal na subtração da soma",
                                    "Índices errados na soma",
                                    "Arredondamento prematuro"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar a Estabilidade Numérica Devido à Ortogonalidade de Q",
                                  "subSteps": [
                                    "Explique que Q ortogonal preserva normas: ||Q^T b||_2 = ||b||_2, evitando amplificação de erros.",
                                    "Compare com decomposição LU: fator L unitário pode amplificar erros, mas Q não.",
                                    "Discuta condição numérica: cond(A) = cond(R) pois cond(Q)=1.",
                                    "Simule perturbação em b e observe que erro em x é similar em magnitude.",
                                    "Conclua que QR é estável para sistemas bem condicionados."
                                  ]
                                },
                                "verification",
                                "estimatedTime",
                                "materials",
                                "tips",
                                "learningObjective",
                                "commonMistakes"
                              ],
                              "practicalExample": "Considere A = [[4, 1], [1, 3]], b = [5, 7]. Decomposição QR: Q ≈ [[0.97, -0.24], [0.24, 0.97]], R ≈ [[4.12, 2.37], [0, 2.83]]. Então c = Q^T b ≈ [5.49, 6.1]. Resolva Rx = c: x2 = 6.1 / 2.83 ≈ 2.16, x1 = (5.49 - 2.37*2.16)/4.12 ≈ 1.0. Verifique: Ax = [5,7] = b.",
                              "finalVerifications": [
                                "Explicar corretamente como Ax=b vira Rx=Q^T b.",
                                "Executar substituição retroativa sem erros aritméticos em exemplo 3x3.",
                                "Calcular Q^T b e notar preservação de norma.",
                                "Descrever fórmula recursiva x_i = (c_i - sum R_{ij}x_j)/R_{ii}.",
                                "Justificar estabilidade: cond(Q)=1 evita amplificação de erros.",
                                "Comparar estabilidade QR vs. Gauss direto."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual na transformação do sistema (100%).",
                                "Correção no algoritmo de substituição retroativa (90%+ acertos).",
                                "Compreensão de estabilidade numérica via ortogonalidade (explicação clara).",
                                "Habilidade em verificação numérica (erro <1e-10).",
                                "Uso correto de notação matricial e índices.",
                                "Identificação de erros comuns e prevenção."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python com numpy.linalg.qr e back-substitution.",
                                "Física Computacional: Resolver sistemas em simulações dinâmicas (e.g., FEM).",
                                "Machine Learning: Pré-condicionamento em regressão linear ou PCA.",
                                "Estatística: Cálculo de mínimos quadrados via QR estável."
                              ],
                              "realWorldApplication": "Usado em solvers de equações lineares em engenharia (e.g., análise estrutural), machine learning para regressão robusta e simulações científicas onde estabilidade numérica é crítica para grandes matrizes mal-condicionadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.6.1.2",
                            "name": "Analisar a estabilidade numérica da abordagem QR",
                            "description": "Comparar a sensibilidade numérica da resolução por QR com a eliminação gaussiana, utilizando conceitos de condição da matriz e perda de precisão em flutuação finita.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Estabilidade Numérica",
                                  "subSteps": [
                                    "Defina estabilidade numérica e distinção entre estabilidade forward e backward.",
                                    "Explique o número de condição de uma matriz A (cond(A)) e seu impacto na sensibilidade a perturbações.",
                                    "Discuta aritmética de ponto flutuante (flops) e erros de arredondamento acumulados.",
                                    "Revise normas de matrizes (ex: norma 2, norma Frobenius) usadas em análises de erro.",
                                    "Estude bounds de erro para operações matriciais básicas."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e dê um exemplo simples de uma matriz mal-condicionada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de álgebra numérica (ex: Golub & Van Loan), calculadora ou Python/NumPy para cond(A).",
                                  "tips": "Use exemplos pequenos (2x2) para visualizar crescimento de erros.",
                                  "learningObjective": "Compreender as bases teóricas de estabilidade e condição matricial.",
                                  "commonMistakes": "Confundir condição com rank; ignorar que cond(A) afeta ambos os métodos, mas diferentemente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Estabilidade da Eliminação Gaussiana",
                                  "subSteps": [
                                    "Descreva o processo de eliminação gaussiana com pivotação parcial.",
                                    "Derive bounds de crescimento de elementos durante a eliminação (fator de crescimento).",
                                    "Analise perda de precisão em flops finitos para matrizes mal-condicionadas.",
                                    "Calcule erro relativo forward para solução x de Ax=b.",
                                    "Discuta impacto da pivotação na estabilidade."
                                  ],
                                  "verification": "Aplique eliminação gaussiana manualmente a uma matriz 3x3 mal-condicionada e compare com solução exata.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel e caneta, MATLAB/Python para simular com eps máquina (machine epsilon).",
                                  "tips": "Sempre use pivotação; teste com matrizes de Hilbert para ilustrar instabilidade.",
                                  "learningObjective": "Identificar fontes de instabilidade na eliminação gaussiana.",
                                  "commonMistakes": "Esquecer pivotação, levando a overflow/underflow; superestimar estabilidade sem cond(A) alta."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Estabilidade da Decomposição QR",
                                  "subSteps": [
                                    "Revise Householder ou Givens para QR sem re-ortogonalização.",
                                    "Explique resolução de Ax=b via QR: resolver R y = Q^T b, então R x = y.",
                                    "Derive bounds de erro backward para QR (ortogonalidade preserva normas).",
                                    "Discuta independência do fator de crescimento em relação à pivotação.",
                                    "Compare flops: QR é O(n^3), similar à gaussiana."
                                  ],
                                  "verification": "Implemente QR via Householder em código e verifique ||Q^T Q - I|| < tol.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python (NumPy/SciPy) ou MATLAB, exemplos de código para QR.",
                                  "tips": "Verifique ortogonalidade numericamente após cada reflexão Householder.",
                                  "learningObjective": "Entender por que QR é backward stable independentemente da condição.",
                                  "commonMistakes": "Confundir QR com SVD; ignorar custo computacional extra vs. gaussiana."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Numericamente QR vs. Eliminação Gaussiana",
                                  "subSteps": [
                                    "Gere matrizes A com cond(A) variando de 10^2 a 10^12 (ex: Hilbert escalonada).",
                                    "Resolva Ax=b exato com ambos métodos em precisão dupla.",
                                    "Meça erros relativos ||x - x_exact|| / ||x_exact|| e residual ||Ax - b||.",
                                    "Plote erros vs. log(cond(A)) para visualização.",
                                    "Analise perda de dígitos: log10(eps) - log10(erros)."
                                  ],
                                  "verification": "Produza gráfico ou tabela mostrando QR superior em casos mal-condicionados.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python/MATLAB com NumPy/SciPy (qr, lu), gerador de matrizes Hilbert.",
                                  "tips": "Use b = A * x_exact com x_exact unitário para isolar erros numéricos.",
                                  "learningObjective": "Quantificar superioridade numérica da QR sobre gaussiana.",
                                  "commonMistakes": "Não perturbar b adequadamente; ignorar pivotação na gaussiana."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Conclusões e Limitações",
                                  "subSteps": [
                                    "Resuma: QR é backward stable (erro ~ eps * cond(A)), gaussiana depende de crescimento.",
                                    "Discuta trade-offs: QR mais estável mas 2x mais flops.",
                                    "Aborde extensões: QR com pivotação colunar para ranks.",
                                    "Relacione com aplicações onde estabilidade prevalece.",
                                    "Prepare relatório com achados."
                                  ],
                                  "verification": "Escreva um resumo de 300 palavras comparando os métodos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de texto, gráficos gerados anteriormente.",
                                  "tips": "Enfatize que nenhum método altera cond(A), mas QR preserva estrutura.",
                                  "learningObjective": "Integrar análises em comparação coerente.",
                                  "commonMistakes": "Super-generalizar: QR não é sempre melhor em tempo real."
                                }
                              ],
                              "practicalExample": "Considere A = [[1,1],[1,1+eps]] com eps=1e-10, cond(A)~1e10. Resolva Ax=[1,1]^T. Gaussiana sem pivot pode cancelar leading 1s, erro ~1; QR mantém ortogonalidade, erro ~1e-10.",
                              "finalVerifications": [
                                "Calcule cond(A) corretamente para matrizes teste.",
                                "Implemente ambos métodos e compare erros relativos.",
                                "Explique verbalmente por que QR é mais estável.",
                                "Identifique cenário onde gaussiana falha mas QR succeeds.",
                                "Gere plot de erros vs. condição.",
                                "Discuta bounds teóricos matching simulações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de bounds de erro (80% correto).",
                                "Correta implementação numérica sem bugs (erros < 1e-8).",
                                "Análise qualitativa profunda da comparação.",
                                "Uso apropriado de normas e machine epsilon.",
                                "Clareza em relatórios e visualizações.",
                                "Identificação de trade-offs computacionais."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em Python/MATLAB.",
                                "Análise Numérica: Teoria de erros em flops.",
                                "Física Computacional: Simulações estáveis em dinâmica.",
                                "Estatística: Regressão linear robusta via QR."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, resolver sistemas grandes mal-condicionados para simulações CFD; QR previne crashes por instabilidade, unlike gaussiana em grids finos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.6.1.3",
                            "name": "Implementar resolução de sistemas lineares com QR",
                            "description": "Desenvolver um algoritmo ou pseudocódigo para computar QR via Householder ou Givens e resolver Ax = b, testando com exemplos numéricos em software como MATLAB ou Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos teóricos da decomposição QR com Householder",
                                  "subSteps": [
                                    "Estude os refletos de Householder e como eles zeram elementos abaixo da diagonal.",
                                    "Revise a construção da matriz Householder H_k = I - 2 v v^T / ||v||^2 para cada coluna.",
                                    "Entenda o processo iterativo para triangularizar a matriz A em Q R.",
                                    "Analise propriedades: Q ortogonal, R upper triangular.",
                                    "Prepare pseudocódigo básico para QR."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando o algoritmo Householder QR e verifique com fórmulas corretas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Matrix Computations' de Golub e Van Loan (cap. 5)",
                                    "Notas de aula sobre Álgebra Linear Computacional",
                                    "Notebook Jupyter com Python/NumPy"
                                  ],
                                  "tips": "Comece com matrizes 2x2 para visualizar os refletos manualmente.",
                                  "learningObjective": "Compreender o mecanismo matemático da decomposição QR via Householder para implementação precisa.",
                                  "commonMistakes": [
                                    "Confundir normalização do vetor v (deve ser unitário)",
                                    "Esquecer de aplicar H_k apenas abaixo da diagonal",
                                    "Ignorar a acumulação de Q"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a decomposição QR usando Householder em Python",
                                  "subSteps": [
                                    "Defina função householder_qr(A) que retorna Q e R.",
                                    "Para cada coluna k de 0 a n-2: compute x = A[k:,k], u = x + sign(x[0])*||x||*e1, v = u/||u||.",
                                    "Construa H_k = I - 2*v*v.T e aplique H_k a A[k:,:].",
                                    "Acumule Q multiplicando pelas H_k transposas.",
                                    "Teste com matriz identidade para verificar ortogonalidade."
                                  ],
                                  "verification": "Execute qr_test() e confira ||Q^T Q - I|| < 1e-12 e ||A - Q R|| < 1e-10.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python 3 com NumPy e SciPy",
                                    "Documentação NumPy para np.linalg.norm e outer products",
                                    "Exemplos online de QR Householder"
                                  ],
                                  "tips": "Use np.eye para identidade e np.outer para v v^T eficientemente.",
                                  "learningObjective": "Desenvolver código funcional para QR decomposition estável numericamente.",
                                  "commonMistakes": [
                                    "Erro de sinal no vetor u (use sign(x[0]) para estabilidade)",
                                    "Aplicar Householder à toda matriz sem slicing k:",
                                    "Não acumular Q corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar resolução de Ax = b usando QR",
                                  "subSteps": [
                                    "Após QR, resolva R y = Q^T b via forward substitution (já que Q^T é simples).",
                                    "Implemente back-substitution para R y = c onde c = Q^T b.",
                                    "Crie função qr_solve(A, b) que chama householder_qr e resolve.",
                                    "Verifique com np.linalg.solve para comparação.",
                                    "Adicione tratamento para matrizes singulares (verificar diagonal de R)."
                                  ],
                                  "verification": "Para A conhecida, confira ||A x - b|| / ||b|| < 1e-10.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código do Step 2",
                                    "Funções NumPy: np.dot, np.linalg.solve",
                                    "Testes unitários com pytest"
                                  ],
                                  "tips": "Implemente back-substitution em loop explícito para clareza antes de vetorizar.",
                                  "learningObjective": "Integrar QR à resolução de sistemas lineares com precisão numérica.",
                                  "commonMistakes": [
                                    "Confundir Q^T b com Q b",
                                    "Back-substitution errada (dividir pelo diagonal de baixo para cima)",
                                    "Ignorar pivoteamento para ill-conditioned matrices"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar a implementação com exemplos numéricos",
                                  "subSteps": [
                                    "Gere matrizes aleatórias 5x5, 10x10 e resolva Ax=b com b randômico.",
                                    "Teste com Hilbert matrix (ill-conditioned) para checar estabilidade.",
                                    "Compare resíduos e tempo com np.linalg.solve.",
                                    "Plote erros relativos vs. condição da matriz.",
                                    "Documente resultados em relatório curto."
                                  ],
                                  "verification": "Todos testes passam com tolerância 1e-8; relatório mostra estabilidade superior a Gaussian elimination sem pivot.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "SciPy para matrices de teste (scipy.linalg.hilb)",
                                    "Matplotlib para plots",
                                    "Jupyter notebook para visualização"
                                  ],
                                  "tips": "Use cond(A) para medir condição e correlacionar com erro.",
                                  "learningObjective": "Avaliar robustez numérica da implementação em cenários reais.",
                                  "commonMistakes": [
                                    "Usar floats sem precisão dupla",
                                    "Não normalizar resíduos por ||b||",
                                    "Ignorar underflow em R diagonal"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[4, 1, 1], [1, 4, 2], [1, 2, 5]] e b = [7, 9, 14]. Implemente QR Householder, compute Q R ≈ A, resolva R y = Q^T b via back-substitution obtendo x ≈ [1, 2, 1], verifique A x ≈ b com erro < 1e-12 em Python.",
                              "finalVerifications": [
                                "Código executa sem erros para matrizes n=5 a 50.",
                                "||Q^T Q - I||_F < 1e-12 confirma ortogonalidade.",
                                "Resíduos ||A x - b|| / ||b|| < 1e-10 em testes aleatórios.",
                                "Solução bate com np.linalg.solve em 12 dígitos.",
                                "Estabilidade mantida para cond(A) até 1e6.",
                                "Tempo de execução razoável (O(n^3) escalável)."
                              ],
                              "assessmentCriteria": [
                                "Correção algorítmica: fórmulas Householder exatas.",
                                "Precisão numérica: erros < 1e-10 em double precision.",
                                "Eficiência: complexidade O(n^3) sem loops desnecessários.",
                                "Robustez: trata matrizes não-quadradas e singulares graciosamente.",
                                "Clareza código: comentários, funções modulares, docstrings.",
                                "Validação completa: múltiplos testes com métricas."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Algoritmos numéricos em Python/NumPy.",
                                "Física: Simulações de dinâmica linear (massa-mola systems).",
                                "Engenharia: Análise estrutural via equações lineares.",
                                "Machine Learning: Pré-processamento para regressão linear.",
                                "Estatística: Least squares com QR para multicolinearidade."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, resolve grandes sistemas lineares de equações de equilíbrio em estruturas (FEA), onde QR Householder garante estabilidade numérica superior à eliminação gaussiana para matrizes mal-condicionadas, evitando acumulação de erros em simulações de voo."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.6.2",
                        "name": "Quadrados Mínimos Lineares via Decomposição QR",
                        "description": "Aplicação da decomposição QR para resolver problemas de mínimos quadrados overdetermined min ||Ax - b||_2, onde A tem mais linhas que colunas, obtendo a solução x = (A^T A)^{-1} A^T b de forma estável.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.6.2.1",
                            "name": "Formular o problema de quadrados mínimos com QR",
                            "description": "Derivar matematicamente como A = QR leva à solução Rx = Q^T b para o problema normal, evitando a formação explícita de A^T A que pode ser mal condicionada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o problema de quadrados mínimos e equações normais",
                                  "subSteps": [
                                    "Lembre-se da formulação: encontrar x que minimiza ||Ax - b||_2^2 para A m x n (m >= n, rank(A)=n).",
                                    "Derive as equações normais: gradiente zero leva a A^T A x = A^T b.",
                                    "Discuta limitações: A^T A pode ser mal condicionada se cond(A) alto, amplificando erros numéricos.",
                                    "Escreva a solução pseudo-inversa: x = (A^T A)^{-1} A^T b.",
                                    "Pratique com uma matriz exemplo pequena para verificar."
                                  ],
                                  "verification": "Escreva as equações normais corretamente e identifique pelo menos dois problemas de A^T A.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor LaTeX/Mathematica",
                                    "Matriz exemplo: A = [[1,0],[0,1],[1,1]], b = [1,1,2.1]"
                                  ],
                                  "tips": "Use norma euclidiana explicitamente para clareza.",
                                  "learningObjective": "Entender a base teórica do problema de quadrados mínimos e suas vulnerabilidades numéricas.",
                                  "commonMistakes": [
                                    "Confundir norma L2 com L1",
                                    "Esquecer que A precisa ser de posto completo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a decomposição QR de A",
                                  "subSteps": [
                                    "Defina QR: A = Q R, onde Q m x n ortogonal (Q^T Q = I), R n x n triangular superior não-singular.",
                                    "Explique como obter QR via Gram-Schmidt ou Householder (sem detalhes de implementação).",
                                    "Verifique propriedades: ||Ax - b|| = ||QRx - b|| = ||Qx - R^{-1}b|| pois Q preserva norma (Q ortogonal).",
                                    "Mostre que minimizar ||Ax - b|| equiv a minimizar ||Rx - Q^T b||.",
                                    "Calcule Q^T b para o exemplo da Step 1."
                                  ],
                                  "verification": "Decomponha uma matriz A simples em QR e confirme Q^T Q = I.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou software como MATLAB/Python (numpy.linalg.qr)",
                                    "Exemplo A da Step 1"
                                  ],
                                  "tips": "Use QR 'econômica' (thin QR) para m > n.",
                                  "learningObjective": "Compreender como QR preserva a norma e simplifica o problema.",
                                  "commonMistakes": [
                                    "Confundir Q triangular com R",
                                    "Esquecer ortogonalidade de Q"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a solução Rx = Q^T b a partir das equações normais",
                                  "subSteps": [
                                    "Substitua A = QR nas normais: A^T A x = (QR)^T QR x = R^T Q^T Q R x = R^T R x (Q^T Q = I).",
                                    "Lado direito: A^T b = R^T Q^T b.",
                                    "Assim, R^T R x = R^T Q^T b; multiplique ambos lados por (R^T)^{-1}: R x = Q^T b.",
                                    "Resolva Rx = Q^T b por substituição retroativa (R triangular).",
                                    "Compare com solução direta de A^T A x = A^T b numericamente para o exemplo."
                                  ],
                                  "verification": "Derive passo a passo Rx = Q^T b e resolva para x no exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software numérico para comparar cond(A^T A) vs cond(R)",
                                    "Exemplo A, b da Step 1"
                                  ],
                                  "tips": "Anote cada igualdade matricial explicitamente.",
                                  "learningObjective": "Derivar matematicamente a formulação QR para quadrados mínimos.",
                                  "commonMistakes": [
                                    "Não cancelar R^T corretamente",
                                    "Usar Q em vez de Q^T"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar vantagens numéricas e formular o problema completo",
                                  "subSteps": [
                                    "Compare condicionamento: cond(A^T A) = [cond(A)]^2 >> cond(R) ≈ cond(A).",
                                    "Discuta estabilidade: QR evita formação de A^T A, reduzindo erros de arredondamento.",
                                    "Formule algoritmo: 1) QR de A; 2) c = Q^T b; 3) Rx = c via back-sub.",
                                    "Teste com exemplo mal-condicionado (A com linhas quase colineares).",
                                    "Resuma: 'QR resolve quadrados mínimos estável sem A^T A'."
                                  ],
                                  "verification": "Mostre numericamente que solução QR é mais precisa que normal para A mal-cond.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python/MATLAB com exemplo mal-cond: A = [[1,1],[1+eps,1],[1,1+eps]]"
                                  ],
                                  "tips": "Use eps = 1e-10 para simular condicionamento ruim.",
                                  "learningObjective": "Avaliar superioridade numérica da abordagem QR.",
                                  "commonMistakes": [
                                    "Ignorar que R pode ser singular se A não é",
                                    "Confundir estabilidade com exatidão analítica"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[1, 0], [0, 1], [1, 1]] (3x2), b = [1, 1, 2.1]^T. QR: Q ≈ [[0.58, -0.81], [0.58, 0.59], [0.58, 0.02]], R = [[1.73, 0.58], [0, 1]]. Q^T b ≈ [2.31, 0.59], Rx = Q^T b dá x ≈ [1.17, 0.59], aproximando b melhor que normais diretas com ruído.",
                              "finalVerifications": [
                                "Deriva corretamente R^T R x = R^T Q^T b → Rx = Q^T b.",
                                "Explica por que cond(R) < cond(A^T A).",
                                "Resolve Rx = Q^T b por back-substitution em exemplo.",
                                "Compara soluções numéricas QR vs normais em matriz mal-condicionada.",
                                "Formula o algoritmo completo em pseudocódigo."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (sem erros algébricos).",
                                "Compreensão de propriedades ortogonais de Q.",
                                "Análise correta de estabilidade numérica.",
                                "Uso apropriado de exemplo concreto com cálculos verificáveis.",
                                "Clareza na formulação final do problema QR.",
                                "Identificação de pelo menos 3 vantagens sobre equações normais."
                              ],
                              "crossCurricularConnections": [
                                "Computação Numérica: Implementação em bibliotecas como LAPACK.",
                                "Estatística: Regressão linear estável para modelagem de dados.",
                                "Programação: Código em Python/NumPy para QR via np.linalg.qr.",
                                "Física: Ajuste de dados experimentais em simulações."
                              ],
                              "realWorldApplication": "Em machine learning, resolve regressão linear estável para grandes datasets (ex: previsão de preços imobiliários), evitando instabilidade em matrizes de design mal-condicionadas; usado em GPS para ajuste de trajetórias ou em processamento de imagens para reconstrução."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.6.2.2",
                            "name": "Calcular soluções de mínimos quadrados numericamente",
                            "description": "Aplicar QR em exemplos práticos de regressão linear ou ajuste de curvas, computando resíduos e analisando a precisão da solução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o problema de mínimos quadrados",
                                  "subSteps": [
                                    "Identifique a matriz A (design matrix) e o vetor b a partir dos dados observados.",
                                    "Verifique as dimensões: A é m x n com m >= n e rank(A) = n.",
                                    "Formule o problema como minimizar ||Ax - b||_2.",
                                    "Escolha um exemplo prático, como dados de regressão linear simples.",
                                    "Registre os dados iniciais em uma tabela ou array."
                                  ],
                                  "verification": "Confirme que A e b estão corretamente dimensionados e o problema está bem definido.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e lápis ou software como Python (NumPy) ou MATLAB.",
                                  "tips": "Sempre normalize os dados se houver escalas muito diferentes para evitar instabilidades numéricas.",
                                  "learningObjective": "Entender a formulação matemática do problema de mínimos quadrados.",
                                  "commonMistakes": "Confundir linhas e colunas da matriz A; ignorar se A não tem posto completo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar a decomposição QR da matriz A",
                                  "subSteps": [
                                    "Aplique o processo Gram-Schmidt modificado ou Householder para decompor A = QR, onde Q é ortogonal e R é triangular superior.",
                                    "Compute as colunas de Q iterativamente, ortogonalizando vetores de A.",
                                    "Calcule R = Q^T A para verificar.",
                                    "Use uma biblioteca numérica (ex: qr() no NumPy) para praticar e comparar.",
                                    "Registre os valores de Q e R com precisão adequada."
                                  ],
                                  "verification": "Verifique se Q^T Q = I (ortogonalidade) e A ≈ Q R (multiplicação matricial).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora matricial, Python/MATLAB com funções QR.",
                                  "tips": "Prefira Householder para estabilidade numérica em implementações manuais.",
                                  "learningObjective": "Dominar o algoritmo QR e sua estabilidade para problemas mal condicionados.",
                                  "commonMistakes": "Perda de ortogonalidade devido a erros de arredondamento; não tratar casos de posto deficiente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver o sistema QR x = b",
                                  "subSteps": [
                                    "Compute c = Q^T b via multiplicação matricial.",
                                    "Resolva R x = c por substituição retroativa, já que R é triangular superior.",
                                    "Inicie da última equação e propague para cima.",
                                    "Verifique a solução x computando A x e comparando com b.",
                                    "Registre o vetor solução x."
                                  ],
                                  "verification": "Confirme que R x = Q^T b exato e ||A x - b|| é pequeno.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software numérico para back-substitution ou implementação manual.",
                                  "tips": "Use pivotação parcial se necessário, mas QR padrão assume A bem condicionado.",
                                  "learningObjective": "Aplicar resolução eficiente de sistemas triangulares no contexto de mínimos quadrados.",
                                  "commonMistakes": "Erro na ordem da substituição retroativa; ignorar componentes nulos em R."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar resíduos e analisar precisão",
                                  "subSteps": [
                                    "Calcule o resíduo r = b - A x.",
                                    "Compute a norma ||r||_2 e o erro relativo ||r|| / ||b||.",
                                    "Analise a precisão comparando com soluções exatas ou outras métodos (ex: normal equations).",
                                    "Interprete: resíduos pequenos indicam bom ajuste; examine distribuição para outliers.",
                                    "Gere um gráfico de resíduos vs. valores preditos se possível."
                                  ],
                                  "verification": "Resíduos têm norma mínima e distribuição aleatória sem padrões.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Gráficos via Matplotlib ou Excel; normas via NumPy.",
                                  "tips": "Compare com svd() para benchmark de precisão.",
                                  "learningObjective": "Avaliar a qualidade da solução QR em termos de precisão numérica e ajuste.",
                                  "commonMistakes": "Confundir resíduo com predito; não normalizar erros para interpretação."
                                }
                              ],
                              "practicalExample": "Considere dados de regressão linear: pontos (1,2), (2,3.1), (3,5), (4,4.9). Forme A = [[1,1],[1,2],[1,3],[1,4]] e b=[2,3.1,5,4.9]. Compute QR, resolva x para y = x0 + x1 t, resíduos ≈ [0.05, 0.05, -0.05, -0.05], norma ||r||≈0.1.",
                              "finalVerifications": [
                                "Decomposição QR satisfaz A = QR com ||A - QR|| < 1e-10.",
                                "Solução x minimiza ||Ax - b||_2.",
                                "Resíduos r = b - Ax têm norma mínima comparada a outras soluções.",
                                "Análise de precisão mostra estabilidade numérica (cond(A) considerado).",
                                "Gráfico de ajuste visualmente bom sem padrões nos resíduos.",
                                "Comparação com método SVD confirma x idêntico dentro de tolerância."
                              ],
                              "assessmentCriteria": [
                                "Correção na decomposição QR (ortogonalidade de Q e triangularidade de R).",
                                "Precisão na resolução do sistema triangular (erro < 1e-8).",
                                "Cálculo correto de resíduos e normas associadas.",
                                "Análise qualitativa adequada da precisão e interpretação dos resultados.",
                                "Uso eficiente de ferramentas numéricas sem erros de implementação.",
                                "Documentação clara dos passos e verificações intermediárias."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Regressão linear simples e análise de resíduos.",
                                "Computação: Algoritmos numéricos e programação matricial (NumPy, MATLAB).",
                                "Física: Ajuste de curvas a dados experimentais (ex: lei de Hooke).",
                                "Engenharia: Modelagem preditiva em controle de sistemas."
                              ],
                              "realWorldApplication": "Em machine learning para treinamento de modelos lineares estáveis (evita ill-conditioning das equações normais); análise de dados em bioinformática para fitting de curvas genéticas; engenharia civil para ajuste de modelos de deformação em estruturas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.6.2.3",
                            "name": "Avaliar vantagens da QR sobre métodos normais",
                            "description": "Discutir as vantagens numéricas da QR em termos de condição efetiva e robustez para matrizes rank-deficient, referenciando análises de sensibilidade de Golub e Van Loan.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Equações Normais e Suas Limitações Numéricas",
                                  "subSteps": [
                                    "Relembre a formulação dos quadrados mínimos lineares: minimizar ||Ax - b||_2 leva às equações normais A^T A x = A^T b.",
                                    "Implemente um exemplo simples em Python/MATLAB com uma matriz A bem condicionada e rank plena para resolver via equações normais.",
                                    "Perturbe A e b ligeiramente e observe a amplificação de erros na solução x devido ao fator kappa(A)^2.",
                                    "Discuta verbalmente por que A^T A tem condição numérica kappa(A^T A) ≈ kappa(A)^2.",
                                    "Registre os resultados numéricos para comparação futura."
                                  ],
                                  "verification": "Capacidade de derivar equações normais e demonstrar instabilidade numérica em um exemplo computacional com erro relativo > 10x o erro de entrada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy/SciPy ou MATLAB; matriz de exemplo 5x3 ill-conditioned (ex: Hilbert matrix truncada).",
                                  "tips": "Use cond(A) para medir condição; compare erros com norma euclidiana.",
                                  "learningObjective": "Entender a origem da instabilidade nas equações normais devido ao condicionamento quadrático.",
                                  "commonMistakes": "Confundir condição de A com A^T A; ignorar normalização de vetores."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Decomposição QR para Quadrados Mínimos",
                                  "subSteps": [
                                    "Aprenda a formulação QR para quadrados mínimos: com A = QR (Q ortogonal, R triangular superior), resolver Rx = Q^T b.",
                                    "Implemente Householder ou Givens QR em código ou use bibliotecas para um exemplo com a mesma A do Step 1.",
                                    "Compare soluções e erros de arredondamento com as equações normais no mesmo exemplo perturbado.",
                                    "Verifique numericamente que kappa(QR) ≈ kappa(A), preservando a condição original.",
                                    "Documente as diferenças em estabilidade observadas."
                                  ],
                                  "verification": "Solução via QR com erro relativo < 10x erro de entrada, contrastando com normais.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python/NumPy (np.linalg.qr) ou MATLAB qr(); mesmas matrizes do Step 1.",
                                  "tips": "Sempre normalize colunas de A antes; teste com pivoteamento para rank-deficiency.",
                                  "learningObjective": "Dominar como QR evita formação de A^T A, mantendo estabilidade.",
                                  "commonMistakes": "Esquecer de triangularizar R adequadamente; não usar Q^T b."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Condição Efetiva e Robustez em Matrizes Rank-Deficient",
                                  "subSteps": [
                                    "Estude matrizes rank-deficient: crie A com rank < n colunas, resolva LS com QR com pivoteamento.",
                                    "Compare com normais: observe singularidade explícita em A^T A vs. detecção via diagonal de R em QR.",
                                    "Calcule análises de sensibilidade: ||dx|| / ||x|| ≈ kappa(A) * ||dr|| / ||r|| para QR vs. kappa(A)^2 para normais.",
                                    "Teste numericamente com ruído, medindo robustez em soluções mínimas norma.",
                                    "Registre métricas como resíduo e norma da solução."
                                  ],
                                  "verification": "QR detecta rank-deficiency corretamente e fornece solução estável, enquanto normais falham ou amplificam erros.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Código do Step 2 estendido; matriz rank-deficient (ex: A com colunas lineares dependentes).",
                                  "tips": "Use qr com pivoteamento ('economy' mode); monitore ||R_{kk}|| para rank.",
                                  "learningObjective": "Compreender robustez de QR em casos patológicos via preservação de ortogonalidade.",
                                  "commonMistakes": "Não pivotear, levando a cancelamentos; assumir rank plena."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Referenciar Análises de Sensibilidade de Golub e Van Loan",
                                  "subSteps": [
                                    "Localize Seções 5.3.8 e 8.3 no livro 'Matrix Computations' de Golub & Van Loan (4ª ed.).",
                                    "Resuma teoremas de bound de erro: para QR, erro bounded por O(eps * kappa(A)); para normais, O(eps * kappa(A)^2).",
                                    "Aplique a um exemplo numérico, validando bounds teóricos.",
                                    "Discuta implicações para robustez em rank-deficient: QR permite underdetermined LS estável.",
                                    "Escreva um relatório comparativo citando as referências."
                                  ],
                                  "verification": "Relatório com citações precisas, bounds validados numericamente e vantagens quantificadas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Cópia do livro Golub & Van Loan; exemplos computacionais anteriores.",
                                  "tips": "Use eps máquina (np.finfo(float64).eps); foque em Teorema 8.3.1.",
                                  "learningObjective": "Integrar teoria de sensibilidade para justificar superioridade numérica da QR.",
                                  "commonMistakes": "Citar seções erradas; ignorar dependência em ulp (unit last place)."
                                }
                              ],
                              "practicalExample": "Considere A = [[1,1],[0.001,0],[0,0.001]] (rank-deficient aproximada), b = [1,0.002,0.001]^T. Equações normais amplificam erro em x2 ~10^6x; QR com pivoteamento dá x estável com resíduo mínimo.",
                              "finalVerifications": [
                                "Explicar verbalmente por que kappa(A^T A) = O(kappa(A)^2).",
                                "Demonstrar QR superior em exemplo ill-conditioned com métricas de erro.",
                                "Identificar rank via R em QR para matriz deficient.",
                                "Citar corretamente bounds de Golub & Van Loan (Seções 5.3.8, 8.3).",
                                "Comparar robustez em 3 cenários: bem-cond, ill-cond, rank-def.",
                                "Produzir relatório com plots de erros vs. perturbação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de condições numéricas (kappa^2 vs. kappa).",
                                "Correta implementação e interpretação de QR vs. normais.",
                                "Validação numérica com erros < 100x eps * kappa.",
                                "Referências teóricas exatas e aplicadas corretamente.",
                                "Análise qualitativa/quantitativa de robustez em rank-deficiency.",
                                "Clareza no relatório com exemplos e visualizações."
                              ],
                              "crossCurricularConnections": [
                                "Numérica Computacional: Análise de erros flutuantes.",
                                "Estatística: Regressão linear robusta.",
                                "Engenharia: Modelagem de sistemas sobdetermined.",
                                "Ciência de Dados: Processamento de signals com ruído."
                              ],
                              "realWorldApplication": "Em regressão linear para previsão de demanda (dados ruidosos/rank-def de sensores), QR evita overfitting e instabilidade vista em normais, como em processamento de imagens médicas ou otimização em ML."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.6.2.4",
                            "name": "Implementar QR para mínimos quadrados",
                            "description": "Codificar uma rotina para decomposição QR e resolução de mínimos quadrados, comparando com funções built-in como qr() no MATLAB e analisando erros em casos ill-conditioned.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos Teóricos de Decomposição QR e Mínimos Quadrados",
                                  "subSteps": [
                                    "Estude a definição de decomposição QR: A = QR onde Q é ortogonal e R é triangular superior.",
                                    "Revise o método dos mínimos quadrados: resolver min ||Ax - b||_2.",
                                    "Entenda como QR resolve mínimos quadrados: transformar em Rx = Q^T b.",
                                    "Analise estabilidade numérica de QR versus normal equations.",
                                    "Implemente um exemplo simples manualmente no papel para uma matriz 2x2."
                                  ],
                                  "verification": "Resuma em um parágrafo as vantagens de QR para mínimos quadrados e resolva um exemplo 2x2 à mão corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação MATLAB qr()",
                                    "Livro 'Matrix Computations' de Golub & Van Loan (capítulo QR)",
                                    "Notebook MATLAB"
                                  ],
                                  "tips": "Use diagramas para visualizar a projeção ortogonal em mínimos quadrados.",
                                  "learningObjective": "Compreender a base teórica para implementação estável de mínimos quadrados via QR.",
                                  "commonMistakes": [
                                    "Confundir QR com decomposição SVD",
                                    "Ignorar normalização em Q",
                                    "Esquecer que R pode ter zeros na diagonal para sub-rank"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Decomposição QR Usando Processo de Gram-Schmidt Modificado",
                                  "subSteps": [
                                    "Escreva função MATLAB para Gram-Schmidt modificado: inicialize Q como cópia de A.",
                                    "Para cada coluna j de 1 a n: subtraia projeções de colunas anteriores e normalize.",
                                    "Calcule R como produto superior Q' * A.",
                                    "Adicione verificação de ortogonalidade: norm(Q'*Q - eye(n)) < 1e-10.",
                                    "Teste com matriz identidade e uma matriz aleatória 5x5."
                                  ],
                                  "verification": "Execute qr_teste.m e confirme ||A - Q*R|| < 1e-12 e ||Q'*Q - I|| < 1e-10.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Editor",
                                    "Função built-in qr() para comparação",
                                    "Exemplos de código Gram-Schmidt online"
                                  ],
                                  "tips": "Use loops vetorizados onde possível para eficiência; reorthogonalize se necessário para precisão.",
                                  "learningObjective": "Codificar uma decomposição QR funcional e estável para matrizes mxn.",
                                  "commonMistakes": [
                                    "Não modificar Gram-Schmidt clássico para evitar perda de ortogonalidade",
                                    "Dividir por norma zero",
                                    "Esquecer transpose em R = Q' * A"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver Solucionador de Mínimos Quadrados Usando QR",
                                  "subSteps": [
                                    "Crie função qr_ls(A, b) que computa [Q, R] = qr_decomp(A).",
                                    "Calcule c = Q' * b.",
                                    "Resolva sistema triangular superior R(1:m,1:m) * x = c(1:m) usando back-substitution.",
                                    "Defina x(n+1:end) = 0 se sub-determinado.",
                                    "Implemente back-substitution manualmente sem rcond()."
                                  ],
                                  "verification": "Para A aleatório 5x3 e b, compare ||A*x - b|| com norma residual built-in.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB mldivide \\ para benchmark",
                                    "Código de back-substitution template"
                                  ],
                                  "tips": "Trate ranks deficientes checando diag(R) > tol.",
                                  "learningObjective": "Integrar QR em um solver completo para Ax ≈ b.",
                                  "commonMistakes": [
                                    "Usar todas linhas de R se rank < n",
                                    "Erro em back-substitution (dividir antes multiplicar)",
                                    "Ignorar parte de c além de rank"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Implementação com Funções Built-in e Testar Precisão",
                                  "subSteps": [
                                    "Gere matrizes A bem-condicionadas (cond(A) ~ 1e3) e compare x_qr vs A\\b.",
                                    "Meça erros relativos: norm(x_qr - x_builtin)/norm(x_builtin).",
                                    "Plote resíduos ||Ax - b|| para ambas implementações.",
                                    "Execute 10 trials com randn e tabule resultados médios.",
                                    "Documente em relatório MATLAB com tabelas e gráficos."
                                  ],
                                  "verification": "Relatório mostra erro relativo < 1e-10 para casos bem-condicionados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "cond() e rcond() funções MATLAB",
                                    "Scripts de teste randn(size(A))"
                                  ],
                                  "tips": "Use gallery('randsvd',n) para condicionados controlados.",
                                  "learningObjective": "Validar implementação contra standards numéricos.",
                                  "commonMistakes": [
                                    "Comparar apenas valores absolutos",
                                    "Não seed rand para reprodutibilidade",
                                    "Esquecer escalas em plots"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Comportamento em Casos Ill-Conditioned",
                                  "subSteps": [
                                    "Gere A ill-condicionada: gallery('randsvd', [m n], kappa) com kappa=1e12.",
                                    "Compare resíduos e erros em x para QR custom, built-in e normal eqs (A'*(b-A*x)=0).",
                                    "Plote cond(A), ||r||_2 e erro relativo vs kappa log.",
                                    "Discuta breakdown numérico: perda de ortogonalidade em Gram-Schmidt.",
                                    "Teste Householder QR built-in vs sua implementação."
                                  ],
                                  "verification": "Gráficos mostram QR superior a normal eqs em alta condição; erro QR < 1e-8 até kappa=1e10.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "gallery() MATLAB para testes padrão",
                                    "eps e macheps para análise numérica"
                                  ],
                                  "tips": "Logscale em kappa; normalize erros por ||x_true||.",
                                  "learningObjective": "Avaliar robustez numérica em problemas reais.",
                                  "commonMistakes": [
                                    "Usar cond() em vez de rcond() para rank",
                                    "Não perturbar b com ruído realista",
                                    "Confundir residual com erro em x"
                                  ]
                                }
                              ],
                              "practicalExample": "Ajuste de regressão linear: dados de temperatura vs vendas (A = [ones(n,1), temps], b = sales + noise). Implemente QR para estimar coeficientes beta, compare com polyfit(1, temps, sales) e visualize fit com scatter + plot.",
                              "finalVerifications": [
                                "Código qr_decomp() e qr_ls() rodam sem erros para m>=n>=2.",
                                "Ortogonalidade: norm(Q'*Q - eye(size(Q,2))) < 1e-12.",
                                "Residual médio ||Ax - b|| coincide com built-in em 1e-10 para cond<1e6.",
                                "Análise ill-conditioned mostra QR estável até cond=1e12.",
                                "Relatório com plots e tabelas gerado.",
                                "Tempo execução < 10x built-in para n=1000."
                              ],
                              "assessmentCriteria": [
                                "Correção teórica: explicação precisa de QR para LS (20%)",
                                "Implementação funcional e eficiente (30%)",
                                "Precisão numérica comprovada vs built-in (20%)",
                                "Análise ill-conditioned com evidências (20%)",
                                "Relatório claro com visualizações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Otimização de algoritmos em MATLAB/Python.",
                                "Estatística: Regressão linear e análise de resíduos.",
                                "Ciência de Dados: Pré-processamento para ML com SVD/QR.",
                                "Física Computacional: Simulações com sistemas lineares grandes."
                              ],
                              "realWorldApplication": "Em machine learning, QR é usado em feature engineering para regressão robusta em datasets grandes e ill-condicionados, como previsão de preços imobiliários com multicolinearidade em features (ex: scikit-learn QR solvers em pipelines)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.4",
                "name": "Quadrados Mínimos Lineares",
                "description": "Métodos para resolver problemas de mínimos quadrados lineares usando decomposições matriciais.",
                "totalSkills": 48,
                "atomicTopics": [
                  {
                    "id": "10.1.4.1",
                    "name": "Formulação do Problema de Mínimos Quadrados Lineares",
                    "description": "Definição matemática do problema de minimizar a norma euclidiana do resíduo em sistemas lineares Ax ≈ b.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.1.1",
                        "name": "Sistemas Lineares Sobredeterminados e Inconsistentes",
                        "description": "Compreensão dos sistemas lineares Ax = b onde o número de equações excede o número de variáveis, levando frequentemente a inconsistências, e a necessidade de soluções aproximadas.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.1",
                            "name": "Identificar sistemas sobredeterminados",
                            "description": "Reconhecer quando m > n em Ax = b, com A de dimensão m x n, e determinar se o sistema é consistente verificando se b está no espaço coluna de A.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a notação padrão de sistemas lineares Ax = b",
                                  "subSteps": [
                                    "Revise a notação: A é matriz m x n, x é vetor n x 1, b é vetor m x 1.",
                                    "Identifique as dimensões: linhas de A = m (equações), colunas de A = n (variáveis).",
                                    "Escreva exemplos simples: para m=2, n=2 (quadrado); m=3, n=2 (sobredeterminado).",
                                    "Desenhe diagramas visuais das dimensões para fixar o conceito.",
                                    "Pratique convertendo descrições verbais em notação matricial."
                                  ],
                                  "verification": "Construa corretamente a notação para 3 exemplos dados, sem erros dimensionais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora básica",
                                    "Folha de referência de dimensões matriciais"
                                  ],
                                  "tips": "Sempre verifique se as dimensões de A, x e b são compatíveis: colunas de A = linhas de x, linhas de A = linhas de b.",
                                  "learningObjective": "Dominar a notação e dimensões de sistemas lineares Ax = b.",
                                  "commonMistakes": [
                                    "Confundir m com n",
                                    "Esquecer que x é coluna",
                                    "Ignorar compatibilidade dimensional"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar sistemas sobredeterminados pela condição m > n",
                                  "subSteps": [
                                    "Defina sobredeterminado: mais equações (m) que variáveis (n), i.e., m > n.",
                                    "Compare dimensões em matrizes dadas: conte linhas (m) vs colunas (n).",
                                    "Classifique exemplos: subdeterminado (m < n), determinado (m = n), sobredeterminado (m > n).",
                                    "Crie seus próprios exemplos com m > n e verifique.",
                                    "Discuta implicações: geralmente inconsistentes, mas nem sempre."
                                  ],
                                  "verification": "Classifique corretamente 5 sistemas aleatórios como sobredeterminados ou não.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de matrizes de exemplo",
                                    "Planilha Excel para contagem rápida",
                                    "Software como Octave/MATLAB para dims"
                                  ],
                                  "tips": "Lembre: sobredeterminado é 'overdetermined', mais restrições que liberdades.",
                                  "learningObjective": "Reconhecer instantaneamente sistemas sobredeterminados pela desigualdade dimensional.",
                                  "commonMistakes": [
                                    "Confundir com subdeterminado",
                                    "Contar errado dimensões",
                                    "Ignorar casos m = n com rank menor"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar consistência: determinar se b está no espaço coluna de A",
                                  "subSteps": [
                                    "Entenda espaço coluna col(A): span das colunas de A.",
                                    "Verifique consistência: sistema consistente se rank([A|b]) = rank(A).",
                                    "Use eliminação gaussiana em [A|b] para comparar ranks.",
                                    "Para casos pequenos, resolva Ax = b e veja se solução existe.",
                                    "Pratique com exemplos onde b está/ não está em col(A)."
                                  ],
                                  "verification": "Para 3 sistemas sobredeterminados, determine corretamente consistência usando rank.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Matriz aumentada em papel",
                                    "Python/NumPy para rank (opcional)",
                                    "Tabela de ranks pré-computados"
                                  ],
                                  "tips": "Se rank([A|b]) > rank(A), inconsistente; senão, consistente.",
                                  "learningObjective": "Avaliar se sistema sobredeterminado é consistente via espaço coluna.",
                                  "commonMistakes": [
                                    "Confundir rank de A com [A|b]",
                                    "Erro em eliminação gaussiana",
                                    "Assumir sempre inconsistente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar identificação em contextos de mínimos quadrados",
                                  "subSteps": [
                                    "Relacione com mínimos quadrados: sobredeterminados inconsistentes levam a soluções aproximadas.",
                                    "Analise exemplo de regressão linear: A com pontos (x_i,1), b com y_i.",
                                    "Identifique m > n em dados reais (mais pontos que parâmetros).",
                                    "Verifique consistência em conjuntos de dados sintéticos.",
                                    "Resuma o processo completo em um fluxograma."
                                  ],
                                  "verification": "Crie e analise um sistema sobredeterminado de regressão, identificando e verificando.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Dados de exemplo em CSV",
                                    "Python/MATLAB para plot e rank",
                                    "Fluxograma em branco"
                                  ],
                                  "tips": "Pense em regressão: sempre m >> n para bom ajuste.",
                                  "learningObjective": "Integrar identificação sobredeterminada com problemas reais de mínimos quadrados.",
                                  "commonMistakes": [
                                    "Não reconhecer contexto de regressão",
                                    "Ignorar ruído em dados reais",
                                    "Confundir consistência com melhor aproximação"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o sistema de regressão linear simples: A = [[1, 1], [1, 2], [1, 3]] (m=3, n=2), b = [1, 2, 2.5]^T. Aqui m=3 > n=2, sobredeterminado. Compute rank(A)=2, rank([A|b])=2, logo consistente (b em col(A)). Se b=[1,2,4]^T, rank([A|b])=3 >2, inconsistente.",
                              "finalVerifications": [
                                "Define corretamente dimensões m e n em Ax=b.",
                                "Identifica m > n como sobredeterminado em 90% dos casos.",
                                "Verifica consistência via rank ou espaço coluna corretamente.",
                                "Explica implicações para mínimos quadrados.",
                                "Aplica em exemplo de regressão linear.",
                                "Cria fluxograma do processo de identificação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação dimensional (m vs n).",
                                "Correção no cálculo de ranks para consistência.",
                                "Clareza na explicação de espaço coluna.",
                                "Capacidade de gerar exemplos válidos.",
                                "Integração com contexto de álgebra computacional.",
                                "Ausência de erros comuns em verificações."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Formulação de regressão linear ordinária.",
                                "Computação: Uso de solvers como lsqr em NumPy/SciPy.",
                                "Física: Modelagem de sistemas com mais medições que parâmetros (ex: experimentos).",
                                "Engenharia: Otimização sob restrições sobredeterminadas.",
                                "Machine Learning: Overfitting em datasets grandes."
                              ],
                              "realWorldApplication": "Em análise de dados, como ajuste de curvas em experimentos científicos (ex: medir temperatura vs tempo com mais pontos que coeficientes do modelo polinomial), identificando sobredeterminação para aplicar mínimos quadrados e encontrar melhores estimativas apesar de inconsistências."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.2",
                            "name": "Construir exemplo de sistema inconsistente",
                            "description": "Criar e analisar um exemplo numérico simples de sistema sobredeterminado inconsistente, ilustrando por que não existe solução exata.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir as dimensões e estrutura básica do sistema sobredeterminado",
                                  "subSteps": [
                                    "Escolha o número de variáveis n (recomendado: 2 para simplicidade)",
                                    "Escolha o número de equações m maior que n (exemplo: m=3)",
                                    "Escreva a forma geral do sistema Ax = b, destacando que A é m x n com m > n",
                                    "Explique verbalmente por que sistemas sobredeterminados geralmente não têm solução exata",
                                    "Anote as dimensões escolhidas em um papel ou editor"
                                  ],
                                  "verification": "Dimensões m > n anotadas corretamente com explicação breve",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora opcional"
                                  ],
                                  "tips": "Use dimensões pequenas para facilitar cálculos manuais",
                                  "learningObjective": "Entender a definição e implicações de um sistema sobredeterminado",
                                  "commonMistakes": "Confundir sobredeterminado (m>n) com subdeterminado (m<n)"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz de coeficientes A com rank completo",
                                  "subSteps": [
                                    "Crie uma matriz A m x n com coeficientes numéricos simples (ex: inteiros pequenos)",
                                    "Verifique que as colunas de A são linearmente independentes (rank(A) = n)",
                                    "Use eliminação gaussiana ou determinante para confirmar rank completo",
                                    "Escreva A explicitamente no formato de equações lineares",
                                    "Teste se as primeiras n equações são consistentes entre si"
                                  ],
                                  "verification": "Matriz A escrita e rank confirmado como igual a n",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora para determinante"
                                  ],
                                  "tips": "Escolha coeficientes como 1, 2, 3 para evitar frações complicadas",
                                  "learningObjective": "Construir uma matriz A que maximize a chance de inconsistência genérica",
                                  "commonMistakes": "Criar A com rank < n, o que pode levar a subespaços inconsistentes prematuramente"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escolher o vetor b fora do espaço coluna de A",
                                  "subSteps": [
                                    "Baseado nas primeiras n equações de A, resolva para um b consistente parcial",
                                    "Altere uma entrada de b (ex: a última) para criar inconsistência",
                                    "Escreva o vetor b completo ao lado das equações",
                                    "Visualize geometricamente: b não no plano gerado pelas colunas de A",
                                    "Anote por que essa escolha garante inconsistência"
                                  ],
                                  "verification": "Vetor b escrito e diferença intencional com solução parcial destacada",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis"
                                  ],
                                  "tips": "Mude apenas uma equação para isolar a inconsistência claramente",
                                  "learningObjective": "Identificar condições algebricas e geométricas para inconsistência",
                                  "commonMistakes": "Escolher b acidentalmente no espaço coluna, resultando em solução exata"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar e analisar a inconsistência do sistema",
                                  "subSteps": [
                                    "Aplique substituição ou eliminação gaussiana ao sistema completo",
                                    "Identifique a contradição (ex: 0 = c onde c ≠ 0)",
                                    "Explique algebricamente que não existe x satisfazendo todas equações",
                                    "Discuta interpretação geométrica: b fora do espaço coluna",
                                    "Resuma por que isso motiva métodos aproximados como mínimos quadrados"
                                  ],
                                  "verification": "Processo de resolução mostra contradição explícita anotada",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora opcional"
                                  ],
                                  "tips": "Faça eliminação passo a passo para clareza visual",
                                  "learningObjective": "Analisar matematicamente a ausência de solução exata",
                                  "commonMistakes": "Parar na resolução parcial sem mostrar a contradição final"
                                }
                              ],
                              "practicalExample": "Considere n=2, m=3. Matriz A = [[2,1], [1,-1], [3,2]], b = [3,1,5]. Resolvendo as duas primeiras: x=4/3, y=-1/3. Na terceira: 3*(4/3) + 2*(-1/3) = 10/3 ≠ 5, provando inconsistência.",
                              "finalVerifications": [
                                "Sistema tem m > n equações e variáveis",
                                "Rank(A) = n confirmado",
                                "b não pertence ao espaço coluna de A",
                                "Eliminação gaussiana revela contradição (0 = c ≠ 0)",
                                "Explicação clara da ausência de solução exata",
                                "Interpretação geométrica ou algébrica incluída"
                              ],
                              "assessmentCriteria": [
                                "Correção matemática do exemplo (sem erros aritméticos)",
                                "Clareza na demonstração de inconsistência",
                                "Uso apropriado de dimensões sobredeterminadas",
                                "Análise da razão da inconsistência",
                                "Conexão com o conceito de mínimos quadrados",
                                "Organização e legibilidade da apresentação"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Fundamento para regressão linear por mínimos quadrados",
                                "Programação: Implementar em Python com NumPy para verificar rank e soluções",
                                "Física: Modelagem de dados experimentais com ruído de medição",
                                "Engenharia: Ajuste de curvas em projetos com superdeterminação de dados"
                              ],
                              "realWorldApplication": "Em experimentos científicos, como medir temperatura em múltiplos sensores (mais medições que parâmetros do modelo), erros de instrumento criam sistemas inconsistentes, exigindo mínimos quadrados para encontrar a melhor aproximação."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.3",
                            "name": "Explicar motivação para aproximações",
                            "description": "Justificar a necessidade de soluções aproximadas em sistemas reais de dados experimentais ou medições com ruído.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Sistemas Lineares Consistentes",
                                  "subSteps": [
                                    "Defina um sistema linear como Ax = b, onde A é a matriz de coeficientes, x o vetor de incógnitas e b o vetor de termos independentes.",
                                    "Explique que um sistema é consistente se existe uma solução exata x tal que Ax = b exatamente.",
                                    "Ilustre com um exemplo simples de 2 equações e 2 variáveis que tem solução única.",
                                    "Discuta cenários ideais onde dados são perfeitos e sem erros.",
                                    "Compare com a realidade onde equações derivam de medições."
                                  ],
                                  "verification": "Resuma em suas palavras a diferença entre sistemas consistentes e o que acontece se não houver solução exata.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Quadro branco ou papel para equações",
                                    "Calculadora básica"
                                  ],
                                  "tips": "Use exemplos numéricos pequenos para visualizar soluções exatas.",
                                  "learningObjective": "Identificar quando um sistema linear tem solução exata e seu significado em contextos ideais.",
                                  "commonMistakes": "Confundir consistência com independência linear das colunas de A."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Sistemas Sobredeterminados",
                                  "subSteps": [
                                    "Defina sistema sobredeterminado como tendo mais equações (m > n) que variáveis (n).",
                                    "Mostre matematicamente que m > n implica geralmente em inconsistência (Ax ≠ b).",
                                    "Crie um exemplo com 3 equações e 2 variáveis sem solução exata.",
                                    "Calcule o resíduo r = b - Ax para ilustrar discrepâncias.",
                                    "Discuta por que sobredeterminação ocorre em experimentos com múltiplas medições."
                                  ],
                                  "verification": "Construa um exemplo sobredeterminado e prove que não tem solução exata via cálculo do determinante ou rank.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software como Python/NumPy ou MATLAB para matrizes",
                                    "Folha de exercícios"
                                  ],
                                  "tips": "Sempre reduza a matriz aumentada para forma escalonada para visualizar inconsistência.",
                                  "learningObjective": "Reconhecer por que sistemas sobredeterminados raramente têm soluções exatas.",
                                  "commonMistakes": "Assumir que mais equações sempre levam a soluções melhores sem considerar inconsistência."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Impacto do Ruído em Dados Reais",
                                  "subSteps": [
                                    "Explique ruído como erros de medição, instrumentação ou fatores ambientais em dados experimentais.",
                                    "Modele b_real = b_perfeito + ε, onde ε é o vetor de ruído.",
                                    "Simule dados com ruído: gere pontos (x_i, y_i + ε_i) de uma linha perfeita y = mx + c.",
                                    "Mostre graficamente como ruído torna o sistema inconsistente.",
                                    "Discuta fontes comuns de ruído em física, engenharia e ciências."
                                  ],
                                  "verification": "Gere um conjunto de dados com ruído e plote para demonstrar discrepância visual.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com Matplotlib e NumPy",
                                    "Dados de exemplo de medições reais (ex: termômetro)"
                                  ],
                                  "tips": "Use distribuições normais para simular ruído realista (np.random.normal).",
                                  "learningObjective": "Entender como ruído introduz inconsistência em sistemas lineares reais.",
                                  "commonMistakes": "Ignorar que ruído é inevitável e tratar dados reais como perfeitos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar Necessidade de Soluções Aproximadas",
                                  "subSteps": [
                                    "Introduza o conceito de melhor aproximação: minimizar ||Ax - b|| (norma euclidiana).",
                                    "Explique que soluções aproximadas equilibram todas as equações com pesos iguais.",
                                    "Compare com ignorar equações (subselecionar) vs usar todas via mínimos quadrados.",
                                    "Discuta benefícios: robustez a ruído, uso de mais dados para precisão.",
                                    "Conclua que aproximações são essenciais para modelagem prática."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que mínimos quadrados é motivado em dados ruidosos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráfico de resíduos",
                                    "Exercícios de comparação de métodos"
                                  ],
                                  "tips": "Pense em termos geométricos: projeção de b no espaço-coluna de A.",
                                  "learningObjective": "Articular a motivação matemática e prática para soluções aproximadas.",
                                  "commonMistakes": "Confundir aproximação com 'solução errada'; enfatize minimização de erro."
                                }
                              ],
                              "practicalExample": "Em um experimento de física, mede-se a aceleração g em 5 quedas livres: dados y = [9.8, 9.7, 10.1, 9.9, 9.6] com posições x conhecidas. O sistema sobredeterminado Ax = b (A de x's, x=[g]) é inconsistente devido a ruído; mínimos quadrados encontra g ≈ 9.82 minimizando erros.",
                              "finalVerifications": [
                                "Explicar diferença entre sistemas consistentes e sobredeterminados inconsistentes.",
                                "Identificar ruído como causa primária de inconsistência em dados reais.",
                                "Descrever minimização de ||Ax - b||^2 como motivação para aproximações.",
                                "Aplicar conceito a um exemplo numérico simples.",
                                "Discutir por que usar todas as medições é superior a subsselecionar."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de sobredeterminado e inconsistente (80% correto).",
                                "Exemplo prático com ruído corretamente modelado e analisado.",
                                "Explicação clara da norma euclidiana como medida de erro.",
                                "Conexão explícita entre ruído experimental e necessidade de aproximação.",
                                "Uso de linguagem matemática apropriada sem erros conceituais.",
                                "Criatividade em analogias reais para motivação."
                              ],
                              "crossCurricularConnections": [
                                "Física: Medições experimentais com erros instrumentais.",
                                "Estatística: Modelos de regressão linear e variância de ruído.",
                                "Computação: Implementação numérica de solvers de mínimos quadrados.",
                                "Engenharia: Otimização em design de sistemas com dados sensoriais."
                              ],
                              "realWorldApplication": "Em machine learning, regressão linear usa mínimos quadrados para prever preços de casas a partir de features ruidosas como área e localização, encontrando parâmetros que melhor aproximam dados reais sem solução exata."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.2",
                        "name": "Resíduo e Norma Euclidiana",
                        "description": "Definição do vetor resíduo e sua norma euclidiana como medida de erro para avaliar a qualidade de uma solução aproximada.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.2.1",
                            "name": "Definir o vetor resíduo",
                            "description": "Estabelecer r = b - Ax como o vetor resíduo para uma aproximação x em Ax ≈ b, e interpretar seu significado geométrico como projeção ortogonal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Problema de Mínimos Quadrados Lineares",
                                  "subSteps": [
                                    "Lembre-se do setup: Dada uma matriz A (m x n, m > n) e vetor b (m x 1), encontrar x (n x 1) tal que Ax ≈ b.",
                                    "Entenda que soluções exatas podem não existir se b não estiver na coluna space de A.",
                                    "Discuta o objetivo: minimizar o erro ||b - Ax||_2.",
                                    "Visualize geometricamente: b em R^m, coluna space de A é subespaço.",
                                    "Pratique com dimensões pequenas: m=3, n=2."
                                  ],
                                  "verification": "Escreva o problema em notação matricial e identifique quando Ax = b não tem solução exata.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e lápis, matriz A e b de exemplo (ex: A = [[1,0],[0,1],[1,1]], b=[1,1,2])",
                                  "tips": "Desenhe vetores para visualizar o subespaço.",
                                  "learningObjective": "Compreender o contexto do problema sobredeterminado.",
                                  "commonMistakes": "Confundir A quadrada com sobredeterminado; assumir sempre solução exata."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Formalmente o Vetor Resíduo",
                                  "subSteps": [
                                    "Defina r = b - Ax para qualquer aproximação x.",
                                    "Calcule r numericamente para um x dado.",
                                    "Mostre que r mede o erro vertical entre b e a projeção Ax.",
                                    "Escreva a norma do resíduo: ||r||_2 = sqrt(r^T r).",
                                    "Verifique que r=0 iff b está na coluna space de A."
                                  ],
                                  "verification": "Compute r para x arbitrário e verifique se ||r||=0 quando possível.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora ou Python (numpy) para multiplicação matricial.",
                                  "tips": "Use x=0 inicialmente: r=b, erro máximo.",
                                  "learningObjective": "Definir e calcular o vetor resíduo matematicamente.",
                                  "commonMistakes": "Escrever r = Ax - b em vez de b - Ax; ignorar dimensões."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar o Significado Geométrico",
                                  "subSteps": [
                                    "Explique que a melhor x faz r ortogonal à coluna space de A: A^T r = 0.",
                                    "Desenhe: Ax é projeção ortogonal de b onto col(A), r é componente ortogonal.",
                                    "Prove geometricamente: menor distância é linha perpendicular.",
                                    "Visualize em 2D: linha (col(A)) e ponto b, pé da perpendicular é proj, r vertical.",
                                    "Conecte com teorema da projeção ortogonal."
                                  ],
                                  "verification": "Para exemplo, compute A^T r e confirme =0 para x ótimo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software de plotagem (Matplotlib ou GeoGebra) para vetores.",
                                  "tips": "Pense em sombras: Ax é 'sombra' de b na subspace.",
                                  "learningObjective": "Interpretar r como vetor ortogonal à subspace.",
                                  "commonMistakes": "Confundir ortogonalidade com paralelismo; esquecer A^T r=0."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar Conceitos",
                                  "subSteps": [
                                    "Resolva um problema completo: encontre x que minimiza ||r|| via normal equations.",
                                    "Compare r para x ruim vs x ótimo.",
                                    "Discuta implicações: resíduo captura erro não explicável por modelo.",
                                    "Estenda para múltiplas colunas: hiperplano em vez de linha.",
                                    "Questione: o que acontece se colunas lineares dependentes?"
                                  ],
                                  "verification": "Confirme A^T r = 0 e ||r|| mínimo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python ou MATLAB para normal equations (x = (A^T A)^{-1} A^T b).",
                                  "tips": "Sempre normalize vetores para visualização.",
                                  "learningObjective": "Integrar definição e geometria em solução prática.",
                                  "commonMistakes": "Não verificar ortogonalidade; assumir A invertível."
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 1], [1, 2], [1, 3]], b = [1, 2, 4]^T. Aproximação x = [0.5, 1]^T dá Ax ≈ [1.5, 2.5, 3.5]^T, r = [1-1.5, 2-2.5, 4-3.5]^T = [-0.5, -0.5, 0.5]^T. Verifique A^T r = [0, 0]^T (ortogonal). Geometricamente, r ⊥ col(A).",
                              "finalVerifications": [
                                "Calcula corretamente r = b - Ax para x dado.",
                                "Explica r como diferença vertical entre b e hiperplano Ax.",
                                "Demonstra A^T r = 0 para x ótimo.",
                                "Desenha representação geométrica precisa.",
                                "Identifica quando r=0 (solução exata).",
                                "Compara ||r|| para diferentes x."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de r (100% correto).",
                                "Correta interpretação geométrica (ortogonalidade).",
                                "Cálculos numéricos sem erros aritméticos.",
                                "Uso apropriado de notação matricial.",
                                "Explicação clara da minimização de ||r||_2.",
                                "Visualização geométrica convincente."
                              ],
                              "crossCurricularConnections": [
                                "Física: Vetores de erro em medidas experimentais e ajuste de dados.",
                                "Estatística: Resíduos em regressão linear.",
                                "Computação: Implementação numérica em solvers de LSQR.",
                                "Engenharia: Modelagem de sistemas sobredeterminados em controle."
                              ],
                              "realWorldApplication": "Em machine learning, resíduos medem erro de modelo em regressão linear; em processamento de imagens, ajustam curvas para detecção de bordas; em finanças, preveem séries temporais minimizando resíduos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.2.2",
                            "name": "Calcular a norma euclidiana do resíduo",
                            "description": "Computar ||r||_2 = sqrt(r^T r) para um dado resíduo r, e relacionar com a distância euclidiana entre b e o espaço coluna de A.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de resíduo e norma euclidiana",
                                  "subSteps": [
                                    "Defina o vetor resíduo r como r = b - Ax, onde A é a matriz, x a solução aproximada e b o vetor de dados.",
                                    "Explique a norma euclidiana ||r||_2 como a raiz quadrada da soma dos quadrados dos componentes de r: sqrt(r^T r).",
                                    "Relacione a norma com a distância euclidiana no espaço vetorial.",
                                    "Discuta o significado geométrico: minimizar ||r||_2 é encontrar o ponto no espaço-coluna de A mais próximo de b.",
                                    "Revise multiplicação matricial e produto interno para preparação."
                                  ],
                                  "verification": "Escreva definições corretas e um diagrama esquemático da interpretação geométrica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Álgebra Linear ou notas de aula"
                                  ],
                                  "tips": "Use analogias como 'distância entre pontos em um mapa' para visualizar melhor.",
                                  "learningObjective": "Entender conceitualmente o resíduo e sua norma como medida de erro e distância.",
                                  "commonMistakes": "Confundir norma L2 com L1 (soma absoluta) ou esquecer o significado geométrico."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o vetor resíduo r = b - Ax",
                                  "subSteps": [
                                    "Identifique a matriz A, vetor x (solução dos mínimos quadrados) e vetor b do problema dado.",
                                    "Compute Ax multiplicando a matriz A pelo vetor x.",
                                    "Subtraia Ax de b componente a componente para obter r.",
                                    "Verifique dimensionalidade: r deve ter o mesmo tamanho de b.",
                                    "Arredonde valores se necessário, mantendo precisão decimal."
                                  ],
                                  "verification": "Confira se cada componente de r está correta comparando com cálculo manual ou software.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora matricial ou software como Python (NumPy) ou MATLAB"
                                  ],
                                  "tips": "Faça os cálculos à mão primeiro para pequenos vetores para ganhar confiança.",
                                  "learningObjective": "Dominar o cálculo prático do vetor resíduo em problemas de mínimos quadrados.",
                                  "commonMistakes": "Erro na ordem da subtração (fazer Ax - b em vez de b - Ax) ou multiplicação matricial incorreta."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar a norma euclidiana ||r||_2 = sqrt(r^T r)",
                                  "subSteps": [
                                    "Calcule o produto interno r^T r: transpose de r vezes r (soma dos quadrados dos elementos).",
                                    "Some os quadrados de cada componente de r.",
                                    "Aplique a raiz quadrada ao resultado para obter ||r||_2.",
                                    "Use fórmula explícita: sqrt(∑ r_i²) para i=1 a n.",
                                    "Compare com norma de vetores unitários para validação (deve ser 1 para vetores unitários)."
                                  ],
                                  "verification": "Resultado deve ser um escalar não-negativo; teste com r=[3,4] → ||r||=5.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Planilha Excel ou Python para automação"
                                  ],
                                  "tips": "Lembre-se: r^T r é sempre positivo ou zero; zero indica solução exata.",
                                  "learningObjective": "Executar o cálculo numérico preciso da norma L2 do resíduo.",
                                  "commonMistakes": "Esquecer a raiz quadrada ou calcular soma de absolutos em vez de quadrados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar a norma como distância euclidiana entre b e o espaço-coluna de A",
                                  "subSteps": [
                                    "Desenhe o espaço vetorial: eixos para R^n, subespaço coluna(A) e pontos b e P_b (projeção).",
                                    "Identifique r como vetor perpendicular de P_b a b.",
                                    "Explique que ||r||_2 é o comprimento dessa perpendicular, mínima nos mínimos quadrados.",
                                    "Discuta implicações: quanto menor ||r||, melhor o ajuste.",
                                    "Relacione com propriedades ortogonais do resíduo em soluções LS."
                                  ],
                                  "verification": "Escreva uma frase explicando a relação e desenhe um diagrama 2D simples.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para diagrama",
                                    "Software de plotagem como GeoGebra ou Matplotlib"
                                  ],
                                  "tips": "Comece com n=2 para visualização fácil antes de generalizar.",
                                  "learningObjective": "Conectar cálculo numérico à interpretação geométrica do problema.",
                                  "commonMistakes": "Confundir espaço-coluna com espaço nulo ou ignorar perpendicularidade de r."
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 1], [1, 2]], b = [1, 3]^T. A solução LS é x ≈ [0.6667, 1.1667]^T. Então r = b - Ax ≈ [0, 0.3333]^T. ||r||_2 = sqrt(0^2 + 0.3333^2) ≈ 0.3333, que é a distância mínima de b ao espaço-coluna de A.",
                              "finalVerifications": [
                                "Cálculo de r = b - Ax está correto componente por componente.",
                                "||r||_2 = sqrt(r^T r) é um escalar preciso com pelo menos 4 casas decimais.",
                                "Interpretação geométrica é descrita corretamente como distância mínima.",
                                "Exemplo prático é resolvido sem erros aritméticos.",
                                "Relação com mínimos quadrados é explicitada.",
                                "Teste com caso trivial (A identidade) dá ||r||=0."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica no cálculo de r e ||r||_2 (erro < 0.01).",
                                "Compreensão conceitual demonstrada na interpretação geométrica.",
                                "Uso correto de notação matricial e vetorial.",
                                "Capacidade de generalizar para dimensões maiores.",
                                "Identificação de erros comuns evitados.",
                                "Clareza na explicação escrita ou verbal."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python/NumPy para automação (Computação Científica).",
                                "Física: Norma como magnitude de vetores de erro em trajetórias.",
                                "Estatística: ||r||_2 relacionado ao erro quadrático médio em regressão.",
                                "Geometria: Distâncias em espaços euclidianos."
                              ],
                              "realWorldApplication": "Em regressão linear para previsão de vendas (A: features, b: vendas reais), calcular ||r||_2 mede o erro de ajuste do modelo, ajudando a avaliar qualidade em machine learning ou engenharia."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.3",
                        "name": "Formulação do Problema de Mínimos Quadrados",
                        "description": "Enunciação matemática precisa do problema de encontrar x que minimiza ||Ax - b||_2, incluindo condições de existência e unicidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.3.1",
                            "name": "Enunciar o problema de mínimos quadrados lineares",
                            "description": "Formular matematicamente o problema como min_x ||Ax - b||_2^2, equivalente a min_x ||Ax - b||_2, para A m x n com m >= n.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o contexto do problema de mínimos quadrados",
                                  "subSteps": [
                                    "Revise o conceito de regressão linear simples: ajustar uma reta y = mx + c a pontos (x_i, y_i) minimizando a soma dos quadrados dos erros.",
                                    "Generalize para regressão múltipla: y depende de múltiplas variáveis, representado como um sistema linear Y = Xβ + ε.",
                                    "Identifique situações onde o número de equações (observações) excede o número de variáveis (m > n), formando um sistema sobredeterminado.",
                                    "Discuta por que soluções exatas Ax = b raramente existem devido a ruído nos dados.",
                                    "Explique intuitivamente que queremos encontrar x que minimize o erro de ajuste."
                                  ],
                                  "verification": "Escreva um parágrafo explicando por que usamos mínimos quadrados em sistemas sobredeterminado e dê um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear (capítulo de regressão)",
                                    "Vídeo introdutório sobre regressão linear (Khan Academy)"
                                  ],
                                  "tips": "Comece com um exemplo visual de pontos espalhados e a melhor reta de ajuste para fixar a intuição.",
                                  "learningObjective": "Entender a motivação e o contexto prático do problema de mínimos quadrados lineares.",
                                  "commonMistakes": [
                                    "Confundir com interpolação (que requer m = n)",
                                    "Ignorar o ruído nos dados reais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a notação matricial padrão",
                                  "subSteps": [
                                    "Defina A como a matriz de design m x n, onde m ≥ n, com linhas representando observações e colunas features.",
                                    "Defina b como o vetor de respostas de dimensão m x 1.",
                                    "Defina x como o vetor de parâmetros desconhecidos de dimensão n x 1.",
                                    "Escreva o modelo como Ax ≈ b, destacando que é uma aproximação.",
                                    "Verifique dimensões: confirme que Ax tem tamanho m x 1, compatível com b."
                                  ],
                                  "verification": "Construa um exemplo pequeno: A 3x2, b 3x1, e escreva Ax.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta para matrizes",
                                    "Software como MATLAB ou Python (NumPy) para testar dimensões"
                                  ],
                                  "tips": "Use matrizes pequenas (2x2 ou 3x2) para visualizar e evitar erros de dimensão.",
                                  "learningObjective": "Dominar a notação matricial Ax ≈ b para sistemas lineares sobredeterminado.",
                                  "commonMistakes": [
                                    "Confundir dimensões de A (linhas=observações, colunas=parâmetros)",
                                    "Esquecer m ≥ n"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir o resíduo e a norma L2",
                                  "subSteps": [
                                    "Defina o vetor de resíduos r = Ax - b.",
                                    "Introduza a norma euclidiana ||v||_2 = sqrt(∑ v_i^2), ou equivalentemente ||v||_2^2 = ∑ v_i^2.",
                                    "Mostre que minimizar ||r||_2 é equivalente a minimizar ||r||_2^2, pois a raiz quadrada é monótona.",
                                    "Escreva explicitamente ||Ax - b||_2^2 = ∑_{i=1}^m ( (Ax)_i - b_i )^2.",
                                    "Discuta por que a norma L2 é preferida: suaviza outliers comparado a L1."
                                  ],
                                  "verification": "Calcule ||Ax - b||_2^2 para um x dado em um exemplo 3x2 e compare com ||Ax - b||_2.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou Python para normas",
                                    "Folha com fórmulas de normas"
                                  ],
                                  "tips": "Lembre-se: para otimização, usamos o quadrado para evitar derivadas complicadas.",
                                  "learningObjective": "Compreender e formular matematicamente o erro de ajuste usando norma L2.",
                                  "commonMistakes": [
                                    "Confundir ||.||_2 com norma L1 (soma absoluta)",
                                    "Esquecer que equivalência é só para minimização"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Enunciar formalmente o problema de otimização",
                                  "subSteps": [
                                    "Escreva o problema como: encontrar argmin_x ||Ax - b||_2^2.",
                                    "Note a equivalência: argmin_x ||Ax - b||_2^2 = argmin_x ||Ax - b||_2.",
                                    "Especifique condições: A ∈ ℝ^{m×n}, m ≥ n, x ∈ ℝ^n.",
                                    "Discuta suposições implícitas: A de posto completo para unicidade.",
                                    "Reescreva em forma expandida para clareza: min_x ∑_{i=1}^m (a_i^T x - b_i)^2."
                                  ],
                                  "verification": "Escreva a formulação completa do problema para um exemplo dado e identifique m, n.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Template de fórmula para preencher",
                                    "Exemplos resolvidos de livros"
                                  ],
                                  "tips": "Pratique escrevendo a fórmula 3 vezes, variando notação (||.|| vs soma).",
                                  "learningObjective": "Enunciar precisamente o problema de mínimos quadrados lineares em notação matemática.",
                                  "commonMistakes": [
                                    "Escrever min ||A - x b|| em vez de ||Ax - b||",
                                    "Omitir dimensões de A"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere dados de temperatura (x) vs vendas de sorvete (y): A = [[1, 20], [1, 25], [1, 30]], b = [50, 60, 75]. O problema é min_x ||Ax - b||_2^2 para encontrar intercepto e inclinação que melhor ajustem os dados.",
                              "finalVerifications": [
                                "Pode enunciar o problema como min_x ||Ax - b||_2^2 com dimensões corretas.",
                                "Explica a equivalência entre minimizar a norma e seu quadrado.",
                                "Identifica corretamente A, x, b em um exemplo real.",
                                "Calcula o resíduo para um x dado.",
                                "Discute quando m > n leva a sobredeterminação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática (100% correto).",
                                "Compreensão conceitual: explica motivação sem erros.",
                                "Habilidade de aplicar a exemplos: constrói A, b corretamente.",
                                "Reconhece equivalências e condições (m ≥ n, posto).",
                                "Clareza na comunicação escrita da formulação.",
                                "Evita confusões comuns como norma errada."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Regressão linear ordinária (RLS).",
                                "Programação: Implementação em NumPy/SciPy (np.linalg.lstsq).",
                                "Física: Ajuste de curvas em experimentos (ex: lei de Hooke).",
                                "Machine Learning: Base para regressão linear em modelos preditivos.",
                                "Otimização: Introdução a problemas convexos não restritos."
                              ],
                              "realWorldApplication": "Em machine learning, usado para treinar modelos de regressão linear prevendo preços de casas a partir de features como tamanho e localização; em engenharia, ajusta parâmetros de sensores ruidosos para calibração precisa."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.2.1",
                              "10.1.4.1.2.2"
                            ]
                          },
                          {
                            "id": "10.1.4.1.3.2",
                            "name": "Derivar as equações normais",
                            "description": "Obter as equações normais A^T A x = A^T b a partir da condição de otimalidade ∇(||Ax - b||_2^2) = 0, e discutir quando A^T A é invertível.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a função objetivo do problema de mínimos quadrados",
                                  "subSteps": [
                                    "Relembre o problema: encontrar x que minimiza a norma ||Ax - b||_2^2, onde A é m x n, b é m x 1.",
                                    "Expanda a norma ao quadrado: f(x) = (Ax - b)^T (Ax - b).",
                                    "Desenvolva o produto: f(x) = x^T A^T A x - 2 x^T A^T b + b^T b.",
                                    "Identifique os termos quadrático, linear e constante.",
                                    "Verifique a forma quadrática positiva semidefinida."
                                  ],
                                  "verification": "Escreva a expressão expandida completa de f(x) e confirme que é uma função quadrática.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Exemplo de matriz A (ex: 3x2) e vetor b"
                                  ],
                                  "tips": "Use a propriedade (u-v)^T (u-v) = u^T u - 2 u^T v + v^T v para expandir corretamente.",
                                  "learningObjective": "Compreender a estrutura quadrática da função de custo nos mínimos quadrados.",
                                  "commonMistakes": [
                                    "Esquecer o fator 2 no termo linear",
                                    "Confundir A^T com A no desenvolvimento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o gradiente da função objetivo",
                                  "subSteps": [
                                    "Lembre-se que para f(x) = x^T Q x - 2 c^T x + d, ∇f(x) = 2 Q x - 2 c, onde Q = A^T A e c = A^T b.",
                                    "Derive componente a componente: ∂f/∂x_i = soma de termos envolvendo linhas de A.",
                                    "Use regras matriciais: ∇(x^T Q x) = (Q + Q^T) x, mas como Q simétrico, 2 Q x.",
                                    "Confirme ∇f(x) = 2 A^T A x - 2 A^T b.",
                                    "Teste com dimensão pequena para validar."
                                  ],
                                  "verification": "Escreva a expressão exata de ∇f(x) em termos de A, x e b.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora matricial opcional",
                                    "Folha com exemplo numérico simples"
                                  ],
                                  "tips": "Aproveite a simetria de A^T A para simplificar cálculos.",
                                  "learningObjective": "Dominar o cálculo do gradiente de funções quadráticas matriciais.",
                                  "commonMistakes": [
                                    "Esquecer o fator 2 no gradiente",
                                    "Invertar incorretamente A^T b"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer a condição de otimalidade",
                                  "subSteps": [
                                    "Defina a condição de mínimo local: ∇f(x) = 0.",
                                    "Substitua: 2 A^T A x - 2 A^T b = 0.",
                                    "Simplifique dividindo por 2: A^T A x = A^T b.",
                                    "Interprete como sistema linear normal com matriz A^T A e lado direito A^T b.",
                                    "Verifique que soluções satisfazem o mínimo se A^T A for definida positiva."
                                  ],
                                  "verification": "Derive e escreva explicitamente as equações normais A^T A x = A^T b.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para anotações",
                                    "Exemplo anterior para plug-in"
                                  ],
                                  "tips": "Sempre divida pelo 2 para obter a forma padrão das equações normais.",
                                  "learningObjective": "Conectar gradiente zero às equações normais clássicas.",
                                  "commonMistakes": [
                                    "Não simplificar o fator 2",
                                    "Escrever A A^T em vez de A^T A"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir a invertibilidade da matriz A^T A",
                                  "subSteps": [
                                    "Note que A^T A é simétrica ( (A^T A)^T = A^T A ) e semidefinida positiva.",
                                    "A^T A é definida positiva (invertível) se e só se as colunas de A são linearmente independentes (rank(A) = n).",
                                    "Conditione em dimensões: requer m >= n e posto completo.",
                                    "Se rank(A) < n, soluções múltiplas ou nenhuma (subespaço nulo).",
                                    "Exemplo: se A tem colunas dependentes, A^T A singular."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito quando A^T A tem inversa e dê contraexemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos de matrizes rank-deficient (ex: A com colunas iguais)"
                                  ],
                                  "tips": "Lembre: posto(A^T A) = posto(A), então invertível iff posto(A)=n.",
                                  "learningObjective": "Analisar condições para solução única nas equações normais.",
                                  "commonMistakes": [
                                    "Confundir com A A^T (que é n x m)",
                                    "Ignorar requisito m >= n"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 0], [0, 1], [1, 1]] (3x2), b = [1, 2, 3]^T. Compute f(x) = ||Ax - b||^2, ∇f(x) = 2[[3,2],[2,2]]x - 2[3,5]^T = 0, levando a [[3,2],[2,2]]x = [3,5]^T. Note det(A^T A)=2>0, invertível pois rank(A)=2.",
                              "finalVerifications": [
                                "Deriva corretamente A^T A x = A^T b a partir de ∇f(x)=0.",
                                "Expande f(x) sem erros aritméticos.",
                                "Identifica ∇f(x) = 2(A^T A x - A^T b).",
                                "Explica invertibilidade de A^T A via posto completo de A.",
                                "Fornece exemplo onde A^T A é singular.",
                                "Confirma que solução minimiza ||Ax-b||_2^2."
                              ],
                              "assessmentCriteria": [
                                "Precisão na expansão e derivação do gradiente (sem erros algébricos).",
                                "Correta simplificação para equações normais padrão.",
                                "Análise completa de invertibilidade com condições necessárias e suficientes.",
                                "Uso apropriado de notação matricial e propriedades.",
                                "Capacidade de aplicar em exemplo numérico simples.",
                                "Clareza na explicação de implicações (solução única vs múltipla)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Base para regressão linear ordinária (OLS).",
                                "Ciência da Computação: Pré-condicionamento em solvers numéricos como QR ou SVD.",
                                "Física: Ajuste de curvas a dados experimentais (ex: lei de Hooke).",
                                "Engenharia: Otimização em controle de sistemas lineares.",
                                "Machine Learning: Treinamento de modelos lineares via closed-form solution."
                              ],
                              "realWorldApplication": "As equações normais são usadas em regressão linear para prever preços de casas a partir de features como tamanho e localização, resolvendo x = (A^T A)^{-1} A^T b para coeficientes ótimos, essencial em data science e previsão econômica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.2.1",
                              "10.1.4.1.2.2"
                            ]
                          },
                          {
                            "id": "10.1.4.1.3.3",
                            "name": "Discutir existência e unicidade da solução",
                            "description": "Explicar que a solução existe sempre, é única se rank(A) = n, e múltipla caso contrário, com componente particular na pseudoinversa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Formulação do Problema de Mínimos Quadrados Lineares",
                                  "subSteps": [
                                    "Relembre o problema: dado A (m x n, m > n), b (m x 1), encontrar x que minimiza ||Ax - b||_2^2.",
                                    "Derive as equações normais: A^T A x = A^T b.",
                                    "Discuta o espaço de soluções: soluções x satisfazem as equações normais.",
                                    "Identifique que A^T A é simétrica e semi-definida positiva (PSD).",
                                    "Verifique se A^T b está sempre no range de A^T A."
                                  ],
                                  "verification": "Escreva as equações normais para um exemplo simples e confirme que A^T A é PSD.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora matricial ou Python (NumPy)"
                                  ],
                                  "tips": "Sempre compute o rank de A primeiro para contextualizar.",
                                  "learningObjective": "Compreender a base teórica das equações normais e sua sempre existência.",
                                  "commonMistakes": [
                                    "Confundir com sistemas quadrados exatos",
                                    "Ignorar que m > n tipicamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Existência da Solução",
                                  "subSteps": [
                                    "Explique por que a solução existe sempre: A^T A é PSD, range(A^T A) = range(A^T), e A^T b ∈ range(A^T).",
                                    "Discuta o núcleo (kernel) de A^T A: ker(A^T A) = ker(A).",
                                    "Mostre que o problema é consistentes independentemente do rank de A.",
                                    "Use um exemplo com rank(A) < n para ilustrar soluções no afim.",
                                    "Confirme numericamente com pseudoinversa."
                                  ],
                                  "verification": "Para uma matriz A singular, resolva A^T A x = A^T b e encontre pelo menos uma solução.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software NumPy ou MATLAB",
                                    "Exemplos de matrizes (fornecer 2x2 e 3x2)"
                                  ],
                                  "tips": "Lembre-se: existência é garantida pela projeção ortogonal.",
                                  "learningObjective": "Provar que soluções sempre existem para mínimos quadrados.",
                                  "commonMistakes": [
                                    "Pensar que rank baixo impede existência",
                                    "Confundir existência com unicidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Discutir Condições de Unicidade",
                                  "subSteps": [
                                    "Defina unicidade: solução única se e somente se ker(A) = {0}, i.e., rank(A) = n.",
                                    "Explique múltiplas soluções quando rank(A) < n: conjunto solução é x_p + ker(A), onde x_p é particular.",
                                    "Calcule rank(A) via SVD ou row reduction.",
                                    "Ilustre com exemplo: A com colunas dependentes leva a infinitas soluções.",
                                    "Verifique: dim(ker(A)) = n - rank(A) dá número de graus de liberdade."
                                  ],
                                  "verification": "Para A com rank < n, encontre duas soluções distintas e confirme ambas minimizam o erro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de SVD (NumPy.linalg.svd)",
                                    "Matrizes exemplo rank-deficient"
                                  ],
                                  "tips": "Use QR ou SVD para checar rank numericamente com cuidado para tolerâncias.",
                                  "learningObjective": "Determinar quando a solução é única baseada no rank.",
                                  "commonMistakes": [
                                    "Confundir rank(A) com rank(A^T A)",
                                    "Ignorar tolerâncias numéricas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Introduzir a Pseudoinversa e Solução Mínima",
                                  "subSteps": [
                                    "Defina pseudoinversa de Moore-Penrose: x = A^+ b, onde A^+ = V Σ^+ U^T via SVD.",
                                    "Explique que A^+ b é a solução particular de menor norma ||x||_2 quando múltiplas.",
                                    "Mostre propriedades: A A^+ A = A, etc.",
                                    "Compute para exemplo não único e compare com outras soluções.",
                                    "Discuta implementação computacional (np.linalg.pinv)."
                                  ],
                                  "verification": "Calcule x = A^+ b e verifique A x ≈ b projetado, e ||x|| mínimo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Exemplo de dados reais (regressão)"
                                  ],
                                  "tips": "Pseudoinversa lida automaticamente com rank baixo.",
                                  "learningObjective": "Usar pseudoinversa para obter solução canônica.",
                                  "commonMistakes": [
                                    "Usar inverse em vez de pinv",
                                    "Esquecer normalização de norma"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere dados de regressão linear: A = [[1,1],[1,2],[1,3]], b=[1,2,2.5]^T. rank(A)=2=n, solução única x ≈ [0.25, 0.75]. Agora, torne colunas dependentes adicionando ruído, rank<2, múltiplas soluções, pinv dá mínima norma.",
                              "finalVerifications": [
                                "Explicar verbalmente por que solução sempre existe.",
                                "Calcular rank(A) e concluir unicidade para dado A.",
                                "Encontrar solução particular e uma no kernel para caso não único.",
                                "Usar pinv para confirmar solução mínima norma.",
                                "Verificar numericamente ||A x - b|| para soluções candidatas.",
                                "Discutir estabilidade numérica via cond(A)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção existência vs. unicidade.",
                                "Correta identificação de condições rank(A)=n.",
                                "Uso apropriado de pseudoinversa em exemplos.",
                                "Compreensão do conjunto solução como afim.",
                                "Habilidade em computar e verificar via software.",
                                "Clareza em explicações teóricas e exemplos."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Regressão linear e mínimos quadrados.",
                                "Computação: Algoritmos numéricos e SVD.",
                                "Física: Modelagem de sistemas overdetermined.",
                                "Machine Learning: Otimização em redes neurais."
                              ],
                              "realWorldApplication": "Em machine learning, mínimos quadrados resolve regressão linear; pseudoinversa lida com features correlacionadas (multicolinearidade) em previsões financeiras ou análise de imagens."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.2",
                    "name": "Equações Normais",
                    "description": "Derivação e solução das equações normais AᵀAx = Aᵀb para mínimos quadrados.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.2.1",
                        "name": "Derivação das Equações Normais",
                        "description": "Processo matemático para derivar as equações normais AᵀAx = Aᵀb a partir da minimização da norma do resíduo no problema de mínimos quadrados lineares.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.1.1",
                            "name": "Formular o problema de mínimos quadrados",
                            "description": "Definir o problema como minimizar ||Ax - b||₂² para matriz A m×n com m ≥ n e vetor b ∈ ℝᵐ, identificando o resíduo r = Ax - b.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o contexto de sistemas lineares sobre-determinados",
                                  "subSteps": [
                                    "Revise o que é um sistema linear Ax = b, onde A é uma matriz m×n.",
                                    "Identifique situações em que m > n (mais equações que incógnitas).",
                                    "Explique por que esses sistemas geralmente não têm solução exata.",
                                    "Discuta a necessidade de encontrar uma solução aproximada que minimize o erro.",
                                    "Dê exemplos simples de dados reais que geram sistemas sobre-determinados."
                                  ],
                                  "verification": "Escreva um exemplo de sistema 3×2 sem solução exata e explique o motivo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Álgebra Linear ou notas de aula"
                                  ],
                                  "tips": "Comece com exemplos pequenos (m=3, n=2) para visualizar graficamente.",
                                  "learningObjective": "Entender por que sistemas sobre-determinados surgem e a importância de aproximações.",
                                  "commonMistakes": [
                                    "Confundir m < n (sub-determinado) com m > n",
                                    "Achar que todo sistema tem solução exata"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir os componentes matemáticos: matriz A, vetor b e vetor x",
                                  "subSteps": [
                                    "Defina A como matriz m×n com m ≥ n, representando coeficientes.",
                                    "Defina b ∈ ℝᵐ como o vetor de observações ou dados medidos.",
                                    "Defina x ∈ ℝⁿ como o vetor de parâmetros desconhecidos a serem estimados.",
                                    "Verifique as dimensões: Ax deve resultar em vetor m×1 compatível com b.",
                                    "Escreva notação explícita com dimensões."
                                  ],
                                  "verification": "Anote as dimensões exatas de A, x e b, e multiplique Ax para confirmar.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora para multiplicação matricial simples"
                                  ],
                                  "tips": "Use subscritos para clareza: A_{m×n}, b_{m×1}, x_{n×1}.",
                                  "learningObjective": "Dominar a notação e dimensões dos elementos do problema.",
                                  "commonMistakes": [
                                    "Invertar dimensões de A (n×m em vez de m×n)",
                                    "Esquecer que x é coluna"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir o conceito de resíduo r = Ax - b",
                                  "subSteps": [
                                    "Calcule o resíduo r como a diferença entre predição Ax e observação b.",
                                    "Confirme que r ∈ ℝᵐ, com dimensões compatíveis.",
                                    "Interprete r_i como erro na i-ésima equação ou observação.",
                                    "Discuta que o objetivo é tornar r o menor possível em norma.",
                                    "Escreva r explicitamente para um exemplo pequeno."
                                  ],
                                  "verification": "Para um sistema exemplo, compute r para um x arbitrário e interprete.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo numérico impresso ou anotado"
                                  ],
                                  "tips": "Lembre-se: ||Ax - b|| é invariante a sinal, mas use convenção Ax - b.",
                                  "learningObjective": "Identificar e calcular o vetor resíduo corretamente.",
                                  "commonMistakes": [
                                    "Escrever r = b - Ax em vez de Ax - b (embora equivalente na norma)",
                                    "Confundir resíduo com norma"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular a função objetivo de mínimos quadrados",
                                  "subSteps": [
                                    "Defina a norma L2 ao quadrado: ||r||₂² = ∑ r_i² = rᵀ r.",
                                    "Expanda: ||Ax - b||₂² = (Ax - b)ᵀ (Ax - b).",
                                    "Escreva a minimização: min_x ||Ax - b||₂².",
                                    "Confirme que é uma função escalar não-negativa.",
                                    "Relacione com soma de quadrados dos erros."
                                  ],
                                  "verification": "Escreva a formulação completa min_x ||Ax - b||₂² com dimensões e expansão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software como Python/Jupyter para testar expansão (opcional)"
                                  ],
                                  "tips": "Expanda algebricamente para ver AᵀAx - 2Aᵀb + bᵀb, preparando para derivadas.",
                                  "learningObjective": "Formular precisamente o problema de mínimos quadrados.",
                                  "commonMistakes": [
                                    "Usar norma L1 ou L∞ em vez de L2",
                                    "Esquecer o quadrado na norma"
                                  ]
                                }
                              ],
                              "practicalExample": "Em regressão linear simples: dados de altura (coluna 1 de A com 1's para intercepto, coluna 2 com alturas), b = pesos medidos (m=10 pontos). Encontre x = [intercepto, inclinação] minimizando ||A x - b||₂², que mede soma quadrados erros preditos vs reais.",
                              "finalVerifications": [
                                "Escreve corretamente as dimensões de A (m×n, m≥n), b (ℝᵐ) e x (ℝⁿ).",
                                "Define r = Ax - b e confirma dimensões de r.",
                                "Formula min_x ||Ax - b||₂² ou equivalente rᵀ r.",
                                "Expande ||Ax - b||₂² = xᵀ Aᵀ A x - 2 xᵀ Aᵀ b + bᵀ b.",
                                "Aplica a um exemplo numérico pequeno e interpreta.",
                                "Explica verbalmente o problema em contexto real."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação e dimensões (correta/parcial/incorreta).",
                                "Compreensão conceitual do resíduo e minimização.",
                                "Capacidade de expandir a norma quadraticamente.",
                                "Aplicação correta a exemplo prático.",
                                "Identificação de erros comuns evitados.",
                                "Clareza na explicação escrita/oral."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Base da regressão linear ordinária (OLR).",
                                "Computação: Implementação em NumPy/Python para resolver min ||Ax-b||.",
                                "Física: Ajuste de curvas a dados experimentais (ex: lei de Ohm).",
                                "Engenharia: Otimização em controle e modelagem de sistemas.",
                                "Machine Learning: Fundamento de perda quadrática em regressão."
                              ],
                              "realWorldApplication": "Usado em análise de dados para ajuste de modelos lineares, como previsão de vendas (regressão), processamento de sinais (filtro Wiener), compressão de imagens e aprendizado de máquina para minimizar erros em predições."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.2",
                            "name": "Derivar via cálculo variacional",
                            "description": "Calcular as derivadas parciais da função objetivo f(x) = ||Ax - b||₂² em relação a x e igualar a zero, obtendo ∇f(x) = 2Aᵀ(Ax - b) = 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir e expandir a função objetivo",
                                  "subSteps": [
                                    "Escreva a função objetivo f(x) = ||Ax - b||₂² explicitamente como f(x) = (Ax - b)^T (Ax - b).",
                                    "Expanda o produto escalar: f(x) = x^T A^T A x - 2 x^T A^T b + b^T b.",
                                    "Identifique os termos quadrático, linear e constante na expansão.",
                                    "Verifique a dimensionalidade: A é m x n, x é n x 1, b é m x 1.",
                                    "Anote a constante b^T b, que não afeta a minimização."
                                  ],
                                  "verification": "Confirme que a expansão algebraica está correta comparando com a forma matricial original.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Matriz A e vetor b de exemplo simples"
                                  ],
                                  "tips": "Use transposições corretamente; lembre-se que (Ax)^T = x^T A^T.",
                                  "learningObjective": "Compreender a representação escalar da norma L2 ao quadrado.",
                                  "commonMistakes": "Esquecer a transposição em (Ax - b)^T ou confundir ordens de multiplicação matricial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o gradiente da função f(x)",
                                  "subSteps": [
                                    "Lembre as regras de derivação matricial: ∇(x^T Q x) = (Q + Q^T) x; para Q simétrico, 2 Q x.",
                                    "Derive o termo quadrático: ∇(x^T A^T A x) = 2 A^T A x (pois A^T A é simétrico).",
                                    "Derive o termo linear: ∇(-2 x^T A^T b) = -2 A^T b.",
                                    "O termo constante tem gradiente zero.",
                                    "Some os gradientes: ∇f(x) = 2 A^T A x - 2 A^T b."
                                  ],
                                  "verification": "Teste com uma matriz 1x1 (escalar) para validar o gradiente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de derivadas matriciais",
                                    "Software como MATLAB ou Python (NumPy) para verificação numérica"
                                  ],
                                  "tips": "Pratique com casos escalares primeiro para ganhar intuição.",
                                  "learningObjective": "Aplicar regras de diferenciação matricial ao gradiente.",
                                  "commonMistakes": "Não multiplicar por 2 no termo quadrático ou errar o sinal no termo linear."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Igualar o gradiente a zero e simplificar",
                                  "subSteps": [
                                    "Defina ∇f(x) = 0: 2 A^T A x - 2 A^T b = 0.",
                                    "Divida por 2: A^T A x = A^T b.",
                                    "Reconheça isso como as equações normais dos quadrados mínimos.",
                                    "Discuta condições: assume A com colunas linearmente independentes para unicidade.",
                                    "Verifique reescrevendo como ∇f(x) = 2 A^T (A x - b) = 0."
                                  ],
                                  "verification": "Substitua x solução em ∇f(x) e confirme que é o vetor zero.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplo numérico com A 2x2",
                                    "Calculadora matricial"
                                  ],
                                  "tips": "Fatore o 2 A^T para ver a forma compacta ∇f(x) = 2 A^T (Ax - b).",
                                  "learningObjective": "Derivar as equações normais a partir do ponto crítico.",
                                  "commonMistakes": "Esquecer de dividir por 2 ou inverter a ordem A^T b."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e interpretar o resultado",
                                  "subSteps": [
                                    "Confirme que x = (A^T A)^{-1} A^T b é a solução (pseudo-inversa para A não quadrada).",
                                    "Relacione com projeção ortogonal: Ax é projeção de b sobre colunas de A.",
                                    "Teste numericamente com um sistema sobredeterminado.",
                                    "Discuta quando A^T A é invertível (rank(A) = n).",
                                    "Explique por que isso minimiza f(x)."
                                  ],
                                  "verification": "Resolva numericamente e compare com método de eliminação de variáveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy para solver",
                                    "Exemplo de regressão linear simples"
                                  ],
                                  "tips": "Use lsqr ou pinv em software para validar.",
                                  "learningObjective": "Interpretar o gradiente zero como condição de mínimo.",
                                  "commonMistakes": "Assumir A quadrada ou invertível sem checar rank."
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 0], [0, 1], [1, 1]], b = [1, 2, 3]^T. Expanda f(x) = (Ax - b)^T (Ax - b), derive ∇f(x) = 2 A^T (Ax - b), iguale a zero obtendo A^T A x = A^T b, resolva x ≈ [0.5, 1.5]^T.",
                              "finalVerifications": [
                                "Expansão de f(x) resulta em forma quadrática correta.",
                                "Gradiente calculado como 2 A^T (Ax - b).",
                                "Equações normais A^T A x = A^T b derivadas corretamente.",
                                "Verificação numérica confirma mínimo.",
                                "Interpretação como projeção ortogonal.",
                                "Discussão de condições de invertibilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na expansão escalar de ||Ax - b||².",
                                "Correta aplicação de regras de derivada matricial.",
                                "Simplificação adequada para equações normais.",
                                "Uso correto de transposições e simetria.",
                                "Validação numérica e interpretação conceitual.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Otimização em Machine Learning (gradiente descendente).",
                                "Física: Mínimos quadrados em ajuste de curvas experimentais.",
                                "Estatística: Regressão linear ordinária.",
                                "Computação: Algoritmos numéricos para solvers lineares."
                              ],
                              "realWorldApplication": "Em regressão linear para previsão de preços de casas (A: features, b: preços), minimizando erro L2 via equações normais para estimar coeficientes sem iterações."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.3",
                            "name": "Derivar via projeção ortogonal",
                            "description": "Interpretar a solução como projeção ortogonal de b no espaço-coluna de A, levando à condição Aᵀr = 0 e assim AᵀAx = Aᵀb.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Problema dos Quadrados Mínimos e a Projeção Ortogonal",
                                  "subSteps": [
                                    "Revise o problema: dado Ax ≈ b com A (m×n, m>n, rank n), minimize ||Ax - b||₂².",
                                    "Defina p = Ax como a projeção de b no espaço-coluna Col(A).",
                                    "Visualize geometricamente: p é o ponto em Col(A) mais próximo de b.",
                                    "Lembre que o vetor residual r = b - p é perpendicular a todo Col(A).",
                                    "Confirme: a projeção minimiza a distância euclidiana."
                                  ],
                                  "verification": "Desenhe um diagrama 2D mostrando b, p em uma linha (Col(A)) e r perpendicular.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis e borracha",
                                    "Livro de Álgebra Linear (cap. projeções)"
                                  ],
                                  "tips": "Use dimensões baixas (n=1 ou 2) para visualizar antes de generalizar.",
                                  "learningObjective": "Entender a interpretação geométrica da solução dos quadrados mínimos como projeção.",
                                  "commonMistakes": [
                                    "Confundir Col(A) com linha de regressão simples",
                                    "Ignorar a condição de rank completo de A"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o Vetor Residual e Sua Propriedade de Ortogonalidade",
                                  "subSteps": [
                                    "Defina r = b - Ax, onde x é a solução ótima.",
                                    "Estabeleça que r ⊥ Col(A), ou seja, r é ortogonal a toda coluna de A.",
                                    "Para todo vetor c em Col(A), <r, c> = 0.",
                                    "Como as colunas de A formam base de Col(A), r ⊥ a_j para j=1..n.",
                                    "Formalize: Aᵀ r = 0 (produto interno zero em cada componente)."
                                  ],
                                  "verification": "Escreva e verifique Aᵀ r = 0 para um exemplo numérico simples (A 3x2, b 3x1).",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Calculadora ou software como MATLAB/Octave",
                                    "Exemplo numérico impresso"
                                  ],
                                  "tips": "Comece com n=1: projeção em reta, r perpendicular à reta.",
                                  "learningObjective": "Reconhecer que o residual é ortogonal ao espaço-coluna na solução ótima.",
                                  "commonMistakes": [
                                    "Esquecer que ortogonalidade é para a base inteira, não só uma direção",
                                    "Confundir Aᵀ r = 0 com Ax = b"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Condição Aᵀ r = 0 Substituindo r",
                                  "subSteps": [
                                    "Substitua r = b - Ax na condição Aᵀ r = 0.",
                                    "Obtenha Aᵀ (b - Ax) = 0.",
                                    "Distribua: Aᵀ b - Aᵀ A x = 0.",
                                    "Reorganize: Aᵀ A x = Aᵀ b.",
                                    "Verifique dimensionalmente: Aᵀ A é n×n, Aᵀ b é n×1."
                                  ],
                                  "verification": "Complete a álgebra em papel e confira com um exemplo onde você resolva Aᵀ A x = Aᵀ b.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Folha de papel",
                                    "Caneta",
                                    "Exemplo de dados de regressão linear"
                                  ],
                                  "tips": "Anote cada igualdade em uma nova linha para evitar erros de álgebra.",
                                  "learningObjective": "Executar a derivação algébrica da condição de ortogonalidade para equações normais.",
                                  "commonMistakes": [
                                    "Erro de sinal em Aᵀ (b - Ax)",
                                    "Confundir transposição Aᵀ A com A Aᵀ"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e Verificar as Equações Normais",
                                  "subSteps": [
                                    "Identifique Aᵀ A x = Aᵀ b como as equações normais.",
                                    "Discuta existência/unicidade: Aᵀ A é simétrica positiva definida se rank(A)=n.",
                                    "Conecte de volta à minimização: gradiente de ||Ax-b||² é 2 Aᵀ (Ax - b) = 0 leva ao mesmo.",
                                    "Teste com exemplo: ajuste de reta y = mx + c para pontos (x_i, y_i).",
                                    "Resuma: projeção ⇒ ortogonalidade ⇒ equações normais."
                                  ],
                                  "verification": "Resolva numericamente um sistema e confirme ||r|| mínimo e Aᵀ r ≈ 0 (numérico).",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Software Python/MATLAB para least squares",
                                    "Dataset pequeno (5 pontos)"
                                  ],
                                  "tips": "Use qr() ou lsqr() para comparar solução exata vs projeção.",
                                  "learningObjective": "Consolidar a derivação completa e suas implicações.",
                                  "commonMistakes": [
                                    "Assumir A quadrada/invertível",
                                    "Ignorar multicolinearidade (rank < n)"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere dados de altura vs peso: A = [1 1.6; 1 1.7; 1 1.65; 1 1.8], b = [60; 65; 62; 70]. A projeção de b em Col(A) (planos afins) dá x = [c, m] para regressão linear, com r perpendicular às colunas (1 e alturas).",
                              "finalVerifications": [
                                "Explicar geometricamente por que r ⊥ Col(A).",
                                "Derivar AᵀAx = Aᵀb sem olhar notas.",
                                "Verificar Aᵀr = 0 em um exemplo numérico.",
                                "Discutir o que acontece se rank(A) < n.",
                                "Comparar com derivação via cálculo (gradiente).",
                                "Aplicar a um caso de regressão simples."
                              ],
                              "assessmentCriteria": [
                                "Correção geométrica da projeção ortogonal (peso 25%).",
                                "Precisão na definição e uso de r e Aᵀr=0 (peso 25%).",
                                "Álgebra impecável na derivação (peso 20%).",
                                "Interpretação das equações normais e condições (peso 15%).",
                                "Uso de exemplo prático com verificação numérica (peso 10%).",
                                "Clareza na explicação escrita/oral (peso 5%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Projeções em mecânica (componentes de forças).",
                                "Estatística: Fundamento da regressão linear ordinária (OLS).",
                                "Computação: Implementação de solvers QR ou SVD para least squares.",
                                "Engenharia: Ajuste de curvas em modelagem de dados experimentais.",
                                "Análise de Dados: Pré-processamento em machine learning."
                              ],
                              "realWorldApplication": "Em machine learning, essa derivação sustenta regressão linear para previsão de preços de casas (features em A, preços em b), minimizando erro de previsão com x otimizado via equações normais ou gradiente descendente."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.2",
                        "name": "Propriedades das Equações Normais",
                        "description": "Características algébricas da matriz normal AᵀA e do vetor direito Aᵀb, incluindo simetria, semi-definida positiva e condições de solvibilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.2.1",
                            "name": "Identificar simetria e PSD de AᵀA",
                            "description": "Verificar que AᵀA é simétrica (AᵀA = (AᵀA)ᵀ) e semi-definida positiva (xᵀAᵀAx = ||Ax||₂² ≥ 0), com autovalores não-negativos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e provar a simetria de AᵀA",
                                  "subSteps": [
                                    "Defina simetria: uma matriz M é simétrica se M = Mᵀ.",
                                    "Lembre propriedades de transposição: (AB)ᵀ = BᵀAᵀ e (Aᵀ)ᵀ = A.",
                                    "Calcule (AᵀA)ᵀ passo a passo: (AᵀA)ᵀ = Aᵀ (Aᵀ)ᵀ = Aᵀ A.",
                                    "Conclua que AᵀA = (AᵀA)ᵀ, logo simétrica.",
                                    "Teste com uma matriz A pequena para validar."
                                  ],
                                  "verification": "Escreva a prova algébrica e verifique se ambos os lados são iguais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora ou software como MATLAB/Octave (opcional)"
                                  ],
                                  "tips": "Sempre aplique propriedades de transposição da direita para a esquerda.",
                                  "learningObjective": "Dominar a prova de que AᵀA é simétrica usando propriedades de transposição.",
                                  "commonMistakes": [
                                    "Inverter a ordem na transposição de produto.",
                                    "Esquecer que (Aᵀ)ᵀ = A."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir e interpretar a forma quadrática xᵀ Aᵀ A x",
                                  "subSteps": [
                                    "Defina forma quadrática: xᵀ M x para matriz M simétrica.",
                                    "Expanda xᵀ Aᵀ A x.",
                                    "Reconheça que xᵀ Aᵀ A x = (Ax)ᵀ (Ax) = ||Ax||₂².",
                                    "Note que ||Ax||₂² é o quadrado da norma euclidiana, sempre ≥ 0.",
                                    "Verifique para x=0: resulta em 0."
                                  ],
                                  "verification": "Compute xᵀ Aᵀ A x para um vetor x específico e confirme igual a ||Ax||².",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo de matriz A 2x2",
                                    "Vetor x teste"
                                  ],
                                  "tips": "Visualize geometricamente: ||Ax||² mede o comprimento de Ax.",
                                  "learningObjective": "Entender que xᵀ Aᵀ A x representa uma norma ao quadrado.",
                                  "commonMistakes": [
                                    "Confundir xᵀ Aᵀ A x com Aᵀ A x.",
                                    "Ignorar que é sempre não-negativa."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar que AᵀA é semi-definida positiva (PSD)",
                                  "subSteps": [
                                    "Defina PSD: xᵀ M x ≥ 0 para todo x, com =0 só se x=0 (se definida positiva).",
                                    "Use o resultado do step 2: xᵀ Aᵀ A x = ||Ax||₂² ≥ 0 para todo x.",
                                    "Mostre que =0 implica Ax=0; se A tem posto cheio, x=0.",
                                    "Conclua que AᵀA é PSD.",
                                    "Discuta caso A não invertível (ainda PSD)."
                                  ],
                                  "verification": "Escreva a prova completa e teste com x não-nulo e nulo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Prova escrita",
                                    "Exemplos numéricos"
                                  ],
                                  "tips": "Ligue à geometria: norma nunca negativa.",
                                  "learningObjective": "Provar PSD de AᵀA via interpretação normativa.",
                                  "commonMistakes": [
                                    "Achar que precisa A invertível para PSD.",
                                    "Confundir PSD com definida positiva."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Confirmar PSD via autovalores de AᵀA",
                                  "subSteps": [
                                    "Lembre que para M simétrica, autovalores reais.",
                                    "Para PSD, todos autovalores λ ≥ 0.",
                                    "Teorema: M PSD iff todos autovalores ≥ 0.",
                                    "Como xᵀ M x = soma λ_i (xᵀ v_i)² ≥ 0, conclui.",
                                    "Compute autovalores de um AᵀA exemplo para verificar."
                                  ],
                                  "verification": "Calcule autovalores de AᵀA pequeno e confirme ≥0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matriz exemplo",
                                    "Ferramenta para autovalores (ex: numpy ou mão)"
                                  ],
                                  "tips": "Diagonalize M = Q Λ Qᵀ para ver somas ponderadas positivas.",
                                  "learningObjective": "Vincular PSD a autovalores não-negativos em AᵀA.",
                                  "commonMistakes": [
                                    "Achar autovalores complexos em simétricas.",
                                    "Ignorar multiplicidade em verificação."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 0], [0, 2]] (2x2). Então AᵀA = [[1, 0], [0, 4]], simétrica. Para x = [1, 1]ᵀ, xᵀ Aᵀ A x = 1*1 + 4*1 = 5, e Ax = [1, 2]ᵀ, ||Ax||² = 1+4=5 ≥0. Autovalores: 1 e 4, ambos >0.",
                              "finalVerifications": [
                                "Pode provar algébricamente AᵀA = (AᵀA)ᵀ?",
                                "Explica por que xᵀ Aᵀ A x = ||Ax||₂² ≥ 0?",
                                "Identifica condições para =0?",
                                "Confirma autovalores ≥0 em exemplo?",
                                "Aplica a propriedades das equações normais?"
                              ],
                              "assessmentCriteria": [
                                "Prova de simetria correta e concisa (100%).",
                                "Interpretação normativa precisa (100%).",
                                "Prova PSD completa sem erros (100%).",
                                "Uso correto de autovalores (80%).",
                                "Exemplo prático resolvido autonomamente (90%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Matrizes de Gram em mecânica (ex: momentos de inércia).",
                                "Computação: Otimização convexa e gradiente descendente.",
                                "Estatística: Matriz de covariância em regressão.",
                                "Engenharia: Análise de estabilidade em sistemas lineares."
                              ],
                              "realWorldApplication": "Em quadrados mínimos lineares (regressão), AᵀA PSD garante soluções únicas ou minimamente normadas via Cholesky/SVD, essencial em machine learning, processamento de imagens e previsão econômica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.2.2",
                            "name": "Analisar condições de unicidade",
                            "description": "Determinar que a solução é única se rank(A) = n (colunas linearmente independentes), pois AᵀA é definida positiva nesse caso.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos de rank e independência linear das colunas de A",
                                  "subSteps": [
                                    "Defina o rank de uma matriz A como a dimensão do espaço coluna.",
                                    "Explique independência linear: colunas de A são independentes se nenhuma é combinação linear das outras.",
                                    "Relacione rank(A) = n (número de colunas) com colunas linearmente independentes.",
                                    "Calcule rank(A) usando eliminação gaussiana em um exemplo 3x3.",
                                    "Verifique se rank(A) < n implica dependência linear."
                                  ],
                                  "verification": "Construa uma matriz A com rank(A) = n e confirme independência via determinante ou EGR.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Matriz A de exemplo (3x3)",
                                    "Calculadora ou software como MATLAB/Octave",
                                    "Folha de papel para cálculos manuais"
                                  ],
                                  "tips": "Sempre reduza a matriz à forma escalonada para visualizar o rank rapidamente.",
                                  "learningObjective": "Compreender que rank(A) = n garante colunas linearmente independentes.",
                                  "commonMistakes": "Confundir rank com dimensão das linhas; ignorar que rank(A) ≤ min(m,n)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular as equações normais a partir do problema de quadrados mínimos",
                                  "subSteps": [
                                    "Enuncie o problema: minimizar ||Ax - b||² para A (m x n), x (n x 1), b (m x 1).",
                                    "Derive as equações normais: gradiente zero leva a AᵀAx = Aᵀb.",
                                    "Identifique AᵀA como matriz n x n simétrica.",
                                    "Discuta o papel de AᵀA na solução x = (AᵀA)⁻¹ Aᵀb.",
                                    "Verifique com um exemplo numérico simples (m=2, n=1)."
                                  ],
                                  "verification": "Escreva as equações normais para um A e b dados e resolva x.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplo numérico: A = [[1,0],[0,1],[1,1]], b = [1,2,3]",
                                    "Software de álgebra linear"
                                  ],
                                  "tips": "Lembre-se: AᵀA é sempre simétrica, facilitando propriedades espectrais.",
                                  "learningObjective": "Derivar e entender as equações normais como condição de otimalidade.",
                                  "commonMistakes": "Esquecer o Aᵀb no lado direito; assumir m = n sempre."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar propriedades de AᵀA e sua definitude positiva",
                                  "subSteps": [
                                    "Prove que AᵀA é simétrica: (AᵀA)ᵀ = Aᵀ(Aᵀ)ᵀ = AᵀA.",
                                    "Mostre que xᵀ(AᵀA)x = ||Ax||² ≥ 0 para todo x ≠ 0.",
                                    "Conclua que AᵀA é semi-definida positiva; definida positiva se ||Ax|| = 0 implica x=0.",
                                    "Relacione com independência: ker(A) = {0} iff colunas independentes iff rank(A)=n.",
                                    "Calcule autovalores de AᵀA em exemplo para verificar positividade.",
                                    "Discuta singularidade se rank(A) < n."
                                  ],
                                  "verification": "Para A com rank=n, compute xᵀ(AᵀA)x > 0 para x≠0.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Matrizes de exemplo com rank cheio e deficiente",
                                    "Software para autovalores (eig em MATLAB)"
                                  ],
                                  "tips": "Use a identidade ||Ax||² para intuitivamente entender positividade.",
                                  "learningObjective": "Reconhecer AᵀA definida positiva sob rank(A)=n.",
                                  "commonMistakes": "Confundir semi-definida com definida; ignorar ker(A)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar a condição de unicidade da solução",
                                  "subSteps": [
                                    "Estabeleça: solução única se AᵀA invertível.",
                                    "Prove: AᵀA invertível iff rank(A)=n (pois rank(AᵀA)=rank(A)).",
                                    "Conclua unicidade: rank(A)=n ⇒ colunas independentes ⇒ solução única.",
                                    "Discuta caso rank(A)<n: infinitas soluções (espaço nulo).",
                                    "Aplique em regressão linear: full column rank para coeficientes únicos."
                                  ],
                                  "verification": "Dada A, compute rank(A); se =n, afirme unicidade e resolva.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exemplos de A com rank=n e <n",
                                    "Ferramentas de rank (svd ou rref)"
                                  ],
                                  "tips": "Verifique rank via SVD: número de singular values não-nulos.",
                                  "learningObjective": "Analisar unicidade via rank(A)=n e propriedades de AᵀA.",
                                  "commonMistakes": "Assumir unicidade sem checar rank; confundir com solvibilidade de Ax=b."
                                }
                              ],
                              "practicalExample": "Em regressão linear simples: A = [[1, x1], [1, x2], ..., [1, xm]] (design matrix com intercepto). Se os xi são distintos, rank(A)=2 (n=2), logo solução única para coeficientes β0, β1 minimizando erro quadrático.",
                              "finalVerifications": [
                                "Explique verbalmente por que rank(A)=n implica AᵀA definida positiva.",
                                "Dado A 4x3 com rank=2, identifique ausência de unicidade.",
                                "Resolva equações normais para A com rank cheio e verifique x único.",
                                "Prove que se rank(A)<n, existe x≠0 com AᵀAx=0.",
                                "Aplique em dados reais: verifique rank antes de fitar modelo.",
                                "Diferencie unicidade em quadrados mínimos vs. sistemas exatos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de AᵀA definida positiva.",
                                "Correta identificação de rank(A)=n como condição necessária e suficiente.",
                                "Uso correto de exemplos numéricos para ilustrar unicidade.",
                                "Compreensão de implicações para soluções múltiplas.",
                                "Aplicação conceitual em contextos como regressão.",
                                "Clareza na distinção entre semi-definida e definida positiva."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Condição para estimadores de MCO únicos em regressão.",
                                "Computação: Condicionamento numérico de AᵀA em solvers iterativos.",
                                "Física: Unicidade em ajustes de curvas para dados experimentais.",
                                "Otimização: Convexidade estrita em problemas quadráticos.",
                                "Machine Learning: Full rank em feature matrices para modelos lineares."
                              ],
                              "realWorldApplication": "Em análise de dados, garante que modelos de regressão linear tenham parâmetros únicos, evitando ambiguidades em previsões financeiras, previsão de demanda ou ajuste de curvas em engenharia."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.2.3",
                            "name": "Verificar consistência do sistema",
                            "description": "Confirmar que Aᵀb está no espaço-coluna de AᵀA se b ∈ range(A) ou via nulidade, garantindo solvibilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender as propriedades fundamentais das matrizes envolvidas",
                                  "subSteps": [
                                    "Defina range(A), range(Aᵀ) e range(AᵀA).",
                                    "Lembre que range(AᵀA) = range(Aᵀ) para qualquer matriz A real.",
                                    "Explique por que isso implica que Aᵀb sempre pertence a range(AᵀA), garantindo consistência do sistema normal.",
                                    "Verifique dimensionalmente: dim(range(AᵀA)) = rank(AᵀA) = rank(A).",
                                    "Confirme com teorema da nulidade: nul(AᵀA) = nul(A)."
                                  ],
                                  "verification": "Você pode provar que range(AᵀA) ⊆ range(Aᵀ) e range(Aᵀ) ⊆ range(AᵀA), concluindo igualdade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Livro de Álgebra Linear ou notas de aula",
                                    "Calculadora matricial opcional"
                                  ],
                                  "tips": "Visualize graficamente para matrizes pequenas: range(Aᵀ) é o espaço ortogonal ao kernel(A).",
                                  "learningObjective": "Compreender as propriedades espectrais e de range das equações normais.",
                                  "commonMistakes": [
                                    "Confundir range(AᵀA) com range(A)",
                                    "Ignorar que rank(AᵀA) = rank(A)",
                                    "Esquecer que AᵀA é simétrica e semidefinida positiva."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar se b pertence ao range(A)",
                                  "subSteps": [
                                    "Compute o vetor de resíduos r = b - A x_particular para alguma solução particular x_particular.",
                                    "Verifique se r ⊥ range(A), i.e., Aᵀ r = 0.",
                                    "Use o teste de consistência: resolva A x = b e veja se existe solução exata.",
                                    "Calcule rank([A | b]) e compare com rank(A); se iguais, b ∈ range(A).",
                                    "Se b ∈ range(A), então existe x tal que A x = b exatamente."
                                  ],
                                  "verification": "Confirme que rank(A) = rank([A | b]), provando b ∈ range(A).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software como MATLAB, Python (NumPy) ou Octave",
                                    "Matriz A e vetor b de exemplo"
                                  ],
                                  "tips": "Para matrizes pequenas (2x3), faça row reduction manualmente no augmented matrix.",
                                  "learningObjective": "Aplicar testes de consistência para sistemas lineares originais.",
                                  "commonMistakes": [
                                    "Usar pseudoinversa prematuramente sem verificar consistência",
                                    "Confundir solvibilidade com solução única",
                                    "Erros em row reduction levando a ranks errados."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Confirmar que Aᵀb está no range(AᵀA)",
                                  "subSteps": [
                                    "Compute Aᵀb e AᵀA explicitamente.",
                                    "Verifique se existe y tal que AᵀA y = Aᵀb (sistema normal).",
                                    "Use a propriedade: Aᵀb ∈ range(Aᵀ) sempre, e como range(AᵀA) = range(Aᵀ), segue que ∈ range(AᵀA).",
                                    "Teste via nulidade: verifique se Aᵀ(b - A z) = 0 para algum z.",
                                    "Se b ∈ range(A), escolha z tal que A z = b, então Aᵀb = Aᵀ A z ∈ range(AᵀA)."
                                  ],
                                  "verification": "Resolva o sistema normal e confirme que a solução satisfaz ||A x - b|| minimizado ou zero se consistente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy para computações matriciais",
                                    "Exemplo numérico impresso"
                                  ],
                                  "tips": "Sempre normalize A se necessário, mas foque em propriedades teóricas primeiro.",
                                  "learningObjective": "Provar a consistência das equações normais usando ranges.",
                                  "commonMistakes": [
                                    "Achar que o sistema normal é consistente só se o original for",
                                    "Não perceber que é sempre consistente",
                                    "Cálculos matriciais com dimensões erradas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar teorema da nulidade e concluir solvibilidade",
                                  "subSteps": [
                                    "Estabeleça nul(AᵀA) = nul(A) pelo teorema fundamental da álgebra linear.",
                                    "Verifique consistência via orthogonalidade: Aᵀ(A x - b) = 0 para soluções x.",
                                    "Conclua que o sistema normal é solúvel com soluções no conjunto afim x_0 + nul(A).",
                                    "Discuta singularidade: múltiplas soluções se rank(A) < n.",
                                    "Resuma: consistência garantida independentemente de b, mas exatidão se b ∈ range(A)."
                                  ],
                                  "verification": "Escreva uma prova curta mostrando que para qualquer b, existe x tal que AᵀA x = Aᵀb.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de teoremas de álgebra linear",
                                    "Quadro branco para diagramas"
                                  ],
                                  "tips": "Use diagramas de espaços vetoriais para visualizar ranges e kernels.",
                                  "learningObjective": "Usar nulidade para analisar o número de soluções.",
                                  "commonMistakes": [
                                    "Confundir nul(AᵀA) com nul(Aᵀ)",
                                    "Ignorar o caso de A não-cheio rank",
                                    "Concluir inconsistência erroneamente."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 0], [0, 1], [1, 1]] (3x2), b = [1, 2, 3]^T. Compute AᵀA = [[2,1],[1,2]], Aᵀb = [2,3]^T. Verifique rank(A)=2=rank([A|b]). Resolva AᵀA x = Aᵀb → x ≈ [1,1]^T. Confirme Aᵀb ∈ range(AᵀA) pois det(AᵀA)≠0 e solução única existe.",
                              "finalVerifications": [
                                "Provar que range(AᵀA) = range(Aᵀ).",
                                "Verificar numericamente rank(A) = rank([A|b]) para b ∈ range(A).",
                                "Mostrar que Aᵀ(b - proj_range(A) b) = 0.",
                                "Resolver sistema normal e validar ||A x - b||^2 mínimo.",
                                "Explicar por que nul(AᵀA) determina o grau de liberdade nas soluções."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de ranges e nulidades.",
                                "Correta aplicação de testes de consistência (rank).",
                                "Prova teórica completa sem gaps lógicos.",
                                "Exemplo numérico resolvido corretamente.",
                                "Explicação clara de implicações para quadrados mínimos.",
                                "Uso apropriado de ferramentas computacionais."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação em NumPy para least squares (SciPy.linalg.lstsq).",
                                "Física: Modelagem de sistemas overdetermined em mecânica.",
                                "Estatística: Regressão linear múltipla e resíduos.",
                                "Engenharia: Otimização de parâmetros em controle linear."
                              ],
                              "realWorldApplication": "Em regressão linear para previsão de vendas (dados overdetermined), verifica-se consistência para garantir que o modelo de quadrados mínimos seja solúvel, permitindo ajustes precisos de coeficientes mesmo com ruído nos dados."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.3",
                        "name": "Solução das Equações Normais",
                        "description": "Métodos computacionais para resolver o sistema AᵀAx = Aᵀb, considerando estabilidade numérica e condicionamento.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.3.1",
                            "name": "Resolver via inversão direta",
                            "description": "Computar x = (AᵀA)⁻¹ Aᵀb quando AᵀA é invertível, discutindo desvantagens numéricas devido ao condicionamento κ(AᵀA) = [κ(A)]².",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Verificar pré-condições de invertibilidade de AᵀA",
                                  "subSteps": [
                                    "Confirmar que a matriz A tem posto completo (rank(A) = n, onde n é o número de colunas).",
                                    "Explicar que AᵀA é simétrica positiva definida se A tem colunas linearmente independentes.",
                                    "Testar invertibilidade computando determinante ou usando decomposição SVD/Cholesky preliminar.",
                                    "Discutir implicações: se não invertível, equações normais não têm solução única.",
                                    "Verificar dimensionalidade: A m×n com m ≥ n."
                                  ],
                                  "verification": "AᵀA possui inversa confirmada por det(AᵀA) ≠ 0 ou rank completo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matriz A de exemplo",
                                    "Software como MATLAB, Python (NumPy) ou calculadora matricial"
                                  ],
                                  "tips": "Sempre priorize testes numéricos estáveis como SVD para verificação em prática.",
                                  "learningObjective": "Entender condições para que AᵀA seja invertível e seu impacto na solução única.",
                                  "commonMistakes": "Assumir invertibilidade sem verificar rank; ignorar m < n."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar AᵀA e Aᵀb",
                                  "subSteps": [
                                    "Calcular Aᵀ, transposta de A.",
                                    "Multiplicar Aᵀ por A para obter AᵀA (n×n).",
                                    "Multiplicar Aᵀ por b para obter Aᵀb (vetor n×1).",
                                    "Verificar simetria de AᵀA e dimensões corretas.",
                                    "Armazenar resultados para próximos passos."
                                  ],
                                  "verification": "Matrizes AᵀA simétrica e Aᵀb com dimensões corretas, sem erros de cálculo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matriz A e vetor b",
                                    "Ferramentas computacionais (NumPy, MATLAB)"
                                  ],
                                  "tips": "Use funções built-in como np.dot(A.T, A) para evitar erros manuais.",
                                  "learningObjective": "Dominar multiplicações matriciais envolvidas nas equações normais.",
                                  "commonMistakes": "Confundir AᵀA com AAᵀ; erros em transposições."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a inversa de AᵀA e obter x",
                                  "subSteps": [
                                    "Computar (AᵀA)⁻¹ usando método de Gauss-Jordan, LU ou função inv().",
                                    "Multiplicar (AᵀA)⁻¹ por Aᵀb para obter x.",
                                    "Verificar solução: ||Ax - b||² mínimo comparando com b.",
                                    "Implementar em código para automação.",
                                    "Comparar com solução exata se conhecida."
                                  ],
                                  "verification": "x satisfaz Ax ≈ b (resíduo pequeno) e Aᵀ(Ax - b) ≈ 0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "AᵀA e Aᵀb computados",
                                    "Software com função de inversa (SciPy, MATLAB)"
                                  ],
                                  "tips": "Evite inversão direta em software; prefira solve() para estabilidade, mas use inv() aqui para aprendizado.",
                                  "learningObjective": "Executar computação direta da solução via inversa das equações normais.",
                                  "commonMistakes": "Usar inversa de AAᵀ em vez de AᵀA; arredondamentos em cálculos manuais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar desvantagens numéricas e condicionamento",
                                  "subSteps": [
                                    "Calcular κ(A), número de condição de A via ||A|| ||A⁻¹|| ou SVD.",
                                    "Mostrar que κ(AᵀA) = [κ(A)]², amplificando erros.",
                                    "Simular exemplo com A mal-condicionado (ex: Vandermonde).",
                                    "Comparar erro em x com métodos alternativos (QR, SVD).",
                                    "Discutir por que evitar inversão direta na prática."
                                  ],
                                  "verification": "Relatório com κ(AᵀA) = [κ(A)]² e exemplo de amplificação de erro demonstrado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de matrizes mal-condicionadas",
                                    "Ferramentas para condição number (np.linalg.cond)"
                                  ],
                                  "tips": "Use log-scale para visualizar amplificação de erros em gráficos.",
                                  "learningObjective": "Compreender impactos numéricos da inversão direta em quadrados mínimos.",
                                  "commonMistakes": "Ignorar que κ(AᵀA) é quadrático; subestimar sensibilidade a ruído."
                                }
                              ],
                              "practicalExample": "Dado A = [[1, 1], [1, 1.0001], [1, 1.0002]] (3x2, mal-condicionado) e b = [1, 1.0001, 1.0003]ᵀ. Compute AᵀA ≈ [[3, 3.0003], [3.0003, 3.0009]], inverta (com κ grande), Aᵀb ≈ [3.0001, 3.0013]ᵀ, x ≈ [0.5, 5000] mas com erro amplificado devido a κ(AᵀA) ≈ 10^8.",
                              "finalVerifications": [
                                "Computa corretamente x para A e b dados.",
                                "Verifica invertibilidade de AᵀA.",
                                "Calcula κ(A) e demonstra [κ(A)]² = κ(AᵀA).",
                                "Identifica resíduo ||Ax - b||² mínimo.",
                                "Explica pelo menos 3 desvantagens numéricas.",
                                "Compara com método QR/SVD."
                              ],
                              "assessmentCriteria": [
                                "Precisão na computação de x (erro < 1e-6).",
                                "Correta verificação de pré-condições.",
                                "Análise qualitativa e quantitativa de condicionamento.",
                                "Uso correto de notação matemática.",
                                "Identificação de erros numéricos em exemplos.",
                                "Clareza na discussão de desvantagens."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python com NumPy/SciPy.",
                                "Estatística: Regressão linear ordinária (OLS).",
                                "Computação Científica: Métodos numéricos estáveis (QR, SVD).",
                                "Física: Ajuste de curvas em dados experimentais."
                              ],
                              "realWorldApplication": "Em regressão linear para previsão de vendas (A: features, b: vendas), mas evitar inversão direta devido a dados ruidosos/mal-condicionados; prefira solvers estáveis em machine learning (scikit-learn)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.3.2",
                            "name": "Aplicar fatoração Cholesky",
                            "description": "Explorar AᵀA = RᵀR com R triangular superior via Cholesky, resolvendo sistemas triangulares para maior estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar as equações normais",
                                  "subSteps": [
                                    "Calcule a matriz AᵀA multiplicando A transpose por A.",
                                    "Calcule o vetor Aᵀb multiplicando A transpose por b.",
                                    "Verifique as dimensões: AᵀA deve ser n x n simétrica.",
                                    "Armazene os resultados em uma estrutura de dados adequada (matriz e vetor)."
                                  ],
                                  "verification": "Confirme que AᵀA é simétrica (AᵀA = (AᵀA)ᵀ) e dimensões corretas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matriz A e vetor b",
                                    "Calculadora ou software (Python/NumPy, MATLAB)"
                                  ],
                                  "tips": "Use funções prontas como np.dot(A.T, A) em Python para evitar erros de cálculo manual.",
                                  "learningObjective": "Entender a formação das equações normais para quadrados mínimos.",
                                  "commonMistakes": [
                                    "Esquecer transpose de A",
                                    "Erro em multiplicação matricial",
                                    "Dimensões incompatíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar propriedades para fatoração Cholesky",
                                  "subSteps": [
                                    "Confirme simetria: compare AᵀA com sua transpose.",
                                    "Teste positiva definida: verifique autovalores > 0 ou pivôs principais > 0.",
                                    "Calcule determinante ou trace para indícios iniciais.",
                                    "Se necessário, condicione a matriz ou avalie condicionamento."
                                  ],
                                  "verification": "Todos autovalores positivos e simetria confirmada.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Software com eigenvals (np.linalg.eigvals)",
                                    "Papel para pivôs principais"
                                  ],
                                  "tips": "Para matrizes pequenas, compute manualmente; para grandes, use software.",
                                  "learningObjective": "Reconhecer quando Cholesky é aplicável para estabilidade.",
                                  "commonMistakes": [
                                    "Ignorar não-positiva definida levando a falha",
                                    "Confundir com simetria não suficiente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar fatoração Cholesky",
                                  "subSteps": [
                                    "Inicialize R como matriz nula triangular superior.",
                                    "Para cada elemento r_{ii}, compute sqrt(a_{ii} - sum r_{ki}^2 para k<i).",
                                    "Para elementos r_{ij} (j>i), compute (a_{ij} - sum r_{ki} r_{kj}) / r_{ii}.",
                                    "Verifique AᵀA ≈ Rᵀ R com erro pequeno."
                                  ],
                                  "verification": "Multiplicação Rᵀ R reproduz AᵀA com erro < 1e-10.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Algoritmo Cholesky implementado ou função np.linalg.cholesky"
                                  ],
                                  "tips": "Implemente em loop para compreensão; use lib para precisão.",
                                  "learningObjective": "Dominar o algoritmo Cholesky para decomposição LDL-like.",
                                  "commonMistakes": [
                                    "Divisão por zero em pivô",
                                    "Soma errada em diagonal",
                                    "Não triangularizar corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver sistemas triangulares",
                                  "subSteps": [
                                    "Resolva Rᵀ z = Aᵀ b por substituição frontal.",
                                    "Resolva R x = z por substituição traseira.",
                                    "Use eliminação gaussiana adaptada para triangulares.",
                                    "Obtenha x como solução dos quadrados mínimos."
                                  ],
                                  "verification": "Verifique ||A x - b|| mínimo e Aᵀ(A x - b) ≈ 0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Funções de solver triangular (scipy.linalg.solve_triangular)"
                                  ],
                                  "tips": "Comece com z, depois x; evite pivotamento desnecessário.",
                                  "learningObjective": "Aplicar solvers eficientes para sistemas triangulares.",
                                  "commonMistakes": [
                                    "Confundir frontal com traseira",
                                    "Erro de sinal em substituição"
                                  ]
                                }
                              ],
                              "practicalExample": "Dada A = [[1, 0], [1, 1], [0, 1]] (3x2), b = [1, 2, 2]. Compute AᵀA = [[2,1],[1,2]], Aᵀb=[3,4]. Cholesky: R = [[√2, 0.707],[0, √1.5]]. Resolva para x ≈ [1,1], verificando ||Ax-b||≈0.",
                              "finalVerifications": [
                                "AᵀA = Rᵀ R com erro numérico pequeno.",
                                "Solução x satisfaz Aᵀ(Ax - b) ≈ 0.",
                                "Resíduo ||Ax - b||_2 é mínimo possível.",
                                "Condição da matriz permite estabilidade.",
                                "Autovalores de AᵀA > 0.",
                                "Solução coincide com método direto (ex: QR)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da fatoração Cholesky (erro < 1e-8).",
                                "Correção das substituições triangulares.",
                                "Verificação de positiva definida antes da fatoração.",
                                "Eficiência computacional (O(n^3) para n pequeno).",
                                "Interpretação correta do contexto de quadrados mínimos.",
                                "Uso apropriado de software vs. manual."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação numérica em Python/NumPy.",
                                "Estatística: Regressão linear via mínimos quadrados.",
                                "Física: Modelagem de sistemas dinâmicos estáveis.",
                                "Otimização: Problemas de minimização quadrática."
                              ],
                              "realWorldApplication": "Em machine learning para regressão linear estável (evita ill-conditioning), simulações físicas (estruturas finitas), processamento de sinais (filtros Kalman), e finanças (otimização de portfólios)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.3.3",
                            "name": "Avaliar sensibilidade numérica",
                            "description": "Analisar o erro na solução x considerando perturbações em A e b, relacionando com análise de sensibilidade e referência a Golub & Van Loan.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as equações normais e a solução exata",
                                  "subSteps": [
                                    "Lembre-se do problema de mínimos quadrados: minimizar ||Ax - b||_2 para A m x n (m > n, rank(A)=n).",
                                    "Derive as equações normais: A^T A x = A^T b.",
                                    "Explique a solução x = (A^T A)^{-1} A^T b.",
                                    "Discuta a necessidade de fatoração QR ou SVD para estabilidade numérica.",
                                    "Verifique com um exemplo simples de 2x2."
                                  ],
                                  "verification": "Resolva um sistema pequeno e confirme que x minimiza o resíduo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e calculadora",
                                    "Capítulo 5 de Golub & Van Loan",
                                    "Python/MATLAB para verificação"
                                  ],
                                  "tips": "Sempre verifique o rank de A antes de inverter A^T A.",
                                  "learningObjective": "Compreender a formulação teórica das equações normais.",
                                  "commonMistakes": [
                                    "Confundir mínimos quadrados com sistemas lineares exatos",
                                    "Ignorar ill-condicionamento de A^T A"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir perturbações em A e b",
                                  "subSteps": [
                                    "Defina perturbações: Ã = A + δA, \tilde{b} = b + δb, com ||δA|| / ||A|| ≤ ε, ||δb|| / ||b|| ≤ ε.",
                                    "Escreva as equações normais perturbadas: Ã^T Ã \tilde{x} = Ã^T \tilde{b}.",
                                    "Introduza o erro e = \tilde{x} - x.",
                                    "Aproximações de primeira ordem para pequenas perturbações.",
                                    "Relacione com normas matriciais e vetoriais."
                                  ],
                                  "verification": "Escreva as expressões perturbadas corretamente em um caderno.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro Golub & Van Loan (Seção 5.3)",
                                    "Software numérico como NumPy"
                                  ],
                                  "tips": "Use aproximações lineares para perturbações pequenas (ε << 1).",
                                  "learningObjective": "Modelar o impacto de ruídos em dados de entrada.",
                                  "commonMistakes": [
                                    "Esquecer termos cruzados como A^T δA",
                                    "Usar normas erradas (L1 vs L2)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e analisar o erro na solução x",
                                  "subSteps": [
                                    "Derive a expressão para e ≈ (A^T A)^{-1} (A^T δb - (A^T δA) x).",
                                    "Calcule o erro relativo ||e|| / ||x|| ≤ κ(A^T A) (||δb||/||b|| + κ(A) ||δA||/||A||), onde κ é o número de condição.",
                                    "Discuta amplificação do erro devido a κ(A^T A) ≈ [κ(A)]^2.",
                                    "Implemente numericamente para validar a aproximação.",
                                    "Compare com solução via QR para estabilidade."
                                  ],
                                  "verification": "Compute o erro para perturbações dadas e compare com bound teórico.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "MATLAB/Python com NumPy/SciPy",
                                    "Exemplo numérico impresso"
                                  ],
                                  "tips": "Prefira fatoração QR para evitar ill-condicionamento de A^T A.",
                                  "learningObjective": "Quantificar o erro na solução devido a perturbações.",
                                  "commonMistakes": [
                                    "Subestimar [κ(A)]^2 como fator de amplificação",
                                    "Não normalizar erros relativos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar com análise de sensibilidade e referências",
                                  "subSteps": [
                                    "Explique análise de sensibilidade: estudo de como erros em entrada afetam saída.",
                                    "Referencie Teorema 5.3.8 de Golub & Van Loan para bounds precisos.",
                                    "Discuta pseudoinverso e papel do menor valor singular.",
                                    "Avalie sensibilidade em problemas mal-condicionados (ex: regressão com multicolinearidade).",
                                    "Conclua com recomendações práticas (regularização)."
                                  ],
                                  "verification": "Cite o teorema relevante e aplique a um caso.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Golub & Van Loan (Cap. 5)",
                                    "Artigos sobre mínimos quadrados"
                                  ],
                                  "tips": "Sempre compute κ(A) antes de resolver.",
                                  "learningObjective": "Conectar teoria local com referências padrão.",
                                  "commonMistakes": [
                                    "Ignorar dependência em σ_min(A)",
                                    "Confundir sensibilidade com estabilidade do algoritmo"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[1,1],[1,1.0001],[1,1.0002]], b=[1,1.0001,1.0003]^T. Solução x ≈ [1, 1.0001]^T. Perturbe δA com ε=1e-6 em uma entrada, δb similar. Calcule \tilde{x}, erro e, e verifique ||e||/||x|| ≈ [κ(A)]^2 ε ≈ 10^12 * 1e-6 = 10^6 (devido a σ_min pequeno).",
                              "finalVerifications": [
                                "Deriva corretamente a aproximação do erro e.",
                                "Calcula o bound de sensibilidade usando κ(A^T A).",
                                "Implementa numericamente e confirma amplificação.",
                                "Cita referência exata de Golub & Van Loan.",
                                "Identifica quando usar QR em vez de normal equations.",
                                "Avalia sensibilidade para um exemplo mal-condicionado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das expressões perturbadas (80%).",
                                "Correta interpretação do fator [κ(A)]^2 (90%).",
                                "Validação numérica com erro <1% do bound (85%).",
                                "Referência adequada a teoremas e capítulos.",
                                "Análise qualitativa de casos extremos.",
                                "Clareza na explicação de recomendações práticas."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em Python/MATLAB.",
                                "Estatística: Regressão linear e análise de resíduos.",
                                "Engenharia: Modelagem de sistemas com ruído.",
                                "Análise Numérica: Teoria de perturbações e estabilidade."
                              ],
                              "realWorldApplication": "Em ajuste de curvas experimentais (ex: regressão em dados de sensores com ruído), previsão financeira com multicolinearidade, ou processamento de imagens onde A é mal-condicionado, permitindo quantificar confiança nas estimativas de parâmetros."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.3.4",
                            "name": "Comparar com decomposição QR",
                            "description": "Discutir por que QR é preferível às normais diretas, evitando formação explícita de AᵀA e seu condicionamento quadrático.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Equações Normais e Solução Direta",
                                  "subSteps": [
                                    "Lembre-se da formulação do problema de quadrados mínimos: min ||Ax - b||_2.",
                                    "Derive as equações normais: A^T A x = A^T b.",
                                    "Explique a solução direta: x = (A^T A)^{-1} A^T b usando decomposição LU ou Cholesky.",
                                    "Implemente um exemplo simples em código para resolver numericamente.",
                                    "Discuta estabilidade numérica básica da abordagem direta."
                                  ],
                                  "verification": "Resolva um sistema 3x2 manualmente e verifique se x minimiza ||Ax - b||.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Matriz A de exemplo (ex: A = [[1,2],[3,4],[5,6]]), calculadora ou Python/NumPy.",
                                  "tips": "Sempre normalize colunas de A para melhorar estabilidade inicial.",
                                  "learningObjective": "Compreender a base teórica das equações normais e sua implementação direta.",
                                  "commonMistakes": "Confundir A^T A x = A^T b com Ax = b; ignorar que A pode ser retangular."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Condicionamento de A^T A",
                                  "subSteps": [
                                    "Defina número de condicionamento cond(M) = ||M|| ||M^{-1}||.",
                                    "Prove que cond(A^T A) = [cond(A)]^2.",
                                    "Calcule cond(A) e cond(A^T A) para uma matriz A mal-condicionada (ex: Vandermonde).",
                                    "Simule erros de arredondamento em floating-point comparando soluções exata e numérica.",
                                    "Discuta impacto: pequenos erros em A amplificados quadraticamente em A^T A."
                                  ],
                                  "verification": "Mostre numericamente que cond(A^T A) ≈ [cond(A)]^2 com erro < 1e-10.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy/SciPy para cond() e svdvals; matrizes de teste.",
                                  "tips": "Use singular values para cond(A); evite A singular para demonstração clara.",
                                  "learningObjective": "Identificar por que A^T A piora estabilidade numérica quadraticamente.",
                                  "commonMistakes": "Esquecer que cond é multiplicativo para produto; confundir com rank."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir Decomposição QR para Quadrados Mínimos",
                                  "subSteps": [
                                    "Lembre QR: A = QR com Q ortogonal, R triangular superior.",
                                    "Derive solução QR: Rx = Q^T b (evita A^T A explicitamente).",
                                    "Implemente Householder ou Givens para QR em código.",
                                    "Compare estabilidade: cond(R) = cond(A), preservando condicionamento original.",
                                    "Teste com a mesma A mal-condicionada, medindo resíduos ||Ax - b||."
                                  ],
                                  "verification": "Resolva via QR e confirme ||Ax - b|| similar à solução exata, melhor que normal.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Código Python/MATLAB para qr(A); mesma A e b do Step 1.",
                                  "tips": "Prefira QR com pivoteamento para A rank-deficient; Q^T Q = I é chave para ortogonalidade.",
                                  "learningObjective": "Dominar como QR resolve quadrados mínimos sem formar A^T A.",
                                  "commonMistakes": "Aplicar QR em A^T em vez de A; ignorar que Q é ortogonal."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Abordagens e Concluir Vantagens da QR",
                                  "subSteps": [
                                    "Tabela comparativa: tempo, estabilidade, memória (A^T A requer O(m n^2)).",
                                    "Execute benchmarks numéricos com A grande (ex: 100x50).",
                                    "Discuta casos onde QR falha vs. normais (raros, como A muito esparsa).",
                                    "Resuma: QR evita perda quadrática de precisão, mais estável e escalável.",
                                    "Debata em fórum ou relatório: 'Por que QR é padrão em libs como LAPACK?'"
                                  ],
                                  "verification": "Relatório de 1 página com tabelas de erros e tempos, provando superioridade QR.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha ou Jupyter notebook para benchmarks; libs SciPy.linalg.",
                                  "tips": "Meça flops: normais ~2mn^2 + n^3; QR ~2mn^2.",
                                  "learningObjective": "Articular claramente por que QR é preferível às normais diretas.",
                                  "commonMistakes": "Ignorar overhead QR em A quadrada/densa; superestimar simplicidade de Cholesky."
                                }
                              ],
                              "practicalExample": "Para A = [[1, 1], [1.0001, 1.0002], [1.0002, 1.0004]] (mal-condicionada, cond(A)≈10^4), b=[1,1.0001,1.0002]. Solução normal direta dá x≈[-1.2e6, 1.2e6] com erro grande devido a cond(A^T A)≈10^8; QR dá x≈[0,1] preciso.",
                              "finalVerifications": [
                                "Explique verbalmente por que cond(A^T A) = [cond(A)]^2.",
                                "Implemente e rode benchmark mostrando erro QR < erro normal em 10^{-10}.",
                                "Prove Rx = Q^T b minimiza ||Ax-b|| sem A^T A.",
                                "Identifique 3 cenários onde normais diretas falham (ex: ill-conditioned A).",
                                "Escreva pseudo-código para ambos métodos.",
                                "Compare resíduos ||Ax-b|| para A 50x30 aleatória."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de cond(A^T A) = [cond(A)]^2 (correto/médio/errado).",
                                "Qualidade de exemplos numéricos: erro relativo <1e-12 para QR vs >1e-5 para normal.",
                                "Clareza na comparação: pelo menos 4 vantagens QR listadas com evidência.",
                                "Profundidade de substeps: todos implementados com código funcional.",
                                "Compreensão conceitual: explica ortogonalidade Q preserva estabilidade.",
                                "Relatório final: estrutura lógica, referências a LAPACK/GSL."
                              ],
                              "crossCurricularConnections": [
                                "Computação Numérica: Análise de erros flutuantes e estabilidade.",
                                "Programação: Implementação em Python/NumPy/SciPy para álgebra linear.",
                                "Estatística: Regressão linear robusta em dados ruidosos.",
                                "Física Computacional: Ajuste de curvas em simulações dinâmicas."
                              ],
                              "realWorldApplication": "Em machine learning, QR é usada em regressão linear estável (scikit-learn); em GPS, ajuste de órbitas evita erros quadráticos em matrizes de observação mal-condicionadas; em processamento de sinais, least-squares para filtros adaptativos."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.3",
                    "name": "Decomposição QR para Mínimos Quadrados",
                    "description": "Uso da fatoração QR (ortogonalização Gram-Schmidt ou Householder) para resolver mínimos quadrados de forma numéricamente estável.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.3.1",
                        "name": "Fatoração QR via Processo de Gram-Schmidt",
                        "description": "Processo clássico de ortogonalização para obter a decomposição QR de uma matriz A = QR, onde Q é ortogonal e R é triangular superior, destacando sua aplicação em problemas numéricos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.1.1",
                            "name": "Implementar o processo Gram-Schmidt clássico",
                            "description": "Aplicar o algoritmo de Gram-Schmidt modificado para fatorar uma matriz m x n em Q ortonormal e R triangular superior, computando projeções ortogonais sucessivas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a matriz de entrada e inicializar estruturas de dados",
                                  "subSteps": [
                                    "Carregue a matriz A de dimensões m x n, garantindo m >= n e rank(A) = n.",
                                    "Inicialize a matriz Q como m x n vazia (lista de vetores coluna).",
                                    "Inicialize a matriz R como n x n triangular superior com zeros.",
                                    "Defina uma lista ou contador para acompanhar os vetores ortogonais u_k.",
                                    "Verifique se a primeira coluna de A é não-nula."
                                  ],
                                  "verification": "Confirme que A está carregada corretamente e Q, R inicializados com dimensões adequadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matriz A de exemplo (papel ou software como Python/NumPy, MATLAB)",
                                    "Calculadora ou ambiente computacional"
                                  ],
                                  "tips": "Use representação matricial explícita para depuração; prefira colunas como vetores para intuição geométrica.",
                                  "learningObjective": "Entender a preparação inicial para o processo iterativo de ortogonalização.",
                                  "commonMistakes": [
                                    "Ignorar verificação de rank ou colunas nulas",
                                    "Dimensões incorretas em Q ou R"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Processar a primeira coluna: normalização inicial",
                                  "subSteps": [
                                    "Extraia a primeira coluna a1 de A.",
                                    "Calcule a norma euclidiana ||a1||.",
                                    "Defina q1 = a1 / ||a1|| e armazene como primeira coluna de Q.",
                                    "Defina r11 = ||a1|| na posição (1,1) de R.",
                                    "Verifique se ||q1|| = 1."
                                  ],
                                  "verification": "Compute q1^T q1 = 1 e confirme que r11 é a norma correta de a1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Vetores coluna representados como arrays",
                                    "Funções de norma (ex: np.linalg.norm)"
                                  ],
                                  "tips": "Use norma L2 (euclidiana); arredonde numericamente com tolerância 1e-10.",
                                  "learningObjective": "Dominar a base do processo: normalizar o primeiro vetor para iniciar a base ortonormal.",
                                  "commonMistakes": [
                                    "Dividir pela norma zero (coluna nula)",
                                    "Esquecer de atualizar R"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o loop de ortogonalização e normalização para colunas subsequentes",
                                  "subSteps": [
                                    "Para cada k de 2 a n: extraia ak da coluna k de A.",
                                    "Compute as projeções: para j=1 a k-1, proj_j = (q_j^T ak) * q_j.",
                                    "Calcule o vetor ortogonal uk = ak - soma das proj_j.",
                                    "Calcule ||uk|| e defina qk = uk / ||uk||, armazenando em Q.",
                                    "Atualize R: r_jk = q_j^T ak para j=1 a k-1, e r_kk = ||uk||."
                                  ],
                                  "verification": "Para cada k, verifique qk perpendicular a qj para j<k (produto escalar ~0) e ||qk||=1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Loop for em pseudocódigo ou código",
                                    "Operações matriciais vetorizadas"
                                  ],
                                  "tips": "Implemente como função recursiva ou loop explícito; armazene coeficientes de projeção em R durante o cálculo.",
                                  "learningObjective": "Aplicar projeções sucessivas para construir base ortonormal incrementalmente.",
                                  "commonMistakes": [
                                    "Soma errada das projeções (usar ak em vez de uk)",
                                    "Índices off-by-one no loop"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir matriz R completa e verificar a decomposição QR",
                                  "subSteps": [
                                    "Preencha R com todos os r_ij computados (já deve estar durante o loop).",
                                    "Compute o produto Q * R e compare com A original.",
                                    "Verifique ortonormalidade de Q: Q^T Q = I_n.",
                                    "Confirme que R é triangular superior.",
                                    "Avalie estabilidade numérica se aplicável (norma do erro ||A - QR|| < epsilon)."
                                  ],
                                  "verification": "||A - Q R|| < 1e-12 e Q^T Q ≈ I.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Funções de multiplicação matricial",
                                    "Verificadores de ortonormalidade"
                                  ],
                                  "tips": "Use tolerâncias numéricas para flutuações de ponto flutuante; plote vetores para visualização.",
                                  "learningObjective": "Validar a fatoração QR e entender propriedades algébricas.",
                                  "commonMistakes": [
                                    "R não triangular (erros em atualizações)",
                                    "Ignorar perda de ortogonalidade numérica"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[1, 3], [1, 1], [0, 1]] (3x2):\n- q1 = [1/√2, 1/√2, 0]^T, r11=√2\n- u2 = [3,1,1]^T - (3/√2 +1/√2)*q1/√2 wait, compute: proj1 = (q1·a2) q1 = ( (1/√2)*3 + (1/√2)*1 +0 ) q1 = (4/√2) q1 = 2√2 q1\nuk = a2 - 2√2 q1, etc. Resultado final: Q ortonormal, R = [[√2, 2√2], [0, √6/3]], QR=A.",
                              "finalVerifications": [
                                "Q tem colunas unitárias (||q_k||=1 para todo k).",
                                "Colunas de Q são ortogonais (q_i^T q_j = 0 para i≠j).",
                                "R é estritamente triangular superior com diagonais positivas.",
                                "A = Q R exatamente (ou com erro numérico pequeno).",
                                "Rank de Q igual a n.",
                                "Processo lida com entrada m x n corretamente."
                              ],
                              "assessmentCriteria": [
                                "Correção algorítmica: projeções sucessivas exatas.",
                                "Eficiência: O(n^2 m) operações sem loops desnecessários.",
                                "Estabilidade numérica: perda de ortogonalidade mínima.",
                                "Implementação limpa: código legível com comentários.",
                                "Tratamento de casos edge: colunas lineares dependentes.",
                                "Verificações integradas no código."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/NumPy ou MATLAB para álgebra numérica.",
                                "Física: Base ortonormal em mecânica quântica (estados ortogonais).",
                                "Estatística: Pré-condicionamento para regressão linear.",
                                "Ciência de Computação: Otimização em machine learning (PCA aproximada)."
                              ],
                              "realWorldApplication": "Usado em solução de sistemas de mínimos quadrados (x = (A^T A)^{-1} A^T b ≈ R^{-1} (Q^T b)), compressão de imagens via SVD aproximado, e estabilização numérica em simulações físicas como dinâmica molecular."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.2",
                            "name": "Analisar perda de ortogonalidade no Gram-Schmidt clássico",
                            "description": "Identificar e quantificar erros de arredondamento que levam à perda de ortogonalidade em Q devido à subtração de projeções, comparando com normas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o processo de Gram-Schmidt clássico",
                                  "subSteps": [
                                    "Lembre-se da fórmula básica: para vetores a1, ..., an, q1 = a1 / ||a1||, qk = (ak - sum_{j=1}^{k-1} <qk, aj> qj) / norma",
                                    "Identifique a etapa de projeção: subtração ak - proj_{span{q1..qk-1}} ak",
                                    "Escreva pseudocódigo do algoritmo clássico",
                                    "Discuta a dependência sequencial dos passos",
                                    "Verifique ortogonalidade teórica: <qi, qj> = 0 para i ≠ j"
                                  ],
                                  "verification": "Implementar o algoritmo em papel para uma matriz 2x2 e confirmar q1^T q2 ≈ 0",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora ou software como MATLAB/Octave"
                                  ],
                                  "tips": "Comece com vetores ortogonais exatos para validar a implementação teórica",
                                  "learningObjective": "Compreender a estrutura algorítmica e identificar a subtração de projeções como ponto crítico",
                                  "commonMistakes": [
                                    "Confundir Gram-Schmidt clássico com modificado",
                                    "Ignorar normalização após subtração",
                                    "Esquecer dependência sequencial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e medir perda de ortogonalidade",
                                  "subSteps": [
                                    "Defina ortogonalidade: Q^T Q = I idealmente",
                                    "Meça erro: ||Q^T Q - I||_F (norma de Frobenius) ou ||Q^T Q - I||_2",
                                    "Compute Q^T Q para Q resultante",
                                    "Compare com máquina epsilon (eps ≈ 2e-16 em double)",
                                    "Escolha norma adequada: Frobenius para global, 2 para espectral"
                                  ],
                                  "verification": "Para uma Q ortonormal exata, ||Q^T Q - I||_F < 1e-14",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software numérico (Python com NumPy ou MATLAB)",
                                    "Matriz de teste ortonormal"
                                  ],
                                  "tips": "Use norma de Frobenius pois é fácil de computar e sensível a erros locais",
                                  "learningObjective": "Saber quantificar numericamente a perda de ortogonalidade",
                                  "commonMistakes": [
                                    "Usar norma 1 ou inf em vez de Frobenius/2",
                                    "Esquecer de subtrair I",
                                    "Não escalar pelo tamanho da matriz"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar erros de arredondamento na subtração de projeções",
                                  "subSteps": [
                                    "Identifique subtração cancelatória: quando ak ≈ proj, qk = (ak - proj)/norma tem perda de dígitos",
                                    "Analise em aritmética de ponto flutuante: fl(ak - <q_j, ak> q_j) = ak - <q_j, ak> q_j + δ, |δ| ≤ eps * ||ak||",
                                    "Estude propagação: erros em qk afetam projeções futuras",
                                    "Considere condição da base: vetores quase paralelos amplificam erro",
                                    "Compare com análise de Wilkinson ou Higham"
                                  ],
                                  "verification": "Explicar verbalmente por que subtração cancelatória causa ||q_k|| << 1 em vez de 1",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Livro de análise numérica (ex: Higham 'Accuracy and Stability')",
                                    "Notas de aula sobre aritmética flutuante"
                                  ],
                                  "tips": "Desenhe vetores graficamente para visualizar cancelamento",
                                  "learningObjective": "Identificar a subtração de projeções como fonte primária de perda de ortogonalidade",
                                  "commonMistakes": [
                                    "Atribuir erro só à normalização",
                                    "Ignorar dependência em passos anteriores",
                                    "Confundir com erros em <q_j, ak>"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Quantificar e simular a perda numericamente",
                                  "subSteps": [
                                    "Gere matriz ill-condicionada: A = [1 1; eps 1+eps]",
                                    "Aplique Gram-Schmidt clássico em precisão finita",
                                    "Compute ||Q^T Q - I||_F e compare com Householder QR",
                                    "Varie condição (kappa(A)) e observe crescimento O(eps * kappa^2)",
                                    "Implemente em código e plote erro vs eps"
                                  ],
                                  "verification": "Erro ||Q^T Q - I||_F ≈ 1e-8 para kappa=1e8, vs <1e-14 para QR estável",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python (NumPy, SciPy.linalg.qr)",
                                    "MATLAB ou Julia"
                                  ],
                                  "tips": "Use np.seterr(all='raise') para detectar overflows/underflows",
                                  "learningObjective": "Quantificar empiricamente a perda e compará-la com teoria",
                                  "commonMistakes": [
                                    "Usar precisão simples em vez de dupla",
                                    "Matriz não ill-condicionada o suficiente",
                                    "Comparar normas sem normalizar"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 1], [1e-8, 1e-8 + 1e-8]]. Aplique Gram-Schmidt: q1 = [1,1e-8]/norma ≈ [1,1e-8], proj = <q1,A2> q1 ≈ q1 * (1e-8 + 1e-8)/2, subtração cancela leading digits em A2 - proj, resultando q2 com ||q2|| <<1 e Q^T Q longe de I (erro ~1e-7).",
                              "finalVerifications": [
                                "Computar ||Q^T Q - I||_F < 1e-12 para caso bem-condicionado",
                                "Identificar cancelamento em qk com ||ak - proj|| / ||ak|| <<1",
                                "Explicar crescimento de erro O(u * kappa(A)^2) onde u=eps máquina",
                                "Comparar com QR de Householder: erro <1e-14",
                                "Simular em código e plotar erro vs log(kappa)",
                                "Verificar que reortogonalização reduz erro"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação da subtração cancelatória como causa raiz",
                                "Cálculo correto de métricas de ortogonalidade (normas adequadas)",
                                "Análise qualitativa e quantitativa coerente com teoria numérica",
                                "Uso apropriado de exemplos numéricos ill-condicionados",
                                "Comparação válida com métodos estáveis",
                                "Clareza na explicação de propagação de erros"
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Estabilidade de algoritmos",
                                "Programação Científica: Implementação em Python/MATLAB",
                                "Engenharia Computacional: Solvers de sistemas lineares",
                                "Física Computacional: Simulações com bases ortogonais",
                                "Estatística: Regressão linear robusta"
                              ],
                              "realWorldApplication": "Em solvers de mínimos quadrados para grandes sistemas em engenharia (ex: processamento de imagens, otimização estrutural), onde perda de ortogonalidade causa soluções imprecisas; motiva uso de QR modificada ou Householder para estabilidade numérica em dados ruidosos ou ill-condicionados."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.3",
                            "name": "Implementar Gram-Schmidt modificado para maior estabilidade",
                            "description": "Realizar a versão modificada do Gram-Schmidt, reortogonalizando a cada passo para minimizar erros de propagação em computações finitas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação do ambiente e inicialização das estruturas",
                                  "subSteps": [
                                    "Escolha uma linguagem de programação numérica (ex: Python com NumPy ou MATLAB).",
                                    "Defina a matriz A de dimensões m x n (m >= n, preferencialmente mal-condicionada para testar estabilidade).",
                                    "Inicialize a matriz Q (m x n) com zeros e R (n x n) com zeros.",
                                    "Copie as colunas de A para trabalhar (não modifique A original).",
                                    "Defina um epsilon para tolerância numérica (ex: 1e-12)."
                                  ],
                                  "verification": "Verifique se Q e R estão inicializados com dimensões corretas e zeros, e A está pronta sem alterações.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python com biblioteca NumPy ou MATLAB",
                                    "Matriz A de exemplo (ex: 3x2 ou maior)"
                                  ],
                                  "tips": "Use precisão de ponto flutuante duplo (float64) para minimizar erros de arredondamento desde o início.",
                                  "learningObjective": "Configurar corretamente o ambiente computacional e estruturas de dados para o algoritmo MGS.",
                                  "commonMistakes": [
                                    "Inicializar Q como identidade em vez de zeros.",
                                    "Confundir dimensões de A (linhas vs colunas).",
                                    "Usar precisão simples (float32) que amplifica erros."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Processamento da primeira coluna (k=1)",
                                  "subSteps": [
                                    "Defina v = A[:, 0] (primeira coluna de A, índice 0 ou 1 dependendo da linguagem).",
                                    "Calcule R[0, 0] = norma euclidiana de v (||v||_2).",
                                    "Normalize: Q[:, 0] = v / R[0, 0].",
                                    "Verifique se ||Q[:, 0]|| ≈ 1.",
                                    "Registre valores para depuração."
                                  ],
                                  "verification": "Confirme que Q[:, 0] tem norma unitária (erro < 1e-12) e R[0, 0] > 0.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Funções de norma (np.linalg.norm ou norm() no MATLAB)"
                                  ],
                                  "tips": "Evite divisão por zero verificando se coluna não é nula.",
                                  "learningObjective": "Implementar o caso base do MGS para a primeira base ortonormal.",
                                  "commonMistakes": [
                                    "Esquecer de copiar v = A[:,k] antes de modificar.",
                                    "Calcular norma errada (ex: norma 1 em vez de 2).",
                                    "Não tratar colunas zero."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementação do loop principal para colunas subsequentes (k=2 a n)",
                                  "subSteps": [
                                    "Para cada k de 2 a n:",
                                    "  Defina v = A[:, k-1].",
                                    "  Para cada j de 1 a k-1:",
                                    "    Calcule R[j-1, k-1] = Q[:, j-1]^T * v.",
                                    "    Atualize v = v - R[j-1, k-1] * Q[:, j-1].",
                                    "  Após inner loop: R[k-1, k-1] = ||v||_2.",
                                    "  Q[:, k-1] = v / R[k-1, k-1]."
                                  ],
                                  "verification": "Após cada k, verifique ||Q[:, k-1]|| ≈ 1 e rastreie perda de ortogonalidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Loops for aninhados",
                                    "Produto escalar (dot ou @ em Python)"
                                  ],
                                  "tips": "Atualize v sequencialmente no inner loop para maximizar estabilidade; evite acumular projeções primeiro.",
                                  "learningObjective": "Codificar a reortogonalização sequencial característica do MGS para minimizar propagação de erros.",
                                  "commonMistakes": [
                                    "Usar classical GS (projetar em a_j em vez de q_j atualizado).",
                                    "Índices errados em loops (off-by-one).",
                                    "Reutilizar v sem recopiá-lo de A."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificação final da decomposição QR",
                                  "subSteps": [
                                    "Calcule Q^T * Q e verifique se é aproximadamente identidade (diagonal 1, off-diagonal < epsilon).",
                                    "Reconstrua A_recon = Q * R e compute erro ||A - A_recon|| / ||A|| < epsilon.",
                                    "Compare perda de ortogonalidade com Classical GS na mesma matriz.",
                                    "Teste com matriz mal-condicionada (ex: Hilbert).",
                                    "Documente resultados."
                                  ],
                                  "verification": "Erro de reconstrução < 1e-10 e ortogonalidade ||Q^T Q - I|| < 1e-12.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Funções de multiplicação matricial e norma Frobenius"
                                  ],
                                  "tips": "Use matrizes de ill-condicionamento para demonstrar superioridade do MGS.",
                                  "learningObjective": "Validar a implementação e quantificar a estabilidade numérica ganha.",
                                  "commonMistakes": [
                                    "Não normalizar adequadamente, levando a normas !=1.",
                                    "Ignorar erros de arredondamento em verificações.",
                                    "Comparar com métodos errados."
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente o MGS na matriz A = [[1.0, 1.0, 1.0], [1.0, 1.1, 1.2], [1.0, 1.21, 1.44]] (Vandermonde-like, mal-condicionada). Verifique Q^T Q ≈ I e A ≈ Q R, contrastando com Classical GS onde ortogonalidade se perde.",
                              "finalVerifications": [
                                "Colunas de Q têm norma euclidiana unitária (||q_i|| = 1).",
                                "Ortogonalidade: |q_i^T q_j| < 1e-12 para i ≠ j.",
                                "Reconstrução exata: ||A - Q R||_F / ||A||_F < 1e-10.",
                                "Superior estabilidade: perda de ortogonalidade menor que no Classical GS.",
                                "R é triangular superior com diagonais positivas.",
                                "Funciona para m > n (QR thin)."
                              ],
                              "assessmentCriteria": [
                                "Código executa corretamente sem erros de índice ou divisão por zero.",
                                "Demonstra estabilidade numérica em matrizes ill-condicionadas.",
                                "Verificações implementadas com tolerâncias apropriadas.",
                                "Explicação clara da diferença entre CGS e MGS.",
                                "Eficiência computacional razoável (O(m n^2)).",
                                "Resultados documentados com saídas numéricas."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Estabilidade de algoritmos de fatoração.",
                                "Programação Científica: Implementação vetorizada em NumPy/MATLAB.",
                                "Quadrados Mínimos: Pré-condicionador para regressão linear estável.",
                                "Processamento de Sinais: Bases ortonormais em transformadas.",
                                "Aprendizado de Máquina: PCA e redução de dimensionalidade."
                              ],
                              "realWorldApplication": "Em simulações científicas (ex: CFD, finanças), onde decomposições QR estáveis resolvem sistemas lineares grandes com precisão, evitando amplificação de erros em aplicações como previsão meteorológica, processamento de imagens e otimização em ML."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.2",
                        "name": "Fatoração QR via Reflexões de Householder",
                        "description": "Método estável baseado em transformações elementares para triangularizar matrizes, garantindo estabilidade numérica superior ao Gram-Schmidt.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.2.1",
                            "name": "Construir uma reflexão de Householder",
                            "description": "Definir um vetor Householder u para zerar subdiagonal de uma coluna, computando a reflexão H = I - 2uu^T / (u^T u).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a subcoluna alvo na matriz",
                                  "subSteps": [
                                    "Selecione a coluna k da matriz A onde a reflexão será aplicada.",
                                    "Extraia o vetor x = A[k:n, k], onde n é o número de linhas.",
                                    "Identifique o primeiro elemento x₁ de x e seu sinal.",
                                    "Verifique as dimensões de x para garantir que capture apenas a subdiagonal."
                                  ],
                                  "verification": "Confirme que x contém exatamente os elementos da subdiagonal da coluna k, começando em A[k,k].",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Matriz A de exemplo (papel ou software como Python/NumPy ou MATLAB)",
                                    "Calculadora"
                                  ],
                                  "tips": "Use índices 1-based para consistência com notação matemática.",
                                  "learningObjective": "Compreender a porção da coluna que precisa ser zerada pela reflexão.",
                                  "commonMistakes": [
                                    "Incluir elementos acima da posição k",
                                    "Usar índices 0-based em cálculos manuais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a norma euclidiana de x",
                                  "subSteps": [
                                    "Calcule a soma dos quadrados: ∑(x_i²) para i = 1 até m (dimensão de x).",
                                    "Aplique a raiz quadrada: ||x||₂ = √(∑ x_i²).",
                                    "Arredonde se necessário, mas mantenha precisão numérica.",
                                    "Verifique o sinal de x₁ para preparar a construção de u."
                                  ],
                                  "verification": "Compare ||x||₂² com ∑ x_i² para validar o cálculo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora ou função np.linalg.norm() em Python",
                                    "Vetor x extraído"
                                  ],
                                  "tips": "Use fórmulas vetoriais em software para evitar erros aritméticos.",
                                  "learningObjective": "Dominar o cálculo de normas vetoriais essenciais para Householder.",
                                  "commonMistakes": [
                                    "Esquecer a raiz quadrada",
                                    "Erro em soma de quadrados devido a arredondamento precoce"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o vetor Householder u",
                                  "subSteps": [
                                    "Defina o vetor unitário e₁ = [1, 0, ..., 0]^T com dimensão de x.",
                                    "Escolha o sinal: σ = sign(x₁), então u = x + σ * ||x||₂ * e₁.",
                                    "Calcule cada componente de u explicitamente.",
                                    "Normalize indiretamente computando ||u|| mais tarde se necessário."
                                  ],
                                  "verification": "Aplique a fórmula e verifique que u₁ = x₁ + σ * ||x||₂ ≠ 0 para estabilidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Vetor x e ||x||₂",
                                    "Papel para vetores ou array NumPy"
                                  ],
                                  "tips": "O sinal +sign(x₁) evita cancelamento numérico quando x₁ é pequeno.",
                                  "learningObjective": "Construir u que mapeia x para múltiplo de e₁.",
                                  "commonMistakes": [
                                    "Usar sinal oposto, causando instabilidade numérica",
                                    "Erro na posição de e₁"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar a matriz de reflexão H",
                                  "subSteps": [
                                    "Calcule o produto externo uu^T.",
                                    "Compute a norma ao quadrado: α = u^T u.",
                                    "Forme H = I - (2/α) * uu^T, onde I é a identidade de tamanho m x m.",
                                    "Multiplique H por x para verificar se zera a subdiagonal."
                                  ],
                                  "verification": "Hx deve ser paralelo a e₁ com zeros abaixo da primeira posição.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Vetores u",
                                    "Software para multiplicação matricial (np.outer() em Python)"
                                  ],
                                  "tips": "Em código, evite formar uu^T explicitamente para grandes dimensões; use atualizações in-place.",
                                  "learningObjective": "Gerar a reflexão ortogonal que zera a subdiagonal.",
                                  "commonMistakes": [
                                    "Dividir por u^T u incorretamente",
                                    "Esquecer o fator 2"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere x = [3, 4]^T. ||x||₂ = 5. σ = sign(3) = 1, u = [3,4] + 1*5*[1,0] = [8,4]. α = 8²+4²=80. uu^T = [[64,32],[32,16]]. H = I - (2/80) uu^T = [[0.2, -0.8], [-0.8, 0.2]]. Hx = [-5, 0]^T, zerando a subdiagonal.",
                              "finalVerifications": [
                                "Hx tem zeros estritos abaixo da primeira posição.",
                                "H é simétrica: H = H^T.",
                                "H é ortogonal: H H^T = I (ou H² = I).",
                                "||Hu|| é preservada (norma invariante).",
                                "u foi construído com sinal correto para estabilidade numérica.",
                                "Subdiagonal da coluna original está zerada após aplicação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração de x e cálculo de ||x||₂ (erro < 10^{-10}).",
                                "Correta escolha de sinal em u para evitar cancelamento.",
                                "Cálculo exato de H com verificação Hx ≈ σ ||x|| e₁.",
                                "Eficiência computacional: O(n²) para step 4.",
                                "Validação ortogonalidade de H.",
                                "Aplicação correta em contexto QR."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação eficiente em NumPy/SciPy para decomposição QR.",
                                "Física: Reflexões em mecânica quântica e óptica geométrica.",
                                "Estatística: Base para SVD em análise de componentes principais (PCA).",
                                "Engenharia: Otimização numérica em controle de sistemas lineares.",
                                "Ciência de Dados: Pré-processamento em regressão linear via mínimos quadrados."
                              ],
                              "realWorldApplication": "Reflexões de Householder são fundamentais na decomposição QR para resolver sistemas de mínimos quadrados em machine learning (ex: regressão linear), simulações físicas (dinâmica de fluidos), processamento de sinais (filtros) e compressão de dados em grandes matrizes, garantindo estabilidade numérica superior ao Gram-Schmidt."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.2.2",
                            "name": "Aplicar sequência de Householder para decomposição QR",
                            "description": "Executar n-1 reflexões para triangularizar A, armazenando Q implicitamente via fatores Householder e recuperando quando necessário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a matriz A e inicializar armazenamento para fatores Householder",
                                  "subSteps": [
                                    "Importe numpy como np.",
                                    "Defina a matriz A como np.array([[1., 2.], [3., 4.], [5., 6.]]), uma matriz 3x2 com m=3, n=2.",
                                    "Crie uma cópia de A chamada R = A.copy().",
                                    "Inicialize uma lista vazia householder_vectors = [] para armazenar os vetores v_k.",
                                    "Defina m, n = A.shape."
                                  ],
                                  "verification": "Confirme que R é idêntico a A inicialmente e householder_vectors está vazia.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python com NumPy instalado",
                                    "Editor de código (Jupyter Notebook recomendado)",
                                    "Documentação NumPy para operações matriciais"
                                  ],
                                  "tips": "Use np.copy() para evitar modificar A original. Assuma m >= n para simplicidade.",
                                  "learningObjective": "Preparar dados para aplicação sequencial de reflexões Householder sem perda de informação original.",
                                  "commonMistakes": [
                                    "Modificar A diretamente sem cópia.",
                                    "Confundir dimensões m e n.",
                                    "Esquecer importações necessárias."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar e aplicar reflexões Householder para triangularizar R",
                                  "subSteps": [
                                    "Para k em range(n-1):",
                                    "  x = R[k:, k]  # subcoluna a partir de k",
                                    "  sigma = np.linalg.norm(x[1:])",
                                    "  v1 = x[0]",
                                    "  u = x.copy(); u[0] += np.sign(v1) * sigma if sigma != 0 else 0",
                                    "  v = u / np.linalg.norm(u)",
                                    "  householder_vectors.append(v)",
                                    "  # Aplicar H_k = I - 2*v*v^T à submatriz R[k:, k:]",
                                    "  R[k:, k:] -= 2 * np.outer(v, np.dot(v, R[k:, k:]))",
                                    "Atualize R[k+1:, k] para zero explicitamente se necessário."
                                  ],
                                  "verification": "Após o loop, verifique se R é triangular superior (elementos abaixo da diagonal são próximos de zero).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "NumPy para np.linalg.norm e np.outer",
                                    "Notebook Jupyter para depuração passo a passo"
                                  ],
                                  "tips": "Use np.sign(v1) * sigma para estabilidade numérica, evitando cancelamento.",
                                  "learningObjective": "Executar n-1 reflexões para zerar subdiagonal de R, armazenando v_k implicitamente.",
                                  "commonMistakes": [
                                    "Erro no cálculo de sigma (usar norm(x) em vez de norm(x[1:])",
                                    "Aplicar reflexão à matriz inteira em vez de submatriz.",
                                    "Normalizar v incorretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Recuperar a matriz Q aplicando as reflexões Householder em sequência",
                                  "subSteps": [
                                    "Inicialize Q como uma matriz identidade de tamanho m x m: Q = np.eye(m).",
                                    "Para cada v em householder_vectors (em ordem reversa para Q):",
                                    "  k = m - len(v)  # posição correta",
                                    "  H = np.eye(m)",
                                    "  H[k:, k:] -= 2 * np.outer(v, v)",
                                    "  Q = np.dot(H, Q)",
                                    "Ou aplique sequencialmente às colunas de uma identidade.",
                                    "Ajuste Q para ter tamanho m x n se necessário: Q = Q[:, :n]."
                                  ],
                                  "verification": "Verifique se Q tem dimensões corretas e np.allclose(np.dot(Q.T, Q), np.eye(n)).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "NumPy para operações outer e dot",
                                    "Função np.allclose para verificações numéricas"
                                  ],
                                  "tips": "Aplique reflexões em ordem reversa para construir Q corretamente.",
                                  "learningObjective": "Construir Q explicitamente a partir dos fatores Householder armazenados.",
                                  "commonMistakes": [
                                    "Ordem errada das reflexões (não reversa).",
                                    "Dimensões incorretas em outer product.",
                                    "Esquecer de truncar Q para m x n."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a decomposição QR completa",
                                  "subSteps": [
                                    "Calcule o produto QR_recon = np.dot(Q, R).",
                                    "Compare com A original: erro = np.linalg.norm(A - QR_recon).",
                                    "Confirme ortogonalidade: QQT = np.dot(Q[:, :n].T, Q[:, :n]) ≈ I_n.",
                                    "Verifique triangularidade: todos R[1:, 0] ≈ 0.",
                                    "Analise resíduos numéricos e ajuste precisão se necessário."
                                  ],
                                  "verification": "Erro de reconstrução < 1e-10 e Q ortogonal dentro de tolerância.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "NumPy linalg.norm",
                                    "Notebook para plotar matrizes se desejar"
                                  ],
                                  "tips": "Use tolerância 1e-12 para comparações de ponto flutuante.",
                                  "learningObjective": "Validar que A = QR com Q ortogonal e R triangular superior.",
                                  "commonMistakes": [
                                    "Ignorar erros de arredondamento.",
                                    "Verificar ortogonalidade em Q completa em vez de thin Q.",
                                    "Não normalizar normas adequadamente."
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = np.array([[1., 2.], [3., 4.], [5., 6.]]), após aplicação: R ≈ [[14.14, 20.49], [0, -0.99], [0, 0]] (valores aproximados), Q thin 3x2 com colunas ortonormais, e np.allclose(A, Q @ R) é True.",
                              "finalVerifications": [
                                "R é triangular superior com zeros abaixo da diagonal.",
                                "Q é ortogonal: Q^T Q = I.",
                                "A = Q R numericamente.",
                                "Fatores Householder v_k têm norma 1.",
                                "Nenhuma reflexão cancela elementos desnecessariamente.",
                                "Erro de reconstrução < 1e-10."
                              ],
                              "assessmentCriteria": [
                                "Correta computação de vetores Householder com sinal apropriado.",
                                "Aplicação precisa das reflexões apenas na submatriz.",
                                "Recuperação correta de Q via produto de Householders.",
                                "Verificações numéricas implementadas e passing.",
                                "Código eficiente sem loops desnecessários.",
                                "Tratamento de casos edge (ex: sigma=0)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em Python/NumPy ou MATLAB.",
                                "Machine Learning: Pré-processamento em regressão linear e PCA.",
                                "Física Computacional: Solução de sistemas em simulações dinâmicas.",
                                "Estatística: Cálculo de intervalos de confiança em mínimos quadrados.",
                                "Engenharia: Análise de estruturas via decomposições matriciais."
                              ],
                              "realWorldApplication": "Essencial para solvers estáveis de mínimos quadrados em regressão linear (ex: ajuste de curvas em dados experimentais), computação de valores singulares via QR iterativa em compressão de imagens, e estabilização numérica em simulações científicas como dinâmica molecular ou finanças quantitativas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.2.3",
                            "name": "Comparar complexidade e estabilidade de Householder vs Gram-Schmidt",
                            "description": "Avaliar custo computacional (flops) e limite de estabilidade relativa, demonstrando superioridade de Householder em precisão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os Algoritmos Gram-Schmidt e Householder",
                                  "subSteps": [
                                    "Estude o processo Gram-Schmidt clássico: orthogonalização sequencial de colunas via projeções.",
                                    "Analise o Gram-Schmidt modificado: correção para evitar cancelamentos catastróficos.",
                                    "Descreva as reflexões de Householder: transformação que zera subdiagonal com uma única reflexão.",
                                    "Compare conceitualmente: Gram-Schmidt é sequencial vs Householder é em blocos.",
                                    "Implemente pseudocódigo simples para cada em uma matriz 3x3."
                                  ],
                                  "verification": "Escreva resumos de 1 parágrafo para cada algoritmo e valide com referências padrão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear Numérica (Golub/Van Loan)",
                                    "Papel e caneta",
                                    "Notebook Jupyter com NumPy"
                                  ],
                                  "tips": "Use diagramas vetoriais para visualizar orthogonalização em Gram-Schmidt.",
                                  "learningObjective": "Compreender os mecanismos fundamentais de cada método para decomposição QR.",
                                  "commonMistakes": [
                                    "Confundir Gram-Schmidt clássico com modificado",
                                    "Ignorar dependência sequencial em Gram-Schmidt"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Complexidade Computacional (FLOPs)",
                                  "subSteps": [
                                    "Para Gram-Schmidt clássico: conte operações para uma matriz mxn (2mn² flops aproximados).",
                                    "Para Gram-Schmidt modificado: adicione custos extras de normalização (similar a clássico).",
                                    "Para Householder: calcule flops por reflexão (4mn por coluna, total ~2mn²).",
                                    "Compare assintoticamente: ambos O(mn²), mas destaque constantes e dependências.",
                                    "Crie tabela comparativa de FLOPs para m=n=100."
                                  ],
                                  "verification": "Derive fórmulas de FLOPs e verifique com execução em código para matriz pequena.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Calculadora ou Python para contagem simbólica",
                                    "Referência: Tabela de complexidades de algoritmos QR"
                                  ],
                                  "tips": "Conte adições/multiplicações separadamente; ignore termos inferiores.",
                                  "learningObjective": "Derivar e comparar custos computacionais precisos em FLOPs.",
                                  "commonMistakes": [
                                    "Contar apenas multiplications, ignorar subtrações",
                                    "Confundir mxn com nxn"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Estabilidade Numérica",
                                  "subSteps": [
                                    "Defina perda de ortogonalidade: ||Q^T Q - I|| como métrica.",
                                    "Para Gram-Schmidt: explique instabilidade por cancelamento em projeções (O(ε n) relativa).",
                                    "Para Householder: destaque estabilidade backward (O(ε) independente de n).",
                                    "Estude bound de erro: limite relativo para Householder vs crescimento exponencial em GS.",
                                    "Simule numericamente com matriz ill-condicionada."
                                  ],
                                  "verification": "Execute simulação em Python mostrando ||Q^T Q - I|| para ambos os métodos.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Python/NumPy/SciPy para householder e gs",
                                    "Matriz de Hilbert 10x10 para teste"
                                  ],
                                  "tips": "Use cond(n) alto para amplificar instabilidades.",
                                  "learningObjective": "Entender limites de estabilidade relativa e por que Householder é superior.",
                                  "commonMistakes": [
                                    "Atribuir estabilidade só a normalizações",
                                    "Ignorar erros de arredondamento acumulados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Demonstrar Superioridade de Householder",
                                  "subSteps": [
                                    "Resuma tabela: FLOPs (similar), Estabilidade (Householder >> GS).",
                                    "Discuta trade-offs: Householder usa mais memória temporária.",
                                    "Aplique a mínimos quadrados: R de Householder é upper triangular estável.",
                                    "Conclua superioridade em precisão para problemas reais.",
                                    "Crie relatório comparativo com gráficos de erro vs n."
                                  ],
                                  "verification": "Gere relatório de 1 página com tabelas, fórmulas e simulações.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Jupyter Notebook para plots (Matplotlib)",
                                    "Templates de relatório LaTeX ou Markdown"
                                  ],
                                  "tips": "Use log-scale para erros numéricos em gráficos.",
                                  "learningObjective": "Sintetizar comparação e justificar escolha de Householder.",
                                  "commonMistakes": [
                                    "Superestimar diferenças em FLOPs",
                                    "Generalizar GS clássico para modificado sem nuance"
                                  ]
                                }
                              ],
                              "practicalExample": "Para matriz A = [[1,1],[1,1.0001],[1,1.0002]] (ill-condicionada), compute QR via Gram-Schmidt e Householder em double precision. Compare ||Q^T Q - I|| (GS ~1e-10, Householder ~1e-16) e resíduos em Ax=b mínimos quadrados.",
                              "finalVerifications": [
                                "Deriva corretamente FLOPs: ~2mn² para ambos.",
                                "Explica instabilidade de GS com exemplo numérico.",
                                "Demonstra superioridade de Householder via simulação.",
                                "Cria tabela comparativa precisa.",
                                "Justifica uso em solvers reais.",
                                "Identifica quando GS modificado falha."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas fórmulas de FLOPs (erro <5%).",
                                "Correta identificação de bounds de estabilidade.",
                                "Qualidade da simulação numérica (gráficos claros).",
                                "Profundidade na comparação qualitativa/quantitativa.",
                                "Clareza no relatório final.",
                                "Ausência de erros conceituais comuns."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em NumPy/SciPy.",
                                "Análise Numérica: Estudo de erros de arredondamento.",
                                "Processamento de Sinais: QR em SVD para PCA.",
                                "Física Computacional: Simulações com matrizes grandes."
                              ],
                              "realWorldApplication": "Em solvers de mínimos quadrados para regressão linear em machine learning (ex: scikit-learn usa Householder-like), processamento de imagens (compressão via SVD), e simulações CFD onde precisão é crítica para estabilidade numérica."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.1.1",
                              "10.1.4.3.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.3",
                        "name": "Solução de Mínimos Quadrados via Decomposição QR",
                        "description": "Uso da fatoração A = QR para resolver min ||Ax - b||_2 via sistema triangular R x = Q^T b, evitando formação explícita de A^T A.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.3.1",
                            "name": "Formular o problema de mínimos quadrados lineares",
                            "description": "Derivar a solução normal A^T A x = A^T b e explicar ill-conditioning quando rank(A) < n.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Formulação do Problema de Mínimos Quadrados Lineares",
                                  "subSteps": [
                                    "Defina o problema como encontrar x que minimiza a norma euclidiana do resíduo ||Ax - b||_2, onde A é m x n com m >= n.",
                                    "Explique que isso surge quando o sistema Ax = b é inconsistente (sem solução exata).",
                                    "Escreva a função objetivo explicitamente: f(x) = ||Ax - b||_2^2 = (Ax - b)^T (Ax - b).",
                                    "Discuta a interpretação geométrica: x minimiza a distância entre b e o espaço coluna de A.",
                                    "Verifique com um exemplo simples de 2 pontos e linha reta."
                                  ],
                                  "verification": "Escreva a formulação matemática correta e interprete geometricamente em um exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora ou software como Python (NumPy)"
                                  ],
                                  "tips": "Pense na projeção ortogonal de b sobre col(A) para visualização intuitiva.",
                                  "learningObjective": "Formular matematicamente o problema de mínimos quadrados e sua interpretação geométrica.",
                                  "commonMistakes": [
                                    "Confundir norma L2 com L1",
                                    "Assumir que A é sempre quadrada e invertível"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar as Equações Normais A^T A x = A^T b",
                                  "subSteps": [
                                    "Expanda a função objetivo: f(x) = x^T A^T A x - 2 b^T A x + b^T b.",
                                    "Calcule o gradiente: ∇f(x) = 2 A^T A x - 2 A^T b.",
                                    "Defina o gradiente igual a zero para mínimo: A^T A x = A^T b.",
                                    "Verifique que é um mínimo usando a Hessiana (A^T A é positiva semidefinida).",
                                    "Confirme com multiplicação: o resíduo r = Ax - b é ortogonal às colunas de A (A^T r = 0)."
                                  ],
                                  "verification": "Derive passo a passo as equações normais a partir de f(x) e prove ortogonalidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Álgebra Linear (ex: Strang)",
                                    "Python para testar gradiente numérico"
                                  ],
                                  "tips": "Use propriedades de transposta e produto interno para simplificar cálculos.",
                                  "learningObjective": "Derivar analiticamente as equações normais e justificar como condição de otimalidade.",
                                  "commonMistakes": [
                                    "Esquecer o fator 2 no gradiente",
                                    "Não expandir corretamente o quadrático"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar e Resolver o Sistema Normal",
                                  "subSteps": [
                                    "Analise a estrutura: A^T A é n x n simétrica positiva semidefinida.",
                                    "Discuta quando rank(A) = n: A^T A é invertível, x = (A^T A)^{-1} A^T b.",
                                    "Implemente numericamente um exemplo pequeno para validar.",
                                    "Compare com projeção: x = (A^T A)^{-1} A^T b é a pseudoinversa de Moore-Penrose para casos cheios.",
                                    "Teste sensibilidade com pequena perturbação em b."
                                  ],
                                  "verification": "Resolva um sistema normal numérico e compare com solução conhecida.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Matriz A de exemplo 3x2"
                                  ],
                                  "tips": "Use np.linalg.lstsq para validar sua solução manual.",
                                  "learningObjective": "Interpretar o sistema normal e resolvê-lo em casos bem condicionados.",
                                  "commonMistakes": [
                                    "Ignorar que A^T A pode ser singular mesmo se rank(A)=n devido a numéricos",
                                    "Confundir com A^{-1} b"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar Ill-Conditioning Quando rank(A) < n",
                                  "subSteps": [
                                    "Defina rank(A) < n: colunas linearmente dependentes, A^T A singular (kernel não-trivial).",
                                    "Mostre infinitas soluções: soluções mínimas norma quando múltiplas.",
                                    "Explique ill-conditioning: pequena perturbação em A ou b causa grandes variações em x.",
                                    "Ilustre com exemplo: A com colunas quase colineares (cond(A) alto).",
                                    "Discuta soluções: use decomposição QR ou SVD para estabilidade."
                                  ],
                                  "verification": "Construa exemplo com rank deficiente, mostre múltiplas soluções e compute condição.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python (NumPy para cond, rank)",
                                    "Exemplos matriciais"
                                  ],
                                  "tips": "Meça cond(A) = sigma_max / sigma_min para quantificar ill-conditioning.",
                                  "learningObjective": "Identificar e explicar problemas numéricos em sistemas sub-rank e motivações para QR.",
                                  "commonMistakes": [
                                    "Pensar que rank(A)<n sempre significa sem solução única",
                                    "Não distinguir ill-conditioning de singularidade pura"
                                  ]
                                }
                              ],
                              "practicalExample": "Ajuste de reta y = mx + c a 4 pontos: (1,2), (2,3), (3,2.5), (4,4). Monte A = [[1,1],[1,2],[1,3],[1,4]], b=[2,3,2.5,4]^T. Derive A^T A x = A^T b, resolva e plote resíduo.",
                              "finalVerifications": [
                                "Deriva corretamente A^T A x = A^T b de ||Ax-b||^2.",
                                "Explica ortogonalidade do resíduo às colunas de A.",
                                "Identifica quando A^T A é singular (rank(A)<n).",
                                "Computa solução numérica para exemplo e verifica norma mínima.",
                                "Discute impacto de ill-conditioning com exemplo concreto.",
                                "Sugere alternativa estável como QR para casos ruins."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das equações normais (100% correta).",
                                "Compreensão geométrica e ortogonalidade demonstrada.",
                                "Análise correta de singularidade e ill-conditioning.",
                                "Exemplo prático resolvido com cálculos verificáveis.",
                                "Clareza na explicação de limitações numéricas.",
                                "Conexão com métodos alternativos como QR."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Base para regressão linear ordinária (OLR).",
                                "Computação: Implementação em NumPy/SciPy (lstsq).",
                                "Engenharia: Ajuste de modelos em dados experimentais.",
                                "Machine Learning: Fundamento de regressão e otimização convexa.",
                                "Física: Análise de dados de sensores e curvas de calibração."
                              ],
                              "realWorldApplication": "Em machine learning para treinamento de modelos lineares (previsão de vendas); em processamento de sinais para filtro de ruído; em engenharia civil para ajuste de curvas de carga em estruturas; em astronomia para órbitas via mínimos quadrados."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.3.2",
                            "name": "Resolver mínimos quadrados usando QR",
                            "description": "Computar c = Q^T b via produto matricial ou Householder reverso, então back-substituição em R x = c para obter x.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a decomposição QR e os vetores envolvidos",
                                  "subSteps": [
                                    "Confirme que a matriz A (m x n, m >= n, rank n) foi decomposta em Q (ortogonal m x m) e R (triangular superior m x n).",
                                    "Identifique o vetor b (m x 1) do problema de mínimos quadrados min ||Ax - b||.",
                                    "Verifique dimensões: Q é m x m, R é m x n com zeros abaixo da diagonal em R[1:n,1:n].",
                                    "Extraia a parte relevante de R: submatriz triangular superior n x n para back-sub.",
                                    "Anote todas as matrizes em formato legível para cálculos manuais ou computacionais."
                                  ],
                                  "verification": "Listar dimensões e primeiras linhas de Q, R, b para confirmar preparação correta.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta, calculadora matricial ou software (Python/NumPy, MATLAB)",
                                  "tips": "Use software para decomposição QR inicial se não pré-computada; foque em precisão numérica.",
                                  "learningObjective": "Entender pré-requisitos da decomposição QR para mínimos quadrados.",
                                  "commonMistakes": "Ignorar que Q pode ser m x m completa; confundir dimensões de R."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar o vetor c = Q^T b",
                                  "subSteps": [
                                    "Calcule o produto matricial Q^T (m x m) * b (m x 1) diretamente se m pequeno.",
                                    "Alternativa: Use reflexões Householder reversas se QR foi construída assim, aplicando-as a b na ordem reversa.",
                                    "Verifique ortogonalidade: ||Q c - b|| deve ser próximo de zero (erro numérico).",
                                    "Armazene apenas os primeiros n componentes de c, pois R tem zeros abaixo.",
                                    "Compare resultados de produto direto vs. Householder para validação."
                                  ],
                                  "verification": "Computar ||Q c - b|| < 1e-10 e listar valores de c.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software NumPy/MATLAB para produto matricial, papel para Householder manual",
                                  "tips": "Householder reverso é numericamente estável e evita formação explícita de Q.",
                                  "learningObjective": "Dominar projeção ortogonal de b no espaço coluna de A via Q^T b.",
                                  "commonMistakes": "Usar Q em vez de Q^T; esquecer transposição em software."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver o sistema triangular R x = c por substituição retroativa",
                                  "subSteps": [
                                    "Extraia a submatriz R_upper (n x n triangular superior) e c[1:n].",
                                    "Inicie da última equação: x_n = c_n / R_{nn}.",
                                    "Para k = n-1 downto 1: x_k = (c_k - sum_{j=k+1 to n} R_{kj} x_j) / R_{kk}.",
                                    "Verifique diagonal de R não-zero (condição de rank completo).",
                                    "Arredonde x com precisão adequada (ex: 1e-12)."
                                  ],
                                  "verification": "Substituir x em R x e comparar com c: ||R x - c|| < 1e-10.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora ou script Python para back-substitution",
                                  "tips": "Implemente função genérica de back-sub para reutilização.",
                                  "learningObjective": "Executar back-substitution eficientemente em sistemas triangulares.",
                                  "commonMistakes": "Dividir por zero se R mal-condicionado; erro de índice em somas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e interpretar a solução dos mínimos quadrados",
                                  "subSteps": [
                                    "Calcule o resíduo r = b - A x e verifique ||r|| mínimo.",
                                    "Confirme ortogonalidade: r perpendicular a colunas de A (A^T r ≈ 0).",
                                    "Compare com solução exata se conhecida ou pseudo-inversa.",
                                    "Analise condicionamento: cond(A) = ||Q|| ||R|| / min(diag(R)).",
                                    "Documente x final e métricas de qualidade."
                                  ],
                                  "verification": "||A x - b|| < tolerância e A^T (b - A x) ≈ 0.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Software para norma e produto A^T r",
                                  "tips": "Sempre compute resíduo relativo ||Ax - b|| / ||b||.",
                                  "learningObjective": "Validar numericamente soluções de mínimos quadrados.",
                                  "commonMistakes": "Aceitar solução sem checar resíduo; ignorar il-condicionamento."
                                }
                              ],
                              "practicalExample": "Para A = [[1,1],[1,2],[1,3]] (3x2), b = [1,2,3]^T. QR: Q ≈ [[-0.577, 0.707, 0.408], ...], R = [[-1.732, -2.309], [0, 0.577], [0,0]]. c = Q^T b ≈ [-3.464, 1.633]. x = back-sub R_upper x = c[1:2] → x ≈ [2.333, -0.333]. Resíduo ||Ax-b|| ≈ 0.163.",
                              "finalVerifications": [
                                "c = Q^T b computado corretamente com ||Q c - b|| pequeno.",
                                "Back-substitution em R x = c sem erros aritméticos.",
                                "Resíduo ||A x - b|| mínimo e r ⊥ col(A).",
                                "Solução x coincide com regressão linear OLS.",
                                "Análise de estabilidade numérica realizada.",
                                "Documentação completa de passos e resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erros < 1e-10 em verificações intermediárias.",
                                "Eficiência: escolha correta entre produto Q^T b vs. Householder.",
                                "Compreensão conceitual: explicar por que QR resolve mínimos quadrados.",
                                "Validação completa: todos resíduos e checks realizados.",
                                "Generalização: aplicar a matrizes de dimensões variadas.",
                                "Clareza na documentação: passos reproduzíveis."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Regressão linear múltipla via OLS.",
                                "Computação: Algoritmos numéricos em LAPACK (dgeqrf, dormqr).",
                                "Física: Ajuste de curvas em dados experimentais.",
                                "Data Science: Machine Learning pré-processamento com QR."
                              ],
                              "realWorldApplication": "Em data science, resolve regressão linear estável para grandes datasets (ex: previsão de vendas); em engenharia, ajuste de modelos paramétricos em simulações CFD sem amplificação de erros de arredondamento."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.2.2"
                            ]
                          },
                          {
                            "id": "10.1.4.3.3.3",
                            "name": "Calcular resíduos e testes de consistência",
                            "description": "Avaliar ||r||_2 = ||b - A x||_2 e usar diag(R) para detectar singularidade ou subcondição.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a decomposição QR e a solução x",
                                  "subSteps": [
                                    "Obtenha a matriz A e o vetor b do problema de mínimos quadrados.",
                                    "Confirme a decomposição QR: A = Q R, onde Q é ortogonal e R é triangular superior.",
                                    "Calcule ou recupere a solução x = R^{-1} (Q^T b).",
                                    "Verifique dimensionalidade: A (m x n), b (m x 1), x (n x 1).",
                                    "Armazene Q, R e x para uso posterior."
                                  ],
                                  "verification": "Verifique se A x ≈ Q (Q^T b) com erro pequeno (ex: norma < 1e-10).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matriz A",
                                    "Vetor b",
                                    "Biblioteca NumPy ou MATLAB para QR",
                                    "Solução x pré-calculada"
                                  ],
                                  "tips": [
                                    "Use funções prontas como np.linalg.qr() para validar manualmente.",
                                    "Mantenha cópias das matrizes originais."
                                  ],
                                  "learningObjective": "Compreender os pré-requisitos da decomposição QR para análise posterior.",
                                  "commonMistakes": [
                                    "Confundir Q e R",
                                    "Usar QR de A^T em vez de A",
                                    "Ignorar m > n em problemas superdeterminados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o vetor resíduo r = b - A x",
                                  "subSteps": [
                                    "Multiplique A por x para obter A x.",
                                    "Subtraia A x de b: r = b - A x.",
                                    "Verifique se r tem as dimensões corretas (m x 1).",
                                    "Exiba ou plote componentes de r para inspeção visual.",
                                    "Salve r para cálculos subsequentes."
                                  ],
                                  "verification": "Confirme que ||A x - b|| é mínimo comparado a outras aproximações.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matriz A",
                                    "Vetor x",
                                    "Vetor b",
                                    "Calculadora matricial ou software"
                                  ],
                                  "tips": [
                                    "Use operações vetorizadas para eficiência.",
                                    "Arredonde para precisão numérica consistente."
                                  ],
                                  "learningObjective": "Dominar o cálculo direto do vetor resíduo em mínimos quadrados.",
                                  "commonMistakes": [
                                    "Erro de sinal: r = A x - b",
                                    "Multiplicação matricial incorreta",
                                    "Ignorar zeros no final de r em casos consistentes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar a norma L2 do resíduo ||r||_2",
                                  "subSteps": [
                                    "Calcule a norma euclidiana: ||r||_2 = sqrt(r^T r) ou sqrt(sum(r_i^2)).",
                                    "Implemente manualmente e valide com função pronta (np.linalg.norm(r, 2)).",
                                    "Compare ||r||_2 com tolerâncias típicas (ex: 1e-6 * ||b||).",
                                    "Registre o valor para relatório.",
                                    "Analise se ||r||_2 é pequeno relativo a ||b||."
                                  ],
                                  "verification": "||r||_2 deve ser o menor possível para a solução ótima.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Vetor r",
                                    "Função de norma L2"
                                  ],
                                  "tips": [
                                    "Evite overflow em r grandes usando norma estabilizada.",
                                    "Log o valor para depuração."
                                  ],
                                  "learningObjective": "Aplicar norma L2 para quantificar erro de aproximação.",
                                  "commonMistakes": [
                                    "Usar norma L1 ou L-infinito por engano",
                                    "Esquecer raiz quadrada",
                                    "Normalizar incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Extrair e analisar a diagonal de R para detecção de problemas",
                                  "subSteps": [
                                    "Extraia diag(R): elementos R_{ii} para i=1 a n.",
                                    "Identifique entradas pequenas em diag(R) (ex: |R_{ii}| < 1e-10).",
                                    "Calcule razões de condição cond(R) ≈ |R_{11}/R_{nn}| para subcondição.",
                                    "Classifique: singular se R_{kk} ≈ 0 para algum k; subcondicionado se cond alta.",
                                    "Documente índices problemáticos."
                                  ],
                                  "verification": "Simule perturbação em A e verifique estabilidade de x.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matriz R triangular superior",
                                    "Critérios de tolerância numérica"
                                  ],
                                  "tips": [
                                    "Use log(|diag(R)|) para visualizar escalas.",
                                    "Considere pivoteamento em QR para melhor numérico."
                                  ],
                                  "learningObjective": "Detectar singularidade e subcondição via estrutura de R.",
                                  "commonMistakes": [
                                    "Analisar off-diagonal de R",
                                    "Ignorar tolerância absoluta vs relativa",
                                    "Confundir com cond(A) diretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Realizar testes de consistência e interpretar resultados",
                                  "subSteps": [
                                    "Verifique consistência: se ||r||_2 pequeno e diag(R) sem zeros, sistema bem-condicionado.",
                                    "Teste sensibilidade: perturbe b ou A e recalcule ||r||_2.",
                                    "Gere relatório: resuma ||r||_2, diag(R), conclusões.",
                                    "Compare com métodos alternativos (ex: SVD).",
                                    "Decida se solução é confiável."
                                  ],
                                  "verification": "Relatório deve justificar aceitação/rejeição da solução.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Resultados anteriores",
                                    "Ferramentas de plotagem"
                                  ],
                                  "tips": [
                                    "Defina thresholds baseados em precisão da máquina.",
                                    "Automatize em script para repetição."
                                  ],
                                  "learningObjective": "Integrar análises para validar soluções numéricas.",
                                  "commonMistakes": [
                                    "Superestimar precisão se ||r||_2 pequeno mas cond alta",
                                    "Ignorar ruído em dados reais",
                                    "Não testar múltiplos cenários"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 1], [1, 2], [2, 2]], b = [1, 2, 2]^T. Decomposição QR: Q = [...], R = [[1.73, 1.73], [0, 0.577], [0, 0]]. x ≈ [0, 1]^T. r = b - A x ≈ [0, 0.333, -0.333]^T. ||r||_2 ≈ 0.471. diag(R) = [1.73, 0.577] sem zeros, mas verifique cond ≈ 3 (moderado). Detecta colinearidade parcial.",
                              "finalVerifications": [
                                "Calcula corretamente r e ||r||_2 para exemplo dado.",
                                "Identifica entradas pequenas em diag(R) com tolerância adequada.",
                                "Interpreta cond(R) para classificar problema.",
                                "Valida consistência em caso superdeterminado.",
                                "Gera relatório com thresholds numéricos.",
                                "Compara com norma de b para normalização."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos (<1e-10 erro relativo).",
                                "Correta detecção de singularidade via diag(R).",
                                "Interpretação qualitativa e quantitativa de ||r||_2.",
                                "Uso apropriado de tolerâncias e normalizações.",
                                "Clareza no relatório de consistência.",
                                "Eficiência computacional nos steps."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementar em Python/NumPy para automação.",
                                "Estatística: Análise de resíduos em regressão linear.",
                                "Engenharia Computacional: Validação de modelos em simulações.",
                                "Física Computacional: Ajuste de curvas experimentais.",
                                "Machine Learning: Diagnóstico de overfitting/underfitting."
                              ],
                              "realWorldApplication": "Em processamento de sinais, calcular resíduos para validar filtros lineares; em finanças, testar consistência de modelos de regressão para previsões de séries temporais; em engenharia civil, analisar erros em simulações de estruturas sob cargas superdeterminadas."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.3.2"
                            ]
                          },
                          {
                            "id": "10.1.4.3.3.4",
                            "name": "Implementar algoritmo completo QR para LS em código",
                            "description": "Codificar em pseudocódigo ou MATLAB/Python a solução de mínimos quadrados via Householder QR, incluindo verificação de resíduos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o problema e configurar o ambiente de codificação",
                                  "subSteps": [
                                    "Defina a matriz A (m x n, m >= n, rank n) e vetor b (m x 1) representando o sistema superdeterminado Ax ≈ b.",
                                    "Escolha a linguagem: pseudocódigo, MATLAB ou Python com NumPy para operações matriciais.",
                                    "Implemente funções auxiliares para normas euclidianas e vetores zero.",
                                    "Crie uma estrutura inicial para a matriz Q e R ou armazene Householder vetores.",
                                    "Teste entrada: verifique dimensões e rank aproximado de A."
                                  ],
                                  "verification": "Código inicial executa sem erros e imprime dimensões corretas de A e b.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código (VS Code/Jupyter), Python/NumPy ou MATLAB instalado.",
                                  "tips": "Use NumPy arrays para eficiência; comece com dados pequenos para depuração.",
                                  "learningObjective": "Configurar corretamente o problema de mínimos quadrados e ambiente computacional.",
                                  "commonMistakes": "Confundir dimensões de A (linhas > colunas); não importar bibliotecas necessárias."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar decomposição QR usando reflexões Householder",
                                  "subSteps": [
                                    "Para cada coluna k de 1 a n-1: compute o vetor Householder v_k para zerar subdiagonal da coluna k.",
                                    "Calcule v_k = x - ||x|| e_1, onde x é subcoluna a partir de k, normalizando adequadamente.",
                                    "Aplique reflexão Householder à matriz A restante (atualizando A[k:m, k:n]).",
                                    "Armazene os vetores Householder ou construa Q explicitamente se necessário.",
                                    "Verifique que a parte superior de R é triangular superior após todas as reflexões."
                                  ],
                                  "verification": "Após QR, R é triangular superior e ||A - Q*R|| < epsilon (ex: 1e-10).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação NumPy/MATLAB para dot products e slicing de arrays.",
                                  "tips": "Implemente função householder_vector(x) reutilizável; evite construir Q full para economia.",
                                  "learningObjective": "Codificar o processo de estabilização QR via Householder para LS.",
                                  "commonMistakes": "Erro de sinal no vetor Householder (use norma positiva); overflow em normas sem normalização."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver o sistema de mínimos quadrados usando R triangular",
                                  "subSteps": [
                                    "Resolva Q^T b = c via aplicações sucessivas de Householder (ou multiplique Q^T * b).",
                                    "Resolva sistema triangular R x = c por substituição retroativa.",
                                    "Implemente função backsolve(R, c) para eficiência.",
                                    "Obtenha solução x e compute ||r|| = ||b - A x|| inicialmente.",
                                    "Compare com solução direta (ex: np.linalg.lstsq) para validação preliminar."
                                  ],
                                  "verification": "x satisfaz R x ≈ c com erro < 1e-12; resíduos iniciais calculados corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Exemplos de sistemas LS pequenos para teste unitário.",
                                  "tips": "Use loop for para backsolve; vetorize onde possível em NumPy.",
                                  "learningObjective": "Aplicar QR para obter solução LS estável numericamente.",
                                  "commonMistakes": "Esquecer de aplicar Householder a b; inverter ordem em substituição retroativa."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar verificação de resíduos e validação final",
                                  "subSteps": [
                                    "Compute resíduos r = b - A x e norma ||r||_2.",
                                    "Verifique ortogonalidade: Q^T Q ≈ I (se Q construído).",
                                    "Teste com múltiplos exemplos: overdetermined, ill-conditioned.",
                                    "Meça tempo de execução e compare com métodos built-in.",
                                    "Adicione comentários e docstrings ao código completo."
                                  ],
                                  "verification": "Resíduos < 1e-8 para dados teste; código roda em <1s para m=1000.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Dados teste: A=[[1,1],[1,2],[1,3]], b=[1,2,3]; matrizes condicionadas.",
                                  "tips": "Use assert para testes automáticos; plote resíduos vs iterações se aplicável.",
                                  "learningObjective": "Validar implementação QR-LS com métricas numéricas precisas.",
                                  "commonMistakes": "Não normalizar resíduos; ignorar conditioning number de A."
                                }
                              ],
                              "practicalExample": "Para A = [[1, 1], [1, 2], [1, 3]], b = [1, 2, 3], implemente QR Householder para obter x ≈ [0.5, 1.0], com ||r||_2 ≈ 0.447.",
                              "finalVerifications": [
                                "Decomposição QR resulta em R triangular superior com diagonais positivas.",
                                "Solução x minimiza ||A x - b||_2 corretamente (verificar com lstsq).",
                                "Resíduos r = b - A x têm norma < 1e-10 para precisão double.",
                                "Código executa sem warnings numéricos (NaN/inf).",
                                "Tempo de execução escalável para m=1000, n=100.",
                                "Ortogonalidade: colunas de Q têm norma 1 e são aproximadamente ortogonais."
                              ],
                              "assessmentCriteria": [
                                "Correção numérica: erro relativo em x < 1e-10 vs solução exata.",
                                "Estabilidade: funciona para matrizes ill-conditioned (cond(A)>1e6).",
                                "Eficiência: O(m n^2) tempo, sem loops desnecessários.",
                                "Clareza do código: comentários, funções modulares, pseudocódigo legível.",
                                "Robustez: trata casos edge (rank deficient aproximado).",
                                "Validação completa: inclui testes unitários para cada componente."
                              ],
                              "crossCurricularConnections": [
                                "Programação/Computação: Algoritmos numéricos e depuração.",
                                "Estatística: Regressão linear e ajuste de modelos.",
                                "Física: Simulações de sistemas lineares em mecânica.",
                                "Engenharia: Processamento de sinais e otimização."
                              ],
                              "realWorldApplication": "Em machine learning para regressão linear robusta em datasets grandes (ex: previsão de preços imobiliários); em processamento de imagens para estabilização de soluções superdeterminadas; em engenharia aeroespacial para ajuste de trajetórias via mínimos quadrados."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.3.2",
                              "10.1.4.3.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.4",
                        "name": "Análise de Estabilidade Numérica da Decomposição QR",
                        "description": "Estudo da sensibilidade da solução de mínimos quadrados em relação a perturbações, comparando com métodos diretos como normal equations.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.4.1",
                            "name": "Analisar sensibilidade condicional de mínimos quadrados",
                            "description": "Derivar bound ||Δx|| / ||x|| ≤ κ(A) ||Δb|| / ||b|| + κ(A)^2 ||ΔA|| / ||A||, destacando papel de κ(A).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar formulação dos mínimos quadrados e número de condição",
                                  "subSteps": [
                                    "Recordar que o problema de mínimos quadrados resolve min ||Ax - b||_2 para A m×n (m≥n, rank n).",
                                    "Apresentar a solução via equações normais: x = (A^T A)^{-1} A^T b.",
                                    "Definir o número de condição κ(A) = ||A||_2 ||A^{-1}||_2 (para quadrada) ou κ(A) = σ_max / σ_min via SVD.",
                                    "Explicar estabilidade numérica: κ(A) mede sensibilidade a perturbações.",
                                    "Discutir decomposição QR: A = QR, solução Rx = Q^T b, mais estável."
                                  ],
                                  "verification": "Escrever as fórmulas corretas e calcular κ(A) para uma matriz exemplo 2x2.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora ou Python/NumPy para SVD",
                                    "Livro: 'Matrix Computations' de Golub & Van Loan (cap. 5)"
                                  ],
                                  "tips": "Use normas 2-consistentes para simplificar bounds; foque em interpretação geométrica de κ(A).",
                                  "learningObjective": "Compreender a base teórica dos mínimos quadrados e o papel do número de condição na estabilidade.",
                                  "commonMistakes": [
                                    "Confundir κ(A) com det(A); ignorar que para retangular usa singular values."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir perturbações em A e b",
                                  "subSteps": [
                                    "Definir sistema perturbado: (A + ΔA)(x + Δx) ≈ b + Δb, aproximando para pequenos erros.",
                                    "Expandir: Ax + A Δx + ΔA x ≈ b + Δb (ignorando termo quadrático ΔA Δx).",
                                    "Reescrever como A Δx ≈ Δb - ΔA x.",
                                    "Tomar norma: ||A Δx|| ≤ ||Δb|| + ||ΔA|| ||x||.",
                                    "Dividir por ||A|| ||x|| para obter bound inicial relativo."
                                  ],
                                  "verification": "Derivar a desigualdade ||Δx|| / ||x|| ≤ (κ(A)/||b||) ||Δb|| + algo para ΔA.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software MATLAB/Python para simular perturbações pequenas"
                                  ],
                                  "tips": "Trabalhe com normas relativas desde o início: ||ΔA|| / ||A||, etc., para clareza.",
                                  "learningObjective": "Modelar matematicamente o impacto de erros em dados e matriz nos resultados.",
                                  "commonMistakes": [
                                    "Esquecer termo ΔA x; usar normas inconsistentes (ex: ||.||_∞ com ||.||_2)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o bound de sensibilidade condicional completo",
                                  "subSteps": [
                                    "Da equação A Δx ≈ Δb - ΔA x, multiplicar por A^{-1} (ou pseudoinversa).",
                                    "||Δx|| ≤ ||A^{-1}|| (||Δb|| + ||ΔA|| ||x||).",
                                    "Dividir por ||x||: ||Δx|| / ||x|| ≤ κ(A) ||Δb|| / ||Ax|| + κ(A) ||ΔA|| / ||A|| * (||Ax|| / ||x||) / ||Ax||.",
                                    "Notar ||Ax|| ≈ ||b||, e simplificar para bound final: ≤ κ(A) ||Δb|| / ||b|| + κ(A)^2 ||ΔA|| / ||A||.",
                                    "Usar propriedades: ||A^{-1}|| ||A|| = κ(A), e bound para ||x||."
                                  ],
                                  "verification": "Escrever exatamente o bound ||Δx|| / ||x|| ≤ κ(A) ||Δb|| / ||b|| + κ(A)^2 ||ΔA|| / ||A||.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência: Higham 'Accuracy and Stability of Numerical Algorithms' (seção 8.3)"
                                  ],
                                  "tips": "Prove passo a passo com desigualdades triangulares; verifique dimensões das normas.",
                                  "learningObjective": "Derivar rigorosamente o bound de erro relativo, conectando a equações normais.",
                                  "commonMistakes": [
                                    "Perder o fator κ(A)^2 no termo ΔA; assumir A quadrada invertible sem cuidado."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Destacar o papel de κ(A) e implicações práticas",
                                  "subSteps": [
                                    "Interpretar: κ(A) amplifica erro em b linearmente; κ(A)^2 amplifica erro em A quadraticamente.",
                                    "Discutir: Para QR, estabilidade forward é O(κ(A) ε_mach), backward O(ε_mach).",
                                    "Comparar com resolução direta: sensibilidade similar, mas QR mais estável computacionalmente.",
                                    "Recomendar: Pré-condicionar se κ(A) grande; regularizar (ex: ridge).",
                                    "Testar numericamente: perturbar A/b e medir ||Δx|| / ||x|| vs bound."
                                  ],
                                  "verification": "Explicar verbalmente por que κ(A)^2 no termo ΔA e simular exemplo confirmando bound.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python/NumPy ou MATLAB",
                                    "Exemplo matriz ill-conditioned (Vandermonde)"
                                  ],
                                  "tips": "Use logscale para plots de erro vs κ(A); sempre normalize erros relativos.",
                                  "learningObjective": "Analisar como κ(A) domina sensibilidade e estratégias de mitigação.",
                                  "commonMistakes": [
                                    "Subestimar impacto de ΔA em problemas overdetermined; ignorar conditioning em dados reais."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 0.1], [0.1, 1]] (κ(A)≈10), b=[1,1]^T. Solução x≈[0.91, 0.91]. Perturbe Δb=10^{-6}*b (rel err 10^{-6}), ΔA=10^{-6}*A. Compute x_pert via QR, verifique ||Δx||/||x|| ≈ 10*10^{-6} + 10^2 *10^{-6} = 1.1*10^{-4}, confirmando bound.",
                              "finalVerifications": [
                                "Derivação exata do bound com todas as etapas mostradas.",
                                "Interpretação correta do papel amplificador de κ(A) e κ(A)^2.",
                                "Exemplo numérico onde bound é tight (quase igualdade).",
                                "Discussão de implicações para QR vs normal equations.",
                                "Identificação de quando sensibilidade é crítica (κ(A)>10^6)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (sem erros em normas ou fatores).",
                                "Profundidade na interpretação do número de condição.",
                                "Uso correto de ferramentas numéricas para validação.",
                                "Clareza na conexão com estabilidade de QR.",
                                "Criatividade em exemplos e conexões práticas.",
                                "Identificação de erros comuns e prevenções."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementar análise de sensibilidade em Python (NumPy/SciPy).",
                                "Estatística: Aplicação em regressão linear e análise de resíduos.",
                                "Engenharia Computacional: Modelagem em simulações finitas (FEA).",
                                "Machine Learning: Condicionamento em least squares para otimização."
                              ],
                              "realWorldApplication": "Em análise de dados científicos, como ajuste de curvas em experimentos físicos ou regressão em finanças, esse bound explica por que matrizes mal-condicionadas (ex: dados colineares) levam a estimativas instáveis de parâmetros, guiando pré-processamento e escolha de algoritmos estáveis como QR em bibliotecas como LAPACK."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.4.2",
                            "name": "Comparar estabilidade QR vs Equações Normais",
                            "description": "Demonstrar que QR preserva κ(A) na solução, enquanto normal equations amplifica para κ(A)^2, usando análise de erros de arredondamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos de Condição Numérica e Erros de Arredondamento",
                                  "subSteps": [
                                    "Defina a condição numérica κ(A) = ||A|| * ||A^{-1}|| para matrizes quadradas e sua extensão para retangulares.",
                                    "Explique o erro relativo de arredondamento em operações de ponto flutuante: fl(a + b) ≈ (a + b)(1 + ε), com |ε| ≤ u (machine epsilon).",
                                    "Discuta como κ(A) amplifica erros na solução de sistemas lineares Ax = b.",
                                    "Estude o problema de mínimos quadrados: min ||Ax - b||_2 e sua sensibilidade.",
                                    "Calcule κ(A) para uma matriz exemplo 3x2 mal-condicionada."
                                  ],
                                  "verification": "Resuma em um parágrafo como κ(A) afeta a estabilidade e forneça o valor de κ para o exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Matrix Computations' de Golub & Van Loan (Cap. 2); Python com NumPy para calcular cond(A).",
                                  "tips": "Use np.linalg.cond() para verificação rápida; foque em interpretação, não só fórmula.",
                                  "learningObjective": "Compreender como κ(A) quantifica sensibilidade a perturbações.",
                                  "commonMistakes": "Confundir κ(A) com rank(A); ignorar que para mínimos quadrados, κ é baseado em A^T A."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Estabilidade das Equações Normais",
                                  "subSteps": [
                                    "Formule as equações normais: A^T A x = A^T b.",
                                    "Mostre que a condição efetiva é κ(A^T A) ≈ [κ(A)]^2.",
                                    "Derive bound de erro: ||δx|| / ||x|| ≤ [κ(A)]^2 * (||δb|| / ||b|| + ||δA|| / ||A||) * u.",
                                    "Implemente em código: resolva com np.linalg.solve((A.T @ A), A.T @ b).",
                                    "Perturbe A e b ligeiramente e observe amplificação de erro."
                                  ],
                                  "verification": "Calcule e compare erros relativos com e sem perturbação; erro deve crescer com [κ(A)]^2.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python/Jupyter com NumPy/SciPy; matriz exemplo A = [[1,1],[1e-6,1e-6+1e-8],[1,1+1e-10]].",
                                  "tips": "Use perturbações de ordem u * ||A||; plote log(erros) vs log(κ).",
                                  "learningObjective": "Demonstrar amplificação quadrática de erros nas equações normais.",
                                  "commonMistakes": "Usar solve direto sem formar A^T A explicitamente; ignorar ill-conditioning de A^T A."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Estabilidade da Decomposição QR",
                                  "subSteps": [
                                    "Lembre QR: A = QR com Q ortogonal (Q^T Q = I), R superior triangular.",
                                    "Formule solução: Rx = Q^T b, com forward substitution em R.",
                                    "Derive bound: ||δx|| / ||x|| ≤ κ(A) * (||δb|| / ||b|| + ||δA|| / ||A||) * u, pois ortogonalidade preserva normas.",
                                    "Implemente: qr = np.linalg.qr(A); x = solve(qr[1], qr[0].T @ b).",
                                    "Teste com mesmas perturbações e compare erros com equações normais."
                                  ],
                                  "verification": "Erro relativo deve ser proporcional a κ(A), não [κ(A)]^2.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Mesmos do Step 2; compare np.linalg.lstsq(A, b) (usa QR internamente).",
                                  "tips": "Verifique ortogonalidade com np.allclose(Q.T @ Q, np.eye(Q.shape[0])).",
                                  "learningObjective": "Entender preservação de condição pela ortogonalidade em QR.",
                                  "commonMistakes": "Confundir Householder vs Gram-Schmidt (use QR estável); não normalizar resíduos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Demonstrar Numericamente QR vs Equações Normais",
                                  "subSteps": [
                                    "Teoricamente: resuma diferenças κ(A) vs [κ(A)]^2 em tabela.",
                                    "Numéricamente: para A com κ(A) = 10^6, mostre erro QR ~10^{-10}, normais ~10^{-4}.",
                                    "Analise resíduos: ||Ax - b|| para ambos métodos.",
                                    "Discuta quando usar cada: QR sempre preferível para fatoreamento.",
                                    "Gere relatório com plots de erros vs tamanho de perturbação."
                                  ],
                                  "verification": "Explique em 200 palavras por que QR é superior; plots confirmam amplificação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Matplotlib para plots; exemplos de código de passos anteriores.",
                                  "tips": "Varie κ(A) de 10^2 a 10^12; use logscale em eixos.",
                                  "learningObjective": "Sintetizar comparação e validar teoricamente com experimentos.",
                                  "commonMistakes": "Usar A bem-condicionada (escolha κ grande); não medir erro relativo correto."
                                }
                              ],
                              "practicalExample": "Considere regressão linear para dados de temperatura vs altitude: A (10x2) com linhas quase colineares (κ(A)=10^8). Resolva min ||Ax - b||_2. Com perturbação u=1e-16 em b, equações normais dão x errada em 10^4%, QR em 0.01%. Plot mostra divergência.",
                              "finalVerifications": [
                                "Explicar corretamente bound de erro para equações normais como O(κ(A)^2 u).",
                                "Demonstrar numericamente erro QR = O(κ(A) u) com exemplo κ=10^6.",
                                "Comparar resíduos ||Ax - b||_2 para ambos métodos em matriz mal-condicionada.",
                                "Identificar ortogonalidade de Q como chave para estabilidade QR.",
                                "Discutir limitações: QR mais caro computacionalmente (2x normais).",
                                "Reproduzir análise para nova matriz A fornecida."
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação teórica de bounds de erro (80% peso).",
                                "Correção numérica: erros condizem com teoria (plots quantitativos).",
                                "Clareza na comparação: tabela ou gráfico destacando κ vs κ^2.",
                                "Profundidade: menciona forward substitution e propriedades ortogonais.",
                                "Originalidade: exemplo prático além do fornecido.",
                                "Completude: todos substeps implementados sem bugs."
                              ],
                              "crossCurricularConnections": [
                                "Computação Científica: Implementação em NumPy/SciPy para análise numérica.",
                                "Estatística: Estabilidade em regressão linear e least squares em dados reais.",
                                "Engenharia: Modelagem em controle de sistemas onde erros amplificados falham.",
                                "Física Computacional: Simulações com matrizes de discretização mal-condicionadas."
                              ],
                              "realWorldApplication": "Em machine learning, regressão linear com features correlacionadas (ex: imagens de satélite para previsão climática) usa QR para evitar overfitting numérico; NASA usa em ajustes orbitais onde [κ]^2 causaria erros catastróficos em trajetórias."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.4.1",
                              "10.1.4.3.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.4",
                    "name": "Decomposição em Valores Singulares (SVD) para Mínimos Quadrados",
                    "description": "Aplicação da SVD para encontrar a solução mínima de norma em problemas subdeterminados ou mal-condicionados.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.4.1",
                        "name": "Decomposição em Valores Singulares (SVD)",
                        "description": "Definição e propriedades fundamentais da decomposição SVD de uma matriz, incluindo matrizes ortogonais U e V, valores singulares diagonais Σ, e sua relação com o rank e a norma da matriz.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.1.1",
                            "name": "Definir e decompor uma matriz via SVD",
                            "description": "Explicar a forma SVD A = U Σ V^T para matrizes m x n reais, identificar os componentes U (ortogonal m x m), Σ (diagonal m x n com valores singulares σ_i ≥ 0 decrescentes) e V (ortogonal n x n), e computar SVD para matrizes pequenas usando ferramentas computacionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição Formal do SVD",
                                  "subSteps": [
                                    "Estude a equação canônica SVD para uma matriz real A de dimensões m × n: A = U Σ V^T.",
                                    "Identifique as dimensões e propriedades: U é matriz ortogonal m × m (U U^T = I_m), Σ é diagonal m × n com valores singulares σ_1 ≥ σ_2 ≥ ... ≥ σ_r ≥ 0 (r = rank(A)), V é ortogonal n × n (V V^T = I_n).",
                                    "Aprenda que os valores singulares σ_i são as raízes quadradas dos autovalores de A^T A (ou A A^T).",
                                    "Diferencie SVD completo (full) de SVD econômico (thin), onde U é m × r, Σ r × r, V n × r.",
                                    "Anote exemplos de dimensões para matrizes quadradas (m=n) e retangulares (m>n ou m<n)."
                                  ],
                                  "verification": "Reescreva a definição completa com dimensões e propriedades de memória em um papel.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de aula ou livro de Álgebra Linear (ex: Strang)",
                                    "Página da Wikipedia sobre SVD",
                                    "Caderno e caneta"
                                  ],
                                  "tips": [
                                    "Visualize U e V como rotações e Σ como escalas independentes.",
                                    "Lembre-se: V vem dos autovetores de A^T A, U de A A^T ou A V Σ^{-1}."
                                  ],
                                  "learningObjective": "Definir precisamente o SVD e seus componentes para matrizes reais m × n.",
                                  "commonMistakes": [
                                    "Confundir dimensões de U (m×m) e V (n×n).",
                                    "Esquecer que σ_i são não-negativos e decrescentes.",
                                    "Pensar que Σ é sempre quadrada."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Propriedades e Interpretação dos Componentes",
                                  "subSteps": [
                                    "Verifique ortogonalidade: multiplique U U^T e V V^T para obter identidades.",
                                    "Interprete σ_i: maior σ_1 captura mais 'energia' da matriz (||A||_2 = σ_1).",
                                    "Entenda interpretação geométrica: SVD decompõe A em rotações (U,V), escalas (Σ) e reflexão possível.",
                                    "Aprenda sobre rank(A) = número de σ_i > 0 e nulidade.",
                                    "Conecte com pseudoinversa: A^+ = V Σ^+ U^T, onde Σ^+ inverte σ_i > 0."
                                  ],
                                  "verification": "Liste e prove 4 propriedades chave do SVD (ortogonalidade, norma, rank) em um documento.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico como SymPy",
                                    "Exemplos de matrizes 2×2 impressas",
                                    "Vídeo introdutório sobre SVD (3Blue1Brown)"
                                  ],
                                  "tips": [
                                    "Use norma de Frobenius: soma σ_i^2 = ||A||_F^2 para checar.",
                                    "Pense em SVD como 'autovalores generalizados' para retangulares."
                                  ],
                                  "learningObjective": "Interpretar os componentes U, Σ, V e suas propriedades geométricas e algébricas.",
                                  "commonMistakes": [
                                    "Ignorar ordem decrescente dos σ_i.",
                                    "Confundir SVD com decomposição em autovalores (só para quadradas).",
                                    "Esquecer reflexão em V^T."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar SVD Manualmente para Matrizes Pequenas",
                                  "subSteps": [
                                    "Escolha matriz A 2×2 ou 2×3 pequena (ex: A = [[1,1],[0,1]]).",
                                    "Calcule A^T A (n×n), encontre autovalores λ_i e autovetores v_i normalizados para formar V.",
                                    "Compute σ_i = √λ_i (apenas σ_i > 0), forme Σ.",
                                    "Calcule u_i = (1/σ_i) A v_i para colunas de U, ortogonalize via Gram-Schmidt se necessário.",
                                    "Verifique reconstrução: U Σ V^T ≈ A (erro numérico pequeno)."
                                  ],
                                  "verification": "Decomponha uma matriz 2×2 manualmente e confirme ||A - U Σ V^T|| < 10^{-6}.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora científica",
                                    "Tabela de funções trigonométricas"
                                  ],
                                  "tips": [
                                    "Comece com matrizes simétricas positivas para simplicidade.",
                                    "Normalise vetores: ||v_i||=1 sempre."
                                  ],
                                  "learningObjective": "Executar cálculo passo a passo do SVD para matrizes de baixa dimensão.",
                                  "commonMistakes": [
                                    "Erro em autovetores não normalizados.",
                                    "Inverter ordem de σ_i.",
                                    "Não checar ortogonalidade de U."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Interpretar SVD com Ferramentas Computacionais",
                                  "subSteps": [
                                    "Instale ambiente: Python com NumPy/SciPy ou MATLAB.",
                                    "Escreva código: import numpy as np; U, s, Vh = np.linalg.svd(A, full_matrices=True).",
                                    "Forme Σ = np.diag(s); verifique A ≈ U @ Σ @ Vh.",
                                    "Compare com cálculo manual para matriz pequena; interprete top-σ_i.",
                                    "Experimente SVD econômico: full_matrices=False para economia."
                                  ],
                                  "verification": "Rode código para matriz 3×2, reconstrua A com erro < 1e-12 e plote σ_i.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Jupyter Notebook ou Google Colab",
                                    "Bibliotecas NumPy e SciPy",
                                    "Matriz teste 3×2"
                                  ],
                                  "tips": [
                                    "Use print(U @ U.T) ≈ I para checar.",
                                    "Vh é V^T, não V!"
                                  ],
                                  "learningObjective": "Usar software para decompor matrizes reais e validar resultados.",
                                  "commonMistakes": [
                                    "Confundir s (vetor) com Σ (diagonal).",
                                    "Esquecer full_matrices para dimensões exatas.",
                                    "Ignorar warnings numéricos."
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[3, 0], [0, 2]] (2×2 diagonal), SVD é U = [[1,0],[0,1]], Σ = [[3,0],[0,2]], V = [[1,0],[0,1]]. Reconstrução perfeita. Para A = [[1,2],[3,4]] (aprox.), np.linalg.svd dá σ ≈ [5.464, 0.365], capturando 99.8% energia no primeiro modo.",
                              "finalVerifications": [
                                "Escrever a forma SVD A = U Σ V^T com dimensões corretas.",
                                "Identificar U, Σ, V em um exemplo dado.",
                                "Computar SVD manual para matriz 2×2 com erro <1e-5.",
                                "Executar SVD em Python/MATLAB para 3×2 e verificar reconstrução.",
                                "Explicar por que σ_1 é a maior norma singular.",
                                "Listar 3 propriedades (ortogonalidade, rank, pseudoinversa)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e dimensões (100% correto).",
                                "Correção numérica do cálculo manual e computacional (erro <1e-10).",
                                "Interpretação adequada de componentes e valores singulares.",
                                "Validação completa via reconstrução e propriedades.",
                                "Conexão clara com aplicações como mínimos quadrados."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: PCA via SVD para redução de dimensionalidade.",
                                "Ciência da Computação: Algoritmos numéricos e estabilidade.",
                                "Engenharia: Análise de sinais e compressão de dados.",
                                "Machine Learning: Fatorização de matrizes em recomendadores."
                              ],
                              "realWorldApplication": "SVD é essencial em sistemas de recomendação (Netflix fatoriza matrizes usuário-filme), compressão de imagens (JPEG2000 usa SVD para redução de rank), e resolução de mínimos quadrados superdeterminados em regressão linear com multicolinearidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.2",
                            "name": "Interpretar propriedades da SVD",
                            "description": "Analisar o rank da matriz como o número de valores singulares positivos, a norma 2 como o maior valor singular σ_1, e as aproximações de baixo rank via truncamento de Σ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Decomposição em Valores Singulares (SVD)",
                                  "subSteps": [
                                    "Estude a forma SVD de uma matriz A m×n: A = U Σ V^T, onde U é m×m ortogonal, Σ é m×n diagonal com valores singulares σ_i ≥ 0 em ordem decrescente, e V é n×n ortogonal.",
                                    "Identifique os valores singulares σ_i como as raízes quadradas dos autovalores da matriz A^T A ou A A^T.",
                                    "Visualize geometricamente para matrizes 2×2: os σ_i representam alongamentos em direções principais.",
                                    "Pratique decompondo uma matriz simples manualmente ou com software.",
                                    "Anote as propriedades chave: σ_1 ≥ σ_2 ≥ ... ≥ σ_r > 0, onde r é o rank."
                                  ],
                                  "verification": "Explique os três componentes da SVD (U, Σ, V) e suas propriedades para uma matriz exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de anotações sobre SVD",
                                    "Calculadora ou Python com NumPy",
                                    "Matriz exemplo 3×2"
                                  ],
                                  "tips": "Comece com matrizes pequenas para intuição; use plots para visualizar transformações.",
                                  "learningObjective": "Compreender a estrutura e propriedades fundamentais da SVD.",
                                  "commonMistakes": [
                                    "Confundir U (esquerda) com V (direita)",
                                    "Esquecer que σ_i são não-negativos e ordenados",
                                    "Ignorar dimensões de U e V"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar o Rank da Matriz via Valores Singulares",
                                  "subSteps": [
                                    "Defina o rank de A como o número de valores singulares positivos σ_i > 0.",
                                    "Conte os σ_i > 0 na diagonal de Σ para determinar rank(A) = r.",
                                    "Verifique que colunas de U e V correspondentes a σ_i > 0 formam bases para espaços coluna e linha.",
                                    "Compare com rank via eliminação gaussiana para validação.",
                                    "Discuta nulidade: número de σ_i = 0 é n - rank(A)."
                                  ],
                                  "verification": "Dado Σ com σ = [5, 3, 0, 0], afirme corretamente rank = 2 e justifique.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos de Σ de diferentes ranks",
                                    "Software como MATLAB ou Jupyter Notebook"
                                  ],
                                  "tips": "Sempre ordene σ_i decrescentemente; tolerância numérica para 'quase zero' em computação.",
                                  "learningObjective": "Associar rank matricial diretamente ao número de σ_i positivos.",
                                  "commonMistakes": [
                                    "Contar todos σ_i incluindo zeros",
                                    "Confundir com dimensão de Σ",
                                    "Ignorar tolerâncias numéricas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar a Norma 2 via Maior Valor Singular",
                                  "subSteps": [
                                    "Lembre que a norma 2 de A, ||A||_2 = sup ||Ax||_2 / ||x||_2 = σ_1, o maior valor singular.",
                                    "Demonstre geometricamente: σ_1 é o maior alongamento de vetores unitários.",
                                    "Calcule ||A||_2 = sqrt(λ_max(A^T A)) e relacione com σ_1.",
                                    "Aplique a uma matriz exemplo: compute SVD e verifique norma.",
                                    "Discuta implicações: cond(A) = σ_1 / σ_r mede ill-condição."
                                  ],
                                  "verification": "Para uma matriz A, compute SVD e confirme ||A||_2 = σ_1 com cálculo direto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Função svd() em Python/Octave",
                                    "Matrizes com normas conhecidas"
                                  ],
                                  "tips": "Use power iteration para aproximar σ_1 se SVD for custosa.",
                                  "learningObjective": "Reconhecer σ_1 como a norma espectral (2-norm) da matriz.",
                                  "commonMistakes": [
                                    "Confundir com norma Frobenius (sqrt(sum σ_i^2))",
                                    "Usar σ_min em vez de σ_max",
                                    "Esquecer normalização de vetores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender Aproximações de Baixo Rank via Truncamento de Σ",
                                  "subSteps": [
                                    "Defina A_k = U_k Σ_k V_k^T, truncando Σ para primeiros k σ_i > 0, k < r.",
                                    "Teorema de Eckart-Young: A_k minimiza ||A - B||_2 sobre rank(B) ≤ k.",
                                    "Compute erro: ||A - A_k||_2 = σ_{k+1}.",
                                    "Aplique a uma matriz ruidosa: compare A_k com A original.",
                                    "Discuta compressão: armazene apenas top-k singular triples."
                                  ],
                                  "verification": "Construa A_1 para uma matriz 5×5 e mostre que é a melhor aproximação rank-1.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código Python para truncar SVD",
                                    "Matriz imagem ou dados reais"
                                  ],
                                  "tips": "Escolha k onde σ_k >> σ_{k+1} (joelho na curva scree).",
                                  "learningObjective": "Aplicar truncamento SVD para aproximações ótimas de baixo rank.",
                                  "commonMistakes": [
                                    "Truncar incorretamente U/V além de Σ",
                                    "Ignorar ordenação de σ",
                                    "Confundir normas de erro"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[3, 1, 1], [-1, 3, 1]]. SVD: σ ≈ [4.24, 2, 0]. Rank=2 (dois σ>0). ||A||_2 = 4.24. A_1 (truncar a σ_2) ≈ [[2.83, 0.94, 0.94], [-0.94, 2.83, 0.94]], melhor rank-1 approx com erro σ_2=2.",
                              "finalVerifications": [
                                "Calcule corretamente rank(A) contando σ_i > 0.",
                                "Identifique ||A||_2 = σ_1 em uma SVD computada.",
                                "Construa e justifique A_k como aproximação de baixo rank.",
                                "Explique geometricamente σ_1 como alongamento máximo.",
                                "Verifique ||A - A_k||_2 = σ_{k+1} numericamente.",
                                "Discuta cond(A) = σ_1/σ_min."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de rank, σ_1 e A_k (erro < 1e-6).",
                                "Compreensão conceitual: explique propriedades sem fórmulas erradas.",
                                "Uso correto de tolerâncias numéricas para σ ≈ 0.",
                                "Aplicação a exemplos reais com interpretação qualitativa.",
                                "Identificação de erros comuns e justificativas claras.",
                                "Conexão entre truncamento e minimização de norma."
                              ],
                              "crossCurricularConnections": [
                                "Machine Learning: Redução dimensional em PCA via SVD truncada.",
                                "Processamento de Imagens: Compressão JPEG-like com SVD de blocos.",
                                "Física Computacional: Análise de modos principais em simulações.",
                                "Estatística: Detecção de rank efetivo em dados ruidosos."
                              ],
                              "realWorldApplication": "Em sistemas de recomendação como Netflix, SVD truncada (rank baixo) aproxima matriz usuário-item, reduzindo dimensionalidade e capturando padrões latentes para previsões precisas com dados esparsos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.3",
                            "name": "Relacionar SVD com ortogonalização",
                            "description": "Comparar SVD com decomposições QR e eigendecomposição, destacando sua generalidade para matrizes retangulares e não simétricas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de SVD, QR e Eigendecomposição",
                                  "subSteps": [
                                    "Estude a definição de SVD: A = U Σ V^T, onde U e V são ortogonais.",
                                    "Revise QR: A = Q R, com Q ortogonal e R triangular superior.",
                                    "Analise eigendecomposição: A = Q Λ Q^{-1}, para matrizes simétricas A = Q Λ Q^T.",
                                    "Identifique as bases ortogonais em cada decomposição.",
                                    "Anote as condições: SVD para qualquer m x n, QR para quadradas ou retangulares, eigen para quadradas simétricas."
                                  ],
                                  "verification": "Resuma em um parágrafo as três decomposições e suas matrizes ortogonais principais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Álgebra Linear (ex: Strang), notas de aula, calculadora ou Python/NumPy.",
                                  "tips": "Desenhe diagramas das decomposições para visualizar ortogonalidade.",
                                  "learningObjective": "Compreender as estruturas ortogonais básicas de cada método.",
                                  "commonMistakes": "Confundir V^T em SVD com inversa em vez de transposta."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Comparar Requisitos e Aplicabilidades das Decomposições",
                                  "subSteps": [
                                    "Liste matrizes suportadas: SVD (retangulares m≠n), QR (colunas ≤ linhas), eigen (quadradas simétricas).",
                                    "Compare estabilidade numérica: SVD mais estável para ill-conditioned.",
                                    "Discuta ortogonalização: U e V em SVD, Q em QR, Q em eigen.",
                                    "Calcule exemplos pequenos manualmente para matrizes retangulares vs. quadradas.",
                                    "Registre limitações: eigen falha em não-simétricas, QR não diagonaliza."
                                  ],
                                  "verification": "Crie uma tabela comparativa com colunas para tipo de matriz, ortogonalidade e uso.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel e lápis, MATLAB/Octave ou Jupyter Notebook com NumPy.",
                                  "tips": "Use svd(), qr(), eig() em software para validar manualmente.",
                                  "learningObjective": "Identificar quando cada decomposição é aplicável e suas diferenças ortogonais.",
                                  "commonMistakes": "Ignorar que QR pode ser para retangulares mas não generaliza como SVD."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Conexões com Ortogonalização",
                                  "subSteps": [
                                    "Explique como SVD generaliza Gram-Schmidt (ortogonalização de colunas via V).",
                                    "Compare com QR: ambos produzem bases ortogonais, mas SVD adiciona singular values.",
                                    "Relacione eigen com SVD para simétricas: SVD é caso especial.",
                                    "Demonstre economic SVD para rank-deficient matrices.",
                                    "Discuta propriedades: colunas de U/V ortonormais em ambos SVD/QR."
                                  ],
                                  "verification": "Escreva 3 equações mostrando ortogonalidade (U^T U = I, etc.).",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Referências online (Wikipedia SVD), software de álgebra linear.",
                                  "tips": "Foquem em U e V como transformações ortogonais rotacionais.",
                                  "learningObjective": "Relacionar SVD como extensão ortogonal para casos gerais.",
                                  "commonMistakes": "Pensar que QR é mais geral que SVD para retangulares não-quadradas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Destacar Generalidade da SVD e Sintetizar Comparação",
                                  "subSteps": [
                                    "Compile vantagens SVD: funciona para retangulares/não-simétricas, robusta.",
                                    "Compare em mínimos quadrados: SVD resolve Ax≈b generalizado.",
                                    "Crie fluxograma: escolha decomposição baseada em forma da matriz.",
                                    "Teste com exemplo retangular: compute SVD vs tentativa de eigen.",
                                    "Conclua com unicidade da SVD em ortogonalidade e singular values."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que SVD é preferida para generalidade.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Exemplos numéricos prontos, planilha ou código Python.",
                                  "tips": "Sempre normalize singular values para comparar escalas.",
                                  "learningObjective": "Sintetizar por que SVD supera QR/eigen em versatilidade ortogonal.",
                                  "commonMistakes": "Subestimar custo computacional da SVD vs QR mais rápida."
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 2], [3, 4], [5, 0]] (3x2 retangular). SVD: U(3x3) Σ(3x2) V^T(2x2), com U,V ortogonais. QR: Q(3x2) R(2x2). Eigendecomposição falha (não quadrada). SVD generaliza ortogonalizando linhas/colunas via U/V.",
                              "finalVerifications": [
                                "Pode listar 3 diferenças chave entre SVD e QR em ortogonalidade?",
                                "Explica por que SVD funciona para matrizes retangulares não-simétricas?",
                                "Compara corretamente SVD com eigendecomposição para simétricas?",
                                "Identifica bases ortogonais em cada decomposição?",
                                "Aplica SVD em um exemplo retangular com sucesso?",
                                "Discute limitações de QR/eigen vs generalidade SVD?"
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual das comparações (80%)",
                                "Compreensão de ortogonalidade e generalidade (90%)",
                                "Uso correto de exemplos numéricos (85%)",
                                "Clareza na tabela/fluxograma comparativo (75%)",
                                "Identificação de erros comuns evitados (80%)",
                                "Síntese de vantagens SVD (90%)"
                              ],
                              "crossCurricularConnections": [
                                "Machine Learning: SVD em PCA para redução dimensional.",
                                "Processamento de Sinais: Compressão via low-rank SVD.",
                                "Computação Gráfica: Transformações ortogonais em V de SVD.",
                                "Estatística: Análise de componentes principais via eigen/SVD."
                              ],
                              "realWorldApplication": "Em sistemas de recomendação (Netflix), SVD decompõe matrizes usuário-item retangulares em U Σ V^T, usando ortogonalidade para fatorar preferências latentes, generalizando além de matrizes simétricas."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.2",
                        "name": "Pseudoinversa de Moore-Penrose via SVD",
                        "description": "Construção da pseudoinversa A^+ usando SVD para resolver problemas de mínimos quadrados lineares, garantindo soluções únicas com propriedades ortogonais.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.2.1",
                            "name": "Construir a pseudoinversa com SVD",
                            "description": "Calcular A^+ = V Σ^+ U^T, onde Σ^+ inverte os valores singulares não-nulos e zera os nulos, e verificar as quatro propriedades de Penrose (A A^+ A = A, etc.).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Executar a Decomposição em Valores Singulares (SVD) da matriz A",
                                  "subSteps": [
                                    "Identifique as dimensões da matriz A (m x n) e confirme se m ≥ n ou n ≥ m para orientação.",
                                    "Use uma ferramenta computacional ou método analítico para decompor A em A = U Σ V^T, onde U é m x m ortogonal, Σ é m x n diagonal com valores singulares σ_i ≥ 0 em ordem decrescente, e V é n x n ortogonal.",
                                    "Verifique a decomposição multiplicando U Σ V^T e confirmando que resulta em A com tolerância numérica pequena (ex: 1e-10).",
                                    "Anote os valores singulares não-nulos e seus índices."
                                  ],
                                  "verification": "Multiplicação U Σ V^T ≈ A com erro residual mínimo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software Python com NumPy/SciPy (np.linalg.svd)",
                                    "Matriz A de exemplo (papel ou Jupyter Notebook)",
                                    "Calculadora matricial para casos pequenos"
                                  ],
                                  "tips": [
                                    "Sempre use a opção full_matrices=True em np.linalg.svd para U e V completos.",
                                    "Normalize manualmente se necessário para precisão numérica."
                                  ],
                                  "learningObjective": "Dominar a aplicação prática da SVD em matrizes reais.",
                                  "commonMistakes": [
                                    "Ignorar tolerância numérica levando a erros de arredondamento.",
                                    "Confundir V^T com V na decomposição."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz diagonal pseudoinversa Σ^+",
                                  "subSteps": [
                                    "Liste os valores singulares σ_i de Σ, identificando os não-nulos (σ_i > ε, onde ε é tolerância como 1e-12).",
                                    "Crie Σ^+ com dimensões n x m: inverta os σ_i não-nulos (1/σ_i) na diagonal correspondente e defina zeros para σ_i = 0.",
                                    "Posicione os elementos de Σ^+ transpondo adequadamente: os inversos vão nas posições diagonais invertidas.",
                                    "Verifique que Σ Σ^+ Σ = Σ multiplicando para confirmação parcial."
                                  ],
                                  "verification": "Σ^+ tem 1/σ_i onde σ_i > 0 e 0 caso contrário, com dimensões corretas n x m.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Σ da etapa anterior",
                                    "Python ou MATLAB para manipulação diagonal"
                                  ],
                                  "tips": [
                                    "Use np.diag(1/np.where(s > eps, s, 0)) em Python para automação.",
                                    "Escolha ε baseado na precisão da máquina (machine epsilon)."
                                  ],
                                  "learningObjective": "Entender como tratar singularidades na pseudoinversa.",
                                  "commonMistakes": [
                                    "Inverter todos os σ_i incluindo zeros, causando instabilidade.",
                                    "Esquecer de transpor dimensões para Σ^+ (n x m)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montar a pseudoinversa A^+ = V Σ^+ U^T",
                                  "subSteps": [
                                    "Transpose U para obter U^T (m x m).",
                                    "Multiplique V (n x n) por Σ^+ (n x m) resultando em V Σ^+ (n x m).",
                                    "Multiplique o resultado por U^T (m x m) para obter A^+ (n x m).",
                                    "Verifique dimensionalmente: entrada m x n vira saída n x m."
                                  ],
                                  "verification": "A^+ tem dimensões corretas n x m e pode ser multiplicada por vetores adequadamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "U, Σ^+, V do passos anteriores",
                                    "Ambiente computacional para multiplicações matriciais"
                                  ],
                                  "tips": [
                                    "Use @ para multiplicação matricial em Python (NumPy) para eficiência.",
                                    "Armazene intermediários para depuração."
                                  ],
                                  "learningObjective": "Aplicar a fórmula composta da pseudoinversa via SVD.",
                                  "commonMistakes": [
                                    "Ordem errada: lembrar V Σ^+ U^T, não U Σ V.",
                                    "Não transpor U corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar as quatro propriedades de Penrose da pseudoinversa",
                                  "subSteps": [
                                    "Calcule A A^+ A e verifique se igual a A (propriedade 1).",
                                    "Calcule A^+ A A^+ e verifique se igual a A^+ (propriedade 2).",
                                    "Calcule A A^+ e verifique se é hermitiana: (A A^+)^T = A A^+ (propriedade 3).",
                                    "Calcule A^+ A e verifique se é hermitiana: (A^+ A)^T = A^+ A (propriedade 4).",
                                    "Use tolerância numérica para todas igualdades (||X - Y|| < 1e-10)."
                                  ],
                                  "verification": "Todas quatro propriedades satisfeitas dentro de tolerância numérica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "A e A^+ computados",
                                    "Funções de norma matricial (np.linalg.norm)"
                                  ],
                                  "tips": [
                                    "Implemente uma função de verificação em loop para as propriedades.",
                                    "Hermitianas são simétricas para reais."
                                  ],
                                  "learningObjective": "Confirmar matematicamente que A^+ é a pseudoinversa de Moore-Penrose.",
                                  "commonMistakes": [
                                    "Usar igualdade exata sem tolerância em computação numérica.",
                                    "Confundir propriedades 3 e 4 (A A^+ vs A^+ A)."
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[1, 2, 0], [0, 0, 3]] (2x3), SVD dá U ≈ [[-0.707, 0.707], [0.707, 0.707]], Σ = diag([3.606, 1]), V^T ≈ [[0.832, 0.555, 0], [-0.525, 0.832, 0.196], [0, -0.094, 0.995]] (aprox.). Então Σ^+ = diag([0.277, 1], zeros), A^+ = V Σ^+ U^T ≈ [[0.122, 0.277], [0.082, 0.183], [0, 0.592]]. Verificações: A A^+ A ≈ A, etc.",
                              "finalVerifications": [
                                "SVD de A verificada: ||A - U Σ V^T|| < 1e-10.",
                                "Σ^+ corretamente formada com inversos apenas para σ_i > 1e-12.",
                                "A^+ = V Σ^+ U^T com dimensões n x m.",
                                "Propriedade 1: ||A A^+ A - A|| < 1e-10.",
                                "Propriedade 2: ||A^+ A A^+ - A^+|| < 1e-10.",
                                "Propriedade 3: ||(A A^+)^T - A A^+|| < 1e-10.",
                                "Propriedade 4: ||(A^+ A)^T - A^+ A|| < 1e-10."
                              ],
                              "assessmentCriteria": [
                                "Precisão da SVD (erro < 1e-12).",
                                "Correção na construção de Σ^+ (inversos exatos para não-nulos).",
                                "Eficiência na montagem de A^+ sem erros de ordem.",
                                "Completude das verificações de Penrose com tolerâncias apropriadas.",
                                "Uso correto de ferramentas numéricas sem instabilidades.",
                                "Clareza na documentação dos passos e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementar SVD em Python/NumPy para automação.",
                                "Estatística: Aplicar em regressão linear com multicolinearidade.",
                                "Processamento de Imagens: Redução de ruído via truncada SVD.",
                                "Machine Learning: Solução de mínimos quadrados em redes neurais.",
                                "Engenharia de Controle: Inversão de sistemas não quadrados."
                              ],
                              "realWorldApplication": "A pseudoinversa via SVD resolve sistemas lineares superdeterminados (ex: regressão com mais observações que variáveis) ou subdeterminados, amplamente usada em machine learning para previsão, processamento de sinais para filtro ótimo, e robótica para cinemática inversa minimizando erro."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.2.2",
                            "name": "Resolver Ax = b com pseudoinversa",
                            "description": "Aplicar x = A^+ b para encontrar a solução de mínimos quadrados ||Ax - b||_2 mínima, e em casos consistentes, a solução única.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Problema de Mínimos Quadrados e a Pseudoinversa",
                                  "subSteps": [
                                    "Revise o sistema Ax = b onde A é m x n (m > n, overdetermined).",
                                    "Explique por que soluções exatas podem não existir e introduza o critério de mínimos quadrados: minimizar ||Ax - b||_2.",
                                    "Defina a pseudoinversa de Moore-Penrose A^+ como a solução x que minimiza a norma e tem menor norma entre soluções.",
                                    "Discuta condições: quando o sistema é consistente, A^+ dá a solução única de menor norma.",
                                    "Compare com soluções normais: A^+ = (A^T A)^{-1} A^T quando A tem posto completo."
                                  ],
                                  "verification": "Resuma em suas palavras o papel da pseudoinversa e dê um exemplo simples onde Ax = b não tem solução exata.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang), Notas sobre SVD",
                                    "Calculadora ou papel para exemplos manuais"
                                  ],
                                  "tips": "Visualize graficamente: linha de regressão melhor ajustada a pontos.",
                                  "learningObjective": "Entender conceitualmente quando e por que usar a pseudoinversa para resolver Ax = b.",
                                  "commonMistakes": [
                                    "Confundir com inversa padrão (só para quadrada e invertível)",
                                    "Ignorar que minimiza ||Ax - b||_2, não erro absoluto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Decomposição em Valores Singulares (SVD) de A",
                                  "subSteps": [
                                    "Lembre a SVD: A = U Σ V^T, onde U (m x m ortogonal), Σ (m x n diagonal com σ_i ≥ 0), V (n x n ortogonal).",
                                    "Ordene σ_1 ≥ σ_2 ≥ ... ≥ σ_r > 0, r = posto(A).",
                                    "Use software para computar SVD (NumPy: np.linalg.svd(A, full_matrices=True)).",
                                    "Identifique valores singulares não-nulos para determinar o posto.",
                                    "Verifique: A ≈ U[:, :r] @ Σ[:r, :r] @ V[:r, :]^T para aproximação de posto baixo."
                                  ],
                                  "verification": "Compute SVD de uma matriz A de exemplo 3x2 e liste U, Σ, V^T.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "MATLAB ou Octave",
                                    "Matriz de teste: A = [[1,1],[1,2],[2,1]]"
                                  ],
                                  "tips": "Sempre use full_matrices=True para pseudoinversa completa.",
                                  "learningObjective": "Dominar o cálculo e interpretação da SVD como base para pseudoinversa.",
                                  "commonMistakes": [
                                    "Esquecer de ordenar valores singulares decrescentes",
                                    "Confundir U e V (U para linhas, V para colunas)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a Pseudoinversa A^+ a partir da SVD",
                                  "subSteps": [
                                    "Formule A^+ = V Σ^+ U^T, onde Σ^+ é a pseudoinversa de Σ: diagonal com 1/σ_i para i=1..r, zeros elsewhere.",
                                    "Para Σ (m x n), Σ^+ é n x m com 1/σ_i na posição (i,i) se σ_i > 0.",
                                    "Compute Σ^+ explicitamente: inverta diagonal não-nula e transpose dimensões.",
                                    "Multiplique: primeiro Σ^+ U^T, depois V vezes isso.",
                                    "Use função built-in para verificar: np.linalg.pinv(A).",
                                    "verification]: "
                                  ],
                                  "verification": "Para a SVD do Step 2, compute A^+ manualmente e compare com pinv(A).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código Python: import numpy as np; pinv = np.linalg.pinv",
                                    "Papel para Σ^+ manual"
                                  ],
                                  "tips": "Regra prática: zeros em Σ^+ onde σ_i = 0 (regularização implícita).",
                                  "learningObjective": "Construir A^+ via SVD e entender sua generalidade (funciona para qualquer A).",
                                  "commonMistakes": [
                                    "Invertendo σ_i = 0 (leva a instabilidade)",
                                    "Erro na transposição: Σ^+ tem dims trocadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver x = A^+ b e Validar a Solução",
                                  "subSteps": [
                                    "Compute x = A^+ @ b usando a pseudoinversa calculada.",
                                    "Calcule resíduo r = b - A @ x e verifique ||r||_2 mínimo.",
                                    "Se posto completo à direita, cheque se A @ x está no espaço-coluna de A.",
                                    "Para sistema consistente, verifique se r = 0 e ||x||_2 mínimo.",
                                    "Teste estabilidade: adicione ruído a b e veja robustez."
                                  ],
                                  "verification": "Resolva Ax = b com seu exemplo, compute ||Ax - b||_2 e compare com outras soluções (ex: normal eqs).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmo código Python",
                                    "Vetor b exemplo: [1,2,2] para A acima"
                                  ],
                                  "tips": "Sempre plote resíduo vs iterações se aplicável.",
                                  "learningObjective": "Aplicar pseudoinversa para obter e validar solução ótima.",
                                  "commonMistakes": [
                                    "Não verificar ortogonalidade de resíduos a colunas de A",
                                    "Assumir x único sem checar consistência"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 0], [0, 1], [1, 1]] (3x2), b = [1, 1, 2.1]^T (ruído). SVD dá A^+ ≈ [[0.545, 0.0, 0.545], [0.0, 1.0, 0.545]], x = A^+ b ≈ [1.09, 1.09], ||Ax - b||_2 ≈ 0.1 (mínimo). Útil para regressão linear com 2 variáveis.",
                              "finalVerifications": [
                                "x = A^+ b satisfaz A x ≈ b com ||Ax - b||_2 mínimo.",
                                "Resíduos r = b - Ax ⊥ espaço-coluna de A (A^T r = 0).",
                                "Entre soluções de mínimos quadrados, x tem norma ||x||_2 mínima.",
                                "SVD de A tem valores singulares corretos e A^+ A A^+ = A^+.",
                                "Código reproduz resultado com pinv() e manual.",
                                "Solução estável a pequenas perturbações em b."
                              ],
                              "assessmentCriteria": [
                                "Explicação conceitual precisa de pseudoinversa e mínimos quadrados (20%).",
                                "Cálculo correto de SVD e A^+ para exemplo dado (30%).",
                                "Solução x validada com métricas ||Ax-b|| e propriedades (20%).",
                                "Uso correto de software e verificação manual (15%).",
                                "Identificação de casos especiais (consistente/inconsistente, posto baixo) (15%)."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação em NumPy/SciPy para ML (sklearn usa internamente).",
                                "Estatística: Regressão linear ordinária (OLS) via mínimos quadrados.",
                                "Engenharia: Processamento de sinais, filtro de Kalman com SVD.",
                                "Física: Ajuste de curvas em dados experimentais overdetermined."
                              ],
                              "realWorldApplication": "Em Machine Learning, resolve regressão linear em datasets grandes (ex: previsão de preços de casas com features > amostras); em processamento de imagens, estabiliza inversão de sistemas mal-condicionados como desfoque."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.3",
                        "name": "Aplicação da SVD em problemas subdeterminados e mal-condicionados",
                        "description": "Uso da SVD para obter a solução de norma mínima em sistemas subdeterminados (m < n) e analisar/regularizar problemas mal-condicionados via valores singulares pequenos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.3.1",
                            "name": "Encontrar solução mínima de norma em subdeterminados",
                            "description": "Para sistemas subdeterminados consistentes, usar x = A^+ b = V Σ^+ U^T b para obter a solução com menor norma ||x||_2 entre todas as soluções possíveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Verificar condições do sistema e decompor SVD de A",
                                  "subSteps": [
                                    "Confirme que m < n (subdeterminado: mais variáveis que equações)",
                                    "Verifique consistência: rank(A) = rank([A|b])",
                                    "Calcule a SVD de A: A = U Σ V^T, onde U (m x m), Σ (m x n), V (n x n)",
                                    "Identifique os valores singulares não-nulos em Σ",
                                    "Armazene U, Σ e V para uso posterior"
                                  ],
                                  "verification": "SVD decomposta corretamente: A ≈ U Σ V^T com erro numérico < 1e-10",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Matriz A (m x n), vetor b (m x 1)",
                                    "Software: Python (numpy.linalg.svd) ou MATLAB"
                                  ],
                                  "tips": "Use SVD econômica (thin SVD) para eficiência em m << n",
                                  "learningObjective": "Compreender e aplicar SVD em matrizes subdeterminadas consistentes",
                                  "commonMistakes": [
                                    "Confundir ordem de U, Σ, V",
                                    "Ignorar verificação de consistência",
                                    "Usar SVD full desnecessariamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a pseudoinversa de Moore-Penrose A^+",
                                  "subSteps": [
                                    "Crie Σ^+ (n x m): inverta diagonais não-nulas de Σ (1/σ_i para σ_i > 0), zeros elsewhere",
                                    "Monte A^+ = V Σ^+ U^T",
                                    "Verifique dimensões: A^+ deve ser n x m",
                                    "Calcule numericamente A^+ A A^+ == A^+ para propriedade idempotente",
                                    "Confirme que A A^+ é projeção em col(A)"
                                  ],
                                  "verification": "A A^+ A == A e propriedades de pseudoinversa satisfeitas",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Matrizes U, Σ, V da Step 1",
                                    "Software para multiplicação matricial"
                                  ],
                                  "tips": "Σ^+ é transposição com inversos nas diagonais; zeros permanecem zeros",
                                  "learningObjective": "Construir pseudoinversa via SVD para soluções mínimas",
                                  "commonMistakes": [
                                    "Inverter σ_i = 0",
                                    "Errar transposição em Σ^+",
                                    "Confundir V e V^T"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a solução mínima x = A^+ b",
                                  "subSteps": [
                                    "Compute U^T b (m x 1)",
                                    "Multiplique por Σ^+ : Σ^+ (U^T b)",
                                    "Multiplique por V: x = V (Σ^+ U^T b)",
                                    "Verifique Ax = b (erro residual < 1e-10)",
                                    "Calcule ||x||_2 e compare com outras soluções possíveis"
                                  ],
                                  "verification": "Ax = b e x é única de menor norma entre soluções",
                                  "estimatedTime": "15 minutes",
                                  "materials": [
                                    "A^+, b",
                                    "Software para multiplicações"
                                  ],
                                  "tips": "Evite recomputar SVD; reuse componentes",
                                  "learningObjective": "Aplicar pseudoinversa para obter solução de menor norma L2",
                                  "commonMistakes": [
                                    "Ordem errada nas multiplicações",
                                    "Não verificar Ax=b",
                                    "Confundir com mínimos quadrados superdeterminados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar minimidade da norma e generalizar",
                                  "subSteps": [
                                    "Encontre solução particular x0 tal que Ax0 = b",
                                    "Calcule solução geral x = x0 + (I - A^+ A) z para z arbitrário",
                                    "Mostre que ||x||_2 >= ||A^+ b||_2 para qualquer z",
                                    "Verifique x ⊥ ker(A) (ortogonal ao núcleo)",
                                    "Discuta estabilidade numérica para matrizes mal-condicionadas"
                                  ],
                                  "verification": "||x||_2 é mínima comprovada por comparação com soluções gerais",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "x de Step 3",
                                    "Base do kernel de A via V"
                                  ],
                                  "tips": "Use V[:, r:] para kernel onde r = rank(A)",
                                  "learningObjective": "Provar e validar que A^+ b minimiza ||x||_2",
                                  "commonMistakes": [
                                    "Ignorar componente no kernel",
                                    "Não provar unicidade da mínima",
                                    "Confundir norma L1/L2"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 0, 0], [0, 1, 0]] (2x3), b = [1, 1]^T. SVD: U = I_2, Σ = diag(1,1,0), V = [[1,0,0],[0,1,0],[0,0,1]]. Então Σ^+ = [[1,0],[0,1],[0,0]], A^+ = V Σ^+ U^T = [[1,0],[0,1],[0,0]]. x = A^+ b = [1,1,0]^T. Verifique: Ax = [1,1]^T = b, ||x||_2 = √2 mínima (ex: [1,1,1] tem ||x||_2=√3 > √2).",
                              "finalVerifications": [
                                "Ax = b com erro residual zero (ou <1e-12)",
                                "||x||_2 é menor que em qualquer outra solução x' com Ax'=b",
                                "x pertence ao espaço coluna de A^T (row space de A)",
                                "Pseudoinversa satisfaz as 4 propriedades de Moore-Penrose",
                                "SVD componentes corretos: ||A - U Σ V^T|| < 1e-10",
                                "Estabilidade: cond(A) não amplifica erro excessivamente"
                              ],
                              "assessmentCriteria": [
                                "Precisão na decomposição SVD (erro de reconstrução <1e-10)",
                                "Correta inversão seletiva em Σ^+ (apenas σ_i > ε)",
                                "Verificação explícita de Ax=b e minimidade ||x||_2",
                                "Uso apropriado de propriedades teóricas (ortogonalidade ao kernel)",
                                "Eficiência computacional e tratamento numérico",
                                "Explicação clara da unicidade da solução mínima"
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementar em Python/NumPy ou MATLAB",
                                "Otimização: Equivalente a min ||x||_2 s.t. Ax=b (QP convexo)",
                                "Machine Learning: Regularização Ridge/Lasso via SVD",
                                "Física/Engenharia: Soluções mínimas em sistemas subatuados",
                                "Estatística: Análise de componentes principais (PCA) via SVD"
                              ],
                              "realWorldApplication": "Em robótica, encontrar comandos de atuadores mínimos (menor energia) para alcançar pose desejada em sistemas subatuados; em processamento de sinais, reconstrução esparsa de imagens com menos pixels que coeficientes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.3.2",
                            "name": "Analisar sensibilidade com SVD",
                            "description": "Avaliar o número de condição cond(A) = σ_1 / σ_min, interpretar amplificação de erros em soluções via ||δx|| / ||x|| ≈ cond(A) ||δb|| / ||b||, e aplicar truncamento para regularização em problemas mal-condicionados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular o número de condição usando SVD",
                                  "subSteps": [
                                    "Obtenha a decomposição SVD de uma matriz A: A = U Σ V^T",
                                    "Identifique os valores singulares σ_i na diagonal de Σ, ordenados decrescentemente",
                                    "Calcule cond(A) = σ_1 / σ_min, onde σ_1 é o maior e σ_min o menor valor singular não nulo",
                                    "Implemente o cálculo em software numérico como Python com NumPy",
                                    "Teste com matrizes bem e mal-condicionadas para comparar"
                                  ],
                                  "verification": "Verifique se cond(A) coincide com np.linalg.cond(A) para a mesma matriz",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com NumPy e SciPy",
                                    "Matrizes de exemplo (ex: Hilbert matrix)"
                                  ],
                                  "tips": "Ordene sempre os valores singulares em ordem decrescente para evitar erros de indexação",
                                  "learningObjective": "Dominar o cálculo preciso do número de condição a partir da SVD",
                                  "commonMistakes": [
                                    "Usar σ_min incluindo zeros em problemas rank-deficient",
                                    "Confundir σ_1 com o maior autovalor em vez de valor singular"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar amplificação de erros em soluções",
                                  "subSteps": [
                                    "Revise a fórmula aproximada: ||δx|| / ||x|| ≈ cond(A) * ||δb|| / ||b|| para sistemas Ax = b",
                                    "Simule perturbações δb pequenas na matriz b e observe δx na solução x",
                                    "Compare o fator de amplificação relativo com cond(A) em experimentos numéricos",
                                    "Analise graficamente o erro relativo em função de cond(A)",
                                    "Discuta limites: quando cond(A) >> 1, o problema é sensível"
                                  ],
                                  "verification": "Simule 10 perturbações aleatórias e confirme que a amplificação média ≈ cond(A)",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python para simulação de erros",
                                    "Gráficos com Matplotlib"
                                  ],
                                  "tips": "Use perturbações relativas pequenas (1e-6) para aproximar o limite linear",
                                  "learningObjective": "Compreender quantitativamente como cond(A) amplifica erros de entrada em saídas",
                                  "commonMistakes": [
                                    "Ignorar normalizações ||.|| nas normas vetoriais",
                                    "Aplicar fórmula diretamente sem SVD para cond(A)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar truncamento SVD para regularização",
                                  "subSteps": [
                                    "Identifique valores singulares pequenos (próximos a zero ou abaixo de threshold)",
                                    "Escolha k < rank(A) para truncamento: A_k = U_k Σ_k V_k^T",
                                    "Resolva o problema regularizado usando pseudoinversa truncada",
                                    "Compare soluções original e truncada em termos de norma de resíduo e sensibilidade",
                                    "Ajuste k iterativamente para minimizar erro esperado"
                                  ],
                                  "verification": "Calcule cond(A_k) e confirme redução significativa em relação a cond(A)",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Funções SVD no SciPy (svdvals, pinv)",
                                    "Matriz mal-condicionada exemplo"
                                  ],
                                  "tips": "Threshold = máquina eps * σ_1 para escolha automática de k",
                                  "learningObjective": "Aplicar truncamento SVD como técnica de regularização em problemas il-condicionados",
                                  "commonMistakes": [
                                    "Truncar demais, perdendo precisão na solução",
                                    "Não reescalar Σ_k adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar sensibilidade completa antes e depois da regularização",
                                  "subSteps": [
                                    "Integre passos anteriores: SVD completa → cond(A) → análise erro → truncamento → reanálise",
                                    "Quantifique melhoria: compare cond(A_k)/cond(A) e fator de amplificação de erros",
                                    "Avalie trade-off entre viés (truncamento) e variância (sensibilidade reduzida)",
                                    "Documente em relatório com tabelas e gráficos",
                                    "Teste em problema subdeterminado real"
                                  ],
                                  "verification": "Demonstre que ||δx_k|| / ||x_k|| << cond(A) * ||δb|| / ||b|| pós-regularização",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Jupyter Notebook para integração",
                                    "Dados de benchmark"
                                  ],
                                  "tips": "Use L-curve para otimizar k em casos complexos",
                                  "learningObjective": "Realizar análise end-to-end de sensibilidade com SVD e regularização",
                                  "commonMistakes": [
                                    "Esquecer de verificar rank efetivo pós-truncamento",
                                    "Comparar soluções sem normalizar"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[1,1],[1,1.0001],[1,1.0002]] (subdeterminado, mal-condicionado). SVD revela σ1≈2.23, σ2≈0.0001, cond(A)≈22300. Perturbe b em 1e-6: erro em x amplifica ~22300x. Trunque k=1: A1 aproxima linha média, cond(A1)=1, erro amplificado reduzido drasticamente, útil para denoising.",
                              "finalVerifications": [
                                "Calcular corretamente cond(A) via SVD para matriz dada",
                                "Simular e interpretar amplificação de erros com precisão <5%",
                                "Aplicar truncamento SVD reduzindo cond(A) em pelo menos 90%",
                                "Comparar soluções regularizadas vs originais em norma de erro",
                                "Explicar trade-offs de regularização verbalmente",
                                "Implementar código reproduzível em Python"
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de SVD e cond(A) (exato até 1e-10)",
                                "Correta interpretação da fórmula de erro relativo (amplificação cond(A))",
                                "Efetividade do truncamento: redução cond(A) > 10x sem perda >10% em ||Ax-b||",
                                "Análise quantitativa com simulações e gráficos claros",
                                "Identificação correta de problemas mal-condicionados (cond>1e6)",
                                "Relatório estruturado com conclusões acionáveis"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de regressão linear e multicolinearidade",
                                "Machine Learning: Redução de dimensionalidade via PCA/SVD",
                                "Engenharia de Controle: Estabilidade de sistemas lineares",
                                "Processamento de Imagens: Compressão e denoising com SVD",
                                "Física Computacional: Simulações numéricas em problemas inversos"
                              ],
                              "realWorldApplication": "Em geofísica, análise de sensibilidade em tomografia sísmica usa SVD para regularizar inversos mal-condicionados, reduzindo amplificação de ruído em modelos de velocidade subterrânea e melhorando previsões de terremotos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.3.3",
                            "name": "Comparar SVD com métodos QR e iterativos",
                            "description": "Discutir vantagens da SVD sobre QR para mínimo norma em subdeterminados e sobre métodos iterativos (como GMRES) em termos de precisão numérica e sensibilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de SVD, QR e GMRES",
                                  "subSteps": [
                                    "Ler definições e fórmulas básicas da SVD: A = UΣV^T.",
                                    "Estudar decomposição QR: A = QR com Q ortogonal e R triangular superior.",
                                    "Revisar GMRES como método iterativo Krylov para soluções aproximadas de Ax=b.",
                                    "Identificar contextos de aplicação: SVD para general, QR para quadrados mínimos overdetermined, GMRES para grandes esparsos."
                                  ],
                                  "verification": "Resumir em um parágrafo as diferenças principais entre os três métodos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Numerical Linear Algebra' de Trefethen e Bau (capítulos 5, 8)",
                                    "Documentação SciPy: linalg.svd, linalg.qr, linalg.gmres"
                                  ],
                                  "tips": "Use diagramas matriciais para visualizar decomposições.",
                                  "learningObjective": "Compreender as bases matemáticas e computacionais de cada método.",
                                  "commonMistakes": [
                                    "Confundir SVD com eigen-decomposição (SVD funciona para não-quadradas)",
                                    "Ignorar que QR assume full rank overdetermined"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar SVD vs QR em Sistemas Subdeterminados (m < n)",
                                  "subSteps": [
                                    "Formular problema subdeterminado: múltiplas soluções, buscar mínimo norma ||x||_2.",
                                    "Demonstrar que QR falha ou dá solução arbitrária em subdeterminados.",
                                    "Mostrar que SVD resolve via pseudo-inversa: x = A^+ b = VΣ^+ U^T b, minimizando norma.",
                                    "Comparar numericamente com exemplo 2x3 matriz."
                                  ],
                                  "verification": "Implementar em Python e verificar que ||x_SVD|| < ||x_QR|| para mesma precisão em b.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Jupyter Notebook para experimentos"
                                  ],
                                  "tips": "Sempre normalize b para comparações justas.",
                                  "learningObjective": "Explicar por que SVD é canônica para mínimo norma em subdeterminados.",
                                  "commonMistakes": [
                                    "Usar QR diretamente sem adaptação (leva a pivoteamento parcial insuficiente)",
                                    "Esquecer pseudoinversa na SVD"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Precisão Numérica e Sensibilidade em Sistemas Mal-Condicionados",
                                  "subSteps": [
                                    "Definir condição numérica κ(A) = σ_max / σ_min e impacto em perturbações.",
                                    "Simular matriz mal-condicionada (ex: Hilbert ou Vandermonde).",
                                    "Comparar erros relativos: ||x_true - x_method|| / ||x_true|| para ruído em b e A.",
                                    "Analisar GMRES: convergência lenta em mal-condicionados sem pré-condicionadores.",
                                    "Destacar robustez SVD mesmo com σ_min pequeno."
                                  ],
                                  "verification": "Plotar gráficos de erro vs log(κ(A)) para os métodos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB ou Python (SciPy sparse para GMRES)",
                                    "Exemplos de matrizes de teste do NIST"
                                  ],
                                  "tips": "Use cond(A) para quantificar e double precision.",
                                  "learningObjective": "Quantificar vantagens SVD em estabilidade numérica sobre QR e GMRES.",
                                  "commonMistakes": [
                                    "Atribuir falha GMRES só a iterações, ignorar resíduos",
                                    "Não perturbar A e b separadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Síntese e Decisão de Uso Baseada em Comparação",
                                  "subSteps": [
                                    "Tabular prós/contras: SVD (preciso, caro O(mn^2)), QR (rápido overdet., sensível), GMRES (esparso, iterativo).",
                                    "Discutir trade-offs: custo computacional vs precisão.",
                                    "Implementar benchmark em código para tempos e erros.",
                                    "Concluir guidelines: SVD para subdet./mal-cond., QR para overdet. bem-cond., GMRES para grandes."
                                  ],
                                  "verification": "Criar tabela comparativa e explicar escolha para 3 cenários hipotéticos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código Python dos passos anteriores",
                                    "Timer: %timeit no Jupyter"
                                  ],
                                  "tips": "Considere tamanho matriz para escalabilidade.",
                                  "learningObjective": "Aplicar comparações para selecionar método ótimo.",
                                  "commonMistakes": [
                                    "Generalizar SVD como sempre melhor (lento para grandes)",
                                    "Ignorar custo SVD cúbico"
                                  ]
                                }
                              ],
                              "practicalExample": "Em compressão de imagens, use SVD para aproximar matriz de pixels subdeterminada (rank baixo); compare com QR que não minimiza norma adequadamente, resultando em artefatos; GMRES converge lento em mal-condicionado por ruído.",
                              "finalVerifications": [
                                "Explicar matematicamente por que SVD dá solução único mínimo norma em subdeterminados.",
                                "Quantificar erro numérico em exemplo mal-condicionado mostrando SVD < QR/GMRES.",
                                "Listar 3 cenários onde QR é preferível a SVD.",
                                "Implementar e rodar comparação em código para sistema 5x10.",
                                "Discutir impacto de pré-condicionadores em GMRES vs SVD inerente.",
                                "Verificar estabilidade com perturbações δb e δA."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação pseudo-inversa SVD vs QR (90% correção).",
                                "Correta identificação vantagens SVD em subdet./mal-cond. (rubrica 1-5).",
                                "Qualidade de implementação numérica e gráficos (funcional + insights).",
                                "Profundidade tabela prós/contras e guidelines (cobertura completa).",
                                "Capacidade síntese verbal/escrita da comparação.",
                                "Originalidade exemplo prático com resultados quantitativos."
                              ],
                              "crossCurricularConnections": [
                                "Implementação NumPy/SciPy (Programação Computacional)",
                                "Análise de erro e condicionamento (Análise Numérica)",
                                "Aplicações em Regressão Linear (Estatística/Machine Learning)",
                                "Otimização de algoritmos (Ciência da Computação)",
                                "Processamento de Sinais (Engenharia)"
                              ],
                              "realWorldApplication": "Em machine learning, SVD é usada em PCA para redução dimensional em datasets mal-condicionados (ex: recomendação Netflix), superior a QR por estabilidade em features correlacionadas e a GMRES por precisão em batches não-esparsos."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.5",
                    "name": "Análise de Sensibilidade em Quadrados Mínimos",
                    "description": "Estudo do condicionamento e sensibilidade das soluções aos erros de arredondamento e perturbações nos dados.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.5.1",
                        "name": "Condicionamento do Problema de Quadrados Mínimos",
                        "description": "Estudo do número de condição para o problema de minimização da norma ||Ax - b||_2, considerando matrizes retangulares e sua relação com o espectro singular da matriz A.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.1.1",
                            "name": "Definir o número de condição κ(A) para quadrados mínimos",
                            "description": "Explicar a definição de κ(A) = σ_max(A)/σ_min(A) usando decomposição em valores singulares (SVD) e sua interpretação como medida de sensibilidade do problema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Decomposição em Valores Singulares (SVD)",
                                  "subSteps": [
                                    "Revise a definição de SVD: A = U Σ V^T, onde U e V são ortogonais e Σ é diagonal com valores singulares σ_i ≥ 0.",
                                    "Explique que os valores singulares σ_i medem o 'alongamento' nas direções principais da matriz A.",
                                    "Discuta como SVD generaliza autovalores para matrizes não quadradas.",
                                    "Pratique decompondo uma matriz simples manualmente ou via software.",
                                    "Identifique o papel de Σ na norma da matriz."
                                  ],
                                  "verification": "Construa SVD de uma matriz 2x2 e verifique A = U Σ V^T.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Álgebra Linear (ex: Strang), Python com NumPy/SciPy ou MATLAB.",
                                  "tips": "Comece com matrizes diagonais para intuitar.",
                                  "learningObjective": "Compreender SVD como base para análise espectral de A.",
                                  "commonMistakes": "Confundir SVD com decomposição em autovalores (válida só para quadradas simétricas)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar σ_max e σ_min a partir do SVD",
                                  "subSteps": [
                                    "Ordene os valores singulares em Σ: σ_1 ≥ σ_2 ≥ ... ≥ σ_r > 0.",
                                    "Defina σ_max = σ_1 (maior valor singular) e σ_min = σ_r (menor valor singular não-zero).",
                                    "Calcule normas relacionadas: ||A||_2 = σ_max e 1/||A^{-1}||_2 = σ_min (se A quadrada invertível).",
                                    "Use software para extrair σ_max e σ_min de uma matriz exemplo.",
                                    "Compare com normas de Frobenius para contextualizar."
                                  ],
                                  "verification": "Para uma matriz dada, liste σ_i corretamente e destaque max/min.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software NumPy (np.linalg.svd), calculadora matricial.",
                                  "tips": "Sempre ordene decrescente para evitar confusão.",
                                  "learningObjective": "Extrair e interpretar os valores singulares extremos.",
                                  "commonMistakes": "Ignorar zeros em Σ para matrizes rank-deficient; σ_min é o menor não-zero."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir o número de condição κ(A)",
                                  "subSteps": [
                                    "Defina formalmente κ(A) = σ_max(A) / σ_min(A) para A m x n com rank completo.",
                                    "Mostre que κ(A) = ||A||_2 ||A^+||_2, onde A^+ é a pseudoinversa.",
                                    "Calcule κ(A) para matrizes exemplo via SVD.",
                                    "Discuta κ(A) = 1 para A ortogonal (bem condicionada).",
                                    "Generalize para κ_∞(A) = ||A||_∞ ||A^{-1}||_∞ em outros normas."
                                  ],
                                  "verification": "Compute κ(A) para A = [[1,0],[0,0.01]] e confirme κ(A)=100.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python/MATLAB para svd e cond.",
                                  "tips": "Use np.linalg.cond() para validar cálculos manuais.",
                                  "learningObjective": "Definir e calcular κ(A) usando SVD.",
                                  "commonMistakes": "Usar autovalores em vez de singulares para matrizes retangulares."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar κ(A) como medida de sensibilidade em quadrados mínimos",
                                  "subSteps": [
                                    "No problema min ||Ax - b||_2, solução x = A^+ b é sensível se κ(A) grande.",
                                    "Explique amplificação de erros: δx / ||x|| ≤ κ(A) (δb / ||b|| + δA / ||A||).",
                                    "Conecte a quadrados mínimos lineares: A é matriz de Vandermonde ou design.",
                                    "Analise exemplo: dados colineares levam σ_min pequeno → κ grande.",
                                    "Discuta mitigação: regularização (Ridge) para reduzir condicionamento efetivo."
                                  ],
                                  "verification": "Explique verbalmente por que κ(A)>10^6 indica problema mal-condicionado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Artigo sobre condicionamento em regressão, exemplos em Jupyter Notebook.",
                                  "tips": "Visualize com plot de σ_i decaindo rapidamente.",
                                  "learningObjective": "Interpretar κ(A) na estabilidade numérica de quadrados mínimos.",
                                  "commonMistakes": "Confundir condicionamento da matriz com o do problema completo (inclui b)."
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 1], [1, 1.0001]] (dados quase colineares). SVD dá σ_max ≈ √2, σ_min ≈ 0.0001, κ(A) ≈ 14142. Solução de min||Ax-b|| amplifica ruído em b em fator κ, simulável em Python: adicione ruído ε a b e observe ||δx|| / ||x|| ≈ κ ε.",
                              "finalVerifications": [
                                "Define corretamente κ(A) = σ_max / σ_min via SVD.",
                                "Calcula κ(A) para matriz 2x2 com precisão.",
                                "Explica amplificação de erros em quadrados mínimos.",
                                "Identifica matriz ill-condicionada (κ>1000).",
                                "Distingue σ_min de zeros em Σ.",
                                "Relaciona κ(A) com normas de A e A^+."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática de κ(A).",
                                "Correção no cálculo de SVD e extração de σ_max/σ_min.",
                                "Clareza na interpretação de sensibilidade.",
                                "Uso adequado de exemplos numéricos.",
                                "Conexão explícita com quadrados mínimos.",
                                "Identificação de limitações (ex: rank-deficient)."
                              ],
                              "crossCurricularConnections": [
                                "Computação Científica: Estabilidade numérica em solvers lineares.",
                                "Estatística: Condicionamento em regressão linear/multivariada.",
                                "Engenharia: Análise de sensibilidade em modelagem de sistemas.",
                                "Física: Estabilidade em simulações dinâmicas (matrizes de rigidez)."
                              ],
                              "realWorldApplication": "Em machine learning, alto κ(A) na matriz de features de regressão indica multicolinearidade, levando a coeficientes instáveis; usado para diagnosticar e regularizar modelos em previsão de vendas ou análise de imagens."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.2",
                            "name": "Calcular o condicionamento via SVD",
                            "description": "Aplicar a SVD de A para computar κ(A) e analisar casos de matrizes mal-condicionadas em problemas de quadrados mínimos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Computar a Decomposição em Valores Singulares (SVD) da matriz A",
                                  "subSteps": [
                                    "Escolha uma matriz A relevante para quadrados mínimos (ex: m x n com m >= n).",
                                    "Use software numérico (ex: MATLAB svd(A), Python numpy.linalg.svd(A)) ou método analítico para matrizes pequenas.",
                                    "Obtenha U, Σ (diagonal com singular values σ1 ≥ σ2 ≥ ... ≥ σr > 0) e V^T.",
                                    "Verifique a reconstrução: A ≈ U Σ V^T (erro deve ser pequeno).",
                                    "Registre os singular values em ordem decrescente."
                                  ],
                                  "verification": "Reconstrua A a partir de U, Σ, V^T e confirme ||A - UΣV^T|| < 1e-10.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Matriz A exemplo, software (NumPy/MATLAB), calculadora para casos pequenos.",
                                  "tips": "Sempre ordene singular values decrescentemente; use full_matrices=False para eficiência em Python.",
                                  "learningObjective": "Dominar o cálculo e interpretação da SVD de uma matriz.",
                                  "commonMistakes": "Confundir singular values com eigenvalues; ignorar zeros em Σ para rank-deficient matrices."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o Número de Condicionamento κ(A)",
                                  "subSteps": [
                                    "Identifique σ_max = σ1 (maior singular value) e σ_min = σr (menor singular value não-zero).",
                                    "Compute κ(A) = σ_max / σ_min.",
                                    "Para matrizes quadradas invertíveis, confirme com ||A|| * ||A^{-1}|| se possível.",
                                    "Classifique: κ < 10^3 bem-condicionado; > 10^6 mal-condicionado.",
                                    "Registre o valor exato e log10(κ) para magnitude."
                                  ],
                                  "verification": "Confirme κ(A) = cond(A) usando função built-in (ex: numpy.linalg.cond(A, 'singular')) e compare.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Singular values de Σ, calculadora ou código Python/MATLAB.",
                                  "tips": "Use precisão dupla; evite divisão por zero verificando rank(A).",
                                  "learningObjective": "Calcular precisamente o condicionamento 2-norma via SVD.",
                                  "commonMistakes": "Usar σ_min = 0 para singular matrices (use pseudo-inverso); confundir com 1-norma."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Impacto em Problemas de Quadrados Mínimos",
                                  "subSteps": [
                                    "Lembre: solução x = A^+ b, onde A^+ envolve Σ^{-1} (1/σ_i).",
                                    "Avalie sensibilidade: erros em b amplificados por κ(A) na direção de σ_min.",
                                    "Simule: adicione ruído pequeno a b e resolva min||Ax-b|| vs min||Ax-(b+δb)||.",
                                    "Observe ||δx|| / ||x|| ≈ κ(A) * ||δb|| / ||b|| para direção ill-condicionada.",
                                    "Discuta regularização (ex: ridge) se κ grande."
                                  ],
                                  "verification": "Plote ||x_ruído - x|| vs κ(A) para diferentes ruídos; deve crescer linearmente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Vetor b, código para lsqr ou pinv(A,b), gerador de ruído.",
                                  "tips": "Use V para direção right singular vector de σ_min para pior caso.",
                                  "learningObjective": "Entender como κ(A) afeta estabilidade numérica em least squares.",
                                  "commonMistakes": "Ignorar pseudoinverso para rank-deficient; superestimar estabilidade em κ moderado."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e Analisar Casos Mal-Condicionados",
                                  "subSteps": [
                                    "Identifique matriz mal-condicionada: ex: Hilbert matrix ou A com σ1/σn > 10^8.",
                                    "Compare soluções com/ sem ruído: destaque perda de dígitos (dígitos perdidos ≈ log10(κ)).",
                                    "Proponha mitigação: truncar SVD (TSVD), adicionar regularização.",
                                    "Teste em exemplo real: gere A ill-condicionada e resolva sistema.",
                                    "Documente conclusões em relatório curto."
                                  ],
                                  "verification": "Resolva para 3 níveis de ruído; verifique se erro predito por κ(A) coincide.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Exemplos de matrizes (Hilbert, Vandermonde), código para gerar ruído.",
                                  "tips": "Escala A primeiro (normalize colunas) para cond independente de escala.",
                                  "learningObjective": "Diagnosticar e mitigar problemas de condicionamento em aplicações práticas.",
                                  "commonMistakes": "Atribuir erro só a ruído sem quantificar via κ; não testar múltiplos casos."
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 1], [1, 1.0001]] (quase rank-deficient). SVD dá σ1 ≈ 2, σ2 ≈ 0.0001, κ(A) ≈ 20000. Para b = [2, 2.0002], x ideal ≈ [1,1], mas com ruído δb=1e-6 em segunda entrada, δx ≈ κ * δb / ||A|| amplifica erro em ~20 ordens, mostrando instabilidade.",
                              "finalVerifications": [
                                "SVD computada corretamente com reconstrução precisa.",
                                "κ(A) calculado como σ_max/σ_min e validado com função built-in.",
                                "Simulação de ruído mostra amplificação condizente com κ(A).",
                                "Identificados pelo menos 2 casos mal-condicionados com análise.",
                                "Propostas de mitigação documentadas.",
                                "Relatório resume interpretações corretas."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos de SVD e κ(A) (erro < 1e-12).",
                                "Análise qualitativa e quantitativa do impacto em least squares.",
                                "Uso correto de conceitos como pseudoinverso e direções singulares.",
                                "Identificação precisa de erros comuns e mitigação.",
                                "Clareza na documentação e exemplos práticos.",
                                "Criatividade em conexões com aplicações reais."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em Python/NumPy ou MATLAB.",
                                "Estatística: Sensibilidade em regressão linear e ANOVA.",
                                "Física Computacional: Modelagem de sistemas com ruído em engenharia.",
                                "Machine Learning: Condicionamento em PCA/SVD para redução de dimensionalidade."
                              ],
                              "realWorldApplication": "Em regressão linear para previsão de vendas (A=design matrix), alto κ(A) causa instabilidade numérica em dados colineares, levando a previsões ruins; SVD detecta e permite regularização para modelos robustos em finanças ou bioinformática."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.1.3",
                            "name": "Interpretar o papel do resíduo no condicionamento",
                            "description": "Analisar como o resíduo r = b - Ax influencia a sensibilidade efetiva do problema, distinguindo entre problemas consistentes e inconsistentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Conceito de Resíduo em Problemas de Quadrados Mínimos",
                                  "subSteps": [
                                    "Defina o problema de quadrados mínimos: encontre x que minimiza ||Ax - b||_2.",
                                    "Calcule o resíduo r = b - Ax para uma solução x.",
                                    "Interprete o resíduo como a discrepância entre o modelo Ax e os dados observados b.",
                                    "Discuta o significado físico do resíduo em contextos de modelagem.",
                                    "Pratique com um exemplo 2x2 simples: A = [[1,1],[1,2]], b=[1,2.1], resolva x e calcule r."
                                  ],
                                  "verification": "Confirme calculando r para um exemplo dado e verificando se ||r|| é mínimo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora ou Python com NumPy",
                                    "Exemplos de matrizes pré-definidas"
                                  ],
                                  "tips": "Sempre normalize o resíduo pela norma de b para relativizar a magnitude.",
                                  "learningObjective": "Compreender o resíduo como medida de ajuste do modelo linear.",
                                  "commonMistakes": [
                                    "Confundir resíduo com erro de arredondamento",
                                    "Esquecer de usar a solução mínima de LS",
                                    "Ignorar a direção do resíduo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Condicionamento Geral em Sistemas Lineares",
                                  "subSteps": [
                                    "Revise o número de condição cond(A) = ||A|| * ||A^{-1}|| para sistemas quadrados.",
                                    "Estenda para quadrados mínimos: cond efetivo depende de singular values de A.",
                                    "Discuta sensibilidade: como perturbações δb afetam δx via ||δx|| / ||x|| ≈ cond * ||δb|| / ||b||.",
                                    "Introduza o papel do resíduo na amplificação de erros.",
                                    "Calcule cond(A) para o exemplo anterior usando SVD."
                                  ],
                                  "verification": "Calcule cond(A) e interprete se >10^6 indica problema mal condicionado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software Python/MATLAB para SVD",
                                    "Documentação de numpy.linalg.svd"
                                  ],
                                  "tips": "Use valores singulares para cond: maior/menor σ.",
                                  "learningObjective": "Identificar como o condicionamento amplifica erros em soluções LS.",
                                  "commonMistakes": [
                                    "Aplicar cond só para A quadrada",
                                    "Confundir cond com rank",
                                    "Ignorar normalização das normas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Influência do Resíduo na Sensibilidade Efetiva",
                                  "subSteps": [
                                    "Estude a fórmula de sensibilidade efetiva: κ_eff = κ(A) * (||A|| ||x|| / ||r||) para casos inconsistentes.",
                                    "Derive qualitativamente por que ||r|| pequeno aumenta sensibilidade.",
                                    "Compare sensibilidade com ||r|| pequeno vs grande.",
                                    "Simule perturbações: adicione δb pequeno e observe δx.",
                                    "Plote ||δx|| vs ||r|| para um exemplo fixo."
                                  ],
                                  "verification": "Para um exemplo, compute κ_eff e verifique amplificação de erro.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Python com matplotlib para plots",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Foquem em ||r|| / ||b|| < 10^{-k} para alta sensibilidade.",
                                  "learningObjective": "Explicar como resíduo pequeno torna o problema mais sensível a perturbações.",
                                  "commonMistakes": [
                                    "Esquecer fator ||Ax|| / ||r||",
                                    "Aplicar fórmula só para consistentes",
                                    "Não relativizar erros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar Problemas Consistentes e Inconsistentes",
                                  "subSteps": [
                                    "Defina consistente: existe x exato com r=0 (b em range(A)).",
                                    "Inconsistente: r ≠ 0, típico em dados reais.",
                                    "Em consistentes: sensibilidade = cond(A).",
                                    "Em inconsistentes: sensibilidade efetiva amplificada por 1/||r||.",
                                    "Classifique exemplos: um exato vs com ruído gaussiano."
                                  ],
                                  "verification": "Classifique 3 problemas e justifique com cálculo de r e cond.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Exemplos gerados em Python",
                                    "Tabela comparativa em papel"
                                  ],
                                  "tips": "Teste consistência projetando b em range(A).",
                                  "learningObjective": "Distinguir impactos do resíduo em cenários consistentes vs inconsistentes.",
                                  "commonMistakes": [
                                    "Assumir sempre inconsistente",
                                    "Ignorar que r=0 máquina ≠ exato",
                                    "Confundir com il-condicionado"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 0], [0, 1]], b = [1, 1 + 10^{-10}]. Solução x=[1, 1+10^{-10}], r=[0, -10^{-10}]. Perturbe b em 10^{-12}: δx amplificado enormemente devido a ||r|| pequeno, mostrando sensibilidade efetiva alta apesar de cond(A)=1.",
                              "finalVerifications": [
                                "Calcule corretamente r para um sistema LS dado.",
                                "Explique verbalmente como ||r|| afeta sensibilidade.",
                                "Classifique um problema como consistente/inconsistente com justificativa.",
                                "Compute κ_eff para um exemplo inconsistente.",
                                "Simule perturbação e meça amplificação de erro.",
                                "Compare sensibilidade em dois casos com ||r|| diferente."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de r e cond (90% correto).",
                                "Explicação clara da amplificação por 1/||r|| (rubrica 4/5).",
                                "Correta distinção consistente/inconsistente (total).",
                                "Uso apropriado de SVD para análise (demonstrado).",
                                "Interpretação qualitativa e quantitativa integrada.",
                                "Exemplo prático resolvido sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Resíduo como erro em regressão linear.",
                                "Computação: Análise numérica de estabilidade em solvers LSQR.",
                                "Física: Modelagem de dados experimentais com ruído.",
                                "Engenharia: Sensibilidade em otimização de sistemas lineares."
                              ],
                              "realWorldApplication": "Em regressão linear para previsão de vendas, um resíduo pequeno indica overfit, tornando previsões sensíveis a novos dados ruidosos; engenheiros usam isso para validar modelos de ajuste de curvas em sensores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.2",
                        "name": "Sensibilidade a Perturbações nos Dados",
                        "description": "Análise da propagação de erros relativos em perturbações δA e δb para a solução x do problema de quadrados mínimos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.2.1",
                            "name": "Derivar bornas para perturbações em b",
                            "description": "Estabelecer a borta |δx|/||x|| ≤ κ(A) |δb|/||b|| para perturbações apenas em b, usando propriedades geométricas do problema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Equações Normais e Interpretação Geométrica do Problema de Quadrados Mínimos",
                                  "subSteps": [
                                    "Lembre-se do problema: minimizar ||Ax - b||_2 para A m×n (m>n, rank n).",
                                    "Estabeleça as equações normais: A^T A x = A^T b.",
                                    "Interprete geometricamente: x minimiza a distância de b ao range(A), projeção p = A x.",
                                    "Discuta o papel de b como vetor de dados e A como base das colunas.",
                                    "Verifique com diagrama: desenhe b, range(A) e projeção perpendicular."
                                  ],
                                  "verification": "Desenhe o diagrama geométrico e confirme que A^T (b - A x) = 0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta para diagramas, calculadora para exemplo 2x2.",
                                  "tips": "Sempre pense em termos de ângulos retos na projeção para intuição geométrica.",
                                  "learningObjective": "Compreender a base geométrica do LS para perturbações.",
                                  "commonMistakes": "Confundir norma euclidiana com outras; ignorar que A pode não ser quadrada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Perturbação em b e Derivar Expressão Explícita para δx",
                                  "subSteps": [
                                    "Defina b' = b + δb, solução x' = x + δx.",
                                    "Escreva equações normais para b': A^T A x' = A^T b'.",
                                    "Substitua: A^T A (x + δx) = A^T (b + δb) → A^T A δx = A^T δb.",
                                    "Resolva: δx = (A^T A)^{-1} A^T δb.",
                                    "Confirme que δx é a correção na pseudoinversa aplicada a δb."
                                  ],
                                  "verification": "Compute δx para um A e b simples e verifique ||A δx - δb|| pequeno.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software como MATLAB/Python (numpy.linalg.lstsq) para validação numérica.",
                                  "tips": "Use pseudoinversa A^+ = (A^T A)^{-1} A^T para compactar notação.",
                                  "learningObjective": "Obter fórmula exata para mudança na solução sob perturbação em b.",
                                  "commonMistakes": "Esquecer A^T na equação de perturbação; assumir A invertível."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer Bornas Absolutas para ||δx|| Usando Normas de Operador",
                                  "subSteps": [
                                    "Tome norma 2: ||δx||_2 ≤ ||(A^T A)^{-1} A^T||_2 ||δb||_2.",
                                    "Lembre que ||B C|| ≤ ||B|| ||C|| para normas subordinadas.",
                                    "Expanda: ||(A^T A)^{-1}||_2 = 1 / σ_min^2(A), ||A^T||_2 = σ_max(A).",
                                    "Conclua ||δx|| ≤ [σ_max(A) / σ_min^2(A)] ||δb||.",
                                    "Relacione com pseudonorma: ||A^+||_2 = 1 / σ_min(A)."
                                  ],
                                  "verification": "Calcule numericamente para matriz condicionada e confirme borne.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com numpy para SVD (np.linalg.svd).",
                                  "tips": "Use SVD de A para computar singular values exatas.",
                                  "learningObjective": "Dominar bornas absolutas via normas matriciais.",
                                  "commonMistakes": "Usar norma Frobenius em vez de 2-norma; confundir σ_max com ||A||_F."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar Borne Relativa Envolvendo o Número de Condição κ(A)",
                                  "subSteps": [
                                    "Defina κ_2(A) = σ_max(A)/σ_min(A), o número de condição.",
                                    "Note ||x|| ≈ ||A^+ b|| ≤ ||A^+|| ||b|| = ||b|| / σ_min(A).",
                                    "Para borne relativa: ||δx|| / ||x|| ≤ [σ_max / σ_min^2] ||δb|| / (||b|| / σ_min) = κ(A)^2 ||δb|| / ||b||.",
                                    "Ajuste geometricamente: perturbação δb afeta projeção por fator amplificado por curvatura (κ).",
                                    "Conclua a borne |δx|/||x|| ≤ κ(A) |δb|/||b|| via aproximação ou borne apertada."
                                  ],
                                  "verification": "Prove ou simule que o fator é no máximo κ(A) para casos geométricos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Papel para provas, software para contraexemplos.",
                                  "tips": "Pense geometricamente: direção de δb paralela ao singular vector amplifica mais.",
                                  "learningObjective": "Conectar bornas relativas ao cond(A) com justificativa geométrica.",
                                  "commonMistakes": "Ignorar o quadrado em κ^2 sem normalização; esquecer ||x|| depende de b."
                                }
                              ],
                              "practicalExample": "Considere A = [[1,0],[0,100]], b = [1,1], resolva LS: x ≈ [1, 0.01]. Perturbe δb = [0.01, 0], compute δx ≈ [0, 0.0001], verifique ||δx||/||x|| ≈ 0.01 /1 = 0.01, κ(A)=100, ||δb||/||b||≈0.01/1.4≈0.007, borne 100*0.007=0.7 >>0.01 (borne conservadora).",
                              "finalVerifications": [
                                "Derivação correta de δx = A^+ δb.",
                                "Borne absoluta ||δx|| ≤ ||A^+|| ||δb|| comprovada.",
                                "Borne relativa ||δx||/||x|| ≤ κ(A) ||δb||/||b|| estabelecida.",
                                "Exemplo numérico valida a borne.",
                                "Interpretação geométrica: perturbação perpendicular amplificada por 1/σ_min.",
                                "Prova usa apenas normas 2 e SVD."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de δx (100% correto).",
                                "Correto uso de normas subordinadas (sem erros de desigualdade).",
                                "Conexão explícita com κ(A) = σ1/σn.",
                                "Justificativa geométrica coerente.",
                                "Exemplo prático computado corretamente.",
                                "Identificação de casos ruins (alta condição)."
                              ],
                              "crossCurricularConnections": [
                                "Numérica Computacional: Estabilidade de algoritmos LS (QR vs normal eqs).",
                                "Física: Sensibilidade em modelagem (ex: ajuste de curvas em experimentos).",
                                "Estatística: Análise de regressão linear e variância inflada.",
                                "Engenharia: Controle de erros em simulações finitas."
                              ],
                              "realWorldApplication": "Em machine learning, avalia sensibilidade de coeficientes de regressão a ruído nos targets (b), essencial para dados experimentais em bioengenharia ou finanças, onde pequenas perturbações em medições podem amplificar erros na predição se κ(A) alto."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.2.2",
                            "name": "Analisar sensibilidade a perturbações em A",
                            "description": "Derivar e interpretar bornas para δA, destacando o fator κ(A)^2 em casos perturbativos, com exemplos numéricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Quadrados Mínimos e Número de Condição",
                                  "subSteps": [
                                    "Relembre a formulação do problema de quadrados mínimos lineares: min_x ||Ax - b||_2, com solução x = (A^T A)^{-1} A^T b.",
                                    "Defina o número de condição κ(A) = ||A||_2 ||A^+||_2, onde A^+ é a pseudoinversa.",
                                    "Discuta o papel de κ(A) na amplificação de erros em sistemas lineares.",
                                    "Estude a matriz normal A^T A e sua relação com a estabilidade.",
                                    "Identifique por que perturbações em A afetam tanto a pseudoinversa."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e compute κ(A) para uma matriz de exemplo 2x2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Álgebra Linear Numérica (ex: Golub-Van Loan), MATLAB/Python para computar normas.",
                                  "tips": "Use decomposição SVD para visualizar singular values e entender κ(A).",
                                  "learningObjective": "Compreender a base teórica para sensibilidade em least squares.",
                                  "commonMistakes": "Confundir κ(A) com κ(A^T A); lembre que κ(A^T A) = κ(A)^2."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar Bornas para Perturbações δA",
                                  "subSteps": [
                                    "Considere A_pert = A + δA e derive a perturbação na solução x_pert ≈ x + δx.",
                                    "Use aproximações de primeira ordem: δx ≈ - (A^T A)^{-1} (δA^T (Ax - b) + A^T δA x).",
                                    "Estabeleça a berna relativa: ||δx|| / ||x|| ≤ κ(A)^2 (||δA|| / ||A||) + termos menores.",
                                    "Prove ou recite o teorema padrão de sensibilidade para least squares (ex: Higham).",
                                    "Simplifique para casos onde b = Ax (sistema compatível)."
                                  ],
                                  "verification": "Escreva a derivação passo a passo e verifique com expansão em série de Taylor.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel e lápis, notas de aula sobre análise de erros, SymPy para derivação simbólica.",
                                  "tips": "Parta da identidade da pseudoinversa e use desigualdades de normas.",
                                  "learningObjective": "Derivar matematicamente as bornas de erro para δA.",
                                  "commonMistakes": "Ignorar termos de segunda ordem; foque em aproximações perturbativas pequenas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar o Fator κ(A)^2 em Casos Perturbativos",
                                  "subSteps": [
                                    "Explique por que κ(A)^2 surge: amplificação quadrática devido a A e A^+.",
                                    "Compare com sensibilidade a δb (que é κ(A)) e δx em Ax=b (κ(A)).",
                                    "Analise cenários: A bem condicionado (κ≈1) vs. mal condicionado (κ>>1).",
                                    "Discuta implicações para precisão numérica em computação.",
                                    "Relacione com o espectro de singular values: gap pequeno amplifica erros."
                                  ],
                                  "verification": "Crie uma tabela comparando bornas para diferentes tipos de perturbações.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Gráficos de singular values via MATLAB svd(), artigos sobre cond. number.",
                                  "tips": "Visualize com plot de ||δx|| vs. ||δA|| para diferentes κ.",
                                  "learningObjective": "Interpretar o impacto amplificador de κ(A)^2.",
                                  "commonMistakes": "Subestimar o quadrático; teste com A ill-conditioned."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar com Exemplos Numéricos",
                                  "subSteps": [
                                    "Gere matriz A 3x2 bem condicionado (ex: Hilbert-like mas suave).",
                                    "Perturbe A com δA aleatório pequeno (||δA||/||A|| = 10^{-6}).",
                                    "Compute x, x_pert e compare ||δx||/||x|| com berna κ(A)^2 * rel_err.",
                                    "Repita para A mal condicionado e observe amplificação.",
                                    "Plote resultados e discuta concordância com teoria."
                                  ],
                                  "verification": "Relatório com códigos, plots e tabela de erros observados vs. bornados.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python (NumPy, SciPy) ou MATLAB, Jupyter notebook.",
                                  "tips": "Use np.linalg.cond() para κ(A); normalize perturbações.",
                                  "learningObjective": "Validar teoria com simulações numéricas.",
                                  "commonMistakes": "Escala errada de perturbação; use relative errors consistentes."
                                }
                              ],
                              "practicalExample": "Considere regressão linear para prever temperatura y de dados x (A = [x ones]), com ruído de medição em x perturbando A. Compute κ(A)^2 ≈ 10^4, δA rel=10^{-5}, preveja ||δx||/||x|| ≈ 10^{-1}, e verifique numericamente em código Python.",
                              "finalVerifications": [
                                "Derivação da berna ||δx||/||x|| ≤ 2 κ(A)^2 (||δA||/||A||) está correta.",
                                "Interpretação destaca amplificação quadrática por κ(A)^2.",
                                "Exemplo numérico 2x2 mostra concordância entre berna e erro observado.",
                                "Discussão inclui limites para ||δA|| pequeno.",
                                "Código reproduzível gera plots de erros vs. κ."
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação matemática (fórmulas corretas e passos lógicos).",
                                "Profundidade na interpretação de κ(A)^2 vs. outros fatores.",
                                "Qualidade dos exemplos numéricos (variação de κ, plots claros).",
                                "Conexão entre teoria e simulação (quantificação de bornas).",
                                "Clareza na escrita e visualizações.",
                                "Identificação de cenários práticos de alto κ."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Sensibilidade em regressão linear e validação de modelos.",
                                "Computação Científica: Estabilidade numérica em solvers de least squares (QR, SVD).",
                                "Física: Modelagem de sistemas com dados ruidosos (ex: ajuste de curvas experimentais).",
                                "Engenharia: Análise de erros em simulações finitas elemento."
                              ],
                              "realWorldApplication": "Em machine learning, analisar como ruído nos features (colunas de A em design matrix) amplifica erros nos coeficientes de regressão, guiando pré-processamento de dados e seleção de regularização (ex: Ridge para mitigar alto κ(A))."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.2.3",
                            "name": "Comparar sensibilidade em sistemas lineares vs. quadrados mínimos",
                            "description": "Contrastar a sensibilidade de Ax=b com a de min||Ax-b||, referenciando teoremas de Higham ou Golub-Van Loan.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Sensibilidade em Sistemas Lineares Exatos Ax = b",
                                  "subSteps": [
                                    "Defina o número de condição cond(A) = ||A|| * ||A^{-1}|| e sua relação com erros relativos.",
                                    "Estude o teorema de perturbação: se δA e δb são perturbações, então ||δx|| / ||x|| ≤ cond(A) * (||δA||/||A|| + ||δb||/||b||) / (1 - cond(A)||δA||/||A||).",
                                    "Implemente um exemplo numérico em Python/MATLAB para ilustrar amplificação de erros.",
                                    "Analise casos onde A é mal-condicionado e observe o impacto na solução.",
                                    "Discuta estabilidade backward vs. forward."
                                  ],
                                  "verification": "Derive o bound de erro relativo e compute cond(A) para uma matriz exemplo, confirmando amplificação numérica.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Accuracy and Stability of Numerical Algorithms' de Higham (Cap. 8)",
                                    "Python com NumPy/SciPy",
                                    "MATLAB (opcional)"
                                  ],
                                  "tips": "Use norm=2 para cond() em software; teste com matrizes Hilbert para alta condição.",
                                  "learningObjective": "Compreender como perturbações em A e b afetam a solução exata de Ax=b.",
                                  "commonMistakes": [
                                    "Confundir estabilidade forward com backward",
                                    "Ignorar o denominador no bound de perturbação",
                                    "Usar norma errada no cond(A)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Sensibilidade em Problemas de Quadrados Mínimos min||Ax - b||",
                                  "subSteps": [
                                    "Revise a solução via pseudoinverso A^+ e x = A^+ b.",
                                    "Estude o número de condição efetivo para LS: cond_{LS}(A) ≈ cond(A) para A bem-condicionado, mas pior para subespaços.",
                                    "Aprenda bounds de Higham: erros em x são amplificados por cond(A)^2 em casos ruidosos.",
                                    "Implemente LS numérico com ruído em b e observe sensibilidade.",
                                    "Compare com projeção ortogonal e resíduos."
                                  ],
                                  "verification": "Calcule x para A overdetermined com ruído, meça ||δx||/||x|| vs. cond(A).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "'Matrix Computations' de Golub-Van Loan (Cap. 5)",
                                    "Python: numpy.linalg.lstsq",
                                    "Exemplos de dados sintéticos"
                                  ],
                                  "tips": "Gere b = A x_true + noise; use svd para cond efetivo.",
                                  "learningObjective": "Identificar como LS amplifica erros devido a A não quadrada e b inconsistente.",
                                  "commonMistakes": [
                                    "Assumir cond(A) simples basta para LS",
                                    "Não diferenciar sensibilidade em x vs. resíduos",
                                    "Ignorar singular values pequenos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar Teoremas Específicos de Higham e Golub-Van Loan",
                                  "subSteps": [
                                    "Leia Teorema 10.7 de Higham sobre backward stability de Householder QR para LS.",
                                    "Analise Seção 5.3.8 de Golub-Van Loan: bounds para perturbações em LS via SVD.",
                                    "Compare: para Ax=b, erro ~ cond(A); para LS, ~ cond(A)^2 ou cond(U) onde A = U Σ V^T.",
                                    "Resuma diferenças: LS é mais sensível a perturbações em b collinear com range(A).",
                                    "Anotar teoremas chave em um quadro comparativo."
                                  ],
                                  "verification": "Cite e prove qualitativamente um teorema de cada autor, destacando diferenças.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "PDFs/extratos dos livros citados",
                                    "Notas em LaTeX/OneNote",
                                    "SVD decomposition tools"
                                  ],
                                  "tips": "Foque em interpretações geométricas via SVD; ignore provas completas inicialmente.",
                                  "learningObjective": "Dominar referências teóricas para contrastar sensibilidades.",
                                  "commonMistakes": [
                                    "Confundir cond(A) com cond_{LS}",
                                    "Não notar que LS é menos sensível em alguns casos underdetermined",
                                    "Sobrepor stability de algoritmos com sensibilidade do problema"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Sintetizar Sensibilidades com Exemplos Numéricos",
                                  "subSteps": [
                                    "Crie matriz A 5x3 rank-deficient parcial; resolva Ax=b exato vs. LS com ruído.",
                                    "Meça sensibilidades: varie δA, δb; plote ||δx||/||x|| vs. tamanho perturbação.",
                                    "Conclua: LS geralmente mais robusto a b inconsistente, mas sensível a colunas lineares dependentes.",
                                    "Discuta quando usar regularização (ridge) para mitigar.",
                                    "Gere relatório com gráficos e conclusões."
                                  ],
                                  "verification": "Produza gráfico comparativo mostrando LS menos sensível a δb grande que Ax=b.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python/MATLAB scripts",
                                    "Matplotlib para plots",
                                    "Dados de benchmark como de Higham"
                                  ],
                                  "tips": "Use logscale em plots de erro; teste múltiplas seeds de ruído.",
                                  "learningObjective": "Sintetizar comparação quantitativa e qualitativa entre os dois.",
                                  "commonMistakes": [
                                    "Não normalizar erros relativos",
                                    "Usar A quadrada em LS",
                                    "Ignorar dimensões (m>n vs. nxn)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em regressão linear (m>n), Ax=b exato falha com b ruidoso (erro amplificado por cond(A)); LS projeta b em range(A), reduzindo sensibilidade a ruído ortogonal, como em ajuste de curvas experimentais onde dados têm erro de medição.",
                              "finalVerifications": [
                                "Derivar bound cond(A) para Ax=b e cond_{LS} para min||Ax-b||.",
                                "Implementar exemplo numérico mostrando LS mais estável para δb grande.",
                                "Citar teorema de Higham provando stability backward em QR para LS.",
                                "Explicar por que LS é preferido em dados overdetermined ruidosos.",
                                "Comparar sensibilidades em tabela: Ax=b vs. LS para δA, δb.",
                                "Identificar caso onde Ax=b é mais sensível que LS."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de bounds de erro (80% correto).",
                                "Correta implementação e interpretação de experimentos numéricos.",
                                "Referências adequadas a Higham/Golub-Van Loan com síntese.",
                                "Clareza na distinção entre sensibilidade do problema vs. algoritmo.",
                                "Uso apropriado de SVD/cond para análise.",
                                "Conclusões qualitativas alinhadas com teoria."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Sensibilidade em regressão linear e análise de resíduos.",
                                "Engenharia Numérica: Estabilidade em simulações CFD/FEM com dados ruidosos.",
                                "Ciência de Dados: Robustez de modelos ML lineares a outliers.",
                                "Física Computacional: Ajuste de parâmetros em leis físicas overdetermined."
                              ],
                              "realWorldApplication": "Em processamento de imagens (tomografia), LS resolve sistemas overdetermined ruidosos com sensibilidade menor que exato, permitindo reconstruções robustas apesar de ruído de sensor, conforme analisado em Golub-Van Loan para aplicações geofísicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.3",
                        "name": "Estabilidade Numérica e Erros de Arredondamento",
                        "description": "Estudo da sensibilidade das soluções computadas aos erros de arredondamento em métodos como QR e SVD para quadrados mínimos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.3.1",
                            "name": "Avaliar estabilidade da decomposição QR",
                            "description": "Explicar por que a ortogonalização QR é backward stable para quadrados mínimos, com análise de erros de arredondamento O(ε_mach κ(A)).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Decomposição QR e Estabilidade Numérica",
                                  "subSteps": [
                                    "Defina decomposição QR: A = QR onde Q é ortogonal e R é triangular superior.",
                                    "Explique quadrados mínimos lineares: min ||Ax - b||_2 resolvido por x = R^{-1} Q^T b.",
                                    "Descreva estabilidade backward: perturbação pequena em A levando a solução exata para A perturbado.",
                                    "Revise número de condição κ(A) = ||A|| ||A^{-1}|| e ε_mach como unidade de arredondamento máquina.",
                                    "Entenda bound de erro O(ε_mach κ(A)) para propagação de erros."
                                  ],
                                  "verification": "Resuma os conceitos em um parágrafo coeso e liste definições chave em um quadro.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Matrix Computations' de Golub & Van Loan (cap. 5), notas de aula sobre álgebra linear numérica.",
                                  "tips": "Use diagramas para visualizar QR e fluxogramas para estabilidade.",
                                  "learningObjective": "Dominar terminologia e relações básicas entre QR, least squares e estabilidade.",
                                  "commonMistakes": "Confundir estabilidade forward com backward; ignorar que κ(A) amplifica erros."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Construção da Decomposição QR via Ortogonalização Estável",
                                  "subSteps": [
                                    "Compare Gram-Schmidt clássico (instável) vs. modificado ou Householder reflections (estáveis).",
                                    "Implemente Householder QR em pseudocódigo, focando em preservação de ortogonalidade.",
                                    "Analise por que Householder garante ||Q^T Q - I|| = O(ε_mach).",
                                    "Discuta perda de ortogonalidade em Gram-Schmidt devido a cancelamento catastrófico.",
                                    "Verifique numericamente com matriz ill-condicionada pequena."
                                  ],
                                  "verification": "Escreva pseudocódigo para Householder QR e compute ||Q^T Q - I|| < 10 ε_mach em exemplo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB ou Python (NumPy/SciPy) para testar QR em matrizes como Hilbert(5), Higham 'Accuracy and Stability'.",
                                  "tips": "Sempre normalize colunas durante reflexão para evitar overflow.",
                                  "learningObjective": "Compreender métodos estáveis de QR e sua propriedade ortogonal numérica.",
                                  "commonMistakes": "Assumir Gram-Schmidt clássico é estável; não testar com κ(A) alto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Estabilidade Backward da QR para Quadrados Mínimos",
                                  "subSteps": [
                                    "Mostre que QR backward stable implica computed \bar{Q}, \bar{R} tais que A + δA = \bar{Q} \bar{R}, ||δA|| = O(ε_mach ||A||).",
                                    "Derive que solução least squares tem erro forward O(ε_mach κ(A)) ||x||.",
                                    "Explique por que multiplicação Q^T b é estável (ortogonalidade preserva norma).",
                                    "Discuta R^{-1} como fonte principal de amplificação por κ(R) ≈ κ(A).",
                                    "Compare com normal equations (instável, O(ε_mach κ(A)^2))."
                                  ],
                                  "verification": "Prove informalmente o bound backward e compare com normal equations em um slide.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Artigos de Björck 'Numerical Methods for Least Squares', MATLAB para simular δA.",
                                  "tips": "Use análise de perturbação: δx / x ≈ κ(A) δb / b + κ(A) δA / A.",
                                  "learningObjective": "Explicar mecanismo de estabilidade backward da QR em least squares.",
                                  "commonMistakes": "Confundir backward stability com small forward error; subestimar κ(R)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar e Verificar Bound de Erro O(ε_mach κ(A))",
                                  "subSteps": [
                                    "Estime ||δA|| ≤ n^{3/2} ε_mach ||A|| para Householder QR (teorema padrão).",
                                    "Mostre ||\bar{x} - x|| / ||x|| ≤ O(ε_mach κ(A)) usando ||δx|| ≤ κ(R) ||δr|| onde r = Q^T b.",
                                    "Implemente experimento numérico: adicione ruído ε_mach e meça erros vs. κ(A).",
                                    "Analise dependência em m, n para A m×n.",
                                    "Conclua por que QR é preferida sobre outros métodos."
                                  ],
                                  "verification": "Gere gráfico de log(error) vs. log(κ(A)) mostrando inclinação 1 para confirmação.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python/MATLAB com cond=svd(A), exemplos de matrizes Vandermonde ou Frank.",
                                  "tips": "Use ε_mach = 2^{-53} no double; plote para κ de 10^1 a 10^12.",
                                  "learningObjective": "Derivar quantitativamente o bound de erro e validá-lo numericamente.",
                                  "commonMistakes": "Ignorar fatores n^{3/2}; testar só com A bem condicionado."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Aplicar Conhecimento",
                                  "subSteps": [
                                    "Escreva explicação completa: 'Por quê QR é backward stable para least squares?'.",
                                    "Resolva problema real: ajuste de regressão com ruído, compare QR vs. normal eqs.",
                                    "Discuta limitações: quando κ(A) >> 1/ε_mach, regularização necessária.",
                                    "Prepare FAQ: diferenças com SVD, impacto de pivoteamento.",
                                    "Autoavalie com verificações finais."
                                  ],
                                  "verification": "Ensine o tópico a um par (rubrica de ensino) ou grave vídeo de 5 min.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Dados reais (e.g., housing dataset), Jupyter notebook para regressão.",
                                  "tips": "Use storytelling: 'QR salva o dia em dados ruidosos'.",
                                  "learningObjective": "Integrar análise em explicação fluida e aplicável.",
                                  "commonMistakes": "Focar só teoria sem experimentos; esquecer pivoteamento para rank-deficient."
                                }
                              ],
                              "practicalExample": "Considere A = [1 1; 1 2; 1 3] (3x2, κ(A)≈14), b=[1;2;3]. Compute QR via Householder: Q ortogonal numérica, resolva x = R\\(Q'*b). Adicione δA ~ ε_mach A, verifique ||δA||/||A|| ≈ 10^{-15}, erro em x ≈ 10^{-15} * 14 = O(ε_mach κ(A)). Compare com normal eqs (erro 10^{-10}).",
                              "finalVerifications": [
                                "Explica em palavras próprias por que QR é backward stable.",
                                "Deriva bound O(ε_mach κ(A)) para erro forward.",
                                "Implementa QR numérica e mede ||Q'*Q - I|| < c n ε_mach.",
                                "Compara estabilidade QR vs. normal equations em exemplo ill-condicionado.",
                                "Identifica limitações quando κ(A) ε_mach > 1.",
                                "Aplica a regressão linear real com análise de erro."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de backward stability e bound de erro (90% correto).",
                                "Correção matemática na derivação (sem erros em estimativas O()).",
                                "Profundidade numérica: experimentos mostram dependência linear em κ(A).",
                                "Clareza na explicação: usa analogias e evita jargão desnecessário.",
                                "Completude: cobre Householder, comparação e aplicações.",
                                "Criatividade: conecta a cenários reais além do exemplo dado."
                              ],
                              "crossCurricularConnections": [
                                "Computação Científica: Implementação em LAPACK/BLAS para QR escalável.",
                                "Estatística: Regressão linear robusta em dados observacionais.",
                                "Física Computacional: Modelagem de sistemas lineares em mecânica quântica.",
                                "Engenharia de Software: Análise de sensibilidade em solvers numéricos."
                              ],
                              "realWorldApplication": "Em machine learning, QR é usada em regressão linear estável para grandes datasets (e.g., scikit-learn), evitando amplificação de erros em imagens de satélite ou previsões financeiras onde κ(A) alto devido a multicolinearidade."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.3.2",
                            "name": "Analisar sensibilidade usando SVD",
                            "description": "Discutir a estabilidade da SVD computacional e seu uso para revelar componentes sensíveis na solução de quadrados mínimos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de SVD e Quadrados Mínimos Lineares",
                                  "subSteps": [
                                    "Relembrar a decomposição SVD de uma matriz A = U Σ V^T, identificando singular values σ_i.",
                                    "Entender a solução de quadrados mínimos via SVD: x = V Σ^+ U^T b, onde Σ^+ é a pseudoinversa.",
                                    "Discutir o papel dos singular values pequenos na amplificação de erros.",
                                    "Implementar SVD básica em Python usando numpy.linalg.svd para uma matriz de exemplo.",
                                    "Calcular a pseudoinversa manualmente para uma matriz 2x2."
                                  ],
                                  "verification": "Computar SVD de uma matriz de teste e verificar se A ≈ U Σ V^T com norma residual < 1e-10.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Documentação SVD no NumPy",
                                    "Capítulo 2 de 'Matrix Computations' por Golub e Van Loan (PDF online)"
                                  ],
                                  "tips": "Sempre normalize as colunas da matriz A para evitar issues de escala.",
                                  "learningObjective": "Compreender como SVD resolve least squares e identifica singular values críticos.",
                                  "commonMistakes": [
                                    "Confundir singular values com eigenvalues",
                                    "Ignorar a ordenação decrescente dos σ_i",
                                    "Não verificar reconstrução da matriz"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Condição Numérica e Sensibilidade em Least Squares",
                                  "subSteps": [
                                    "Calcular o número de condição cond(A) = σ_max / σ_min e sua relação com sensibilidade.",
                                    "Estudar a fórmula de sensibilidade: ||δx|| / ||x|| ≈ cond(A) * ||δb|| / ||b|| para ruído em b.",
                                    "Explorar o gap ratio σ_k / σ_{k+1} para rank-deficiency.",
                                    "Simular erros de arredondamento adicionando ruído gaussiano a b e recomputar x.",
                                    "Plotar curvas de sensibilidade vs. threshold de singular values cortados."
                                  ],
                                  "verification": "Para uma matriz mal-condicionada, mostrar que cond(A) > 1e6 amplifica erros em x por fator similar.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Jupyter Notebook",
                                    "Matplotlib para plots",
                                    "Exemplos de matrizes Hilbert para teste de condição"
                                  ],
                                  "tips": "Use log-scale para singular values em plots para visualizar gaps.",
                                  "learningObjective": "Quantificar como singular values pequenos causam instabilidade numérica.",
                                  "commonMistakes": [
                                    "Usar cond(2-norm) em vez de cond(Frobenius) indevidamente",
                                    "Não distinguir perturbações em A vs. b",
                                    "Ignorar máquina epsilon (~1e-16)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar SVD para Revelar Componentes Sensíveis",
                                  "subSteps": [
                                    "Decompor o problema least squares usando SVD e isolar componentes associados a σ_i pequenos.",
                                    "Identificar direções sensíveis: colunas de V correspondentes a σ_i próximos de zero.",
                                    "Computar contribuições relativas: |v_i^T x| * σ_i para cada modo.",
                                    "Realizar análise de trade-off: truncar SVD e medir perda em ||Ax - b|| vs. estabilidade de x.",
                                    "Implementar função personalizada para rank-revealing SVD e thresholding."
                                  ],
                                  "verification": "Em um exemplo, demonstrar que truncar σ_i < 1e-6 reduz cond(x) em 90% sem perda significativa no residual.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "SciPy para svdvals",
                                    "Código fonte de TSVD (truncated SVD)",
                                    "Artigo 'The Sensitivity of the SVD' de Stewart (PDF)"
                                  ],
                                  "tips": "Threshold dinâmico: tol = max(m,n) * eps * σ_max.",
                                  "learningObjective": "Usar SVD para diagnosticar e mitigar sensibilidade em soluções least squares.",
                                  "commonMistakes": [
                                    "Interpretar U em vez de V para direções de solução",
                                    "Não normalizar contribuições por σ_i",
                                    "Aplicar truncagem sem validar residual"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Estabilidade Computacional da SVD e Interpretação",
                                  "subSteps": [
                                    "Analisar estabilidade da SVD: backward stable com O(eps * cond(Σ)) erro.",
                                    "Comparar SVD vs. QR para least squares em termos de sensibilidade revelada.",
                                    "Simular cenários reais: adicionar ruído em A e b, comparar soluções.",
                                    "Documentar relatório: tabela de singular values, cond numbers, componentes sensíveis.",
                                    "Testar em dados reais (ex: ajuste de regressão com multicolinearidade)."
                                  ],
                                  "verification": "Gerar relatório mostrando que SVD identifica corretamente o componente sensível em um dataset sintético.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB ou Octave para comparação",
                                    "Dataset de regressão do UCI ML Repository",
                                    "Notas de aula sobre estabilidade numérica"
                                  ],
                                  "tips": "Use LAPACK routines subjacentes para máxima precisão.",
                                  "learningObjective": "Avaliar estabilidade da SVD e interpretar resultados para análise de sensibilidade.",
                                  "commonMistakes": [
                                    "Assumir SVD é imune a erros de arredondamento",
                                    "Não considerar custo computacional O(mn^2)",
                                    "Sobrepor interpretação estatística sem contexto numérico"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um problema de ajuste de curvas em dados de sensores com ruído: A (10x3) com colunas quase lineares. Compute SVD, identifique σ_3 ≈ 1e-8, revele que o terceiro coeficiente x_3 é sensível (amplifica ruído por 1e8), e sugira truncar para modelo rank-2 estável.",
                              "finalVerifications": [
                                "Computa corretamente SVD e pseudoinversa para matrizes m x n.",
                                "Identifica singular values pequenos e calcula cond(A) com precisão.",
                                "Simula perturbações e quantifica amplificação em ||δx||.",
                                "Gera plots de singular values e contribuições de modos.",
                                "Recomenda truncagem baseada em threshold e valida estabilidade.",
                                "Redige relatório interpretando componentes sensíveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão na decomposição SVD (erro de reconstrução < 1e-12).",
                                "Correta identificação de componentes sensíveis via V e Σ.",
                                "Análise quantitativa de sensibilidade com fórmulas derivadas.",
                                "Implementação numérica robusta e reproduzível.",
                                "Interpretação clara da estabilidade computacional.",
                                "Aplicação criativa em exemplo prático com insights acionáveis."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Similar a PCA para redução de dimensionalidade em regressão.",
                                "Machine Learning: Regularização via truncada SVD em ridge regression.",
                                "Física/Engenharia: Análise modal em vibrações (modos sensíveis a ruído).",
                                "Ciência de Dados: Detecção de multicolinearidade em datasets reais."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, analisar sensibilidade em ajustes de trajetórias de satélites usando dados de telemetria ruidosos; SVD revela parâmetros instáveis devidos a alinhamentos orbitais, permitindo modelos robustos que evitam falhas de controle."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.2",
                              "10.1.4.5.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.3.3",
                            "name": "Interpretar experimentos numéricos de sensibilidade",
                            "description": "Realizar e interpretar simulações em software (ex: MATLAB) para ilustrar perda de precisão em problemas mal-condicionados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Problema Mal-Condicionado no Software",
                                  "subSteps": [
                                    "Selecionar uma matriz de exemplo mal-condicionada, como a matriz de Hilbert de ordem 5 ou 10.",
                                    "Definir o sistema de equações lineares Ax = b, onde A é mal-condicionada.",
                                    "Implementar a função para gerar perturbações pequenas em b ou A (ex: adicionar ruído gaussiano de 1e-10).",
                                    "Configurar o software (MATLAB ou Octave) com precisão double.",
                                    "Salvar o script inicial para reutilização."
                                  ],
                                  "verification": "Executar o script e confirmar que a matriz A tem condição number (cond(A)) maior que 1e10.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB/Octave instalado, documentação de funções svd() e cond().",
                                  "tips": "Use hilb(n) no MATLAB para gerar matriz de Hilbert rapidamente.",
                                  "learningObjective": "Entender como gerar e representar problemas mal-condicionados numericamente.",
                                  "commonMistakes": "Confundir condição number com rank; usar ordens muito altas que causem overflow."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar Simulações com Perturbações Variadas",
                                  "subSteps": [
                                    "Resolver o sistema original Ax = b usando mldivide (\\) ou lsqr.",
                                    "Aplicar 5-10 perturbações crescentes em b (ex: epsilon = 1e-12 a 1e-6).",
                                    "Registrar soluções x_pert e calcular norma relativa do erro ||x - x_pert|| / ||x||.",
                                    "Repetir para perturbações em A.",
                                    "Plotar gráficos de erro vs. tamanho da perturbação (log-log scale)."
                                  ],
                                  "verification": "Gerar plots mostrando amplificação exponencial do erro para problemas mal-condicionados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Scripts do passo 1, funções norm(), semilogy().",
                                  "tips": "Use loops for para automatizar perturbações e cell arrays para armazenar resultados.",
                                  "learningObjective": "Realizar experimentos numéricos controlados para observar sensibilidade.",
                                  "commonMistakes": "Não normalizar erros; ignorar escala logarítmica nos plots."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Resultados Numéricos",
                                  "subSteps": [
                                    "Calcular o número de condição κ(A) usando svd(A).",
                                    "Comparar limite teórico de erro relativo (κ(A) * ε_máquina) com erros observados.",
                                    "Identificar o regime onde perda de precisão domina (erro ~ κ * pert).",
                                    "Testar com precisões diferentes (single vs double) usando eps.",
                                    "Documentar observações em um relatório curto com tabelas e plots."
                                  ],
                                  "verification": "Tabela mostrando que erros simulados alinham com bound teórico κ(A) * ||Δb|| / ||b||.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Scripts anteriores, eps (machine epsilon), svd().",
                                  "tips": "Anote κ(A) logo no início para referência rápida.",
                                  "learningObjective": "Conectar resultados empíricos com teoria de análise de sensibilidade.",
                                  "commonMistakes": "Esquecer de considerar ε_máquina (~2e-16 em double); superestimar precisão."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Experimentos e Concluir",
                                  "subSteps": [
                                    "Explicar verbalmente por que problemas mal-condicionados amplificam erros de arredondamento.",
                                    "Discutir implicações para quadrados mínimos lineares (ex: regressão instável).",
                                    "Propor regularizações como Tikhonov para mitigar.",
                                    "Comparar com problema bem-condicionado (ex: identidade matrix).",
                                    "Preparar resumo com lições aprendidas."
                                  ],
                                  "verification": "Resumo escrito identificando corretamente sensibilidade como κ(A) * cond(b).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Relatório do passo 3, exemplos de regularização.",
                                  "tips": "Use analogia de 'balança instável' para explicar condição ruim.",
                                  "learningObjective": "Desenvolver habilidade de interpretação crítica de experimentos numéricos.",
                                  "commonMistakes": "Atribuir erros só a perturbações externas, ignorando arredondamento interno."
                                }
                              ],
                              "practicalExample": "Em MATLAB, gere A = hilb(8); b = A * ones(8,1); x_true = ones(8,1); adicione Δb = 1e-10 * randn(8,1); resolva perturbado e observe ||x - x_pert|| / ||x|| ≈ 1e6 devido a cond(A) ≈ 1e13.",
                              "finalVerifications": [
                                "Pode gerar plots log-log mostrando amplificação linear do erro por κ(A).",
                                "Explica corretamente o papel de erros de arredondamento em soluções instáveis.",
                                "Identifica quando usar métodos alternativos como SVD para quadrados mínimos.",
                                "Compara resultados com problema bem-condicionado.",
                                "Documenta experimento com código reproduzível e conclusões claras.",
                                "Calcula bounds teóricos que batem com simulações numéricas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração e execução das simulações (código sem erros).",
                                "Qualidade dos plots e tabelas (escalas corretas, legendas claras).",
                                "Correção na análise de condição number e bounds de erro.",
                                "Profundidade da interpretação (liga teoria à prática).",
                                "Criatividade em exemplos e propostas de mitigação.",
                                "Clareza no relatório final (linguagem acessível, estrutura lógica)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Uso avançado de MATLAB para análise numérica.",
                                "Estatística: Aplicação em regressão linear e ajuste de dados ruidosos.",
                                "Engenharia: Modelagem de sistemas físicos sensíveis (ex: controle).",
                                "Física Computacional: Simulações de dinâmica com matrizes il-condicionadas."
                              ],
                              "realWorldApplication": "Em processamento de imagens (inversão de matrizes grandes), previsão meteorológica (sistemas lineares massivos), finanças (otimização de portfólios via mínimos quadrados), onde pequenas incertezas em dados levam a previsões drasticamente erradas sem análise de sensibilidade."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.2.2"
                            ]
                          },
                          {
                            "id": "10.1.4.5.3.4",
                            "name": "Relacionar com métodos iterativos",
                            "description": "Breve análise de como o condicionamento afeta a convergência de métodos como CG para quadrados mínimos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Condicionamento e Método dos Gradientes Conjugados (CG)",
                                  "subSteps": [
                                    "Defina o número de condicionamento κ(A) para uma matriz A simétrica positiva definida.",
                                    "Explique o problema de quadrados mínimos: min ||Ax - b||₂ onde A é m x n.",
                                    "Descreva o algoritmo CG para resolver sistemas lineares Ax = b e sua extensão para quadrados mínimos.",
                                    "Liste as suposições do CG: A simétrica positiva definida.",
                                    "Identifique métricas de convergência no CG, como redução do resíduo."
                                  ],
                                  "verification": "Resuma em um parágrafo como κ(A) mede a sensibilidade e liste 3 propriedades do CG.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Álgebra Linear Numérica (ex: Golub-Van Loan), notebook Jupyter com NumPy/SciPy.",
                                  "tips": "Use diagramas para visualizar elipses de nível em normas euclidianas.",
                                  "learningObjective": "Compreender os pré-requisitos teóricos para analisar convergência.",
                                  "commonMistakes": "Confundir condicionamento com rank; ignorar que CG requer A SPD."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Teoria de Convergência do CG",
                                  "subSteps": [
                                    "Estude o teorema de convergência de CG: ||e_k||_A ≤ 2 (√κ - 1)/(√κ + 1)^k ||e_0||_A.",
                                    "Derive qualitativamente como κ grande amplia o fator (√κ - 1)/(√κ + 1).",
                                    "Discuta o número de iterações necessário: O(k) ≈ √κ para precisão ε.",
                                    "Compare com método de gradiente: CG é mais rápido devido a conjugação.",
                                    "Explique o papel dos autovalores extremos em autovalores de A."
                                  ],
                                  "verification": "Calcule o bound de erro para κ=10 e κ=1000 após 10 iterações.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Notas de aula sobre métodos iterativos, calculadora simbólica (SymPy).",
                                  "tips": "Aproxime (√κ - 1)/(√κ + 1) ≈ 1 - 2/√κ para κ grande.",
                                  "learningObjective": "Dominar a dependência da convergência em κ(A).",
                                  "commonMistakes": "Esquecer que o bound é no norma A, não euclidiana; superestimar velocidade para κ pequeno."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar o Impacto do Condicionamento na Convergência para Quadrados Mínimos",
                                  "subSteps": [
                                    "Formule o sistema normal para quadrados mínimos: AᵀAx = Aᵀb, onde κ(AᵀA) = [κ(A)]².",
                                    "Analise como erros de arredondamento propagam via κ, afetando iterações CG.",
                                    "Estude pré-condicionadores para mitigar alto κ (ex: diagonal, ILU).",
                                    "Discuta estagnação do CG em matrizes mal condicionadas.",
                                    "Relacione com análise de sensibilidade: perturbações em b ou A."
                                  ],
                                  "verification": "Escreva uma equação mostrando κ(AᵀA) = κ(A)² e discuta implicações.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Artigos sobre CG (ex: Shewchuk's paper), MATLAB/Python para protótipos.",
                                  "tips": "Foque em exemplos 2D para visualizar direção de conjugados.",
                                  "learningObjective": "Conectar condicionamento, estabilidade e convergência em quadrados mínimos.",
                                  "commonMistakes": "Ignorar que CG em AᵀA herda [κ(A)]²; confundir com métodos diretos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e Visualizar Numericamente",
                                  "subSteps": [
                                    "Gere matrizes A bem (κ≈1) e mal condicionada (κ=10^6) via svd.",
                                    "Implemente CG para resolver AᵀAx = Aᵀb e plote resíduo vs iterações.",
                                    "Adicione ruído de arredondamento e compare curvas de convergência.",
                                    "Teste com pré-condicionador simples e meça aceleração.",
                                    "Grave número de iterações para ε=1e-10."
                                  ],
                                  "verification": "Produza gráficos mostrando >10x mais iterações para κ alto.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python (NumPy, SciPy, Matplotlib), código template de CG.",
                                  "tips": "Use np.linalg.cond() para verificar κ; logscale no eixo y para resíduos.",
                                  "learningObjective": "Validar teoricamente através de experimentos computacionais.",
                                  "commonMistakes": "Não normalizar b; usar float32 em vez de float64 para simular erros."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Análise e Conclusões",
                                  "subSteps": [
                                    "Resuma como alto κ causa convergência lenta e instabilidade.",
                                    "Discuta trade-offs: CG vs diretos (Cholesky) em grandes sistemas.",
                                    "Proponha estratégias: pré-condicionamento, reinício CG.",
                                    "Relacione com aplicações reais de quadrados mínimos.",
                                    "Prepare relatório com achados."
                                  ],
                                  "verification": "Escreva 1-página de análise com gráficos e bounds teóricos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Editor de texto, gráficos da simulação.",
                                  "tips": "Use bullet points para clareza; inclua referências.",
                                  "learningObjective": "Integrar teoria, análise e prática em uma visão coesa.",
                                  "commonMistakes": "Generalizar demais sem dados numéricos; omitir limitações do CG."
                                }
                              ],
                              "practicalExample": "Considere ajustar uma reta y = mx + c a pontos (x_i, y_i + ε_i) com A = [x 1], b = y. Para x clusterizados (alto κ), CG em AᵀAx = Aᵀb converge em 100+ iterações vs 5 para x uniformes. Simule com n=1000, κ=10^4, mostrando platô no resíduo devido a erros de arredondamento.",
                              "finalVerifications": [
                                "Calcule corretamente o bound de convergência para κ dado.",
                                "Gere simulações mostrando dependência quadrática em κ(A) para quadrados mínimos.",
                                "Identifique pelo menos 2 estratégias para mitigar alto condicionamento.",
                                "Explique verbalmente o papel dos autovalores em 1 minuto.",
                                "Produza gráfico de resíduos com logscale validando teoria.",
                                "Relacione estabilidade numérica à convergência em relatório."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação do teorema de convergência (80%+ correto).",
                                "Qualidade dos gráficos de simulação (clareza, escalas adequadas).",
                                "Profundidade da análise de impacto do condicionamento (inclui [κ(A)]²).",
                                "Uso correto de pré-condicionamento em experimentos.",
                                "Síntese coerente ligando teoria a prática.",
                                "Ausência de erros comuns como confusão de normas."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação de CG em Python/MATLAB.",
                                "Otimização: Paralelos com gradiente descendente em ML.",
                                "Física Computacional: Solução de PDEs discretizadas mal condicionadas.",
                                "Estatística: Regressão linear e análise de sensibilidade."
                              ],
                              "realWorldApplication": "Em image denoising via quadrados mínimos (A = blurring operator, alto κ), CG com pré-condicionador acelera convergência de horas para minutos em GPUs, essencial para MRI reconstruction em medicina onde estabilidade afeta diagnósticos precisos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.5",
                "name": "Análise de Sensibilidade",
                "description": "Estudo geral da sensibilidade em computações com matrizes e autovalores.",
                "totalSkills": 44,
                "atomicTopics": [
                  {
                    "id": "10.1.5.1",
                    "name": "Número de Condição de Matrizes",
                    "description": "Definição e interpretação do número de condição como medida de sensibilidade numérica de matrizes.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.1.1",
                        "name": "Definição do Número de Condição",
                        "description": "Apresenta a definição formal do número de condição de uma matriz como a razão entre a norma da matriz e a norma de sua inversa, destacando sua dependência da escolha da norma vetorial e matricial.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.1",
                            "name": "Definir o número de condição usando normas",
                            "description": "Explicar que cond(A) = ||A|| * ||A^{-1}|| para matrizes invertíveis A, e listar normas comuns como norma 2, norma 1 e norma infinito, com exemplos numéricos simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Normas de Matrizes",
                                  "subSteps": [
                                    "Defina norma de matriz como uma função que generaliza o comprimento, satisfazendo propriedades como positividade, homogeneidade e desigualdade triangular.",
                                    "Discuta normas induzidas por normas vetoriais, onde ||A|| = sup_{x≠0} ||Ax|| / ||x||.",
                                    "Revise normas vetoriais básicas: norma 1 (soma de absolutos), norma 2 (euclidiana) e norma infinito (máximo absoluto).",
                                    "Entenda que para matrizes, normas 1 e ∞ são máximos de somas de colunas/linhas absolutas, e norma 2 é raiz do maior autovalor de A^T A.",
                                    "Pratique com uma matriz 2x2 simples, como A = [[1, 0], [0, 2]], calculando intuitivamente."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as propriedades de uma norma e dê um exemplo de norma induzida.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel e caneta, calculadora científica, tabela de referência de normas de matrizes.",
                                  "tips": "Visualize normas como 'tamanho' da matriz; comece com normas vetoriais para intuitividade.",
                                  "learningObjective": "Identificar e explicar propriedades fundamentais de normas de matrizes.",
                                  "commonMistakes": "Confundir normas de vetores com normas de matrizes; esquecer que normas de matrizes são induzidas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Normas Comuns: 1, 2 e Infinito",
                                  "subSteps": [
                                    "Calcule a norma 1: máximo da soma absoluta das colunas de A.",
                                    "Calcule a norma infinito: máximo da soma absoluta das linhas de A.",
                                    "Para norma 2, use a fórmula ||A||_2 = sqrt(λ_max(A^T A)) ou aproximação para matrizes pequenas.",
                                    "Compare as três normas em uma matriz exemplo, como A = [[1, 1], [1, 2]].",
                                    "Liste vantagens: norma 1 e ∞ são fáceis de computar, norma 2 é geometricamente intuitiva."
                                  ],
                                  "verification": "Forneça cálculos corretos das três normas para uma matriz 2x2 dada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora ou software como Python (NumPy) para verificação, matrizes de exemplo impressas.",
                                  "tips": "Use somas absolutas para normas 1 e ∞; para norma 2 em 2x2, calcule autovalores manualmente.",
                                  "learningObjective": "Calcular com precisão as normas 1, 2 e infinito para matrizes dadas.",
                                  "commonMistakes": "Esquecer valores absolutos nas somas; errar na transposição para norma 2."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir o Número de Condição Usando Normas",
                                  "subSteps": [
                                    "Estabeleça que para A invertível, cond(A) = ||A|| * ||A^{-1}||, medindo sensibilidade a perturbações.",
                                    "Explique que cond(A) ≥ 1 sempre, e cond(A)=1 se A é isometria (ortogonal).",
                                    "Discuta independência da escolha de norma (equivalência de normas).",
                                    "Verifique invertibilidade de A antes de calcular A^{-1}.",
                                    "Relacione com análise de erro: erro relativo em solução ≈ cond(A) * erro relativo em A."
                                  ],
                                  "verification": "Escreva a fórmula de cond(A) e prove que cond(I)=1 para matriz identidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha com fórmula de inversa de 2x2, referência teórica de álgebra linear.",
                                  "tips": "Lembre: cond mede 'quão longe A está de ser singular'; alto cond indica instabilidade.",
                                  "learningObjective": "Formular e justificar a definição de número de condição via normas.",
                                  "commonMistakes": "Aplicar cond a matrizes singulares; ignorar fator ||A^{-1}||."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Exemplo Numérico Completo",
                                  "subSteps": [
                                    "Escolha A = [[2, 1], [1, 1]]; calcule det(A)=1, A^{-1}=[[1, -1], [-1, 2]].",
                                    "Compute ||A||_1 = 3, ||A^{-1}||_1 = 3, cond_1(A)=9.",
                                    "Repita para norma ∞: ambos 3, cond=9.",
                                    "Aproxime norma 2: calcule A^T A, autovalores, cond_2≈3.16*3.16≈10.",
                                    "Interprete: cond≈10 significa soluções sensíveis a ~10x perturbações relativas."
                                  ],
                                  "verification": "Apresente cálculos completos e cond para todas normas, com interpretação.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Software NumPy/MATLAB para checagem (opcional), papel quadriculado.",
                                  "tips": "Verifique com np.linalg.cond(A, p=1/2/inf) em Python para validação.",
                                  "learningObjective": "Executar cálculo integral de cond(A) com múltiplas normas e interpretar resultados.",
                                  "commonMistakes": "Erro na inversa; inconsistência entre normas calculadas."
                                }
                              ],
                              "practicalExample": "Para A = [[2, 1], [1, 1]], ||A||_1 = max(3,2)=3, A^{-1}=[[1,-1],[-1,2]], ||A^{-1}||_1=3, cond_1(A)=9. Similar para outras normas, mostrando sensibilidade moderada.",
                              "finalVerifications": [
                                "Pode escrever corretamente cond(A) = ||A|| * ||A^{-1}||?",
                                "Lista e define normas 1, 2 e ∞ com fórmulas?",
                                "Calcula cond_1 e cond_∞ para matriz 2x2 simples?",
                                "Explica por que cond(A) mede sensibilidade?",
                                "Identifica que cond depende da norma mas ordem é similar?",
                                "Verifica cond(I)=1?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula de definição (100% correto).",
                                "Cálculos numéricos exatos para normas e inversa (erro <1%).",
                                "Explicação clara de interpretação de cond alto/baixo.",
                                "Uso correto de propriedades de normas em exemplos.",
                                "Identificação de erros comuns em cálculos.",
                                "Conexão com contexto de sensibilidade numérica."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Uso de np.linalg.cond em Python/NumPy para análise prática.",
                                "Análise Numérica: Relação com propagação de erros em solvers lineares.",
                                "Engenharia: Avaliação de estabilidade em modelos de simulação física.",
                                "Física Computacional: Sensibilidade em sistemas dinâmicos discretizados."
                              ],
                              "realWorldApplication": "Em engenharia civil, avalia estabilidade numérica de matrizes de rigidez em simulações FEM; cond alto alerta para refinamento de malha ou modelo para evitar erros catastróficos em predições estruturais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.2",
                            "name": "Relacionar com decomposição em valores singulares (SVD)",
                            "description": "Demonstrar que para a norma 2, cond_2(A) = σ_max / σ_min, onde σ são os valores singulares de A, e interpretar o papel da SVD na computação do número de condição.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de SVD e Norma 2",
                                  "subSteps": [
                                    "Defina a Decomposição em Valores Singulares (SVD) para uma matriz A m×n: A = U Σ V^T, onde U e V são ortogonais e Σ é diagonal com valores singulares σ1 ≥ σ2 ≥ ... ≥ σr > 0.",
                                    "Explique a norma 2 de uma matriz: ||A||_2 = sup_{x≠0} ||Ax||_2 / ||x||_2 = maior valor singular σ_max.",
                                    "Discuta o número de condição na norma 2: cond_2(A) = ||A||_2 ||A^{-1}||_2.",
                                    "Identifique que para A invertível, os valores singulares de A^{-1} são 1/σ_i de A.",
                                    "Verifique com uma matriz diagonal simples para intuitar a relação."
                                  ],
                                  "verification": "Escreva definições precisas e compute ||D||_2 e ||D^{-1}||_2 para D diagonal com entradas σ1, σ2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, calculadora científica, notebook Jupyter com NumPy para verificação opcional.",
                                  "tips": "Use diagramas geométricos para visualizar a ação de U e V como rotações.",
                                  "learningObjective": "Compreender os componentes da SVD e sua relação com normas matriciais.",
                                  "commonMistakes": "Confundir valores singulares com autovalores; lembrar que SVD aplica a retângulos não quadrados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Relação cond_2(A) = σ_max / σ_min",
                                  "subSteps": [
                                    "Parta da definição cond_2(A) = ||A||_2 ||A^{-1}||_2 = σ_max(A) * σ_max(A^{-1}).",
                                    "Mostre que σ_max(A^{-1}) = 1 / σ_min(A), pois os valores singulares de A^{-1} são o inverso dos de A.",
                                    "Prove usando propriedades: ||A^{-1}||_2 = sup ||A^{-1}y||_2 / ||y||_2 = sup ||x||_2 / ||Ax||_2 (com y=Ax).",
                                    "Conclua que o máximo ocorre quando x é o vetor singular direito associado a σ_min.",
                                    "Verifique algebricamente para A = U Σ V^T, então A^{-1} = V Σ^{-1} U^T."
                                  ],
                                  "verification": "Derive a igualdade passo a passo em um caderno e teste com uma matriz 2x2.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Caderno de anotações, software como MATLAB ou Python (scipy.linalg.svd).",
                                  "tips": "Escreva todas as supremações explicitamente para evitar saltos lógicos.",
                                  "learningObjective": "Derivar matematicamente a fórmula exata envolvendo SVD.",
                                  "commonMistakes": "Esquecer que σ_min é o menor valor singular positivo; assumir A quadrada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar SVD e Número de Condição em Exemplo Prático",
                                  "subSteps": [
                                    "Escolha uma matriz A 2x2, como A = [[1, 0.1], [0.1, 1]], e compute SVD manualmente ou via software.",
                                    "Extraia σ_max e σ_min de Σ.",
                                    "Calcule cond_2(A) diretamente via ||A||_2 ||A^{-1}||_2 e compare com σ_max / σ_min.",
                                    "Analise numericamente: perturbe A e observe amplificação de erros relacionada a cond_2.",
                                    "Registre valores exatos e aproxime se necessário."
                                  ],
                                  "verification": "Confirme que os valores coincidem dentro de precisão numérica (erro < 1e-10).",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python com NumPy/SciPy, ou MATLAB; matriz exemplo impressa.",
                                  "tips": "Use np.linalg.cond(A, 2) para verificação rápida após cálculo manual.",
                                  "learningObjective": "Aplicar SVD computacionalmente para validar a relação.",
                                  "commonMistakes": "Erro de arredondamento em software; confundir normas 1, inf ou 2."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar o Papel da SVD na Análise de Sensibilidade",
                                  "subSteps": [
                                    "Explique que SVD revela a direção de maior sensibilidade (vetor singular de σ_min).",
                                    "Discuta implicações: alto cond_2 indica ill-conditioned, SVD quantifica via gap σ_max/σ_min.",
                                    "Relacione com resolução de Ax=b: erro relativo ~ cond_2 * erro em b ou A.",
                                    "Interprete em contextos: por que SVD é preferida para cond_2 vs autovalores.",
                                    "Resuma vantagens: SVD sempre existe, numéricamente estável."
                                  ],
                                  "verification": "Escreva um parágrafo de interpretação e responda: 'Por que SVD é essencial para cond_2?'",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Artigos ou slides sobre análise numérica (opcional), caderno.",
                                  "tips": "Pense em elipses: SVD alonga eixos para visualizar condicionamento.",
                                  "learningObjective": "Interpretar SVD como ferramenta diagnóstica para estabilidade numérica.",
                                  "commonMistakes": "Ignorar que cond alto não implica singular; focar só em fórmula, não interpretação."
                                }
                              ],
                              "practicalExample": "Para A = [[2, 1], [1, 1]], SVD dá σ1 ≈ 2.618, σ2 ≈ 0.618, cond_2(A) ≈ 4.236. Perturbe b=[3,2] em 1% e observe erro em x amplificado por ~4x, demonstrando sensibilidade.",
                              "finalVerifications": [
                                "Derivação correta de cond_2(A) = σ_max / σ_min sem erros lógicos.",
                                "Cálculo SVD preciso para pelo menos duas matrizes de teste.",
                                "Interpretação escrita conectando SVD a sensibilidade numérica.",
                                "Comparação numérica entre métodos diretos e via SVD coincide.",
                                "Explicação verbal fluida do papel da SVD em computação de cond_2.",
                                "Identificação de direções sensíveis via vetores singulares."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (100% dos passos corretos).",
                                "Profundidade dos substeps (mínimo 4 por step com detalhes acionáveis).",
                                "Correção numérica em exemplos (erro < 1e-8).",
                                "Qualidade da interpretação (conexão clara com análise de sensibilidade).",
                                "Criatividade em conexões reais (além do básico).",
                                "Completude: todos campos preenchidos sem lacunas."
                              ],
                              "crossCurricularConnections": [
                                "Computação Numérica: Estabilidade em solvers lineares (e.g., QR via SVD).",
                                "Machine Learning: Regularização em PCA/SVD para dados ill-conditioned.",
                                "Física Computacional: Análise de estabilidade em simulações dinâmicas.",
                                "Engenharia: Dimensionamento reduzido via truncada SVD em controle.",
                                "Estatística: Sensibilidade em regressão linear múltipla."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, SVD computa cond_2 de matrizes de rigidez para detectar modos frágeis em estruturas, evitando falhas catastróficas por amplificação de erros de medição em simulações FEM."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.3",
                            "name": "Identificar casos especiais",
                            "description": "Reconhecer que cond(A) = 1 para matrizes ortogonais e cond(A) → ∞ para matrizes singulares, com ilustrações gráficas em 2D.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição do número de condição e introduzir matrizes ortogonais",
                                  "subSteps": [
                                    "Relembre a definição: cond(A) = ||A|| * ||A⁻¹|| para matrizes invertíveis.",
                                    "Defina matriz ortogonal: A^T A = I, implicando ||A|| = ||A⁻¹|| = 1 para normas adequadas.",
                                    "Mostre que para ortogonais, cond(A) = 1.",
                                    "Exemplo simples: Matriz identidade 2x2.",
                                    "Calcule cond(I) manualmente."
                                  ],
                                  "verification": "Confirme que cond(A) = 1 para uma matriz ortogonal de teste usando fórmula.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Caderno, calculadora, software como MATLAB ou Python (NumPy).",
                                  "tips": "Use norma 2 (espectral) para clareza em ortogonais.",
                                  "learningObjective": "Compreender por que matrizes ortogonais têm cond(A) = 1.",
                                  "commonMistakes": "Confundir ortogonal com simétrica; lembre que ortogonais preservam normas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar matrizes singulares e seu número de condição infinito",
                                  "subSteps": [
                                    "Defina matriz singular: det(A) = 0, sem inversa.",
                                    "Explique que cond(A) → ∞ pois ||A⁻¹|| → ∞.",
                                    "Exemplo 2x2: [[1,0],[0,0]], compute autovalores para norma espectral.",
                                    "Discuta limite: perturbações pequenas causam grandes erros.",
                                    "Compare com não-singulares."
                                  ],
                                  "verification": "Verifique det(A) = 0 e tente inverter para erro.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesmos do step 1, mais tabela de autovalores.",
                                  "tips": "Pense em singular como achatamento linear (kernel não-trivial).",
                                  "learningObjective": "Reconhecer que singularidade implica cond infinito.",
                                  "commonMistakes": "Achar que toda mal-condicionada é singular; singular é caso extremo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar ilustrações gráficas em 2D para visualização",
                                  "subSteps": [
                                    "Para ortogonal (ex: rotação 90°): plote unit circle → unit circle preservado.",
                                    "Para singular (ex: projeção): unit circle → linha, distorção extrema.",
                                    "Use software para plotar imagem da esfera unitária sob A.",
                                    "Meça distorção: max/min alongamento.",
                                    "Anote cond ≈ max_stretch / min_stretch."
                                  ],
                                  "verification": "Gere gráficos mostrando preservação vs colapso.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python (Matplotlib, NumPy) ou GeoGebra para plots 2D.",
                                  "tips": "Comece com vetores base para simplicidade.",
                                  "learningObjective": "Visualizar geometricamente cond=1 vs ∞.",
                                  "commonMistakes": "Ignorar norma; foque em elipse SVD para precisão."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação de casos especiais em exemplos mistos",
                                  "subSteps": [
                                    "Dada matriz 2x2, cheque ortogonalidade (A^T A = I?).",
                                    "Cheque singularidade (det=0?).",
                                    "Compute cond aproximado via SVD.",
                                    "Classifique: cond=1, cond=∞ ou intermediário.",
                                    "Desenhe gráfico rápido para confirmação."
                                  ],
                                  "verification": "Corretamente classifique 5 matrizes de teste.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Lista de matrizes de teste, software computacional.",
                                  "tips": "Sempre verifique propriedades antes de cond numérico.",
                                  "learningObjective": "Identificar rapidamente casos especiais.",
                                  "commonMistakes": "Arredondamento numérico fingindo singularidade; use tolerância."
                                }
                              ],
                              "practicalExample": "Considere A = [[0,-1],[1,0]] (rotação 90°, ortogonal): cond(A)=1, círculo unitário mapeado para si. B = [[1,1],[1,1]] (singular): cond(B)=∞, círculo colapsa para linha.",
                              "finalVerifications": [
                                "Explique verbalmente por que cond=1 para ortogonais.",
                                "Identifique singularidade em matriz dada sem cálculo.",
                                "Gere gráfico 2D correto para ambos casos.",
                                "Calcule cond exato para matriz ortogonal 2x2.",
                                "Discuta implicações de estabilidade numérica.",
                                "Classifique 3 matrizes mistas corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de cond para ortogonais/singulares (100%).",
                                "Qualidade das ilustrações gráficas (clareza, precisão).",
                                "Correção em cálculos de cond e det.",
                                "Profundidade na explicação geométrica.",
                                "Identificação correta em exemplos práticos.",
                                "Uso apropriado de ferramentas computacionais."
                              ],
                              "crossCurricularConnections": [
                                "Computação Numérica: Estabilidade de algoritmos de resolução linear.",
                                "Física: Transformações ortogonais em mecânica (rotações).",
                                "Engenharia: Análise de sensibilidade em modelagem estrutural.",
                                "Gráficos Computacionais: Preservação de normas em renderização."
                              ],
                              "realWorldApplication": "Em simulações numéricas (ex: CFD), matrizes ortogonais garantem precisão sem amplificação de erros de arredondamento; singulares indicam modelos inválidos, como em análise de imagens onde colapso revela redundâncias."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.2",
                        "name": "Propriedades e Cálculo do Número de Condição",
                        "description": "Explora propriedades algébricas do número de condição e métodos computacionais para seu cálculo, incluindo estimativas e relação com outras decomposições.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.2.1",
                            "name": "Listar propriedades multiplicativas",
                            "description": "Enunciar e provar que cond(AB) ≤ cond(A) * cond(B) e cond(A^T) = cond(A), com exemplos de matrizes 2x2 para verificação numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Enunciar e compreender as propriedades multiplicativas do número de condição",
                                  "subSteps": [
                                    "Recordar a definição de cond(A) = ||A|| ⋅ ||A⁻¹|| para norma matricial compatível.",
                                    "Enunciar a propriedade: cond(Aᵀ) = cond(A).",
                                    "Enunciar a propriedade: cond(AB) ≤ cond(A) ⋅ cond(B) para matrizes invertíveis A e B.",
                                    "Explicar intuitivamente: a segunda propriedade mostra submultiplicatividade do condicionamento.",
                                    "Discutir normas adequadas (ex: norma 2 ou ∞) onde as propriedades valem."
                                  ],
                                  "verification": "Escrever as propriedades enunciadas corretamente em um documento, incluindo definições.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de álgebra linear",
                                    "Calculadora ou software como MATLAB/Octave",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Sempre especifique a norma usada, pois propriedades dependem dela ser subordinada.",
                                  "learningObjective": "Dominar o enunciado preciso das propriedades multiplicativas.",
                                  "commonMistakes": [
                                    "Confundir cond(AB) = cond(A)cond(B) em vez de ≤",
                                    "Esquecer que A e B devem ser invertíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provar que cond(Aᵀ) = cond(A)",
                                  "subSteps": [
                                    "Mostrar que (Aᵀ)⁻¹ = (A⁻¹)ᵀ.",
                                    "Verificar que ||Aᵀ|| = ||A|| para normas invariantes à transposta (ex: norma 2, Frobenius).",
                                    "Verificar que ||(Aᵀ)⁻¹|| = ||(A⁻¹)ᵀ|| = ||A⁻¹|| pela mesma razão.",
                                    "Concluir cond(Aᵀ) = ||Aᵀ|| ⋅ ||(Aᵀ)⁻¹|| = ||A|| ⋅ ||A⁻¹|| = cond(A).",
                                    "Testar com norma específica, como norma espectral σ_max/σ_min."
                                  ],
                                  "verification": "Derivar a prova completa passo a passo e confirmar com uma matriz exemplo simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de álgebra linear (ex: Strang)",
                                    "Software para normas (Python NumPy)"
                                  ],
                                  "tips": "Lembre-se: propriedades valem para normas que satisfazem ||Aᵀ|| = ||A||.",
                                  "learningObjective": "Realizar a prova formal da invariância sob transposta.",
                                  "commonMistakes": [
                                    "Assumir ||Aᵀ|| = ||A|| sem justificar a norma",
                                    "Erro na inversa da transposta"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar que cond(AB) ≤ cond(A) ⋅ cond(B)",
                                  "subSteps": [
                                    "Escrever cond(AB) = ||AB|| ⋅ ||(AB)⁻¹|| = ||AB|| ⋅ ||B⁻¹ A⁻¹||.",
                                    "Aplicar submultiplicatividade da norma: ||AB|| ≤ ||A|| ⋅ ||B||.",
                                    "Aplicar novamente: ||B⁻¹ A⁻¹|| ≤ ||B⁻¹|| ⋅ ||A⁻¹||.",
                                    "Combinar: cond(AB) ≤ (||A|| ⋅ ||B||) ⋅ (||B⁻¹|| ⋅ ||A⁻¹||) = cond(A) ⋅ cond(B).",
                                    "Notar que igualdade pode ocorrer em casos especiais (ex: normais escalares)."
                                  ],
                                  "verification": "Escrever a prova chain inequality e validar com desigualdades de norma.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Referência de normas matriciais",
                                    "Exemplos de matrizes no papel"
                                  ],
                                  "tips": "Use normas induzidas (subordinadas) para garantir ||AB|| ≤ ||A|| ||B||.",
                                  "learningObjective": "Entender a submultiplicatividade via propriedades de normas.",
                                  "commonMistakes": [
                                    "Esquecer a ordem em ||B⁻¹ A⁻¹||",
                                    "Usar normas não-submultiplicativas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar numericamente com matrizes 2x2 e listar propriedades",
                                  "subSteps": [
                                    "Escolher A = [[2, 1], [1, 1]] e B = [[1, 0], [1, 2]]; calcular inversas.",
                                    "Computar cond(A), cond(B), cond(AB), cond(Aᵀ) usando norma 2 (autovalores).",
                                    "Verificar cond(AB) ≤ cond(A)cond(B) e cond(Aᵀ) = cond(A) numericamente.",
                                    "Listar as propriedades em bullet points com provas e exemplos.",
                                    "Explorar sensibilidade: como ill-condicionamento se propaga."
                                  ],
                                  "verification": "Resultados numéricos batem com propriedades (ex: cond(AB) ≈ 8.0 ≤ 4.3 * 2.6).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python com NumPy ou MATLAB",
                                    "Calculadora matricial online"
                                  ],
                                  "tips": "Use np.linalg.cond() para automação; teste com matrizes mal-condicionadas.",
                                  "learningObjective": "Aplicar propriedades em cálculos concretos e compilar lista.",
                                  "commonMistakes": [
                                    "Erros de cálculo na inversa ou autovalores",
                                    "Norma errada (use '2')"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[1, 0], [0, 2]] (cond(A)=2), B = [[1, 1], [0, 1]] (cond(B)=1), AB = [[1,1],[0,2]] (cond(AB)=2 ≤ 2*1), e Aᵀ=A (cond igual). Calcule via autovalores: σ_max(A)/σ_min(A)=2.",
                              "finalVerifications": [
                                "Enuncia corretamente ambas as propriedades?",
                                "Provas derivadas sem erros lógicos?",
                                "Cálculos numéricos para matrizes 2x2 precisos (erro <1e-10)?",
                                "Lista completa de propriedades com exemplos?",
                                "Explica submultiplicatividade intuitivamente?",
                                "Identifica normas requeridas?"
                              ],
                              "assessmentCriteria": [
                                "Precisão no enunciado e provas (100% correto)",
                                "Correção nos exemplos numéricos (valores exatos ou precisos)",
                                "Profundidade dos substeps (mínimo 4 por step)",
                                "Uso adequado de normas matriciais",
                                "Conexão entre teoria e prática numérica",
                                "Ausência de erros comuns listados"
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Estabilidade de algoritmos de solução de sistemas lineares",
                                "Computação Científica: Propagação de erros em multiplicações matriciais no NumPy/MATLAB",
                                "Engenharia: Análise de sensibilidade em modelos finitos (FEM)",
                                "Machine Learning: Condicionamento em matrizes de covariância para PCA"
                              ],
                              "realWorldApplication": "Em simulações numéricas (ex: CFD ou ML), avaliar cond(AB) ≤ cond(A)cond(B) previne perda de precisão ao decompor problemas em etapas matriciais, garantindo estabilidade em solvers iterativos como GMRES."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.2.2",
                            "name": "Calcular via decomposição QR",
                            "description": "Explicar como o produto dos elementos diagonais da R na decomposição QR fornece uma estimativa para cond_2(A), e implementar em pseudocódigo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Decomposição QR e sua Relação com o Número de Condição",
                                  "subSteps": [
                                    "Definir decomposição QR: Qualquer matriz A m×n com m≥n pode ser decomposta em A = QR, onde Q é ortogonal (colunas unitárias e ortogonais) e R é triangular superior.",
                                    "Revisar métodos de cálculo: Gram-Schmidt modificado (estável) e reflexões de Householder (padrão em bibliotecas).",
                                    "Entender propriedades chave: cond_2(A) = cond_2(R) pois ||Q||_2 = 1; os |r_ii| aproximam os valores singulares σ_i de A em ordem decrescente.",
                                    "Explorar a estimativa de cond_2(A): O produto ∏ |r_ii| reflete a variação geométrica dos σ_i, fornecendo uma estimativa quando combinado com normas (ex: exp( (1/n) sum log|r_ii| ) para média geométrica, contrastando com cond_2 ≈ σ_max/σ_min).",
                                    "Discutir limitações: Válido para matrizes sem pivoteamento excessivo; para precisão, usar ratios max/min |r_ii|."
                                  ],
                                  "verification": "Escrever um parágrafo explicando como QR relaciona-se a cond_2(A) e citar a propriedade do produto dos diagonais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Álgebra Linear Numérica' de Trefethen e Bau",
                                    "Notas de aula sobre QR",
                                    "Calculadora simbólica online"
                                  ],
                                  "tips": "Visualize graficamente: as colunas de Q são direções ortogonais sucessivas; |r_ii| mede o comprimento residual na i-ésima direção.",
                                  "learningObjective": "Dominar a teoria da QR e a interpretação dos diagonais de R para análise de condicionamento.",
                                  "commonMistakes": [
                                    "Confundir QR com LU (não preserva ortogonalidade)",
                                    "Ignorar que Gram-Schmidt clássico sofre cancelamento numérico",
                                    "Acreditar que ∏ |r_ii| = cond_2 exato (é apenas estimativa aproximada)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar Decomposição QR Manualmente para uma Matriz Exemplo",
                                  "subSteps": [
                                    "Escolher matriz exemplo: A = [[4, 3], [1, 1]] (cond_2(A) ≈ 5.74).",
                                    "Aplicar Gram-Schmidt modificado: Calcular q1 = a1 / ||a1||, r11 = ||a1||; r12 = q1^T a2; depois residual e2 = a2 - r12 q1, r22 = ||e2||, q2 = e2 / r22.",
                                    "Verificar: Multiplicar Q R e comparar com A (erro < 1e-10). Obter diag(R) ≈ [4.472, 0.894].",
                                    "Calcular produto inicial: P = |4.472| * |0.894| ≈ 4.0 (estimativa relacionada ao condicionamento médio).",
                                    "Comparar com SVD: σ1 ≈ 4.9, σ2 ≈ 0.85, cond_2 ≈ 5.77."
                                  ],
                                  "verification": "Apresentar QR computada, produto dos diagonais e verificação A = QR com erro numérico.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel e lápis para cálculos manuais",
                                    "Software como Python/NumPy ou MATLAB para validação (qr(A))"
                                  ],
                                  "tips": "Normalize colunas passo a passo para evitar erros de arredondamento; use precisão de 4 casas decimais inicialmente.",
                                  "learningObjective": "Executar QR na mão e observar como diag(R) revela condicionamento.",
                                  "commonMistakes": [
                                    "Esquecer de normalizar q_i após residual",
                                    "Usar Gram-Schmidt clássico sem modificação (perda de ortogonalidade)",
                                    "Não verificar Q^T Q ≈ I"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar a Propriedade do Produto dos Elementos Diagonais para Estimativa de cond_2(A)",
                                  "subSteps": [
                                    "Analisar diag(R): |r_ii| decrescentes indicam ill-conditioning se min |r_ii| << max |r_ii|.",
                                    "Derivar a estimativa: ∏ |r_ii| ≈ ∏ σ_i (produto dos singulares), útil para estimar cond_2 indiretamente via log(P)/n vs log(σ_max) + log(1/σ_min); em prática, serve como proxy para det(A) normalizado em análises.",
                                    "Interpretar numericamente: Para A acima, P ≈ 4.0; cond_2 ≈ 5.77 (estimativa grosseira via P * (max/min |r_ii|) refinada).",
                                    "Estudar casos: Matriz diagonal D=diag(1,1e-3), QR=R=D, P=1e-3, cond=1000 (P pequeno sinaliza alto cond).",
                                    "Discutir refinamentos: Estimativa melhorada cond_2 ≈ (|r_11|/|r_nn|) * fator geométrico de ∏ |r_ii|."
                                  ],
                                  "verification": "Explicar em 200 palavras como o produto estima cond_2, com exemplo numérico.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Exemplos de matrizes ill-condicionadas",
                                    "Tabela comparativa QR vs SVD"
                                  ],
                                  "tips": "Pense em ∏ |r_ii| como 'volume ortogonal'; pequeno produto implica direções fracas (alto cond).",
                                  "learningObjective": "Interpretar teoricamente o produto dos diagonais como estimador de condicionamento.",
                                  "commonMistakes": [
                                    "Confundir produto com razão max/min (razão é estimativa direta; produto é global)",
                                    "Aplicar a matrizes não quadradas sem adaptação",
                                    "Ignorar sinal dos r_ii (use absolutos)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Pseudocódigo para Cálculo da Estimativa cond_2 via Decomposição QR",
                                  "subSteps": [
                                    "Escrever pseudocódigo para QR via Gram-Schmidt modificado: Inicializar Q, R; para j=1 to n: v = a_j - Q[:,1:j-1] * (Q[:,1:j-1]^T a_j); r_jj = ||v||; q_j = v / r_jj.",
                                    "Extrair diagonais: diag_R = [R[i,i] for i=1 to n].",
                                    "Calcular estimativa: product = 1; for i=1 to n: product *= abs(diag_R[i]); estimate_cond = product * (max(abs(diag_R)) / min(abs(diag_R)))  // refinada.",
                                    "Testar com exemplo: Input A, output QR, product, estimate_cond ≈ real cond_2.",
                                    "Adicionar comentários e tratamento de casos (n=1, singular)."
                                  ],
                                  "verification": "Executar pseudocódigo em pseudolinguagem ou código real, validar com 2 matrizes (cond baixo/alto).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Editor de código (VS Code, Jupyter)",
                                    "Bibliotecas NumPy/SciPy para teste (np.linalg.qr, np.linalg.cond)"
                                  ],
                                  "tips": "Implemente vetorizado para eficiência; teste ortogonalidade de Q com ||I - Q^T Q|| < 1e-12.",
                                  "learningObjective": "Criar algoritmo acionável para estimativa prática de cond_2 via QR.",
                                  "commonMistakes": [
                                    "Não tratar divisão por zero em r_ii ≈0 (matriz singular)",
                                    "Erro de índice em loops (off-by-one em diag)",
                                    "Esquecer abs() nos diagonais"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[4, 3], [1, 1]]: QR dá Q ≈ [[0.894, 0.447], [0.447, -0.894]], R ≈ [[4.472, 3.328], [0, 0.894]]. Produto diag(R) = 4.472 * 0.894 ≈ 4.0. cond_2 real (via SVD) ≈ 5.77. A estimativa usa produto para capturar variação geométrica, refinada por max/min ≈5.0, aproximando bem.",
                              "finalVerifications": [
                                "Explica corretamente como ∏ |r_ii| relaciona-se à estimativa de cond_2(A).",
                                "Computa QR manualmente para matriz 2x2x3 com verificação A=QR.",
                                "Implementa e testa pseudocódigo produzindo estimativa coerente com SVD.",
                                "Identifica limitações (ex: pivoteamento necessário para matrizes mal-ordenadas).",
                                "Aplica a matriz ill-condicionada (ex: [[1,1],[1e-6,1e-6]]) e interpreta P pequeno como alto cond.",
                                "Compara estimativa QR com cond exato em 3 exemplos."
                              ],
                              "assessmentCriteria": [
                                "Compreensão teórica da propriedade do produto diag(R) (25%)",
                                "Precisão nos cálculos manuais de QR e produto (25%)",
                                "Corretude e completude do pseudocódigo (20%)",
                                "Qualidade da interpretação e refinamento da estimativa (15%)",
                                "Verificações e testes com exemplos variados (10%)",
                                "Clareza na documentação e avoidance de erros comuns (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Computação Científica: Algoritmos numéricos em bibliotecas como LAPACK.",
                                "Engenharia de Software: Análise de estabilidade em solvers lineares.",
                                "Data Science: Detecção de multicolinearidade em datasets.",
                                "Física Computacional: Modelos de sistemas dinâmicos lineares."
                              ],
                              "realWorldApplication": "Usado em pacotes como MATLAB (condest via QR interna) e SciPy para estimar cond_2 de matrizes grandes sem SVD custoso, crítico em otimização (ex: least squares), controle automático (estabilidade), e ML (regularização em redes neurais para evitar overfitting por ill-conditioning)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.2.3",
                            "name": "Comparar estimativas computacionais",
                            "description": "Discutir a precisão da SVD versus métodos iterativos para grandes matrizes, referenciando Golub & Van Loan.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Decomposição em Valores Singulares (SVD) para Número de Condição",
                                  "subSteps": [
                                    "Explicar o que é SVD e como ela decompõe uma matriz A = UΣV^T.",
                                    "Derivar a fórmula para o número de condição κ(A) = σ_max / σ_min usando singular values.",
                                    "Discutir estabilidade numérica da SVD em termos de precisão relativa.",
                                    "Implementar SVD em software para uma matriz pequena e calcular κ(A).",
                                    "Analisar sensibilidade a perturbações na matriz."
                                  ],
                                  "verification": "Implementar SVD em código e verificar se κ(A) coincide com valores teóricos conhecidos para matrizes de teste.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Matrix Computations' de Golub & Van Loan (Capítulo 2-3), MATLAB/Python com NumPy/SciPy, matrizes de teste (ex: Hilbert matrix).",
                                  "tips": "Use funções built-in como np.linalg.svd() para validar implementações manuais.",
                                  "learningObjective": "Compreender como SVD fornece estimativa exata e estável para κ(A).",
                                  "commonMistakes": "Confundir singular values com eigenvalues; ignorar normalização da matriz."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Métodos Iterativos para Estimativa de Número de Condição",
                                  "subSteps": [
                                    "Descrever métodos iterativos como power iteration para ||A||_2 e ||A^{-1}||_2.",
                                    "Explicar variantes como Lanczos/Arnoldi para matrizes esparsas ou grandes.",
                                    "Implementar power iteration para estimar σ_max e σ_min.",
                                    "Comparar convergência: número de iterações vs precisão.",
                                    "Referenciar seção 8.7 de Golub & Van Loan sobre estimativas iterativas."
                                  ],
                                  "verification": "Executar iterações até convergência e comparar erro relativo com SVD exata.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Golub & Van Loan (Capítulo 8), código Python/MATLAB para power iteration, matrizes grandes geradas aleatoriamente.",
                                  "tips": "Monitore norma residual para parada; use preconditioning para aceleração.",
                                  "learningObjective": "Dominar princípios de métodos iterativos e suas limitações em precisão.",
                                  "commonMistakes": "Escolher tolerância muito baixa levando a não-convergência; assumir independência de inicialização."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Precisão Teórica e Numérica entre SVD e Métodos Iterativos",
                                  "subSteps": [
                                    "Analisar teoremas de estabilidade: SVD é backward stable (Golub & Van Loan, Thm 3.1).",
                                    "Discutir erros em métodos iterativos devido a truncamento e round-off.",
                                    "Gerar matrizes grandes (n=1000+) e medir tempo/precisão para ambos.",
                                    "Plotar erro relativo vs tamanho da matriz.",
                                    "Referenciar discussões em Golub & Van Loan sobre SVD vs iterativos para cond estimado."
                                  ],
                                  "verification": "Tabela comparativa mostrando erro < 1e-10 para SVD vs >1e-6 para iterativos em matrizes mal-condicionadas.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Software com suporte a matrizes grandes (SciPy sparse), Golub & Van Loan (Capítulos 3 e 8), plots com Matplotlib.",
                                  "tips": "Use matrizes mal-condicionadas como Vandermonde para destacar diferenças.",
                                  "learningObjective": "Avaliar superioridade da SVD em precisão para matrizes grandes.",
                                  "commonMistakes": "Comparar em matrizes bem-condicionadas onde diferenças são mínimas; ignorar custo computacional."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Discussão e Aplicar em Casos Práticos",
                                  "subSteps": [
                                    "Resumir prós/cons: SVD precisa O(n^3), precisa alta; iterativos escalam melhor mas menos precisos.",
                                    "Discutir trade-offs para grandes matrizes (ex: n>10^4).",
                                    "Referenciar exemplos de Golub & Van Loan (páginas específicas sobre cond estimado).",
                                    "Testar em dataset real (ex: matriz de covariância).",
                                    "Escrever relatório comparativo."
                                  ],
                                  "verification": "Relatório de 1 página com tabelas/plots e citações corretas do livro.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Golub & Van Loan (índice para 'condition number estimation'), datasets públicos (UCI ML repo).",
                                  "tips": "Estruture como: introdução, métodos, resultados, conclusão.",
                                  "learningObjective": "Articular discussão crítica sobre escolha de método baseada em contexto.",
                                  "commonMistakes": "Generalizar de pequenos testes; omitir referências bibliográficas."
                                }
                              ],
                              "practicalExample": "Considere uma matriz de covariância 1000x1000 de dados de imagens (ex: MNIST features). Calcule κ via SVD (precisão 1e-12, tempo 10s) vs power iteration (precisão 1e-8 após 100 iterações, tempo 2s). SVD detecta ill-conditioning melhor para regularização em PCA.",
                              "finalVerifications": [
                                "Explicar com precisão por que SVD é mais estável que iterativos em teoria.",
                                "Implementar ambos e mostrar plots de erro vs n para matrizes randn(n).",
                                "Citar seções específicas de Golub & Van Loan suportando a comparação.",
                                "Discutir quando usar cada método em matrizes grandes.",
                                "Identificar limitações computacionais para n>10^5."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática (SVD vs iterativos): 25%.",
                                "Qualidade de implementações numéricas e plots: 25%.",
                                "Referenciação correta a Golub & Van Loan: 20%.",
                                "Análise crítica de trade-offs (precisão vs custo): 20%.",
                                "Clareza na discussão e relatório: 10%."
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Algoritmos numéricos e complexidade (O(n^3) vs O(n k)).",
                                "Estatística: Análise de dados multivariados e detecção de multicolinearidade.",
                                "Engenharia: Simulações em sistemas lineares (controle, processamento de sinais).",
                                "Física Computacional: Modelagem de sistemas com matrizes grandes (FEM)."
                              ],
                              "realWorldApplication": "Em machine learning, avaliar cond number de matrizes de features para evitar overfitting em regressão; SVD preferida em pré-processamento de dados de alta dimensão como genômica, onde precisão é crítica apesar do custo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.3",
                        "name": "Interpretação como Medida de Sensibilidade",
                        "description": "Interpreta o número de condição no contexto de estabilidade numérica, especialmente para soluções de sistemas lineares Ax = b.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.3.1",
                            "name": "Interpretar sensibilidade em sistemas lineares",
                            "description": "Derivar o bound |δx / x| ≤ cond(A) * |δb / b| para perturbações em b, e similar para perturbações em A, com análise relativa de erros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definição e propriedades do número de condição cond(A)",
                                  "subSteps": [
                                    "Defina cond(A) = ||A|| * ||A^{-1}|| para uma norma matricial consistente.",
                                    "Explique que cond(A) ≥ 1 e mede a amplificação de erros.",
                                    "Calcule cond(A) para uma matriz simples usando norma 2 ou infinito.",
                                    "Discuta propriedades: cond(A) = 1 se A ortogonal; cresce com il-condicionamento.",
                                    "Compare cond(A) para matrizes bem e mal condicionadas."
                                  ],
                                  "verification": "Calcule cond(A) para pelo menos duas matrizes diferentes e interprete os valores.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora matricial ou software como MATLAB/Octave/Python (NumPy), notas de aula sobre normas.",
                                  "tips": "Use norma 2 para simplicidade em matrizes simétricas.",
                                  "learningObjective": "Compreender cond(A) como medida de sensibilidade inerente do sistema.",
                                  "commonMistakes": "Confundir cond(A) com det(A); esquecer que é sempre ≥1."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar e derivar bound para perturbações em b",
                                  "subSteps": [
                                    "Considere Ax = b, com perturbação b + δb levando a A(x + δx) = b + δb.",
                                    "Subtraia equações: A δx = δb, então δx = A^{-1} δb.",
                                    "Tome normas: ||δx|| ≤ ||A^{-1}|| ||δb||.",
                                    "Divida por normas originais: ||δx|| / ||x|| ≤ (||A|| ||A^{-1}||) (||δb|| / ||b||) = cond(A) * (||δb|| / ||b||).",
                                    "Escreva a forma relativa: |δx / x| ≤ cond(A) * |δb / b| (notação aproximada)."
                                  ],
                                  "verification": "Derive o bound passo a passo em papel e verifique com uma matriz 2x2 numérica.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e lápis, software para resolver sistemas lineares.",
                                  "tips": "Mantenha consistência na norma usada em todas as desigualdades.",
                                  "learningObjective": "Derivar matematicamente o bound de erro relativo para δb.",
                                  "commonMistakes": "Esquecer de dividir por ||x|| e ||b|| para obter erro relativo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar bound para perturbações em A",
                                  "subSteps": [
                                    "Considere (A + δA)(x + δx) = b, aproximando δA pequeno.",
                                    "Expanda e ignore termos quadráticos: A δx + δA x ≈ 0, então δx ≈ -A^{-1} δA x.",
                                    "Tome normas: ||δx|| ≤ ||A^{-1}|| ||δA|| ||x||.",
                                    "Relativo: ||δx|| / ||x|| ≤ cond(A) (||δA|| / ||A||).",
                                    "Compare com bound para δb, notando dependência em ||x||."
                                  ],
                                  "verification": "Escreva a derivação completa e teste numericamente com δA pequeno.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software numérico para perturbar A e medir erros.",
                                  "tips": "Use aproximação de primeiro ordem válida para ||δA|| pequeno.",
                                  "learningObjective": "Entender como perturbações em A propagam erros semelhantes, mas dependentes de x.",
                                  "commonMistakes": "Ignorar termo δA δx na expansão; usar norma absoluta em vez de relativa."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar sensibilidade e analisar erros relativos",
                                  "subSteps": [
                                    "Explique que cond(A) amplifica erros de entrada em até cond(A) vezes no output.",
                                    "Discuta: se cond(A) = 10^6, erros são amplificados 1 milhão de vezes.",
                                    "Compare bounds para δb vs δA: ambos limitados por cond(A) * erro relativo de entrada.",
                                    "Analise impacto em precisão numérica (e.g., floating-point).",
                                    "Conclua: prefira matrizes bem condicionadas para estabilidade."
                                  ],
                                  "verification": "Interprete resultados de um exemplo onde cond(A) alto causa grande erro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Exemplos numéricos de steps anteriores.",
                                  "tips": "Pense em cond(A) como 'fator de amplificação máxima'.",
                                  "learningObjective": "Interpretar bounds como medida prática de sensibilidade.",
                                  "commonMistakes": "Confundir sensibilidade com precisão absoluta; ignorar erros relativos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar em exemplos numéricos e sintetizar",
                                  "subSteps": [
                                    "Escolha matriz bem condicionada (cond≈1) e mal condicionada (cond>100).",
                                    "Perturbe b e A, meça erros reais vs bounds previstos.",
                                    "Compare ||δx/x|| / ||δb/b|| ≈ cond(A)?",
                                    "Registre observações sobre quando bound é apertado.",
                                    "Sintetize: interpretação em contextos computacionais."
                                  ],
                                  "verification": "Gere relatório com tabelas de erros medidos vs bounds.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python/MATLAB com NumPy/SciPy para cond, solve e normas.",
                                  "tips": "Use np.linalg.cond() para cálculo rápido.",
                                  "learningObjective": "Validar teoricamente com prática numérica.",
                                  "commonMistakes": "Escolher matrizes singulares; perturbações δ muito grandes."
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 1], [1, 1+eps]] com eps=1e-6 (mal condicionada, cond(A)≈1e6). Resolva Ax=b com b=[2,2+1e-6]. Perturbe b por 1e-10: erro relativo em x amplificado ~1e6 vezes, matching o bound.",
                              "finalVerifications": [
                                "Deriva corretamente ambos os bounds relativos.",
                                "Calcula cond(A) e interpreta seu valor.",
                                "Simula numericamente e confirma amplificação por cond(A).",
                                "Distingue perturbações em b vs A.",
                                "Explica impacto em precisão computacional.",
                                "Identifica quando sistema é 'sensível' (cond>10^4)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática (100% dos passos corretos).",
                                "Correta interpretação qualitativa dos bounds.",
                                "Exemplos numéricos mostram bound válido (erro ≤ predicted).",
                                "Uso consistente de normas relativas.",
                                "Síntese clara de sensibilidade como cond(A) * erro_input.",
                                "Identificação de limitações (e.g., aproximações)."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Estabilidade numérica em solvers lineares (SciPy, LAPACK).",
                                "Física: Modelagem de sistemas com ruído (e.g., equações diferenciais discretizadas).",
                                "Engenharia: Análise de estruturas finitas (matrizes de rigidez mal condicionadas).",
                                "Estatística: Regressão linear e multicolinearidade (cond(X) alto)."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, matrizes de massa/rigidez em FEM podem ter cond(A)>10^12; análise de sensibilidade guia refinamento de malha para evitar falhas catastróficas por erros de arredondamento."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.3.2",
                            "name": "Analisar exemplos numéricos de sensibilidade",
                            "description": "Resolver numericamente Ax = b com A mal-condicionada (ex: Hilbert matrix), medindo amplificação de erros e comparando com cond(A).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Gerar matriz mal-condicionada (ex: Matriz de Hilbert)",
                                  "subSteps": [
                                    "Escolha o tamanho n da matriz (ex: n=5 para Hilbert).",
                                    "Implemente a função para gerar a matriz de Hilbert H onde H_ij = 1/(i+j-1).",
                                    "Verifique as propriedades da matriz gerada (simetria, positividade definida).",
                                    "Calcule o número de condição cond(H) usando decomposição SVD ou norma.",
                                    "Salve a matriz em formato acessível para uso posterior."
                                  ],
                                  "verification": "Matriz gerada corretamente e cond(H) > 10^10 para n=5.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python com NumPy e SciPy (np.linalg.cond).",
                                  "tips": "Use np.hilbert(n) se disponível, senão implemente manualmente para compreensão.",
                                  "learningObjective": "Entender como gerar matrizes clássicas mal-condicionadas.",
                                  "commonMistakes": "Índices errados na fórmula de Hilbert (começa em 1, não 0)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Resolver o sistema Ax = b exato",
                                  "subSteps": [
                                    "Defina vetor b como um vetor de ones (b = np.ones(n)).",
                                    "Resolva Hx = b usando decomposição LU ou QR para precisão.",
                                    "Calcule a solução exata x_exato usando precisão simbólica se possível (SymPy).",
                                    "Compare x numérico com x exato para validar.",
                                    "Registre resíduos ||Hx - b||."
                                  ],
                                  "verification": "Resíduo pequeno (<<1e-10) e solução converge.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python NumPy, SciPy (scipy.linalg.solve), SymPy opcional.",
                                  "tips": "Prefira solve em vez de inversa para estabilidade.",
                                  "learningObjective": "Aplicar solvers diretos em matrizes mal-condicionadas.",
                                  "commonMistakes": "Usar inversa de matriz (amplifica erros desnecessariamente)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir perturbação e resolver novamente",
                                  "subSteps": [
                                    "Gere perturbação δb com norma relativa ε = 1e-6 (δb = ε * np.random.randn(n)).",
                                    "Defina b_pert = b + δb.",
                                    "Resolva Hx_pert = b_pert obtendo x_pert.",
                                    "Calcule erro relativo na solução: ||x_pert - x_exato|| / ||x_exato||.",
                                    "Registre o erro relativo em b: ||δb|| / ||b||."
                                  ],
                                  "verification": "Erro em b é aproximadamente ε, e x_pert difere visivelmente de x.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python NumPy para randn e normas (np.linalg.norm).",
                                  "tips": "Use semente randômica fixa para reprodutibilidade (np.random.seed(42)).",
                                  "learningObjective": "Simular propagação de erros de entrada para saída.",
                                  "commonMistakes": "Norma errada (use norma 2, não inf)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar amplificação de erros e comparar com cond(A)",
                                  "subSteps": [
                                    "Calcule a razão de amplificação: erro_rel_x / erro_rel_b.",
                                    "Compare com cond(H) teórico.",
                                    "Repita para diferentes ε (1e-8, 1e-4) e observe limite.",
                                    "Plote gráficos de log(erros) vs log(ε) para visualização.",
                                    "Interprete: se razão ≈ cond(A), confirma sensibilidade."
                                  ],
                                  "verification": "Razão de amplificação próxima a cond(H) dentro de fator 10.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python Matplotlib para plots.",
                                  "tips": "Log-log plot destaca o regime linear onde ||δx||/||x|| ≈ cond(A) * ||δb||/||b||.",
                                  "learningObjective": "Interpretar numericamente o teorema de sensibilidade.",
                                  "commonMistakes": "Ignorar regime de ε muito pequeno (subtraição catastrófica)."
                                }
                              ],
                              "practicalExample": "Para n=5, H = hilbert(5), b=ones(5). Solução exata x≈[1.408,0.056,-1.408,...]. Perturbe b com ε=1e-6, observe ||δx||/||x|| ≈ 10^12 * 1e-6 = 10^6, compatível com cond(H)≈10^12.",
                              "finalVerifications": [
                                "cond(A) calculado corretamente e elevado (>10^10).",
                                "Erro relativo em x amplificado por fator próximo a cond(A).",
                                "Gráficos mostram relação linear em escala log-log.",
                                "Interpretação escrita relaciona exemplo ao teorema de sensibilidade.",
                                "Testes com múltiplos ε confirmam consistência.",
                                "Resíduos pequenos em ambas resoluções."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos (erros <1%).",
                                "Correta implementação de Hilbert e solvers.",
                                "Análise qualitativa e quantitativa da amplificação.",
                                "Uso apropriado de normas e condições.",
                                "Visualizações claras e interpretadas.",
                                "Relatório conciso com conclusões."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica (implementação em Python/NumPy).",
                                "Análise Numérica (estabilidade de algoritmos).",
                                "Engenharia (modelagem de sistemas físicos mal-condicionados).",
                                "Estatística (propagação de incertezas)."
                              ],
                              "realWorldApplication": "Em engenharia civil para análise de estruturas (matrizes de rigidez mal-condicionadas), finanças para otimização de portfólios e machine learning para inversão de matrizes de covariância em dados ruidosos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.3.3",
                            "name": "Relacionar com quadrados mínimos e métodos iterativos",
                            "description": "Explicar como alto cond(A) afeta a convergência de métodos como gradiente conjugado e a sensibilidade em problemas de mínimos quadrados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Número de Condição e Mínimos Quadrados",
                                  "subSteps": [
                                    "Defina o número de condição cond(A) como a razão entre o maior e menor valor singular de A.",
                                    "Explique mínimos quadrados como minimizar ||Ax - b||_2 para sistemas superdeterminados.",
                                    "Discuta como cond(A) alto implica amplificação de erros em soluções aproximadas.",
                                    "Calcule cond(A) para uma matriz 2x2 simples usando SVD.",
                                    "Compare soluções exatas vs aproximadas em um exemplo numérico."
                                  ],
                                  "verification": "Resolva um problema de mínimos quadrados simples e verifique se cond(A) > 10^6 indica ill-conditioning.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora científica ou Python (NumPy, SciPy); notas de aula sobre SVD.",
                                  "tips": "Use log10(cond(A)) para interpretar: >10 é moderado, >16 é severo.",
                                  "learningObjective": "Compreender a base matemática de cond(A) e sua relação inicial com mínimos quadrados.",
                                  "commonMistakes": "Confundir cond(A) com det(A) ou norm(A); ignorar pseudoinversa em sistemas não quadrados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Sensibilidade em Problemas de Mínimos Quadrados",
                                  "subSteps": [
                                    "Estude a fórmula de erro relativo: ||δx|| / ||x|| ≤ cond(A) * ||δb|| / ||b||.",
                                    "Gere matrizes A bem e mal condicionadas (ex: Hilbert matrix).",
                                    "Resolva mínimos quadrados para ambas e compare erros com ruído em b.",
                                    "Plote resíduos vs cond(A) para visualizar sensibilidade.",
                                    "Discuta regularização (ex: ridge) como mitigação."
                                  ],
                                  "verification": "Demonstre que perturbando b em 1%, o erro em x cresce proporcionalmente a cond(A).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python/MATLAB com NumPy/SciPy para SVD e lsqr; matrizes de teste pré-definidas.",
                                  "tips": "Use np.linalg.cond() para cálculos rápidos; normalize vetores para comparações justas.",
                                  "learningObjective": "Quantificar como alto cond(A) amplifica erros em soluções de mínimos quadrados.",
                                  "commonMistakes": "Usar norma euclidiana sem normalizar; esquecer de considerar ruído relativo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Impacto na Convergência de Métodos Iterativos como Gradiente Conjugado",
                                  "subSteps": [
                                    "Revise o gradiente conjugado (CG) para Ax = b, com taxa de convergência ~ (sqrt(k)-1)/(sqrt(k)+1) onde k=cond(A).",
                                    "Implemente CG em Python para matrizes com cond(A) baixo/alto.",
                                    "Meça iterações até convergência e residual.",
                                    "Analise eigenvalues de A e distribuição para entender lentidão em cond alto.",
                                    "Compare com GMRES ou outros iterativos."
                                  ],
                                  "verification": "Execute CG em A com cond(A)=10 vs 10^8; confirme que alto cond requer >10x mais iterações.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "SciPy.sparse.linalg.cg; matrizes esparsas geradas (ex: poisson matrix).",
                                  "tips": "Pré-condicione com diagonal de A para melhorar; monitore ||r_k||_2.",
                                  "learningObjective": "Relacionar cond(A) diretamente à velocidade de convergência em CG e iterativos.",
                                  "commonMistakes": "Aplicar CG a matrizes densas sem sparse; ignorar simetria positiva definida."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Conceitos e Aplicar em Exemplos Práticos",
                                  "subSteps": [
                                    "Resuma: alto cond(A) → sensibilidade em LS e convergência lenta em iterativos.",
                                    "Resolva um problema combinado: LS com CG para grande sistema mal condicionado.",
                                    "Avalie trade-offs: direto (QR) vs iterativo com pré-condicionador.",
                                    "Discuta escolhas algorítmicas baseadas em cond(A).",
                                    "Crie relatório com gráficos de erro/convergência."
                                  ],
                                  "verification": "Gere relatório mostrando impacto quantitativo em um caso realista.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Jupyter Notebook; bibliotecas SciPy/NumPy; dados de exemplo (ex: image deblurring).",
                                  "tips": "Use cond estimado via Lanczos para matrizes grandes; foque em exemplos 100x100+.",
                                  "learningObjective": "Sintetizar relações entre cond(A), LS e iterativos para decisões computacionais.",
                                  "commonMistakes": "Generalizar de 2D para high-dim sem escalabilidade; negligenciar custo computacional."
                                }
                              ],
                              "practicalExample": "Em processamento de imagens, resolva mínimos quadrados para deblurring (A é matriz de convolução blur, cond(A)~10^12). Alto cond causa artefatos sensíveis a ruído; CG converge em >1000 iterações vs <50 com pré-condicionador.",
                              "finalVerifications": [
                                "Calcule cond(A) corretamente via SVD para pelo menos 3 matrizes.",
                                "Demonstre erro amplificado em LS com δb pequeno.",
                                "Execute CG e reporte iterações vs cond(A).",
                                "Explique verbalmente o impacto em convergência.",
                                "Aplique regularização e compare resultados.",
                                "Crie gráfico de residual decay para CG."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e cálculo de cond(A) (30%).",
                                "Análise quantitativa de sensibilidade em LS (25%).",
                                "Compreensão e simulação de convergência em CG (25%).",
                                "Integração conceitual e exemplos (10%).",
                                "Clareza em relatórios/gráficos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Algoritmos numéricos e otimização.",
                                "Física: Modelagem de sistemas dinâmicos com matrizes mal condicionadas.",
                                "Engenharia: Análise finita de elementos (FEM) em simulações.",
                                "Machine Learning: Regressão linear e condicionamento em dados."
                              ],
                              "realWorldApplication": "Em machine learning, alto cond em matrizes de covariância causa overfitting em regressão; em engenharia aeroespacial, afeta precisão de simulações CFD onde CG é usado para solvers de grande escala, exigindo pré-condicionadores para convergência viável."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.2",
                    "name": "Sensibilidade de Soluções de Sistemas Lineares",
                    "description": "Análise de perturbações em A e b e seu impacto nas soluções de Ax = b.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.2.1",
                        "name": "Número de Condição e Condicionamento de Matrizes",
                        "description": "Definição do número de condição κ(A) = ||A|| ⋅ ||A⁻¹|| para diferentes normas matriciais e seu papel como medida de sensibilidade de soluções de sistemas lineares Ax = b a perturbações pequenas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.1.1",
                            "name": "Calcular o número de condição usando normas 2 e ∞",
                            "description": "Computar κ₂(A) e κ∞(A) para matrizes dadas, utilizando decomposição SVD para norma 2 e inversão direta para norma ∞, interpretando valores altos como indicativos de ill-condicionamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições de normas de matriz e número de condição",
                                  "subSteps": [
                                    "Defina a norma ∞ de uma matriz A como a soma máxima absoluta dos elementos de uma linha: ||A||_∞ = max_i Σ_j |a_ij|.",
                                    "Defina a norma 2 de uma matriz A como a maior singular value obtida via decomposição SVD: ||A||_2 = σ_max.",
                                    "Explique o número de condição κ_p(A) = ||A||_p * ||A^{-1}||_p e sua relação com ill-condicionamento quando κ é grande.",
                                    "Discuta por que κ mede sensibilidade de soluções de sistemas lineares Ax=b.",
                                    "Liste exemplos de matrizes bem e mal condicionadas."
                                  ],
                                  "verification": "Resuma as definições em um parágrafo e identifique uma matriz mal condicionada de exemplo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Referência: Livro de Álgebra Linear Numérica (ex: Golub & Van Loan)"
                                  ],
                                  "tips": "Use exemplos 2x2 para visualizar; memorize fórmulas chave.",
                                  "learningObjective": "Compreender conceitualmente normas 2, ∞ e número de condição.",
                                  "commonMistakes": [
                                    "Confundir norma de vetor com norma de matriz",
                                    "Ignorar que κ requer A^{-1}",
                                    "Esquecer que SVD é para norma 2"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular κ_∞(A) via normas ∞ de A e A^{-1}",
                                  "subSteps": [
                                    "Dada matriz A, compute ||A||_∞ somando absolutos por linha e pegando o máximo.",
                                    "Calcule a inversa A^{-1} usando fórmula analítica para 2x2 ou método de Gauss-Jordan.",
                                    "Compute ||A^{-1}||_∞ da mesma forma.",
                                    "Multiplique ||A||_∞ * ||A^{-1}||_∞ para obter κ_∞(A).",
                                    "Verifique se A é invertível (det(A) ≠ 0)."
                                  ],
                                  "verification": "Apresente cálculos passo a passo para uma matriz exemplo e confira κ_∞.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software Python com NumPy (np.linalg.inv)",
                                    "Matriz exemplo impressa"
                                  ],
                                  "tips": "Para matrizes pequenas, faça à mão; valide com código para precisão.",
                                  "learningObjective": "Dominar cálculo prático de κ_∞.",
                                  "commonMistakes": [
                                    "Erro na inversão manual",
                                    "Não usar valores absolutos nas somas",
                                    "Esquecer verificação de singularidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular κ_2(A) via decomposição SVD",
                                  "subSteps": [
                                    "Execute SVD de A: A = U Σ V^H, onde Σ tem singular values σ1 ≥ σ2 ≥ ... ≥ 0.",
                                    "Identifique σ_max = σ1 (maior diagonal de Σ) para ||A||_2.",
                                    "Calcule ||A^{-1}||_2 = 1 / σ_min (menor singular value não-zero).",
                                    "Compute κ_2(A) = σ_max / σ_min.",
                                    "Confirme com software: np.linalg.svd(A, compute_uv=False) para singular values."
                                  ],
                                  "verification": "Compare κ_2 computado manualmente/software com valor esperado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Documentação SVD online"
                                  ],
                                  "tips": "SVD é numericamente estável; use full_matrices=False para eficiência.",
                                  "learningObjective": "Aplicar SVD para norma 2 e κ_2.",
                                  "commonMistakes": [
                                    "Confundir σ_max com σ_min",
                                    "Não condicionar para matrizes não quadradas",
                                    "Ignorar ordenação decrescente das σ"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e avaliar condicionamento",
                                  "subSteps": [
                                    "Compare κ_2 e κ_∞: note que κ_2 ≤ κ_∞ ≤ n κ_2 para matriz nxn.",
                                    "Classifique: κ < 10^3 bem condicionado; >10^6 mal condicionado.",
                                    "Discuta implicações: erro relativo em x ≈ κ * erro relativo em b.",
                                    "Teste com perturbação: resolva Ax=b e Ax=(b+δb), compare erros.",
                                    "Documente achados em relatório curto."
                                  ],
                                  "verification": "Interprete κ para matriz exemplo e prediga sensibilidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código Python para simulação de perturbação",
                                    "Gráfico de erros"
                                  ],
                                  "tips": "Use log10(κ) para escala; sempre normalize matrizes se necessário.",
                                  "learningObjective": "Interpretar κ como métrica de estabilidade numérica.",
                                  "commonMistakes": [
                                    "Interpretar κ pequeno como sempre bom (depende de contexto)",
                                    "Não considerar máquina epsilon",
                                    "Ignorar diferenças entre normas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[1, 0.999], [0.999, 1]], compute ||A||_∞ ≈ 1.999, A^{-1} ≈ [[1.001, -1], [-1, 1.001]] approx, ||A^{-1}||_∞ ≈ 2.001, κ_∞ ≈ 4. Para SVD, σ1 ≈ 1.999, σ2 ≈ 0.001, κ_2 ≈ 2000, indicando ill-condicionamento.",
                              "finalVerifications": [
                                "κ_∞ e κ_2 calculados corretamente para matriz exemplo.",
                                "SVD executado e singular values identificados.",
                                "Interpretação coerente com valores (alto κ = ill-condicionado).",
                                "Código Python reproduz resultados analíticos.",
                                "Perturbação numérica confirma sensibilidade predita.",
                                "Relatório resume passos e conclusões."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de normas e inversa (erro < 1e-10).",
                                "Correta aplicação de SVD e extração de σ_max/σ_min.",
                                "Interpretação qualitativa e quantitativa de condicionamento.",
                                "Uso eficiente de ferramentas computacionais.",
                                "Identificação de erros comuns evitados.",
                                "Clareza na documentação de passos."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em Python/MATLAB.",
                                "Análise Numérica: Estabilidade em solvers de sistemas lineares.",
                                "Física Computacional: Modelagem de sistemas dinâmicos sensíveis.",
                                "Engenharia: Análise de estruturas e controle.",
                                "Estatística: Regressão linear e multicolinearidade."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, avalia estabilidade de modelos finitos elemento; em finanças, condicionamento em otimização de portfólios; em ML, evita overfitting em regressão via detecção de features correlacionadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.2",
                            "name": "Interpretar o impacto do condicionamento na precisão numérica",
                            "description": "Analisar como κ(A) amplifica erros relativos nas soluções, com limite superior ||δx||/||x|| ≤ κ(A) ⋅ (||δA||/||A|| + ||δb||/||b||), usando exemplos matriciais simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de número de condição κ(A)",
                                  "subSteps": [
                                    "Defina o número de condição κ(A) = ||A|| ⋅ ||A⁻¹|| para uma matriz invertível A.",
                                    "Explique que κ(A) quantifica a sensibilidade da matriz a pequenas perturbações.",
                                    "Discuta que κ(A) ≥ 1 sempre, com κ(A) = 1 para matrizes perfeitamente condicionadas como a identidade.",
                                    "Calcule κ(A) usando norma 2 para matrizes simples, como A identidade 2x2.",
                                    "Compare com uma matriz mal condicionada, como a matriz de Hilbert 2x2."
                                  ],
                                  "verification": "Calcule κ(A) para duas matrizes (bem e mal condicionadas) e interprete os valores obtidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Software como Python (NumPy) ou MATLAB",
                                    "Matrizes de exemplo impressas"
                                  ],
                                  "tips": "Sempre use a mesma norma para ||A|| e ||A⁻¹|| para consistência.",
                                  "learningObjective": "Dominar a definição e interpretação do número de condição como medida de sensibilidade.",
                                  "commonMistakes": "Confundir κ(A) com o determinante; lembrar que é produto de normas, não razão."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a propagação de erros em sistemas lineares Ax = b",
                                  "subSteps": [
                                    "Considere perturbações pequenas δA em A e δb em b, resultando em solução perturbada x + δx.",
                                    "Estabeleça as equações perturbadas: (A + δA)(x + δx) = b + δb.",
                                    "Derive intuitivamente que erros relativos em x são amplificados por fatores relacionados a A⁻¹.",
                                    "Introduza a aproximação ||δx||/||x|| ≈ κ(A) ⋅ (||δA||/||A|| + ||δb||/||b||).",
                                    "Ilustre com diagrama de fluxo de erros de entrada para saída."
                                  ],
                                  "verification": "Descreva por escrito ou verbalmente como κ(A) atua como fator de amplificação de erros.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Folha de papel para derivações",
                                    "Software de álgebra linear (NumPy.linalg)",
                                    "Exemplos de matrizes perturbadas"
                                  ],
                                  "tips": "Pense em termos relativos para normalizar escalas diferentes entre matrizes.",
                                  "learningObjective": "Entender o mecanismo de propagação de erros relativos nas soluções.",
                                  "commonMistakes": "Ignorar termos relativos; sempre divida por ||x||, ||A|| etc."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar o limite superior rigoroso da amplificação de erros",
                                  "subSteps": [
                                    "Apresente a desigualdade exata: ||δx||/||x|| ≤ κ(A) ⋅ (||δA||/||A|| + ||δb||/||b||).",
                                    "Derive os passos principais da prova usando desigualdades de normas (triangular e submultiplicativa).",
                                    "Discuta condições para que a bound seja apertada (perturbações alinhadas com autovetores).",
                                    "Calcule numericamente para uma matriz 2x2, variando δA e δb pequenos.",
                                    "Analise o pior caso: quando κ(A) é grande, erros explodem."
                                  ],
                                  "verification": "Derive ou reproduza a fórmula limite e aplique a um exemplo numérico simples.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Livro de Álgebra Numérica (opcional)",
                                    "Python ou MATLAB para simulações",
                                    "Tabela para registrar bounds"
                                  ],
                                  "tips": "Use norma 2 para facilitar cálculos com valores singulares.",
                                  "learningObjective": "Dominar a bound teórica e sua interpretação prática.",
                                  "commonMistakes": "Esquecer o fator ≤ (é uma upper bound, não igualdade exata)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a análise em exemplos matriciais simples",
                                  "subSteps": [
                                    "Selecione A bem condicionada (ex: diagonal [[2,0],[0,3]]), resolva Ax=b exato.",
                                    "Aplique perturbações relativas de 10^{-6} em A e b, resolva o perturbado.",
                                    "Calcule erros relativos e verifique se ≤ κ(A) * erros de entrada.",
                                    "Repita com A mal condicionada (Hilbert 3x3), observe amplificação.",
                                    "Registre em tabela: κ(A), erros entrada, erros saída, bound."
                                  ],
                                  "verification": "Produza tabela com 4 cenários mostrando validação da fórmula em prática.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código Python pronto com numpy.solve e linalg.cond",
                                    "Planilha Excel para tabelas"
                                  ],
                                  "tips": "Use perturbações aleatórias pequenas para realismo; rode múltiplas vezes.",
                                  "learningObjective": "Aplicar a teoria em experimentos numéricos concretos.",
                                  "commonMistakes": "Usar perturbações grandes; mantenha < máquina epsilon para linearidade."
                                }
                              ],
                              "practicalExample": "Para A = [[1, 0], [0, 1]] (κ(A)=1), b=[1,2], x=[1,2]. Perturbe b para [1+10^{-6}, 2-10^{-6}], erro relativo em b ≈5e-7. Erro em x ≈5e-7, sem amplificação. Agora A Hilbert 2x2 ≈[[1,0.5],[0.5,0.25]], κ(A)≈6. Erro em x amplifica para ~3e-6, validando a bound.",
                              "finalVerifications": [
                                "Calcula corretamente κ(A) e interpreta seu valor.",
                                "Deriva ou reproduz a fórmula de bound de erro relativa.",
                                "Aplica a análise a matrizes 2x2/3x3 com perturbações.",
                                "Identifica sistemas mal condicionados e prevê sensibilidade.",
                                "Explica limitações (ex: normas específicas, perturbações pequenas).",
                                "Valida numericamente a bound em pelo menos dois exemplos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na definição e cálculo de κ(A).",
                                "Correção na derivação e aplicação da bound de erro.",
                                "Qualidade dos exemplos numéricos e tabelas de resultados.",
                                "Profundidade na interpretação do papel amplificador de κ(A).",
                                "Clareza e organização na apresentação de análises.",
                                "Identificação correta de erros comuns e limitações."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Uso de numpy.linalg.cond em Python para análise prática.",
                                "Engenharia Computacional: Estabilidade em métodos de elementos finitos (FEM).",
                                "Machine Learning: Condicionamento de Hessianas em otimização.",
                                "Física Computacional: Propagação de erros em simulações de dinâmica molecular."
                              ],
                              "realWorldApplication": "Na engenharia estrutural, matrizes de rigidez mal condicionadas amplificam erros de medição em sensores, podendo levar a falhas em pontes ou aviões. Análise de condição garante precisão em simulações antes da fabricação."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.3",
                            "name": "Relacionar SVD ao número de condição",
                            "description": "Usar a decomposição em valores singulares A = UΣVᵀ para obter κ₂(A) = σ_max / σ_min, identificando singularidades próximas como causa de alta sensibilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os fundamentos da Decomposição em Valores Singulares (SVD)",
                                  "subSteps": [
                                    "Lembre-se da forma SVD: A = U Σ Vᵀ, onde U e V são ortogonais e Σ é diagonal com valores singulares σ₁ ≥ σ₂ ≥ ... ≥ σ_n ≥ 0.",
                                    "Entenda que os valores singulares representam a 'força' das direções principais de alongamento da matriz A.",
                                    "Pratique decompor uma matriz simples 2x2 manualmente ou com software para visualizar U, Σ e V.",
                                    "Identifique que σ_max é o maior valor singular e σ_min o menor não-nulo."
                                  ],
                                  "verification": "Decompor corretamente uma matriz exemplo e listar os valores singulares em ordem decrescente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora científica, software como Python (NumPy) ou MATLAB, notas de aula sobre SVD.",
                                  "tips": "Sempre normalize as colunas de U e V para verificar ortogonalidade (UUᵀ = I).",
                                  "learningObjective": "Compreender a estrutura da SVD e o papel dos valores singulares.",
                                  "commonMistakes": "Confundir valores singulares com autovalores; lembre-se que SVD é para qualquer matriz, não só quadrada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair os valores singulares da matriz Σ",
                                  "subSteps": [
                                    "Após computar SVD de A, isole a matriz Σ diagonal.",
                                    "Ordene os elementos da diagonal: σ₁ (maior) até σ_r (rank), com zeros após.",
                                    "Identifique σ_max = σ₁ e σ_min = σ_r (menor não-zero).",
                                    "Registre os valores para uma matriz de teste.",
                                    "Compare com normas da matriz: ||A||₂ = σ_max e ||A⁻¹||₂ ≈ 1/σ_min."
                                  ],
                                  "verification": "Listar corretamente σ_max e σ_min para uma matriz dada via SVD.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software NumPy/Python ou Octave para SVD, papel e lápis para matrizes pequenas.",
                                  "tips": "Use np.linalg.svd() no Python para automação rápida.",
                                  "learningObjective": "Extrair e interpretar os valores singulares de Σ.",
                                  "commonMistakes": "Ignorar zeros em Σ para matrizes singulares; foque no menor não-zero para condicionamento."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o número de condição κ₂(A)",
                                  "subSteps": [
                                    "Aplique a fórmula: κ₂(A) = ||A||₂ ||A⁻¹||₂ = σ_max / σ_min.",
                                    "Compute σ_max / σ_min numericamente.",
                                    "Verifique com norma 2 direta se possível.",
                                    "Classifique: κ ≈ 1 (bem condicionado), κ > 10¹⁶ (ill-condicionado).",
                                    "Calcule para múltiplas matrizes variando σ_min."
                                  ],
                                  "verification": "Obter κ₂ exato ou aproximado igual ao de σ_max/σ_min para exemplo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python com NumPy (svd e np.linalg.cond), exemplos de matrizes.",
                                  "tips": "Para matrizes grandes, SVD é mais estável que inversa direta.",
                                  "learningObjective": "Dominar o cálculo de κ₂ via SVD.",
                                  "commonMistakes": "Usar σ_min = 0 para singulares; defina como menor não-zero ou inf."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar κ₂ em termos de sensibilidade e singularidades próximas",
                                  "subSteps": [
                                    "Relacione alta κ₂ (σ_max >> σ_min) a singularidades próximas: A quase singular.",
                                    "Explique sensibilidade: pequenas perturbações em A causam grandes erros em x = A⁻¹b.",
                                    "Simule: adicione ruído ε a A e observe variação em solução.",
                                    "Conclua que SVD revela direções sensíveis (próximas a σ_min).",
                                    "Discuta mitigação: regularização ou preconditioning."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito como SVD identifica causas de ill-conditioning.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Código Python para simulação de perturbações, gráficos de erro vs. κ.",
                                  "tips": "Plote σ_i em log para visualizar gap entre σ_max e σ_min.",
                                  "learningObjective": "Relacionar SVD-κ₂ à análise de sensibilidade prática.",
                                  "commonMistakes": "Atribuir ill-conditioning só a dimensões altas; SVD mostra causa espectral."
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 1], [1, 1+ε]] com ε=10^{-6}. SVD dá σ_max ≈ √2, σ_min ≈ ε/√2, κ₂ ≈ 2/ε = 2×10^6. Perturbe b=[1,1]ᵀ por 10^{-8}, observe erro em x amplificado por κ₂, demonstrando sensibilidade devido a singularidade próxima.",
                              "finalVerifications": [
                                "Computar SVD e κ₂ corretamente para matriz 3x3 ill-condicionada.",
                                "Explicar por que σ_min pequeno implica alta sensibilidade.",
                                "Simular perturbação e quantificar amplificação de erro ≈ κ₂ × rel.err(b).",
                                "Identificar direções singulares via V correspondente a σ_min.",
                                "Comparar κ₂ via SVD vs. norma direta, com tolerância 1e-10."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de σ_max/σ_min (erro < 1e-12).",
                                "Interpretação correta de κ₂ > 10^8 como ill-condicionado.",
                                "Simulação numérica reproduzindo bound de erro de sensibilidade.",
                                "Uso apropriado de SVD para evitar instabilidade numérica.",
                                "Explicação clara ligando singularidades próximas a aplicações reais.",
                                "Identificação de pelo menos 2 limitações (ex: custo computacional SVD)."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Estabilidade de algoritmos de resolução de sistemas.",
                                "Machine Learning: Condicionamento em PCA e regressão ridge via SVD.",
                                "Engenharia Civil: Análise de estruturas com matrizes de rigidez ill-condicionadas.",
                                "Física Computacional: Simulações de dinâmica com matrizes quase singulares."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, SVD analisa condicionamento de matrizes de massa/inércia para simulações CFD; κ₂ alto alerta para necessidade de refinamento de malha ou regularização, evitando erros catastróficos em predições de fluxo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.2",
                        "name": "Sensibilidade a Perturbações no Vetor b",
                        "description": "Análise do efeito de pequenas perturbações δb no vetor de termos independentes, resultando em δx ≈ A⁻¹ δb, com amplificação relativa pelo fator κ(A).",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.2.1",
                            "name": "Derivar a fórmula de erro relativo para perturbações em b",
                            "description": "Demonstrar que ||δx||/||x|| ≤ κ(A) ⋅ ||δb||/||b|| para sistemas consistentes, aplicando em cenários numéricos com MATLAB ou Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Sensibilidade em Sistemas Lineares",
                                  "subSteps": [
                                    "Defina normas vetoriais e matriciais relevantes (ex: norma 2, norma infinito).",
                                    "Lembre o número de condição κ(A) = ||A|| ⋅ ||A⁻¹|| e sua interpretação como medida de sensibilidade.",
                                    "Reveja o teorema básico de perturbação: para Ax = b, A(x + δx) = b + δb implica δx = A⁻¹ δb.",
                                    "Discuta sistemas consistentes e o que significa ||δx||/||x|| ≤ κ(A) ⋅ ||δb||/||b||.",
                                    "Esboce a intuição: amplificação do erro por κ(A)."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e compute κ(A) para uma matriz de exemplo 2x2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Álgebra Linear Numérica (ex: Golub-Van Loan), calculadora ou Python/Jupyter para normas.",
                                  "tips": "Use normas consistentes (ex: sempre norma 2) para evitar confusões.",
                                  "learningObjective": "Compreender os pré-requisitos teóricos para a derivação de sensibilidade.",
                                  "commonMistakes": "Confundir norma de vetor com norma de matriz; ignorar que κ(A) ≥ 1."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar Analiticamente a Fórmula de Erro Relativo",
                                  "subSteps": [
                                    "Comece com Ax = b e A(x + δx) = b + δb, derive δx = A⁻¹ δb.",
                                    " Tome normas: ||δx|| = ||A⁻¹ δb|| ≤ ||A⁻¹|| ⋅ ||δb||.",
                                    "Divida por ||x||: ||δx||/||x|| ≤ ||A⁻¹|| ⋅ ||δb|| / ||x||.",
                                    "Substitua ||x|| ≥ ||b|| / ||A|| (de ||b|| = ||Ax|| ≤ ||A|| ||x||), então ||δx||/||x|| ≤ (||A|| ||A⁻¹||) ⋅ ||δb||/||b||.",
                                    "Conclua que ||δx||/||x|| ≤ κ(A) ⋅ ||δb||/||b||."
                                  ],
                                  "verification": "Escreva a derivação completa em LaTeX ou papel, verificando cada desigualdade pela propriedade de submultiplicatividade.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel e caneta ou editor LaTeX (Overleaf), notas de aula sobre normas.",
                                  "tips": "Anote cada desigualdade com justificativa (triangular ou submultiplicativa).",
                                  "learningObjective": "Dominar a prova rigorosa da bound de erro relativo.",
                                  "commonMistakes": "Esquecer de dividir por ||x|| corretamente; usar ||x|| ≤ ||A⁻¹|| ||b|| em vez do inverso."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Exemplo Numérico em Python ou MATLAB",
                                  "subSteps": [
                                    "Gere uma matriz A mal-condicionada (ex: Hilbert 4x4) e b consistente.",
                                    "Perturbe b com δb pequeno (ex: 10^{-6} * norma(b)).",
                                    "Resolva Ax = b e A(x + δx) = b + δb usando backslash ou np.linalg.solve.",
                                    "Compute erros relativos ||δx||/||x|| e ||δb||/||b||, e κ(A).",
                                    "Verifique se ||δx||/||x|| ≈ κ(A) ⋅ ||δb||/||b||."
                                  ],
                                  "verification": "Execute o código e plote erros vs. κ(A); a bound deve holding.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy/SciPy ou MATLAB, Jupyter Notebook.",
                                  "tips": "Use cond(A, inf) para cond number; normalize vetores para clareza.",
                                  "learningObjective": "Aplicar a teoria em computação numérica para validar a fórmula.",
                                  "commonMistakes": "Não usar solver estável (use lu_factor se necessário); perturbações muito grandes quebram linearidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Generalizar os Resultados",
                                  "subSteps": [
                                    "Compare erro observado com bound teórica em múltiplas perturbações.",
                                    "Teste com matrizes bem e mal-condicionadas.",
                                    "Discuta quando a bound é sharp (quase igualdade).",
                                    "Explore impacto de diferentes normas (2 vs. inf).",
                                    "Registre observações em relatório curto."
                                  ],
                                  "verification": "Tabela com κ(A), erros relativos e ratios; bound deve ser superior.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Mesmo ambiente de programação, planilha para tabelas.",
                                  "tips": "Varie seed para aleatoriedade em b para robustez.",
                                  "learningObjective": "Interpretar numericamente a sensibilidade e limitações.",
                                  "commonMistakes": "Ignorar erros de arredondamento que mascaram δb; confundir cond com rank."
                                }
                              ],
                              "practicalExample": "Considere A = [[1,1],[1,1+eps]] com eps=1e-10, b=[1,1]^T. Perturbe b em 1e-8 na segunda entrada. κ(A)≈1e10, erro em x amplificado similarmente. Implemente em Python: import numpy as np; A=np.array([[1,1],[1,1+1e-10]]); b=np.array([1,1]); x=np.linalg.solve(A,b); db=1e-8*np.array([0,1]); xpert=np.linalg.solve(A,b+db); rel_err_x=np.linalg.norm(xpert-x)/np.linalg.norm(x); rel_err_b=np.linalg.norm(db)/np.linalg.norm(b); print(rel_err_x / (np.linalg.cond(A)*rel_err_b)) # ≈1",
                              "finalVerifications": [
                                "Derivação escrita corretamente com todas as desigualdades justificadas.",
                                "Código numérico executa sem erros e produz bound válida.",
                                "Tabela de resultados mostra ||δx||/||x|| ≤ κ(A) ||δb||/||b|| em pelo menos 3 casos.",
                                "Explicação verbal da intuição da amplificação por κ(A).",
                                "Identificação de quando a bound é atingida (ex: δb alinhado com singular vector)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação analítica (100% das steps corretas).",
                                "Correção do código numérico e reprodutibilidade.",
                                "Análise qualitativa: discute sharp bounds e limitações numéricas.",
                                "Uso consistente de normas e normalizações.",
                                "Relatório claro com plots/tabelas demonstrando a fórmula.",
                                "Conexão com conceitos prévios como κ(A)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Uso de solvers lineares em SciPy/NumPy.",
                                "Engenharia: Análise de sensibilidade em modelos de estruturas (FEA).",
                                "Física Computacional: Propagação de erros em simulações.",
                                "Estatística: Condicionamento em regressão linear."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, perturbações em medições de forças (b) propagam para estimativas de tensões (x) em estruturas; alta κ(A) indica necessidade de refinamento de malha ou regularização para evitar falhas catastróficas."
                            },
                            "estimatedTime": "0.75 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.2.2.2",
                            "name": "Simular perturbações em b numericamente",
                            "description": "Implementar experimentos computacionais perturbando b com ruído gaussiano, medindo ||δx||/||x|| e comparando com κ(A) ⋅ ||δb||/||b|| para validar a teoria.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o sistema linear base",
                                  "subSteps": [
                                    "Escolha uma matriz A não singular de tamanho n x n (ex: n=5, use matriz de Hilbert para ill-conditioning).",
                                    "Gere um vetor b consistente tal que Ax = b tenha solução exata x.",
                                    "Resolva o sistema Ax = b usando decomposição LU ou QR para obter x exato.",
                                    "Calcule as normas ||x|| usando norma 2 (euclidiana)."
                                  ],
                                  "verification": "Verifique se A x = b dentro de tolerância 1e-10 e imprima x, ||x||.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Python com NumPy e SciPy",
                                  "tips": "Use np.linalg.solve para simplicidade inicial; armazene A, b, x em variáveis.",
                                  "learningObjective": "Entender configuração de baseline para experimentos de sensibilidade.",
                                  "commonMistakes": "Escolher A singular (det(A)=0); não normalizar normas corretamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o número de condição κ(A)",
                                  "subSteps": [
                                    "Compute ||A||_2 e ||A^{-1}||_2 usando np.linalg.norm e np.linalg.inv.",
                                    "Calcule κ(A) = ||A||_2 * ||A^{-1}||_2.",
                                    "Alternativamente, use np.linalg.cond(A, p=2) para verificação.",
                                    "Registre o valor de κ(A) e interprete: κ≈1 bem condicionado, κ>>1 mal condicionado."
                                  ],
                                  "verification": "Compare κ(A) manual com np.linalg.cond; deve coincidir em 1e-10.",
                                  "estimatedTime": "5 minutos",
                                  "materials": "Python com NumPy",
                                  "tips": "Para matrizes grandes, evite inv explícita; use cond diretamente.",
                                  "learningObjective": "Dominar cálculo e interpretação do número de condição.",
                                  "commonMistakes": "Usar norma errada (ex: inf em vez de 2); confundir com det(A)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar perturbações gaussianas em b",
                                  "subSteps": [
                                    "Defina níveis de ruído ε = [1e-6, 1e-4, 1e-2, 0.1].",
                                    "Para cada ε, gere δb ~ N(0, ε * ||b|| * I) com np.random.normal.",
                                    "Crie b_pert = b + δb e compute ||δb|| / ||b||.",
                                    "Repita 50 vezes por ε para estatísticas robustas (média e desvio)."
                                  ],
                                  "verification": "Imprima ||δb||/||b|| médio ≈ ε para cada nível.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python com NumPy (np.random.normal)",
                                  "tips": "Use np.random.seed(42) para reprodutibilidade.",
                                  "learningObjective": "Gerar e controlar perturbações realistas gaussianas.",
                                  "commonMistakes": "Gerar δb sem escalar por ||b||; poucas repetições (viés)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver sistemas perturbados e medir erros",
                                  "subSteps": [
                                    "Para cada b_pert, resolva A x_pert = b_pert para obter x_pert.",
                                    "Calcule δx = x_pert - x e erro relativo ||δx|| / ||x||.",
                                    "Colete erros para cada ε e repetição.",
                                    "Plote log(||δx||/||x||) vs log(||δb||/||b||); espere inclinação ≈1."
                                  ],
                                  "verification": "Gráfico mostra correlação linear em escala log-log.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python com NumPy, Matplotlib para plot",
                                  "tips": "Vetorize loops com np.linalg.solve em arrays.",
                                  "learningObjective": "Quantificar sensibilidade numérica via normas relativas.",
                                  "commonMistakes": "Usar norma absoluta; resolver com método instável (ex: eliminação ingênua)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar com bound teórica e analisar",
                                  "subSteps": [
                                    "Compute bound = κ(A) * ||δb|| / ||b|| para cada caso.",
                                    "Verifique se ||δx||/||x|| ≤ bound (teorema de sensibilidade).",
                                    "Calcule razão média ||δx||/||x|| / (κ(A) * ||δb||/||b||) ≈1 para pequenas perturbações.",
                                    "Discuta quando bound é atingida (condicionamento alto)."
                                  ],
                                  "verification": "Razão média < 2 para ε pequeno; plote bound vs erro observado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python com Matplotlib",
                                  "tips": "Use np.mean e np.std para estatísticas; log-escala para clareza.",
                                  "learningObjective": "Validar teoria de sensibilidade via simulação numérica.",
                                  "commonMistakes": "Ignorar fator κ(A); comparar absolutos em vez de relativos."
                                }
                              ],
                              "practicalExample": "Use A = matriz de Hilbert 5x5 (np.linalg.hilbert(5)), b = A @ np.ones(5), κ(A)≈4.8e4. Perturbe com ε=1e-4: espere ||δx||/||x|| ≈ 5e-4 a 1e-2, validando bound κε.",
                              "finalVerifications": [
                                "Gráfico log-log mostra inclinação próxima de 1 entre erro e perturbação.",
                                "Razão média de erros observados vs bound teórica está entre 0.5 e 2 para ε<1e-3.",
                                "Para matrizes bem condicionadas (ex: identidade), erros ≈ perturbações.",
                                "50 repetições por ε mostram baixa variância (std < 10% da média).",
                                "Código roda sem erros numéricos (condições de parada atingidas)."
                              ],
                              "assessmentCriteria": [
                                "Precisão do cálculo de κ(A): erro <1e-8 vs função built-in.",
                                "Correta geração de ruído gaussiano: variância matches ε * ||b||^2.",
                                "Medição de normas relativas exata (norma 2 usada consistentemente).",
                                "Análise estatística robusta com múltiplas simulações e plots claros.",
                                "Validação teórica: bound superior respeitado em 95% dos casos.",
                                "Código limpo, comentado e reprodutível (seed fixo)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Distribuição gaussiana e análise de Monte Carlo.",
                                "Programação: Vetorização NumPy e visualização Matplotlib.",
                                "Física/Engenharia: Modelagem de ruído em medições experimentais.",
                                "Análise Numérica: Estabilidade de algoritmos de resolução linear."
                              ],
                              "realWorldApplication": "Em engenharia civil, perturbações em cargas medidas (b) afetam soluções de equilíbrio estrutural (Ax=b); simulações validam se estruturas são sensíveis a erros de sensor, guiando designs robustos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.3",
                        "name": "Sensibilidade a Perturbações na Matriz A",
                        "description": "Estudo do impacto de perturbações δA na matriz dos coeficientes, com aproximações δx ≈ -A⁻¹ (δA) x + A⁻¹ δb, destacando maior complexidade e dependência em x.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.3.1",
                            "name": "Derivar bounds para erros devidos a δA",
                            "description": "Obter ||δx||/||x|| ≤ κ(A) ⋅ (||δA||/||A||) / (1 - κ(A) ⋅ ||δA||/||A||), assumindo perturbações pequenas, e discutir condições de validade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a formulação do problema de sistemas lineares perturbados",
                                  "subSteps": [
                                    "Lembre-se da equação original: Ax = b, onde A é invertível.",
                                    "Introduza a perturbação: (A + δA)(x + δx) = b, com b fixo.",
                                    "Expanda a equação perturbada: Ax + A δx + δA x + δA δx = b.",
                                    "Negligencie o termo de segunda ordem δA δx para perturbações pequenas.",
                                    "Simplifique para obter: A δx ≈ -δA x."
                                  ],
                                  "verification": "Escreva a aproximação A δx = -δA x e confirme que o termo δA δx é desprezível.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta, notas de álgebra linear numérica (ex: Golub & Van Loan).",
                                  "tips": "Sempre normalize as normas para trabalhar com quantidades relativas.",
                                  "learningObjective": "Entender a aproximação de primeira ordem para perturbações em A.",
                                  "commonMistakes": "Esquecer de cancelar Ax = b na expansão inicial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a expressão exata para δx",
                                  "subSteps": [
                                    "Da aproximação, resolva para δx: δx = -A^{-1} δA x.",
                                    "Para a equação exata, reescreva: A δx = -δA (x + δx).",
                                    "Tome normas: ||A δx|| ≤ ||δA|| ||x + δx||.",
                                    "Divida por ||A||: ||δx|| ≤ κ(A) ||δA|| / ||A|| ⋅ ||x + δx||.",
                                    "Introduza ε = ||δA|| / ||A|| e manipule para obter recursão."
                                  ],
                                  "verification": "Derive δx = -A^{-1} δA (x + δx) e confirme a bound inicial ||δx|| / ||x|| ≤ κ(A) ε / (1 - κ(A) ε).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora ou software simbólico (ex: SymPy, MATLAB), quadro branco.",
                                  "tips": "Use a definição de condição number κ(A) = ||A|| ||A^{-1}|| desde o início.",
                                  "learningObjective": "Obter a expressão δx em termos de perturbação e resolver para bound relativa.",
                                  "commonMistakes": "Confundir ||x + δx|| com ||x|| prematuramente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer a bound final e provar rigorosamente",
                                  "subSteps": [
                                    "Defina η = ||δx|| / ||x|| e ε = ||δA|| / ||A||.",
                                    "Da desigualdade: η ≤ κ(A) ε (1 + η), assumindo normas compatíveis.",
                                    "Reorganize: η (1 - κ(A) ε) ≤ κ(A) ε.",
                                    "Assim: η ≤ [κ(A) ε] / [1 - κ(A) ε], para κ(A) ε < 1.",
                                    "Verifique que a bound é afiada para casos específicos."
                                  ],
                                  "verification": "Escreva e prove a fórmula final ||δx||/||x|| ≤ κ(A) ⋅ (||δA||/||A||) / (1 - κ(A) ⋅ ||δA||/||A||).",
                                  "estimatedTime": "1 hora",
                                  "materials": "Livro de referência (ex: Higham 'Accuracy and Stability'), lápis para anotações.",
                                  "tips": "Trabalhe com normas submultiplicativas e generalize para qualquer norma vetor/matriz.",
                                  "learningObjective": "Derivar e justificar a bound relativa de erro usando manipulação de desigualdades.",
                                  "commonMistakes": "Esquecer a condição κ(A) ε < 1, levando a divisão por zero."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir condições de validade e limitações",
                                  "subSteps": [
                                    "Condição principal: perturbações pequenas, i.e., ||δA|| / ||A|| < 1/κ(A).",
                                    "Assumir A + δA invertível; bound falha se não.",
                                    "Discussão: bound piora com κ(A) grande (matrizes mal-condicionadas).",
                                    "Extensões: para δb também, ou normas específicas (ex: 2-norma).",
                                    "Exemplos de falha: quando ε ≈ 1/κ(A), erro amplificado."
                                  ],
                                  "verification": "Liste 3 condições necessárias e dê um contraexemplo para violação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Artigos ou slides sobre análise de sensibilidade.",
                                  "tips": "Relacione com estabilidade numérica em solvers como LU ou QR.",
                                  "learningObjective": "Identificar hipóteses e cenários onde a bound é aplicável ou não.",
                                  "commonMistakes": "Ignorar que a bound é uma pior-caso, não exata."
                                }
                              ],
                              "practicalExample": "Considere A = [[2,1],[1,1]], x = [1,0]^T, b = [3,1]^T. Perturbe A com δA = 0.01 * [[0,1],[0,0]], compute x+δx via solver numérico, verifique se ||δx||/||x|| ≤ κ(A) ε / (1 - κ(A) ε) com ε=0.005 approx.",
                              "finalVerifications": [
                                "Derivação correta da bound final sem erros algébricos.",
                                "Identificação precisa da condição κ(A) ||δA||/||A|| < 1.",
                                "Explicação verbal da amplificação de erro por κ(A).",
                                "Teste numérico simples confirma a bound.",
                                "Discussão de limitações para matrizes singulares próximas.",
                                "Generalização para normas arbitrárias."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (100% das desigualdades corretas).",
                                "Clareza na manipulação de termos relativos η e ε.",
                                "Compreensão das condições de validade (pelo menos 3 citadas).",
                                "Capacidade de aplicar em exemplo numérico 2x2.",
                                "Análise qualitativa do impacto de condnumber alto.",
                                "Ausência de erros comuns como negligenciar segunda ordem cedo."
                              ],
                              "crossCurricularConnections": [
                                "Computação Numérica: Implementação em código para estimar κ(A) via SVD.",
                                "Física Computacional: Análise de erros em simulações de EDPs discretizadas.",
                                "Estatística: Sensibilidade em regressão linear (A como matriz de design).",
                                "Engenharia: Validação de modelos finitos com perturbações de malha."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, bounds como essa avaliam sensibilidade de soluções de equilíbrio estrutural a erros de fabricação na matriz de rigidez, garantindo segurança quando κ(A) é alto devido a geometrias esguias."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.1.1",
                              "10.1.5.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.2.3.2",
                            "name": "Analisar exemplos de matrizes mal-condicionadas",
                            "description": "Aplicar análise a matrizes como Hilbert ou Vandermonde, perturbando A e b, computando soluções exatas vs. perturbadas e quantificando sensibilidade via resíduos e normas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e gerar matrizes mal-condicionadas de exemplo",
                                  "subSteps": [
                                    "Pesquisar as propriedades das matrizes de Hilbert e Vandermonde, focando em seu alto número de condição.",
                                    "Implementar funções para gerar essas matrizes em software numérico (ex: Python com NumPy ou MATLAB) para dimensões n=4 a 6.",
                                    "Calcular o número de condição cond(A) = ||A|| * ||A^{-1}|| usando normas adequadas (ex: norma 2).",
                                    "Verificar se cond(A) é muito maior que 1 (ex: >10^10 para n=6).",
                                    "Documentar as matrizes geradas e seus números de condição."
                                  ],
                                  "verification": "O número de condição calculado é exibido e confirmado como elevado (ex: ordem de 10^12 ou mais).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy ou MATLAB",
                                    "Documentação online sobre matrizes Hilbert e Vandermonde"
                                  ],
                                  "tips": "Use funções prontas como np.linalg.cond() para agilizar; comece com n pequeno para evitar overflow.",
                                  "learningObjective": "Compreender as características que tornam matrizes mal-condicionadas e como gerá-las.",
                                  "commonMistakes": [
                                    "Confundir mal-condicionamento com singularidade (det(A)=0)",
                                    "Escolher n muito grande sem precisão de dupla precisão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o sistema linear Ax = b com solução exata conhecida",
                                  "subSteps": [
                                    "Escolher um vetor solução exato x_exact simples (ex: todos os elementos iguais a 1).",
                                    "Computar o vetor b exato como b = A * x_exact.",
                                    "Resolver o sistema Ax = b usando método direto (ex: decomposição LU ou QR) para recuperar x_exact.",
                                    "Verificar numericamente se ||x_computado - x_exact|| é próximo de zero (erro de arredondamento).",
                                    "Registrar valores exatos de x_exact e b."
                                  ],
                                  "verification": "A solução computada de Ax=b coincide com x_exact dentro de tolerância de máquina (ex: 1e-15).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Mesmos do Step 1",
                                    "Solucionadores lineares (np.linalg.solve ou mldivide no MATLAB)"
                                  ],
                                  "tips": "Escolha x_exact com elementos de magnitude 1 para facilitar comparações de erros relativos.",
                                  "learningObjective": "Estabelecer uma baseline exata para medir impactos de perturbações.",
                                  "commonMistakes": [
                                    "Erro na multiplicação A * x_exact devido a indexação errada",
                                    "Não usar precisão suficiente ao definir b"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir perturbações controladas em A e b",
                                  "subSteps": [
                                    "Definir níveis de perturbação ε (ex: 10^{-10}, 10^{-8}, 10^{-6}).",
                                    "Gerar matriz de perturbação δA aleatória com elementos ~ N(0,1), escalada por ε, e computar A_pert = A + ε * δA.",
                                    "Similarmente, perturbar b: b_pert = b + ε * δb, com δb aleatório.",
                                    "Manter registros de ε, δA e δb para reprodutibilidade.",
                                    "Resolver múltiplos sistemas perturbados para cada ε."
                                  ],
                                  "verification": "Matrizes A_pert e vetores b_pert são gerados e exibidos para pelo menos 3 valores de ε.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Mesmos do Step 1",
                                    "Gerador de números aleatórios (np.random.randn)"
                                  ],
                                  "tips": "Use semente fixa para aleatoriedade (np.random.seed(42)) para resultados reproduzíveis.",
                                  "learningObjective": "Simular erros de medição ou arredondamento reais em sistemas lineares.",
                                  "commonMistakes": [
                                    "Perturbações muito grandes que invertem cond(A_pert)",
                                    "Não escalar corretamente por ε"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar soluções perturbadas e quantificar sensibilidade",
                                  "subSteps": [
                                    "Resolver A_pert * x_pert = b_pert para cada perturbação.",
                                    "Calcular erro relativo na solução: ||x_pert - x_exact|| / ||x_exact||.",
                                    "Computar resíduo: ||A_pert * x_pert - b_pert|| / ||b_pert||.",
                                    "Comparar amplificação: erro na solução vs. ε, relacionando com cond(A).",
                                    "Plotar gráficos de erros vs. log(ε) e interpretar se o erro cresce como cond(A)*ε."
                                  ],
                                  "verification": "Gráficos e tabelas mostram amplificação de erros proporcional ao número de condição.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Mesmos do Step 1",
                                    "Bibliotecas de plotagem (Matplotlib ou MATLAB plots)"
                                  ],
                                  "tips": "Use escalas logarítmicas nos gráficos para visualizar a linearidade esperada.",
                                  "learningObjective": "Quantificar como mal-condicionamento amplifica erros em soluções.",
                                  "commonMistakes": [
                                    "Confundir resíduo com erro na solução",
                                    "Ignorar normalizações relativas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a matriz de Hilbert 4x4 (H_ij = 1/(i+j-1)), defina x_exact = [1, 1, 1, 1]^T, b = H * x_exact. Perturbe com ε=10^{-8}: adicione ε a H[1,1] e ε a b[1]. Resolva e observe que o erro em x_pert é ~10^5 * ε devido a cond(H)≈10^5.",
                              "finalVerifications": [
                                "Número de condição da matriz é calculado corretamente e classificado como mal-condicionado.",
                                "Erros relativos na solução são amplificados pelo fator cond(A) em relação a ε.",
                                "Resíduos são pequenos, mas erros na solução são grandes.",
                                "Gráficos mostram relação linear log-log entre erro e ε.",
                                "Conclusões escritas explicam o impacto do mal-condicionamento.",
                                "Experimento é reproduzível com código fornecido."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de cond(A), resíduos e erros relativos (erro <1%).",
                                "Correta interpretação da amplificação de erros pelo condicionamento.",
                                "Uso adequado de normalizações e escalas nos gráficos.",
                                "Clareza na documentação de passos, código e resultados.",
                                "Identificação de pelo menos 2 exemplos reais de impacto.",
                                "Código limpo, comentado e executável."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em Python/MATLAB reforça computação científica.",
                                "Estatística: Relaciona com condicionamento em regressão linear múltipla.",
                                "Engenharia: Aplicações em modelagem de estruturas e controle de sistemas.",
                                "Física Computacional: Simulações com matrizes de discretização mal-condicionadas."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, matrizes mal-condicionadas surgem na discretização de equações diferenciais para simular fluxos; pequenas incertezas em dados de sensores causam grandes erros em predições de estabilidade, demandando técnicas de regularização."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.2.2"
                            ]
                          },
                          {
                            "id": "10.1.5.2.3.3",
                            "name": "Comparar sensibilidade via decomposições QR e SVD",
                            "description": "Usar fatoração QR para medir sensibilidade em normas e SVD para decompor contribuições singulares, avaliando estabilidade numérica em implementações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar decomposição QR e sua aplicação em sensibilidade",
                                  "subSteps": [
                                    "Estudar a definição e propriedades da decomposição QR (Q ortogonal, R triangular superior).",
                                    "Analisar como a QR é usada para resolver sistemas lineares via substituição retroativa.",
                                    "Explorar a sensibilidade a perturbações na matriz A através da norma da inversa de R.",
                                    "Calcular o fator de condição baseado em elementos de R.",
                                    "Implementar QR em software numérico para uma matriz de exemplo."
                                  ],
                                  "verification": "Decompor corretamente uma matriz 4x4 via QR e calcular normas relevantes.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro de Álgebra Linear Numérica (Golub/Van Loan)",
                                    "Python com NumPy/SciPy",
                                    "Matriz de exemplo perturbada"
                                  ],
                                  "tips": [
                                    "Use Householder reflections para estabilidade numérica.",
                                    "Verifique ortogonalidade de Q com Q^T * Q = I."
                                  ],
                                  "learningObjective": "Compreender como QR mede sensibilidade via normas de R.",
                                  "commonMistakes": [
                                    "Ignorar estabilidade numérica em implementações ingênuas.",
                                    "Confundir norma de R com cond(A)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar decomposição SVD e contribuições singulares",
                                  "subSteps": [
                                    "Definir SVD: A = U Σ V^T, com Σ diagonal de valores singulares.",
                                    "Interpretar valores singulares como medidas de 'esticamento' e sensibilidade.",
                                    "Analisar sensibilidade de soluções lineares via menores valores singulares.",
                                    "Estudar o fator de condição cond(A) = σ_max / σ_min.",
                                    "Decompor uma matriz rank-deficient para observar sensibilidade extrema."
                                  ],
                                  "verification": "Realizar SVD de uma matriz e identificar σ_min corretamente.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Documentação SciPy.linalg.svd",
                                    "Exemplos de matrizes mal-condicionadas",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": [
                                    "Ordene valores singulares em ordem decrescente.",
                                    "Use SVD compacta para matrizes rank-low."
                                  ],
                                  "learningObjective": "Dominar SVD como ferramenta para decompor contribuições à sensibilidade.",
                                  "commonMistakes": [
                                    "Interpretar erroneamente valores singulares como autovalores.",
                                    "Negligenciar o impacto de σ_min pequeno na estabilidade."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Medir sensibilidade comparativa usando QR e SVD",
                                  "subSteps": [
                                    "Calcular sensibilidade via QR: ||δx|| / ||δA|| ≈ cond(R).",
                                    "Calcular via SVD: bounds baseados em σ_min e σ_max.",
                                    "Comparar acurácia das estimativas para matrizes bem e mal condicionadas.",
                                    "Analisar diferenças em normas (2-norma vs Frobenius).",
                                    "Plotar gráficos de erro relativo vs perturbação para ambas."
                                  ],
                                  "verification": "Produzir tabela comparativa de fatores de condição para 3 matrizes.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Matplotlib para plots",
                                    "Código Python para perturbações aleatórias",
                                    "Matrizes de teste (Hilbert, Vandermonde)"
                                  ],
                                  "tips": [
                                    "Use perturbações relativas pequenas (1e-6).",
                                    "Compare com cond(A) exato via np.linalg.cond."
                                  ],
                                  "learningObjective": "Aplicar ambas decomposições para quantificar sensibilidade.",
                                  "commonMistakes": [
                                    "Usar normas inconsistentes na comparação.",
                                    "Sobreestimar estabilidade em matrizes próximas a singulares."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e avaliar estabilidade numérica",
                                  "subSteps": [
                                    "Implementar solver QR-based e SVD-based para Ax=b.",
                                    "Aplicar perturbações em A e medir ||δx|| / ||x||.",
                                    "Comparar estabilidade em implementações flutuantes.",
                                    "Avaliar tempo computacional e precisão relativa.",
                                    "Concluir sobre quando usar QR vs SVD."
                                  ],
                                  "verification": "Relatório com plots e conclusões para matriz 10x10 perturbada.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python/NumPy/SciPy",
                                    "Timer para benchmarks",
                                    "Relatório template"
                                  ],
                                  "tips": [
                                    "Evite loops desnecessários; use funções vetoriais.",
                                    "Teste com múltiplas seeds para aleatoriedade."
                                  ],
                                  "learningObjective": "Avaliar numericamente a superioridade de cada método.",
                                  "commonMistakes": [
                                    "Ignorar erros de arredondamento em double precision.",
                                    "Comparar apples-to-oranges em tamanhos de matriz."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma matriz de rigidez em engenharia estrutural 5x5. Perturbe A em 1% e compare ||δx|| via QR (foco em R) e SVD (foco em σ_min), observando que SVD captura melhor direções sensíveis.",
                              "finalVerifications": [
                                "Decompor QR e SVD corretamente para matriz arbitrária.",
                                "Calcular e interpretar fatores de condição comparativos.",
                                "Implementar solvers estáveis e medir erros numéricos.",
                                "Identificar cenários onde SVD é preferível a QR.",
                                "Produzir plots de sensibilidade vs perturbação.",
                                "Explicar limitações de cada decomposição."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas decomposições (erro < 1e-10).",
                                "Correta interpretação de sensibilidade numérica.",
                                "Qualidade dos gráficos e tabelas comparativas.",
                                "Eficiência da implementação (tempo < 1s para n=50).",
                                "Profundidade da análise de erros comuns.",
                                "Clareza na conclusão sobre QR vs SVD."
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Algoritmos numéricos e estabilidade (ex: LAPACK).",
                                "Física: Modelagem de sistemas dinâmicos com matrizes mal-condicionadas.",
                                "Engenharia: Análise de estruturas e otimização sob incerteza.",
                                "Estatística: Análise de componentes principais (PCA via SVD).",
                                "Machine Learning: Estabilidade em regressão linear."
                              ],
                              "realWorldApplication": "Em simulações de engenharia aeroespacial, SVD via QR/SVD avalia sensibilidade de modelos finitos a erros de medição, garantindo estabilidade em controle de voo; em ML, SVD detecta multicolinearidade em dados para previsões robustas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.1.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.3",
                    "name": "Sensibilidade de Autovalores",
                    "description": "Estudo da variação de autovalores sob perturbações na matriz.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.3.1",
                        "name": "Perturbações em Matrizes e Autovalores",
                        "description": "Introdução ao conceito de perturbações pequenas em matrizes e seu impacto nos autovalores, incluindo definições de normas de matrizes e vetores para medir variações.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.1.1",
                            "name": "Definir perturbação matricial e normas associadas",
                            "description": "Explicar o que é uma perturbação εA em uma matriz A e calcular normas como ||εA||_2 para quantificar o tamanho da perturbação, relacionando com a variação nos autovalores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de perturbação matricial",
                                  "subSteps": [
                                    "Revise a definição de uma matriz A e introduza εA como uma pequena variação adicionada a A.",
                                    "Entenda que εA representa erros de arredondamento, medições imprecisas ou variações modeladas.",
                                    "Discuta propriedades: εA é pequena em norma, tipicamente ||εA|| < δ para algum δ pequeno.",
                                    "Explore notação: A_pert = A + εA.",
                                    "Identifique contextos onde perturbações ocorrem, como em computação numérica."
                                  ],
                                  "verification": "Escreva uma definição clara de perturbação matricial em suas próprias palavras e dê um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang), caderno para anotações, calculadora"
                                  ],
                                  "tips": "Use analogia com ruído em sinais para visualizar εA.",
                                  "learningObjective": "Definir precisamente o que é uma perturbação εA em uma matriz A.",
                                  "commonMistakes": [
                                    "Confundir εA com multiplicação em vez de adição.",
                                    "Ignorar que εA pode ser assimétrica mesmo se A for simétrica."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender normas matriciais associadas, focando na norma espectral (2-norma)",
                                  "subSteps": [
                                    "Defina norma matricial geral: ||A|| satisfaz positividade, homogeneidade e desigualdade triangular.",
                                    "Estude norma 2: ||A||_2 = maior valor singular de A, ou sqrt(autovalor máximo de A*A^T).",
                                    "Relacione com norma vetorial: ||A||_2 = sup_{||x||=1} ||Ax||_2.",
                                    "Compare com outras normas (Frobenius, 1-norma, infinito-norma) brevemente.",
                                    "Pratique cálculo de ||A||_2 para matrizes 2x2 usando SVD ou potência."
                                  ],
                                  "verification": "Calcule ||M||_2 para uma matriz de exemplo 2x2 e explique o método usado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software MATLAB/Python (NumPy/SciPy), exemplos de matrizes impressas"
                                  ],
                                  "tips": "Para matrizes simétricas, ||A||_2 = |λ_max| onde λ_max é o autovalor de maior módulo.",
                                  "learningObjective": "Explicar e calcular a norma 2 de uma matriz, justificando sua relevância para perturbações.",
                                  "commonMistakes": [
                                    "Confundir norma 2 com autovalor máximo sem considerar módulo.",
                                    "Usar norma Frobenius como proxy sem justificar."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular normas de perturbações εA",
                                  "subSteps": [
                                    "Gere uma matriz A e crie εA com entradas aleatórias pequenas (ex: uniformes em [-ε, ε]).",
                                    "Calcule ||εA||_2 usando decomposição SVD ou método da potência iterativo.",
                                    "Verifique que ||εA||_2 é pequeno se entradas individuais forem pequenas.",
                                    "Compare com outras normas para ver consistência (||.||_2 ≤ ||.||_F ≤ sqrt(n) ||.||_2).",
                                    "Automatize cálculo em código para várias instâncias."
                                  ],
                                  "verification": "Forneça εA exemplo, calcule ||εA||_2 manualmente e via software, com resultado < 0.1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy, Jupyter Notebook"
                                  ],
                                  "tips": "Use np.linalg.norm(E, 2) para verificação rápida.",
                                  "learningObjective": "Quantificar o 'tamanho' de uma perturbação usando ||εA||_2 com precisão.",
                                  "commonMistakes": [
                                    "Escalar norma errada (usar 1 ou inf em vez de 2).",
                                    "Normalizar incorretamente vetores no método da potência."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar perturbação com variação nos autovalores",
                                  "subSteps": [
                                    "Introduza teorema de Bauer-Fike: para autovalor λ de A, existe μ de A+εA tal que |λ - μ| ≤ cond(V) ||εA||_2.",
                                    "Explique cond(V): condição da matriz de autovetores.",
                                    "Calcule autovalores de A e A+εA, verificando variação ≤ bound.",
                                    "Discuta implicações: matrizes mal-condicionadas amplificam perturbações.",
                                    "Aplique a uma matriz diagonalizável simples."
                                  ],
                                  "verification": "Para A e εA dados, comprove numericamente o bound de Bauer-Fike.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código Python para autovalores (np.linalg.eig), referências teóricas"
                                  ],
                                  "tips": "Comece com matrizes 2x2 para intuição visual.",
                                  "learningObjective": "Conectar ||εA||_2 com bounds na perturbação de autovalores via teoremas padrão.",
                                  "commonMistakes": [
                                    "Ignorar fator de condição cond(V).",
                                    "Aplicar teorema sem verificar diagonalizabilidade."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[2, 1], [1, 2]] com autovalores 3 e 1. Perturbe com εA = [[0.01, 0.005], [0.005, -0.01]]. Calcule ||εA||_2 ≈ 0.015, autovalores de A+εA ≈ 3.008 e 0.992, variando < cond(V)*0.015 onde cond(V)≈1.6.",
                              "finalVerifications": [
                                "Define corretamente εA como adição pequena a A.",
                                "Calcula ||εA||_2 para matriz 2x2 com precisão de 3 casas decimais.",
                                "Explica relação entre ||εA||_2 e variação |Δλ| via Bauer-Fike.",
                                "Identifica quando norma 2 é preferida sobre outras.",
                                "Fornece exemplo numérico completo com código ou cálculos manuais.",
                                "Discute limitações de perturbações não-normalizadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual na definição de perturbação (90%+ correto).",
                                "Correção nos cálculos de norma 2 (erro < 1e-4).",
                                "Aplicação correta de teoremas de sensibilidade.",
                                "Profundidade nas explicações relacionais (autovalores-perturbações).",
                                "Uso apropriado de ferramentas computacionais.",
                                "Clareza em exemplos práticos fornecidos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de estabilidade em sistemas dinâmicos lineares (matrizes de transição).",
                                "Engenharia: Controle de sistemas com incertezas em modelos (robustez).",
                                "Computação: Análise de erros numéricos em algoritmos de autovalores (QR, etc.).",
                                "Estatística: Perturbações em matrizes de covariância para PCA.",
                                "Economia: Sensibilidade em modelos de equilíbrio linear."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, perturbações em matrizes de rigidez modelam tolerâncias de fabricação; ||εA||_2 quantifica risco de instabilidade em autovalores (modos de vibração), guiando designs robustos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.2",
                            "name": "Calcular variação aproximada de autovalores sob perturbações",
                            "description": "Usar a fórmula de primeira ordem δλ ≈ v* εA u / (v* u) para estimar a mudança em autovalores sob perturbações pequenas, onde u e v são autovetores direito e esquerdo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos teóricos da fórmula de perturbação",
                                  "subSteps": [
                                    "Revise a definição de autovalores λ e autovetores direitos u (Au = λu) e esquerdos v (v*A = λv*) para matrizes não simétricas.",
                                    "Estude a perturbação εA como uma matriz pequena adicionada à matriz original A, onde ||εA|| << 1.",
                                    "Derive intuitivamente a fórmula δλ ≈ (v* εA u) / (v* u), explicando o papel do denominador como normalização.",
                                    "Discuta a validade da aproximação de primeira ordem para perturbações pequenas.",
                                    "Identifique condições para autovalores simples (não múltiplos)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a origem da fórmula e suas premissas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear Computacional (ex: Golub & Van Loan)",
                                    "Notas de aula sobre análise de sensibilidade",
                                    "Calculadora ou software como MATLAB/Octave"
                                  ],
                                  "tips": "Visualize com diagramas o espaço vetorial e como a perturbação desloca o autovetor.",
                                  "learningObjective": "Entender conceitualmente a fórmula de perturbação de autovalores de primeira ordem.",
                                  "commonMistakes": [
                                    "Confundir autovetores direitos e esquerdos",
                                    "Ignorar a normalização v* u",
                                    "Aplicar a fórmula para autovalores múltiplos sem ajustes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular autovalores e autovetores da matriz original",
                                  "subSteps": [
                                    "Escolha ou defina uma matriz A numérica pequena (2x2 ou 3x3) com autovalores distintos.",
                                    "Compute os autovalores λ usando o polinômio característico det(A - λI) = 0.",
                                    "Para cada λ, resolva (A - λI)u = 0 para o autovetor direito u.",
                                    "Compute o autovetor esquerdo v resolvendo v*(A - λI) = 0 e normalize se necessário.",
                                    "Verifique ortogonalidade/normalização: confirme v* u ≠ 0 e normalize para v* u = 1 se aplicável."
                                  ],
                                  "verification": "Confirme que Au = λu e v*A = λv* com erro numérico < 10^-10.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software numérico: MATLAB, Python (NumPy/SciPy), ou Octave",
                                    "Papel e lápis para matrizes pequenas"
                                  ],
                                  "tips": "Use funções prontas como eig() no MATLAB para verificação, mas implemente manualmente para compreensão.",
                                  "learningObjective": "Dominar o cálculo preciso de autovalores e autovetores direitos/esquerdos.",
                                  "commonMistakes": [
                                    "Erros em normalização levando a v* u ≠ 1",
                                    "Confusão na transposição conjugada para v*",
                                    "Escolha de matrizes com autovalores múltiplos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir perturbação e aplicar a fórmula de aproximação",
                                  "subSteps": [
                                    "Defina uma perturbação εA pequena (ex: ε = 0.01, A_pert = randn(size(A))*ε).",
                                    "Compute o numerador v* (εA) u usando multiplicação matricial.",
                                    "Calcule o denominador v* u.",
                                    "Aplique δλ ≈ (v* εA u) / (v* u).",
                                    "Compare com o autovalor exato da matriz perturbada A + εA para validar a aproximação."
                                  ],
                                  "verification": "Erro entre δλ aproximado e λ_exato - λ < 5% para ε pequeno.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software numérico com suporte a operações matriciais",
                                    "Exemplos de matrizes pré-definidas"
                                  ],
                                  "tips": "Teste com ε decrescente (0.1, 0.01, 0.001) para observar convergência da aproximação.",
                                  "learningObjective": "Executar o cálculo da variação aproximada δλ com precisão numérica.",
                                  "commonMistakes": [
                                    "Não escalar corretamente ε em εA",
                                    "Erro na ordem de multiplicação v* εA u",
                                    "Dividir por v* u = 0 devido a má normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e analisar sensibilidade",
                                  "subSteps": [
                                    "Analise o sinal e magnitude de δλ em relação à direção da perturbação.",
                                    "Compute δλ para múltiplas perturbações e identifique autovalores mais sensíveis.",
                                    "Discuta limitações: quando a aproximação falha (ε grande ou autovalores próximos).",
                                    "Gere um gráfico de δλ vs. ε para visualização.",
                                    "Resuma insights sobre estabilidade espectral da matriz."
                                  ],
                                  "verification": "Produza relatório com tabela/comparação e gráfico mostrando boa aproximação para ε pequeno.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de plotagem (MATLAB plot, Python Matplotlib)",
                                    "Planilha para tabelas"
                                  ],
                                  "tips": "Use cond(A) para estimar sensibilidade geral antes.",
                                  "learningObjective": "Interpretar e validar a aproximação no contexto de análise de sensibilidade.",
                                  "commonMistakes": [
                                    "Ignorar efeitos de segunda ordem para ε moderado",
                                    "Generalizar resultados sem testar múltiplos casos",
                                    "Má interpretação do impacto de perturbações assimétricas"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[2, 1], [0, 3]]. Autovalores: λ1=2, λ2=3. u1=[1,0]^T, v1=[1,0] (normalizados). Perturbação εA = 0.01 * [[0,1],[1,0]]. Então v1* εA u1 = 0.01, v1* u1=1, δλ1 ≈ 0.01. Autovalor exato de A+εA ≈ 2.01, confirmando a aproximação.",
                              "finalVerifications": [
                                "Calcula corretamente autovetores direitos e esquerdos para matriz dada.",
                                "Aplica a fórmula δλ sem erros aritméticos.",
                                "Valida aproximação comparando com autovalor exato.",
                                "Identifica quando a aproximação é válida (ε pequeno).",
                                "Interpreta o resultado em termos de sensibilidade.",
                                "Discute limitações para autovalores múltiplos."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos (erro < 1%).",
                                "Compreensão conceitual demonstrada em explicações.",
                                "Validação adequada com exemplos múltiplos.",
                                "Análise de erros comuns e limitações.",
                                "Uso correto de software e interpretação gráfica.",
                                "Clareza na documentação do processo."
                              ],
                              "crossCurricularConnections": [
                                "Física: Perturbação em mecânica quântica (teoria de perturbação não degenerada).",
                                "Engenharia: Análise de estabilidade em sistemas dinâmicos e controle.",
                                "Computação: Algoritmos numéricos para eigendecomposição sensível (ex: LAPACK).",
                                "Estatística: Análise de sensibilidade em PCA e análise de componentes principais."
                              ],
                              "realWorldApplication": "Em engenharia estrutural, estima mudanças em frequências de vibração (autovalores) devido a pequenas variações em rigidez/massa, auxiliando na previsão de falhas; em finanças, analisa sensibilidade de portfólios a perturbações de mercado."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.3.1.3",
                            "name": "Interpretar o papel dos autovetores na sensibilidade",
                            "description": "Analisar como a não-ortogonalidade entre autovetores direito e esquerdo afeta a sensibilidade de um autovalor específico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar autovetores direitos e esquerdos",
                                  "subSteps": [
                                    "Defina autovetor direito: resolver Av = λv para matriz A.",
                                    "Defina autovetor esquerdo: resolver w^T A = λ w^T ou A^T w = λw.",
                                    "Explique a biorthogonalidade: w_i^T v_j = δ_{ij} após normalização.",
                                    "Discuta diferenças em matrizes normais vs. não-normais.",
                                    "Calcule autovetores para uma matriz 2x2 simples não simétrica."
                                  ],
                                  "verification": "Compute autovetores direitos e esquerdos de uma matriz dada e verifique biorthogonalidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora ou software como MATLAB/Python (NumPy)",
                                    "Notas de Álgebra Linear"
                                  ],
                                  "tips": "Sempre normalize os autovetores para w^T v = 1 ao trabalhar com sensibilidade.",
                                  "learningObjective": "Entender as definições e relações entre autovetores direitos e esquerdos.",
                                  "commonMistakes": [
                                    "Confundir autovetores direitos com esquerdos",
                                    "Esquecer transposição para esquerdos",
                                    "Não normalizar adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar ortogonalidade e não-ortogonalidade",
                                  "subSteps": [
                                    "Defina ortogonalidade: w^T v = 0 para autovalores distintos em matrizes normais.",
                                    "Explique não-ortogonalidade em matrizes não-normais: autovetores podem ser quase paralelos.",
                                    "Meça o ângulo entre autovetores direitos e esquerdos usando produto escalar.",
                                    "Calcule o condicionamento cond(v, w) = 1 / |w^T v|.",
                                    "Compare matrizes simétricas (ortogonais) vs. Jordan blocks (não-ortogonais)."
                                  ],
                                  "verification": "Para uma matriz não-normal, compute |w^T v| e interprete se indica boa ou má ortogonalidade.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software NumPy/SciPy para autovalores",
                                    "Exemplos de matrizes não-normais"
                                  ],
                                  "tips": "Use blocos de Jordan para ilustrar extremos de não-ortogonalidade.",
                                  "learningObjective": "Identificar e quantificar a não-ortogonalidade entre pares de autovetores.",
                                  "commonMistakes": [
                                    "Assumir ortogonalidade em todas as matrizes",
                                    "Ignorar normalização no produto escalar",
                                    "Confundir ortogonalidade com biorthogonalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar fórmulas de sensibilidade de autovalores",
                                  "subSteps": [
                                    "Apresente a fórmula de perturbação: δλ ≈ (w^* δA v) / (w^* v).",
                                    "Explique o denominador |w^* v|: mede sensibilidade à perturbação.",
                                    "Discuta como |w^* v| pequeno amplifica erros em δλ.",
                                    "Derive qualitativamente para matrizes 2x2.",
                                    "Simule numericamente com pequenas perturbações δA."
                                  ],
                                  "verification": "Aplique a fórmula a uma perturbação e compare δλ teórico vs. numérico.",
                                  "estimatedTime": "1 hora 30 minutos",
                                  "materials": [
                                    "Código Python/MATLAB para simulações",
                                    "Artigo de Stewart sobre análise de erro"
                                  ],
                                  "tips": "Teste com δA aleatória pequena para validar a aproximação.",
                                  "learningObjective": "Dominar a fórmula que liga autovetores à sensibilidade de autovalores.",
                                  "commonMistakes": [
                                    "Esquecer o denominador na fórmula",
                                    "Usar autovetores não normalizados",
                                    "Ignorar conjugado para matrizes complexas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar o impacto na sensibilidade",
                                  "subSteps": [
                                    "Conclua que não-ortogonalidade (pequeno |w^T v|) aumenta sensibilidade.",
                                    "Analise exemplos: matrizes normais (baixa sensibilidade) vs. não-normais (alta).",
                                    "Discuta implicações computacionais: precisão em algoritmos de autovalores.",
                                    "Crie gráfico de sensibilidade vs. não-ortogonalidade.",
                                    "Resolva problema: dada matriz, avalie sensibilidade de um autovalor."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como a não-ortogonalidade afeta um autovalor específico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Gráficos via Matplotlib",
                                    "Problemas de exercícios"
                                  ],
                                  "tips": "Visualize com plots de autovetores para intuitividade.",
                                  "learningObjective": "Interpretar qualitativa e quantitativamente o papel dos autovetores na sensibilidade.",
                                  "commonMistakes": [
                                    "Atribuir sensibilidade só à perturbação δA",
                                    "Generalizar de casos simétricos",
                                    "Não considerar autovalor específico"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a matriz A = [[1, 1], [0, 1]] (bloco Jordan). Autovalor λ=1 simples, mas autovetor direito v=[1,0]^T, esquerdo w=[0,1]^T, w^T v=0 (má condicionado). Perturbe δA=[[0,ε],[0,0]], δλ ≈ ε / 0 → infinito, mostrando alta sensibilidade devido à não-ortogonalidade.",
                              "finalVerifications": [
                                "Explique a fórmula de sensibilidade δλ ≈ (w^* δA v)/(w^* v).",
                                "Para uma matriz dada, identifique o autovalor mais sensível baseado em |w^T v|.",
                                "Simule perturbação e compare com predição teórica.",
                                "Discuta por que matrizes não-normais são problemáticas.",
                                "Crie exemplo próprio de alta/baixa sensibilidade.",
                                "Avalie condicionamento de autovetores para λ específico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da fórmula de sensibilidade (80%+ correto).",
                                "Correta normalização e cálculo de |w^T v|.",
                                "Interpretação qualitativa clara do impacto da não-ortogonalidade.",
                                "Exemplos numéricos com erro <1e-6 na aproximação.",
                                "Análise de implicações computacionais.",
                                "Uso adequado de terminologia (direito/esquerdo, biorthogonalidade)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modos normais em vibrações (matrizes não-simétricas).",
                                "Engenharia: Análise de estabilidade em controle de sistemas.",
                                "Computação: Precisão numérica em eigendecomposições (SciPy).",
                                "Economia: Modelos dinâmicos com matrizes de transição não-normais."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, analisar sensibilidade de autovalores em modelos de flutter de asas garante estabilidade; não-ortogonalidade indica necessidade de refinamento do modelo para evitar falhas catastróficas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.2",
                        "name": "Sensibilidade de Autovalores Simples",
                        "description": "Estudo da sensibilidade para autovalores distintos (simples), incluindo teoremas clássicos como o de Bauer-Fike e medidas de condicionamento.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.2.1",
                            "name": "Aplicar o teorema de Bauer-Fike",
                            "description": "Usar o teorema de Bauer-Fike para boundar a distância entre autovalores de A e A+εA: min_j |λ_i - μ_j| ≤ ||εA|| / |cos θ|, onde θ é o ângulo entre autovetores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e enunciar o Teorema de Bauer-Fike",
                                  "subSteps": [
                                    "Ler a enunciação precisa do teorema: para A diagonalizável com autovalor λ_i e B = A + εA, min_j |λ_i - μ_j| ≤ ||εA|| / |cos θ|, onde θ é o ângulo entre autovetores associados.",
                                    "Identificar pressupostos: A deve ser diagonalizável, autovalor simples, normas apropriadas (ex: norma 2).",
                                    "Explicar intuitivamente por que o bound depende de cos θ (medida de alinhamento de autovetores).",
                                    "Anotar a fórmula em termos de matriz de autovetores P e cond(P), se aplicável.",
                                    "Resolver um exercício simples de enunciação sem números."
                                  ],
                                  "verification": "Enunciar o teorema corretamente por escrito, incluindo todos os termos e condições.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas de aula sobre sensibilidade de autovalores",
                                    "Livro de Álgebra Linear Numérica (ex: Golub-Van Loan)",
                                    "Calculadora ou Python/NumPy"
                                  ],
                                  "tips": "Sempre especifique a norma usada (geralmente norma espectral ||.||_2). Use diagrama para visualizar o bound geométrico.",
                                  "learningObjective": "Dominar a enunciação precisa e os pressupostos do teorema para aplicação correta.",
                                  "commonMistakes": [
                                    "Omitir a diagonalizabilidade de A",
                                    "Confundir com teoremas para autovalores múltiplos",
                                    "Usar norma errada sem especificar"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diagonalizar a matriz original A e preparar componentes",
                                  "subSteps": [
                                    "Calcular os autovalores λ_i de A resolvendo det(A - λI) = 0.",
                                    "Encontrar autovetores u_i associados a cada λ_i normalizados.",
                                    "Formar a matriz P de autovetores e verificar A = P D P^{-1}.",
                                    "Calcular cond(P) = ||P|| ||P^{-1}|| como proxy para 1/|cos θ|.",
                                    "Definir o autovetor de referência para medir θ posteriormente."
                                  ],
                                  "verification": "Verificar numericamente que ||A P - P D|| < 1e-10, confirmando diagonalização.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software computacional (MATLAB, Python com NumPy/SciPy)",
                                    "Papel e lápis para matrizes pequenas",
                                    "Tabela de fórmulas de autovalores"
                                  ],
                                  "tips": "Para matrizes 2x2, faça à mão; para maiores, use código. Normalize autovetores para ||u||=1.",
                                  "learningObjective": "Computar com precisão os autovalores e autovetores de A, base para o bound.",
                                  "commonMistakes": [
                                    "Erro no cálculo de autovetores (não ortogonais se A não simétrica)",
                                    "Esquecer normalização",
                                    "Não verificar diagonalização"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir perturbação εA e calcular o bound superior",
                                  "subSteps": [
                                    "Definir a matriz de perturbação εA com norma conhecida ||εA||.",
                                    "Calcular cos θ aproximado ou usar cond(P) para o bound: ||εA|| / |cos θ|.",
                                    "Aplicar a fórmula: bound = ||εA|| / |cos θ| para cada λ_i.",
                                    "Interpretar o bound: quanto menor cos θ (autovetores desalinhados), maior sensibilidade.",
                                    "Documentar todos os valores intermediários em tabela."
                                  ],
                                  "verification": "O bound calculado é um número finito e consistente com as normas usadas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python/NumPy para normas e cond",
                                    "Exemplos de matrizes perturbadas",
                                    "Folha de cálculo para rastrear valores"
                                  ],
                                  "tips": "Use norma 2: ||M||_2 = maior autovalor singular. Para θ, cos θ = |u_i^* v_j| / (||u_i|| ||v_j||).",
                                  "learningObjective": "Derivar o bound analiticamente para dada perturbação, entendendo dependência em θ.",
                                  "commonMistakes": [
                                    "Calcular ||εA|| errada (ex: norma Frobenius em vez de 2)",
                                    "Ignorar dependência em autovetores",
                                    "Bound negativo ou infinito"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar o bound computando autovalores de A + εA",
                                  "subSteps": [
                                    "Construir B = A + εA.",
                                    "Calcular autovalores μ_j de B.",
                                    "Para cada λ_i, encontrar min_j |λ_i - μ_j|.",
                                    "Comparar: confirmar que min |λ_i - μ_j| ≤ bound.",
                                    "Analisar discrepância e discutir implicações para sensibilidade."
                                  ],
                                  "verification": "A desigualdade holds em todos os autovalores com tolerância numérica.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software numérico (SciPy eigvals)",
                                    "Gráfico de autovalores antes/depois",
                                    "Relatório template"
                                  ],
                                  "tips": "Use precisão dupla; plote autovalores para visualização. Teste com ε pequeno e grande.",
                                  "learningObjective": "Validar empiricamente o teorema e interpretar resultados de sensibilidade.",
                                  "commonMistakes": [
                                    "Erro numérico em eig de B",
                                    "Não parear corretamente λ_i e μ_j mais próximo",
                                    "Ignorar tolerâncias de máquina"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[2, 1], [0, 3]] (autovalores λ1=2, λ2=3; autovetores u1=[1,0], u2=[1/2,1]). Tome εA = 0.01 * [[0,1],[1,0]], ||εA||_2 ≈ 0.01. Calcule P, cond(P)≈2, θ pequeno, bound ≈ 0.01 / cosθ ≈ 0.015. Compute eig(B): μ≈[2.005, 2.995], min diffs < bound, confirmando baixa sensibilidade.",
                              "finalVerifications": [
                                "Enunciação correta do teorema com fórmula exata.",
                                "Diagonalização de A verificada numericamente.",
                                "Bound calculado coincide com ||εA|| / |cos θ|.",
                                "Desigualdade confirmada para todos autovalores.",
                                "Interpretação escrita da sensibilidade observada.",
                                "Código ou cálculos reproduzíveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos (erro <1e-8).",
                                "Correta identificação de pressupostos e normas.",
                                "Validação numérica completa com comparação quantitativa.",
                                "Interpretação qualitativa do bound e sensibilidade.",
                                "Clareza na documentação e uso de ferramentas.",
                                "Generalização para casos similares."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Estabilidade de algoritmos eig.",
                                "Física Computacional: Perturbações em Hamiltonianos quânticos.",
                                "Engenharia de Controle: Análise de estabilidade de sistemas lineares.",
                                "Ciência de Dados: Sensibilidade em PCA e redução dimensional."
                              ],
                              "realWorldApplication": "Em simulações numéricas de engenharia (ex: vibrações estruturais), o teorema quantifica quanto erro em medições (εA) afeta autovalores (frequências), guiando tolerâncias em modelos finitos de elementos ou controle de aeronaves."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.3.2.2",
                            "name": "Calcular o número de condição de um autovalor simples",
                            "description": "Computar κ(λ) = 1 / |y* x|, onde x e y são autovetores direito e esquerdo normalizados, e interpretar seu significado na amplificação de erros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular o autovetor direito x para o autovalor simples λ",
                                  "subSteps": [
                                    "Dada a matriz A e autovalor simples λ, forme a matriz A - λI.",
                                    "Resolva o sistema (A - λI)x = 0 para encontrar um autovetor direito x ≠ 0.",
                                    "Escolha uma solução básica não-trivial, por exemplo, usando eliminação gaussiana.",
                                    "Verifique que Ax = λx para confirmar.",
                                    "Escala x arbitrariamente por enquanto (normalização vem depois)."
                                  ],
                                  "verification": "Verificar se ||Ax - λx|| é próximo de zero (tolerância numérica 10^-10).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matriz A",
                                    "Papel e calculadora ou Python/MATLAB"
                                  ],
                                  "tips": "Use autovalor simples (multiplicidade algébrica 1) para garantir existência única de direção.",
                                  "learningObjective": "Entender como obter autovetor direito associado a λ simples.",
                                  "commonMistakes": [
                                    "Confundir com autovetor esquerdo",
                                    "Escolher x=0",
                                    "Não verificar Ax=λx"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o autovetor esquerdo y para o autovetor direito x",
                                  "subSteps": [
                                    "Forme a matriz transposta A^T - λI.",
                                    "Resolva o sistema y^T (A^T - λI) = 0^T, equivalente a (A^T - λI)^T y = 0.",
                                    "Ou resolva (A - λI)^T y = 0 para y.",
                                    "Encontre y ≠ 0 não-trivial.",
                                    "Verifique y^H A = λ y^H (para complexos, ou y^T A = λ y^T em reais)."
                                  ],
                                  "verification": "Confirmar y^H A ≈ λ y^H com erro pequeno.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matriz A",
                                    "Software numérico como NumPy ou MATLAB"
                                  ],
                                  "tips": "Autovetor esquerdo resolve o problema adjunto; em reais, use transposto.",
                                  "learningObjective": "Distinguir e calcular autovetores esquerdos corretamente.",
                                  "commonMistakes": [
                                    "Usar A - λI em vez de adjunto",
                                    "Confundir normalização precoce",
                                    "Ignorar conjugado hermitiano em complexos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Normalizar os autovetores x e y",
                                  "subSteps": [
                                    "Calcule a norma euclidiana ||x||_2 = sqrt(x^H x) e normalize x_norm = x / ||x||_2.",
                                    "Da mesma forma, normalize y_norm = y / ||y||_2.",
                                    "Confirme que ||x_norm||_2 = 1 e ||y_norm||_2 = 1.",
                                    "Use norma 2 padrão para consistência com teoria de sensibilidade.",
                                    "Registre os vetores normalizados."
                                  ],
                                  "verification": "Verificar ||x_norm||_2 = 1 e ||y_norm||_2 = 1 com precisão numérica.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Vetores x e y",
                                    "Calculadora ou Python (np.linalg.norm)"
                                  ],
                                  "tips": "Sempre normalize após encontrar vetores brutos para evitar escalas erradas.",
                                  "learningObjective": "Aplicar normalização L2 corretamente em autovetores.",
                                  "commonMistakes": [
                                    "Normalizar com norma 1 ou infinito",
                                    "Esquecer conjugado em x^H x",
                                    "Normalizar só um vetor"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar o número de condição κ(λ) = 1 / |y^H x|",
                                  "subSteps": [
                                    "Calcule o produto interno hermitiano y_norm^H x_norm.",
                                    "Tome o módulo absoluto |y_norm^H x_norm|.",
                                    "Compute κ(λ) = 1 / |y_norm^H x_norm|.",
                                    "Para matrizes reais, y^T x_norm.",
                                    "Arredonde com precisão adequada (ex: 4 casas decimais)."
                                  ],
                                  "verification": "Garantir 0 < |y^H x| ≤ 1, pois κ(λ) ≥ 1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "x_norm, y_norm",
                                    "Software para produto interno"
                                  ],
                                  "tips": "Em autovalores simples, |y^H x| > 0; próximo de 1 indica bom condicionamento.",
                                  "learningObjective": "Executar cálculo preciso de κ(λ).",
                                  "commonMistakes": [
                                    "Usar y x em vez de y^H x",
                                    "Esquecer módulo absoluto",
                                    "Dividir incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar o significado de κ(λ) na amplificação de erros",
                                  "subSteps": [
                                    "Lembre que δλ / |λ| ≈ κ(λ) * (δA / ||A||) para perturbações δA.",
                                    "Se κ(λ) ≈1, autovalor bem condicionado (erros não amplificados).",
                                    "Se κ(λ) >>1, sensível a erros de arredondamento ou dados.",
                                    "Compare com outros autovalores da matriz.",
                                    "Discuta implicações numéricas (ex: evitar em algoritmos)."
                                  ],
                                  "verification": "Explicar verbalmente como κ amplifica erros relativos em λ.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Valor de κ(λ)",
                                    "Referência teórica (ex: livro de Demmel)"
                                  ],
                                  "tips": "κ(λ)=1 para matrizes normais/simétricas; maior para não-normais.",
                                  "learningObjective": "Compreender interpretação de sensibilidade via número de condição.",
                                  "commonMistakes": [
                                    "Confundir com condição da matriz",
                                    "Ignorar normalização na interpretação",
                                    "Pensar κ pequeno é ruim"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[2, 1], [0, 3]], λ=2 simples. Autovetor direito x=[1,0]^T (||x||=1). Autovetor esquerdo: resolva (A^T - 2I)y=0, A^T=[[2,0],[1,3]], A^T-2I=[[0,0],[1,1]], y=[1,-1]^T, ||y||=√2, y_norm=[1/√2, -1/√2]. y^T x = 1/√2 ≈0.707, κ(λ)=√2≈1.414. Interpretação: erros em A amplificados por fator ~1.414 em λ.",
                              "finalVerifications": [
                                "Autovetores x e y calculados e verificados corretamente (Ax=λx, y^H A=λ y^H).",
                                "Normalização confirmada: ||x||_2=1, ||y||_2=1.",
                                "κ(λ) computado com |y^H x| >0 e κ≥1.",
                                "Interpretação inclui amplificação de erros relativos.",
                                "Exemplo numérico reproduzido sem erros.",
                                "Discussão de implicações numéricas coerente."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de autovetores e produto interno (erro <10^-8).",
                                "Correta normalização L2 aplicada.",
                                "Cálculo exato de κ(λ) com justificativa.",
                                "Interpretação qualitativa e quantitativa precisa de sensibilidade.",
                                "Uso consistente de notação hermitiana/transposta.",
                                "Clareza na verificação e exemplo prático."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Perturbações e estabilidade de algoritmos eigen (QR, etc.).",
                                "Computação Científica: Implementação em Python/NumPy para eigenproblemas.",
                                "Física Computacional: Modos normais em vibrações com matrizes não-simétricas.",
                                "Engenharia: Análise de estabilidade em sistemas dinâmicos lineares."
                              ],
                              "realWorldApplication": "Em análise de estabilidade de algoritmos de machine learning (ex: PCA com dados ruidosos), onde autovalores sensíveis levam a instabilidade; ou em simulações de engenharia estrutural, prevendo amplificação de erros de medição nas frequências naturais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.1.3"
                            ]
                          },
                          {
                            "id": "10.1.5.3.2.3",
                            "name": "Resolver problemas numéricos de sensibilidade para autovalores simples",
                            "description": "Implementar em software (ex: MATLAB) a computação de autovalores perturbados e comparar com predições teóricas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar teoria de sensibilidade para autovalores simples",
                                  "subSteps": [
                                    "Estudar a fórmula de sensibilidade: para autovalor simples λ com autovetor u e autovetor esquerdo v, δλ ≈ (v^* E u) / (v^* u), onde E é a perturbação.",
                                    "Identificar condições: autovalor simples (multiplicidade algébrica 1).",
                                    "Consultar teorema de Bauer-Fike ou resultados locais de Kato para contexto.",
                                    "Preparar anotações sobre normalização de autovetores (unitários).",
                                    "Verificar exemplos teóricos simples em 2x2."
                                  ],
                                  "verification": "Resumir a fórmula em um bloco de notas e resolver manualmente um exemplo 2x2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Álgebra Linear Computacional (ex: Golub-Van Loan), notas de aula, calculadora.",
                                  "tips": "Sempre normalize autovetores para |v^* u| = 1 para simplificar.",
                                  "learningObjective": "Compreender a predição teórica de perturbação em autovalores simples.",
                                  "commonMistakes": "Confundir autovetor direito e esquerdo; ignorar normalização."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir matriz original, perturbação e preparar ambiente MATLAB",
                                  "subSteps": [
                                    "Escolher matriz A diagonalizável com autovalor simples (ex: A = [2 1; 1 2]).",
                                    "Definir perturbação E pequena (ex: E = 0.01 * eye(2) ou aleatória).",
                                    "Iniciar script MATLAB: limpar workspace, definir A e E.",
                                    "Computar autovalores e autovetores originais com eig(A).",
                                    "Identificar o autovalor simples λ e autovetores u, v."
                                  ],
                                  "verification": "Exibir A, E, λ, u, v no console MATLAB sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB instalado, documentação eig() no help MATLAB.",
                                  "tips": "Use [V, D] = eig(A) para autovetores direitos; para esquerdos, eig(A', 'vector').",
                                  "learningObjective": "Configurar problema numérico reproduzível em software.",
                                  "commonMistakes": "Escolher matriz com autovalores múltiplos; perturbação muito grande."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar autovalores perturbados numericamente",
                                  "subSteps": [
                                    "Definir matriz perturbada B = A + E.",
                                    "Calcular autovalores e autovetores de B com eig(B).",
                                    "Identificar λ_pert próximo de λ original (usar abs(λ_pert - λ) mínimo).",
                                    "Calcular δλ_num = λ_pert - λ.",
                                    "Repetir para múltiplas perturbações E (ex: loop com randn)."
                                  ],
                                  "verification": "Plotar histograma de δλ_num para várias E e confirmar variação pequena.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "MATLAB, funções eig(), randn() para E aleatória.",
                                  "tips": "Use formato long para precisão numérica em display.",
                                  "learningObjective": "Implementar computação direta de efeitos perturbados.",
                                  "commonMistakes": "Não parear corretamente λ original com perturbado; overflow numérico."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar predições teóricas no MATLAB",
                                  "subSteps": [
                                    "Normalizar: u = u / norm(u); v = (eig(A')' * u) / (u' * eig(A') * u) para v esquerdo.",
                                    "Calcular predição δλ_teor = (v' * E * u) / (v' * u).",
                                    "Implementar em função: function delta = predict(lambda_idx, A, E).",
                                    "Loop para várias E e coletar δλ_teor.",
                                    "Verificar normalização: abs(v' * u - 1) < 1e-10."
                                  ],
                                  "verification": "Comparar manualmente δλ_teor com cálculo à mão para uma E fixa.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "MATLAB, funções ctranspose (') para hermitiano.",
                                  "tips": "Para matrizes reais simétricas, v = u conjuga.",
                                  "learningObjective": "Traduzir teoria em código numérico estável.",
                                  "commonMistakes": "Erro em autovetor esquerdo; divisão por zero se não normalizado."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar resultados e analisar discrepâncias",
                                  "subSteps": [
                                    "Calcular erros: err = abs(δλ_num - δλ_teor) para cada trial.",
                                    "Plotar scatter(δλ_teor, δλ_num) e linha y=x.",
                                    "Computar estatísticas: mean(err), max(err), cond(A).",
                                    "Analisar: se err grande, verificar condição da matriz.",
                                    "Documentar relatório com plots e conclusões."
                                  ],
                                  "verification": "Erro médio < 1e-10 e R^2 > 0.99 no scatter plot.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "MATLAB plot(), scatter(), polyfit() para regressão.",
                                  "tips": "Use semilogx para erros pequenos; teste com ||E|| variando.",
                                  "learningObjective": "Validar teoria contra prática numérica e interpretar.",
                                  "commonMistakes": "Ignorar precisão máquina (eps); plots sem labels."
                                }
                              ],
                              "practicalExample": "Matriz A = [2 1; 1 2], λ=3 (simples), u=[1;1]/sqrt(2). Perturbe E=[0.01 0; 0 0]. Predição δλ ≈ 0.01 / 2 = 0.005. Compute eig(A+E) ≈ [1.995 0; 0 2.005], confirme δλ_num ≈ 0.005.",
                              "finalVerifications": [
                                "Predições teóricas coincidem com numéricas dentro de 1e-10 para ||E||<1e-3.",
                                "Código roda sem erros para matrizes 2x2 a 10x10 diagonalizáveis.",
                                "Plots mostram alinhamento perfeito y=x.",
                                "Relatório explica qualquer discrepância por condição numérica.",
                                "Testes com 100 perturbações aleatórias confirmam robustez.",
                                "Normalização de autovetores verificada em todos casos."
                              ],
                              "assessmentCriteria": [
                                "Código MATLAB completo, comentado e reproduzível (20%).",
                                "Fórmulas teóricas implementadas corretamente (25%).",
                                "Comparação quantitativa precisa com erros < eps*cond(A) (20%).",
                                "Análise de resultados com plots e estatísticas (20%).",
                                "Relatório claro com interpretações (15%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação numérica: uso avançado de MATLAB/Python (NumPy/SciPy).",
                                "Física: análise de sensibilidade em modos normais de vibração.",
                                "Engenharia: estabilidade em sistemas de controle e otimização.",
                                "Estatística: análise de erro e condicionamento numérico."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, avalia sensibilidade de frequências de flutter a variações de material, prevendo falhas estruturais sem simulações custosas; ou em finanças, análise de estabilidade de portfólios perturbados por ruído de mercado."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.3",
                        "name": "Sensibilidade de Autovalores Múltiplos",
                        "description": "Análise da sensibilidade em clusters de autovalores múltiplos ou próximos, abordando déficits e teoremas específicos para multiplicidade algébrica.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.3.1",
                            "name": "Diferenciar sensibilidade em autovalores múltiplos",
                            "description": "Explicar por que autovalores múltiplos podem ser mais sensíveis e definir o déficit de geometricidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos básicos de autovalores e multiplicidades",
                                  "subSteps": [
                                    "Defina autovalor λ e autovetor v para uma matriz A.",
                                    "Explique multiplicidade algébrica (raiz da característica) vs. geométrica (dimensão do eigenspace).",
                                    "Classifique autovalores como simples (mult. alg. = 1) ou múltiplos (mult. alg. > 1).",
                                    "Introduza o conceito de matriz diagonalizável (geo mult = alg mult para todos λ).",
                                    "Calcule multiplicidades para uma matriz exemplo 2x2."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre multiplicidades algébrica e geométrica, com um exemplo numérico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Álgebra Linear (ex: Strang), calculadora ou Python/MATLAB para polinômio característico.",
                                  "tips": "Sempre compute o polinômio característico primeiro para confirmar multiplicidades.",
                                  "learningObjective": "Entender as bases teóricas de autovalores múltiplos.",
                                  "commonMistakes": "Confundir multiplicidade algébrica com geométrica sem verificar dim(ker(A-λI))."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar sensibilidade de autovalores simples",
                                  "subSteps": [
                                    "Lembre o teorema de Bauer-Fike: |λ̃ - λ| ≤ cond(V) * ||E|| para perturbação E.",
                                    "Mostre que para autovalores simples, a sensibilidade é bounded por 1/gap (separação espectral).",
                                    "Perturbe numericamente uma matriz com autovalor simples e observe o erro.",
                                    "Compare com autovalores isolados (grande gap espectral).",
                                    "Discuta o papel da matriz de autovetores V na condição."
                                  ],
                                  "verification": "Perturbe uma matriz 2x2 com autovalor simples e calcule o erro relativo < 10^-10 para ||E||=10^-12.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software numérico (MATLAB/Python com numpy/scipy), matrizes de teste.",
                                  "tips": "Use perturbações pequenas (10^-12) para simular erro de arredondamento.",
                                  "learningObjective": "Compreender por que autovalores simples são menos sensíveis.",
                                  "commonMistakes": "Ignorar o gap espectral, achando que cond(V) é o único fator."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar sensibilidade em autovalores múltiplos e déficit de geometricidade",
                                  "subSteps": [
                                    "Defina déficit de geometricidade δ(λ) = mult_alg(λ) - mult_geo(λ).",
                                    "Explique que δ > 0 implica Jordan blocks, aumentando sensibilidade.",
                                    "Estude Wilkinson's theorem: sensibilidade ~ 1/|λ_i - λ_j|^k onde k depende de δ.",
                                    "Mostre que clusters de autovalores múltiplos têm gap pequeno, amplificando erros.",
                                    "Derive qualitativamente por que δ reduz a robustez da decomposição espectral."
                                  ],
                                  "verification": "Explique em 3 frases por que autovalores múltiplos com δ>0 são mais sensíveis que simples.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Referências: Golub-Van Loan 'Matrix Computations', caderno para derivações.",
                                  "tips": "Visualize com blocos de Jordan: perturbações 'quebram' a estrutura diagonal.",
                                  "learningObjective": "Diferenciar mecanismos de sensibilidade para autovalores múltiplos.",
                                  "commonMistakes": "Atribuir toda sensibilidade ao gap sem considerar δ."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar com exemplos numéricos e comparações",
                                  "subSteps": [
                                    "Construa matriz diagonalizável com λ duplo (δ=0) e perturbe.",
                                    "Construa matriz com Jordan block 2x2 (δ=1) e compare erros.",
                                    "Use exemplo 3x3 com cluster de autovalores múltiplos.",
                                    "Compute índices de condição para eigenspaces.",
                                    "Gráficos de erro vs. tamanho da perturbação."
                                  ],
                                  "verification": "Gere plots mostrando erro 10x maior para δ>0 vs. δ=0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python (numpy.linalg.eig, matplotlib), ou MATLAB.",
                                  "tips": "Escolha matrizes com λ=1 duplo para simplicidade.",
                                  "learningObjective": "Aplicar teoria em experimentos controlados.",
                                  "commonMistakes": "Usar autovalores reais em matrizes complexas sem normalizar."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e diferenciar casos de sensibilidade",
                                  "subSteps": [
                                    "Resuma: simples < múltiplos diagonalizáveis < defeituosos (δ>0).",
                                    "Defina formalmente: autovalores múltiplos mais sensíveis devido a gap pequeno + δ.",
                                    "Discuta implicações computacionais (ex: QR algorithm).",
                                    "Crie tabela comparativa de sensibilidade.",
                                    "Resolva exercício: classifique sensibilidade de uma matriz dada."
                                  ],
                                  "verification": "Crie tabela comparando 3 matrizes com diferentes δ e gaps.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha ou LaTeX para tabela.",
                                  "tips": "Sempre quantifique com índices de condição cond_2(V).",
                                  "learningObjective": "Diferenciar e explicar sensibilidade de forma integrada.",
                                  "commonMistakes": "Generalizar sem exemplos quantitativos."
                                }
                              ],
                              "practicalExample": "Considere A = [[1,1],[0,1]] (Jordan block, λ=1 duplo, δ=1). Perturbe com E=10^-10*[[0,0],[1,0]], resultando em autovalores ~1 ± 10^-5, erro relativo ~10^-5, vs. A_diag=[[1,0],[0,1]] com erro ~10^-10.",
                              "finalVerifications": [
                                "Explique verbalmente por que δ>0 aumenta sensibilidade.",
                                "Compute δ para uma matriz 3x3 aleatória.",
                                "Compare erros numéricos para δ=0 vs δ=1.",
                                "Defina gap espectral e seu papel em clusters.",
                                "Resolva: 'Por que autovalores múltiplos reais podem se tornar complexos sob perturbação?'",
                                "Crie diagrama de fluxo para diagnosticar sensibilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de δ (correta e formal).",
                                "Explicação causal clara (gap + δ → sensibilidade).",
                                "Exemplos numéricos com cálculos verificáveis.",
                                "Uso correto de teoremas (Bauer-Fike, Wilkinson).",
                                "Diferenciação qualitativa/quantitativa entre casos.",
                                "Aplicação a novos problemas sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Estabilidade de algoritmos eig.",
                                "Física Computacional: Modos normais em sistemas com degenerescências.",
                                "Machine Learning: Sensibilidade em PCA/SVD com autovalores próximos.",
                                "Otimização: Condição de Hessianas com autovalores múltiplos."
                              ],
                              "realWorldApplication": "Em engenharia estrutural, autovalores múltiplos em análises modais indicam modos degenerados sensíveis a imperfeições de fabricação, levando a erros em predições de vibração; δ alto sinaliza necessidade de refinamento numérico ou redesign."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.3.3.2",
                            "name": "Aplicar teoremas de sensibilidade para multiplicidade",
                            "description": "Usar resultados como o teorema de Lidskii ou Davis-Kahan para boundar variações em subespaços invariantes sob perturbações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar teoremas fundamentais de sensibilidade",
                                  "subSteps": [
                                    "Estude o teorema de Lidskii: para matrizes normais, a diferença entre autovalores é bounded pela norma da perturbação.",
                                    "Analise o teorema de Davis-Kahan: bounda o ângulo entre subespaços invariantes sob perturbações.",
                                    "Identifique hipóteses comuns: matrizes hermitianas ou normais, perturbações pequenas.",
                                    "Derive provas simplificadas para autovalores múltiplos.",
                                    "Compare Lidskii e Davis-Kahan em termos de aplicações a multiplicidade."
                                  ],
                                  "verification": "Resuma em 3-5 sentenças os teoremas e forneça uma citação ou referência exata.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Matrix Perturbation Theory' de Stewart e Sun (cap. 11)",
                                    "Notas de aula sobre álgebra linear avançada",
                                    "Artigo original de Davis-Kahan (1970)"
                                  ],
                                  "tips": [
                                    "Use representações matriciais para visualizar bounds.",
                                    "Foquem em normas de Frobenius e espectral para intuição."
                                  ],
                                  "learningObjective": "Compreender precisamente os teoremas de Lidskii e Davis-Kahan e suas hipóteses para autovalores múltiplos.",
                                  "commonMistakes": [
                                    "Confundir bounds para autovalores simples vs. múltiplos.",
                                    "Ignorar que Davis-Kahan aplica a subespaços, não vetores individuais."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender subespaços invariantes e perturbações",
                                  "subSteps": [
                                    "Defina subespaço invariante para autovalor múltiplo: espaço spanned pelos autovetores associados.",
                                    "Modele perturbações: E = A + ΔA, com ||ΔA|| pequeno.",
                                    "Calcule separação espectral: gap entre cluster de autovalores múltiplos e o resto do espectro.",
                                    "Visualize geometricamente: como perturbações rotacionam subespaços.",
                                    "Exercite com matriz 3x3 diagonal com autovalor duplo perturbado."
                                  ],
                                  "verification": "Construa um exemplo 2x2 e compute subespaço antes/depois da perturbação.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software MATLAB/Python (NumPy/SciPy)",
                                    "Matriz de exemplo impressa ou digital",
                                    "Tutorial sobre eigendecomposição"
                                  ],
                                  "tips": [
                                    "Sempre normalize vetores para comparar ângulos.",
                                    "Use sinθ para medir desvio angular."
                                  ],
                                  "learningObjective": "Modelar perturbações em subespaços invariantes e identificar gaps espectrais.",
                                  "commonMistakes": [
                                    "Esquecer de considerar multiplicidade algébrica vs. geométrica.",
                                    "Usar norma errada (L1 em vez de 2)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar teoremas para boundar variações",
                                  "subSteps": [
                                    "Aplique Lidskii: bound ||λ_i - μ_i|| ≤ ||ΔA||_2 para autovalores ordenados.",
                                    "Use Davis-Kahan: ||sinΘ|| ≤ ||ΔA||_2 / δ, onde δ é o gap espectral.",
                                    "Para multiplicidade m, agrupe em cluster e aplique a subespaços de dim m.",
                                    "Derive bound explícito para variação de subespaço projetado.",
                                    "Teste em exemplo: compute bound teórico vs. variação numérica real."
                                  ],
                                  "verification": "Para uma matriz dada, calcule bound e verifique se variação observada ≤ bound.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código Python para eigvals/subspaces",
                                    "Matrizes de teste (ex: Jordan block perturbado)",
                                    "Calculadora simbólica (SymPy)"
                                  ],
                                  "tips": [
                                    "Ordene autovalores por magnitude real para clusters.",
                                    "Verifique hipóteses antes de aplicar."
                                  ],
                                  "learningObjective": "Aplicar teoremas para obter bounds quantitativos em variações de autovalores e subespaços.",
                                  "commonMistakes": [
                                    "Aplicar Davis-Kahan sem gap espectral positivo.",
                                    "Confundir norma da perturbação com norma do resíduo."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar numericamente e interpretar resultados",
                                  "subSteps": [
                                    "Implemente em código: gere A, perturbe, compute eigendecomposições.",
                                    "Meça erros: distância Hausdorff para subespaços, diferenças de autovalores.",
                                    "Compare bounds teóricos com erros numéricos em diferentes níveis de perturbação.",
                                    "Analise sensibilidade: plote erro vs. ||ΔA||.",
                                    "Discuta limitações: quando bounds são sharp ou conservadores."
                                  ],
                                  "verification": "Gere gráfico mostrando bound vs. erro real para 5 perturbações crescentes.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Jupyter Notebook",
                                    "Bibliotecas SciPy/NumPy/Matplotlib",
                                    "Dados de benchmark de matrizes"
                                  ],
                                  "tips": [
                                    "Use cond number para prever ill-conditioning.",
                                    "Teste com matrizes não-simétricas."
                                  ],
                                  "learningObjective": "Validar teoremas numericamente e interpretar bounds no contexto prático.",
                                  "commonMistakes": [
                                    "Erros de precisão numérica mascarando bounds.",
                                    "Ignorar round-off em computações de subespaços."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a matriz A = diag(1,1,2) (autovalor múltiplo 1 com multiplicidade 2). Perturbe com ΔA de norma 0.1. Use Davis-Kahan para boundar o ângulo do subespaço span{e1,e2} após perturbação, com gap δ=1. Compute: ||sinΘ|| ≤ 0.1/1 = 0.1. Verifique numericamente em Python.",
                              "finalVerifications": [
                                "Deriva corretamente o bound de Davis-Kahan para um cluster de autovalores múltiplos.",
                                "Identifica gap espectral e verifica hipóteses dos teoremas.",
                                "Implementa código que computa variações reais vs. bounds teóricos.",
                                "Interpreta quando bounds são tight ou loose.",
                                "Aplica a uma matriz não-diagonalizável (bloco Jordan).",
                                "Discute impacto de normas diferentes (2 vs. Frobenius)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de bounds (erro <5%).",
                                "Correta identificação de subespaços invariantes.",
                                "Validação numérica com gráficos comparativos.",
                                "Explicação clara de limitações e hipóteses.",
                                "Criatividade em exemplos personalizados.",
                                "Proficiência em software para análise sensível."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de modos normais em vibrações sob ruído.",
                                "Engenharia de Controle: Estabilidade de polos múltiplos em sistemas lineares.",
                                "Aprendizado de Máquina: Sensibilidade em PCA/SVD para dados ruidosos.",
                                "Computação Quântica: Perturbações em Hamiltonianos degenerados."
                              ],
                              "realWorldApplication": "Em simulações de engenharia estrutural, bounds de Davis-Kahan quantificam como ruído de medição afeta subespaços de modos vibracionais múltiplos, garantindo segurança em designs de pontes ou aviões."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.5.3.3.3",
                            "name": "Analisar exemplos de matrizes com autovalores múltiplos",
                            "description": "Estudar matrizes Jordan perturbadas e computar numericamente a separação de autovalores múltiplos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Formas de Jordan e Autovalores Múltiplos",
                                  "subSteps": [
                                    "Defina autovalor múltiplo e sua multiplicidade algébrica e geométrica.",
                                    "Explique a estrutura de uma matriz de Jordan para autovalores múltiplos.",
                                    "Estude exemplos simples de matrizes Jordan com blocos de tamanho 2x2 e 3x3.",
                                    "Calcule manualmente autovalores e autovetores para uma matriz Jordan básica.",
                                    "Identifique a diferença entre diagonalizável e não-diagonalizável."
                                  ],
                                  "verification": "Resolva um exercício simples: encontre a forma de Jordan de uma matriz 3x3 com autovalor duplo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang), notebook para anotações, calculadora matricial online"
                                  ],
                                  "tips": "Visualize blocos Jordan como cadeias de autovetores generalizados para melhor compreensão.",
                                  "learningObjective": "Compreender a representação canônica de matrizes com autovalores múltiplos.",
                                  "commonMistakes": [
                                    "Confundir multiplicidade algébrica com geométrica",
                                    "Ignorar blocos Jordan maiores que 1x1"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Perturbações em Matrizes Jordan",
                                  "subSteps": [
                                    "Aprenda o conceito de perturbação εE em uma matriz Jordan J.",
                                    "Estude o teorema de separação de autovalores para perturbações.",
                                    "Derive a fórmula aproximada para a separação de autovalores múltiplos: O(√|ε|).",
                                    "Analise como o tamanho do bloco Jordan afeta a sensibilidade.",
                                    "Compare perturbações em autovalores simples vs. múltiplos."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que autovalores múltiplos são mais sensíveis a perturbações.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Artigos sobre análise de sensibilidade (ex: Stewart's papers), software simbólico como SymPy"
                                  ],
                                  "tips": "Use expansões em série de Taylor para perturbações pequenas para intuição.",
                                  "learningObjective": "Entender os efeitos de perturbações pequenas em estruturas Jordan.",
                                  "commonMistakes": [
                                    "Assumir que todos os autovalores múltiplos se comportam como simples",
                                    "Negligenciar o índice do bloco Jordan"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Computação Numérica de Separação",
                                  "subSteps": [
                                    "Instale bibliotecas numéricas (NumPy, SciPy ou MATLAB).",
                                    "Escreva código para gerar uma matriz Jordan perturbada: J + εE.",
                                    "Compute autovalores numericamente para vários valores de ε.",
                                    "Plote a separação dos autovalores em função de ε.",
                                    "Calcule a taxa de separação e compare com a teoria O(√|ε|)."
                                  ],
                                  "verification": "Execute o código e produza um gráfico mostrando convergência para ε→0.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy/Matplotlib, Jupyter Notebook, exemplos de código online"
                                  ],
                                  "tips": "Use ε de 10^-1 a 10^-10 para observar o comportamento assintótico.",
                                  "learningObjective": "Desenvolver habilidades computacionais para análise numérica de sensibilidade.",
                                  "commonMistakes": [
                                    "Escolha inadequada de ε levando a erros numéricos",
                                    "Não normalizar a perturbação E"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Exemplos Específicos e Interpretar Resultados",
                                  "subSteps": [
                                    "Selecione um exemplo: matriz Jordan 4x4 com dois blocos para λ=0.",
                                    "Perturbe com matrizes aleatórias E e compute separações.",
                                    "Compare resultados teóricos e numéricos.",
                                    "Analise impacto de diferentes tamanhos de blocos.",
                                    "Discuta limitações numéricas e condicionar da matriz."
                                  ],
                                  "verification": "Relatório curto com gráficos e conclusões para 2-3 exemplos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Mesmo ambiente computacional do step 3, papel para esboços"
                                  ],
                                  "tips": "Varie o tipo de perturbação (diagonal, aleatória) para insights adicionais.",
                                  "learningObjective": "Aplicar conceitos a casos concretos e interpretar discrepâncias.",
                                  "commonMistakes": [
                                    "Interpretação errada de plots em escala log",
                                    "Ignorar precisão de máquina"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Verificar Compreensão",
                                  "subSteps": [
                                    "Resuma os fatores que influenciam a separação de autovalores múltiplos.",
                                    "Resolva problemas variados misturando teoria e computação.",
                                    "Crie seu próprio exemplo de matriz perturbada.",
                                    "Avalie a sensibilidade em contexto maior de autovalores defeituosos.",
                                    "Prepare para discussões ou autoavaliação."
                                  ],
                                  "verification": "Auto-teste com 3 problemas independentes resolvidos corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Exercícios de livros ou online (ex: MIT OCW Álgebra Linear)"
                                  ],
                                  "tips": "Ensine o conceito a alguém ou grave um vídeo explicativo para reforço.",
                                  "learningObjective": "Integrar teoria, computação e análise crítica.",
                                  "commonMistakes": [
                                    "Generalizar demais de um único exemplo",
                                    "Esquecer normalização de normas"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a matriz Jordan J = [[0,1,0],[0,0,1],[0,0,0]] (bloco 3x3 para λ=0). Perturbe com εE onde E=[[1,0,0],[0,1,0],[0,0,1]] e ε=0.01. Compute autovalores de J+εE usando SciPy: espere separação ~√0.01=0.1, verifique numericamente e plote para ε variando de 0.1 a 10^-6.",
                              "finalVerifications": [
                                "Explica corretamente a dependência O(√|ε|) para separação.",
                                "Implementa código que plota separação vs. ε com boa precisão.",
                                "Identifica tamanho do bloco Jordan em uma matriz dada.",
                                "Compara sensibilidade de autovalores simples vs. múltiplos.",
                                "Analisa limitações numéricas em um exemplo concreto.",
                                "Cria e resolve um exemplo próprio."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: entendimento de Jordan e perturbações (30%)",
                                "Habilidade computacional: código correto e plots informativos (30%)",
                                "Análise qualitativa: interpretação de resultados (20%)",
                                "Criatividade: exemplos originais e variações (10%)",
                                "Clareza de comunicação: relatórios e explicações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de modos normais em sistemas vibratórios com degenerescências.",
                                "Engenharia: Estabilidade de controladores lineares com polos múltiplos.",
                                "Ciência de Dados: Análise de PCA com autovalores próximos em dados ruidosos.",
                                "Computação: Condicionamento numérico em algoritmos de autovalores (QR).",
                                "Estatística: Sensibilidade em análise de componentes principais."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, analisar a sensibilidade de autovalores múltiplos em modelos de dinâmica de fluidos garante estabilidade preditiva sob ruído de medição; em machine learning, ajuda a diagnosticar instabilidades em decomposições espectrais de matrizes de covariância grandes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.4",
                    "name": "Sensibilidade de Autovetores",
                    "description": "Análise da estabilidade e variação de autovetores em matrizes perturbadas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.4.1",
                        "name": "Perturbação de Autovetores Simples",
                        "description": "Análise da variação de autovetores associados a autovalores simples quando a matriz é perturbada por uma pequena matriz de erro.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.1.1",
                            "name": "Calcular a variação aproximada de um autovetor simples",
                            "description": "Derivar e aplicar a fórmula de primeira ordem para a perturbação de autovetores simples: δv ≈ (A - λI)^† E v / gap, onde gap é a separação mínima dos autovalores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes da fórmula de perturbação",
                                  "subSteps": [
                                    "Defina autovetor simples e autovalor simples em uma matriz diagonalizável.",
                                    "Explique o conceito de perturbação E em uma matriz A, onde A + E é a matriz perturbada.",
                                    "Descreva o pseudoinverso de Moore-Penrose (A - λI)^† e sua relação com o espaço nulo.",
                                    "Identifique o gap como a separação mínima entre o autovalor λ e os demais autovalores.",
                                    "Interprete δv como a correção de primeira ordem no autovetor v."
                                  ],
                                  "verification": "Liste e explique corretamente cada termo da fórmula δv ≈ (A - λI)^† E v / gap.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas de álgebra linear",
                                    "Exemplo de matriz 2x2 diagonalizável",
                                    "Calculadora ou software como MATLAB/Octave"
                                  ],
                                  "tips": "Verifique se o autovalor é simples para garantir que o pseudoinverso exista no espaço ortogonal a v.",
                                  "learningObjective": "Identificar e explicar todos os componentes matemáticos da fórmula de perturbação.",
                                  "commonMistakes": "Confundir pseudoinverso com inverso regular ou ignorar que v está no kernel de (A - λI)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a fórmula de primeira ordem para perturbação de autovetores",
                                  "subSteps": [
                                    "Comece com a equação de autovalor exata: (A + E)(v + δv) = λ(v + δv) + O(‖E‖²).",
                                    "Subtraia Av = λv e isole termos de primeira ordem: E v + A δv ≈ λ δv.",
                                    "Projete ortogonalmente a v: δv ⊥ v, então (A - λI) δv ≈ -P E v, onde P é projeção ortogonal a v.",
                                    "Aplique o pseudoinverso: δv ≈ -(A - λI)^† P E v.",
                                    "Incorpore o gap para normalização e simplifique para δv ≈ (A - λI)^† E v / gap."
                                  ],
                                  "verification": "Escreva a derivação passo a passo e confirme que chega à fórmula dada.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis para derivação",
                                    "Referência: Livro de Álgebra Linear Numérica (ex: Golub-Van Loan)",
                                    "Software simbólico como SymPy"
                                  ],
                                  "tips": "Mantenha ordens de grandeza: ignore termos O(‖E‖²) desde o início.",
                                  "learningObjective": "Derivar rigorosamente a aproximação de primeira ordem para δv.",
                                  "commonMistakes": "Esquecer a projeção ortogonal a v ou não dividir pelo gap corretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular pseudoinverso, gap e aplicar a fórmula",
                                  "subSteps": [
                                    "Para uma matriz A dada, compute autovalores e autovetores; selecione λ simples e v.",
                                    "Calcule o gap: min|λ - μ| para μ ≠ λ.",
                                    "Construa B = A - λI e compute seu pseudoinverso B^† (usando SVD ou fórmula para low-rank).",
                                    "Dada perturbação E, calcule E v e então B^† (E v).",
                                    "Divida pelo gap para obter δv aproximado e normalize se necessário."
                                  ],
                                  "verification": "Compare δv aproximado com autovetor exato da matriz perturbada A + E.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": [
                                    "Software numérico: Python (NumPy/SciPy) ou MATLAB",
                                    "Matriz exemplo 2x2 ou 3x3",
                                    "Tabela para registrar valores"
                                  ],
                                  "tips": "Use SVD para pseudoinverso: pinv(B) = V Σ^+ U^T.",
                                  "learningObjective": "Implementar computacionalmente todos os elementos da fórmula.",
                                  "commonMistakes": "Usar inverso em vez de pseudoinverso, levando a resultados inconsistentes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e validar a variação aproximada",
                                  "subSteps": [
                                    "Compare ‖δv‖ com ‖E‖ para verificar linearidade da aproximação.",
                                    "Analise como o gap afeta a sensibilidade: gap pequeno implica δv grande.",
                                    "Teste com diferentes E e observe direção de δv.",
                                    "Valide numericamente resolvendo autovalor exato de A + E e comparando.",
                                    "Discuta limitações: validade para perturbações pequenas e autovalores simples."
                                  ],
                                  "verification": "A aproximação tem erro relativo < 5% para ‖E‖ pequeno.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código Python/MATLAB do passo anterior",
                                    "Gráficos de erro vs. ‖E‖"
                                  ],
                                  "tips": "Plote ‖δv_exato - δv_aprox‖ / ‖δv_exato‖ vs. tamanho de E.",
                                  "learningObjective": "Avaliar precisão e interpretar sensibilidade de autovetores.",
                                  "commonMistakes": "Aplicar fórmula para autovalores múltiplos ou perturbações grandes."
                                }
                              ],
                              "practicalExample": "Considere A = [[2, 0], [0, 1]], λ=2, v=[1, 0]^T (gap=1). Perturbe com E = [[0, 0.1], [0, 0]]. Calcule (A - λI) = [[0,0],[0,-1]], pseudoinverso [[0,0],[0,-1]], E v = [0, 0]^T (erro, ajuste E=[[0,0.1],[0,0]] -> Ev=[0.1, 0]^T), δv ≈ [[0,0],[0,-1]] [0.1,0]^T /1 = [0, -0.1]^T. Autovetor exato de A+E ≈ [1, -0.099]^T, boa aproximação.",
                              "finalVerifications": [
                                "Derivação da fórmula está correta e completa.",
                                "Pseudoinverso calculado via SVD ou analiticamente sem erros.",
                                "δv aproximado coincide com exato dentro de 5% para ‖E‖=0.01.",
                                "Gap identificado corretamente como separação mínima.",
                                "Interpretação inclui dependência em 1/gap.",
                                "Código numérico reproduz resultados manualmente."
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação (rubrica: 30%)",
                                "Correção numérica do pseudoinverso e δv (25%)",
                                "Validação comparativa com solução exata (20%)",
                                "Interpretação qualitativa da sensibilidade (15%)",
                                "Clareza na documentação e gráficos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física Quântica: Teoria de perturbação não-degenerada em mecânica quântica.",
                                "Engenharia: Análise de sensibilidade em controle de sistemas dinâmicos.",
                                "Ciência de Dados: Estabilidade de componentes principais em PCA.",
                                "Computação Científica: Erros de arredondamento em métodos iterativos."
                              ],
                              "realWorldApplication": "Em machine learning, avalia a robustez de autovetores em PCA perante ruído nos dados, essencial para feature extraction em imagens ou sensores; em engenharia estrutural, mede sensibilidade de modos de vibração a variações materiais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.2",
                            "name": "Interpretar o condicionamento de autovetores simples",
                            "description": "Avaliar o fator de condicionamento cond(v) = 1 / |y^* v|, onde y é o autovetor à esquerda, e relacioná-lo com a sensibilidade à perturbação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender autovetores à direita e à esquerda",
                                  "subSteps": [
                                    "Defina autovetor à direita: Av = λv.",
                                    "Defina autovetor à esquerda: y^* A = λ y^*, onde y^* é o transposto conjugado.",
                                    "Explique a biortogonalidade: y^* v = 1 para autovetores normalizados.",
                                    "Discuta normalização: |v| = 1 e y normalizado tal que y^* v = 1.",
                                    "Identifique diferenças em matrizes não simétricas."
                                  ],
                                  "verification": "Resuma as definições em suas palavras e dê um exemplo de matriz 2x2 com autovetores distintos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Álgebra Linear (ex: Strang), calculadora ou software como MATLAB/Python (NumPy).",
                                  "tips": "Visualize graficamente para matrizes 2x2: direções invariantes.",
                                  "learningObjective": "Distinguir autovetores à esquerda e à direita e sua biortogonalidade.",
                                  "commonMistakes": "Confundir esquerda com direita; esquecer conjugado transposto para complexos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a fórmula do fator de condicionamento cond(v)",
                                  "subSteps": [
                                    "Apresente a fórmula: cond(v) = 1 / |y^* v|.",
                                    "Explique por que y é o autovetor à esquerda associado.",
                                    "Discuta normalização: assumir y^* v = 1 para cond(v) = 1.",
                                    "Relacione com norma: cond(v) mede quão pequeno é |y^* v|.",
                                    "Derive intuitivamente: pequeno y^* v implica alta sensibilidade."
                                  ],
                                  "verification": "Escreva a fórmula e explique seu significado em uma frase.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Notas de aula sobre análise de sensibilidade, papel e caneta.",
                                  "tips": "Pense em cond(v) como recíproco da 'sobreposição' entre y e v.",
                                  "learningObjective": "Memorizar e interpretar a fórmula cond(v) = 1 / |y^* v|.",
                                  "commonMistakes": "Usar autovetor à direita no lugar de y; ignorar normalização."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular cond(v) em um exemplo prático",
                                  "subSteps": [
                                    "Escolha matriz A = [[3, 1], [0, 2]]; encontre autovalores λ1=3, λ2=2.",
                                    "Calcule v1 = [1, 0]^T para λ1 (direita).",
                                    "Encontre y1 à esquerda: resolva y^* (A - 3I) = 0, y1 = [1, -1]^T, normalize y1^* v1 = 1.",
                                    "Calcule |y1^* v1| e cond(v1) = 1 / |y1^* v1|.",
                                    "Repita para λ2."
                                  ],
                                  "verification": "Mostre cálculos completos com cond(v1) ≈ 1 e cond(v2) >1.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python com NumPy ou MATLAB para eigendecomposição.",
                                  "tips": "Use scipy.linalg.eig para autovetores à esquerda (esquerda=True).",
                                  "learningObjective": "Aplicar a fórmula computacionalmente em uma matriz não simétrica.",
                                  "commonMistakes": "Erro em normalização; confundir ordens de autovalores."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar cond(v) com sensibilidade à perturbação",
                                  "subSteps": [
                                    "Explique: alto cond(v) significa v sensível a perturbações em A.",
                                    "Discuta fórmula de perturbação: δv ≈ cond(v) * (perturbação) / gap_autovalores.",
                                    "Compare: cond(v)=1 implica baixa sensibilidade.",
                                    "Analise exemplo: perturbe A e observe mudança em v.",
                                    "Conclua: cond(v) quantifica amplificação de erros."
                                  ],
                                  "verification": "Perturbe A numericamente e meça ||δv|| / ||δA|| ≈ cond(v).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código Python para perturbação aleatória (numpy.random).",
                                  "tips": "Use perturbações pequenas (1e-6) para aproximação linear.",
                                  "learningObjective": "Interpretar cond(v) como medida de sensibilidade.",
                                  "commonMistakes": "Ignorar gap entre autovalores; superestimar para matrizes simétricas."
                                }
                              ],
                              "practicalExample": "Para A = [[3,1],[0,2]], v1=[1,0] (λ=3), y1=[1,-1]/1 normalizado tal y1^* v1=1, cond(v1)=1. Perturbe A para [[3,1+ε],[0,2]], observe v1 muda pouco se cond baixo.",
                              "finalVerifications": [
                                "Calcule cond(v) corretamente para nova matriz 2x2.",
                                "Explique verbalmente o impacto de cond(v)>10 em sensibilidade.",
                                "Identifique autovetor à esquerda em código.",
                                "Relacione cond(v) com estabilidade numérica.",
                                "Dê exemplo onde cond(v) alto causa problemas práticos.",
                                "Compare cond(v) para dois autovetores da mesma matriz."
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula cond(v) = 1 / |y^* v|.",
                                "Correta identificação de y como autovetor à esquerda.",
                                "Cálculo numérico exato com normalização.",
                                "Interpretação qualitativa: alto cond → alta sensibilidade.",
                                "Uso de exemplo com perturbação para validar.",
                                "Clareza na relação com gap de autovalores."
                              ],
                              "crossCurricularConnections": [
                                "Física: Sensibilidade em modos normais de vibração (matrizes não simétricas).",
                                "Engenharia: Estabilidade em controle de sistemas dinâmicos.",
                                "Ciência de Dados: Robustez em PCA ou decomposição espectral.",
                                "Computação: Análise de erro em métodos iterativos (ex: power method)."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, avalia sensibilidade de autovetores em modelos de flutter (instabilidade); alto cond(v) indica necessidade de refinamento do modelo para evitar falhas catastróficas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.3",
                            "name": "Aplicar teorema de Bauer-Fike para autovetores",
                            "description": "Usar extensões do teorema de Bauer-Fike para estimar a distância entre autovetores perturbados em norma espectral.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Teorema de Bauer-Fike e sua Extensão para Autovetores",
                                  "subSteps": [
                                    "Ler a declaração precisa do teorema de Bauer-Fike para autovalores: para A + E, |λ̃ - λ| ≤ ||E||₂.",
                                    "Estudar a extensão para autovetores simples: sin θ(u, ũ) ≤ (||E||₂ / sep(λ)) * κ(V), onde sep é a separação espectral e κ(V) é a condição da matriz de autovetores.",
                                    "Identificar premissas: autovetor simples (multiplicidade algébrica 1), normas espectrais (||.||₂).",
                                    "Derivar intuitivamente por que a bound depende da perturbação E, separação e condicionamento.",
                                    "Comparar com bound para autovalores para contextualizar."
                                  ],
                                  "verification": "Resumir verbalmente ou por escrito as premissas e a fórmula da bound para autovetores, sem consultar notas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Matrix Computations' de Golub & Van Loan (Cap. 11)",
                                    "Notas de aula sobre perturbações espectrais",
                                    "Calculadora simbólica como SymPy ou Mathematica"
                                  ],
                                  "tips": "Visualize geometricamente: a perturbação 'desalinhada' autovetores quanto menor a separação.",
                                  "learningObjective": "Dominar a declaração exata e premissas da extensão do teorema para autovetores perturbados.",
                                  "commonMistakes": [
                                    "Confundir norma espectral com norma de Frobenius.",
                                    "Ignorar que aplica só a autovetores simples.",
                                    "Esquecer fator de condicionamento κ(V)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o Problema de Perturbação Espectral",
                                  "subSteps": [
                                    "Dada matriz A diagonalizável com autovetor u simples para λ, definir perturbação E com ||E||₂ conhecida.",
                                    "Computar matriz de autovetores V e seus autovalores Λ.",
                                    "Calcular separação espectral sep(λ) = min_{μ≠λ} |λ - μ|.",
                                    "Avaliar condicionamento κ₂(V) = ||V||₂ ||V⁻¹||₂.",
                                    "Identificar ũ como autovetor aproximado de A + E."
                                  ],
                                  "verification": "Montar um exemplo simples (2x2) e listar todos os valores: sep(λ), κ(V), ||E||₂ corretamente calculados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software numérico: MATLAB, Python (NumPy/SciPy)",
                                    "Matriz de exemplo impressa ou digital"
                                  ],
                                  "tips": "Use eig() no software para validar computações exatas em casos pequenos.",
                                  "learningObjective": "Preparar todos os componentes quantitativos necessários para aplicar a bound.",
                                  "commonMistakes": [
                                    "Usar norma errada (ex: ||E||_F ao invés de ||E||₂).",
                                    "Calcular sep com autovalores complexos incorretamente.",
                                    "Confundir κ(V) com trace(V)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Bound do Teorema para Estimar Distância entre Autovetores",
                                  "subSteps": [
                                    "Aplicar fórmula: sin θ(u, ũ) ≤ ||E||₂ * κ(V) / sep(λ).",
                                    "Calcular numericamente ||ũ - u|| ou ângulo θ usando inner product.",
                                    "Comparar bound teórica com distância computada para validar (deve satisfazer ≤).",
                                    "Analisar sensibilidade: como varia com ||E|| pequeno vs grande.",
                                    "Generalizar para múltiplos autovetores se aplicável."
                                  ],
                                  "verification": "Produzir cálculo escrito mostrando bound ≤ observada, com valores numéricos.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python script com funções eig, norm, cond",
                                    "Papel para derivações manuais"
                                  ],
                                  "tips": "Normalize autovetores para ||u||=||ũ||=1 antes de comparar.",
                                  "learningObjective": "Executar a aplicação prática da estimativa de perturbação em autovetores.",
                                  "commonMistakes": [
                                    "Não normalizar vetores antes de sin θ.",
                                    "Dividir por sep(λ)=0 (autovalor múltiplo).",
                                    "Esquecer multiplicar por κ(V)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Analisar Limitações",
                                  "subSteps": [
                                    "Interpretar bound: quão 'apertada' é? (ex: κ grande piora estimativa).",
                                    "Testar com exemplo onde bound é sharp (E alinhado com direção sensível).",
                                    "Discutir limitações: só para simples, norma 2, upper bound não tight sempre.",
                                    "Explorar refinamentos (ex: teoremas Davis-Kahan).",
                                    "Documentar relatório com gráficos de ||ũ - u|| vs ||E||."
                                  ],
                                  "verification": "Criar gráfico ou tabela mostrando variação da bound vs simulações.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Matplotlib/Plots para gráficos",
                                    "Relatório template LaTeX ou Markdown"
                                  ],
                                  "tips": "Varie ||E|| em loop para ver linearidade.",
                                  "learningObjective": "Avaliar validade prática e limitações do teorema em contextos reais.",
                                  "commonMistakes": [
                                    "Assumir bound é exata (é só upper).",
                                    "Ignorar efeitos de autovalores próximos.",
                                    "Não plotar para visualização intuitiva."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[3, 1], [1, 3]] com autovalores λ1=4 (u1=[1,1]/√2), λ2=2 (u2=[1,-1]/√2). Perturbe E = 0.01 * [[0,1],[0,0]], ||E||₂≈0.01. sep(λ1)=2, κ(V)=1. Bound: sin θ ≤ 0.01 *1 /2 = 0.005. Compute eig(A+E): ũ1 ≈ [0.9995, 0.7071+0.000035], sin θ ≈0.0035 < bound.",
                              "finalVerifications": [
                                "Reproduzir fórmula exata da bound para autovetores simples.",
                                "Aplicar corretamente a um problema 2x2 numérico, obtendo bound válida.",
                                "Identificar quando premissas falham (ex: autovetor múltiplo).",
                                "Comparar bound com distância real em pelo menos dois exemplos.",
                                "Explicar impacto de sep pequena na sensibilidade.",
                                "Gerar gráfico de sensibilidade vs ||E||."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática: fórmulas e cálculos corretos (90%+).",
                                "Compreensão conceitual: explicação clara de premissas e limitações.",
                                "Aplicação prática: código ou cálculos manuais sem erros.",
                                "Análise crítica: interpretação da 'apertada' da bound.",
                                "Criatividade: extensão a exemplo próprio ou refinamento.",
                                "Clareza de documentação: relatório legível com visualizações."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Estabilidade de algoritmos de decomposição espectral (QR algorithm).",
                                "Computação Científica: Análise de erros em simulações PDEs com eigenmodes.",
                                "Engenharia Mecânica: Sensibilidade de modos de vibração em estruturas perturbadas.",
                                "Física Quântica: Teoria de perturbação não-degenerada em mecânica quântica.",
                                "Machine Learning: Estabilidade de PCA/SVD em dados ruidosos."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, estima sensibilidade de modos de flutter em asas deformadas por fabricação; em finanças, analisa estabilidade de portfólios via autovetores de matriz de covariância perturbada por ruído de mercado; em Google PageRank, avalia robustez de autovetor principal a mudanças na web."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.2",
                        "name": "Sensibilidade em Autovetores Múltiplos",
                        "description": "Estudo da estabilidade de espaços invariantes e autovetores em clusters de autovalores múltiplos sob perturbações.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.2.1",
                            "name": "Analisar a variação de espaços invariantes",
                            "description": "Aplicar o teorema de Davis-Kahan: sin θ ≤ ||E|| / gap, onde θ é o ângulo canônico entre espaços invariantes originais e perturbados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Espaços Invariantes e Perturbações",
                                  "subSteps": [
                                    "Defina espaço invariante para uma matriz A como um subespaço V tal que A(V) ⊆ V.",
                                    "Explique o ângulo canônico θ entre dois subespaços U e V como o menor ângulo entre vetores u ∈ U e v ∈ V.",
                                    "Identifique o gap espectral como a distância mínima entre autovalores de clusters espectrais distintos.",
                                    "Discuta perturbações: dada A = A0 + E, onde E é pequena.",
                                    "Calcule exemplos simples de ângulos canônicos para subespaços de dimensão baixa."
                                  ],
                                  "verification": "Resuma os conceitos em um parágrafo coerente e compute θ para dois vetores ortogonais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta; notebook Jupyter com NumPy para cálculos vetoriais.",
                                  "tips": "Use visualizações geométricas para entender o ângulo canônico.",
                                  "learningObjective": "Compreender os componentes chave do teorema de Davis-Kahan.",
                                  "commonMistakes": "Confundir gap espectral com diferença de autovalores individuais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Enunciar e Interpretar o Teorema de Davis-Kahan",
                                  "subSteps": [
                                    "Enuncie o teorema: Para matrizes hermitianas A0 e A = A0 + E, sin θ ≤ ||E|| / gap, onde θ é o ângulo entre espaços invariantes.",
                                    "Especifique condições: clusters espectrais separados por gap > 0.",
                                    "Interprete ||E|| como norma espectral ou Frobenius.",
                                    "Discuta extensões para matrizes não-hermitianas.",
                                    "Derive intuitivamente a bound usando projeções ortogonais."
                                  ],
                                  "verification": "Escreva o teorema com notação precisa e explique cada termo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Referência ao paper original de Davis-Kahan ou notas de aula; calculadora simbólica como SymPy.",
                                  "tips": "Lembre-se: o teorema quantifica quão 'pouco' a perturbação afeta o espaço invariante.",
                                  "learningObjective": "Dominar a declaração precisa e interpretação do teorema.",
                                  "commonMistakes": "Usar norma errada para ||E|| (sempre especifique 2-norma para bound ótimo)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar ou Entender a Prova do Teorema",
                                  "subSteps": [
                                    "Considere projeções P e Q nos espaços invariantes de A0 e A.",
                                    "Use desigualdade: ||(I - P)Q|| ≤ ||E|| / gap via análise espectral.",
                                    "Aplique lemma de Weyl para controle de autovalores perturbados.",
                                    "Conclua com sin θ = ||(I - P)Q||.",
                                    "Verifique passos com igualdades em casos ideais (E=0)."
                                  ],
                                  "verification": "Reproduza a prova em outline e identifique passos chave.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Livro de álgebra linear numérica (e.g., Golub-Van Loan); MATLAB ou Python para simulações auxiliares.",
                                  "tips": "Foque na desigualdade trigonométrica sin θ ≈ θ para perturbações pequenas.",
                                  "learningObjective": "Internalizar a lógica da prova para aplicações futuras.",
                                  "commonMistakes": "Ignorar hipóteses de hermitiana ou gap positivo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o Teorema em um Exemplo Numérico",
                                  "subSteps": [
                                    "Construa A0 com autovalor múltiplo (e.g., bloco diagonal com autovalor 1 de mult. 2).",
                                    "Perturbe com E pequena e compute autovetores/autovalores de A.",
                                    "Calcule espaços invariantes e ângulo canônico θ numericamente.",
                                    "Verifique a bound sin θ ≤ ||E|| / gap.",
                                    "Varie ||E|| e gap para observar comportamento."
                                  ],
                                  "verification": "Gere plot de sin θ vs. ||E|| / gap mostrando a bound.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy/SciPy (eig, subspace angles); Matplotlib para plots.",
                                  "tips": "Use svd para ângulo canônico entre subespaços.",
                                  "learningObjective": "Aplicar o teorema computacionalmente com precisão.",
                                  "commonMistakes": "Erro numérico em dimensões altas; normalize vetores adequadamente."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Sensibilidade e Casos Especiais",
                                  "subSteps": [
                                    "Examine caso de gap pequeno: bound explode.",
                                    "Considere autovalores múltiplos não-defeituosos.",
                                    "Compare com bounds para autovetores individuais.",
                                    "Discuta implicações para algoritmos de eigendecomposição.",
                                    "Teste com matriz não-hermitiana usando variantes."
                                  ],
                                  "verification": "Responda: 'O que acontece se gap → 0?' com justificativa quantitativa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Mesmo ambiente computacional do step 4; referências adicionais.",
                                  "tips": "Sempre cheque condicão de gap na prática.",
                                  "learningObjective": "Interpretar limitações e extensões do teorema.",
                                  "commonMistakes": "Generalizar bound sem verificar hipóteses."
                                }
                              ],
                              "practicalExample": "Considere A0 = diag(1,1,2), E = 0.01 * randn(3,3). Compute espaço invariante span([1,0,0],[0,1,0]) para A0 e perturbado para A. Calcule θ ≈ 0.005 rad, gap=1, ||E||₂≈0.01, verificando sin θ ≤ 0.01/1.",
                              "finalVerifications": [
                                "Enuncie corretamente o teorema com todas as condições.",
                                "Compute θ e bound em um exemplo numérico com erro <1%.",
                                "Explique impacto de gap pequeno qualitativamente.",
                                "Identifique norma apropriada para ||E||.",
                                "Aplique a uma matriz 4x4 com mult. 2.",
                                "Discuta prova em 3 frases chave."
                              ],
                              "assessmentCriteria": [
                                "Precisão na declaração do teorema (100% match).",
                                "Correção numérica em exemplos (erro relativo <10^{-3}).",
                                "Profundidade na interpretação da bound.",
                                "Uso correto de normas e gaps.",
                                "Criatividade em exemplos personalizados.",
                                "Clareza em verificações e plots."
                              ],
                              "crossCurricularConnections": [
                                "Física Quântica: Perturbação degenerada em autovalores múltiplos.",
                                "Machine Learning: Sensibilidade em PCA/SVD para dados ruidosos.",
                                "Engenharia de Controle: Estabilidade de modos em sistemas dinâmicos.",
                                "Processamento de Sinais: Análise de espectro perturbado."
                              ],
                              "realWorldApplication": "Em simulações numéricas de engenharia estrutural, analisa como ruído em medições afeta modos vibracionais (espaços invariantes), garantindo designs robustos contra incertezas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.4.2.2",
                            "name": "Estimar erros em bases de autovetores múltiplos",
                            "description": "Calcular bounds para a perturbação ortogonal de subespaços invariantes usando decomposição SVD da perturbação projetada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender subespaços invariantes e perturbações ortogonais",
                                  "subSteps": [
                                    "Revise a definição de subespaço invariante para autovalores múltiplos em uma matriz A.",
                                    "Explique o conceito de perturbação ortogonal: E tal que as colunas de E são ortogonais às bases do subespaço.",
                                    "Defina a distância entre subespaços usando o ângulo principal ou norma do projetor.",
                                    "Estude o teorema de sensibilidade para subespaços invariantes sob perturbações.",
                                    "Identifique a projeção ortogonal P do subespaço invariante V."
                                  ],
                                  "verification": "Resuma em suas palavras o papel do subespaço invariante na sensibilidade de autovetores múltiplos e esboce a fórmula básica de bound.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear Computacional (ex: Golub-Van Loan)",
                                    "Papel e lápis para diagramas",
                                    "Notebook Jupyter com NumPy"
                                  ],
                                  "tips": "Visualize geometricamente: o subespaço como um plano e a perturbação como uma rotação mínima.",
                                  "learningObjective": "Dominar os fundamentos teóricos de subespaços invariantes e perturbações ortogonais.",
                                  "commonMistakes": "Confundir subespaço invariante com autovetor individual; ignorar a multiplicidade do autovalor."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar a perturbação no complemento ortogonal do subespaço",
                                  "subSteps": [
                                    "Construa a base ortonormal Q para o subespaço invariante V usando QR ou SVD.",
                                    "Calcule o projetor ortogonal P = Q Q^T para V.",
                                    "Projete a perturbação E no complemento: Ep = (I - P) E P.",
                                    "Verifique que Ep tem linhas e colunas no complemento de V.",
                                    "Implemente numericamente em Python usando np.dot e np.eye."
                                  ],
                                  "verification": "Compute Ep para uma matriz de exemplo e confirme que Q^T Ep = 0 e Ep Q = 0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Matriz de exemplo 4x4 com autovalor duplo"
                                  ],
                                  "tips": "Use np.linalg.qr para obter Q ortonormal de forma estável numericamente.",
                                  "learningObjective": "Saber projetar perturbações corretamente para isolar o componente relevante.",
                                  "commonMistakes": "Usar projeção errada (P E em vez de (I-P) E P); não normalizar Q."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar decomposição SVD da perturbação projetada",
                                  "subSteps": [
                                    "Aplique SVD a Ep: Ep = U Σ V^T, onde Σ contém valores singulares σ1 ≥ σ2 ≥ ...",
                                    "Identifique o maior valor singular σ1 como medida da perturbação efetiva.",
                                    "Relacione σ1 ao bound da perturbação do subespaço: sin θ ≤ σ1 / gap, onde gap é a separação espectral.",
                                    "Extraia os vetores singulares U e V para análise adicional.",
                                    "Teste condicional: verifique rank de Ep via valores singulares."
                                  ],
                                  "verification": "Execute SVD em Ep de exemplo e liste os três maiores σi; confirme σ1 domina o bound.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python SciPy: scipy.linalg.svd",
                                    "Exemplo numérico salvo do step anterior"
                                  ],
                                  "tips": "Use full_matrices=False em svd para eficiência em subespaços pequenos.",
                                  "learningObjective": "Executar e interpretar SVD para quantificar sensibilidade.",
                                  "commonMistakes": "Confundir valores singulares com autovalores; ignorar ordenação decrescente de σ."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular e interpretar bounds para a perturbação do subespaço",
                                  "subSteps": [
                                    "Recupere o gap espectral δ = min |λ_i - λ_j| para λ fora do múltiplo.",
                                    "Calcule o bound superior: ||sin Θ|| ≤ σ1(Ep) / δ.",
                                    "Estime o erro na base: ||ΔQ|| ≈ σ1(Ep) / δ.",
                                    "Compare com bounds inferiores usando menores σi.",
                                    "Valide com perturbação real: compute novo subespaço e meça distância."
                                  ],
                                  "verification": "Para exemplo, calcule bound teórico e compare com erro numérico real (< 1% diferença).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código Python integrado dos steps anteriores",
                                    "Função para distância de subespaço (ex: np.linalg.norm(P1 - P2))"
                                  ],
                                  "tips": "Sempre normalize o gap pelo ||A|| se não unitário; use cond(Ep) para robustez.",
                                  "learningObjective": "Aplicar fórmulas para obter bounds acionáveis e interpretá-los.",
                                  "commonMistakes": "Esquecer divisão pelo gap; usar norma errada (Frob vs 2-norma para sin Θ)."
                                }
                              ],
                              "practicalExample": "Considere A = [[2,0,0],[0,2,0],[0,0,1]] com autovalor múltiplo λ=2, V=span{e1,e2}. Perturbe com E=[[0,0.1,0],[0.1,0,0],[0,0,0.01]]. Projete Ep, SVD dá σ1≈0.1414, gap=1, bound sinΘ ≤0.1414. Novo subespaço tem erro ~0.14, confirmando.",
                              "finalVerifications": [
                                "Deriva corretamente o bound usando σ1(Ep)/gap.",
                                "Implementa pipeline completo em código sem erros numéricos.",
                                "Interpreta bound: pequeno σ1 implica subespaço estável.",
                                "Valida com exemplo: erro real ≤ bound teórico.",
                                "Explica limitação para gaps pequenos."
                              ],
                              "assessmentCriteria": [
                                "Precisão teórica: explica projeção e SVD corretamente (80%).",
                                "Implementação numérica: código roda e dá bound exato (90%).",
                                "Interpretação: relaciona σ1 a estabilidade prática (70%).",
                                "Validação: compara teoria vs prática com <5% erro.",
                                "Criatividade: aplica a caso com multiplicidade >2."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de modos normais em vibrações com degenerescência.",
                                "Engenharia de Controle: Estabilidade de polos múltiplos em sistemas lineares.",
                                "Ciência de Dados: Sensibilidade em PCA para componentes múltiplos.",
                                "Otimização: Condicionamento de subespaços em métodos de autovalores."
                              ],
                              "realWorldApplication": "Em simulações de engenharia estrutural, estima sensibilidade de modos vibracionais degenerados a incertezas de modelagem, evitando falhas catastróficas; ou em machine learning, avalia robustez de subespaços em PCA para dados ruidosos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.3",
                        "name": "Medidas Numéricas de Sensibilidade",
                        "description": "Ferramentas computacionais e métricas para quantificar a sensibilidade de autovetores em problemas reais.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.3.1",
                            "name": "Computar o número de condição de autovetores",
                            "description": "Implementar numericamente cond(v) = ||(A - λI)^†|| * ||v|| e interpretá-lo em termos de estabilidade relativa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Sensibilidade de Autovetores",
                                  "subSteps": [
                                    "Revisar definições de autovalor λ e autovetor v de uma matriz A.",
                                    "Estudar a pseudoinversa de Moore-Penrose (†) para matrizes singulares.",
                                    "Aprender normas de matrizes (||·||_2) e vetores usadas no número de condição.",
                                    "Entender que cond(v) mede a sensibilidade relativa de v a perturbações em A.",
                                    "Explorar exemplos teóricos de autovetores sensíveis (ex: autovalores múltiplos)."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito por que (A - λI) é singular e como a pseudoinversa captura isso.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Matrix Computations' de Golub e Van Loan (cap. 2)",
                                    "Documentação SciPy.linalg.pinv",
                                    "Notebook Jupyter vazio"
                                  ],
                                  "tips": "Visualize graficamente autovetores com Matplotlib para intuição geométrica.",
                                  "learningObjective": "Dominar a teoria por trás de cond(v) = ||(A - λI)^†|| * ||v||.",
                                  "commonMistakes": [
                                    "Confundir pseudoinversa com inversa regular",
                                    "Ignorar normalização do autovetor v",
                                    "Esquecer que normas devem ser consistentes (ex: norma 2)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o Problema Numérico",
                                  "subSteps": [
                                    "Selecionar ou gerar uma matriz quadrada A (ex: 2x2 ou 3x3).",
                                    "Computar autovalores e autovetores de A usando eigendecomposição.",
                                    "Escolher um par (λ, v) específico, normalizando v para ||v||=1.",
                                    "Verificar que A v = λ v com tolerância numérica.",
                                    "Documentar A, λ e v em um script de programação."
                                  ],
                                  "verification": "Imprimir A, λ e v, confirmando A @ v ≈ λ * v com erro < 1e-10.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy e SciPy",
                                    "Exemplo de matriz A = [[2,1],[1,2]]"
                                  ],
                                  "tips": "Use np.linalg.eig para automação inicial; sempre normalize v com np.linalg.norm.",
                                  "learningObjective": "Preparar dados precisos para evitar erros de propagação.",
                                  "commonMistakes": [
                                    "Não normalizar v",
                                    "Escolher autovetor com componente numérica zero",
                                    "Usar matriz não simétrica sem cuidado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar a Matriz Deslocada e sua Pseudoinversa",
                                  "subSteps": [
                                    "Calcular B = A - λ * np.eye(n), onde n é a dimensão.",
                                    "Verificar que B é singular (det(B) ≈ 0 ou rank < n).",
                                    "Implementar pseudoinversa B† usando np.linalg.pinv(B).",
                                    "Calcular norma de matriz ||B†||_2 com np.linalg.norm(B_pinv, 2).",
                                    "Testar com perturbação pequena em A para validar."
                                  ],
                                  "verification": "Confirmar ||B @ v|| ≈ 0 e ||B† @ (B @ v)|| ≈ 0.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "SciPy.linalg.pinv",
                                    "NumPy para operações matriciais"
                                  ],
                                  "tips": "Para matrizes grandes, considere SVD explícita para pseudoinversa: U, S, Vh = np.linalg.svd(B); pinv via 1/S onde S>eps.",
                                  "learningObjective": "Implementar corretamente a pseudoinversa numérica.",
                                  "commonMistakes": [
                                    "Usar np.linalg.inv em matriz singular (erro)",
                                    "Escolher norma errada (ex: Frobenius em vez de 2)",
                                    "Ignorar precisão de máquina em singulares"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular e Interpretar o Número de Condição cond(v)",
                                  "subSteps": [
                                    "Computar ||v||_2 (deve ser 1 se normalizado).",
                                    "Calcular cond_v = np.linalg.norm(B_pinv, 2) * np.linalg.norm(v, 2).",
                                    "Interpretar: cond(v) baixo → v estável; alto → sensível a perturbações.",
                                    "Simular perturbação δA pequena e recomputar v' para validar (||v' - v|| / ||v|| vs cond(v)*||δA||).",
                                    "Comparar com cond(A) para contexto."
                                  ],
                                  "verification": "Para exemplo conhecido, cond(v) deve coincidir com valor teórico ou simulação.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código dos passos anteriores",
                                    "Função de perturbação: A_pert = A + 1e-6 * np.random.randn(n,n)"
                                  ],
                                  "tips": "Registre cond(v) em log10 para escala intuitiva (ex: 10^6 indica alta sensibilidade).",
                                  "learningObjective": "Aplicar fórmula e ligar a estabilidade relativa.",
                                  "commonMistakes": [
                                    "Esquecer multiplicar por ||v||",
                                    "Interpretar cond(v)>1 como sempre instável sem contexto",
                                    "Não escalar perturbação corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Generalizar a Implementação",
                                  "subSteps": [
                                    "Testar com múltiplas matrizes (simétrica, não-simétrica, mal-condicionada).",
                                    "Implementar função reutilizável: def cond_eigenvector(A, lambda_, v): ...",
                                    "Analisar casos extremos (autovalor múltiplo).",
                                    "Documentar limitações numéricas (ex: precisão para n grande).",
                                    "Criar relatório com plots de sensibilidade vs cond(v)."
                                  ],
                                  "verification": "Função passa em 5 testes unitários com assert abs(error) < 1e-8.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Pytest para testes",
                                    "Matplotlib para gráficos"
                                  ],
                                  "tips": "Use cond_number = np.log10(cond_v) para visualização.",
                                  "learningObjective": "Criar ferramenta robusta para análise de sensibilidade.",
                                  "commonMistakes": [
                                    "Não tratar casos onde pseudoinversa falha",
                                    "Generalizar sem testar diversidade",
                                    "Ignorar custo computacional O(n^3)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[2, 1], [1, 2]], λ ≈ 3, v = [1/sqrt(2), 1/sqrt(2)], compute B = A - 3I = [[-1,1],[1,-1]], B† via SVD tem ||B†||_2 = 0.5 * sqrt(2), ||v||=1, assim cond(v) ≈ 0.707 (baixo, estável). Simule δA=1e-6 e verifique mudança em v.",
                              "finalVerifications": [
                                "Implementar cond(v) corretamente para matriz 3x3 aleatória.",
                                "Interpretar cond(v) > 10^8 como altamente instável.",
                                "Validar com perturbação: erro relativo em v ≈ cond(v) * erro relativo em A.",
                                "Comparar com software como MATLAB eigcond.",
                                "Explicar ligação com separação de autovalores.",
                                "Testar em autovalor simples vs múltiplo."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erro < 1e-10 em verificações.",
                                "Correta implementação de pseudoinversa e normas.",
                                "Interpretação qualitativa/quantitativa de estabilidade.",
                                "Eficiência do código para n≤100.",
                                "Relatório claro com exemplos e plots.",
                                "Tratamento de casos edge (singularidade forte)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Científica: Uso de NumPy/SciPy para álgebra linear.",
                                "Análise Numérica: Estudo de erros de arredondamento e condicionamento.",
                                "Engenharia: Estabilidade em análise modal de vibrações.",
                                "Machine Learning: Sensibilidade em PCA e autovalores de covariância.",
                                "Física Computacional: Modelos quânticos e matrizes Hamiltonianas."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, avalia estabilidade de modos de vibração em estruturas (ex: asas de avião); em finanças, sensibilidade de autovetores em análise de portfólio; em ML, detecta componentes instáveis em PCA para dados ruidosos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.4.3.2",
                            "name": "Avaliar sensibilidade via simulações de perturbação",
                            "description": "Realizar experimentos numéricos adicionando ruído aleatório à matriz e medindo desvios em autovetores normalizados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a matriz original e seus autovetores",
                                  "subSteps": [
                                    "Escolha uma matriz simétrica n x n (ex: 2x2 ou 3x3) com autovalores distintos.",
                                    "Implemente o cálculo de autovalores e autovetores usando biblioteca numérica (ex: numpy.linalg.eig).",
                                    "Normalize os autovetores para norma euclidiana unitária.",
                                    "Armazene os resultados originais em variáveis dedicadas.",
                                    "Visualize os autovetores originais em gráfico (se aplicável para n=2)."
                                  ],
                                  "verification": "Confirme que os autovetores têm norma igual a 1 e autovalores são reais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python com NumPy e Matplotlib; Jupyter Notebook.",
                                  "tips": "Use np.linalg.norm para verificar normalização; prefira matrizes pequenas para depuração rápida.",
                                  "learningObjective": "Dominar o cálculo e normalização de autovetores de uma matriz original.",
                                  "commonMistakes": "Esquecer de normalizar autovetores; usar matriz não simétrica (leva a autovalores complexos)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar matrizes perturbadas com ruído aleatório",
                                  "subSteps": [
                                    "Defina o nível de ruído ε (ex: 10^{-k} para k=1 a 6).",
                                    "Gere N matrizes perturbadas: A_pert = A + ε * G, onde G é matriz gaussiana aleatória (média 0, desvio 1).",
                                    "Use np.random.normal para gerar o ruído com shape (n,n).",
                                    "Repita para múltiplos níveis de ruído e múltiplas realizações (ex: N=100).",
                                    "Armazene as matrizes perturbadas em uma lista ou array."
                                  ],
                                  "verification": "Verifique que a perturbação tem magnitude média próxima a ε via np.linalg.norm.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python com NumPy; seed para reprodutibilidade (np.random.seed(42)).",
                                  "tips": "Escolha ε pequeno para simular perturbações realistas; use loops vetorizados para eficiência.",
                                  "learningObjective": "Implementar simulações de perturbação estocástica controlada.",
                                  "commonMistakes": "Gerar ruído assimétrico sem simetrizar (A_pert = (A_pert + A_pert.T)/2); N muito pequeno leva a variância alta."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular autovetores das matrizes perturbadas e normalizá-los",
                                  "subSteps": [
                                    "Para cada A_pert, compute autovalores e autovetores com np.linalg.eig.",
                                    "Associe autovetores perturbados aos originais pelo autovalor mais próximo (matching por distância).",
                                    "Normalize cada autovetor perturbado para norma unitária.",
                                    "Calcule o desvio angular: sinθ = ||v - v_pert|| / √2 (aproximação para ângulo pequeno).",
                                    "Armazene desvios para cada realização e nível de ruído."
                                  ],
                                  "verification": "Todos autovetores perturbados têm norma ≈1; matching correto via plot de autovalores.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "NumPy; função auxiliar para matching de autovalores (np.argmin de diferenças).",
                                  "tips": "Para matching, ordene autovalores; use np.linalg.norm(v - v_pert) para desvio.",
                                  "learningObjective": "Comparar e medir diferenças entre autovetores originais e perturbados.",
                                  "commonMistakes": "Matching errado de autovetores (inverte pares); não normalizar levando a desvios inflados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e avaliar a sensibilidade numérica",
                                  "subSteps": [
                                    "Compute estatísticas: média e desvio padrão dos sinθ para cada ε.",
                                    "Plote log-log de média(sinθ) vs log(ε) para verificar linearidade (condição de sensibilidade).",
                                    "Calcule a taxa de sensibilidade: inclinação da reta de regressão.",
                                    "Interprete: se inclinação ≈1, sensibilidade condicional; >1 hiper-sensível.",
                                    "Gere relatório com gráficos e conclusões."
                                  ],
                                  "verification": "Gráficos mostram tendência linear; estatísticas coerentes com teoria (ex: bound O(ε/δ) onde δ=gap autovalores).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Matplotlib para plots; SciPy para regressão linear (scipy.stats.linregress).",
                                  "tips": "Use plt.loglog para escalas log; inclua gap de autovalores no plot para correlação.",
                                  "learningObjective": "Interpretar resultados de simulações para quantificar sensibilidade.",
                                  "commonMistakes": "Escala errada no plot (não log-log); ignorar gap de autovalores afetando sensibilidade."
                                }
                              ],
                              "practicalExample": "Para A = [[2, 1], [1, 2]], autovalores λ1=3 (v1=[0.707,0.707]), λ2=1 (v2=[-0.707,0.707]). Adicione ε=0.01*G (G gaussiana), compute 100 realizações, meça média(sinθ1) ≈ 0.01 / |λ1-λ2| = 0.005, confirmando sensibilidade condicional.",
                              "finalVerifications": [
                                "Autovetores originais e perturbados normalizados corretamente (norma=1).",
                                "Desvios angulares crescem linearmente com ε no plot log-log.",
                                "Estatísticas (média, std) computadas para pelo menos 50 realizações por ε.",
                                "Matching de autovetores por autovalor mais próximo sem ambiguidades.",
                                "Interpretação inclui referência ao gap de autovalores.",
                                "Código reproduzível com seed fixa."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: desvios <1e-10 para ε=0.",
                                "Eficiência: tempo de execução <5s para N=100, n=3.",
                                "Visualizações claras: plots com legendas, eixos log e títulos.",
                                "Análise estatística robusta: uso de médias e intervalos de confiança.",
                                "Interpretação teórica: ligação com bounds de sensibilidade (ex: Bauer-Fike).",
                                "Código limpo: funções modulares e comentários."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de modos normais em vibrações com ruído experimental.",
                                "Engenharia: Estabilidade de sistemas lineares em controle (ex: polos perturbados).",
                                "Ciência de Dados: Sensibilidade em PCA para redução dimensional robusta.",
                                "Estatística: Modelos de Monte Carlo para quantificação de incerteza."
                              ],
                              "realWorldApplication": "Em machine learning, avalia sensibilidade de componentes principais (PCA) a ruído nos dados, essencial para imagens médicas ou sensores falhos; em engenharia aeroespacial, verifica estabilidade de autovalores em modelos de flutter de asas sob incertezas de fabricação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.4.3.3",
                            "name": "Interpretar resultados à luz da bibliografia",
                            "description": "Relacionar análises computadas com resultados de Golub & Van Loan (Cap. 11) e Meyer (Cap. 8) para validação teórica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos teóricos chave da bibliografia",
                                  "subSteps": [
                                    "Localize e leia Capítulo 11 de Golub & Van Loan, focando em seções sobre sensibilidade de autovalores e autovetores.",
                                    "Estude Capítulo 8 de Meyer, enfatizando teoremas de perturbação e bounds para sensibilidade de autovetores.",
                                    "Anote fórmulas principais, como o bound de sensibilidade cond(Y, cond(A)) para autovetores normalizados.",
                                    "Crie um mapa mental conectando definições de sensibilidade numérica com teoremas citados.",
                                    "Resuma em 1 página as condições de aplicabilidade dos resultados teóricos."
                                  ],
                                  "verification": "Verifique se possui anotações com pelo menos 5 fórmulas/teoremas chave e um mapa mental completo.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livros: Golub & Van Loan (Cap. 11), Meyer (Cap. 8); caderno ou ferramenta digital como Notion/OneNote.",
                                  "tips": "Destaque passagens com marcadores de cores para fácil referência posterior.",
                                  "learningObjective": "Compreender os fundamentos teóricos de sensibilidade de autovetores para validação posterior.",
                                  "commonMistakes": "Ignorar condições de hipóteses dos teoremas, como diagonalizabilidade da matriz."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar análises computadas de sensibilidade",
                                  "subSteps": [
                                    "Selecione uma matriz de teste A (ex: matriz simétrica 5x5 com autovalores distintos).",
                                    "Compute autovalores e autovetores usando software (MATLAB/Python com NumPy/SciPy).",
                                    "Perturbe A com ruído pequeno (ex: 10^-6 * randn) para obter A_pert.",
                                    "Calcule medidas numéricas: condição do autovetor cond(Y), sensibilidade relativa.",
                                    "Registre valores exatos de todas as computações em uma tabela."
                                  ],
                                  "verification": "Confirme que possui tabela com resultados numéricos para A e A_pert, incluindo erros relativos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Software: MATLAB ou Python (SciPy.linalg); matriz de teste pré-definida.",
                                  "tips": "Use seeds fixas para reprodutibilidade: np.random.seed(42).",
                                  "learningObjective": "Gerar dados computacionais precisos para comparação teórica.",
                                  "commonMistakes": "Não normalizar autovetores adequadamente, levando a condições infladas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar resultados computados com bibliografia",
                                  "subSteps": [
                                    "Compare o cond(Y) computado com o bound teórico de Golub & Van Loan (Cap. 11, Eq. 11.4.2).",
                                    "Verifique se o erro relativo em autovetores atende ao bound de Meyer (Cap. 8, Thm 8.2.1).",
                                    "Identifique se os resultados numéricos validam ou desafiam as previsões teóricas.",
                                    "Calcule discrepâncias quantitativas (ex: erro = |numérico - bound teórico|).",
                                    "Documente citações exatas da bibliografia para cada relação estabelecida."
                                  ],
                                  "verification": "Revise relatório com pelo menos 3 comparações explícitas entre numérico e teórico.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Resultados do Step 2; bibliografia; calculadora ou script para discrepâncias.",
                                  "tips": "Use equações LaTeX para documentar comparações com clareza.",
                                  "learningObjective": "Estabelecer ligações diretas entre evidências empíricas e teoria.",
                                  "commonMistakes": "Aplicar bounds fora do escopo (ex: autovalores múltiplos sem adaptação)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e validar teoricamente os resultados",
                                  "subSteps": [
                                    "Explique por que os resultados numéricos confirmam/invalidam a teoria (ex: influência de cond(A)).",
                                    "Discuta limitações computacionais vs. ideais teóricos (ex: precisão de ponto flutuante).",
                                    "Proponha experimentos adicionais para casos borderline (ex: autovalores próximos).",
                                    "Escreva um parágrafo conclusivo integrando análise.",
                                    "Autoavalie a robustez da validação com base em múltiplas matrizes de teste."
                                  ],
                                  "verification": "Confirme parágrafo conclusivo com interpretações claras e pelo menos 2 experimentos propostos.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Relatórios dos steps anteriores; editor de texto.",
                                  "tips": "Pergunte: 'O que a teoria explica que o numérico não?' para insights profundos.",
                                  "learningObjective": "Desenvolver habilidade de interpretação crítica e validação teórica.",
                                  "commonMistakes": "Super-generalizar de um exemplo isolado sem considerar variabilidade."
                                }
                              ],
                              "practicalExample": "Para matriz A = [[4,1],[1,3]], compute autovetores, perturbe com ε=10^-8, calcule sensibilidade numérica cond(Y)≈2.5. Compare com bound de Golub & Van Loan: sens(Y) ≤ cond(A)/(gap) ≈ 2.8, validando teoria pois 2.5 < 2.8; discuta por Meyer que perturbações em autovetores são amplificadas por cond(Y).",
                              "finalVerifications": [
                                "Resultados numéricos estão dentro dos bounds teóricos citados.",
                                "Todas as comparações incluem referências exatas (capítulo/equação).",
                                "Discrepâncias são explicadas quantitativamente.",
                                "Conclusão integra validação teórica com limitações computacionais.",
                                "Testado com pelo menos duas matrizes diferentes.",
                                "Mapa mental ou resumo cobre conceitos chave da bibliografia."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas citações bibliográficas (exato capítulo/equação): 25%.",
                                "Correção das computações numéricas e bounds teóricos: 25%.",
                                "Profundidade da interpretação (explicação de validações/discrepâncias): 20%.",
                                "Clareza na documentação (tabelas, equações): 15%.",
                                "Identificação de limitações e propostas de extensão: 15%."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em Python/MATLAB reforça Álgebra Computacional.",
                                "Estatística: Análise de erros numéricos liga a distribuições de perturbações.",
                                "Física: Sensibilidade de autovetores em mecânica quântica (matrizes Hamiltonianas).",
                                "Engenharia: Validação em controle de sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, validar sensibilidade de modos de vibração (autovetores) de estruturas via simulações numéricas contra teoria, garantindo estabilidade preditiva e evitando falhas catastróficas por perturbações de fabricação."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.1.3",
                              "10.1.5.4.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.5",
                    "name": "Papel da SVD na Análise de Sensibilidade",
                    "description": "Uso da decomposição em valores singulares para avaliar sensibilidade em computações matriciais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.5.1",
                        "name": "Decomposição em Valores Singulares (SVD)",
                        "description": "A SVD representa uma matriz A como A = U Σ V^T, onde U e V são matrizes ortogonais e Σ é diagonal com valores singulares não negativos em ordem decrescente, fornecendo base para análise espectral e sensibilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.1.1",
                            "name": "Definir os componentes da SVD",
                            "description": "Explicar os papéis das matrizes U, Σ e V na decomposição SVD de uma matriz m x n, incluindo propriedades de ortogonalidade e ordenação dos valores singulares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Forma Geral e Dimensões da Decomposição SVD",
                                  "subSteps": [
                                    "Estude a equação fundamental: Para uma matriz A de m x n, A = U Σ V^T, onde U é m x m, Σ é m x n diagonal, e V é n x n.",
                                    "Identifique as dimensões exatas: U tem m linhas e m colunas, Σ tem m linhas e n colunas com zeros fora da diagonal principal, V tem n linhas e n colunas.",
                                    "Revise a unicidade: SVD é única para matrizes distintas quando valores singulares são ordenados em ordem decrescente.",
                                    "Visualize geometricamente: SVD representa A como uma rotação (U), escalonamento (Σ) e outra rotação (V^T).",
                                    "Pratique escrevendo a equação para uma matriz exemplo 2x3."
                                  ],
                                  "verification": "Escrever corretamente a equação SVD com dimensões para uma matriz m x n arbitrária.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Notas de álgebra linear, calculadora matricial online (Wolfram Alpha), vídeo introdutório sobre SVD (Khan Academy ou YouTube).",
                                  "tips": "Sempre escreva V^T para enfatizar a transposição.",
                                  "learningObjective": "Descrever a estrutura geral da SVD, incluindo dimensões e equação básica.",
                                  "commonMistakes": "Esquecer a transposição em V^T ou inverter as dimensões de U e V."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar as Propriedades da Matriz U",
                                  "subSteps": [
                                    "Defina U: Matriz ortogonal m x m cujas colunas são os vetores singulares esquerdos de A.",
                                    "Verifique ortogonalidade: U^T U = I, ou seja, colunas são ortonormais.",
                                    "Entenda o papel: U captura a base ortonormal para o espaço-coluna de A, rotacionando os vetores para alinhar com os eixos principais.",
                                    "Calcule para exemplo simples: Para A identidade, U é identidade.",
                                    "Discuta interpretação: Colunas de U são direções de variância máxima em dados."
                                  ],
                                  "verification": "Verificar que U U^T = I computando para uma matriz pequena usando Python (numpy.linalg.svd).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com NumPy/SciPy, papel e lápis para multiplicação manual.",
                                  "tips": "Pense em U como uma matriz de rotação que alinha colunas de A com os eixos.",
                                  "learningObjective": "Explicar o papel e propriedades ortogonais de U na SVD.",
                                  "commonMistakes": "Confundir U com autovetores de A A^T em vez de focar em singular vectors."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Matriz Σ e a Ordenação dos Valores Singulares",
                                  "subSteps": [
                                    "Defina Σ: Matriz retangular m x n com valores singulares σ1 ≥ σ2 ≥ ... ≥ σr > 0 na diagonal principal, zeros fora.",
                                    "Explique ordenação: Valores singulares decrescentes, onde r é o posto de A.",
                                    "Papel de Σ: Captura os 'ganhos' ou escalas ao longo das direções principais definidas por U e V.",
                                    "Interprete pequenos σ: Indicam direções de baixa energia ou sensibilidade em análises.",
                                    "Pratique: Liste valores singulares ordenados para uma matriz exemplo."
                                  ],
                                  "verification": "Identificar e ordenar corretamente os valores singulares de uma SVD computada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software MATLAB/Python para svd(), tabela de exemplo de matriz.",
                                  "tips": "Valores singulares são raízes quadradas dos autovalores de A A^T ou A^T A.",
                                  "learningObjective": "Descrever Σ, seus valores singulares ordenados e significado.",
                                  "commonMistakes": "Não ordenar decrescente ou incluir zeros como singulares positivos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Investigar as Propriedades da Matriz V",
                                  "subSteps": [
                                    "Defina V: Matriz ortogonal n x n cujas colunas são os vetores singulares direitos de A.",
                                    "Verifique ortogonalidade: V^T V = I, colunas ortonormais.",
                                    "Papel de V: Captura a base ortonormal para o espaço-linha de A, rotacionando linhas para eixos principais.",
                                    "Relação com Σ: Colunas de V correspondem às direções associadas aos σ_i.",
                                    "Reconstrua A: Verifique A ≈ U Σ V^T para aproximação truncada."
                                  ],
                                  "verification": "Confirmar V V^T = I e reconstruir A usando U, Σ, V de um exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Jupyter Notebook com NumPy, exemplos de matrizes de teste.",
                                  "tips": "V^T é usado na decomposição para mapear do espaço de entrada para o escalonado.",
                                  "learningObjective": "Explicar o papel e propriedades ortogonais de V na SVD.",
                                  "commonMistakes": "Confundir V com autovetores de A^T A sem notar transposição."
                                }
                              ],
                              "practicalExample": "Para a matriz A = [[1, 1], [0, 1]] (2x2), a SVD é aproximadamente U = [[0.82, -0.57], [0.57, 0.82]], Σ = [[1.62, 0], [0, 0.38]], V = [[0.85, 0.53], [-0.53, 0.85]]. U rotaciona colunas, Σ escala por 1.62 e 0.38 (direções principais), V rotaciona linhas. Reconstrua A multiplicando para verificar.",
                              "finalVerifications": [
                                "Escrever e explicar verbalmente A = U Σ V^T com dimensões e papéis.",
                                "Computar SVD de uma matriz 3x2 e identificar U, Σ, V corretamente.",
                                "Verificar ortogonalidade: U U^T = I e V V^T = I.",
                                "Listar valores singulares ordenados e interpretar os menores.",
                                "Explicar geometricamente SVD como rotação-escala-rotação.",
                                "Reconstruir A truncada removendo σ pequenos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição das dimensões e equação SVD (pontos cheios se correto).",
                                "Correta explicação de ortogonalidade de U e V com prova simples.",
                                "Entendimento da ordenação decrescente em Σ e implicações.",
                                "Capacidade de interpretar papéis via exemplo prático.",
                                "Uso correto de terminologia (vetores singulares esquerdos/direitos).",
                                "Aplicação em reconstrução ou análise de sensibilidade."
                              ],
                              "crossCurricularConnections": [
                                "Ciência de Dados: SVD truncada para PCA e redução dimensional.",
                                "Engenharia: Análise de sensibilidade em sistemas lineares via valores singulares pequenos.",
                                "Processamento de Imagens: Compressão via SVD de matrizes de pixels.",
                                "Física Computacional: Diagonalização em mecânica quântica e vibrações."
                              ],
                              "realWorldApplication": "Na análise de sensibilidade computacional, SVD de jacobianas identifica parâmetros sensíveis (σ pequenos indicam direções instáveis), usado em otimização, controle de sistemas e machine learning para robustez em modelos lineares aproximados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.2",
                            "name": "Calcular SVD manualmente para matrizes 2x2",
                            "description": "Realizar o cálculo passo a passo da SVD para matrizes quadradas pequenas, identificando autovalores e autovetores das matrizes A A^T e A^T A.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular as matrizes simétricas A A^T e A^T A",
                                  "subSteps": [
                                    "Transpor a matriz A para obter A^T.",
                                    "Multiplicar A por A^T para obter a matriz simétrica de 2x2.",
                                    "Multiplicar A^T por A para obter a outra matriz simétrica de 2x2.",
                                    "Verificar os cálculos multiplicando os elementos manualmente.",
                                    "Confirmar que ambas as matrizes são simétricas (igual a sua transposta)."
                                  ],
                                  "verification": "As matrizes resultantes devem ser simétricas e iguais à sua própria transposta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora para multiplicações",
                                    "Matriz A de exemplo 2x2"
                                  ],
                                  "tips": "Use a notação matricial para organizar os cálculos e evite erros aritméticos anotando cada produto escalar.",
                                  "learningObjective": "Compreender a construção das matrizes associadas à SVD e sua simetria.",
                                  "commonMistakes": [
                                    "Confundir a ordem das multiplicações (A A^T vs A^T A)",
                                    "Erros em transposições simples",
                                    "Não verificar simetria"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular autovalores de A^T A (valores singulares ao quadrado)",
                                  "subSteps": [
                                    "Escrever a equação característica: det(A^T A - λ I) = 0.",
                                    "Calcular o determinante da matriz 2x2: (a-λ)(d-λ) - bc = 0.",
                                    "Resolver a equação quadrática λ² - traça λ + det = 0 usando fórmula de Bhaskara.",
                                    "Identificar os dois autovalores λ1 ≥ λ2 ≥ 0.",
                                    "Verificar que os autovalores são não-negativos."
                                  ],
                                  "verification": "Os autovalores resolvem a equação característica e são reais/não-negativos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Fórmula quadrática anotada",
                                    "Calculadora para raízes",
                                    "Matriz A^T A"
                                  ],
                                  "tips": "Ordene λ1 > λ2 para convenção; use discriminante para verificar raízes reais.",
                                  "learningObjective": "Resolver polinômio característico quadrático para autovalores.",
                                  "commonMistakes": [
                                    "Erro no sinal do determinante",
                                    "Não ordenar autovalores decrescentemente",
                                    "Raízes negativas (impossível para SVD)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Encontrar autovetores de A^T A e formar a matriz V ortonormal",
                                  "subSteps": [
                                    "Para cada λi, resolver (A^T A - λi I) v_i = 0.",
                                    "Encontrar o autovetor não-nulo resolvendo o sistema 2x2.",
                                    "Normalizar o autovetor: dividir pelo comprimento euclidiano.",
                                    "Verificar ortogonalidade: produto escalar v1 · v2 = 0.",
                                    "Formar V = [v1, v2] e confirmar V^T V = I."
                                  ],
                                  "verification": "Autovetores normalizados e ortogonais: ||v_i||=1 e v_i · v_j = 0 para i≠j.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Regras de normalização",
                                    "Calculadora para normas",
                                    "Matriz A^T A"
                                  ],
                                  "tips": "Escolha sinal do autovetor para consistência; use frações exatas se possível.",
                                  "learningObjective": "Calcular e ortonormalizar autovetores para vetores singulares direitos.",
                                  "commonMistakes": [
                                    "Autovetores não normalizados",
                                    "Falta de ortogonalidade",
                                    "Escolha errada de base nula"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular U, Σ e verificar consistência com A A^T",
                                  "subSteps": [
                                    "Calcular σ_i = sqrt(λ_i) para i=1,2 e formar Σ = diag(σ1, σ2).",
                                    "Calcular u_i = A v_i / σ_i para i=1,2 (se σ_i >0).",
                                    "Verificar ortonormalidade de U = [u1, u2].",
                                    "Opcionalmente, confirmar autovalores de A A^T = σ_i².",
                                    "Ajustar sinais se necessário para U ortonormal."
                                  ],
                                  "verification": "U é ortonormal e A v_i = σ_i u_i.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matriz A original",
                                    "Autovetores V e σ",
                                    "Calculadora para divisões"
                                  ],
                                  "tips": "Para σ_i=0, u_i pode ser escolhido ortogonal a outros; priorize método A v_i.",
                                  "learningObjective": "Construir vetores singulares esquerdos e diagonal Σ.",
                                  "commonMistakes": [
                                    "Dividir por σ_i=0",
                                    "Sinais inconsistentes em U",
                                    "Não verificar A = U Σ V^T"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar a decomposição SVD: A = U Σ V^T",
                                  "subSteps": [
                                    "Calcular V^T (transposta de V).",
                                    "Multiplicar Σ V^T para obter matriz intermediária.",
                                    "Multiplicar U pela intermediária e comparar com A original.",
                                    "Verificar elemento a elemento para precisão.",
                                    "Analisar resíduos se houver discrepâncias numéricas."
                                  ],
                                  "verification": "A calculada = A original com erro < 10^{-6} ou exato.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Todas as matrizes U, Σ, V",
                                    "Calculadora matricial"
                                  ],
                                  "tips": "Faça contas exatas com símbolos se possível; use software para checagem opcional.",
                                  "learningObjective": "Validar a decomposição completa SVD.",
                                  "commonMistakes": [
                                    "Erro em V^T ao invés de V^* para reais",
                                    "Multiplicações matriciais erradas",
                                    "Ignorar verificação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[1, 1], [0, 2]]:\n- A^T A = [[1,1],[1,5]], autovalores λ ≈ [5.828, 0.172], σ ≈ [2.414, 0.414].\n- Autovetores normalizados formam V ≈ [[0.788, -0.616], [0.616, 0.788]].\n- U obtido via A V / Σ ≈ [[1, 0], [0, 1]] (aprox.).\nVerificação: U Σ V^T ≈ A.",
                              "finalVerifications": [
                                "U e V são matrizes ortogonais (U^T U = I, V^T V = I).",
                                "Σ é diagonal com entradas não-negativas decrescentes.",
                                "A = U Σ V^T exatamente (ou com erro numérico mínimo).",
                                "Autovalores de A A^T e A^T A coincidem com σ_i².",
                                "Cada coluna de A tem norma σ_i.",
                                "Rank de A igual ao número de σ_i > 0."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de autovalores (erro < 1%).",
                                "Autovetores corretamente normalizados e ortogonais.",
                                "Construção correta de U via A V / Σ.",
                                "Verificação completa da decomposição.",
                                "Explicação clara dos passos e justificativas matemáticas.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar SVD em Python com NumPy para comparação.",
                                "Estatística: Ligação com Análise de Componentes Principais (PCA).",
                                "Engenharia: Aplicação em análise de sensibilidade de sistemas lineares.",
                                "Física: Decomposição em modos normais de vibrações."
                              ],
                              "realWorldApplication": "Na análise de sensibilidade de modelos computacionais, a SVD identifica direções de maior variação (valores singulares grandes), permitindo redução de dimensionalidade em simulações de engenharia, compressão de imagens em visão computacional e estabilização numérica em álgebra linear aplicada."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.3",
                            "name": "Interpretar propriedades dos valores singulares",
                            "description": "Relacionar os valores singulares com normas matriciais, rank e normas de Frobenius, demonstrando como eles capturam a 'energia' da matriz.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e propriedades básicas dos valores singulares na SVD",
                                  "subSteps": [
                                    "Revise a decomposição SVD: A = U Σ V^T, onde Σ é diagonal com valores singulares σ_i ≥ 0 ordenados decrescentemente.",
                                    "Identifique que σ_i são as raízes quadradas dos autovalores de A^T A ou A A^T.",
                                    "Liste propriedades: σ1 ≥ σ2 ≥ ... ≥ σ_min(m,n) ≥ 0.",
                                    "Calcule manualmente os SVs para uma matriz 2x2 simples.",
                                    "Discuta o papel dos SVs como 'escalas' nos eixos principais."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as propriedades dos SVs e compute-os para uma matriz exemplo.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Notas de aula sobre SVD",
                                    "Calculadora ou Python (NumPy)",
                                    "Matriz exemplo impressa"
                                  ],
                                  "tips": "Sempre ordene os SVs decrescentemente; visualize Σ como um retângulo alongado.",
                                  "learningObjective": "Dominar a definição e ordenação dos valores singulares na SVD.",
                                  "commonMistakes": [
                                    "Confundir SVs com autovalores da matriz original",
                                    "Não ordenar decrescentemente",
                                    "Ignorar zeros nos SVs"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Relacionar valores singulares com o rank da matriz",
                                  "subSteps": [
                                    "Defina rank como o número de SVs positivos (σ_i > 0).",
                                    "Para uma matriz rank-deficient, identifique SVs zero.",
                                    "Prove que rank(A) = r onde σ_r > 0 ≥ σ_{r+1}.",
                                    "Aplique a uma matriz exemplo com rank < min(m,n).",
                                    "Discuta implicações para nulidade e independência linear."
                                  ],
                                  "verification": "Determine o rank de uma matriz dada seus SVs e justifique.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Software de álgebra linear (MATLAB ou Python)",
                                    "Exemplos de matrizes rank-deficient"
                                  ],
                                  "tips": "Conte apenas SVs estritamente positivos; tolerâncias numéricas em computação.",
                                  "learningObjective": "Conectar SVs diretamente ao rank matricial.",
                                  "commonMistakes": [
                                    "Contar SVs muito pequenos como positivos",
                                    "Confundir com dimensão do kernel",
                                    "Ignorar contexto numérico"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Conectar valores singulares à norma de Frobenius",
                                  "subSteps": [
                                    "Lembre a definição: ||A||_F = sqrt(∑_{i,j} a_{ij}^2).",
                                    "Mostre que ||A||_F = sqrt(∑ σ_i^2) via propriedades da SVD.",
                                    "Calcule ||A||_F diretamente e via SVs para verificação.",
                                    "Interprete ∑ σ_i^2 como energia total preservada.",
                                    "Compare com reconstrução SVD truncada."
                                  ],
                                  "verification": "Compute ||A||_F de duas formas para uma matriz e confirme igualdade.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Folha de cálculo para normas"
                                  ],
                                  "tips": "Use np.linalg.norm(A, 'fro') para validação rápida.",
                                  "learningObjective": "Entender a norma Frobenius como soma quadrada dos SVs.",
                                  "commonMistakes": [
                                    "Esquecer a raiz quadrada",
                                    "Confundir com norma 2",
                                    "Não verificar numericamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar valores singulares como captura de 'energia' da matriz",
                                  "subSteps": [
                                    "Discuta ||A||_2 = σ1 (maior SV) como norma espectral.",
                                    "Explique como maiores SVs capturam a maior energia/direções principais.",
                                    "Relacione com energia em sinais: % energia = (∑_{i=1}^k σ_i^2 / ∑ σ_i^2) * 100%.",
                                    "Aplique a SVD truncada: perda de energia ≈ ∑_{i>k} σ_i^2.",
                                    "Conclua com interpretação global: SVs distribuem a energia total."
                                  ],
                                  "verification": "Para uma matriz, calcule % de energia retida por k primeiros SVs e explique.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Código Python para SVD e energia",
                                    "Gráficos de SVs (scree plot)"
                                  ],
                                  "tips": "Visualize com plot de σ_i decrescentes para intuitividade.",
                                  "learningObjective": "Interpretar SVs como componentes de energia matricial.",
                                  "commonMistakes": [
                                    "Achar que todos SVs são iguais em importância",
                                    "Ignorar ordenação na energia cumulativa",
                                    "Confundir energia com soma linear de SVs"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[3, 1], [0, 2]], SVs ≈ [3.16, 1.87]. Rank=2, ||A||_F ≈ sqrt(3.16² + 1.87²) ≈ 3.606. Energia total = 13; 90% retida pelos 2 SVs. Truncar ao σ1 perde ~13% energia.",
                              "finalVerifications": [
                                "Explique rank via SVs para uma matriz 3x2.",
                                "Calcule ||A||_F via SVs e entradas.",
                                "Compute % energia cumulativa para k=1,2.",
                                "Identifique maior SV como ||A||_2.",
                                "Descreva perda de energia em SVD truncada.",
                                "Relacione SVs zero a dependências lineares."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de SVs e normas.",
                                "Clareza na interpretação conceitual de energia.",
                                "Correta conexão entre SVs, rank e normas.",
                                "Uso apropriado de exemplos numéricos.",
                                "Compreensão de implicações práticas (truncamento).",
                                "Ausência de erros comuns como confusão de normas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Energia em vibrações modais (autovalores semelhantes).",
                                "Processamento de Sinais: Análise de frequência via FFT/SVD.",
                                "Machine Learning: PCA onde SVs são variâncias principais.",
                                "Estatística: Decomposição de covariância.",
                                "Engenharia: Análise de estabilidade em sistemas lineares."
                              ],
                              "realWorldApplication": "Em compressão de imagens (JPEG2000), SVs maiores capturam 99% da energia visual, permitindo redução de dados sem perda perceptível de qualidade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.2",
                        "name": "Sensibilidade e Condicionamento de Matrizes",
                        "description": "Avaliação de como perturbações nos dados de entrada afetam as saídas em problemas lineares, quantificada pelo número de condição κ(A) = ||A|| ||A^{-1}||.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.2.1",
                            "name": "Calcular o número de condição via normas",
                            "description": "Computar κ_2(A) usando normas espectrais e relacioná-lo com a amplificação relativa de erros em soluções de Ax = b.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos de normas matriciais e norma espectral",
                                  "subSteps": [
                                    "Defina norma matricial induzida e especifique a norma 2 (espectral).",
                                    "Explique que ||A||_2 é o maior valor singular de A, obtido via SVD.",
                                    "Discuta propriedades: ||A||_2 ≥ 1 para A invertível, submultiplicativa.",
                                    "Relacione norma espectral com autovalores para matrizes normais.",
                                    "Pratique com matriz identidade: ||I||_2 = 1."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a definição de ||A||_2 e compute para I_2x2.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang)",
                                    "Calculadora ou software como MATLAB/Octave",
                                    "Matriz de exemplo 2x2"
                                  ],
                                  "tips": "Lembre-se: SVD de A é A = UΣV^*, ||A||_2 = σ_max.",
                                  "learningObjective": "Compreender a norma espectral como maior valor singular.",
                                  "commonMistakes": [
                                    "Confundir norma 2 com norma de Frobenius",
                                    "Esquecer que é para autovalores absolutos em matrizes normais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a norma espectral de A",
                                  "subSteps": [
                                    "Escolha uma matriz A invertível (ex: 2x2 ou 3x3).",
                                    "Compute a SVD de A usando software ou manualmente para pequena dimensão.",
                                    "Identifique o maior valor singular σ_1 = ||A||_2.",
                                    "Verifique com autovalores de A^* A se aplicável.",
                                    "Registre o valor exato ou aproximado."
                                  ],
                                  "verification": "Mostre o cálculo da SVD e σ_max para matriz dada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software NumPy/MATLAB com svd()",
                                    "Papel e lápis para 2x2",
                                    "Exemplo: A = [[1, 0.1], [0.1, 1]]"
                                  ],
                                  "tips": "Use np.linalg.svd() em Python para automação; valide manualmente.",
                                  "learningObjective": "Executar computação prática de ||A||_2.",
                                  "commonMistakes": [
                                    "Erro na transposição conjugada em SVD",
                                    "Pegar menor singular em vez de maior"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a norma espectral de A^{-1} e o número de condição κ_2(A)",
                                  "subSteps": [
                                    "Compute A^{-1} analiticamente ou numericamente.",
                                    "Aplique SVD a A^{-1} para obter ||A^{-1}||_2 = 1/σ_min(A).",
                                    "Calcule κ_2(A) = ||A||_2 * ||A^{-1}||_2 = σ_max / σ_min.",
                                    "Compare com np.linalg.cond(A, '2') para validação.",
                                    "Classifique: κ_2 ≈1 bem condicionado, κ_2 >>1 mal condicionado."
                                  ],
                                  "verification": "Apresente κ_2 computado e valide com função built-in.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Mesmos do step 2",
                                    "Função cond() em software numérico"
                                  ],
                                  "tips": "Evite inversão direta se possível; use 1/σ_min diretamente de SVD de A.",
                                  "learningObjective": "Computar κ_2 eficientemente via SVD única.",
                                  "commonMistakes": [
                                    "Inverter numericamente causando perda de precisão",
                                    "Usar σ_min de A^{-1} errado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar κ_2 com amplificação de erros em Ax = b",
                                  "subSteps": [
                                    "Lembre teorema: ||δx||/||x|| ≤ κ_2 ||δb||/||b|| para perturbação δb.",
                                    "Gere b = Ax exato, adicione δb pequeno (ex: 10^{-6}).",
                                    "Resolva (A)x' = b + δb e compute erro relativo em x'.",
                                    "Observe amplificação ≈ κ_2 * ||δb||/||b||.",
                                    "Discuta implicações para precisão numérica."
                                  ],
                                  "verification": "Simule exemplo numérico mostrando amplificação bounded por κ_2.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código Python/MATLAB para simulação",
                                    "Gráficos de erro relativo"
                                  ],
                                  "tips": "Use matrizes com κ_2 variando: diagonal vs. Hilbert.",
                                  "learningObjective": "Interpretar κ_2 como fator de amplificação relativa de erros.",
                                  "commonMistakes": [
                                    "Ignorar normalização relativa",
                                    "Usar norma errada no teorema"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[1, 0.01], [0.01, 1]], SVD dá σ_max≈1.00005, σ_min≈0.99995, κ_2≈2. Perturbe b=[1.01,1.01] com δb=10^{-6}, resolva Ax'=b+δb; erro em x amplifica por ~2, ilustrando sensibilidade moderada.",
                              "finalVerifications": [
                                "Define corretamente κ_2(A) = ||A||_2 ||A^{-1}||_2.",
                                "Computa SVD e extrai normas para matriz 2x2.",
                                "Relaciona κ_2 com bound de erro relativo δx/||x|| ≤ κ_2 δb/||b||.",
                                "Classifica condicionamento baseado em valor de κ_2.",
                                "Simula numericamente amplificação de erro.",
                                "Valida com software (ex: cond(A,'2'))."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de SVD e normas (erro <1%).",
                                "Correta interpretação de κ_2 como razão σ_max/σ_min.",
                                "Demonstração clara da relação com erros via simulação.",
                                "Uso eficiente de propriedades (ex: SVD única para ambas normas).",
                                "Análise qualitativa de condicionamento e implicações.",
                                "Clareza em explicações e avoidance de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em NumPy/SciPy para análise de estabilidade.",
                                "Engenharia Computacional: Avaliação de sistemas lineares em simulações FEM.",
                                "Física: Condicionamento em matrizes de massa/rigidez em dinâmica.",
                                "Estatística: Sensibilidade em regressão linear e mínimos quadrados.",
                                "Ciência de Dados: Detecção de multicolinearidade via κ_2."
                              ],
                              "realWorldApplication": "Em modelagem financeira, matrizes de covariância mal condicionadas (alto κ_2) amplificam erros em otimização de portfólios, levando a decisões ruins; engenheiros usam para validar estabilidade numérica em CFD (dinâmica de fluidos computacional)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.1"
                            ]
                          },
                          {
                            "id": "10.1.5.5.2.2",
                            "name": "Analisar sensibilidade em sistemas lineares",
                            "description": "Derivar bounds para erros relativos em soluções de sistemas lineares perturbados, como ||δx||/||x|| ≤ κ(A) ||δb||/||b|| + κ(A) ||δA||/||A||.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de normas e número de condição",
                                  "subSteps": [
                                    "Defina normas vetoriais e matriciais comuns (ex: norma 2, norma infinito).",
                                    "Calcule o número de condição κ(A) = ||A|| * ||A^{-1}|| para uma matriz dada.",
                                    "Resolva um sistema linear Ax = b usando eliminação gaussiana ou decomposição LU.",
                                    "Interprete o significado de κ(A): quanto maior, mais sensível ao erro.",
                                    "Pratique com uma matriz 2x2 simples."
                                  ],
                                  "verification": "Conseguiu calcular κ(A) corretamente para pelo menos duas matrizes de teste e explicar seu impacto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e lápis, calculadora científica, software como Python (NumPy) ou MATLAB.",
                                  "tips": "Use norma 2 para simplicidade em exemplos iniciais; visualize com gráficos de vetores.",
                                  "learningObjective": "Dominar definições e cálculos de normas e condicionamento para análise posterior.",
                                  "commonMistakes": "Confundir norma de matriz com norma de vetor; esquecer de inverter A corretamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar sensibilidade a perturbações no vetor b (δb)",
                                  "subSteps": [
                                    "Resolva Ax = b e Ax = (b + δb).",
                                    "Derive a bound relativa: ||δx||/||x|| ≤ κ(A) * ||δb||/||b|| usando desigualdade triangular.",
                                    "Prove passo a passo: x + δx = A^{-1}(b + δb) ⇒ δx = A^{-1} δb.",
                                    "Calcule numericamente para um exemplo com ||δb||/||b|| = 10^{-6}.",
                                    "Compare erro relativo previsto vs. observado."
                                  ],
                                  "verification": "Derivação escrita corretamente e erro numérico dentro do bound previsto.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software numérico (Python/NumPy ou MATLAB), exemplos de matrizes bem e mal condicionadas.",
                                  "tips": "Escolha matrizes com κ(A) variando de 1 a 1000 para ver diferenças claras.",
                                  "learningObjective": "Entender e derivar bound para perturbações em b, relacionando com condicionamento.",
                                  "commonMistakes": "Ignorar a multiplicação por ||A^{-1}|| no bound; usar normas inconsistentes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar sensibilidade a perturbações na matriz A (δA)",
                                  "subSteps": [
                                    "Considere (A + δA)(x + δx) = b, linearize para primeira ordem.",
                                    "Derive δx ≈ -A^{-1} δA x + A^{-1} δb (foco em δA).",
                                    "Obtenha bound: ||δx||/||x|| ≤ κ(A) * ||δA||/||A||.",
                                    "Implemente numericamente perturbando um elemento de A.",
                                    "Analise como perturbações relativas se amplificam."
                                  ],
                                  "verification": "Bound derivado e verificado numericamente em pelo menos um exemplo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Mesmo software do passo anterior, matrizes de teste com perturbações controladas.",
                                  "tips": "Perturbe um elemento por vez para isolar efeitos; use norma Frobenius para ||δA||.",
                                  "learningObjective": "Derivar e validar bound para perturbações em A.",
                                  "commonMistakes": "Esquecer termo -A^{-1} δA x na aproximação; subestimar impacto de δA grande."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar bounds e interpretar resultados",
                                  "subSteps": [
                                    "Some bounds: ||δx||/||x|| ≤ κ(A) (||δb||/||b|| + ||δA||/||A||).",
                                    "Aplique a um exemplo completo com ambas perturbações.",
                                    "Discuta papel da SVD: singular values explicam condicionamento.",
                                    "Avalie cenários: quando ignorar δA vs. δb.",
                                    "Crie tabela comparativa de erros para diferentes κ(A)."
                                  ],
                                  "verification": "Fórmula geral aplicada corretamente com interpretação qualitativa.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software para SVD (np.linalg.svd), exemplos finais integrados.",
                                  "tips": "Sempre normalize erros relativos para comparação justa.",
                                  "learningObjective": "Integrar análises em bound completo e conectar com SVD.",
                                  "commonMistakes": "Adicionar bounds sem justificar; ignorar que bound é conservador."
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 1], [1, 2]], b = [3, 4], x = [1, 2]. κ(A) ≈ 3.4 (norma 2). Perturbe b com δb = [10^{-5}, 0], δA = [[0, 10^{-5}], [0, 0]]. Calcule x perturbado, erros relativos e verifique ||δx||/||x|| ≤ 3.4*(10^{-5} + 10^{-5}).",
                              "finalVerifications": [
                                "Deriva corretamente todos os bounds individuais e combinado.",
                                "Calcula κ(A) e erros em exemplo numérico com precisão.",
                                "Explica amplificação por condicionamento em palavras.",
                                "Aplica SVD para decompor sensibilidade em um caso.",
                                "Identifica quando sistema é 'seguro' (κ baixo)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (100% das fórmulas corretas).",
                                "Exemplos numéricos com erros dentro dos bounds previstos.",
                                "Interpretação qualitativa clara e conectada ao condicionamento.",
                                "Uso consistente de normas em todos cálculos.",
                                "Criatividade em exemplos e conexões com SVD.",
                                "Ausência de erros comuns como normas mistas."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação estável com pivoteamento.",
                                "Engenharia Computacional: Análise de erros em simulações FEM.",
                                "Física Computacional: Modelos diferenciais perturbados.",
                                "Economia/Machine Learning: Sensibilidade em otimização linear."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, analisa como erros de medição (δb) ou modelagem (δA) em equações estruturais propagam para previsões de estresse, evitando falhas catastróficas em designs sensíveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.1"
                            ]
                          },
                          {
                            "id": "10.1.5.5.2.3",
                            "name": "Comparar com decomposição QR",
                            "description": "Discutir limitações da QR na detecção de sensibilidade em matrizes mal-condicionadas e como SVD supera isso via valores singulares pequenos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Decomposição QR e seu uso em análise de sensibilidade",
                                  "subSteps": [
                                    "Lembre-se da definição: QR decompõe A = QR onde Q é ortogonal e R é triangular superior.",
                                    "Discuta como o fator de condição de R (cond(R)) aproxima cond(A) para matrizes bem-condicionadas.",
                                    "Implemente QR em software (ex: MATLAB ou Python com numpy.linalg.qr) para uma matriz simples.",
                                    "Calcule cond(R) e compare com cond(A) usando norm-inf ou 2-norm.",
                                    "Identifique premissas: funciona bem quando A é dominante na primeira coluna."
                                  ],
                                  "verification": "Conseguiu decompor uma matriz 3x3 via QR e calcular cond(R) corretamente, comparando com cond(A).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora matricial, Python/MATLAB com numpy/scipy, notas de álgebra linear.",
                                  "tips": "Use qr com modo='complete' para matrizes não quadradas se necessário.",
                                  "learningObjective": "Compreender como QR revela condionamento via diagonal de R.",
                                  "commonMistakes": "Confundir cond(Q) (sempre 1) com cond(R); ignorar que QR falha em detectar colunas pequenas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar SVD e detecção de sensibilidade via valores singulares",
                                  "subSteps": [
                                    "Defina SVD: A = U Σ V^T, onde Σ tem valores singulares σ1 ≥ σ2 ≥ ... ≥ σn ≥ 0.",
                                    "Explique cond(A) = σ1 / σ_min exatamente, detectando sensibilidade por σ pequenos.",
                                    "Implemente SVD (numpy.linalg.svd) em uma matriz mal-condicionada (ex: [[1,1],[1,1.0001]]).",
                                    "Analise σ_min pequeno indicando ill-condicionamento.",
                                    "Compare perturbações: adicione ruído pequeno e veja impacto em soluções."
                                  ],
                                  "verification": "Calculou SVD de matriz exemplo, identificou σ_min < 10^-3 e explicou impacto em cond(A).",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python com numpy, exemplos de matrizes Hilbert ou Vandermonde mal-condicionadas.",
                                  "tips": "Plot os valores singulares decrescentes para visualização intuitiva.",
                                  "learningObjective": "Dominar como SVD quantifica sensibilidade precisamente via σ_min.",
                                  "commonMistakes": "Esquecer que SVD captura direção de sensibilidade via vetores singulares; confundir com autovalores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar limitações da QR em matrizes mal-condicionadas",
                                  "subSteps": [
                                    "Crie matriz mal-condicionada onde colunas finais são lineares dependentes (ex: A com cond(A)~10^6).",
                                    "Aplique QR: observe que cond(R) subestima cond(A) se problema não estiver nas primeiras colunas.",
                                    "Teste numericamente: resolva Ax=b com QR vs. back-substituição direta, medindo erro relativo.",
                                    "Discuta teoricamente: QR perde info sobre σ pequenos se não na diagonal inicial de R.",
                                    "Compare com exemplo onde QR falha: matriz com σ pequeno na direção não alinhada com Q."
                                  ],
                                  "verification": "Demonstrou numérica/analiticamente que cond(R) << cond(A) em matriz exemplo mal-condicionada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software numérico, matrizes de teste (ex: gallery('randsvd') no MATLAB).",
                                  "tips": "Use cond() built-in para validação rápida antes de decompor.",
                                  "learningObjective": "Reconhecer cenários onde QR mascara sensibilidade.",
                                  "commonMistakes": "Assumir QR sempre dá cond exato; não testar com perturbações reais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar QR vs SVD e demonstrar superioridade da SVD",
                                  "subSteps": [
                                    "Para mesma matriz mal-condicionada, compute QR e SVD lado a lado.",
                                    "Compare: cond(R) vs σ1/σ_min; discuta por que SVD é invariante e global.",
                                    "Analise estabilidade: resolva sistemas lineares com ambos e compare resíduos ||Ax-b||.",
                                    "Resuma vantagens SVD: detecta todos σ, rank revelação, low-rank approx.",
                                    "Crie tabela comparativa: precisão, custo computacional, robustez."
                                  ],
                                  "verification": "Produziu tabela ou relatório comparando métricas em exemplo concreto, destacando SVD superior.",
                                  "estimatedTime": "55 minutos",
                                  "materials": "Planilha ou Jupyter notebook para tabelas, gráficos de erros.",
                                  "tips": "Escolha matriz 4x4 para balancear simplicidade e realismo.",
                                  "learningObjective": "Articular claramente por que SVD supera QR na análise de sensibilidade.",
                                  "commonMistakes": "Ignorar custo SVD O(n^3) vs QR O(n^3) similar mas SVD mais estável; super-generalizar."
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 1], [1e-6, 1e-6 + 1e-12]]. QR dá R com cond(R)~1, mascarando cond(A)~1e6. SVD revela σ1~1, σ2~1e-12, cond(A)=1e12 exatamente. Perturbe b=[1,1e-6], solução x varia drasticamente só visível em SVD.",
                              "finalVerifications": [
                                "Explica limitações QR em 2 exemplos distintos.",
                                "Calcula corretamente cond via SVD para matriz dada.",
                                "Compara cond(R) vs σ1/σ_min em caso mal-condicionado.",
                                "Demonstra numericamente instabilidade QR vs estabilidade SVD.",
                                "Resume 3 vantagens chave da SVD sobre QR.",
                                "Identifica quando QR pode ser preferível (custo em grandes matrizes esparsas)."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: distinção clara entre cond(R) aproximado vs σ exato (30%).",
                                "Exemplos numéricos: implementações corretas e análise de erros (25%).",
                                "Profundidade comparação: discute direções singulares e invariância (20%).",
                                "Clareza explicação: linguagem acessível com analogias (15%).",
                                "Aplicação prática: liga a estabilidade numérica real (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Computação Numérica: Estabilidade em solvers lineares (ex: LU vs QR).",
                                "Machine Learning: SVD em PCA para redução dimensional robusta.",
                                "Engenharia: Análise de sensibilidade em simulações FEM.",
                                "Física Computacional: Condicionamento em matrizes de discretização."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, SVD detecta instabilidades em modelos de fluidos mal-condicionados que QR ignora, evitando erros catastróficos em simulações CFD; em finanças, analisa risco em covariança mal-condicionada para portfólios."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.3",
                        "name": "Aplicação da SVD na Análise de Sensibilidade",
                        "description": "Uso dos valores singulares para quantificar sensibilidade em problemas como resolução de sistemas lineares, quadrados mínimos e pseudoinversa.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.3.1",
                            "name": "Determinar condicionamento via SVD",
                            "description": "Calcular κ_2(A) = σ_1 / σ_n diretamente dos valores singulares da SVD, interpretando impactos em precisão numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Decomposição em Valores Singulares (SVD)",
                                  "subSteps": [
                                    "Lembre-se da definição de SVD: A = U Σ V^T, onde Σ é diagonal com valores singulares σ1 ≥ σ2 ≥ ... ≥ σn ≥ 0.",
                                    "Identifique σ1 como o maior valor singular (norma espectral) e σn como o menor valor singular não-nulo.",
                                    "Entenda que os valores singulares medem a 'esticamento' das direções principais da matriz.",
                                    "Pratique decompondo manualmente uma matriz 2x2 simples para visualizar Σ.",
                                    "Confirme propriedades: σ1 = ||A||_2 e 1/σn relaciona-se à pseudoinversa."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a estrutura da SVD e identifique σ1 e σn em um exemplo dado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, calculadora científica, tutorial online de SVD (ex: Khan Academy).",
                                  "tips": "Visualize geometricamente: SVD como rotações e escalas.",
                                  "learningObjective": "Compreender os componentes da SVD e o papel dos valores singulares.",
                                  "commonMistakes": "Confundir valores singulares com autovalores; lembrar que SVD aplica a qualquer matriz real."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Valores Singulares de uma Matriz",
                                  "subSteps": [
                                    "Escolha uma matriz A mxn e compute SVD usando software (MATLAB svd() ou Python numpy.linalg.svd).",
                                    "Extraia o vetor diagonal Σ e ordene σ1 ≥ ... ≥ σn.",
                                    "Para matrizes pequenas, compute manualmente resolvendo autovalores de A^T A.",
                                    "Verifique numericamente: ||A - U Σ V^T|| deve ser próximo de zero.",
                                    "Registre σ1 (máximo) e σn (mínimo não-zero)."
                                  ],
                                  "verification": "Forneça os valores singulares corretos para uma matriz 3x3 aleatória.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com NumPy ou MATLAB, matriz de exemplo impressa.",
                                  "tips": "Use np.linalg.svd(A, compute_uv=False) para apenas singulares.",
                                  "learningObjective": "Executar computação prática de valores singulares.",
                                  "commonMistakes": "Ignorar zeros em Σ para matrizes não quadradas; sempre ordenar decrescente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Número de Condição κ_2(A)",
                                  "subSteps": [
                                    "Defina κ_2(A) = σ1 / σn, onde σn é o menor singular não-zero.",
                                    "Compute numericamente: divida σ1 por σn e arredonde adequadamente.",
                                    "Para matrizes singulares, note que σn=0 implica κ_2=∞.",
                                    "Compare com outras normas: verifique consistência com cond(A) em software.",
                                    "Documente o valor e sua magnitude (ex: κ<10^3 é bem-condicionado)."
                                  ],
                                  "verification": "Calcule κ_2 para duas matrizes dadas e confirme com função built-in.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software de álgebra linear (NumPy/MATLAB), planilha para registro.",
                                  "tips": "Log10(κ) indica dígitos de precisão perdidos.",
                                  "learningObjective": "Aplicar fórmula de condicionamento diretamente da SVD.",
                                  "commonMistakes": "Usar σn=0 sem tratar singularidade; confundir com κ_1 (norma 1)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Impactos na Precisão Numérica",
                                  "subSteps": [
                                    "Relacione κ_2 com erro relativo: |δx|/|x| ≈ κ_2 |δb|/|b| em Ax=b.",
                                    "Classifique: κ≈1 (bem-condicionado, estável), κ>>1 (il-condicionado, sensível a ruído).",
                                    "Simule perturbação: adicione ε a b e observe amplificação em x.",
                                    "Discuta mitigação: regularização ou preconditioning.",
                                    "Aplique a exemplo real: analise estabilidade de um sistema linear."
                                  ],
                                  "verification": "Explique qualitativamente e quantitativamente o impacto de κ_2=10^6 em uma solução.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Código Python para simulação de erro, gráficos de erro vs. perturbação.",
                                  "tips": "Plote log(erro) vs log(κ) para visualização.",
                                  "learningObjective": "Interpretar κ_2 em contexto de estabilidade numérica.",
                                  "commonMistakes": "Subestimar amplificação em problemas il-condicionados; ignorar máquina epsilon."
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 1], [1, 1+ε]] com ε=10^-10. SVD dá σ1≈√2, σn≈ε/√2, κ_2≈2/ε=2e10. Resolvendo Ax=b com b=[1,1], pequena perturbação δb=10^-15 causa δx/|x|≈10^-5, perdendo 5 dígitos de precisão devido a alto κ.",
                              "finalVerifications": [
                                "Calcula corretamente σ1 e σn de uma matriz 4x4.",
                                "Computa κ_2(A) com precisão de 10^-10.",
                                "Interpreta κ_2>10^12 como 'numericamente singular'.",
                                "Simula e explica perda de precisão em Ax=b.",
                                "Identifica quando SVD é superior a autovalores para condicionamento.",
                                "Aplica a matriz ill-condicionada real (ex: Hilbert)."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de valores singulares (erro <10^-12).",
                                "Correta aplicação da fórmula κ_2 = σ1/σn.",
                                "Interpretação qualitativa e quantitativa precisa.",
                                "Tratamento adequado de casos singulares.",
                                "Uso eficiente de ferramentas computacionais.",
                                "Clareza na documentação de passos e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Computação Científica: Estabilidade em solvers lineares (SciPy).",
                                "Engenharia: Análise de sensibilidade em controle de sistemas.",
                                "Física: Condicionamento em inversão de matrizes de momentos.",
                                "Machine Learning: Regularização em PCA/SVD para dados ruidosos."
                              ],
                              "realWorldApplication": "Em simulações de engenharia estrutural, SVD detecta matrizes ill-condicionadas de rigidez, previnindo erros catastróficos em predições de deformação; em finanças, avalia risco em modelos de portfólio onde alto κ amplifica ruído de mercado."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.1",
                              "10.1.5.5.2"
                            ]
                          },
                          {
                            "id": "10.1.5.5.3.2",
                            "name": "Aplicar SVD em quadrados mínimos",
                            "description": "Resolver min ||Ax - b||_2 usando SVD, analisando sensibilidade via valores singulares próximos de zero e regularização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o problema e computar a SVD da matriz A",
                                  "subSteps": [
                                    "Identifique o sistema Ax ≈ b onde A é m x n, tipicamente m > n ou rank(A) < n.",
                                    "Verifique as dimensões de A e b para confirmar o problema de quadrados mínimos.",
                                    "Use software numérico (ex: numpy.linalg.svd em Python ou svd em MATLAB) para decompor A = U Σ V^T.",
                                    "Extraia as matrizes U, Σ (vetor de valores singulares σ1 ≥ σ2 ≥ ... ≥ σr > 0) e V.",
                                    "Ordene os valores singulares em ordem decrescente."
                                  ],
                                  "verification": "Confirme que A ≈ U Σ V^T com erro numérico pequeno (ex: norm(A - U@diag(Σ)@V.T) < 1e-10).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy/SciPy ou MATLAB; matriz A e vetor b de exemplo.",
                                  "tips": "Sempre normalize A se necessário para evitar overflow numérico.",
                                  "learningObjective": "Dominar a computação prática da SVD e interpretação de seus componentes.",
                                  "commonMistakes": "Confundir ordem dos valores singulares ou ignorar zeros em Σ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular e calcular a solução dos quadrados mínimos usando pseudoinverso SVD",
                                  "subSteps": [
                                    "Construa o pseudoinverso A^+ = V Σ^+ U^T, onde Σ^+ inverte σi > threshold e zera os demais.",
                                    "Calcule x = A^+ b.",
                                    "Compute o resíduo r = b - A x e verifique ||r||_2.",
                                    "Confirme que x minimiza ||Ax - b||_2 entre todas as soluções possíveis.",
                                    "Plote ||Ax - b||_2 se m for pequeno para visualização."
                                  ],
                                  "verification": "Verifique que x é ortogonal ao núcleo de A^T e ||A x - b||_2 é mínimo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Mesmo software do step 1; funções linalg.pinv ou svd-based pinv.",
                                  "tips": "Use um threshold pequeno (ex: 1e-10 * σ1) para valores singulares próximos de zero.",
                                  "learningObjective": "Aplicar SVD para obter a solução mínima norma dos quadrados mínimos.",
                                  "commonMistakes": "Usar Σ^+ incorretamente para σi ≈ 0, levando a soluções instáveis."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a sensibilidade da solução via valores singulares",
                                  "subSteps": [
                                    "Examine o espectro de Σ: identifique σi próximos de zero (cond(A) = σ1/σ_min grande).",
                                    "Calcule a condição numérica cond(A) e avalie amplificação de erros em b para x.",
                                    "Simule ruído em b (ex: b_noisy = b + 0.01*randn) e compare x e x_noisy.",
                                    "Identifique componentes de x amplificados (coeficientes grandes em V correspondentes a σi pequenos).",
                                    "Discuta o gap no espectro de Σ para rank revelado."
                                  ],
                                  "verification": "Mostre que Δx / ||x|| ≈ cond(A) * Δb / ||b|| em simulações.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software com plotting (Matplotlib ou MATLAB plots); dados com ruído.",
                                  "tips": "Log-scale plot de σi para visualizar gaps facilmente.",
                                  "learningObjective": "Interpretar valores singulares para diagnosticar ill-posedness.",
                                  "commonMistakes": "Ignorar o fator de amplificação cond(A) na análise de erros."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar regularização para mitigar sensibilidade",
                                  "subSteps": [
                                    "Escolha método de regularização (ex: Tikhonov: min ||Ax - b||^2 + λ ||x||^2).",
                                    "Via SVD: x_λ = V (Σ^T (Σ Σ^T + λ I)^{-1} U^T b).",
                                    "Selecione λ via L-curve ou GCV, testando valores (ex: λ = σ_k^2 para k onde gap).",
                                    "Compare x_λ com x não-regularizado em termos de resíduo e norma de x.",
                                    "Avalie trade-off bias-variance."
                                  ],
                                  "verification": "x_λ tem ||x_λ|| razoável e resíduo controlado, melhor que x em dados ruidosos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Funções de regularização em SciPy (lsqr com reg) ou custom SVD.",
                                  "tips": "Comece com λ = 0 e aumente iterativamente.",
                                  "learningObjective": "Implementar e justificar regularização SVD-based.",
                                  "commonMistakes": "Escolha errada de λ levando a under/over-regularização."
                                }
                              ],
                              "practicalExample": "Em regressão linear com dados ruidosos de temperatura vs. vendas (A 100x5, rank 3), use SVD para fit x, detecte σ4≈σ5≈0 indicando multicolinearidade, aplique Tikhonov λ=0.01 para x estável prevendo vendas futuras com erro <5%.",
                              "finalVerifications": [
                                "Solução x satisfaz A^T (b - A x) = 0.",
                                "||Ax - b||_2 é mínimo e cond(A) corretamente computado.",
                                "Análise identifica σi < 1e-8 e impacto em sensibilidade.",
                                "Regularização reduz ||x|| sem explodir resíduo.",
                                "Simulação com ruído confirma análise.",
                                "Pseudocódigo ou código reproduz resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica da SVD e pseudoinverso (erro <1e-12).",
                                "Correta identificação de valores singulares críticos e cond(A)>10^6.",
                                "Análise qualitativa/quantitativa de sensibilidade com evidências.",
                                "Implementação válida de regularização com escolha motivada de λ.",
                                "Interpretação clara do trade-off regularização.",
                                "Código limpo e reproduzível."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Regressão linear ridge (Tikhonov).",
                                "Ciência de Dados: Análise PCA via SVD para redução dimensional.",
                                "Engenharia: Controle de sistemas ill-posed.",
                                "Física Computacional: Inversão tomográfica.",
                                "Machine Learning: Inicialização de redes e análise de features."
                              ],
                              "realWorldApplication": "Em processamento de imagens, SVD resolve sistemas overdetermined para deconvolução ruidosa (ex: restaurar fotos borradas), analisando sensibilidade para evitar artefatos e regularizando para imagens nítidas em apps como Photoshop ou medical imaging."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.1",
                              "10.1.5.5.2"
                            ]
                          },
                          {
                            "id": "10.1.5.5.3.3",
                            "name": "Avaliar sensibilidade em métodos iterativos",
                            "description": "Usar SVD para diagnosticar convergência lenta em métodos como CG devido a clusters de valores singulares, referenciando Golub & Van Loan.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos Teóricos de SVD e Métodos Iterativos",
                                  "subSteps": [
                                    "Estude a decomposição SVD: A = U Σ V^T, focando nos valores singulares σ_i.",
                                    "Revise o método do Gradiente Conjugado (CG) para Ax = b, e fatores que afetam sua convergência.",
                                    "Leia seção relevante de Golub & Van Loan (ex: Capítulo 10) sobre sensibilidade em métodos iterativos.",
                                    "Entenda como clusters de valores singulares próximos causam convergência lenta no CG.",
                                    "Anote equações chave: condição de parada do CG e bound de erro baseado em σ_max/σ_min."
                                  ],
                                  "verification": "Resuma em 3-5 frases o impacto de clusters singulares na convergência do CG.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro Golub & Van Loan (Matrix Computations)",
                                    "Notas de aula de Álgebra Linear Numérica",
                                    "Notebook Jupyter para anotações"
                                  ],
                                  "tips": "Use diagramas para visualizar clusters de σ_i em uma reta.",
                                  "learningObjective": "Compreender a teoria por trás da SVD na análise de sensibilidade para CG.",
                                  "commonMistakes": "Confundir SVD com EVD; ignorar que CG assume A simétrica positiva definida."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar Matriz de Exemplo e Configurar Ambiente Computacional",
                                  "subSteps": [
                                    "Gere ou selecione uma matriz A simétrica positiva definida de tamanho 100x100 com clusters singulares conhecidos (ex: soma de matrizes de baixa rank).",
                                    "Crie vetor b = A x0 para x0 aleatório.",
                                    "Configure software numérico (MATLAB/Python com SciPy/NumPy).",
                                    "Implemente função básica de CG para rodar iterações.",
                                    "Execute CG inicial e registre número de iterações para convergência."
                                  ],
                                  "verification": "Confirme que CG converge, mas note número alto de iterações (>50 para n=100).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python/MATLAB",
                                    "Bibliotecas: NumPy, SciPy (svds), scikit-learn",
                                    "Matriz de teste: gallery('randsvd', n=100, sigma=[1,1,0.1,0.1])"
                                  ],
                                  "tips": "Use svds() para SVD truncada em matrizes grandes.",
                                  "learningObjective": "Configurar problema prático para demonstrar convergência lenta.",
                                  "commonMistakes": "Escolher matriz mal-condicionada sem clusters; não verificar simetria de A."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar e Visualizar a SVD da Matriz",
                                  "subSteps": [
                                    "Calcule SVD completa ou truncada de A.",
                                    "Extraia vetor de valores singulares σ.",
                                    "Plote log(σ) vs índice para identificar clusters (agrupamentos próximos).",
                                    "Calcule gaps entre clusters: Δσ = σ_i - σ_{i+1}.",
                                    "Compare com bound teórico de convergência do CG."
                                  ],
                                  "verification": "Identifique pelo menos 2 clusters no plot de σ.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código Python/MATLAB para SVD e plotting (matplotlib)",
                                    "Função svdvals() ou sigma = svd(A, compute_uv=False)"
                                  ],
                                  "tips": "Escala logarítmica no plot destaca clusters pequenos.",
                                  "learningObjective": "Aplicar SVD computacionalmente e visualizar singular values.",
                                  "commonMistakes": "Usar SVD em matriz não simétrica; plot sem escala log."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diagnosticar Sensibilidade e Interpretar Resultados",
                                  "subSteps": [
                                    "Relacione clusters de σ próximos a subespaços invariantes lentos no CG.",
                                    "Preveja número de iterações ~ 1 / min(Δσ entre clusters).",
                                    "Teste com pré-condicionador para separar clusters e re-execute CG.",
                                    "Compare iterações antes/depois e valide diagnóstico.",
                                    "Documente referências de Golub & Van Loan para suporte teórico."
                                  ],
                                  "verification": "Redução >30% em iterações após ajuste baseado em SVD.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código CG com pré-condicionador simples (ex: diagonal baseado em V)",
                                    "Referências Golub & Van Loan Sec. 10.2.5"
                                  ],
                                  "tips": "Use subspace iteration para confirmar subespaços de clusters.",
                                  "learningObjective": "Diagnosticar e mitigar convergência lenta usando SVD.",
                                  "commonMistakes": "Ignorar normalização de σ; atribuir lentidão só a cond(A)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Generalizar o Diagnóstico",
                                  "subSteps": [
                                    "Teste em 2-3 matrizes diferentes (ex: discretização de Laplace com anisotropia).",
                                    "Gere relatório: plots, iterações, interpretação.",
                                    "Discuta limitações: custo computacional de SVD vs ganho em diagnóstico.",
                                    "Compare com outros métodos (GMRES) sensíveis a clusters.",
                                    "Extraia lições para problemas reais."
                                  ],
                                  "verification": "Relatório explica corretamente 80% dos casos testados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Matrizes teste adicionais (gallery('poisson'), custom)",
                                    "Template de relatório Markdown"
                                  ],
                                  "tips": "Automatize plots em loop para múltiplas matrizes.",
                                  "learningObjective": "Generalizar técnica para análise de sensibilidade iterativa.",
                                  "commonMistakes": "Overfitting a um exemplo; negligenciar custo O(n^3) da SVD."
                                }
                              ],
                              "practicalExample": "Considere A de 100x100 da gallery('randsvd',100,[1,1,0.01,0.01]). CG toma ~80 iterações. SVD revela dois clusters: σ≈1 (doblete) e σ≈0.01 (doblete). Gap pequeno causa lentidão. Pré-condicionador diagonal reduz para 20 iterações.",
                              "finalVerifications": [
                                "Computa SVD corretamente e identifica clusters em plot log.",
                                "Explica verbalmente ligação entre clusters σ e iterações CG.",
                                "Aplica diagnóstico para prever/mitigar em nova matriz.",
                                "Cita Golub & Van Loan com precisão contextual.",
                                "Valida numericamente redução de iterações pós-ajuste.",
                                "Discute trade-offs computacionais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de clusters singulares (90% match com ground truth).",
                                "Correta interpretação teórica (alinhada com Golub & Van Loan).",
                                "Efetividade prática: redução mensurável em iterações CG.",
                                "Qualidade de visualizações e documentação.",
                                "Generalização para casos não vistos.",
                                "Consciência de limitações numéricas/condicionamento."
                              ],
                              "crossCurricularConnections": [
                                "Otimização Numérica: Análise de Hessiana via SVD em gradiente conjugado não-linear.",
                                "Machine Learning: PCA/SVD para redução dimensional em dados com clusters espectrais.",
                                "Análise Numérica: Condicionamento em EDOs/PDEs discretizadas.",
                                "Processamento de Sinais: Análise de filtros com polos próximos via SVD."
                              ],
                              "realWorldApplication": "Em simulações de CFD (fluidodinâmica computacional), SVD diagnostica convergência lenta de CG em matrizes de discretização de Navier-Stokes, permitindo pré-condicionadores espectrais que aceleram solvers em grids de milhões de pontos, reduzindo tempo de simulação de horas para minutos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.1",
                              "10.1.5.5.2"
                            ]
                          },
                          {
                            "id": "10.1.5.5.3.4",
                            "name": "Construir pseudoinversa via SVD",
                            "description": "Computar A^+ = V Σ^+ U^T e analisar sua sensibilidade a perturbações em matrizes rank-deficientes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Realizar a Decomposição em Valores Singulares (SVD) da Matriz A",
                                  "subSteps": [
                                    "Escolha uma matriz A m×n, preferencialmente rank-deficiente (rank < min(m,n)).",
                                    "Utilize software ou método analítico para computar U (m×m ortogonal), Σ (m×n diagonal com valores singulares não-crescentes) e V (n×n ortogonal), tal que A = U Σ V^T.",
                                    "Verifique a decomposição multiplicando U Σ V^T e confirmando que resulta em A (dentro de tolerância numérica).",
                                    "Identifique os valores singulares zero ou próximos de zero para confirmar rank-deficiência.",
                                    "Registre os valores singulares σ_i e note os menores para análise posterior."
                                  ],
                                  "verification": "A = U Σ V^T holds numerically (erro < 1e-10). Rank estimado correto via número de σ_i > threshold.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software: Python (NumPy/SciPy) ou MATLAB",
                                    "Matriz exemplo rank-deficiente (ex: A = [[1,1],[1,1]])"
                                  ],
                                  "tips": "Use svd(full_matrices=False) para economia computacional em retangular.",
                                  "learningObjective": "Compreender e aplicar SVD para decompor matrizes rank-deficientes.",
                                  "commonMistakes": [
                                    "Confundir ordem dos valores singulares (devem ser decrescentes)",
                                    "Ignorar tolerância numérica para zeros",
                                    "Esquecer transposição em V^T"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Pseudoinversa Diagonal Σ^+",
                                  "subSteps": [
                                    "Inverta os valores singulares não-zero: σ_i^+ = 1/σ_i para σ_i > ε (threshold, ex: 1e-10).",
                                    "Defina σ_i^+ = 0 para σ_i ≤ ε.",
                                    "Monte Σ^+ como matriz diagonal n×m com os σ_i^+ na diagonal principal (transposta conceitual de Σ).",
                                    "Verifique dimensões: se Σ é m×n, Σ^+ é n×m.",
                                    "Confirme que Σ Σ^+ Σ = Σ (propriedade de pseudoinversa)."
                                  ],
                                  "verification": "Σ Σ^+ = diagonal com 1s nos ranks não-zero e zeros elsewhere.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Mesmos do Step 1",
                                    "Folha de cálculo para valores singulares"
                                  ],
                                  "tips": "Escolha ε baseado na precisão da máquina (eps * max(σ)) para robustez.",
                                  "learningObjective": "Dominar a construção do pseudoinverso diagonal a partir de SVD.",
                                  "commonMistakes": [
                                    "Inverter todos σ_i incluindo zeros",
                                    "Errar dimensões de Σ^+",
                                    "Usar reciprocals sem threshold"
                                  ]
                                },
                                {
                                  "5": {
                                    "stepNumber": 5,
                                    "title": "Verificação Final e Exploração de Aplicações",
                                    "subSteps": [
                                      "Teste A^+ em least-squares: min ||Ax - b|| para b inconsistente.",
                                      "Avalie estabilidade: perturbe b e veja variação em x = A^+ b.",
                                      "Discuta truncada SVD para regularização (reduzir cutoff).",
                                      "Documente relatório com código, plots e conclusões.",
                                      "Compare performance computacional vs. outros métodos (QR)."
                                    ],
                                    "verification": "Relatório completo com plots e métricas.",
                                    "estimatedTime": "45 minutos",
                                    "materials": [
                                      "Notebook Jupyter para relatório"
                                    ],
                                    "tips": "Salve session para reprodutibilidade.",
                                    "learningObjective": "Aplicar pseudoinversa em problemas reais e avaliar trade-offs.",
                                    "commonMistakes": [
                                      "Não testar com b no range(A)",
                                      "Esquecer regularização em ill-conditioned"
                                    ]
                                  },
                                  "stepNumber": 3,
                                  "title": "Computar a Pseudoinversa Completa A^+ = V Σ^+ U^T",
                                  "subSteps": [
                                    "Multiplique V (n×n) por Σ^+ (n×m) para obter V Σ^+.",
                                    "Multiplique o resultado por U^T (m×m) para A^+ (n×m).",
                                    "Verifique propriedades: A A^+ A = A e A^+ A A^+ = A^+.",
                                    "Compute ||A A^+ - I|| para projeção.",
                                    "Compare com pseudoinversa via pinv() no software para validação.",
                                    "verification]: "
                                  ],
                                  "propriedades Moore-Penrose satisfeitas (4 condições) dentro de tolerância 1e-8). A^+ pinv(A) coincide.": "estimatedTime",
                                  "40 minutos": "materials",
                                  "Python/MATLAB, exemplos de matrizes": "tips",
                                  "Evite loops; use matrix multiply otimizado (dot/@).": "learningObjective",
                                  "Montar pseudoinversa via SVD e validar.": "commonMistakes",
                                  "Esquecer U^T ou V (não V^T aqui), inverter ordem de multiplicação": {
                                    "stepNumber": 4,
                                    "title": "Analisar Sensibilidade a Perturbações em A Rank-Deficiente",
                                    "subSteps": [
                                      "Perturbe A adicionando ruído pequeno E (ex: ||E||=1e-6 * ||A||) em entradas aleatórias.",
                                      "Recomputar SVD e A^+ para A + E.",
                                      "Compute Δ = ||A^+ - (A+E)^+|| / ||A^+|| (sensibilidade relativa).",
                                      "Analise impacto dos pequenos σ_i: cond(A) ≈ σ_max/σ_min amplifica erros.",
                                      "Compare com caso full-rank; discuta ill-posedness em rank-def."
                                    ],
                                    "verification": "Gráfico de Δ vs. tamanho perturbação mostra amplificação por 1/σ_min.",
                                    "estimatedTime": "60 minutos",
                                    "materials": [
                                      "Software com plotting (Matplotlib)",
                                      "Função randn para E"
                                    ],
                                    "tips": "Use log-scale para plots de sensibilidade.",
                                    "learningObjective": "Interpretar como SVD revela e quantifica sensibilidade.",
                                    "commonMistakes": [
                                      "Perturbações grandes demais (mascara efeito)",
                                      "Ignorar normalização relativa",
                                      "Confundir cond com 1/σ_min sem contexto"
                                    ]
                                  }
                                },
                                "practicalExample: "
                              ],
                              "Para A = [[1, 1], [1,1], [0,0]] (rank 1), SVD dá σ1≈1.41, σ2,3=0. Compute A^+ e perturbe última linha por 1e-5; observe ΔA^+ ~ 1e3 vezes maior devido a σ pequeno.": "finalVerifications",
                              ":[  ": "SVD correta: A = U Σ V^T exato.",
                              "Σ^+: apenas σ1^+ = 1/σ1, outros zero correto.Dimensions match (n×m).”,  ": "A^+ satisfaz 4 propriedades Moore-Penrose.",
                              "Sensibilidade: ΔA^+ / ||A^+|| >> ||E|| / ||A|| por fator cond(A).”,  ": "Código reproduzível e plots mostram amplificação.",
                              "Aplicação least-squares resolve min ||Ax-b|| corretamente.”,  ": "Discussão inclui truncada SVD para mitigação.”  ]  ],",
                              "assessmentCriteria": [
                                "Precisão numérica da SVD e A^+ (erro < 1e-10).",
                                "Correta identificação e inversão seletiva de σ_i com threshold.",
                                "Análise quantitativa de sensibilidade com métricas relativas e plots.",
                                "Validação de propriedades Moore-Penrose.",
                                "Interpretação física: ligação entre pequenos σ e ill-conditioning.",
                                "Criatividade em exemplo/extensões (ex: regularização)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Regressão linear ridge via truncada SVD.",
                                "Machine Learning: Principal Component Regression (PCR).",
                                "Processamento de Sinais: Compressão de imagens denoising.",
                                "Física Computacional: Solvers para equações diferenciais ill-posed."
                              ],
                              "realWorldApplication": "Em engenharia, usado para controle ótimo em sistemas underactuated (rank-def) onde perturbações sensoriais amplificam erros; SVD guia regularização para robustez em drones/autônomos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.1",
                              "10.1.5.5.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.6",
                "name": "Análise de Métodos Iterativos Clássicos",
                "description": "Exame de convergência e análise de métodos iterativos como Jacobi, Gauss-Seidel para sistemas lineares.",
                "totalSkills": 44,
                "atomicTopics": [
                  {
                    "id": "10.1.6.1",
                    "name": "Método Iterativo de Jacobi",
                    "description": "Formulação e implementação do método de Jacobi para resolução de sistemas lineares Ax=b.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.1.1",
                        "name": "Formulação Matemática do Método de Jacobi",
                        "description": "Derivação da decomposição da matriz A em componentes diagonal D, triangular inferior estrita L e triangular superior estrita U, levando à fórmula iterativa para resolver sistemas lineares Ax = b.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.1.1",
                            "name": "Decompor matriz A em D, L e U",
                            "description": "Identificar e extrair os elementos da diagonal principal para formar D, os elementos abaixo da diagonal para L (sem diagonal) e acima para U (sem diagonal), garantindo que A = D + L + U.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a estrutura da matriz A",
                                  "subSteps": [
                                    "Escreva a matriz A explicitamente, identificando seu tamanho n x n.",
                                    "Localize a diagonal principal (elementos onde i = j).",
                                    "Identifique os elementos estritamente abaixo da diagonal (i > j).",
                                    "Identifique os elementos estritamente acima da diagonal (i < j).",
                                    "Verifique se A é quadrada e diagonalmente dominante (opcional para Jacobi)."
                                  ],
                                  "verification": "Crie um diagrama da matriz destacando diagonal, abaixo e acima com cores diferentes.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel quadriculado, lápis, matriz A exemplo impressa ou digital.",
                                  "tips": "Use índices i (linhas) e j (colunas) para sistematizar: para cada posição (i,j), classifique como diagonal, L ou U.",
                                  "learningObjective": "Compreender a decomposição posicional dos elementos de uma matriz simétrica ou não em componentes D, L e U.",
                                  "commonMistakes": "Confundir linhas com colunas ou ignorar que A deve ser quadrada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz diagonal D",
                                  "subSteps": [
                                    "Crie uma matriz n x n zerada.",
                                    "Copie os elementos da diagonal principal de A para D (D_{ii} = A_{ii}).",
                                    "Preencha todos os elementos fora da diagonal com zero.",
                                    "Nomeie explicitamente cada elemento: D_{11} = A_{11}, etc.",
                                    "Confirme que D é diagonal."
                                  ],
                                  "verification": "Verifique se todos os elementos fora da diagonal são zero e diagonal matches A.",
                                  "estimatedTime": "8 minutos",
                                  "materials": "Papel quadriculado, lápis, calculadora para valores numéricos.",
                                  "tips": "D representa a 'parte diagonal dominante' no método de Jacobi.",
                                  "learningObjective": "Extrair precisamente a diagonal principal para formar D.",
                                  "commonMistakes": "Copiar elementos errados da diagonal ou deixar resíduos não-zero fora dela."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a matriz estritamente triangular inferior L",
                                  "subSteps": [
                                    "Crie uma matriz n x n zerada.",
                                    "Copie os elementos abaixo da diagonal de A para L (L_{ij} = A_{ij} para i > j).",
                                    "Defina diagonal de L como zero e acima da diagonal como zero.",
                                    "Para uma matriz 3x3, preencha L_{21}=A_{21}, L_{31}=A_{31}, L_{32}=A_{32}.",
                                    "Rotule como 'estritamente inferior'."
                                  ],
                                  "verification": "Confirme zeros na diagonal e acima; apenas abaixo tem valores de A.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel quadriculado, lápis.",
                                  "tips": "L é a parte 'abaixo' que será negada em algumas formulações de Jacobi.",
                                  "learningObjective": "Isolar corretamente os elementos triangulares inferiores sem incluir a diagonal.",
                                  "commonMistakes": "Incluir diagonal em L ou inverter elementos de A."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir U e verificar a decomposição A = D + L + U",
                                  "subSteps": [
                                    "Crie matriz n x n zerada para U.",
                                    "Copie elementos acima da diagonal de A para U (U_{ij} = A_{ij} para i < j).",
                                    "Defina diagonal e abaixo como zero.",
                                    "Some element-wise: para cada (i,j), C_{ij} = D_{ij} + L_{ij} + U_{ij}.",
                                    "Compare C com A original para validar."
                                  ],
                                  "verification": "A matriz soma deve ser idêntica a A em todos os elementos.",
                                  "estimatedTime": "12 minutos",
                                  "materials": "Papel quadriculado, lápis, calculadora ou software como Python/NumPy para soma.",
                                  "tips": "Faça a soma manualmente primeiro, depois automatize se possível.",
                                  "learningObjective": "Completar U e validar a equação fundamental da decomposição.",
                                  "commonMistakes": "Esquecer de zerar diagonal em U ou erros de sinal na soma."
                                }
                              ],
                              "practicalExample": "Para A = [[4, -1, 0], [-1, 4, -1], [0, -1, 4]]:\nD = [[4, 0, 0], [0, 4, 0], [0, 0, 4]]\nL = [[0, 0, 0], [-1, 0, 0], [0, -1, 0]]\nU = [[0, -1, 0], [0, 0, -1], [0, 0, 0]]\nVerifique: D + L + U = A.",
                              "finalVerifications": [
                                "D contém apenas a diagonal de A, zeros fora.",
                                "L tem valores de A apenas abaixo da diagonal, zeros em diagonal e acima.",
                                "U tem valores de A apenas acima da diagonal, zeros em diagonal e abaixo.",
                                "Soma element-wise D + L + U resulta exatamente em A.",
                                "Todas as matrizes são do mesmo tamanho n x n.",
                                "Nenhum elemento da diagonal foi duplicado em L ou U."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração de elementos (100% match com A).",
                                "Correta colocação de zeros em posições não pertencentes.",
                                "Validação correta da soma A = D + L + U.",
                                "Clareza na apresentação das matrizes (rótulos, índices).",
                                "Explicação verbal da decomposição.",
                                "Tempo de execução dentro do estimado."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar decomposição em NumPy/Python para automação.",
                                "Física: Resolver sistemas lineares em circuitos elétricos ou mecânica.",
                                "Engenharia Computacional: Pré-condicionadores em solvers iterativos.",
                                "Economia: Modelos input-output lineares em análise econômica."
                              ],
                              "realWorldApplication": "Essa decomposição é essencial no Método de Jacobi para resolver grandes sistemas lineares Ax = b em simulações numéricas, como previsão climática, análise de estruturas em engenharia ou otimização em machine learning."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.2",
                            "name": "Derivar a fórmula iterativa de Jacobi",
                            "description": "Partir de Ax = b, isolar o termo diagonal Dx^{(k+1)} = b - (L + U)x^{(k)}, e obter x^{(k+1)} = D^{-1}(b - (L + U)x^{(k)}).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Decompor a matriz A em componentes diagonal (D), triangular inferior estrita (L) e superior estrita (U)",
                                  "subSteps": [
                                    "Identifique os elementos da diagonal principal de A e forme a matriz diagonal D com esses elementos.",
                                    "Extraia os elementos abaixo da diagonal para formar L (matriz triangular inferior estrita, zeros na diagonal).",
                                    "Extraia os elementos acima da diagonal para formar U (matriz triangular superior estrita, zeros na diagonal).",
                                    "Verifique que A = D + L + U somando as matrizes.",
                                    "Confirme que D é diagonal dominante ou invertível para o método de Jacobi."
                                  ],
                                  "verification": "Escreva explicitamente D, L e U para uma matriz de exemplo e confirme A = D + L + U.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Exemplo de matriz 2x2 ou 3x3",
                                    "Calculadora opcional"
                                  ],
                                  "tips": "Sempre use uma matriz pequena inicialmente para visualizar a decomposição.",
                                  "learningObjective": "Compreender a estrutura matricial necessária para métodos iterativos.",
                                  "commonMistakes": [
                                    "Incluir diagonal em L ou U",
                                    "Confundir elementos de L e U"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever a equação do sistema linear Ax = b usando a decomposição A = D + L + U",
                                  "subSteps": [
                                    "Substitua A por D + L + U na equação Ax = b, obtendo (D + L + U)x = b.",
                                    "Expanda o produto matricial: Dx + Lx + Ux = b.",
                                    "Mantenha a equação na forma matricial sem expandir ainda.",
                                    "Discuta a motivação: isolar D para inverter facilmente.",
                                    "Anote simbolicamente para generalidade."
                                  ],
                                  "verification": "Reescreva a equação corretamente em termos de D, L, U e x.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Decomposição do Step 1"
                                  ],
                                  "tips": "Use parênteses para agrupar D + (L + U) visualmente.",
                                  "learningObjective": "Expressar o sistema linear na base da decomposição espectral simples.",
                                  "commonMistakes": [
                                    "Escrever D + L + U incorretamente como produto",
                                    "Ignorar a soma matricial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Isolar o termo diagonal: Dx = b - (L + U)x",
                                  "subSteps": [
                                    "Subtraia (L + U)x de ambos os lados: Dx = b - (L + U)x.",
                                    "Justifique: move os termos off-diagonal para o lado direito.",
                                    "Verifique algebricamente multiplicando ambos os lados por D^{-1} (conceitualmente).",
                                    "Aplique a um exemplo numérico para validar.",
                                    "Enfatize que L + U é a parte off-diagonal."
                                  ],
                                  "verification": "Derive e escreva Dx = b - (L + U)x a partir da equação anterior.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Exemplo numérico"
                                  ],
                                  "tips": "Pense em D como o 'principal' e o resto como 'perturbação'.",
                                  "learningObjective": "Manipular equações matriciais para isolar componentes principais.",
                                  "commonMistakes": [
                                    "Escrever b - Dx = (L + U)x em vez de isolar Dx",
                                    "Confundir sinais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Introduzir a iteração: Dx^{(k+1)} = b - (L + U)x^{(k)} e resolver para x^{(k+1)}",
                                  "subSteps": [
                                    "Substitua x no lado direito por x^{(k)} (aproximação anterior) e Dx por Dx^{(k+1)} (nova aproximação).",
                                    "Multiplique ambos os lados por D^{-1}: x^{(k+1)} = D^{-1}(b - (L + U)x^{(k)}).",
                                    "Explique o processo iterativo: começa com x^{(0)}, gera x^{(1)}, etc.",
                                    "Verifique com uma iteração manual em exemplo.",
                                    "Discuta convergência qualitativamente (diagonal dominante)."
                                  ],
                                  "verification": "Escreva a fórmula final x^{(k+1)} = D^{-1}(b - (L + U)x^{(k)}) e aplique uma iteração.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora para inverso diagonal",
                                    "Exemplo completo"
                                  ],
                                  "tips": "Inverso de D é fácil: cada elemento é 1/diagonal.",
                                  "learningObjective": "Derivar a fórmula iterativa padrão do método de Jacobi.",
                                  "commonMistakes": [
                                    "Usar x^{(k+1)} no lado direito",
                                    "Esquecer D^{-1}"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[4, 1], [1, 3]], b = [5, 5]: D = [[4,0],[0,3]], L = [[0,0],[1,0]], U = [[0,1],[0,0]]. Então x^{(k+1)} = [[1/4,0],[0,1/3]] * ( [5,5] - (L+U) x^{(k)} ). Com x^{(0)} = [0,0], x^{(1)} = [5/4, 5/3].",
                              "finalVerifications": [
                                "Decompor corretamente A em D, L, U.",
                                "Derivar Dx = b - (L + U)x.",
                                "Obter x^{(k+1)} = D^{-1}(b - (L + U)x^{(k)}).",
                                "Aplicar a fórmula a uma matriz 2x2.",
                                "Explicar verbalmente cada transição.",
                                "Identificar pré-condições como diagonal dominante."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica em todas as derivações (sem erros de sinal ou decomposição).",
                                "Clareza na justificativa de cada passo iterativo.",
                                "Correta aplicação numérica em exemplo fornecido.",
                                "Compreensão conceitual da convergência.",
                                "Uso apropriado de notação matricial.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar Jacobi em Python/NumPy para sistemas lineares.",
                                "Física: Resolver equações de equilíbrio em redes elétricas.",
                                "Economia: Modelos de equilíbrio de mercado com sistemas lineares.",
                                "Engenharia: Análise de estruturas finitas elementares."
                              ],
                              "realWorldApplication": "O método de Jacobi é usado em solvers numéricos para sistemas lineares grandes e esparsos, como em simulações CFD (dinâmica de fluidos computacional), processamento de imagens (filtro gaussiano aproximado) e otimização em machine learning (pré-condicionadores)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.1.3",
                            "name": "Expressar em forma de iteração afim",
                            "description": "Reescrever a iteração como x^{(k+1)} = G x^{(k)} + c, onde G = -D^{-1}(L + U) é a matriz de iteração e c = D^{-1}b.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a decomposição matricial de A em D, L e U",
                                  "subSteps": [
                                    "Identifique a matriz A do sistema Ax = b.",
                                    "Extraia a matriz diagonal D, cujos elementos são os da diagonal principal de A.",
                                    "Forme a matriz L com os elementos estritamente abaixo da diagonal de A.",
                                    "Forme a matriz U com os elementos estritamente acima da diagonal de A.",
                                    "Verifique que A = D + L + U."
                                  ],
                                  "verification": "Confirme que a soma D + L + U resulta exatamente em A.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matriz A exemplo",
                                    "Papel e lápis ou software como Python/NumPy"
                                  ],
                                  "tips": "Use uma matriz pequena (2x2 ou 3x3) para praticar visualmente.",
                                  "learningObjective": "Compreender a decomposição triangular de A essencial para métodos iterativos.",
                                  "commonMistakes": "Incluir elementos da diagonal em L ou U; sempre verifique a soma."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever a equação iterativa padrão do método de Jacobi",
                                  "subSteps": [
                                    "Parta da equação Ax = b e isole o termo diagonal: D x = - (L + U) x + b.",
                                    "Aplique a inversa de D: x = D^{-1} [ - (L + U) x + b ].",
                                    "Introduza o índice de iteração: x^{(k+1)} = D^{-1} [ b - (L + U) x^{(k)} ].",
                                    "Simplifique a expressão interna.",
                                    "Anote a dependência apenas em x^{(k)}."
                                  ],
                                  "verification": "A equação deve expressar x^{(k+1)} unicamente em termos de x^{(k)} e b.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Decomposição de A do passo anterior",
                                    "Calculadora para inversa de D"
                                  ],
                                  "tips": "D é diagonal, então D^{-1} é fácil: cada elemento é 1/d_ii.",
                                  "learningObjective": "Derivar a iteração explícita de Jacobi a partir do sistema linear.",
                                  "commonMistakes": "Esquecer o sinal negativo em -(L + U); teste com valores numéricos simples."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reescrever a iteração na forma afim x^{(k+1)} = G x^{(k)} + c",
                                  "subSteps": [
                                    "Fatore a expressão: x^{(k+1)} = [ - D^{-1} (L + U) ] x^{(k)} + D^{-1} b.",
                                    "Identifique G como a matriz de iteração: G = - D^{-1} (L + U).",
                                    "Identifique o vetor constante c = D^{-1} b.",
                                    "Substitua na forma geral x^{(k+1)} = G x^{(k)} + c.",
                                    "Confirme que é uma transformação afim linear."
                                  ],
                                  "verification": "Substitua G e c na forma afim e veja se recupera a iteração original.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Expressão do passo 2",
                                    "Software para multiplicação matricial"
                                  ],
                                  "tips": "Multiplique D^{-1} por (L + U) passo a passo para visualizar G.",
                                  "learningObjective": "Transformar a iteração em forma padrão afim para análise de convergência.",
                                  "commonMistakes": "Erro no sinal de G (deve ser negativo); sempre isole o termo com x^{(k)}."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e praticar com um exemplo numérico",
                                  "subSteps": [
                                    "Escolha uma matriz A diagonal-dominante, como A = [[4,1],[1,3]], b = [5,5].",
                                    "Compute D, L, U, D^{-1}, G e c.",
                                    "Calcule x^{(1)} a partir de x^{(0)} = [0,0] usando ambas as formas.",
                                    "Compare os resultados para validação.",
                                    "Analise o raio espectral de G rapidamente (opcional para verificação)."
                                  ],
                                  "verification": "As duas formas (iterativa e afim) produzem o mesmo x^{(1)}.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplo numérico",
                                    "Python/MATLAB ou calculadora matricial"
                                  ],
                                  "tips": "Use NumPy para automação: np.linalg.inv(D) @ (L + U).",
                                  "learningObjective": "Aplicar a formulação afim em um caso concreto para consolidação.",
                                  "commonMistakes": "Erro aritmético em inversas ou multiplicações; use software para checar."
                                }
                              ],
                              "practicalExample": "Para A = [[10, 2, 0], [-1, 8, -1], [0, 1, 6]] e b = [6, 25, -11]:\nD = [[10,0,0],[0,8,0],[0,0,6]], L = [[0,0,0],[-1,0,0],[0,0,0]], U = [[0,2,0],[0,0,-1],[0,1,0]].\nG = -D^{-1}(L+U) = [[0,-0.2,0],[0.125,0,0.125], [0,-0.1667,0]], c = D^{-1}b = [0.6, 3.125, -1.8333].\nAssim, x^{(k+1)} = G x^{(k)} + c.",
                              "finalVerifications": [
                                "Pode decompor qualquer A 3x3 em D, L, U corretamente?",
                                "Deriva a iteração de Jacobi na forma afim sem consultar notas?",
                                "Identifica G e c explicitamente para um exemplo dado?",
                                "Verifica numericamente que a forma afim reproduz a iteração?",
                                "Explica o papel de G na convergência do método?",
                                "Aplica a formulação a uma matriz não simétrica?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na decomposição D + L + U = A (100% correto).",
                                "Correção dos sinais e fatores em G = -D^{-1}(L+U) e c = D^{-1}b.",
                                "Capacidade de derivar a forma afim passo a passo.",
                                "Validação numérica com erro < 10^{-6} em exemplo prático.",
                                "Clareza na explicação oral ou escrita da formulação.",
                                "Identificação de condições para convergência via ||G|| < 1."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar G e c em Python/NumPy para simulações iterativas.",
                                "Física: Resolver sistemas lineares em mecânica (equilíbrios elásticos).",
                                "Computação Científica: Análise de convergência em PDEs numéricas.",
                                "Estatística: Iterações em modelos de regressão linear iterativa."
                              ],
                              "realWorldApplication": "Em engenharia civil, resolve sistemas lineares grandes de equações de equilíbrio estrutural via Jacobi em softwares como MATLAB, acelerando simulações de pontes ou edifícios sob cargas dinâmicas."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.2",
                        "name": "Condições de Convergência do Método",
                        "description": "Análise das condições matemáticas para garantir que a sequência iterativa convirja para a solução única do sistema linear Ax = b.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.2.1",
                            "name": "Calcular a matriz de iteração G",
                            "description": "Computar G = -D^{-1}(L + U) explicitamente para uma matriz A dada, verificando suas propriedades espectrais iniciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Decompor a matriz A em componentes D, L e U",
                                  "subSteps": [
                                    "Identifique os elementos da diagonal principal de A e forme a matriz diagonal D.",
                                    "Extraia os elementos estritamente abaixo da diagonal para formar a matriz L (triangular inferior estrita).",
                                    "Extraia os elementos estritamente acima da diagonal para formar a matriz U (triangular superior estrita).",
                                    "Escreva explicitamente as matrizes D, L e U.",
                                    "Verifique a decomposição somando D + L + U e confirmando que resulta em A."
                                  ],
                                  "verification": "A soma D + L + U deve igualar exatamente a matriz A original.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Matriz A de exemplo (papel e lápis ou software como Python/NumPy ou MATLAB)",
                                    "Calculadora matricial"
                                  ],
                                  "tips": "Mantenha zeros na diagonal de L e U para garantir a decomposição SPLIT correta.",
                                  "learningObjective": "Compreender a decomposição de uma matriz simétrica ou não em componentes para métodos iterativos.",
                                  "commonMistakes": [
                                    "Incluir elementos da diagonal em L ou U",
                                    "Confundir posições de L (abaixo) e U (acima)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a matriz R = L + U",
                                  "subSteps": [
                                    "Some os elementos correspondentes de L e U, posição por posição.",
                                    "Preencha a diagonal de R com zeros, pois L e U têm zeros na diagonal.",
                                    "Escreva a matriz R explicitamente.",
                                    "Verifique se R possui zeros na diagonal.",
                                    "Confira a soma elemento a elemento com L e U originais."
                                  ],
                                  "verification": "Cada elemento de R deve ser a soma exata de L e U na mesma posição, com diagonal zero.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Matrizes L e U do passo anterior",
                                    "Papel e lápis ou software matricial"
                                  ],
                                  "tips": "R representa a parte off-diagonal de A, facilitando o cálculo de G.",
                                  "learningObjective": "Reconhecer a estrutura off-diagonal para métodos de relaxação.",
                                  "commonMistakes": [
                                    "Esquecer de zerar a diagonal",
                                    "Somar incorretamente elementos não correspondentes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a inversa diagonal D^{-1}",
                                  "subSteps": [
                                    "Identifique os elementos diagonais de D (não nulos).",
                                    "Calcule o inverso de cada elemento diagonal: (D^{-1})_{ii} = 1 / D_{ii}.",
                                    "Forme a matriz diagonal D^{-1} com esses valores.",
                                    "Verifique multiplicando D * D^{-1} = I (identidade).",
                                    "Confirme que D^{-1} é diagonal."
                                  ],
                                  "verification": "O produto matricial D * D^{-1} deve resultar na matriz identidade I.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Matriz D do passo 1",
                                    "Calculadora para inversos"
                                  ],
                                  "tips": "Como D é diagonal, a inversa é simples: inverta cada entrada diagonal individualmente.",
                                  "learningObjective": "Dominar o cálculo de inversa para matrizes diagonais dominantes.",
                                  "commonMistakes": [
                                    "Calcular inverso errado de elementos (ex: 1/0 ou sinal trocado)",
                                    "Não verificar o produto D * D^{-1}"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar a matriz de iteração G = -D^{-1} R",
                                  "subSteps": [
                                    "Calcule o produto matricial D^{-1} * R.",
                                    "Multiplique o resultado por -1 para obter G.",
                                    "Escreva G explicitamente, elemento por elemento.",
                                    "Verifique uma linha ou coluna manualmente.",
                                    "Confirme que G tem zeros na diagonal (propriedade do Jacobi)."
                                  ],
                                  "verification": "G deve satisfazer G = -D^{-1}(L + U), com diagonal zero.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Matrizes D^{-1} e R dos passos anteriores",
                                    "Software para multiplicação matricial recomendada"
                                  ],
                                  "tips": "Use multiplicação matricial: linha de D^{-1} por coluna de R, escalado por diagonal.",
                                  "learningObjective": "Executar multiplicação matricial para formar a matriz de iteração.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo",
                                    "Erro na ordem de multiplicação (D^{-1} R, não R D^{-1})"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar propriedades espectrais iniciais de G",
                                  "subSteps": [
                                    "Calcule as normas de G: ||G||_∞ e ||G||_2 (se possível).",
                                    "Estime ou calcule o raio espectral ρ(G) = max |λ_i| dos autovalores.",
                                    "Use software para autovalores exatos de G.",
                                    "Verifique se ρ(G) < 1 (condição de convergência para Jacobi).",
                                    "Registre propriedades: diagonal zero, simetria se A simétrica."
                                  ],
                                  "verification": "ρ(G) < 1 indica convergência; normas devem ser <1 para garantia.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matriz G",
                                    "Software com eigenvals (Python/NumPy eigvals, MATLAB eig)"
                                  ],
                                  "tips": "Para matrizes pequenas, calcule autovalores manualmente; use numpy.linalg.eig para precisão.",
                                  "learningObjective": "Analisar o espectro de G para prever convergência iterativa.",
                                  "commonMistakes": [
                                    "Confundir raio espectral com autovalor dominante",
                                    "Não usar software para matrizes >2x2"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[4, 1, 0], [1, 5, 2], [0, 2, 6]]. Decomposição: D = [[4,0,0],[0,5,0],[0,0,6]], L = [[0,0,0],[1,0,0],[0,0,0]], U = [[0,1,0],[0,0,2],[0,0,0]]. R = L+U = [[0,1,0],[1,0,2],[0,0,0]]. D^{-1} = [[0.25,0,0],[0,0.2,0],[0,0,1/6]]. G = -D^{-1}R = [[-0.25, 0, 0], [-0.2, 0, -0.4], [0, -1/3, 0]]. Autovalores aproximados: ρ(G) ≈ 0.447 < 1 (converge).",
                              "finalVerifications": [
                                "G = -D^{-1}(L + U) calculada corretamente elemento por elemento.",
                                "Diagonal de G é zero.",
                                "Decomposição A = D + L + U validada.",
                                "D * D^{-1} = I confirmada.",
                                "Raio espectral ρ(G) < 1 estimado ou calculado.",
                                "Normas de G (∞ e 2) < 1 verificadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na decomposição D, L, U (sem erros posicionais).",
                                "Correção no cálculo de D^{-1} e produto matricial para G.",
                                "Verificação explícita de propriedades (soma, produto, diagonal zero).",
                                "Análise espectral correta com uso de ferramentas adequadas.",
                                "Explicação clara de ρ(G) e implicações para convergência.",
                                "Uso eficiente de tempo e materiais sem erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar decomposição e cálculo de G em Python/NumPy para automação.",
                                "Física: Aplicar em sistemas lineares de equações diferenciais em simulações dinâmicas.",
                                "Engenharia Computacional: Integração com solvers iterativos em CFD (dinâmica de fluidos).",
                                "Estatística: Análise de convergência em modelos de regressão multivariada."
                              ],
                              "realWorldApplication": "Cálculo de G é essencial para prever convergência do método de Jacobi em solvers de grandes sistemas lineares, usados em simulações numéricas de engenharia (estruturas, fluidos), processamento de imagens e machine learning (otimização iterativa)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.3"
                            ]
                          },
                          {
                            "id": "10.1.6.1.2.2",
                            "name": "Aplicar critério espectral de convergência",
                            "description": "Verificar se o raio espectral ρ(G) < 1 garante convergência linear, e relacionar com o erro e_k = x - x^{(k)} satisfazendo e_{k+1} ≈ G e_k.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a matriz de iteração G no método de Jacobi",
                                  "subSteps": [
                                    "Relembre a decomposição A = D - L - U, onde D é diagonal, L triagular inferior, U superior.",
                                    "Derive a matriz G = D^{-1}(L + U) explicitamente para o método de Jacobi.",
                                    "Escreva a iteração x^{(k+1)} = G x^{(k)} + D^{-1} b.",
                                    "Defina o erro e_k = x - x^{(k)}, mostrando que e_{k+1} = G e_k.",
                                    "Discuta por que a convergência depende das propriedades espectrais de G."
                                  ],
                                  "verification": "Escreva corretamente a expressão de G e e_{k+1} para um sistema 2x2 simples e confirme que satisfaz a relação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, matriz de exemplo Ax=b, calculadora básica",
                                  "tips": "Sempre normalize A para facilitar cálculos iniciais; comece com sistemas simétricos positivos definidos.",
                                  "learningObjective": "Compreender a origem e o papel da matriz G na análise de erro do método de Jacobi.",
                                  "commonMistakes": "Confundir G com -D^{-1}(L+U) (sinal errado); esquecer que é exata só se x^{(0)}=0."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o raio espectral ρ(G)",
                                  "subSteps": [
                                    "Defina o espectro de G como o conjunto de autovalores λ_i.",
                                    "Explique ρ(G) = max |λ_i| sobre todos autovalores.",
                                    "Use métodos numéricos ou analíticos para encontrar autovalores de G (ex: polinômio característico para matrizes pequenas).",
                                    "Implemente em software para matrizes maiores, verificando precisão.",
                                    "Compare ρ(G) com outras normas como ||G||_∞ para insights."
                                  ],
                                  "verification": "Para uma matriz G 3x3, liste todos autovalores e compute ρ(G) corretamente, com erro < 10^{-6}.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software como MATLAB/Python (numpy.linalg.eig), ou calculadora matricial",
                                  "tips": "Para matrizes esparsas, use power iteration para estimar o autovalor dominante.",
                                  "learningObjective": "Dominar o cálculo preciso do raio espectral como métrica de contração.",
                                  "commonMistakes": "Usar autovalores complexos sem módulo; confundir ρ(G) com traço ou determinante."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a condição de convergência ρ(G) < 1",
                                  "subSteps": [
                                    "Estabeleça o teorema: se ρ(G) < 1, então ||G^k|| → 0, implicando ||e_{k+1}|| ≤ ρ(G) ||e_k||.",
                                    "Prove ou recite que isso garante convergência linear com taxa ρ(G).",
                                    "Teste numericamente: itere o método e plote ||e_k|| vs k, confirmando decaimento exponencial.",
                                    "Discuta o caso ρ(G) ≥ 1: divergência ou estagnação.",
                                    "Relacione com ||e_{k+1}|| ≈ ρ(G) ||e_k|| para grandes k."
                                  ],
                                  "verification": "Para um exemplo, confirme ρ(G) < 1 e observe redução de erro em 5 iterações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Script Python/MATLAB para iterações e plot de erros, sistema Ax=b de teste",
                                  "tips": "Use norma euclidiana para erros; log-plot para visualizar linearidade.",
                                  "learningObjective": "Aplicar o critério espectral para prever e validar convergência linear.",
                                  "commonMistakes": "Ignorar autovalores na borda da unidade; assumir convergência sem checar ρ(G)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e interpretar resultados em contexto prático",
                                  "subSteps": [
                                    "Compare taxa de convergência com outros métodos (ex: Gauss-Seidel).",
                                    "Estime número de iterações necessárias: k ≈ log(ε)/log(ρ(G)).",
                                    "Discuta aceleração se ρ(G) próximo de 1.",
                                    "Aplique a malhas finitas ou problemas reais onde Jacobi é usado.",
                                    "Documente relatório com gráficos de erro e ρ(G)."
                                  ],
                                  "verification": "Gere relatório mostrando convergência confirmada e predição de iterações acertada em ±10%.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramentas de plot (matplotlib), exemplos de sistemas grandes",
                                  "tips": "Salve seeds para reprodutibilidade em simulações numéricas.",
                                  "learningObjective": "Interpretar o critério espectral para otimização de métodos iterativos.",
                                  "commonMistakes": "Superestimar velocidade se ρ(G) > 0.9; não considerar custo computacional."
                                }
                              ],
                              "practicalExample": "Considere o sistema Ax = b com A = [[4,1,0],[1,3,1],[0,1,2]], b=[5,6,3]. Compute D^{-1}(L+U) = G, encontre autovalores ≈ [0.4, -0.3, 0.2], ρ(G)=0.4 <1. Itere de x0=[0,0,0], observe ||e_k|| reduzindo por fator ~0.4 por iteração.",
                              "finalVerifications": [
                                "ρ(G) calculado corretamente com todos autovalores listados.",
                                "Condição ρ(G)<1 explicitamente checada e justificada.",
                                "Relação e_{k+1} = G e_k derivada e verificada numericamente.",
                                "Gráfico de log||e_k|| vs k linear com inclinação log(ρ(G)).",
                                "Predição de iterações para ε=10^{-6} coincide com simulação.",
                                "Relatório resume convergência linear confirmada."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de autovalores e ρ(G) (erro <10^{-4}).",
                                "Correta derivação da relação de erro e interpretação de linearidade.",
                                "Uso apropriado de normas e verificações numéricas.",
                                "Análise qualitativa de casos ρ(G)≥1.",
                                "Clareza em exemplos e gráficos fornecidos.",
                                "Conexão explícita entre teoria espectral e prática iterativa."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de estabilidade em simulações dinâmicas (ex: difusão).",
                                "Computação: Algoritmos numéricos e análise de complexidade em SciPy/NumPy.",
                                "Engenharia: Otimização de solvers em CFD e estruturas finitas.",
                                "Estatística: Iterações em MCMC e métodos de Monte Carlo."
                              ],
                              "realWorldApplication": "Em engenharia civil, usa-se Jacobi para resolver sistemas de equações de equilíbrio em malhas finitas de grandes estruturas; ρ(G)<1 garante eficiência em supercomputadores para simulações em tempo real de terremotos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.2.3",
                            "name": "Verificar dominância diagonal estrita",
                            "description": "Testar se |a_{ii}| > ∑_{j≠i} |a_{ij}| para todo i implica ρ(G) < 1, fornecendo uma condição suficiente simples para convergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a definição de dominância diagonal estrita",
                                  "subSteps": [
                                    "Leia a definição: Uma matriz A é estritamente diagonalmente dominante se, para todo i, |a_{ii}| > ∑_{j≠i} |a_{ij}|.",
                                    "Identifique os elementos diagonais (a_{ii}) e off-diagonais (a_{ij}, j≠i).",
                                    "Revise o contexto do método de Jacobi: A = D - E - F, onde G = D^{-1}(E+F).",
                                    "Lembre que ρ(G) < 1 garante convergência.",
                                    "Anote por que dominância implica ||G||_∞ < 1, logo ρ(G) ≤ ||G||_∞ < 1."
                                  ],
                                  "verification": "Escreva a definição em suas palavras e cite o teorema de convergência para Jacobi.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Livro de Álgebra Linear Computacional, notas de aula sobre métodos iterativos.",
                                  "tips": "Use notação LaTeX para clareza: |a_{ii}| > \\sum_{j\\neq i} |a_{ij}|.",
                                  "learningObjective": "Compreender conceitualmente a condição de dominância diagonal estrita e sua relação com ρ(G).",
                                  "commonMistakes": "Confundir dominância estrita (>) com fraca (≥); ignorar valores absolutos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar a matriz e calcular somas off-diagonais",
                                  "subSteps": [
                                    "Selecione ou crie uma matriz A n×n simétrica ou não, representando Ax=b.",
                                    "Para cada linha i=1 a n, liste os elementos a_{i1}, ..., a_{in}.",
                                    "Compute s_i = ∑_{j≠i} |a_{ij}| para cada i.",
                                    "Calcule |a_{ii}| para cada i.",
                                    "Registre os valores em uma tabela: linha i, |a_{ii}|, s_i."
                                  ],
                                  "verification": "Verifique cálculos com uma calculadora ou software; soma off-diagonal deve excluir diagonal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Matriz exemplo (papel ou Excel/MATLAB), calculadora.",
                                  "tips": "Trabalhe linha por linha para evitar erros de soma.",
                                  "learningObjective": "Dominar o cálculo preciso das somas off-diagonais absolutas.",
                                  "commonMistakes": "Incluir |a_{ii}| na soma; esquecer valores absolutos em elementos negativos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a desigualdade para todas as linhas",
                                  "subSteps": [
                                    "Para cada i, compare |a_{ii}| e s_i: se |a_{ii}| > s_i para TODO i, então sim.",
                                    "Marque linhas que satisfazem (✓) e que não (✗).",
                                    "Se todas ✓, conclua dominância estrita.",
                                    "Caso contrário, identifique linhas problemáticas e sugira normalização.",
                                    "Demonstre matematicamente: para Jacobi, ||G||_∞ = max_i (s_i / |a_{ii}|) < 1."
                                  ],
                                  "verification": "Lista completa de comparações; afirme 'dominante' ou 'não dominante' com justificativa.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabela do Step 2, lápis para marcar.",
                                  "tips": "Use frações: s_i / |a_{ii}| < 1 para todos i.",
                                  "learningObjective": "Aplicar a condição de dominância e ligar à norma ∞ de G.",
                                  "commonMistakes": "Parar na primeira linha falha; confundir com dominância por colunas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir implicação para convergência e testar",
                                  "subSteps": [
                                    "Afirme: Se dominante, ρ(G) < 1, método de Jacobi converge.",
                                    "Calcule G = D^{-1}(E+F) se possível e verifique autovalores (opcional).",
                                    "Teste com iterações iniciais para validar empiricamente.",
                                    "Discuta limitações: suficiente mas não necessária.",
                                    "Documente resultado final em relatório curto."
                                  ],
                                  "verification": "Declaração clara: 'Converge porque ρ(G) < 1 via dominância' + 2 iterações manuais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software como MATLAB/Python para autovalores opcionais.",
                                  "tips": "Para matrizes pequenas (3x3), compute ρ(G) explicitamente.",
                                  "learningObjective": "Conectar verificação à garantia teórica de convergência.",
                                  "commonMistakes": "Achar que é condição necessária; ignorar que falha não impede convergência."
                                }
                              ],
                              "practicalExample": "Considere A = [[4, -1, 0], [-1, 4, -1], [0, -1, 4]]. Para i=1: |4| > | -1| + |0| =1 → 4>1 ✓. i=2:4>|-1|+| -1|=2 ✓. i=3:4>1 ✓. Dominante, logo Jacobi converge.",
                              "finalVerifications": [
                                "Identificou corretamente todos |a_{ii}| e somas off-diagonais.",
                                "Verificou |a_{ii}| > soma para TODO i.",
                                "Explicou ||G||_∞ <1 implica ρ(G)<1.",
                                "Aplicou a uma matriz exemplo com conclusão correta.",
                                "Discutiu implicação para convergência de Jacobi.",
                                "Identificou limitações da condição."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos absolutos e somas (90% correto).",
                                "Compreensão teórica: ligação correta com ρ(G) e normas.",
                                "Clareza na verificação linha por linha.",
                                "Uso de exemplo prático com passos completos.",
                                "Identificação de erros comuns evitados.",
                                "Conclusão lógica sobre convergência."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar verificação em Python/NumPy para matrizes grandes.",
                                "Física: Sistemas lineares em mecânica (malhas finitas).",
                                "Estatística: Análise de covariância em modelos multivariados.",
                                "Engenharia: Resolução de equações em circuitos elétricos."
                              ],
                              "realWorldApplication": "Em simulações numéricas de equações diferenciais (ex: fluxo de calor em engenharia), verificar dominância diagonal garante convergência rápida do Jacobi sem pivoteamento, economizando tempo computacional em solvers de PDEs."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.3",
                        "name": "Implementação Computacional do Método",
                        "description": "Desenvolvimento de algoritmo eficiente para implementação prática do método de Jacobi, incluindo critérios de parada e considerações numéricas.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.3.1",
                            "name": "Escrever pseudocódigo do algoritmo",
                            "description": "Implementar loop iterativo com inicialização x^{(0)}, computação de resíduos, atualização via Jacobi e verificação de convergência até tolerância ε.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir parâmetros de entrada e inicialização",
                                  "subSteps": [
                                    "Identificar as entradas necessárias: matriz A, vetor b, tolerância ε, vetor inicial x^{(0)} e máximo de iterações.",
                                    "Escrever a seção de inicialização do pseudocódigo, atribuindo x^{(0)} (geralmente vetor de zeros).",
                                    "Definir variáveis auxiliares como resíduo r e contador de iterações k=0.",
                                    "Incluir comentários explicando o propósito de cada parâmetro.",
                                    "Verificar dimensões: n = tamanho do sistema."
                                  ],
                                  "verification": "Conferir se todas as entradas estão declaradas e x^{(0)} inicializado corretamente.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Referência ao método de Jacobi"
                                  ],
                                  "tips": "Use notação clara como 'x_old ← x^{(0)}' para evitar confusão.",
                                  "learningObjective": "Compreender e documentar as entradas e estado inicial do algoritmo.",
                                  "commonMistakes": [
                                    "Esquecer de definir o tamanho n",
                                    "Inicializar x^{(0)} incorretamente sem zeros ou valores adequados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estruturar o loop iterativo principal",
                                  "subSteps": [
                                    "Iniciar o loop com 'while' ou 'repeat until', condicionando à convergência (||r|| > ε) e k < max_iter.",
                                    "Incrementar o contador k no início do loop.",
                                    "Preparar para computar o novo vetor x dentro do loop.",
                                    "Armazenar o x anterior como x_old para cálculos.",
                                    "Adicionar limite de iterações para evitar loops infinitos."
                                  ],
                                  "verification": "Testar mentalmente: o loop roda pelo menos uma vez e para corretamente.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Exemplo de sistema linear simples 2x2",
                                    "Pseudocódigo base de loops"
                                  ],
                                  "tips": "Use 'do-while' se quiser garantir pelo menos uma iteração.",
                                  "learningObjective": "Dominar a estrutura de controle para iterações condicionais.",
                                  "commonMistakes": [
                                    "Condição de loop invertida (parar quando converge em vez de continuar)",
                                    "Esquecer incremento de k"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar atualização via Jacobi e computação do resíduo",
                                  "subSteps": [
                                    "Calcular o novo x^{(k+1)} usando a fórmula Jacobi: x_i^{(k+1)} = (b_i - sum_{j≠i} a_{ij} x_j^{(k)}) / a_{ii}.",
                                    "Computar o resíduo r^{(k)} = b - A x^{(k+1)} ou usar norma do erro.",
                                    "Atualizar x ← x^{(k+1)} após cálculos.",
                                    "Escolher norma adequada (ex: norma infinito ou L2) para ||r||.",
                                    "Otimizar: pré-calcular diagonais ou fatores se possível."
                                  ],
                                  "verification": "Simular uma iteração manual com valores numéricos para checar cálculos.",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Matriz A e b de exemplo",
                                    "Calculadora para verificação manual"
                                  ],
                                  "tips": "Evite divisão por zero verificando diagonal dominante.",
                                  "learningObjective": "Aplicar precisamente as fórmulas matemáticas do método Jacobi no pseudocódigo.",
                                  "commonMistakes": [
                                    "Usar x^{(k)} em vez de x^{(k-1)} nos somatórios",
                                    "Erro na fórmula: incluir a_{ii} x_i no somatório"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar verificação de convergência e saída",
                                  "subSteps": [
                                    "No final do loop, verificar se ||r|| ≤ ε ou k ≥ max_iter.",
                                    "Se convergido, sair do loop e retornar x^{(k+1)} e número de iterações.",
                                    "Incluir tratamento de falha: mensagem se não convergir.",
                                    "Adicionar comentários finais resumindo o algoritmo.",
                                    "Formatar o pseudocódigo com indentação clara."
                                  ],
                                  "verification": "Ler o pseudocódigo completo e simular 2-3 iterações.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Pseudocódigo completo em rascunho"
                                  ],
                                  "tips": "Teste com ε pequeno para ver se para corretamente.",
                                  "learningObjective": "Garantir terminação correta e saída útil do algoritmo.",
                                  "commonMistakes": [
                                    "Condição de parada fora do loop",
                                    "Não retornar o vetor final x"
                                  ]
                                }
                              ],
                              "practicalExample": "Para Ax = b com A = [[4,1,0],[1,3,1],[0,1,2]], b=[5,7,4], x0=[0,0,0], ε=1e-5:\nINICIALIZE x ← [0,0,0], k=0, max_iter=100\nWHILE ||b - A x|| > ε AND k < max_iter DO\n  k ← k+1\n  x_new[1] ← (5 -1*x[2] -0*x[3])/4\n  x_new[2] ← (7 -1*x[1] -1*x[3])/3\n  x_new[3] ← (4 -0*x[1] -1*x[2])/2\n  x ← x_new\n  r ← b - A x\nEND WHILE\nRETORNE x, k",
                              "finalVerifications": [
                                "Inicialização inclui x^{(0)}, ε e max_iter.",
                                "Loop atualiza x via fórmula Jacobi corretamente.",
                                "Resíduo r = b - A x é computado a cada iteração.",
                                "Condição de parada usa ||r|| ≤ ε ou max_iter.",
                                "Saída retorna x final e número de iterações.",
                                "Pseudocódigo é legível com comentários e indentação."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática da atualização Jacobi (100%).",
                                "Correta implementação da verificação de convergência (20%).",
                                "Estrutura lógica do loop sem erros de controle (20%).",
                                "Clareza e legibilidade do pseudocódigo (15%).",
                                "Tratamento de casos limites (ex: não convergência) (15%).",
                                "Uso consistente de notação (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Estruturas de loops e condicionais.",
                                "Análise Numérica: Estabilidade e convergência de métodos iterativos.",
                                "Computação Científica: Implementação de algoritmos numéricos.",
                                "Matemática Discreta: Representação algorítmica de problemas lineares."
                              ],
                              "realWorldApplication": "Resolução de grandes sistemas lineares em simulações de fluidos (CFD), processamento de imagens (filtro gaussiano), otimização em finanças e modelagem climática, onde matrizes esparsas demandam métodos iterativos eficientes."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.6.1.3.2",
                            "name": "Definir critérios de parada",
                            "description": "Utilizar normas como ||x^{(k+1)} - x^{(k)}|| < ε ou ||b - A x^{(k)}|| < ε, e limitar máximo de iterações para evitar loops infinitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de convergência e critérios de parada no método de Jacobi",
                                  "subSteps": [
                                    "Estude a definição de convergência para métodos iterativos: a sequência x^{(k)} converge para a solução exata quando ||x^{(k+1)} - x^{(k)}|| → 0.",
                                    "Analise o critério de resíduo: ||b - A x^{(k)}|| < ε, que mede o erro no sistema linear Ax = b.",
                                    "Compare normas vetoriais comuns: norma L1 (soma absoluta), L2 (euclidiana) e infinito (máximo).",
                                    "Discuta por que critérios absolutos evitam loops infinitos em implementações computacionais.",
                                    "Revise exemplos teóricos de quando o método diverge sem critérios de parada."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre critério de diferença de iterações e resíduo, citando fórmulas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear Computacional (cap. Métodos Iterativos)",
                                    "Notas de aula sobre normas vetoriais",
                                    "Calculadora ou Python para testes rápidos"
                                  ],
                                  "tips": "Use diagramas para visualizar a convergência; foque em normas L2 e infinito por simplicidade computacional.",
                                  "learningObjective": "Identificar e explicar os principais critérios de parada e suas bases matemáticas.",
                                  "commonMistakes": [
                                    "Confundir norma do vetor solução com norma do resíduo",
                                    "Ignorar que ε muito pequeno causa lentidão computacional"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e configurar parâmetros: tolerância ε e normas apropriadas",
                                  "subSteps": [
                                    "Escolha ε baseado no problema: tipicamente 10^{-6} a 10^{-10} para precisão numérica dupla.",
                                    "Decida a norma: use ||.||_2 para equilíbrio entre precisão e custo; ||.||_∞ para casos esparsos.",
                                    "Calcule exemplos manuais: para um vetor x = [1,2], compute ||x||_2 e ||x||_∞.",
                                    "Avalie impacto de ε: teste com valores crescentes para observar trade-off precisão vs. iterações.",
                                    "Documente escolhas em um relatório curto justificando com propriedades do problema."
                                  ],
                                  "verification": "Crie uma tabela comparando 3 valores de ε com número de iterações estimado em um exemplo simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou Jupyter Notebook",
                                    "Documentação NumPy para funções de norma (np.linalg.norm)"
                                  ],
                                  "tips": "Comece com ε = 1e-6; ajuste baseado na condição da matriz A (cond(A)).",
                                  "learningObjective": "Configurar parâmetros ótimos para convergência eficiente.",
                                  "commonMistakes": [
                                    "Escolher ε fixo sem considerar escala dos dados",
                                    "Usar norma errada para matrizes assimétricas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir limite máximo de iterações para robustez",
                                  "subSteps": [
                                    "Estabeleça max_iter = 1000 como padrão, ajustável pela raio espectral da matriz de iteração.",
                                    "Integre lógica: se k >= max_iter, pare e reporte 'não convergiu'.",
                                    "Analise raio espectral ρ(G) do Jacobi: se ρ(G) >=1, divergência possível, reduza max_iter.",
                                    "Teste cenários: rode simulação com max_iter baixo para forçar parada.",
                                    "Registre estatísticas: iterações reais vs. max_iter em log."
                                  ],
                                  "verification": "Implemente pseudocódigo com if k >= max_iter: break.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pseudocódigo editor (ex: VS Code)",
                                    "Referência teórica sobre raio espectral"
                                  ],
                                  "tips": "Monitore ρ(G) < 1 para garantir convergência teórica antes de definir max_iter.",
                                  "learningObjective": "Garantir terminação finita mesmo em casos de convergência lenta ou divergência.",
                                  "commonMistakes": [
                                    "Definir max_iter muito baixo, interrompendo prematuramente",
                                    "Esquecer de alertar sobre não-convergência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e testar critérios de parada no código do método de Jacobi",
                                  "subSteps": [
                                    "Adicione loop while: while k < max_iter and (norm(x_new - x_old) >= ε or norm(b - A @ x_new) >= ε):",
                                    "Integre ambas verificações com norm() do NumPy.",
                                    "Rode teste com sistema Ax=b: A=[[4,-1,0],[-1,4,-1],[0,-1,4]], b=[2,2,2], x0=[0,0,0].",
                                    "Compare resultados com solução exata x=[0.5,1,0.5].",
                                    "Otimize: use norma relativa se necessário (dividido por ||b||)."
                                  ],
                                  "verification": "Execute código e confirme parada com resíduo < ε em < max_iter iterações.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python + NumPy/SciPy",
                                    "Jupyter Notebook",
                                    "Sistema de teste pronto"
                                  ],
                                  "tips": "Vectorize operações com @ para eficiência; plote erro vs. iterações.",
                                  "learningObjective": "Integrar critérios em implementação computacional funcional.",
                                  "commonMistakes": [
                                    "Erro de índice em k",
                                    "Usar x_old em vez de x_new no resíduo"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o sistema Ax = b com A = [[10, 2, 0], [-1, 8, -1], [0, -2, 6]] e b = [6, 2, -2], implemente Jacobi com x0 = [0,0,0], ε=1e-5, max_iter=100. O código para em k=12 com ||x^{(13)}-x^{(12)}||_2 ≈ 4.2e-6 < ε e resíduo ≈ 3.1e-6.",
                              "finalVerifications": [
                                "Explicar verbalmente os dois critérios principais com fórmulas.",
                                "Configurar ε e max_iter para um novo sistema e justificar.",
                                "Modificar código para usar norma L∞ e comparar iterações.",
                                "Identificar não-convergência em matriz com ρ(G)>1.",
                                "Relatar estatísticas: iterações, erro final, tempo CPU."
                              ],
                              "assessmentCriteria": [
                                "Precisão: critérios implementados corretamente (100%).",
                                "Eficiência: convergência em < max_iter com ε atingido.",
                                "Robustez: tratamento de divergência com alerta.",
                                "Documentação: comentários no código explicando escolhas.",
                                "Testes: pelo menos 3 sistemas variados validados vs. exato."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Loops condicionais e vetores NumPy.",
                                "Análise Numérica: Estabilidade e condicionamento de matrizes.",
                                "Estatística: Normas como medidas de erro probabilístico.",
                                "Engenharia: Simulações em equações diferenciais finitas."
                              ],
                              "realWorldApplication": "Em simulações de fluxo de fluidos (CFD), resolve sistemas lineares grandes do método dos elementos finitos, parando iterações quando erro < ε para equilibrar precisão e tempo computacional em supercomputadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.3.3",
                            "name": "Analisar exemplo numérico",
                            "description": "Aplicar o método a um sistema 3x3 diagonal dominante, computar iterações manualmente e avaliar taxa de convergência via resíduos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e preparar o sistema linear 3x3 diagonal dominante",
                                  "subSteps": [
                                    "Escolha uma matriz A 3x3 diagonal dominante, como A = [[4,1,1],[1,3,-1],[1,-1,3]] e vetor b = [10,0,0].",
                                    "Verifique a condição de diagonal dominante: |a_ii| > sum_{j≠i} |a_ij| para i=1,2,3.",
                                    "Defina um vetor inicial de chute x^{(0)} = [0,0,0]^T.",
                                    "Calcule a solução exata usando eliminação gaussiana ou inversa para referência futura.",
                                    "Anote todos os valores em uma tabela organizada."
                                  ],
                                  "verification": "Confirme que a matriz satisfaz a condição de diagonal dominante e a solução exata está calculada corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora ou software simbólico (opcional)",
                                    "Tabela pré-formatada para iterações"
                                  ],
                                  "tips": "Use uma matriz simétrica positiva definida para garantir convergência rápida.",
                                  "learningObjective": "Preparar um exemplo concreto que atenda aos critérios para análise do método de Jacobi.",
                                  "commonMistakes": [
                                    "Escolher matriz não diagonal dominante, levando a possível divergência.",
                                    "Erros de cálculo na verificação da dominância diagonal."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar as equações iterativas do método de Jacobi",
                                  "subSteps": [
                                    "Reescreva o sistema Ax = b na forma x_i^{(k+1)} = (1/a_ii) * (b_i - sum_{j≠i} a_ij x_j^{(k)}) para i=1,2,3.",
                                    "Para o exemplo: x1 = (10 - y - z)/4, x2 = (0 - x + z)/3, x3 = (0 - x + y)/3 (usando notação x,y,z).",
                                    "Crie uma tabela com colunas para k, x1^k, x2^k, x3^k.",
                                    "Preencha a iteração 0 com o chute inicial."
                                  ],
                                  "verification": "As fórmulas iterativas estão corretas e coincidem com a decomposição D^{-1}(b - (L+U)x^{(k)}).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Fórmulas anotadas do método de Jacobi"
                                  ],
                                  "tips": "Rotule claramente cada equação para evitar confusão nas variáveis.",
                                  "learningObjective": "Entender e derivar a forma iterativa explícita do método de Jacobi.",
                                  "commonMistakes": [
                                    "Inverter incorretamente os sinais nos termos off-diagonal.",
                                    "Esquecer de dividir por a_ii."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar iterações manualmente",
                                  "subSteps": [
                                    "Calcule x^{(1)} usando x^{(0)} nas fórmulas.",
                                    "Calcule x^{(2)} usando x^{(1)}, e continue até x^{(4)} ou até ||x^{(k+1)} - x^{(k)}|| < 10^{-3}.",
                                    "Registre todos os valores com pelo menos 4 casas decimais em uma tabela.",
                                    "Compare com a solução exata em cada iteração."
                                  ],
                                  "verification": "Tabela de iterações completa e cálculos manuais sem erros aritméticos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora para aritmética precisa",
                                    "Tabela expandida com espaço para 5 iterações"
                                  ],
                                  "tips": "Use notação fracionária inicial para precisão, depois decimais.",
                                  "learningObjective": "Executar computações iterativas manuais para observar o comportamento do método.",
                                  "commonMistakes": [
                                    "Erros de propagação em arredondamentos decimais.",
                                    "Confundir valores de iterações anteriores."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar taxa de convergência via resíduos",
                                  "subSteps": [
                                    "Calcule o resíduo r^{(k)} = b - A x^{(k)} para k=0 a 4, usando norma ||r^{(k)}||_∞ ou ||r^{(k)}||_2.",
                                    "Compute a taxa de convergência aproximada ρ ≈ ||r^{(k+1)}|| / ||r^{(k)}||.",
                                    "Plote ou tabule os resíduos vs. iterações para visualizar a redução.",
                                    "Conclua se converge (ρ < 1) e estime o número de iterações para precisão ε=10^{-6}.",
                                    "Compare com solução exata: erro e^{(k)} = x^* - x^{(k)}."
                                  ],
                                  "verification": "Resíduos calculados corretamente e taxa de convergência avaliada com ρ < 1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora matricial",
                                    "Gráfico simples de resíduos (papel ou Excel)"
                                  ],
                                  "tips": "Use norma infinito para simplicidade manual.",
                                  "learningObjective": "Quantificar a convergência usando resíduos e estimar desempenho prático.",
                                  "commonMistakes": [
                                    "Calcular resíduo como x^{(k+1)} - x^{(k)} em vez de b - A x^{(k)}.",
                                    "Ignorar normalização na taxa ρ."
                                  ]
                                }
                              ],
                              "practicalExample": "Sistema: 4x + y + z = 10; x + 3y - z = 0; x - y + 3z = 0. Solução exata: [1.8, 1.2, 1.0]. Chute inicial [0,0,0]. Iteração 1: [2.5, 0, 0]. Resíduos diminuem: ||r0||≈10, ||r1||≈2.5, ρ≈0.25.",
                              "finalVerifications": [
                                "Matriz confirmada diagonal dominante.",
                                "No mínimo 4 iterações computadas com precisão decimal.",
                                "Resíduos calculados e tabela de ρ <1.",
                                "Erro final <10^{-3} comparado à solução exata.",
                                "Visualização gráfica ou tabular da convergência."
                              ],
                              "assessmentCriteria": [
                                "Precisão aritmética nos cálculos (erro <0.001).",
                                "Clareza e organização da tabela de iterações.",
                                "Correta interpretação da taxa de convergência.",
                                "Análise qualitativa da velocidade (rápida/lenta).",
                                "Uso apropriado de normas para resíduos."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python com NumPy para automação.",
                                "Física: Modelagem de redes elétricas ou difusão.",
                                "Estatística: Análise de erro e convergência numérica.",
                                "Engenharia: Otimização em sistemas lineares grandes."
                              ],
                              "realWorldApplication": "Em engenharia civil, analisar deformações em estruturas via sistemas lineares; em machine learning, pré-condicionadores para solvers iterativos em grandes datasets."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.2.2",
                              "10.1.6.1.3.2"
                            ]
                          },
                          {
                            "id": "10.1.6.1.3.4",
                            "name": "Considerar estabilidade numérica",
                            "description": "Discutir inversão de D (diagonal, trivial mas sensível a zeros) e uso de aritmética de ponto flutuante em implementações reais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Decomposição e Inversão da Matriz Diagonal D",
                                  "subSteps": [
                                    "Revise a decomposição A = D - L - U no método de Jacobi, onde D é a matriz diagonal.",
                                    "Explique por que a inversão de D é trivial: D^{-1} tem elementos 1/d_ii na diagonal.",
                                    "Identifique a sensibilidade: se qualquer d_ii = 0, D não é invertível.",
                                    "Discuta implicações para o método iterativo: iterações param ou divergem.",
                                    "Implemente uma função simples para extrair D de A em código."
                                  ],
                                  "verification": "Função extrai corretamente D de uma matriz de teste e detecta zeros na diagonal com aviso.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy; matrizes de exemplo (diagonalmente dominante e com zero).",
                                  "tips": "Sempre verifique diagonal antes de inverter para evitar divisão por zero.",
                                  "learningObjective": "Compreender a estrutura de D e riscos de singularidade na inversão.",
                                  "commonMistakes": "Ignorar zeros na diagonal levando a NaN ou erros de divisão."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Inversão de D com Tratamento de Ponto Flutuante",
                                  "subSteps": [
                                    "Crie uma função para inverter D usando aritmética de ponto flutuante (np.linalg.inv ou manual).",
                                    "Incorpore tolerância para valores próximos a zero (ex: |d_ii| < 1e-12).",
                                    "Teste com matrizes em double precision e observe erros de arredondamento.",
                                    "Compare inversão exata (frações) vs. flutuante usando sympy para validação.",
                                    "Registre resíduos ||Ax - b|| para avaliar impacto na precisão."
                                  ],
                                  "verification": "Inversão produz resultados com erro relativo < 1e-10 para matrizes bem-condicionadas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python, NumPy, SymPy; Jupyter Notebook para testes.",
                                  "tips": "Use np.diag(1/np.diag(D)) para inversão manual eficiente.",
                                  "learningObjective": "Implementar inversão robusta considerando limitações de precisão finita.",
                                  "commonMistakes": "Não tratar underflow/overflow em elementos pequenos/grandes da diagonal."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Estabilidade Numérica nas Iterações de Jacobi",
                                  "subSteps": [
                                    "Implemente o método de Jacobi completo: x^{k+1} = D^{-1}(b + (L+U)x^k).",
                                    "Execute com diferentes precisões (float32 vs float64) e meça erros acumulados.",
                                    "Calcule norma do erro em cada iteração e plote convergência.",
                                    "Teste com matrizes mal-condicionadas ou próximas a singularidade.",
                                    "Compare com métodos diretos (ex: np.linalg.solve) para benchmark."
                                  ],
                                  "verification": "Gráficos mostram divergência ou lentidão quando há instabilidade detectada.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Matplotlib para plots; matrizes de teste variadas (Hilbert, diagonally dominant).",
                                  "tips": "Monitore cond(D) com np.linalg.cond para prever instabilidade.",
                                  "learningObjective": "Diagnosticar como erros de ponto flutuante afetam convergência iterativa.",
                                  "commonMistakes": "Atribuir falhas de convergência só à matriz, ignorando precisão numérica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Estratégias de Melhoria e Verificação Final",
                                  "subSteps": [
                                    "Implemente pivoteamento diagonal parcial se zero detectado.",
                                    "Use preconditioning ou mude para Gauss-Seidel se Jacobi instável.",
                                    "Valide com testes unitários: convergência em <100 iterações para casos bons.",
                                    "Documente relatório com análise de erros e recomendações.",
                                    "Execute em hardware diferente para checar reprodutibilidade."
                                  ],
                                  "verification": "Método converge com erro < 1e-8 em todos testes estáveis; relatórios gerados.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "SciPy para solvers alternativos; relatório template em Markdown.",
                                  "tips": "Sempre normalize resíduos para comparação entre runs.",
                                  "learningObjective": "Desenvolver práticas para estabilidade em implementações numéricas reais.",
                                  "commonMistakes": "Sobreestimar estabilidade sem testes em precisões variadas."
                                }
                              ],
                              "practicalExample": "Considere A = [[4, -1, 0], [-1, 4, -1], [0, -1, 4]] e b = [1, 2, 3]. D = diag(4,4,4), invertível. Altere a(2,2)=1e-15 (quase zero): Jacobi falha por erros de flutuante, divergindo após 10 iterações, enquanto solve direto dá x≈[0.25, 0.5, 0.75].",
                              "finalVerifications": [
                                "Inversão de D detecta e alerta zeros ou near-zeros.",
                                "Jacobi converge com erro <1e-8 em matrizes diagonally dominantes.",
                                "Erros de ponto flutuante são quantificados via resíduos e normas.",
                                "Testes em float32/float64 mostram diferenças esperadas.",
                                "Relatório inclui cond(D) e plots de convergência.",
                                "Pivoteamento corrige casos borderline."
                              ],
                              "assessmentCriteria": [
                                "Explicação precisa da sensibilidade de D^{-1} (90-100%).",
                                "Implementação lida corretamente com flutuante e zeros (80-90%).",
                                "Análise de estabilidade com evidências numéricas (70-80%).",
                                "Estratégias de melhoria aplicadas e testadas (90-100%).",
                                "Relatório claro com plots e conclusões (80-90%).",
                                "Tratamento completo de edge cases (70-80%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de NumPy/SciPy para computação numérica.",
                                "Análise Numérica: Teoria de erros de arredondamento e condicionamento.",
                                "Física Computacional: Simulações de PDEs com solvers iterativos.",
                                "Engenharia de Software: Testes unitários para robustez numérica."
                              ],
                              "realWorldApplication": "Em simulações de fluxo de fluidos (CFD) ou modelagem financeira, onde sistemas lineares grandes surgem de discretizações; estabilidade garante precisão em previsões climáticas ou otimização de portfólios sem crashes por singularidades numéricas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.2",
                    "name": "Método Iterativo de Gauss-Seidel",
                    "description": "Formulação e implementação do método de Gauss-Seidel, destacando a utilização de valores atualizados durante a iteração.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.2.1",
                        "name": "Pré-condições e Decomposição Matricial para Gauss-Seidel",
                        "description": "Compreender as condições de convergência do método de Gauss-Seidel, como a dominância diagonal estrita da matriz, e realizar a decomposição matricial A = D + L + U, onde D é a diagonal, L a triangular inferior estrita e U a triangular superior estrita.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.1.1",
                            "name": "Verificar dominância diagonal estrita",
                            "description": "Dado um sistema linear Ax = b, verificar se a matriz A satisfaz a condição de dominância diagonal estrita, ou seja, |a_ii| ≥ Σ_{j≠i} |a_ij| para todo i, com desigualdade estrita para pelo menos uma linha, garantindo potencial convergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e Preparar a Definição e a Matriz",
                                  "subSteps": [
                                    "Leia a definição: Para todo i, |a_ii| ≥ Σ_{j≠i} |a_ij|, com desigualdade estrita em pelo menos uma linha",
                                    "Identifique o tamanho n da matriz A (quadrada n x n)",
                                    "Escreva a matriz A explicitamente, destacando elementos diagonais a_ii",
                                    "Liste as linhas i de 1 a n para análise sistemática",
                                    "Confirme que A é real e quadrada"
                                  ],
                                  "verification": "Explique oralmente ou por escrito a condição em suas palavras, citando um exemplo simples de linha",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Matriz A do sistema Ax=b",
                                    "Papel quadriculado ou software como MATLAB/Octave",
                                    "Calculadora"
                                  ],
                                  "tips": "Sempre use valores absolutos | | para evitar erros com sinais negativos",
                                  "learningObjective": "Internalizar a definição exata de dominância diagonal estrita e preparar dados para verificação",
                                  "commonMistakes": [
                                    "Confundir com dominância diagonal fraca (sem estrita)",
                                    "Ignorar que deve ser estrita em pelo menos uma linha",
                                    "Assumir matriz não quadrada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Somas dos Valores Absolutos Off-Diagonal por Linha",
                                  "subSteps": [
                                    "Para cada linha i de 1 a n:",
                                    "Identifique elementos off-diagonal: todos a_ij onde j ≠ i",
                                    "Calcule |a_ij| para cada j ≠ i",
                                    "Some esses valores para obter S_i = Σ_{j≠i} |a_ij|",
                                    "Registre S_i ao lado da linha i em uma tabela"
                                  ],
                                  "verification": "Recalcule uma linha aleatória com uma segunda pessoa ou software para confirmar S_i",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela em papel ou planilha Excel",
                                    "Calculadora para somas precisas"
                                  ],
                                  "tips": "Crie uma tabela com colunas: i, a_ii, S_i para organização visual",
                                  "learningObjective": "Dominar o cálculo preciso das somas off-diagonal usando valores absolutos",
                                  "commonMistakes": [
                                    "Incluir o elemento diagonal na soma",
                                    "Esquecer o valor absoluto de elementos negativos",
                                    "Erros aritméticos em somas longas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Elementos Diagonais com Somas Off-Diagonal",
                                  "subSteps": [
                                    "Para cada i, calcule |a_ii|",
                                    "Compare |a_ii| ≥ S_i para todas as linhas",
                                    "Marque linhas onde |a_ii| > S_i (estrita)",
                                    "Conte o número de linhas com desigualdade estrita",
                                    "Registre resultados em uma tabela de comparação"
                                  ],
                                  "verification": "Verifique se todas as comparações estão corretas somando marcas de falha (deve ser zero para ≥ em todas)",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela de Step 2 expandida",
                                    "Marcadores coloridos para ≥ e >"
                                  ],
                                  "tips": "Use símbolos visuais: ✓ para ≥, ✗ para falha, ★ para estrita",
                                  "learningObjective": "Aplicar comparações linha a linha para validar a condição de dominância",
                                  "commonMistakes": [
                                    "Esquecer |a_ii| se diagonal negativa",
                                    "Contar estritas incorretamente",
                                    "Ignorar linhas com igualdade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir a Verificação da Condição Estrita Global",
                                  "subSteps": [
                                    "Confirme que |a_ii| ≥ S_i para TODO i (nenhuma falha)",
                                    "Verifique se existe PELO MENOS UMA linha com |a_ii| > S_i",
                                    "Se ambas condições atendidas, conclua 'Sim, dominância diagonal estrita'",
                                    "Caso contrário, identifique linhas problemáticas e explique por quê",
                                    "Documente a conclusão com justificativa"
                                  ],
                                  "verification": "Teste com matriz conhecida (ex: identidade) para validar lógica final",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela completa dos steps anteriores",
                                    "Exemplo de matriz conhecida"
                                  ],
                                  "tips": "A condição estrita diferencia de 'fraca'; sempre cheque o 'pelo menos uma'",
                                  "learningObjective": "Sintetizar resultados para uma conclusão binária precisa sobre convergência potencial",
                                  "commonMistakes": [
                                    "Aceitar dominância fraca como estrita",
                                    "Não identificar qual linha falha",
                                    "Concluir sem contar estricts"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[4, 1, 0], [-1, 3, 2], [0, 1, 5]].\nLinha 1: S1 = |1| + |0| = 1, |4| > 1 ✓ estrita\nLinha 2: S2 = |-1| + |2| = 3, |3| = 3 ✓ igual\nLinha 3: S3 = |0| + |1| = 1, |5| > 1 ✓ estrita\nResultado: Sim, pois ≥ em todas e estrita em 1 e 3 (para Gauss-Seidel).",
                              "finalVerifications": [
                                "Todas as n linhas satisfazem |a_ii| ≥ S_i",
                                "Pelo menos uma linha tem |a_ii| > S_i",
                                "Todos cálculos de |a_ij| estão corretos (verificados duplamente)",
                                "Tabela de resultados completa e organizada",
                                "Conclusão explícita: 'Sim/Não' com justificativa",
                                "Identificação de linhas críticas (se aplicável)"
                              ],
                              "assessmentCriteria": [
                                "Precisão em todos os cálculos de somas e absolutos (100% correto)",
                                "Correta aplicação da condição estrita (não confundir com fraca)",
                                "Organização clara em tabelas ou passos documentados",
                                "Explicação verbal ou escrita da lógica para cada linha",
                                "Tempo respeitado sem erros aritméticos",
                                "Identificação correta de matrizes contraexemplos"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar verificação em Python/NumPy para automação",
                                "Física: Aplicar em matrizes de rigidez em simulações finitas",
                                "Estatística: Verificar covariância em modelos multivariados",
                                "Engenharia: Pré-condição para solvers em CFD (dinâmica de fluidos computacional)"
                              ],
                              "realWorldApplication": "Em engenharia civil e aeroespacial, verifica-se dominância diagonal estrita em matrizes de equações de equilíbrio estrutural antes de aplicar Gauss-Seidel para resolver sistemas lineares grandes, garantindo convergência rápida em simulações de tensões sem métodos diretos caros."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.2",
                            "name": "Decompor matriz em D, L e U",
                            "description": "Extrair as componentes diagonal D, subdiagonal L e superdiagonal U de uma matriz A simétrica ou assimétrica, preparando para a formulação iterativa do Gauss-Seidel.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Componentes da Decomposição A = D + L + U",
                                  "subSteps": [
                                    "Revise a definição de D: matriz diagonal com os elementos da diagonal principal de A.",
                                    "Defina L: matriz triangular inferior estrita, com zeros na diagonal e acima dela, contendo elementos abaixo da diagonal de A.",
                                    "Defina U: matriz triangular superior estrita, com zeros na diagonal e abaixo dela, contendo elementos acima da diagonal de A.",
                                    "Entenda o propósito: preparar para iterações no método de Gauss-Seidel, onde A = D + L + U.",
                                    "Anote as propriedades: D é diagonal, L não-diagonal inferior, U não-diagonal superior."
                                  ],
                                  "verification": "Escreva definições curtas de D, L e U e dê um exemplo simples de 2x2.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora opcional",
                                    "Referência de álgebra linear"
                                  ],
                                  "tips": "Visualize graficamente: diagonal no centro, L abaixo, U acima.",
                                  "learningObjective": "Dominar as definições exatas de D, L e U na decomposição SPLIT.",
                                  "commonMistakes": [
                                    "Incluir elementos da diagonal em L ou U",
                                    "Confundir lower (L) com upper (U)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Analisar a Matriz A",
                                  "subSteps": [
                                    "Selecione uma matriz A quadrada n x n (ex: 3x3 para prática).",
                                    "Escreva A explicitamente, destacando a diagonal principal.",
                                    "Identifique visualmente as posições subdiagonal (abaixo) e superdiagonal (acima).",
                                    "Verifique pré-condições para Gauss-Seidel: diagonal dominante (opcional para decomposição).",
                                    "Copie A em uma grade para facilitar extração."
                                  ],
                                  "verification": "Marque na matriz copiada as regiões de D (diagonal), L (abaixo) e U (acima).",
                                  "estimatedTime": "8 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Matriz exemplo impressa ou anotada"
                                  ],
                                  "tips": "Use cores diferentes para destacar regiões: azul para diagonal, vermelho para L, verde para U.",
                                  "learningObjective": "Preparar matriz para extração precisa dos componentes.",
                                  "commonMistakes": [
                                    "Usar matriz não quadrada",
                                    "Ignorar zeros fora das bandas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair a Matriz Diagonal D",
                                  "subSteps": [
                                    "Crie uma matriz n x n zerada para D.",
                                    "Copie os elementos da diagonal principal de A para D (A_{ii} → D_{ii}).",
                                    "Preencha o resto de D com zeros.",
                                    "Confirme que D tem apenas elementos na diagonal.",
                                    "Escreva D explicitamente."
                                  ],
                                  "verification": "Verifique se todos os elementos fora da diagonal em D são zero.",
                                  "estimatedTime": "7 minutos",
                                  "materials": [
                                    "Papel",
                                    "Caneta"
                                  ],
                                  "tips": "Liste os elementos da diagonal separadamente antes de montar a matriz.",
                                  "learningObjective": "Isolar corretamente a componente diagonal de A.",
                                  "commonMistakes": [
                                    "Copiar elementos errados da diagonal",
                                    "Deixar resíduos não-zero fora da diagonal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Extrair L e U e Verificar a Decomposição",
                                  "subSteps": [
                                    "Crie matriz zerada para L: copie elementos de A abaixo da diagonal (A_{ij} para i>j).",
                                    "Crie matriz zerada para U: copie elementos de A acima da diagonal (A_{ij} para i<j).",
                                    "Some D + L + U elemento a elemento e compare com A original.",
                                    "Corrija discrepâncias se houver.",
                                    "Confirme que a soma reproduz A exatamente."
                                  ],
                                  "verification": "Calcule D + L + U e confirme igualdade com A para todos os elementos.",
                                  "estimatedTime": "12 minutos",
                                  "materials": [
                                    "Papel",
                                    "Calculadora para soma manual"
                                  ],
                                  "tips": "Some coluna por coluna ou linha por linha para eficiência.",
                                  "learningObjective": "Construir L e U corretamente e validar a decomposição.",
                                  "commonMistakes": [
                                    "Inverter posições de L e U",
                                    "Esquecer zeros na diagonal de L/U"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[4, 1, 0], [2, 5, -1], [0, 3, 6]]:\nD = [[4, 0, 0], [0, 5, 0], [0, 0, 6]]\nL = [[0, 0, 0], [2, 0, 0], [0, 3, 0]]\nU = [[0, 1, 0], [0, 0, -1], [0, 0, 0]]\nVerificação: D + L + U = A.",
                              "finalVerifications": [
                                "D contém exatamente os elementos da diagonal de A e zeros fora dela.",
                                "L tem elementos de A abaixo da diagonal e zeros na/above diagonal.",
                                "U tem elementos de A acima da diagonal e zeros na/abaixo diagonal.",
                                "Soma D + L + U reproduz A identicamente.",
                                "Matriz A é quadrada e decomposição funciona para simétrica/assimétrica.",
                                "Nenhum elemento foi perdido ou duplicado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração de elementos para D, L e U (100% correto).",
                                "Verificação da soma D + L + U == A sem erros.",
                                "Explicação clara das definições de cada componente.",
                                "Identificação correta de posições sub/super diagonal.",
                                "Eficiência no processo (tempo e organização).",
                                "Capacidade de aplicar a matrizes de tamanhos variados (2x2 a 4x4)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar decomposição em Python/NumPy para solvers iterativos.",
                                "Física: Decomposição em modelagem de circuitos elétricos e equilíbrios.",
                                "Engenharia: Pré-processamento em análise finita de elementos.",
                                "Computação Científica: Base para métodos SOR e Jacobi."
                              ],
                              "realWorldApplication": "Essa decomposição é essencial em solvers iterativos para sistemas lineares grandes em simulações numéricas, como previsão meteorológica, análise de estruturas em engenharia civil e processamento de imagens em visão computacional, onde métodos diretos como LU são ineficientes para matrizes esparsas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.1.3",
                            "name": "Entender critério de convergência espectral",
                            "description": "Calcular o raio espectral da matriz de iteração do Gauss-Seidel, ρ((D+L)^{-1}U), e verificar se é menor que 1 para garantir convergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a decomposição matricial para o método de Gauss-Seidel",
                                  "subSteps": [
                                    "Lembre-se da decomposição A = D + L + U, onde D é a matriz diagonal, L é a triangular inferior estrita e U é a triangular superior estrita.",
                                    "Identifique cada componente para uma matriz A de exemplo 3x3 ou 4x4.",
                                    "Verifique que L é estrita (zeros na diagonal) e U também.",
                                    "Confirme que D contém apenas os elementos da diagonal de A.",
                                    "Escreva explicitamente D + L para o pré-condicionador."
                                  ],
                                  "verification": "Construa corretamente D, L e U para uma matriz dada e some D + L sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Matriz A de exemplo (papel ou software como Python com NumPy), calculadora ou Jupyter Notebook.",
                                  "tips": "Sempre comece separando a diagonal primeiro para evitar confusão com L e U.",
                                  "learningObjective": "Compreender a decomposição matricial específica para Gauss-Seidel.",
                                  "commonMistakes": "Incluir diagonal em L ou U; confundir L (inferior) com U (superior)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz de iteração G = (D + L)^{-1} U",
                                  "subSteps": [
                                    "Calcule a matriz B = D + L (triangular inferior).",
                                    "Inverta B para obter (D + L)^{-1}, usando decomposição LU ou solver triangular.",
                                    "Multiplique (D + L)^{-1} por U para obter G.",
                                    "Verifique dimensionalidade: G deve ter o mesmo tamanho de A.",
                                    "Armazene G para próximos cálculos."
                                  ],
                                  "verification": "G resultante deve satisfazer ||G|| < 1 em norma adequada como indício inicial.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software numérico (MATLAB, Python/NumPy/SciPy), matriz A de 3x3.",
                                  "tips": "Use funções built-in como np.linalg.solve para inversão eficiente em vez de np.linalg.inv.",
                                  "learningObjective": "Construir corretamente a matriz de iteração do Gauss-Seidel.",
                                  "commonMistakes": "Esquecer de inverter B; multiplicar na ordem errada (U (D+L)^{-1} em vez de (D+L)^{-1} U)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os autovalores de G e determinar o raio espectral ρ(G)",
                                  "subSteps": [
                                    "Use função eigvals para encontrar todos os autovalores λ_i de G.",
                                    "Calcule o módulo |λ_i| para cada autovalor.",
                                    "Identifique o máximo |λ_max| = ρ(G).",
                                    "Registre ρ(G) com precisão de pelo menos 4 casas decimais.",
                                    "Compare ρ(G) com 1."
                                  ],
                                  "verification": "Autovalores corretos validados comparando com cálculo manual para matriz pequena.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python (numpy.linalg.eigvals), MATLAB (eig), matriz G computada.",
                                  "tips": "Para matrizes pequenas, verifique autovalores manualmente resolvendo det(G - λI) = 0.",
                                  "learningObjective": "Calcular o raio espectral como a máxima magnitude de autovalores.",
                                  "commonMistakes": "Confundir raio espectral com autovalor dominante real; ignorar autovalores complexos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar o critério de convergência e interpretar resultados",
                                  "subSteps": [
                                    "Se ρ(G) < 1, conclua convergência; se ≥1, divergência.",
                                    "Calcule o número de iterações estimado como k ≈ log(ε)/log(ρ(G)) para erro ε.",
                                    "Teste com Gauss-Seidel iterativo para validar (opcional).",
                                    "Documente ρ(G), conclusão e razões.",
                                    "Discuta implicações para matrizes não diagonal-dominantes."
                                  ],
                                  "verification": "Conclusão correta sobre convergência com ρ(G) < 1 confirmada por iterações numéricas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Código iterativo Gauss-Seidel, logs de erro por iteração.",
                                  "tips": "Sempre normalize o erro residual ||e_k|| / ||e_0|| para monitorar convergência.",
                                  "learningObjective": "Aplicar e interpretar o critério ρ(G) < 1 para convergência.",
                                  "commonMistakes": "Assumir convergência sem calcular ρ; confundir com critério de norma ||G|| < 1."
                                }
                              ],
                              "practicalExample": "Considere A = [[4, -1, 0], [-1, 4, -1], [0, -1, 4]]. Decomponha: D=diag(4,4,4), L=[0,0,0; -1,0,0; 0,-1,0], U=[0,-1,0; 0,0,-1; 0,0,0]. B=D+L triangular. G = B^{-1} U tem ρ(G) ≈ 0.25 < 1, convergente.",
                              "finalVerifications": [
                                "Calcula corretamente D, L, U para matriz dada.",
                                "Constrói G = (D+L)^{-1} U sem erros numéricos.",
                                "Computa autovalores e ρ(G) com precisão.",
                                "Interpreta corretamente se ρ(G) < 1 implica convergência.",
                                "Valida com exemplo numérico completo.",
                                "Explica limitação do critério espectral."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de ρ(G): erro < 1e-6.",
                                "Correta decomposição matricial (100% dos elementos).",
                                "Interpretação qualitativa e quantitativa do critério.",
                                "Uso eficiente de ferramentas computacionais.",
                                "Identificação de erros comuns evitados.",
                                "Aplicação em exemplo não-trivial."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/MATLAB para autovalores.",
                                "Análise Numérica: Comparação com métodos de potência para ρ.",
                                "Física Computacional: Solvers em equações de Poisson (CFD).",
                                "Estatística: Análise de convergência em MCMC.",
                                "Engenharia: Otimização de sistemas lineares em controle."
                              ],
                              "realWorldApplication": "Em simulações de engenharia como fluxo de fluidos (CFD), onde sistemas lineares grandes são resolvidos iterativamente; verifica se Gauss-Seidel converge rapidamente para meshes finitas, evitando solvers diretos caros em supercomputadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.2",
                        "name": "Formulação do Algoritmo Iterativo",
                        "description": "Derivar a equação iterativa do método de Gauss-Seidel, destacando o uso imediato dos valores atualizados das componentes anteriores na mesma iteração, diferenciando-o do método de Jacobi.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.2.1",
                            "name": "Derivar equação iterativa x^{(k+1)}",
                            "description": "Escrever a formulação x_i^{(k+1)} = (b_i - Σ_{j=1}^{i-1} a_ij x_j^{(k+1)} - Σ_{j=i+1}^n a_ij x_j^{(k)}) / a_ii para i=1 a n, enfatizando as atualizações forward.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recordar o sistema linear Ax = b e isolar a equação i-ésima",
                                  "subSteps": [
                                    "Escreva o sistema geral Ax = b onde A é n x n, x e b vetores n x 1.",
                                    "Expanda a equação i-ésima: a_{i1} x_1 + a_{i2} x_2 + ... + a_{in} x_n = b_i.",
                                    "Assuma diagonal dominante: |a_{ii}| > Σ_{j≠i} |a_{ij}| para convergência.",
                                    "Reescreva agrupando o termo diagonal: a_{ii} x_i = b_i - Σ_{j≠i} a_{ij} x_j.",
                                    "Divida ambos os lados por a_{ii} para isolar x_i."
                                  ],
                                  "verification": "Confirme que a equação isolada para x_i está correta, sem erros nos somatórios.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo de matriz 3x3 diagonal dominante"
                                  ],
                                  "tips": "Comece sempre com um sistema pequeno (n=2 ou 3) para visualizar.",
                                  "learningObjective": "Compreender a origem da equação iterativa a partir do sistema linear.",
                                  "commonMistakes": [
                                    "Esquecer o termo b_i",
                                    "Não assumir A diagonal dominante",
                                    "Confundir índices i e j"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir iterações e decompor somatório em forward e backward",
                                  "subSteps": [
                                    "Defina aproximações iterativas: x^{(k)} aproximando x, com x^{(k+1)} da próxima.",
                                    "No somatório Σ_{j≠i} a_{ij} x_j, divida em j=1 a i-1 (forward, usar x_j^{(k+1)} já atualizados) e j=i+1 a n (backward, usar x_j^{(k)} antigos).",
                                    "Escreva: a_{ii} x_i^{(k+1)} = b_i - Σ_{j=1}^{i-1} a_{ij} x_j^{(k+1)} - Σ_{j=i+1}^n a_{ij} x_j^{(k)}.",
                                    "Justifique forward: em Gauss-Seidel, atualizamos sequencialmente de cima para baixo.",
                                    "Compare brevemente com Jacobi (todos x_j^{(k)})."
                                  ],
                                  "verification": "Escreva a equação com os dois somatórios separados corretamente.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Folha com sistema exemplo",
                                    "Gráfico de iterações forward vs backward"
                                  ],
                                  "tips": "Desenhe setas: forward (← atualizado), backward (→ antigo).",
                                  "learningObjective": "Distinguir atualizações forward no Gauss-Seidel vs Jacobi.",
                                  "commonMistakes": [
                                    "Usar todos x^{(k)} como Jacobi",
                                    "Inverter forward/backward",
                                    "Esquecer (k+1) nos forward"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a fórmula explícita para x_i^{(k+1)}",
                                  "subSteps": [
                                    "Da equação anterior, isole x_i^{(k+1)}: x_i^{(k+1)} = [b_i - Σ_{j=1}^{i-1} a_{ij} x_j^{(k+1)} - Σ_{j=i+1}^n a_{ij} x_j^{(k)}] / a_{ii}.",
                                    "Verifique para i=1: Σ_{j=1}^{0} vazio, então x_1^{(k+1)} = (b_1 - Σ_{j=2}^n a_{1j} x_j^{(k)}) / a_{11}.",
                                    "Verifique para i=n: Σ_{j=n+1}^n vazio, x_n^{(k+1)} = (b_n - Σ_{j=1}^{n-1} a_{nj} x_j^{(k+1)}) / a_{nn}.",
                                    "Confirme que a_{ii} ≠ 0 e preferencialmente grande.",
                                    "Escreva pseudocódigo: for i=1 to n, atualize x_i."
                                  ],
                                  "verification": "A fórmula final matches exatamente a descrição da habilidade.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Calculadora para testar i=1 e i=n",
                                    "Pseudocódigo template"
                                  ],
                                  "tips": "Teste com n=2 para validar manualmente.",
                                  "learningObjective": "Formular a equação iterativa explícita enfatizando forward updates.",
                                  "commonMistakes": [
                                    "Dividir por a_{ij} errado",
                                    "Índices invertidos nos somatórios",
                                    "Não tratar casos i=1 e i=n"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Generalizar para o algoritmo completo e discutir propriedades",
                                  "subSteps": [
                                    "Escreva o loop iterativo: inicialize x^{(0)}, while não convergido, for i=1 to n, x_i^{(k+1)} = fórmula.",
                                    "Enfatize ordem sequencial: x_1 atualiza primeiro, afeta x_2, etc.",
                                    "Discuta convergência: requer A estritamente diagonal dominante ou simétrica positiva definida.",
                                    "Compare velocidade: Gauss-Seidel ~2x mais rápido que Jacobi.",
                                    "Planeje implementação numérica futura."
                                  ],
                                  "verification": "Pseudocódigo roda corretamente em um exemplo simples.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Editor de texto para pseudocódigo",
                                    "Exemplo numérico resolvido"
                                  ],
                                  "tips": "Implemente mentalmente uma iteração para fixar.",
                                  "learningObjective": "Integrar a equação em um algoritmo iterativo completo.",
                                  "commonMistakes": [
                                    "Atualizar em ordem errada",
                                    "Ignorar critério de parada",
                                    "Confundir com SOR"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[4, -1, 0], [-1, 4, -1], [0, -1, 4]], b = [4, 0, 4], derive para i=2: x_2^{(k+1)} = (0 - (-1)x_1^{(k+1)} - (-1)x_3^{(k)}) / 4 = (x_1^{(k+1)} + x_3^{(k)})/4.",
                              "finalVerifications": [
                                "Escreve corretamente a fórmula geral x_i^{(k+1)} com somatórios forward e backward.",
                                "Aplica para i=1 e i=n sem erros.",
                                "Explica verbalmente a atualização forward.",
                                "Distingue Gauss-Seidel de Jacobi.",
                                "Esboça pseudocódigo iterativo.",
                                "Identifica condição de convergência básica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da fórmula (100% match).",
                                "Correta identificação de forward (j<i: k+1) vs backward (j>i: k).",
                                "Casos especiais (i=1, i=n) tratados adequadamente.",
                                "Justificativa clara da ordem sequencial.",
                                "Compreensão de convergência via diagonal dominância.",
                                "Pseudocódigo funcional e completo."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python/NumPy para simulações.",
                                "Física: Resolver equações de equilíbrio em redes elétricas.",
                                "Engenharia: Análise de elementos finitos em estruturas.",
                                "Estatística: Iterações em regressão linear iterativa."
                              ],
                              "realWorldApplication": "Usado em solvers numéricos para sistemas lineares grandes em simulações de fluidos (CFD), otimização de redes, modelagem financeira e machine learning (ex: aproximações em redes neurais)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.3"
                            ]
                          },
                          {
                            "id": "10.1.6.2.2.2",
                            "name": "Comparar com método de Jacobi",
                            "description": "Explicar e ilustrar a diferença entre Gauss-Seidel (usa x_j^{(k+1)} para j < i) e Jacobi (usa apenas x^{(k)}), mostrando aceleração na convergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as Formulações dos Métodos Jacobi e Gauss-Seidel",
                                  "subSteps": [
                                    "Escreva a forma matricial geral de um sistema linear Ax = b.",
                                    "Expresse o método de Jacobi: x^{(k+1)} = D^{-1}(b - (L+U)x^{(k)}).",
                                    "Expresse o método de Gauss-Seidel: x^{(k+1)} = D^{-1}(b - L x^{(k+1)} - U x^{(k)}).",
                                    "Identifique as matrizes D, L e U em ambos.",
                                    "Implemente pseudocódigo simples para cada método."
                                  ],
                                  "verification": "Confirme escrevendo as equações corretas e pseudocódigos sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou editor de texto; referência de Álgebra Linear.",
                                  "tips": "Use decomposição A = D - L - U para clareza visual.",
                                  "learningObjective": "Entender as bases matemáticas de ambos os métodos iterativos.",
                                  "commonMistakes": "Confundir L e U (L é estritamente triangular inferior, U superior)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Diferenças Chave na Atualização de Componentes",
                                  "subSteps": [
                                    "No Jacobi, explique que todos x_j^{(k+1)} usam apenas valores de x^{(k)} anteriores.",
                                    "No Gauss-Seidel, destaque que para i-ésimo componente, usa x_j^{(k+1)} para j < i (valores já atualizados).",
                                    "Desenhe um diagrama de fluxo mostrando a ordem de atualização em uma iteração.",
                                    "Discuta implicações: Gauss-Seidel usa informações mais recentes.",
                                    "Calcule manualmente uma iteração para um sistema 2x2 para ilustrar."
                                  ],
                                  "verification": "Crie um diagrama comparativo e execute cálculo manual correto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel quadriculado; calculadora.",
                                  "tips": "Pinte valores atualizados vs. antigos para visualização.",
                                  "learningObjective": "Diferenciar precisamente o uso de iterados em cada método.",
                                  "commonMistakes": "Ignorar a dependência forward no Gauss-Seidel."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ilustrar Diferenças com Exemplo Numérico",
                                  "subSteps": [
                                    "Escolha um sistema Ax = b diagonal-dominante, ex: 4x1 - x2 = 1; -x1 + 4x2 - x3 = 2; -x2 + 4x3 = 3.",
                                    "Inicialize x^{(0)} = [0,0,0] e compute 3-5 iterações para Jacobi.",
                                    "Repita para Gauss-Seidel, notando valores intermediários atualizados.",
                                    "Tabule os resultados lado a lado em uma tabela.",
                                    "Meça norma do erro residual ||Ax^{(k)} - b|| em cada iteração."
                                  ],
                                  "verification": "Tabela completa com iterações convergindo corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha Excel ou Python/Octave para tabelas.",
                                  "tips": "Use tolerância 10^{-4} para parar iterações.",
                                  "learningObjective": "Demonstrar numericamente as diferenças iterativas.",
                                  "commonMistakes": "Arredondamentos errados levando a desvios na convergência."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Aceleração na Convergência",
                                  "subSteps": [
                                    "Compare número de iterações até convergência (ex: Jacobi 15 vs. Gauss-Seidel 10).",
                                    "Discuta raio espectral: ρ(G_J) vs. ρ(G_GS), onde geralmente ρ(G_GS) < ρ(G_J).",
                                    "Plote gráficos de erro vs. iteração para ambos.",
                                    "Conclua condições onde Gauss-Seidel acelera (matrizes simétricas positivas definidas).",
                                    "Teste com código para confirmação."
                                  ],
                                  "verification": "Gráficos e conclusão escrita sobre aceleração observada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software de plotagem como Python (matplotlib) ou MATLAB.",
                                  "tips": "Use log-erro para visualizar aceleração linear.",
                                  "learningObjective": "Quantificar e explicar aceleração do Gauss-Seidel.",
                                  "commonMistakes": "Assumir aceleração sempre, sem testar matrizes não adequadas."
                                }
                              ],
                              "practicalExample": "Resolva o sistema 10x1 - 2x2 - x3 = 6; -x1 + 11x2 - 2x3 = 25; -x1 - x2 + 10x3 = -11 com x^{(0)}=[0,0,0]. Jacobi leva ~12 iterações para erro <10^{-3}, Gauss-Seidel ~8, mostrando aceleração via uso de updates forward.",
                              "finalVerifications": [
                                "Explicar verbalmente diferença no uso de x_j^{(k+1)} vs. x^{(k)}.",
                                "Resolver manualmente 2 iterações de um sistema 3x3 para ambos.",
                                "Identificar em tabela qual método converge mais rápido.",
                                "Calcular raio espectral qualitativamente para um exemplo.",
                                "Implementar código simples que compara iterações.",
                                "Discutir limitação: divergência possível em Gauss-Seidel se não diagonal-dominante."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição das diferenças de atualização (90% correto).",
                                "Correção numérica no exemplo (erro <10^{-4}).",
                                "Análise qualitativa/quantitativa da convergência.",
                                "Uso de visualizações (diagramas, tabelas, gráficos).",
                                "Conexão com teoria (raio espectral, condições de convergência).",
                                "Clareza na comunicação da aceleração."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/NumPy para automação.",
                                "Física: Modelagem de redes elétricas ou difusão onde sistemas lineares surgem.",
                                "Estatística: Otimização iterativa em regressão linear.",
                                "Engenharia: Simulações CFD com malhas finitas."
                              ],
                              "realWorldApplication": "Em simulações de engenharia estrutural, Gauss-Seidel acelera solução de sistemas esparsos de milhares de equações (ex: análise finita de elementos), reduzindo tempo computacional em 20-50% vs. Jacobi em fluidodinâmica computacional."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.2.3",
                            "name": "Definir critérios de parada",
                            "description": "Estabelecer critérios como norma do resíduo ||Ax^{(k)} - b|| < ε ou diferença ||x^{(k+1)} - x^{(k)}|| < δ, com tolerância ε típica de 10^{-6}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a necessidade de critérios de parada em métodos iterativos",
                                  "subSteps": [
                                    "Explique por que métodos iterativos como Gauss-Seidel precisam de critérios de parada para evitar convergência infinita.",
                                    "Discuta os riscos de parar cedo (solução imprecisa) ou tarde (desperdício computacional).",
                                    "Identifique os componentes principais: iteração k, vetor solução x^{(k)} e tolerância ε.",
                                    "Revise a convergência do método Gauss-Seidel e sua relação com a matriz A.",
                                    "Estude exemplos de divergência sem critérios adequados."
                                  ],
                                  "verification": "Resuma em 3 frases os motivos para critérios de parada e liste 2 riscos associados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Álgebra Linear Computacional",
                                    "Notas de aula sobre Gauss-Seidel"
                                  ],
                                  "tips": "Use analogias como 'dirigir até chegar ao destino sem mapa eterno'.",
                                  "learningObjective": "Entender o papel fundamental dos critérios de parada na eficiência e precisão de algoritmos iterativos.",
                                  "commonMistakes": [
                                    "Ignorar a possibilidade de divergência",
                                    "Confundir precisão com número fixo de iterações"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o critério baseado na norma do resíduo",
                                  "subSteps": [
                                    "Defina o resíduo r^{(k)} = Ax^{(k)} - b e sua norma ||r^{(k)}||.",
                                    "Explique por que ||Ax^{(k)} - b|| < ε indica que x^{(k)} é uma boa aproximação da solução exata.",
                                    "Escolha normas apropriadas: norma 2 (euclidiana) ou infinito, com justificativa.",
                                    "Pratique cálculo manual de ||Ax^{(k)} - b|| para uma matriz 2x2 simples.",
                                    "Discuta valores típicos de ε, como 10^{-6}, e como eles afetam a precisão."
                                  ],
                                  "verification": "Calcule o resíduo para uma iteração dada e verifique se atende ε = 10^{-6}.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Software como Python com NumPy (opcional)",
                                    "Matriz de exemplo Ax=b"
                                  ],
                                  "tips": "Sempre normalize o resíduo pela norma de b para sistemas escalados: ||r|| / ||b|| < ε.",
                                  "learningObjective": "Dominar o critério de resíduo como medida de erro absoluto na equação linear.",
                                  "commonMistakes": [
                                    "Usar norma errada (ex: norma 1 em vez de 2)",
                                    "Esquecer de computar Ax corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar o critério baseado na diferença entre iterações consecutivas",
                                  "subSteps": [
                                    "Defina o critério ||x^{(k+1)} - x^{(k)}|| < δ como teste de estabilização.",
                                    "Compare com o resíduo: diferença mede mudança, resíduo mede erro real.",
                                    "Escolha δ similar a ε, tipicamente 10^{-6}, mas ajuste baseado na taxa de convergência.",
                                    "Implemente logicamente: compute após cada iteração e compare.",
                                    "Analise casos onde um falha mas o outro succeeds (ex: convergência lenta)."
                                  ],
                                  "verification": "Para um exemplo, compute ||x^{(k+1)} - x^{(k)}|| e decida parada com δ = 10^{-6}.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python para iterações",
                                    "Exemplos numéricos de Gauss-Seidel"
                                  ],
                                  "tips": "Use o critério mais conservador: pare só se AMBOS resíduo E diferença atenderem.",
                                  "learningObjective": "Compreender e aplicar o critério de diferença como complemento ao resíduo.",
                                  "commonMistakes": [
                                    "Confundir δ com ε sem relação",
                                    "Parar só na diferença, ignorando resíduo grande"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir e integrar critérios de parada no algoritmo Gauss-Seidel",
                                  "subSteps": [
                                    "Escreva pseudocódigo com LOOP: while ||r|| >= ε or ||Δx|| >= δ, atualize x.",
                                    "Defina valores padrão: ε = δ = 10^{-6}, máximo 1000 iterações como safeguard.",
                                    "Teste com sistema real: resolva e verifique solução exata via eliminação gaussiana.",
                                    "Ajuste ε baseado em precisão da máquina (machine epsilon ~10^{-16}).",
                                    "Documente a escolha de critérios no cabeçalho do algoritmo."
                                  ],
                                  "verification": "Implemente e rode o algoritmo; confirme parada correta e precisão da solução.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python ou MATLAB",
                                    "Sistema linear de teste 3x3",
                                    "Solução exata conhecida"
                                  ],
                                  "tips": "Sempre inclua contador de iterações para debug e evitar loops infinitos.",
                                  "learningObjective": "Integrar múltiplos critérios de parada em um algoritmo iterativo completo.",
                                  "commonMistakes": [
                                    "Loop while incorreto (usar > em vez de <)",
                                    "Não resetar contadores entre testes"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o sistema Ax = b com A = [[10, 2, 0], [-1, 8, -2], [2, -6, 10]], b = [15, 7, 5], inicie x^{(0)} = [0,0,0]. Aplique Gauss-Seidel: x1^{(1)} = (15-2*x2^{(0)})/10 = 1.5, etc. Pare quando ||Ax^{(k)}-b||_2 < 10^{-6} ou ||x^{(k+1)}-x^{(k)}||_2 < 10^{-6}. Solução converge em ~15 iterações para x ≈ [1.2, 2.0, 0.8].",
                              "finalVerifications": [
                                "O algoritmo para corretamente com ε = 10^{-6} em menos de 1000 iterações.",
                                "Solução final satisfaz ||Ax - b|| < ε.",
                                "||x_final - x_exata|| < 10^{-5} (comparado com solução direta).",
                                "Mudança de ε altera número de iterações de forma esperada.",
                                "Pseudocódigo inclui ambos critérios e máximo iterações.",
                                "Teste com sistema divergente detecta falha (ex: contador max atingido)."
                              ],
                              "assessmentCriteria": [
                                "Explicação clara da diferença entre resíduo e diferença de iterações (nota 1-5).",
                                "Cálculo correto de normas em exemplos manuais.",
                                "Pseudocódigo funcional com critérios integrados.",
                                "Justificativa adequada para escolha de ε/δ.",
                                "Análise de sensibilidade a valores de tolerância.",
                                "Identificação de erros comuns em cenários práticos."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Implementação em Python/NumPy para loops e normas.",
                                "Análise Numérica: Estudo de erros de arredondamento e estabilidade.",
                                "Otimização: Critérios semelhantes em gradiente descendente.",
                                "Física Computacional: Parada em simulações iterativas de equações diferenciais."
                              ],
                              "realWorldApplication": "Em engenharia, usado em solvers de elementos finitos para estruturas (ex: ANSYS), simulações de fluxo de fluidos (CFD) e otimização de redes elétricas, onde precisão controlada evita sobrecarga computacional em grandes matrizes esparsas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.3",
                        "name": "Implementação Computacional do Gauss-Seidel",
                        "description": "Implementar o método em pseudocódigo e código real, testando com exemplos numéricos e analisando o número de iterações necessárias.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.3.1",
                            "name": "Escrever pseudocódigo do algoritmo",
                            "description": "Construir pseudocódigo completo incluindo inicialização x^{(0)}, loop iterativo com atualizações sequenciais, verificação de convergência e saída.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir variáveis de entrada e inicializar x^{(0)}",
                                  "subSteps": [
                                    "Identifique a matriz A (n x n), vetor b (n x 1) e dimensões n.",
                                    "Escolha vetor inicial x^{(0)} (geralmente vetor de zeros).",
                                    "Defina parâmetros de controle: tolerância tol (ex: 1e-6) e máximo de iterações max_iter (ex: 1000).",
                                    "Declare variáveis auxiliares: x_old para x^{(k)}, x_new para x^{(k+1)}, contador k=0.",
                                    "Inclua verificação básica se diagonal de A tem elementos não-zero (para evitar divisão por zero)."
                                  ],
                                  "verification": "Pseudocódigo declara corretamente A, b, x_old = x^{(0)}, tol, max_iter e k=0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo de sistema linear Ax=b",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Use notação consistente como 'x_old' e 'x_new' para evitar confusão entre iterações.",
                                  "learningObjective": "Compreender e declarar todos os componentes iniciais necessários para o algoritmo Gauss-Seidel.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar x^{(0)}",
                                    "Não definir tol ou max_iter",
                                    "Ignorar verificação de diagonal dominante"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estruturar o loop iterativo com atualizações sequenciais",
                                  "subSteps": [
                                    "Inicie o loop: while k < max_iter.",
                                    "Dentro do loop, para i de 1 a n: calcule soma1 = soma_{j=1 a i-1} a[i][j] * x_new[j] (valores já atualizados).",
                                    "Calcule soma2 = soma_{j=i+1 a n} a[i][j] * x_old[j] (valores antigos).",
                                    "Atualize x_new[i] = (b[i] - soma1 - soma2) / a[i][i].",
                                    "Após o for i, copie x_new para x_old e incremente k."
                                  ],
                                  "verification": "Loop while contém for i=1 to n com atualizações sequenciais usando x_new para j<i e x_old para j>i.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pseudocódigo esboçado do Step 1",
                                    "Calculadora para testar manualmente uma iteração"
                                  ],
                                  "tips": "Lembre-se: Gauss-Seidel usa valores novos assim que computados, diferentemente de Jacobi.",
                                  "learningObjective": "Implementar logicamente as atualizações sequenciais características do método Gauss-Seidel.",
                                  "commonMistakes": [
                                    "Usar x_old para todos j≠i (erro Jacobi)",
                                    "Índices errados em somas",
                                    "Esquecer de copiar x_new para x_old após o for"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar verificação de convergência",
                                  "subSteps": [
                                    "Após atualizar x_old, calcule o erro: norma = sqrt(soma (x_new[i] - x_old[i])^2 para i=1 a n) ou ||x_new - x_old||_∞.",
                                    "Adicione condição no while: while k < max_iter AND norma >= tol.",
                                    "Atualize o loop para verificar convergência no início ou fim da iteração.",
                                    "Registre o número de iterações k para depuração.",
                                    "Opcional: verifique se aii != 0 antes de dividir."
                                  ],
                                  "verification": "Condição de convergência baseada em norma do resíduo entre iterações consecutivas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigo dos Steps 1-2",
                                    "Fórmula de norma euclidiana ou máxima"
                                  ],
                                  "tips": "Use norma infinita (max |x_new[i]-x_old[i]|) para simplicidade em pseudocódigo.",
                                  "learningObjective": "Incorporar critério de parada baseado em tolerância para garantir convergência.",
                                  "commonMistakes": [
                                    "Verificar ||Ax - b|| em vez de diferença entre iterações",
                                    "Colocar verificação fora do loop",
                                    "Usar tol muito grande"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar com saída e tratamento de casos especiais",
                                  "subSteps": [
                                    "Após o loop, verifique se convergiu: se norma < tol, saia com x_new e mensagem 'Convergiu em k iterações'.",
                                    "Caso contrário (k==max_iter), avise 'Não convergiu' e saia com x_new anyway.",
                                    "Inclua output: imprimir x_final, número de iterações e norma final.",
                                    "Adicione comentários explicativos no pseudocódigo.",
                                    "Teste logicamente com um exemplo pequeno."
                                  ],
                                  "verification": "Pseudocódigo completo termina com saída condicional e mensagens claras.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Pseudocódigo completo dos Steps anteriores",
                                    "Exemplo numérico para validação"
                                  ],
                                  "tips": "Sempre inclua tratamento para não-convergência para robustez.",
                                  "learningObjective": "Completar o algoritmo com saída apropriada e handling de erros.",
                                  "commonMistakes": [
                                    "Sair sem verificar convergência",
                                    "Não reportar k ou norma final",
                                    "Falta de comentários"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[10, 2, 0], [-1, 8, -2], [1.5, -2.5, 6.5]], b = [[20], [-11], [11.5]], x0 = [0,0,0], tol=1e-5, max_iter=50:\n1. Inicialize x_old = [0,0,0], k=0\n2. While k<50:\n   for i=1 to 3:\n     x_new[1] = (20 - 0)/10 = 2\n     x_new[2] = (-11 - (-1)*2)/8 = -1\n     x_new[3] = (11.5 - 1.5*2 - (-2.5)*-1)/6.5 ≈ 2\n   norma = ||x_new - x_old||, if <tol break\n   x_old = x_new, k++\nSaída: x ≈ [1.2, -0.4, 1.6] após poucas iterações.",
                              "finalVerifications": [
                                "Inicialização inclui x^{(0)}, tol e max_iter corretamente declarados.",
                                "Loop usa atualizações sequenciais (x_new para j<i).",
                                "Verificação de convergência baseada em ||x^{(k+1)} - x^{(k)}|| < tol.",
                                "Cópia x_new → x_old após cada iteração completa.",
                                "Saída condicional reporta convergência ou falha.",
                                "Pseudocódigo é legível com comentários."
                              ],
                              "assessmentCriteria": [
                                "Correção lógica das atualizações Gauss-Seidel (sequenciais).",
                                "Clareza e consistência da notação (índices, variáveis).",
                                "Implementação completa de convergência e parada.",
                                "Tratamento de casos edge (divisão por zero, max_iter).",
                                "Profundidade de comentários e estrutura indentada.",
                                "Capacidade de simular uma iteração manualmente."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Estruturas de loop aninhado e arrays (Python/MATLAB).",
                                "Análise Numérica: Critérios de convergência e normas vetoriais.",
                                "Física: Modelagem de sistemas lineares em circuitos elétricos.",
                                "Engenharia: Otimização iterativa em controle de sistemas.",
                                "Matemática Discreta: Índices e somatórias em algoritmos."
                              ],
                              "realWorldApplication": "Implementação em software para resolver grandes sistemas lineares em simulações de engenharia estrutural (análise de tensões), processamento de imagens (filtros iterativos) e machine learning (otimizadores coordenados)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.3"
                            ]
                          },
                          {
                            "id": "10.1.6.2.3.2",
                            "name": "Implementar em Python ou MATLAB",
                            "description": "Codificar o método em Python usando NumPy para matrizes, com loop for para atualizações in-place, e plotar convergência do erro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e definir dados de entrada",
                                  "subSteps": [
                                    "Instale e importe as bibliotecas necessárias: NumPy para manipulação de matrizes e Matplotlib para plotagem.",
                                    "Defina a matriz de coeficientes A (ex: uma matriz simétrica positiva definida 3x3), o vetor b e o chute inicial x0.",
                                    "Verifique as dimensões de A, b e x0 para garantir compatibilidade (A nxn, b nx1, x0 nx1)."
                                  ],
                                  "verification": "Execute o código de setup e confirme que não há erros de importação ou shape mismatch ao imprimir shapes.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Python com NumPy e Matplotlib instalados",
                                    "Editor de código (Jupyter Notebook recomendado)"
                                  ],
                                  "tips": [
                                    "Use np.array para criar matrizes e vetores.",
                                    "Escolha um sistema de teste conhecido que converge rapidamente."
                                  ],
                                  "learningObjective": "Preparar dados estruturados para iterações numéricas eficientes.",
                                  "commonMistakes": [
                                    "Esquecer de importar bibliotecas.",
                                    "Usar listas Python em vez de np.array, causando erros em operações vetoriais."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o núcleo do algoritmo Gauss-Seidel com atualizações in-place",
                                  "subSteps": [
                                    "Crie um loop for com número máximo de iterações (ex: 1000) e tolerância de erro.",
                                    "Dentro do loop, para cada i de 0 a n-1, atualize x[i] = (b[i] - sum(A[i,j]*x[j] para j!=i)) / A[i,i] usando o novo x[i] imediatamente.",
                                    "Garanta atualizações in-place modificando o vetor x diretamente sem cópias.",
                                    "Adicione condição de parada se norma do erro residual < tolerância."
                                  ],
                                  "verification": "Teste com poucas iterações e imprima x após 5 iterações; compare manualmente com cálculo Gauss-Seidel à mão.",
                                  "estimatedTime": "40 minutes",
                                  "materials": [
                                    "Código do Step 1",
                                    "Documentação NumPy para slicing e sum"
                                  ],
                                  "tips": [
                                    "Use np.dot(A[i,:], x) mas ajuste para excluir j==i com soma manual.",
                                    "Evite loops aninhados desnecessários; otimize com broadcasting onde possível."
                                  ],
                                  "learningObjective": "Codificar corretamente o método iterativo com forward substitution implícita.",
                                  "commonMistakes": [
                                    "Atualizar cópia de x em vez de in-place, levando a Jacobi em vez de Gauss-Seidel.",
                                    "Índices off-by-one no sum de off-diagonais."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Monitorar e calcular a convergência do erro",
                                  "subSteps": [
                                    "Inicialize listas para armazenar erros por iteração (ex: lista de norms).",
                                    "Em cada iteração, calcule erro como np.linalg.norm(A @ x - b) ou diferença entre iterações.",
                                    "Armazene o erro relativo ||x_new - x_old|| / ||x_new||.",
                                    "Pare o loop se erro < 1e-6 ou max iterações atingidas."
                                  ],
                                  "verification": "Após execução, imprima os últimos erros; confirme que diminuem monotonicamente.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Código dos Steps 1-2",
                                    "Funções np.linalg.norm"
                                  ],
                                  "tips": [
                                    "Use np.linalg.norm(x, np.inf) para norma infinita comum em análise numérica.",
                                    "Log o erro para plotagem em escala log."
                                  ],
                                  "learningObjective": "Quantificar convergência para análise de performance do método.",
                                  "commonMistakes": [
                                    "Calcular erro absoluto em vez de relativo, mascarando escalas.",
                                    "Não resetar x_old corretamente entre iterações."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar a convergência do erro",
                                  "subSteps": [
                                    "Importe pyplot de matplotlib se não feito.",
                                    "Crie um plot semilog com iterações no eixo x e log(erro) no y.",
                                    "Adicione labels, título ('Convergência Gauss-Seidel') e grid.",
                                    "Exiba ou salve o plot."
                                  ],
                                  "verification": "Execute plt.show() e confirme que o gráfico mostra declínio exponencial do erro.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Listas de erros do Step 3",
                                    "Matplotlib"
                                  ],
                                  "tips": [
                                    "Use plt.semilogy para escala log automática.",
                                    "Marque a iteração de convergência."
                                  ],
                                  "learningObjective": "Visualizar comportamento assintótico para validação empírica.",
                                  "commonMistakes": [
                                    "Plotar erro linear em vez de log, ocultando comportamento inicial.",
                                    "Esquecer de importar ou usar plt.plot em vez de semilogy."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Executar, testar e analisar o código completo",
                                  "subSteps": [
                                    "Execute o script completo com dados de teste.",
                                    "Compare solução final com np.linalg.solve(A, b) para precisão.",
                                    "Teste com diferentes chutes iniciais ou tamanhos de matriz.",
                                    "Documente número de iterações necessárias e taxa de convergência observada."
                                  ],
                                  "verification": "Solução final coincide com exata dentro de 1e-8 e plot confirma convergência em <100 iterações.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Código completo",
                                    "Sistemas de teste variados"
                                  ],
                                  "tips": [
                                    "Salve código em .py ou .ipynb para reutilização.",
                                    "Experimente matrizes maiores para ver desaceleração."
                                  ],
                                  "learningObjective": "Validar implementação através de testes e análise comparativa.",
                                  "commonMistakes": [
                                    "Não verificar diagonal dominante para garantir convergência.",
                                    "Ignorar warnings de NumPy sobre divisões por zero."
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva o sistema A x = b onde A = [[10, 2, 1], [-1, 10, 3], [2, 1, 10]], b = [17, 5, 22], x0 = [0,0,0]. O código deve convergir em ~15 iterações, plotando log(erros) decaindo para <1e-10.",
                              "finalVerifications": [
                                "Código executa sem erros e converge em tempo razoável (<1s para n=10).",
                                "Atualizações são in-place (verifique com print(x) intra-loop).",
                                "Plot mostra declínio suave do erro em escala log.",
                                "Solução final matches np.linalg.solve dentro de tolerância 1e-10.",
                                "Loop para corretamente em critério de parada ou max_iter.",
                                "Funciona com matrizes 3x3 a 10x10 diagonal-dominantes."
                              ],
                              "assessmentCriteria": [
                                "Correção algorítmica: forward substitution imediata em loop for.",
                                "Eficiência: O(n^2) por iteração com NumPy vetorial onde possível.",
                                "Monitoramento de erro preciso e relativo.",
                                "Visualização clara com semilogy, labels e título.",
                                "Robustez: Tratamento de não-convergência e testes múltiplos.",
                                "Código limpo: Comentado, modular e reutilizável."
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Algoritmos numéricos e otimização de loops.",
                                "Física/Engenharia: Resolução de EDOs via diferenças finitas (sistemas lineares).",
                                "Estatística: Modelos lineares e regressão múltipla.",
                                "Visualização de Dados: Análise gráfica de convergência."
                              ],
                              "realWorldApplication": "Implementado em solvers de CFD (dinâmica de fluidos computacional) para malhas finitas, análise de estruturas em engenharia civil, e otimização em machine learning para sistemas lineares em redes neurais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.3.3",
                            "name": "Testar e analisar com exemplo numérico",
                            "description": "Aplicar o método a um sistema 3x3 diagonal dominante, como A = [[4,-1,0],[-1,4,-1],[0,-1,4]], b=[1,2,3], contando iterações até ε=10^{-8} e comparando com Jacobi.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o problema e ambiente computacional",
                                  "subSteps": [
                                    "Instale e importe bibliotecas necessárias como NumPy para manipulação de matrizes.",
                                    "Defina a matriz A = [[4, -1, 0], [-1, 4, -1], [0, -1, 4]] e vetor b = [1, 2, 3].",
                                    "Escolha vetor inicial x0 = [0, 0, 0] e tolerância ε = 10^{-8}.",
                                    "Calcule a solução exata usando np.linalg.solve(A, b) para referência futura.",
                                    "Verifique se A é diagonal dominante somando |a_ii| > sum(|a_ij| for j!=i)."
                                  ],
                                  "verification": "Matriz A, b e x0 definidos corretamente; solução exata computada e exibida.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Python 3.x",
                                    "NumPy library",
                                    "Jupyter Notebook ou IDE como VS Code"
                                  ],
                                  "tips": "Use np.array para definições precisas; imprima A, b e x_exact para confirmação visual.",
                                  "learningObjective": "Preparar dados de entrada e validar propriedades do sistema para métodos iterativos.",
                                  "commonMistakes": [
                                    "Esquecer de importar NumPy como np.",
                                    "Definir A ou b com tipos incorretos (lista em vez de array).",
                                    "Não verificar diagonal dominância, levando a dúvidas sobre convergência."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o algoritmo de Gauss-Seidel",
                                  "subSteps": [
                                    "Crie uma função gauss_seidel(A, b, x0, tol) que inicialize x_old = x0.copy().",
                                    "Em loop while: atualize x_new[0] = (b[0] + A[0,1]*x_old[1] + A[0,2]*x_old[2])/A[0,0]; similar para x[1] e x[2] sequencialmente.",
                                    "Calcule erro = np.linalg.norm(x_new - x_old, np.inf); x_old = x_new.copy(); conte iterações.",
                                    "Pare quando erro < tol; retorne x_final, iterações e histórico de erros.",
                                    "Teste a função com os dados definidos."
                                  ],
                                  "verification": "Função retorna x aproximado próximo à solução exata e lista de iterações (esperado ~8-12 para ε=1e-8).",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "NumPy",
                                    "Código Python da função"
                                  ],
                                  "tips": "Use norma infinito para erro (np.linalg.norm(..., np.inf)); armazene histórico para plotar convergência.",
                                  "learningObjective": "Codificar corretamente as atualizações sequenciais do Gauss-Seidel.",
                                  "commonMistakes": [
                                    "Atualizar todas componentes simultaneamente (erro de Jacobi).",
                                    "Não copiar x_old corretamente, causando uso de valores atualizados prematuramente.",
                                    "Loop infinito por tol muito pequeno sem limite de iterações máximas (adicione max_iter=1000)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Gauss-Seidel e analisar convergência",
                                  "subSteps": [
                                    "Execute a função e registre número de iterações, x_final e erro final.",
                                    "Plote gráfico de erro vs iteração usando matplotlib para visualizar convergência.",
                                    "Compare x_final com solução exata (erro relativo < 1e-8).",
                                    "Registre métricas: iterações totais, tempo de execução com %timeit.",
                                    "Documente observações sobre velocidade de convergência."
                                  ],
                                  "verification": "Gráfico mostra redução exponencial do erro; convergência em menos de 15 iterações.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Matplotlib para plots",
                                    "NumPy"
                                  ],
                                  "tips": "Use plt.semilogy para escala log do erro; label e legend para clareza.",
                                  "learningObjective": "Monitorar e visualizar o comportamento de convergência do método.",
                                  "commonMistakes": [
                                    "Norma errada (L2 em vez de Linf para comparação padrão).",
                                    "Plot sem escala log, ocultando convergência rápida.",
                                    "Ignorar tempo de CPU, focando só em iterações."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e executar método de Jacobi para comparação",
                                  "subSteps": [
                                    "Crie função jacobi(A, b, x0, tol) similar, mas atualize todas x_new baseado em x_old simultaneamente.",
                                    "Exemplo: x_new[0] = (b[0] - A[0,1]*x_old[1] - A[0,2]*x_old[2])/A[0,0]; etc.",
                                    "Execute com mesmos parâmetros e registre iterações, x_final e gráfico de erro.",
                                    "Compare soluções finais entre GS e Jacobi.",
                                    "Meça tempo de execução para ambos."
                                  ],
                                  "verification": "Jacobi converge em mais iterações (~15-20) que GS; soluções coincidem dentro de tol.",
                                  "estimatedTime": "40 minutes",
                                  "materials": [
                                    "NumPy",
                                    "Matplotlib"
                                  ],
                                  "tips": "Copie estrutura da função GS para consistência; plote ambos erros no mesmo gráfico.",
                                  "learningObjective": "Implementar Jacobi e contrastar com Gauss-Seidel em eficiência.",
                                  "commonMistakes": [
                                    "Confundir atualizações (usar x_new em Jacobi).",
                                    "Não usar x_old.copy() para Jacobi, poluindo iterações.",
                                    "Esquecer de subtrair off-diagonais corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar resultados e tirar conclusões",
                                  "subSteps": [
                                    "Tabule métricas: iterações GS vs Jacobi, tempo GS vs Jacobi, erro final ambos.",
                                    "Discuta por que GS converge mais rápido (atualizações sequenciais usam info recente).",
                                    "Teste sensibilidade variando x0 ou ε; verifique raio espectral se possível.",
                                    "Escreva relatório curto com tabelas, gráficos e insights.",
                                    "Sugira extensões para sistemas maiores (ex: sparse matrices com SciPy)."
                                  ],
                                  "verification": "Relatório compara GS superior em iterações (~2x mais rápido) e inclui gráficos/tabelas.",
                                  "estimatedTime": "35 minutes",
                                  "materials": [
                                    "Pandas para tabelas opcionais",
                                    "Matplotlib"
                                  ],
                                  "tips": "Use print formatado ou DataFrame para tabelas; foque em quantificação (ex: GS: 9 its, Jacobi: 18 its).",
                                  "learningObjective": "Interpretar numericamente vantagens do Gauss-Seidel sobre Jacobi.",
                                  "commonMistakes": [
                                    "Atribuir causalidade errada (não mencionar uso de valores atualizados).",
                                    "Ignorar testes de sensibilidade, generalizando prematuramente.",
                                    "Relatório sem dados quantitativos, só qualitativos."
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[4,-1,0],[-1,4,-1],[0,-1,4]], b=[1,2,3], x0=[0,0,0], ε=1e-8: Gauss-Seidel converge em 9 iterações (erro~5e-9), Jacobi em 18 iterações (erro~3e-9). Solução exata ≈ [1.333, 2.0, 2.333]. GS é ~2x mais eficiente.",
                              "finalVerifications": [
                                "Códigos GS e Jacobi rodam sem erros e convergem abaixo de ε=1e-8.",
                                "Número de iterações GS < Jacobi (ex: 9 vs 18).",
                                "Erros relativos finais < 1e-7 comparado à solução exata.",
                                "Gráficos mostram convergência mais rápida de GS.",
                                "Relatório documenta métricas e análise qualitativa.",
                                "Testes com x0 diferente confirmam robustez."
                              ],
                              "assessmentCriteria": [
                                "Correção da implementação (atualizações sequenciais/simultâneas).",
                                "Precisão numérica e controle de erro (norma adequada).",
                                "Eficiência medida (iterações e tempo).",
                                "Qualidade de visualizações (gráficos logarítmicos claros).",
                                "Análise profunda (razões de performance, sensibilidade).",
                                "Clareza do relatório (tabelas, conclusões acionáveis)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação numérica em Python/NumPy.",
                                "Análise Numérica: Teoria de convergência iterativa.",
                                "Física/Engenharia: Modelagem de PDEs discretizadas (ex: Laplace).",
                                "Data Science: Otimização em machine learning (gradiente descendente).",
                                "Computação Científica: Uso de solvers esparsos em SciPy."
                              ],
                              "realWorldApplication": "Resolução eficiente de grandes sistemas lineares em simulações de engenharia (fluxo de fluidos, estruturas), processamento de imagens (restauração), finanças (modelos de risco) e aprendizado de máquina (regressão logística iterativa), onde Gauss-Seidel acelera convergência em matrizes esparsas diagonal-dominantes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.3.2"
                            ]
                          },
                          {
                            "id": "10.1.6.2.3.4",
                            "name": "Analisar sensibilidade numérica",
                            "description": "Avaliar impacto de erros de arredondamento nas iterações e discutir relaxação (SOR) como extensão, referenciando Golub & Van Loan.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender erros de arredondamento em aritmética de ponto flutuante",
                                  "subSteps": [
                                    "Estudar a representação de números em ponto flutuante IEEE 754 (single e double precision).",
                                    "Calcular o erro relativo de arredondamento (machine epsilon) para diferentes precisões.",
                                    "Analisar propagação de erros em operações básicas: soma, multiplicação e divisão.",
                                    "Ler seção relevante de Golub & Van Loan sobre análise numérica de erros.",
                                    "Resolver exercícios simples de propagação de erros em vetores."
                                  ],
                                  "verification": "Capacidade de calcular machine epsilon corretamente e explicar propagação em um exemplo numérico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação IEEE 754, livro Golub & Van Loan (Cap. 2), Python com numpy (np.finfo).",
                                  "tips": "Use funções como np.spacing() no NumPy para visualizar epsilons.",
                                  "learningObjective": "Entender os fundamentos teóricos dos erros numéricos em computação.",
                                  "commonMistakes": "Confundir erro absoluto com relativo; ignorar dependência da precisão da máquina."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Gauss-Seidel com precisão controlada",
                                  "subSteps": [
                                    "Implementar o método de Gauss-Seidel em Python usando NumPy.",
                                    "Modificar o código para usar precisão single (float32) e double (float64).",
                                    "Executar iterações em uma matriz de teste diagonal-dominante.",
                                    "Registrar resíduos e soluções em cada iteração para ambas as precisões.",
                                    "Plotar gráficos de convergência comparando as duas precisões."
                                  ],
                                  "verification": "Código executável que gera gráficos mostrando divergência em precisão baixa.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python, NumPy, Matplotlib; matriz de exemplo 5x5.",
                                  "tips": "Use dtype=np.float32 explicitamente para forçar precisão.",
                                  "learningObjective": "Implementar numericamente o Gauss-Seidel e controlar precisão.",
                                  "commonMistakes": "Não inicializar vetores de solução adequadamente; ignorar normalização de resíduos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar impacto dos erros de arredondamento nas iterações",
                                  "subSteps": [
                                    "Calcular normas de erro (L2, infinito) entre soluções com diferentes precisões.",
                                    "Estudar sensibilidade via perturbações artificiais na matriz A.",
                                    "Avaliar número de iterações até convergência em cada caso.",
                                    "Comparar com análise teórica (raio espectral da matriz de iteração).",
                                    "Documentar observações em um relatório curto."
                                  ],
                                  "verification": "Relatório com tabelas e gráficos quantificando o impacto (ex: erro cresce 10x em float32).",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Código do passo anterior, SciPy para normas, Jupyter Notebook.",
                                  "tips": "Use cond(A) para prever sensibilidade inicial.",
                                  "learningObjective": "Quantificar e interpretar o impacto numérico na convergência.",
                                  "commonMistakes": "Usar normas inconsistentes; não considerar tolerância de convergência."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar relaxação SOR como extensão e referenciar literatura",
                                  "subSteps": [
                                    "Implementar SOR modificando Gauss-Seidel com parâmetro ω (0<ω<2).",
                                    "Testar diferentes valores de ω e comparar com Gauss-Seidel puro.",
                                    "Analisar estabilidade numérica do SOR via simulações.",
                                    "Consultar Golub & Van Loan (Cap. 10) sobre escolha ótima de ω e sensibilidade.",
                                    "Discutir limitações e quando usar SOR vs. outros métodos."
                                  ],
                                  "verification": "Código SOR com gráfico de convergência otimizada e resumo de referências.",
                                  "estimatedTime": "55 minutos",
                                  "materials": "Livro Golub & Van Loan, código anterior expandido.",
                                  "tips": "Comece com ω=1 (Gauss-Seidel) e teste ω=1.5 para aceleração.",
                                  "learningObjective": "Compreender SOR como mitigação de sensibilidade e embasar em literatura.",
                                  "commonMistakes": "Escolher ω>2 levando a divergência; ignorar dependência em raio espectral."
                                }
                              ],
                              "practicalExample": "Considere a matriz A = [[4,1,0],[1,3,1],[0,1,2]] com b=[5,7,4]. Implemente Gauss-Seidel em float32 vs float64: em 100 iterações, float32 diverge com erro L2 >1e-3 enquanto float64 converge para erro <1e-10. Com SOR (ω=1.2), float32 melhora convergência em 30%.",
                              "finalVerifications": [
                                "Explicar propagação de erros de arredondamento no Gauss-Seidel.",
                                "Apresentar gráfico comparando convergência em precisões diferentes.",
                                "Calcular corretamente normas de erro e sensibilidade condicional.",
                                "Implementar SOR funcional com ω otimizado.",
                                "Citar seções específicas de Golub & Van Loan sobre o tema.",
                                "Discutir cenários onde sensibilidade é crítica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação e análise numérica (40%).",
                                "Profundidade na quantificação de erros e impactos (25%).",
                                "Correta interpretação de resultados e referências (20%).",
                                "Qualidade de gráficos e relatórios (10%).",
                                "Criatividade em testes de sensibilidade (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Uso de bibliotecas como NumPy/SciPy.",
                                "Análise Numérica: Estabilidade de algoritmos iterativos.",
                                "Física Computacional: Simulações em CFD com malhas finitas.",
                                "Estatística Computacional: MCMC e métodos iterativos."
                              ],
                              "realWorldApplication": "Em simulações de escoamento de fluidos (CFD) ou modelagem financeira, onde matrizes grandes de sistemas lineares são resolvidas iterativamente; erros de arredondamento podem invalidar previsões, e SOR otimiza precisão em hardware limitado."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.3",
                    "name": "Critério de Convergência por Raio Espectral",
                    "description": "Condição de convergência baseada no raio espectral da matriz de iteração sendo menor que 1.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.3.1",
                        "name": "Raio Espectral",
                        "description": "O raio espectral de uma matriz é o módulo máximo de seus autovalores, fundamental para analisar a convergência de métodos iterativos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.1.1",
                            "name": "Definir o raio espectral",
                            "description": "Explicar a definição formal do raio espectral ρ(A) como o máximo dos módulos dos autovalores de A, e relacioná-lo com a norma espectral.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar autovalores e autovetores de matrizes",
                                  "subSteps": [
                                    "Lembre-se da definição: λ é autovalor de A se existe v ≠ 0 tal que Av = λv.",
                                    "Discuta o polinômio característico det(A - λI) = 0 para encontrar autovalores.",
                                    "Explique o módulo |λ| como a distância de λ ao zero no plano complexo.",
                                    "Calcule autovalores para uma matriz 2x2 simples, como [[2,1],[0,3]].",
                                    "Verifique que autovalores são raízes do polinômio característico."
                                  ],
                                  "verification": "Liste corretamente os autovalores e seus módulos para uma matriz dada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel e lápis",
                                    "Calculadora para raízes quadráticas",
                                    "Software como Python com numpy.linalg.eig"
                                  ],
                                  "tips": "Sempre normalize autovetores para facilitar cálculos.",
                                  "learningObjective": "Compreender a base conceitual de autovalores para definir o raio espectral.",
                                  "commonMistakes": [
                                    "Confundir autovalor com autovetor",
                                    "Esquecer que autovalores podem ser complexos",
                                    "Não considerar o módulo absoluto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir formalmente o raio espectral ρ(A)",
                                  "subSteps": [
                                    "Defina ρ(A) = max{|λ| : λ autovalor de A}.",
                                    "Escreva a notação matemática precisa: ρ(A) = sup{|λ| : λ ∈ σ(A)}, onde σ(A) é o espectro de A.",
                                    "Diferencie de outros raios, como raio de Jordan.",
                                    "Prove que ρ(A) ≤ ||A|| para qualquer norma de matriz.",
                                    "Discuta que ρ(A) é o maior módulo de autovalor."
                                  ],
                                  "verification": "Escreva a definição exata e prove ρ(A) ≤ ||A||_2 para norma espectral.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Quadro ou papel para anotações",
                                    "Livro de Álgebra Linear (ex: Strang)",
                                    "Notebook Jupyter com sympy para símbolos"
                                  ],
                                  "tips": "Use notação LaTeX para clareza em definições formais.",
                                  "learningObjective": "Estabelecer a definição precisa do raio espectral.",
                                  "commonMistakes": [
                                    "Definir ρ(A) como máximo autovalor real em vez de módulo",
                                    "Ignorar autovalores complexos",
                                    "Confundir com traço ou determinante"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar o raio espectral com a norma espectral",
                                  "subSteps": [
                                    "Defina a norma espectral ||A||_2 = sqrt(ρ(A*A^T)).",
                                    "Mostre que ρ(A) ≤ ||A||_2 ≤ ||A||_F (norma de Frobenius).",
                                    "Calcule ||A||_2 para matriz diagonal e relacione com ρ(A).",
                                    "Discuta desigualdade ρ(A) ≤ ||A|| para normas induzidas.",
                                    "Exemplo: Para A diagonal, ρ(A) = ||A||_∞."
                                  ],
                                  "verification": "Demonstre matematicamente ρ(A) ≤ ||A||_2 e calcule para uma matriz exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora matricial",
                                    "Python/MATLAB para normas",
                                    "Referência: Axler 'Linear Algebra Done Right'"
                                  ],
                                  "tips": "Lembre-se: norma espectral é o maior valor singular, relacionado a autovalores de A*A.",
                                  "learningObjective": "Conectar raio espectral à norma espectral e suas implicações.",
                                  "commonMistakes": [
                                    "Confundir norma espectral com raio espectral",
                                    "Esquecer sqrt em ||A||_2",
                                    "Aplicar desigualdades erradas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e verificar com exemplos computacionais",
                                  "subSteps": [
                                    "Escolha matriz A = [[0.5, 0.5],[0.5, 0.5]] e calcule autovalores: 1 e 0.",
                                    "Compute ρ(A) = 1 e ||A||_2 ≈ 1.",
                                    "Teste matriz não normal e verifique ρ(A) < ||A||_2.",
                                    "Use software para matriz 3x3 aleatória e confirme definição.",
                                    "Discuta limite: ρ(A^k)^{1/k} → ρ(A)."
                                  ],
                                  "verification": "Calcule ρ(A) e ||A||_2 para duas matrizes e relacione corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com numpy (eig, norm)",
                                    "MATLAB ou Octave",
                                    "Planilha Excel para matrizes pequenas"
                                  ],
                                  "tips": "Sempre verifique numericamente com software para validação.",
                                  "learningObjective": "Aplicar conceitos em exemplos concretos para fixação.",
                                  "commonMistakes": [
                                    "Erro numérico em autovalores devido a precisão",
                                    "Não usar módulo para complexos",
                                    "Ignorar multiplicidade algébrica"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a matriz de iteração do método de Gauss-Seidel em um sistema Ax=b, compute os autovalores de T (matriz de iteração), encontre ρ(T) = max|λ_i|, e verifique se ρ(T) < 1 garante convergência, relacionando com ||T||_2.",
                              "finalVerifications": [
                                "Definição correta de ρ(A) como max módulo de autovalores.",
                                "Prova de ρ(A) ≤ ||A|| para norma induzida.",
                                "Cálculo preciso de ρ(A) para matriz 2x2x2 com autovalores complexos.",
                                "Explicação verbal da relação com norma espectral.",
                                "Identificação de quando ρ(A) = ||A||_2 (matrizes normais).",
                                "Uso correto de software para verificação numérica."
                              ],
                              "assessmentCriteria": [
                                "Precisão e formalidade na definição matemática (30%).",
                                "Correção nas provas de desigualdades com normas (25%).",
                                "Qualidade dos exemplos computacionais e verificações (20%).",
                                "Clareza na explicação da relação ρ(A) e ||A||_2 (15%).",
                                "Identificação de erros comuns e tips práticos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Espectros em mecânica quântica (autovalores de Hamiltoniano).",
                                "Computação: Análise de convergência em métodos iterativos (PageRank).",
                                "Engenharia: Estabilidade em controle de sistemas lineares.",
                                "Estatística: Análise de componentes principais (PCA via autovalores)."
                              ],
                              "realWorldApplication": "No método de Jacobi para resolver Ax=b, ρ(T) < 1 determina a taxa de convergência; em machine learning, ρ controla estabilidade em redes neurais recorrentes e otimização gradient-based."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.2",
                            "name": "Calcular o raio espectral",
                            "description": "Computar o raio espectral de matrizes pequenas usando decomposição em autovalores e discutir aproximações para matrizes grandes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e propriedades do raio espectral",
                                  "subSteps": [
                                    "Defina o raio espectral ρ(A) como o máximo dos valores absolutos dos autovalores de A: ρ(A) = max_i |λ_i|.",
                                    "Revise o espectro de autovalores: conjunto {λ | det(A - λI) = 0}.",
                                    "Discuta propriedades: ρ(A) ≤ ||A|| para qualquer norma matricial compatível.",
                                    "Explique relação com convergência de métodos iterativos: série converge se ρ(A) < 1.",
                                    "Identifique que ρ(A) é invariante sob similaridade."
                                  ],
                                  "verification": "Escreva a definição e prove ρ(A) ≤ ||A||_2 para norma espectral.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": [
                                    "Lembre-se: raio espectral é sempre não-negativo e ρ(AB) ≤ ρ(A)ρ(B)."
                                  ],
                                  "learningObjective": "Dominar a definição conceitual e propriedades básicas do raio espectral.",
                                  "commonMistakes": [
                                    "Confundir raio espectral com autovalor dominante sem módulo absoluto.",
                                    "Ignorar que autovalores complexos requerem |λ|."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular autovalores e raio espectral para matrizes 2x2 manualmente",
                                  "subSteps": [
                                    "Escreva a equação característica det(A - λI) = 0 para matriz 2x2.",
                                    "Resolva a equação quadrática λ² - tr(A)λ + det(A) = 0.",
                                    "Calcule os autovalores λ1 e λ2.",
                                    "Compute ρ(A) = max(|λ1|, |λ2|).",
                                    "Verifique numericamente com traço e determinante."
                                  ],
                                  "verification": "Para A = [[1, 2], [0.5, 3]], calcule λ ≈ 0.38, 3.62 e ρ(A) ≈ 3.62.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou papel para equação quadrática",
                                    "Software simbólico como SymPy (opcional)"
                                  ],
                                  "tips": [
                                    "Use fórmula quadrática: λ = [tr ± sqrt(tr² - 4det)] / 2."
                                  ],
                                  "learningObjective": "Executar cálculo exato de raio espectral para matrizes pequenas.",
                                  "commonMistakes": [
                                    "Erro aritmético na equação característica.",
                                    "Esquecer módulo absoluto para autovalores complexos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular raio espectral para matrizes 3x3 usando decomposição numérica",
                                  "subSteps": [
                                    "Monte a equação característica det(A - λI) = 0 para 3x3.",
                                    "Use software para resolver polinômio cúbico ou eigendecomposição.",
                                    "Liste todos autovalores e seus módulos absolutos.",
                                    "Identifique o máximo módulo como ρ(A).",
                                    "Valide com normas: verifique se ρ(A) ≤ ||A||_∞."
                                  ],
                                  "verification": "Para matriz de rotação 3D, confirme ρ(A) = 1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy (np.linalg.eig)",
                                    "MATLAB ou Octave"
                                  ],
                                  "tips": [
                                    "np.linalg.eig retorna autovalores complexos; use np.abs()."
                                  ],
                                  "learningObjective": "Aplicar ferramentas computacionais para matrizes de ordem superior.",
                                  "commonMistakes": [
                                    "Interpretar autovalores complexos sem módulo.",
                                    "Não verificar precisão numérica."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir aproximações e aplicações para matrizes grandes",
                                  "subSteps": [
                                    "Explique limitações: decomposição cara para n > 1000 (O(n³)).",
                                    "Descreva método da potência para aproximar |λ_max| ≈ ρ(A) se dominante.",
                                    "Discuta estimativas por normas: ρ(A) ≤ min{||A||_1, ||A||_∞, ||A||_2}.",
                                    "Aplique a métodos iterativos: ρ(I - B) < 1 garante convergência de Jacobi.",
                                    "Compare precisão: power iteration vs. normas."
                                  ],
                                  "verification": "Aproxime ρ para matriz 10x10 via power method e compare com eig.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código Python para power iteration",
                                    "Documentação NumPy"
                                  ],
                                  "tips": [
                                    "Power iteration: x_{k+1} = A x_k / ||A x_k||; monitore Rayleigh quotient."
                                  ],
                                  "learningObjective": "Entender e implementar aproximações práticas para casos reais.",
                                  "commonMistakes": [
                                    "Assumir autovalor dominante sempre existe.",
                                    "Usar norma errada sem justificar."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar ao contexto de convergência de métodos iterativos",
                                  "subSteps": [
                                    "Lembre critério: método de Richardson converge se ρ(T) < 1, onde T é matriz de iteração.",
                                    "Calcule ρ para exemplo de Gauss-Seidel em sistema linear.",
                                    "Discuta aceleração: como reduzir ρ efetivo.",
                                    "Simule convergência lenta se ρ próximo de 1.",
                                    "Conclua com condições suficientes para convergência."
                                  ],
                                  "verification": "Para sistema Ax=b com A diagonal dominante, mostre ρ < 1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos de livros de métodos numéricos",
                                    "Python para simulação"
                                  ],
                                  "tips": [
                                    "ρ < 1 é necessário e suficiente para convergência assintótica."
                                  ],
                                  "learningObjective": "Conectar raio espectral à análise de algoritmos iterativos.",
                                  "commonMistakes": [
                                    "Confundir ρ(A) com taxa de convergência (é -log ρ)."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[2, 1], [1, 2]]. Autovalores: λ1=3, λ2=1 → ρ(A)=3. Para método iterativo x_{k+1}=Ax_k + b, diverge pois ρ(A)>1. Aproxime para A 100x100 via ||A||_∞=3.",
                              "finalVerifications": [
                                "Calculou corretamente ρ para matrizes 2x2 e 3x3 fornecidas.",
                                "Implementou power iteration para aproximação em matriz grande.",
                                "Verificou ρ ≤ ||A|| para múltiplas normas.",
                                "Explicou impacto de ρ na convergência de método iterativo específico.",
                                "Identificou autovalor dominante corretamente em exemplo numérico.",
                                "Discutiu limitações computacionais para n grande."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de autovalores (erro < 1e-6).",
                                "Correta identificação do máximo módulo absoluto.",
                                "Implementação funcional de aproximação por power method.",
                                "Análise qualitativa de convergência (ρ <1 → converge).",
                                "Uso apropriado de normas como bounds.",
                                "Clareza na discussão de limitações e aplicações."
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Algoritmos numéricos e análise de complexidade (QR algorithm).",
                                "Física: Dinâmica de sistemas lineares e estabilidade (modos normais de vibração).",
                                "Engenharia: Controle de sistemas (polos do laço fechado).",
                                "Economia: Modelos de equilíbrio geral e matrizes de input-output (Leontief)."
                              ],
                              "realWorldApplication": "Em machine learning, o raio espectral de matrizes de Hessian otimiza gradiente descendente; no PageRank do Google, aproxima convergência da iteração de potência; em simulações CFD, garante estabilidade numérica de esquemas iterativos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.3",
                            "name": "Propriedades do raio espectral",
                            "description": "Listar e demonstrar propriedades como ρ(AB) ≤ ρ(A)ρ(B), ρ(A^k) = ρ(A)^k e sua relação com convergência de potências de matriz.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e propriedades básicas do raio espectral",
                                  "subSteps": [
                                    "Revise a definição de autovalores e autovetores de uma matriz quadrada A.",
                                    "Defina o raio espectral ρ(A) como o máximo módulo dos autovalores de A: ρ(A) = max{|λ| : λ autovalor de A}.",
                                    "Calcule ρ(A) para matrizes simples 2x2, como A = [[1,1],[0,0.5]].",
                                    "Discuta que ρ(A) é uma norma induzida e submultiplicativa.",
                                    "Verifique que ρ(A) ≤ ||A|| para qualquer norma matricial compatível."
                                  ],
                                  "verification": "Capacidade de calcular corretamente ρ(A) para pelo menos duas matrizes de exemplo e explicar a definição verbalmente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Folha de papel ou caderno",
                                    "Calculadora ou Python/MATLAB para autovalores",
                                    "Exemplos de matrizes impressos"
                                  ],
                                  "tips": "Sempre normalize os autovalores pelo módulo para identificar o maior.",
                                  "learningObjective": "Dominar a definição precisa do raio espectral e seu cálculo básico.",
                                  "commonMistakes": [
                                    "Confundir raio espectral com traço ou determinante",
                                    "Esquecer de considerar o módulo absoluto dos autovalores",
                                    "Não verificar se a matriz é diagonalizável"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Demonstrar a submultiplicatividade: ρ(AB) ≤ ρ(A)ρ(B)",
                                  "subSteps": [
                                    "Lembre que para autovetores normalizados, ||A v|| ≤ ||A|| ||v||.",
                                    "Prove usando desigualdade de normas: para autovalor μ de AB com autovetor w (||w||=1), ||AB w|| = |μ| ||w|| ≤ ||A|| ||B w|| ≤ ||A|| ||B||.",
                                    "Como ρ ≤ qualquer norma, ρ(AB) ≤ ρ(A) ρ(B).",
                                    "Teste numericamente com A = [[0.4, 0.3],[0.3, 0.4]] e B similar.",
                                    "Discuta igualdade quando A e B compartilham autovetores."
                                  ],
                                  "verification": "Prova escrita da desigualdade e cálculo numérico confirmando ρ(AB) ≤ ρ(A)ρ(B) para exemplos dados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software NumPy ou MATLAB para multiplicação e autovalores",
                                    "Papel para esboço da prova"
                                  ],
                                  "tips": "Use vetores unitários para simplificar as normas na prova.",
                                  "learningObjective": "Provar e ilustrar a propriedade submultiplicativa do raio espectral.",
                                  "commonMistakes": [
                                    "Ignorar normalização do autovetor",
                                    "Confundir com multiplicatividade exata",
                                    "Erro em cálculo de autovalores de AB"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a propriedade das potências: ρ(A^k) = ρ(A)^k",
                                  "subSteps": [
                                    "Pela submultiplicatividade iterada: ρ(A^k) = ρ(A^{k-1} A) ≤ ρ(A^{k-1}) ρ(A) ≤ ... ≤ ρ(A)^k.",
                                    "Para o outro lado, se λ é autovalor com |λ|=ρ(A), então λ^k é autovalor de A^k com |λ^k|=ρ(A)^k, logo ρ(A^k) ≥ ρ(A)^k.",
                                    "Conclua igualdade ρ(A^k) = ρ(A)^k.",
                                    "Calcule para A diagonalizável: A = P D P^{-1}, ρ(A^k) = ρ(D^k) = ρ(D)^k = ρ(A)^k.",
                                    "Verifique numericamente para k=2,3 com matriz exemplo."
                                  ],
                                  "verification": "Prova completa da igualdade e resultados numéricos para k=1 a 5.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python com numpy.linalg.eig",
                                    "Matrizes de exemplo 2x2 e 3x3"
                                  ],
                                  "tips": "Comece com o caso diagonalizável para intuição antes da prova geral.",
                                  "learningObjective": "Compreender e provar a homogeneidade do raio espectral em potências.",
                                  "commonMistakes": [
                                    "Esquecer a direção ≥ na prova",
                                    "Assumir diagonalizabilidade sem justificativa",
                                    "Erro em potências matriciais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar raio espectral com convergência de potências de matriz",
                                  "subSteps": [
                                    "Defina convergência de potências: lim_{k→∞} A^k = 0 se ρ(A) < 1.",
                                    "Prove: se ρ(A) < 1, existe norma com ||A|| <1, logo ||A^k|| ≤ ||A||^k → 0.",
                                    "Mostre que se ρ(A) >1, existe autovalor |λ|>1, ||A^k v|| = |λ|^k ||v|| → ∞.",
                                    "Se ρ(A)=1, convergência depende de autovalor de módulo 1 ser simples, etc.",
                                    "Aplique a métodos iterativos: x_{k+1} = A x_k + b converge se ρ(A)<1."
                                  ],
                                  "verification": "Explicação verbal da relação e contraexemplo para ρ(A)=1 sem convergência.",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "Exemplos de matrizes com ρ<1, =1, >1",
                                    "Gráficos de ||A^k|| vs k via software"
                                  ],
                                  "tips": "Use Gelfand's formula para lim sup ||A^k||^{1/k} = ρ(A).",
                                  "learningObjective": "Conectar propriedades do raio à convergência em métodos iterativos.",
                                  "commonMistakes": [
                                    "Achar que ρ(A)≤1 sempre converge",
                                    "Confundir com norma <1 diretamente",
                                    "Ignorar multiplicidade de autovalores unitários"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a matriz de iteração do método de Jacobi para um sistema laplaciano: A = [[0, 0.5, 0],[0.5, 0, 0.5],[0, 0.5, 0]]. Calcule ρ(A) ≈ 0.85 <1. Verifique ρ(A^2) = [ρ(A)]^2 ≈0.72, multiplique por B=I-A e confirme ρ(AB) ≤ ρ(A)ρ(B). Simule potências A^k →0, demonstrando convergência.",
                              "finalVerifications": [
                                "Listar e enunciar corretamente as três propriedades principais do raio espectral.",
                                "Provar ρ(AB) ≤ ρ(A)ρ(B) sem consultar notas.",
                                "Calcular ρ(A^k) para k=3 dado ρ(A) e matriz exemplo.",
                                "Explicar por que ρ(A)<1 implica A^k →0.",
                                "Identificar erro em uma prova incompleta fornecida.",
                                "Aplicar a uma matriz 3x3 real e verificar numericamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude das provas matemáticas (40%)",
                                "Correção em cálculos numéricos de autovalores e raios (30%)",
                                "Clareza na explicação da relação com convergência (15%)",
                                "Uso adequado de exemplos e contraexemplos (10%)",
                                "Identificação de erros comuns e dicas práticas (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de estabilidade em sistemas dinâmicos lineares (equações diferenciais).",
                                "Computação: Avaliação de convergência em algoritmos iterativos como Power Method.",
                                "Engenharia: Controle de sistemas e análise de Markov chains.",
                                "Estatística: Estudo de convergência em processos estocásticos."
                              ],
                              "realWorldApplication": "No método de Gauss-Seidel ou SOR para resolver sistemas lineares Ax=b, o raio espectral da matriz de iteração determina a taxa de convergência; em PageRank do Google, ρ da matriz de transição <1 garante convergência do vetor estacionário."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.2",
                        "name": "Matriz de Iteração em Métodos Clássicos",
                        "description": "A matriz de iteração G surge na forma x^{(k+1)} = G x^{(k)} + c dos métodos iterativos como Jacobi e Gauss-Seidel para resolver Ax = b.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.2.1",
                            "name": "Derivar a matriz de iteração para Jacobi",
                            "description": "Derivar explicitamente a matriz G_J = D^{-1}(L+U) para o método de Jacobi a partir da decomposição A = D - L - U.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a decomposição SPLIT da matriz A",
                                  "subSteps": [
                                    "Lembre-se da decomposição padrão A = D - L - U, onde D é a matriz diagonal com os elementos da diagonal de A.",
                                    "Identifique L como a matriz triangular inferior estrita contendo os elementos abaixo da diagonal de A (com sinal positivo em L).",
                                    "Identifique U como a matriz triangular superior estrita contendo os elementos acima da diagonal de A (com sinal positivo em U).",
                                    "Verifique que A = D - L - U segurando para uma matriz exemplo pequena.",
                                    "Escreva explicitamente D, L e U para uma matriz 2x2 ou 3x3 de exemplo."
                                  ],
                                  "verification": "Decompor corretamente uma matriz A dada em D, L e U, e confirmar que D - L - U = A.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora opcional",
                                    "Matriz exemplo impressa"
                                  ],
                                  "tips": "Sempre comece extraindo a diagonal para D; L e U são zero na diagonal.",
                                  "learningObjective": "Compreender e aplicar a decomposição SPLIT A = D - L - U.",
                                  "commonMistakes": [
                                    "Incluir elementos da diagonal em L ou U",
                                    "Esquecer o sinal negativo na verificação A = D - L - U",
                                    "Confundir L (inferior) com U (superior)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a equação do método de Jacobi",
                                  "subSteps": [
                                    "Parta da equação do sistema linear A x = b.",
                                    "Substitua A = D - L - U na equação, obtendo (D - L - U) x = b.",
                                    "Reorganize os termos: D x = b + (L + U) x.",
                                    " isole x: x = D^{-1} (b + (L + U) x).",
                                    "Explique que isso sugere uma iteração onde o novo x depende do x anterior."
                                  ],
                                  "verification": "Escrever corretamente a forma x = D^{-1} (b + (L + U) x) a partir de A x = b.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo de sistema linear A x = b"
                                  ],
                                  "tips": "Pense em D x como isolando a diagonal, tratando off-diagonais como 'conhecidas' da iteração anterior.",
                                  "learningObjective": "Derivar a forma iterativa implícita do método de Jacobi.",
                                  "commonMistakes": [
                                    "Esquecer de inverter D",
                                    "Colocar sinal errado em (L + U)",
                                    "Não reorganizar corretamente os termos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a forma de iteração matricial",
                                  "subSteps": [
                                    "Defina x^{k+1} = D^{-1} (b + (L + U) x^k), onde x^k é a aproximação anterior.",
                                    "Separe o termo independente: x^{k+1} = D^{-1} (L + U) x^k + D^{-1} b.",
                                    "Identifique a matriz de iteração G_J como o coeficiente de x^k, ou seja, G_J = D^{-1} (L + U).",
                                    "Escreva o termo constante como c = D^{-1} b.",
                                    "Confirme que a iteração é x^{k+1} = G_J x^k + c."
                                  ],
                                  "verification": "Expressar a iteração como x^{k+1} = G_J x^k + c com G_J = D^{-1}(L + U).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Matriz D, L, U do passo 1"
                                  ],
                                  "tips": "Lembre-se que D^{-1} é diagonal, facilitando o cálculo.",
                                  "learningObjective": "Obter explicitamente a matriz de iteração G_J para Jacobi.",
                                  "commonMistakes": [
                                    "Colocar G_J = (L + U) D^{-1} em vez de D^{-1}(L + U)",
                                    "Incluir D no G_J",
                                    "Esquecer o termo constante c"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e computar G_J para um exemplo concreto",
                                  "subSteps": [
                                    "Escolha uma matriz A exemplo, como A = [[4, 1], [1, 3]].",
                                    "Compute D, L, U: D = [[4,0],[0,3]], L = [[0,0],[1,0]], U = [[0,1],[0,0]].",
                                    "Calcule L + U = [[0,1],[1,0]].",
                                    "Compute D^{-1} = [[0.25,0],[0,1/3]], então G_J = D^{-1}(L + U).",
                                    "Multiplique e verifique o resultado: G_J = [[0.25, 0.25], [1/3, 0]]."
                                  ],
                                  "verification": "Calcular corretamente G_J para a matriz exemplo e confirmar dimensões e valores.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Papel para multiplicação matricial"
                                  ],
                                  "tips": "Verifique multiplicação matricial linha por linha.",
                                  "learningObjective": "Aplicar a derivação para computar G_J explicitamente.",
                                  "commonMistakes": [
                                    "Erro em D^{-1}",
                                    "Multiplicação matricial incorreta",
                                    "Confundir ordem de multiplicação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[4, 1], [1, 3]], D = [[4,0],[0,3]], L = [[0,0],[1,0]], U = [[0,1],[0,0]]. Então L + U = [[0,1],[1,0]], D^{-1} = [[1/4,0],[0,1/3]], G_J = [[1/4 * 0 + 0*1, 1/4*1 + 0*0], [0*0 + 1/3*1, 0*1 + 1/3*0]] = [[0, 0.25], [1/3, 0]].",
                              "finalVerifications": [
                                "Pode decompor qualquer A em D - L - U corretamente.",
                                "Deriva x^{k+1} = D^{-1}(b + (L + U)x^k) a partir de A x = b.",
                                "Identifica G_J = D^{-1}(L + U) na forma x^{k+1} = G_J x^k + D^{-1} b.",
                                "Computa G_J para uma matriz 2x2 ou 3x3 sem erros.",
                                "Explica o papel de G_J no critério de convergência (raio espectral <1)."
                              ],
                              "assessmentCriteria": [
                                "Correção algébrica na derivação (100% dos passos sem erros).",
                                "Clareza na identificação de D, L, U.",
                                "Precisão no cálculo de D^{-1}(L + U).",
                                "Compreensão conceitual: ligação com iteração e convergência.",
                                "Habilidade em exemplos numéricos."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementar Jacobi em Python/MATLAB usando essa matriz.",
                                "Física Computacional: Resolver equações de Poisson em grids 2D.",
                                "Engenharia: Análise de estruturas via sistemas lineares esparsos.",
                                "Estatística: Iterações em modelos de regressão linear."
                              ],
                              "realWorldApplication": "Em engenharia civil, derivar G_J permite analisar convergência de solvers iterativos para matrizes de rigidez em simulações FEM de edifícios, otimizando tempo de computação em grandes sistemas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.2.2",
                            "name": "Derivar a matriz de iteração para Gauss-Seidel",
                            "description": "Obter a matriz G_{GS} = (D+L)^{-1} U para o método de Gauss-Seidel e compará-la com a de Jacobi.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a decomposição matricial A = D + L + U",
                                  "subSteps": [
                                    "Defina a matriz diagonal D como os elementos da diagonal principal de A.",
                                    "Defina a matriz L como a parte triangular inferior estrita de A (elementos abaixo da diagonal com sinal negativo).",
                                    "Defina a matriz U como a parte triangular superior estrita de A (elementos acima da diagonal).",
                                    "Verifique que A = D + L + U para uma matriz A simétrica ou não.",
                                    "Escreva explicitamente para uma matriz 2x2 ou 3x3 de exemplo."
                                  ],
                                  "verification": "Confirme que a soma D + L + U resulta em A original.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matriz A de exemplo (papel ou software como MATLAB/Python)",
                                    "Folha de cálculo"
                                  ],
                                  "tips": "Use uma matriz pequena inicialmente para visualização clara.",
                                  "learningObjective": "Compreender a decomposição padrão usada em métodos iterativos.",
                                  "commonMistakes": [
                                    "Confundir sinais em L (deve ser -L para lower), esquecer elementos zero em D fora da diagonal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Recordar e derivar a matriz de iteração para o método de Jacobi",
                                  "subSteps": [
                                    "Lembre a iteração de Jacobi: x^{k+1} = D^{-1} (b - (L + U) x^k).",
                                    "Reescreva como x^{k+1} = -D^{-1}(L + U) x^k + D^{-1} b.",
                                    "Identifique G_J = -D^{-1}(L + U) ou na forma dada G_J = D^{-1} U ajustando convenções.",
                                    "Compute D^{-1} explicitamente (inverso diagonal é simples).",
                                    "Aplique a uma matriz de exemplo para obter G_J numérica."
                                  ],
                                  "verification": "A iteração produz a forma matricial correta G_J x^k + c.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou Python/NumPy para inverso",
                                    "Exemplo numérico de A e b"
                                  ],
                                  "tips": "Inverta D elemento a elemento para simplicidade.",
                                  "learningObjective": "Dominar a matriz de iteração de Jacobi como base de comparação.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo em G_J",
                                    "Não inverter D corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a matriz de iteração para Gauss-Seidel",
                                  "subSteps": [
                                    "Lembre a iteração de Gauss-Seidel: usa atualizações imediatas na mesma iteração.",
                                    "Escreva a forma: (D + L) x^{k+1} = b - U x^k.",
                                    "Resolva para x^{k+1}: x^{k+1} = (D + L)^{-1} (b - U x^k).",
                                    "Identifique G_{GS} = (D + L)^{-1} U (seguindo a convenção da descrição).",
                                    "Compute (D + L)^{-1} para matriz triangular inferior (fácil por forward substitution)."
                                  ],
                                  "verification": "Verifique que a multiplicação (D + L) G_{GS} = U.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software para resolver sistemas triangulares (ex: SciPy)",
                                    "Matriz de exemplo"
                                  ],
                                  "tips": "Para inverso de (D+L), use decomposição LU simples ou fórmula explícita.",
                                  "learningObjective": "Derivar precisamente G_{GS} incorporando atualizações parciais.",
                                  "commonMistakes": [
                                    "Usar D + U em vez de D + L",
                                    "Ignorar que (D+L) é triangular inferior"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar as matrizes de iteração G_{GS} e G_J",
                                  "subSteps": [
                                    "Escreva lado a lado: G_J = D^{-1} U e G_{GS} = (D + L)^{-1} U.",
                                    "Note que para A simétrica, ||G_{GS}|| < ||G_J|| frequentemente.",
                                    "Compute numericamente raios espectrais para um exemplo.",
                                    "Discuta implicações para convergência (raio espectral <1).",
                                    "Identifique casos onde Gauss-Seidel converge mais rápido."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as diferenças chave.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta para autovalores (eigenvalues em NumPy)"
                                  ],
                                  "tips": "Use matrizes diagonal-dominantes para testar convergência.",
                                  "learningObjective": "Analisar diferenças e vantagens de Gauss-Seidel sobre Jacobi.",
                                  "commonMistakes": [
                                    "Afirmar equivalência sem prova",
                                    "Confundir normas ou raios"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[4,1,0],[1,3,1],[0,1,2]], D=diag(4,3,2), L=[0,0,0;1,0,0;0,1,0] (negativo implícito), U=[0,1,0;0,0,1;0,0,0]. Compute G_J = D^{-1} U ≈ [[0,0.25,0],[0,0,0.333],[0,0,0]], G_GS = (D+L)^{-1} U (resolva triangular para obter matriz explícita e compare raios espectrais: ρ(G_J)≈0.25, ρ(G_GS)≈0.2).",
                              "finalVerifications": [
                                "Pode decompor qualquer A em D+L+U corretamente.",
                                "Deriva G_{GS} = (D+L)^{-1} U sem erros algébricos.",
                                "Compara corretamente com G_J, notando (D+L)^{-1} vs D^{-1}.",
                                "Calcula numericamente para exemplo 3x3.",
                                "Explica impacto na convergência.",
                                "Identifica condições onde ||G_{GS}|| < ||G_J||."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação algébrica (100% correto).",
                                "Correção numérica no exemplo prático.",
                                "Profundidade da comparação (diferenças qualitativas e quantitativas).",
                                "Uso apropriado de propriedades triangulares.",
                                "Clareza na explicação de implicações para convergência.",
                                "Ausência de erros comuns em sinais ou decomposições."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação em Python/NumPy para solvers iterativos.",
                                "Física: Simulações de equações diferenciais finitas (Poisson).",
                                "Engenharia: Análise de estruturas (sistemas lineares esparsos).",
                                "Estatística: Otimização em regressão linear iterativa."
                              ],
                              "realWorldApplication": "Em engenharia civil, resolve sistemas lineares grandes de equilíbrios estáticos em estruturas; em finanças, itera soluções para modelos de precificação de opções; em machine learning, pré-condicionadores para gradiente descendente em redes neurais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.3.2.3",
                            "name": "Interpretar o erro de iteração",
                            "description": "Mostrar que o erro e^{(k+1)} = G e^{(k)}, onde a convergência depende das propriedades espectrais de G.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Propagação do Erro em Métodos Iterativos",
                                  "subSteps": [
                                    "Revise o conceito de erro absoluto e relativo em aproximações iterativas: e^{(k)} = x - x^{(k)}.",
                                    "Identifique como métodos iterativos clássicos (Jacobi, Gauss-Seidel) geram sequências de aproximações x^{(k+1)} = G x^{(k)} + c.",
                                    "Explique verbalmente como o erro se propaga de uma iteração para a próxima.",
                                    "Esboce diagramaticamente a relação entre erros consecutivos.",
                                    "Compare com métodos diretos para destacar a natureza iterativa."
                                  ],
                                  "verification": "Escreva uma definição clara da propagação de erro e forneça um esboço diagrama confirmando a linearidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Álgebra Linear Numérica (ex: Golub-Van Loan), caderno para esboços, calculadora.",
                                  "tips": "Use setas em diagramas para visualizar a multiplicação por G.",
                                  "learningObjective": "Entender que o erro segue uma dinâmica linear governada pela matriz de iteração G.",
                                  "commonMistakes": "Confundir erro absoluto com relativo; ignorar o termo constante c na iteração fixa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Relação de Erro e^{(k+1)} = G e^{(k)}",
                                  "subSteps": [
                                    "Parta da equação do sistema linear Ax = b e da forma iterativa x^{(k+1)} = G x^{(k)} + c.",
                                    "Substitua a solução exata x na equação iterativa para isolar o erro: e^{(k+1)} = x - x^{(k+1)}.",
                                    "Simplifique algebricamente para obter e^{(k+1)} = G e^{(k)}.",
                                    "Verifique a derivação com um exemplo numérico simples de 2x2.",
                                    "Generalize para qualquer dimensão n."
                                  ],
                                  "verification": "Derive a fórmula passo a passo em papel e teste com uma matriz de exemplo, confirmando numericamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e lápis, software como MATLAB ou Python (NumPy) para verificação numérica.",
                                  "tips": "Mantenha os passos algébricos curtos; anote suposições como A não singular.",
                                  "learningObjective": "Derivar e provar matematicamente a relação recursiva do erro.",
                                  "commonMistakes": "Esquecer de subtrair corretamente os termos; confundir G com a matriz do sistema A."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Propriedades Espectrais de G e sua Influência na Convergência",
                                  "subSteps": [
                                    "Defina raio espectral ρ(G) como o máximo módulo dos autovalores de G.",
                                    "Explique que ||e^{(k)}|| ≤ ρ(G)^k ||e^{(0)}|| para normas compatíveis.",
                                    "Discuta que convergência requer ρ(G) < 1, com taxa assintótica log(ρ(G)).",
                                    "Calcule ρ(G) para um exemplo de Jacobi em uma matriz diagonal dominante.",
                                    "Compare ρ(G) para Jacobi vs. Gauss-Seidel em casos conhecidos."
                                  ],
                                  "verification": "Calcule autovalores e ρ(G) para uma matriz 3x3 de exemplo e verifique se ρ(G) < 1 implica redução de erro.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software computacional (MATLAB eig() ou Python numpy.linalg.eig), matrizes de teste.",
                                  "tips": "Use funções prontas para autovalores inicialmente, depois entenda o algoritmo.",
                                  "learningObjective": "Ligar propriedades espectrais à redução geométrica do erro.",
                                  "commonMistakes": "Confundir raio espectral com norma espectral; assumir convergência sem checar ρ(G) < 1."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e Aplicar o Critério de Convergência",
                                  "subSteps": [
                                    "Resuma: convergência linear se ρ(G) < 1, divergência se ρ(G) ≥ 1.",
                                    "Interprete numericamente: simule iterações e plote ||e^{(k)}|| vs. k.",
                                    "Discuta aceleração quando ρ(G) próximo de 0 vs. lentidão perto de 1.",
                                    "Aplique a um problema real: sistema de Poisson 2D com Jacobi.",
                                    "Conclua com condições suficientes como dominância diagonal estrita."
                                  ],
                                  "verification": "Simule 20 iterações, plote norma do erro e confirme alinhamento com ρ(G).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python/MATLAB para simulação e plotagem (matplotlib), dados de teste.",
                                  "tips": "Use logscale no plot para visualizar taxa geométrica.",
                                  "learningObjective": "Interpretar o comportamento assintótico do erro baseado em G.",
                                  "commonMistakes": "Ignorar dependência na norma escolhida; superestimar velocidade sem ρ(G)."
                                }
                              ],
                              "practicalExample": "Considere o sistema Ax = b com A = [[4,1],[1,3]], b=[5,5]^T (dominante diagonal). Para Jacobi, G = [[0,0.25],[1/3,0]], autovalores ≈ 0.25 e -0.25, ρ(G)=0.25<1. Inicie com x^{(0)}=[0,0], erro reduz geometricamente por fator 0.25 por iteração.",
                              "finalVerifications": [
                                "Deriva corretamente e^{(k+1)} = G e^{(k)} sem erros algébricos.",
                                "Calcula ρ(G) e prevê corretamente convergência/divergência.",
                                "Simula iterações e confirma redução de erro alinhada com ρ(G)^k.",
                                "Explica verbalmente o papel das propriedades espectrais.",
                                "Identifica condições para ρ(G)<1 em métodos clássicos.",
                                "Aplica a exemplo prático com plot de norma de erro."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da relação de erro (100% correta).",
                                "Correto cálculo de autovalores e ρ(G) (erro <1e-10).",
                                "Interpretação qualitativa e quantitativa da convergência.",
                                "Uso apropriado de normas e visualizações.",
                                "Identificação de pelo menos 3 fatores afetando ρ(G).",
                                "Aplicação independente a novo exemplo."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação de solvers iterativos em Python/MATLAB.",
                                "Análise Numérica: Estudo de taxas de convergência e estabilidade.",
                                "Física Computacional: Solução de EDP por métodos iterativos (ex: difusão).",
                                "Otimização: Relação com gradiente conjugado e métodos multiplicativos."
                              ],
                              "realWorldApplication": "Em engenharia, usado para solvers de grandes sistemas lineares em simulações CFD (dinâmica de fluidos computacional), onde matrizes esparsas demandam métodos iterativos eficientes; ρ(G)<1 garante convergência rápida em grids finitos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.3",
                        "name": "Critério de Convergência",
                        "description": "O método iterativo converge para qualquer vetor inicial se e somente se o raio espectral da matriz de iteração ρ(G) < 1.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.3.1",
                            "name": "Enunciar o teorema de convergência",
                            "description": "Estabelecer o teorema: o método converge iff ρ(G) < 1, com prova baseada na norma ||G||_2 ≤ ρ(G) < 1 implicando ||G^k|| → 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de raio espectral e normas matriciais",
                                  "subSteps": [
                                    "Defina o raio espectral ρ(G) como o máximo dos módulos dos autovalores de G.",
                                    "Explique normas matriciais induzidas por vetores, como a norma 2-espectral ||G||_2 = sup_{||x||=1} ||Gx||_2.",
                                    "Estabeleça a propriedade fundamental: para qualquer norma matricial induzida, ρ(G) ≤ ||G||.",
                                    "Discuta como existe uma norma equivalente tal que ||G|| < 1 se ρ(G) < 1.",
                                    "Exemplo: Calcule ρ(G) e ||G||_2 para uma matriz 2x2 simples."
                                  ],
                                  "verification": "Responda corretamente a perguntas sobre definições e desigualdades ρ(G) ≤ ||G||.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre autovalores e normas",
                                    "Livro de Álgebra Linear (ex: Strang)",
                                    "Calculadora ou software como MATLAB para autovalores"
                                  ],
                                  "tips": "Comece com matrizes pequenas para visualizar autovalores.",
                                  "learningObjective": "Dominar as definições e relações entre raio espectral e normas.",
                                  "commonMistakes": "Confundir raio espectral com o maior autovalor real (ignorar autovalores complexos) ou achar que ||G||_2 = ρ(G) sempre."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Enunciar precisamente o teorema de convergência",
                                  "subSteps": [
                                    "Estabeleça o contexto: método iterativo x_{k+1} = G x_k + c converge para o sistema fixo.",
                                    "Enuncie: O método converge se e somente se ρ(G) < 1.",
                                    "Explique 'converge' como ||x_k - x^*|| → 0 para qualquer x_0, onde x^* = (I - G)^{-1} c.",
                                    "Destaque as condições: G com ρ(G) < 1 garante independência do ponto inicial.",
                                    "Escreva o teorema formalmente em notação matemática."
                                  ],
                                  "verification": "Escreva o enunciado completo sem erros em um papel ou documento.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Exemplos de métodos iterativos (Jacobi, Gauss-Seidel)"
                                  ],
                                  "tips": "Memorize a estrutura 'iff' e as implicações práticas.",
                                  "learningObjective": "Articular o teorema de forma clara e precisa.",
                                  "commonMistakes": "Omitir 'se e somente se' ou confundir com critério suficiente apenas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar a direção 'ρ(G) < 1 implica convergência'",
                                  "subSteps": [
                                    "Mostre que existe norma ||.|| tal que ||G|| ≤ ρ(G) < 1.",
                                    "Use ||G^k|| ≤ ||G||^k → 0 geometricamente.",
                                    "Derive ||x_k - x^*|| ≤ ||G||^k ||x_0 - x^*|| → 0.",
                                    "Discuta a escolha da norma 2-espectral: ||G||_2 ≤ ρ(G) não é verdade, mas existe norma induzida com ||G|| próximo a ρ(G).",
                                    "Conclua a convergência linear com taxa ρ(G)."
                                  ],
                                  "verification": "Escreva a prova passo a passo e verifique com um exemplo numérico simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel para derivações",
                                    "Software para calcular potências de matriz (ex: Python NumPy)"
                                  ],
                                  "tips": "Use indução ou desigualdade geométrica para ||G^k||.",
                                  "learningObjective": "Compreender e provar a suficiência do critério.",
                                  "commonMistakes": "Errar a relação ||G||_2 ≤ ρ(G) (é o contrário: ρ(G) ≤ ||G||_2); confundir com norma de Frobenius."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar a direção 'convergência implica ρ(G) < 1'",
                                  "subSteps": [
                                    "Suponha convergência para todo x_0; tome x_0 = v (autovetor com |λ| = ρ(G)).",
                                    "Mostre que λ^k v / ||v|| não converge a menos que |λ| < 1.",
                                    "Por contradição: se ρ(G) ≥ 1, existe autovalor com |λ| ≥ 1, e a componente não converge.",
                                    "Generalize para autovalores generalizados ou Jordan se necessário, mas foque no caso diagonalizável.",
                                    "Conclua que ρ(G) < 1 é necessário."
                                  ],
                                  "verification": "Escreva a prova por contradição e teste com matriz com ρ(G) ≥ 1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas sobre autovetores",
                                    "Exemplos de matrizes divergentes"
                                  ],
                                  "tips": "Use autovetores unitários para simplificar.",
                                  "learningObjective": "Dominar a necessidade do critério via contradição.",
                                  "commonMistakes": "Ignorar autovalores complexos ou assumir diagonalizabilidade desnecessária."
                                }
                              ],
                              "practicalExample": "No método de Jacobi para resolver Ax = b com A diagonal dominante, compute G = I - D^{-1}A, encontre autovalores de G e verifique ρ(G) < 1 para garantir convergência; teste iterativamente em um sistema 3x3 como fluxo em rede elétrica.",
                              "finalVerifications": [
                                "Enunciado do teorema escrito corretamente com 'iff ρ(G) < 1'.",
                                "Prova da suficiência derivada com ||G^k|| → 0.",
                                "Prova da necessidade via contradição com autovetor.",
                                "Exemplo numérico onde ρ(G) < 1 converge e ρ(G) > 1 diverge.",
                                "Explicação da relação entre normas e raio espectral.",
                                "Taxa de convergência ligada a ρ(G)."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude do enunciado (20%).",
                                "Correção matemática da prova da suficiência (25%).",
                                "Correção da prova da necessidade (25%).",
                                "Uso correto de conceitos prévios (normas, autovalores) (15%).",
                                "Clareza na explicação e exemplos (10%).",
                                "Identificação de erros comuns evitados (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Aplicação em métodos iterativos como SOR.",
                                "Programação Computacional: Implementar em Python/MATLAB para testar ρ(G).",
                                "Física Computacional: Simulações de equações diferenciais discretizadas.",
                                "Estatística: Análise de convergência em modelos de Markov."
                              ],
                              "realWorldApplication": "Em engenharia civil, resolve sistemas lineares grandes para análise estrutural via métodos iterativos como Gauss-Seidel, verificando ρ(G) < 1 para eficiência em simulações de pontes ou edifícios sob carga."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.1.1",
                              "10.1.6.3.2.3"
                            ]
                          },
                          {
                            "id": "10.1.6.3.3.2",
                            "name": "Verificar convergência via raio espectral",
                            "description": "Dado um sistema Ax = b e método iterativo, calcular ρ(G) e concluir sobre convergência, usando software como MATLAB.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o sistema linear e identificar o método iterativo",
                                  "subSteps": [
                                    "Analise o sistema dado Ax = b e identifique a matriz A e vetor b.",
                                    "Determine o método iterativo especificado (ex: Jacobi, Gauss-Seidel ou SOR).",
                                    "Relembre a forma geral da iteração: x^{(k+1)} = G x^{(k)} + c, onde G é a matriz de iteração.",
                                    "Escreva explicitamente a decomposição de A necessária (ex: para Jacobi, A = D - L - U).",
                                    "Construa manualmente a matriz G para verificação inicial."
                                  ],
                                  "verification": "Confirme que G foi derivada corretamente comparando com a fórmula padrão do método.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Sistema Ax = b",
                                    "Folha de anotações sobre métodos iterativos",
                                    "Calculadora ou papel para decomposição manual"
                                  ],
                                  "tips": "Sempre verifique se A é estritamente diagonal dominante para intuição inicial de convergência.",
                                  "learningObjective": "Compreender a estrutura do sistema e derivar a matriz de iteração G.",
                                  "commonMistakes": [
                                    "Confundir decomposição Jacobi (D^{-1}(L+U)) com Gauss-Seidel ( (D-L)^{-1} U )",
                                    "Esquecer o sinal negativo em L e U",
                                    "Ignorar normalização de A"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a matriz G no MATLAB",
                                  "subSteps": [
                                    "Abra o MATLAB e defina a matriz A e vetor b como matrizes.",
                                    "Implemente a decomposição apropriada baseada no método (ex: D = diag(diag(A)); L = tril(-A,-1); U = triu(-A,1); ).",
                                    "Calcule G = D\\(L+U) para Jacobi ou equivalente para outros métodos.",
                                    "Visualize G com disp(G) ou spy(G) para checar estrutura.",
                                    "Teste uma iteração manual: x0 = zeros(size(b)); x1 = G*x0 + c;."
                                  ],
                                  "verification": "Execute o código e confirme que G corresponde à derivação manual do Step 1.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "MATLAB instalado",
                                    "Script .m com sistema exemplo",
                                    "Documentação MATLAB para diag, tril, triu"
                                  ],
                                  "tips": "Use ponto-e-vírgula ; no final de linhas para suprimir output desnecessário.",
                                  "learningObjective": "Implementar corretamente a matriz de iteração em ambiente computacional.",
                                  "commonMistakes": [
                                    "Usar \\ incorretamente (esquerda vs direita)",
                                    "Definir L e U com sinais errados",
                                    "Não inicializar variáveis como matrizes adequadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os autovalores e o raio espectral ρ(G)",
                                  "subSteps": [
                                    "No MATLAB, compute os autovalores com lambda = eig(G);.",
                                    "Calcule o módulo de cada autovalor: abs_lambda = abs(lambda);.",
                                    "Determine ρ(G) = max(abs_lambda).",
                                    "Exiba os resultados com fprintf('Raio espectral: %f\n', rho);.",
                                    "Plote o círculo unitário e os autovalores com scatter(real(lambda), imag(lambda)) para visualização."
                                  ],
                                  "verification": "Verifique se todos |λ_i| ≤ ρ(G) e ρ(G) é o máximo.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Script MATLAB do Step 2",
                                    "Funções eig e abs do MATLAB"
                                  ],
                                  "tips": "Para matrizes grandes, eig é eficiente; use eigs para autovalores extremos se necessário.",
                                  "learningObjective": "Calcular precisamente o raio espectral usando ferramentas numéricas.",
                                  "commonMistakes": [
                                    "Confundir raio espectral com autovalor dominante real",
                                    "Ignorar autovalores complexos (use abs)",
                                    "Erro numérico em matrizes mal-condicionadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar convergência e documentar conclusões",
                                  "subSteps": [
                                    "Compare ρ(G) com 1: se ρ(G) < 1, converge; =1, inconclusivo; >1, diverge.",
                                    "Registre o valor exato de ρ(G) e lista de |λ_i|.",
                                    "Discuta taxa de convergência aproximada: mais próximo de 0, mais rápido.",
                                    "Execute 10 iterações no MATLAB para validar empiricamente.",
                                    "Escreva um relatório curto com código, ρ(G) e conclusão."
                                  ],
                                  "verification": "Simule iterações e confirme que ||e^{(k+1)}|| < ρ(G) ||e^{(k)}||.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Script MATLAB completo",
                                    "Papel para relatório"
                                  ],
                                  "tips": "Se ρ(G) ≈1, considere aceleração como SOR com ω ótimo.",
                                  "learningObjective": "Interpretar o critério de convergência e validar numericamente.",
                                  "commonMistakes": [
                                    "Concluir convergência se ρ(G)=1 (apenas se todos |λ|<1)",
                                    "Não testar empiricamente",
                                    "Ignorar precisão numérica do MATLAB"
                                  ]
                                }
                              ],
                              "practicalExample": "Sistema 2x2: A = [2 1; 1 3], b=[3;5]. Para Jacobi: D=[2 0;0 3], L=[0 0;-1 0], U=[0 -1;0 0]. G = D^{-1}(L+U) = [0 0.5; 0.333 0]. Autovalores ≈0, ρ(G)≈0.5<1 → converge. Código MATLAB: A=[2 1;1 3]; D=diag(diag(A)); L=tril(-A,-1); U=triu(-A,1); G=D\\(L+U); rho=max(abs(eig(G))).",
                              "finalVerifications": [
                                "Matriz G implementada corretamente e matches derivação manual.",
                                "Autovalores calculados com precisão (erro <1e-10).",
                                "ρ(G) determinado como máximo |λ_i|.",
                                "Conclusão de convergência correta baseada em ρ(G)<1.",
                                "Simulação de 10 iterações mostra redução de erro.",
                                "Relatório documenta todos os passos e resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação e implementação de G (100% match).",
                                "Correção no cálculo de eig e ρ(G) (erro numérico mínimo).",
                                "Interpretação teórica precisa do critério espectral.",
                                "Validação empírica via iterações simuladas.",
                                "Clareza e completude do relatório/código.",
                                "Eficiência e boas práticas em MATLAB (comentários, visualizações)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Uso de MATLAB para análise numérica.",
                                "Física/Engenharia: Métodos iterativos em simulações de PDEs (ex: fluxo de calor).",
                                "Estatística: Análise de convergência em modelos de regressão iterativa.",
                                "Ciência da Computação: Algoritmos de autovalores em grafos e redes."
                              ],
                              "realWorldApplication": "Em engenharia civil para análise de estruturas (sistemas esparsos grandes resolvidos por Gauss-Seidel), simulações climáticas (modelos de atmosfera com milhões de variáveis), processamento de imagens (iterações para filtros) e finanças (modelos de risco com convergência rápida exigida)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.1.2",
                              "10.1.6.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.3.3.3",
                            "name": "Analisar taxa de convergência",
                            "description": "Relacionar a taxa de convergência assintótica com -log(ρ(G)), e estimar o número de iterações necessárias para precisão ε.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Raio Espectral e Convergência",
                                  "subSteps": [
                                    "Relembre a definição de raio espectral ρ(G) como o máximo módulo dos autovalores de G.",
                                    "Explique o critério de convergência: o método itera converge se ρ(G) < 1.",
                                    "Discuta o erro assintótico e como ele se comporta para métodos lineares iterativos.",
                                    "Identifique a relação qualitativa: quanto menor ρ(G), mais rápida a convergência.",
                                    "Calcule ρ(G) para uma matriz G simples de exemplo."
                                  ],
                                  "verification": "Resuma em uma frase a relação entre ρ(G) e convergência, e compute ρ para uma matriz 2x2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, calculadora ou software como MATLAB/Python (NumPy para autovalores).",
                                  "tips": "Sempre normalize a matriz para verificar se ρ < 1 antes de prosseguir.",
                                  "learningObjective": "Compreender a base teórica do raio espectral como indicador de velocidade de convergência.",
                                  "commonMistakes": "Confundir ρ(G) com norma da matriz; lembrar que ρ é o maior |λ|."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Relacionar Taxa de Convergência Assintótica",
                                  "subSteps": [
                                    "Defina a taxa de convergência assintótica R como lim (log(||e_{k+1}|| / ||e_k||)) / log(||e_k||) ≈ -log(ρ(G)).",
                                    "Derive intuitivamente por que R ≈ -log(ρ(G)) a partir da expansão ||e_{k+1}|| ≈ ρ(G) ||e_k||.",
                                    "Calcule -log(ρ(G)) para valores de ρ como 0.9, 0.5 e 0.1, observando o impacto na velocidade.",
                                    "Compare taxas para diferentes ρ: interprete numericamente (ex: ρ=0.9 requer ~23 iterações para fator 0.1).",
                                    "Registre a fórmula exata: número de iterações k ≈ log(ε / ||e_0||) / log(ρ(G))."
                                  ],
                                  "verification": "Compute -log(ρ) para ρ=0.95 e explique se é 'lento' ou 'rápido'.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora científica, planilha Excel ou Python para logaritmos.",
                                  "tips": "Use log na base natural ou 10; foque na magnitude negativa para taxa positiva.",
                                  "learningObjective": "Estabelecer a conexão quantitativa entre ρ(G) e a taxa R = -log(ρ(G)).",
                                  "commonMistakes": "Esquecer o sinal negativo; log(ρ) é negativo se ρ<1, então -log(ρ)>0."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estimar Número de Iterações para Precisão ε",
                                  "subSteps": [
                                    "Escreva a fórmula k ≈ [log(ε) - log(||e_0||)] / log(ρ(G)).",
                                    "Assuma ||e_0|| ≈ 1 para simplificação inicial e refine com norma da solução.",
                                    "Aplique a um sistema Ax=b: compute G para Jacobi/Gauss-Seidel, encontre ρ(G).",
                                    "Estime k para ε=10^{-6}, variando ρ de 0.99 a 0.5.",
                                    "Valide comparando com simulação numérica de poucas iterações."
                                  ],
                                  "verification": "Para ρ=0.9 e ε=10^{-8}, calcule k e justifique se é razoável.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software numérico (MATLAB, Python com SciPy para eigenvals e iterações).",
                                  "tips": "Use log10 para contagem intuitiva: cada década de precisão requer 1/log10(ρ) iterações.",
                                  "learningObjective": "Aplicar a fórmula para prever iterações necessárias baseado em ρ(G) e ε.",
                                  "commonMistakes": "Ignorar log(||e_0||); assumir ||e_0||=1 sem checar norma inicial."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Análise Completa em um Exemplo Real",
                                  "subSteps": [
                                    "Escolha um sistema 3x3 diagonal-dominante, compute G para Jacobi.",
                                    "Calcule autovalores de G, determine ρ(G), e -log(ρ(G)).",
                                    "Estime k para ε=10^{-10}, execute 10 iterações e compare erro real vs. previsto.",
                                    "Analise sensibilidade: altere A ligeiramente e reavalie ρ e k.",
                                    "Documente relatório com gráficos de erro vs. iteração (semi-log)."
                                  ],
                                  "verification": "Produza tabela/gráfico mostrando erro decaindo como ρ^k, confirmando previsão.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python/MATLAB para simulação completa, papel para anotações.",
                                  "tips": "Plote log(||e_k||) vs. k; inclinação deve ser log(ρ).",
                                  "learningObjective": "Integrar todos os conceitos em uma análise prática e validada.",
                                  "commonMistakes": "Máquinas flutuantes: use tolerância relativa; evite singularidade em A."
                                }
                              ],
                              "practicalExample": "Para o sistema Ax=b com A = [[4,1,0],[1,3,1],[0,1,2]], use Jacobi: G = I - D^{-1}A. Autovalores de G dão ρ≈0.577, R≈-log(0.577)≈0.55. Para ε=10^{-6}, k≈ log(10^{-6})/log(0.577) ≈ 20 iterações. Simule e confirme erro reduzido em ~20 passos.",
                              "finalVerifications": [
                                "Calcule corretamente ρ(G) e verifique ρ<1.",
                                "Relacione precisamente R = -log(ρ(G)) com exemplo numérico.",
                                "Estime k para ε dada com erro <20% vs. simulação.",
                                "Interprete: ρ=0.99 é lento (k>300 para ε=10^{-6}).",
                                "Gere gráfico confirmando decaimento exponencial.",
                                "Explique impacto de pré-condicionadores em ρ."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de R ≈ -log(ρ(G)) (100% correto).",
                                "Cálculos numéricos exatos para ρ e k (erro <1%).",
                                "Interpretação qualitativa e quantitativa da taxa.",
                                "Validação via simulação (gráfico matching).",
                                "Identificação de erros comuns e prevenção.",
                                "Relatório claro com fórmulas e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementar solvers em Python/MATLAB.",
                                "Otimização: Similar a gradiente descendente em ML.",
                                "Física Computacional: Simulações de PDEs iterativas.",
                                "Estatística: Análise de convergência em MCMC.",
                                "Engenharia: Solvers em FEA (elementos finitos)."
                              ],
                              "realWorldApplication": "Em simulações de engenharia (ex: análise estrutural via elementos finitos), estimar iterações evita desperdício computacional em solvers iterativos para sistemas grandes; em ML, otimiza treinamento de redes com solvers como conjugate gradient."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.4",
                    "name": "Condições Suficientes de Convergência",
                    "description": "Análise de convergência para matrizes estritamente diagonalmente dominantes e simétricas positivas definidas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.4.1",
                        "name": "Matrizes Estritamente Diagonalmente Dominantes",
                        "description": "Conceito fundamental para garantir a convergência de métodos iterativos clássicos como Jacobi e Gauss-Seidel, baseado na norma das linhas da matriz onde o elemento diagonal domina estritamente os off-diagonais.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.1.1",
                            "name": "Definir matriz estritamente diagonalmente dominante",
                            "description": "Reconhecer e formalizar a definição: para uma matriz A n x n, |a_ii| > sum_{j≠i} |a_ij| para todo i=1,...,n, e verificar exemplos numéricos e contraexemplos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de matrizes e dominância diagonal",
                                  "subSteps": [
                                    "Revise a estrutura de uma matriz n x n e identifique os elementos diagonais (a_ii) e off-diagonais (a_ij para j ≠ i).",
                                    "Estude o conceito de 'diagonalmente dominante' fraco vs. estrito, focando na desigualdade |a_ii| ≥ sum_{j≠i} |a_ij| para o fraco.",
                                    "Analise por que a dominância diagonal é importante em métodos iterativos para sistemas lineares.",
                                    "Pratique identificando diagonais em matrizes simples 2x2 e 3x3.",
                                    "Anote diferenças entre dominância por linha e por coluna."
                                  ],
                                  "verification": "Liste corretamente os elementos diagonais e off-diagonais de uma matriz dada e explique a importância da dominância.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Exemplos de matrizes impressos ou em software como MATLAB/Octave"
                                  ],
                                  "tips": "Visualize a matriz como uma tabela para destacar a diagonal principal.",
                                  "learningObjective": "Entender os componentes básicos de uma matriz e o papel da dominância diagonal.",
                                  "commonMistakes": [
                                    "Confundir dominância por linha com por coluna",
                                    "Incluir a diagonal na soma off-diagonal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formalizar a definição de matriz estritamente diagonalmente dominante",
                                  "subSteps": [
                                    "Escreva a definição formal: Para A n x n, |a_ii| > ∑_{j=1 to n, j≠i} |a_ij| para todo i = 1, ..., n.",
                                    "Destaque o 'estrito' (> em vez de ≥) e por que isso garante propriedades como convergência em iterações.",
                                    "Pratique reescrevendo a soma em notação sigma: ∑_{j≠i} |a_ij|.",
                                    "Crie uma matriz 2x2 simbólica e expresse a condição para cada i.",
                                    "Verifique a notação em fontes confiáveis como livros de álgebra linear numérica."
                                  ],
                                  "verification": "Escreva a definição exata e prove-a para uma matriz 2x2 genérica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang)",
                                    "Bloco de notas para fórmulas"
                                  ],
                                  "tips": "Use subscritos claros (i,i) para diagonal e (i,j) para off-diagonal.",
                                  "learningObjective": "Formalizar precisamente a definição matemática da propriedade.",
                                  "commonMistakes": [
                                    "Usar ≥ em vez de >",
                                    "Esquecer 'para todo i'"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar exemplos numéricos de matrizes estritamente diagonalmente dominantes",
                                  "subSteps": [
                                    "Selecione uma matriz 3x3 exemplo: A = [[4,1,1],[1,3,1],[1,1,5]] e calcule para cada linha.",
                                    "Para i=1: |4| > |1| + |1|? (4 > 2 ✓)",
                                    "Repita para i=2 e i=3, registrando cálculos.",
                                    "Teste uma matriz 4x4 similar e confirme todos os i.",
                                    "Implemente uma função simples em Python ou calculadora para automatizar."
                                  ],
                                  "verification": "Forneça pelo menos dois exemplos numéricos verificados corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou Python/Jupyter Notebook",
                                    "Matrizes exemplo pré-definidas"
                                  ],
                                  "tips": "Calcule somas absolutas passo a passo para evitar erros aritméticos.",
                                  "learningObjective": "Aplicar a definição para confirmar matrizes que satisfazem a condição.",
                                  "commonMistakes": [
                                    "Erros em valores absolutos negativos",
                                    "Somar incluindo diagonal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e analisar contraexemplos",
                                  "subSteps": [
                                    "Crie uma contraexemplo: B = [[2,2,0],[1,1,1],[0,2,2]] e verifique i=1: |2| > |2|+|0|? (2 > 2 ✗).",
                                    "Teste matrizes fracas: |a_ii| = soma off-diagonal.",
                                    "Gere três contraexemplos variados (2x2, 3x3, não quadrada para invalidar).",
                                    "Explique por que falham e implicações para convergência iterativa.",
                                    "Compare com matrizes dominantes para contrastar."
                                  ],
                                  "verification": "Apresente dois contraexemplos com cálculos mostrando falha na condição.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para desenhar matrizes",
                                    "Software de matriz como NumPy"
                                  ],
                                  "tips": "Comece com matrizes próximas à dominância para aprender sutilezas.",
                                  "learningObjective": "Reconhecer quando a condição não é satisfeita e por quê.",
                                  "commonMistakes": [
                                    "Afirmar dominância em contraexemplos óbvios",
                                    "Ignorar todos os i"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a matriz A = [[5, -1, 0], [-1, 4, -1], [0, -1, 3]]. Verifique: Linha 1: |5| > 1+0 (5>1 ✓); Linha 2: |4| > 1+1 (4>2 ✓); Linha 3: |3| > 0+1 (3>1 ✓). Logo, A é estritamente diagonalmente dominante, garantindo convergência do método de Jacobi.",
                              "finalVerifications": [
                                "Defina corretamente a condição para n=3.",
                                "Verifique uma matriz 3x3 exemplo fornecida.",
                                "Identifique falha em um contraexemplo.",
                                "Explique implicação para métodos iterativos.",
                                "Escreva a notação sigma precisa.",
                                "Distinga estrita de fraca."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (100% match).",
                                "Cálculos numéricos corretos em exemplos (sem erros aritméticos).",
                                "Identificação correta de contraexemplos.",
                                "Explicação clara de implicações teóricas.",
                                "Uso consistente de notação matemática.",
                                "Profundidade em sub-passos (mínimo 4 por step)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar função em Python/NumPy para checar dominância.",
                                "Física: Modelagem de sistemas lineares em circuitos elétricos ou mecânica.",
                                "Computação Científica: Análise de convergência em solvers numéricos.",
                                "Estatística: Condições em modelos de regressão multivariada."
                              ],
                              "realWorldApplication": "Em engenharia computacional, matrizes estritamente diagonalmente dominantes garantem convergência rápida de métodos iterativos como Gauss-Seidel em simulações de fluxo de fluidos, análise finita de elementos ou resolução de grandes sistemas lineares em machine learning."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.2",
                            "name": "Provar convergência do método de Jacobi",
                            "description": "Demonstrar que o raio espectral da matriz de iteração de Jacobi B = I - D^{-1}A é menor que 1 usando a norma infinito, citando teorema de Golub & Van Loan (Cap. 10).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições de matriz estritamente diagonalmente dominante (SDD) e método de Jacobi",
                                  "subSteps": [
                                    "Defina uma matriz A = (a_ij) como estritamente diagonalmente dominante se |a_ii| > Σ_{j≠i} |a_ij| para todo i.",
                                    "Lembre a decomposição A = D - L - U, onde D é diagonal, L estritamente triangular inferior, U estritamente triangular superior.",
                                    "Descreva o método de iteração de Jacobi: x^{(k+1)} = D^{-1}(b + (L+U)x^{(k)}), com matriz de iteração B_J = D^{-1}(L + U) = I - D^{-1}A."
                                  ],
                                  "verification": "Escreva as definições formalmente e verifique com um exemplo 2x2 simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro Golub & Van Loan, Cap. 10",
                                    "Papel e caneta ou editor LaTeX"
                                  ],
                                  "tips": "Use notação consistente para índices i,j.",
                                  "learningObjective": "Entender as premissas da prova: SDD e forma de B.",
                                  "commonMistakes": [
                                    "Confundir dominante diagonal fraco com estrito",
                                    "Esquecer que L e U são sem diagonal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Expressar a matriz de iteração B explicitamente",
                                  "subSteps": [
                                    "Escreva B = I - D^{-1}A.",
                                    "Mostre que os elementos de B são b_ii = 0 e b_ij = -a_ij / a_ii para i≠j.",
                                    "Confirme que B tem zeros na diagonal e off-diagonal b_ij = a_ij / |a_ii| em valor absoluto."
                                  ],
                                  "verification": "Escreva a forma matricial de B para uma matriz A genérica n x n.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Matriz exemplo SDD 3x3",
                                    "Software simbólico como SymPy (opcional)"
                                  ],
                                  "tips": "Assuma a_ii > 0 para simplicidade, comum em problemas físicos.",
                                  "learningObjective": "Dominar a estrutura elemento a elemento de B.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo em b_ij = - (D^{-1}A)_{ij}",
                                    "Confundir B_J com B_GS"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a norma infinito da matriz B",
                                  "subSteps": [
                                    "Defina ||B||_∞ = max_{1≤i≤n} Σ_{j=1}^n |b_ij|.",
                                    "Como b_ii=0, ||B||_∞ = max_i Σ_{j≠i} |b_ij| = max_i Σ_{j≠i} |a_ij| / |a_ii|.",
                                    "Escreva explicitamente a linha i de B em termos de A."
                                  ],
                                  "verification": "Compute ||B||_∞ para uma matriz exemplo e confirme fórmula.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplo numérico: A = [[4,-1,0],[-1,4,-1],[0,-1,4]]"
                                  ],
                                  "tips": "A norma ∞ é a máxima soma de linha absoluta.",
                                  "learningObjective": "Aplicar definição de norma matricial subordinada à ∞.",
                                  "commonMistakes": [
                                    "Incluir diagonal na soma (que é zero)",
                                    "Usar norma 2 em vez de ∞"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Concluir convergência citando teorema de Golub & Van Loan",
                                  "subSteps": [
                                    "Cite Teorema 10.1.1 de Golub & Van Loan: se ||B|| <1 para norma compatível, então método converge e ρ(B) ≤ ||B|| <1.",
                                    "Como norma ∞ é subordinada, ρ(B) <1 implica convergência do método de Jacobi.",
                                    "Escreva a conclusão: Para A SDD, Jacobi converge com raio espectral ρ(B) <1."
                                  ],
                                  "verification": "Inclua citação exata e lembre que raio espectral determina taxa assintótica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Golub & Van Loan, Cap. 10, p. 508-509"
                                  ],
                                  "tips": "Norma qualquer subordinada funciona, ∞ é conveniente para SDD.",
                                  "learningObjective": "Ligar norma à convergência via raio espectral.",
                                  "commonMistakes": [
                                    "Confundir ρ(B) com ||B||",
                                    "Citar capítulo errado"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[4, -1, 0], [-1, 4, -1], [0, -1, 4]], SDD pois |4| >1, |4|>1+1=2, |4|>1. D=diag(4,4,4), B = [[0, 0.25, 0], [0.25, 0, 0.25], [0, 0.25, 0]]. ||B||_∞ = max(0.25, 0.5, 0.25)=0.5 <1. Autovalores de B confirmam ρ(B)≈0.5<1.",
                              "finalVerifications": [
                                "Definições de SDD e B corretas.",
                                "Cálculo explícito de ||B||_∞ em termos de A.",
                                "Desigualdade estrita ||B||_∞ <1 derivada de SDD.",
                                "Citação precisa do teorema de Golub & Van Loan.",
                                "Conclusão sobre ρ(B)<1 e convergência."
                              ],
                              "assessmentCriteria": [
                                "Rigor matemático nas desigualdades.",
                                "Lógica sequencial sem lacunas.",
                                "Uso correto de notação matricial e normas.",
                                "Citação bibliográfica precisa.",
                                "Clareza na ligação entre SDD e ρ(B)<1."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementar Jacobi em Python/NumPy e testar convergência.",
                                "Análise Numérica: Comparar com Gauss-Seidel para mesmas matrizes.",
                                "Física Computacional: Matrizes SDD em discretizações de equações de Poisson/Laplace.",
                                "Otimização: Condições para métodos iterativos em minimização quadrática."
                              ],
                              "realWorldApplication": "Em simulações numéricas de equações diferenciais parciais (EDPs) como difusão de calor ou escoamento de fluidos (CFD), onde matrizes laplacianas são SDD, o método de Jacobi garante convergência rápida para prever distribuições de temperatura ou pressão em engenharia."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.1.3",
                            "name": "Provar convergência do método de Gauss-Seidel",
                            "description": "Estender a prova para Gauss-Seidel mostrando que ||G||_∞ < 1 onde G = (D+L)^{-1}U, com análise de normas e propriedades de dominância diagonal (Meyer, Cap. 6).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estabelecer a decomposição matricial A = D + L + U e verificar dominância diagonal estrita (SDD)",
                                  "subSteps": [
                                    "Defina D como a matriz diagonal com entradas a_{ii}, L como a matriz triangular inferior estrita com entradas l_{ij} = a_{ij} para i > j, e U como a triangular superior estrita com u_{ij} = a_{ij} para i < j.",
                                    "Verifique a condição SDD: para cada i, |a_{ii}| > ∑_{j ≠ i} |a_{ij}|.",
                                    "Mostre que essa condição implica que D é invertível e domina as partes off-diagonal.",
                                    "Escolha uma matriz exemplo 3x3 SDD para ilustrar a decomposição.",
                                    "Confirme que D + L herda propriedades de dominância do lower block."
                                  ],
                                  "verification": "Escreva explicitamente D, L, U para a matriz exemplo e confirme SDD linha por linha com desigualdades estritas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro Meyer, Capítulo 6",
                                    "Papel e lápis",
                                    "Calculadora ou software simbólico como SymPy"
                                  ],
                                  "tips": "Sempre normalize a matriz para ter diagonais positivas se possível, facilitando bounds.",
                                  "learningObjective": "Compreender a estrutura matricial essencial para métodos iterativos e condições de convergência.",
                                  "commonMistakes": [
                                    "Confundir L (inferior estrita) com U (superior estrita)",
                                    "Usar dominância fraca (≥) em vez de estrita (>)",
                                    "Esquecer de verificar todas as linhas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a iteração do método de Gauss-Seidel e o operador de iteração G",
                                  "subSteps": [
                                    "Escreva as equações do método GS: para cada i, a_{ii} x_i^{(k+1)} + ∑_{j<i} a_{ij} x_j^{(k+1)} = b_i - ∑_{j>i} a_{ij} x_j^{(k)}.",
                                    "Reorganize em forma matricial: (D + L) x^{(k+1)} = - U x^{(k)} + b.",
                                    "Inverta: x^{(k+1)} = (D + L)^{-1} (-U) x^{(k)} + (D + L)^{-1} b.",
                                    "Defina G = (D + L)^{-1} U (absorvendo sinal para norma, pois ||-G|| = ||G||).",
                                    "Justifique por que ||G||_∞ < 1 implica convergência pelo teorema de normas."
                                  ],
                                  "verification": "Derive a expressão de G explicitamente e escreva a forma x^{(k+1)} = G x^{(k)} + c.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Meyer Cap. 6, seção sobre GS",
                                    "Exemplo de matriz do passo 1",
                                    "Folha para equações matriciais"
                                  ],
                                  "tips": "Use a convenção do prompt para G = (D + L)^{-1} U, focando na norma absoluta.",
                                  "learningObjective": "Derivar corretamente o operador espectral para análise de convergência.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo na derivação inicial",
                                    "Confundir com Jacobi (que usa D^{-1} (L + U))",
                                    "Não inverter corretamente para a forma fixa-ponto"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar que D + L é diagonalmente dominante e boundar ||(D + L)^{-1}||_∞ ≤ 1",
                                  "subSteps": [
                                    "Mostre que D + L é triangular inferior e estritamente diagonalmente dominante: para linha i, |(D + L)_{ii}| = |a_{ii}| > ∑_{j=1}^{i-1} |a_{ij}| = ∑_{j<i} |(D + L)_{i j}|.",
                                    "Prove por indução que as somas de linha absolutas de H = (D + L)^{-1} satisfazem ∑_{j=1}^i |h_{i j}| ≤ 1 para todo i.",
                                    "Base: para i=1, h_{11} = 1/a_{11}, |h_{11}| < 1? Na verdade ≤ 1 se normalizado, mas para SDD geral ≤ 1 pela dominância.",
                                    "Passo indutivo: assuma para linhas anteriores, resolva para h_{i .} usando a equação H (D + L) = I.",
                                    "Conclua que ||H||_∞ = ∑_{j} |h_{i j}| ≤ 1 para todas as linhas i."
                                  ],
                                  "verification": "Escreva a prova por indução completa, verificando base e passo para n=2 e generalizando.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Meyer Cap. 6 sobre propriedades de inversas",
                                    "Matriz triangular exemplo",
                                    "SymPy para verificação numérica opcional"
                                  ],
                                  "tips": "Use equação da i-ésima linha: h_{i i} = 1 / (a_{ii} - ∑_{j<i} a_{i j} h_{j i}), mas foque em bounds absolutos.",
                                  "learningObjective": "Dominar prova por indução para normas de inversas de triangulares dominantes.",
                                  "commonMistakes": [
                                    "Erro na base da indução (assumir |a_{11}| > 0 só)",
                                    "Não usar valores absolutos nas somas off-diagonal",
                                    "Confundir row sums com column sums"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar que ||G||_∞ < 1 usando SDD e o bound de (D + L)^{-1}",
                                  "subSteps": [
                                    "Para cada linha i, bounde ∑_{j} |g_{i j}| = ∑_{j} | ∑_{k} h_{i k} u_{k j} | ≤ ∑_{k ≤ i} |h_{i k}| ∑_{j > k} |u_{k j}|.",
                                    "Note que ∑_{j > k} |u_{k j}| = ∑_{j > k} |a_{k j}| < |a_{k k}| - ∑_{j < k} |a_{k j}|.",
                                    "Como ∑_{j < k} |a_{k j}| = ∑_{j < k} |l_{k j}|, e pela dominância em H, o produto estrito <1.",
                                    "Use estrutura triangular: para k < i, o bound é estrito devido a SDD, e para k=i, u_{i j}=0 para j>i exceto zero.",
                                    "Conclua estritamente ||G||_∞ < 1 para SDD."
                                  ],
                                  "verification": "Calcule ||G||_∞ para o exemplo numérico e generalize a prova row-wise.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Exemplo matricial completo",
                                    "Meyer Cap. 6 prova detalhada",
                                    "Software para computar normas (opcional)"
                                  ],
                                  "tips": "Visualize graficamente as somas row-wise para entender o 'espaço' deixado pela dominância.",
                                  "learningObjective": "Completar a prova de convergência estendendo Jacobi para GS via normas.",
                                  "commonMistakes": [
                                    "Usar submultiplicatividade direta ||H|| ||U|| (pode não ser <1)",
                                    "Ignorar a estrutura triangular nos bounds",
                                    "Não garantir estritude (<1, não ≤)"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = \\begin{pmatrix} 10 & -1 & 0 \\\\ -1 & 11 & -1 \\\\ 0 & -1 & 12 \\end{pmatrix} (SDD: 10>1, 11>2, 12>1). D = diag(10,11,12), L = \\begin{pmatrix} 0&0&0 \\\\ -1&0&0 \\\\ 0&-1&0 \\end{pmatrix}, U = \\begin{pmatrix} 0&-1&0 \\\\ 0&0&-1 \\\\ 0&0&0 \\end{pmatrix}. Compute (D+L) = \\begin{pmatrix} 10&0&0 \\\\ -1&11&0 \\\\ 0&-1&12 \\end{pmatrix}, encontre H=(D+L)^{-1} (use fórmula ou software), G = H U, e verifique max_i \\sum_j |g_{ij}| <1 (tipicamente ~0.1).",
                              "finalVerifications": [
                                "G definido corretamente como (D+L)^{-1} U.",
                                "Prova mostra ||(D+L)^{-1}||_∞ ≤ 1 por indução.",
                                "Bounds row-wise para U usam SDD estrita.",
                                "||G||_∞ <1 explicitamente para linhas.",
                                "Exemplo numérico confirma norma <1.",
                                "Conclusão liga a convergência absoluta."
                              ],
                              "assessmentCriteria": [
                                "Corretude matemática na derivação de G e normas.",
                                "Uso preciso de indução para bound de inversa.",
                                "Aplicação correta de SDD em todos os bounds.",
                                "Clareza na generalização row-wise.",
                                "Verificação numérica no exemplo.",
                                "Ausência de erros de sinal ou estrutura triangular."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementar GS em Python/NumPy e testar com matrizes SDD.",
                                "Análise Numérica: Comparar com SOR e aceleração.",
                                "Engenharia Computacional: Solvers para EDPs em método de diferenças finitas.",
                                "Otimização: Sistemas lineares em modelos de regressão multivariada."
                              ],
                              "realWorldApplication": "Provar convergência garante confiabilidade em solvers iterativos para sistemas lineares grandes em simulações de engenharia (ex: análise estrutural em mecânica, modelagem de fluidos em CFD, circuitos elétricos), onde matrizes SDD surgem naturalmente de discretizações físicas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.1.1",
                              "10.1.6.4.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.2",
                        "name": "Matrizes Simétricas Positivamente Definidas",
                        "description": "Classe de matrizes simétricas com todos autovalores positivos, garantindo convergência de métodos iterativos simétricos como SOR e SSOR em sistemas lineares Ax=b.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.2.1",
                            "name": "Definir e caracterizar matrizes SPD",
                            "description": "Formalizar: A simétrica e x^T A x > 0 para x ≠ 0; equivalências com autovalores positivos e decomposição de Cholesky (Watkins, Cap. 5).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender matrizes simétricas",
                                  "subSteps": [
                                    "Revise a definição de matriz simétrica: A = A^T.",
                                    "Verifique simetria transpondo uma matriz manualmente.",
                                    "Explore propriedades: autovalores reais, autovetores ortogonais.",
                                    "Pratique com matrizes 2x2 e 3x3.",
                                    "Use software para computar A - A^T e confirmar nulidade."
                                  ],
                                  "verification": "Confirme que A = A^T para exemplos escolhidos; teste com pelo menos 3 matrizes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora ou Python/NumPy"
                                  ],
                                  "tips": "Sempre compare A e A^T elemento a elemento para iniciantes.",
                                  "learningObjective": "Identificar e verificar matrizes simétricas corretamente.",
                                  "commonMistakes": [
                                    "Confundir simetria com diagonalidade",
                                    "Erros em transposição manual"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir positividade definida via forma quadrática",
                                  "subSteps": [
                                    "Defina x^T A x > 0 para todo x ≠ 0.",
                                    "Calcule x^T A x para vetores unitários em matrizes 2x2.",
                                    "Teste com x aleatórios e verifique sinal positivo.",
                                    "Compare com semi-definida positiva (≥ 0).",
                                    "Programe uma função para checar em múltiplos x."
                                  ],
                                  "verification": "Para uma matriz dada, compute x^T A x para 5 vetores x ≠ 0 e confirme todos positivos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy",
                                    "Matriz de exemplo simétrica"
                                  ],
                                  "tips": "Escolha x com normas variadas para robustez do teste.",
                                  "learningObjective": "Aplicar definição de forma quadrática para caracterizar SPD.",
                                  "commonMistakes": [
                                    "Permitir x=0 na definição",
                                    "Confundir com autovalores"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Equivalência com autovalores positivos",
                                  "subSteps": [
                                    "Lembre que para A simétrica, autovalores são reais.",
                                    "Prove ou aceite: todos λ_i > 0 iff x^T A x > 0.",
                                    "Compute autovalores de matrizes SPD candidatas.",
                                    "Verifique decomposição espectral A = Q Λ Q^T com Λ diagonal positiva.",
                                    "Teste contra-exemplos: um autovalor zero ou negativo."
                                  ],
                                  "verification": "Calcule autovalores; todos devem ser positivos para SPD.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software: NumPy eig ou MATLAB eig",
                                    "Matrizes 3x3 simétricas"
                                  ],
                                  "tips": "Use np.linalg.eig para eficiência em dimensões maiores.",
                                  "learningObjective": "Reconhecer equivalência entre forma quadrática e autovalores.",
                                  "commonMistakes": [
                                    "Ignorar que autovalores reais só para simétricas",
                                    "Arredondamento numérico em autovalores próximos de zero"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Caracterização via decomposição de Cholesky",
                                  "subSteps": [
                                    "Defina decomposição: A = L L^T com L triangular inferior.",
                                    "Aplique algoritmo de Cholesky em matriz 2x2.",
                                    "Implemente em código e teste sucesso/falha.",
                                    "Relacione: existência de Cholesky iff SPD.",
                                    "Verifique reconstruindo A = L L^T."
                                  ],
                                  "verification": "Decomposição Cholesky bem-sucedida sem pivoteamento e A ≈ L L^T.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python: scipy.linalg.cholesky",
                                    "Matrizes SPD conhecidas"
                                  ],
                                  "tips": "Monitore diagonal de L para positividade durante computação.",
                                  "learningObjective": "Usar Cholesky como teste prático para SPD.",
                                  "commonMistakes": [
                                    "Confundir com LU",
                                    "Não checar simetria prévia"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar todas as caracterizações",
                                  "subSteps": [
                                    "Crie fluxograma: simétrica? → forma quad? → autovalores? → Cholesky.",
                                    "Teste matrizes mistas (SPD, não-SPD).",
                                    "Discuta estabilidade numérica de cada método.",
                                    "Resolva exercício: classifique dada matriz.",
                                    "Documente conclusões em relatório curto."
                                  ],
                                  "verification": "Classifique corretamente 4 matrizes usando múltiplos testes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou Jupyter Notebook",
                                    "Banco de matrizes teste"
                                  ],
                                  "tips": "Priorize Cholesky para prática computacional.",
                                  "learningObjective": "Sintetizar todas as caracterizações de SPD.",
                                  "commonMistakes": [
                                    "Dependência excessiva em um método só",
                                    "Erros numéricos não detectados"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[2, 1], [1, 2]]. Verifique: simétrica (A=A^T), x=[1,0]^T → x^T A x=2>0, x=[1,1]^T → 6>0; autovalores ≈3,1 >0; Cholesky L=[[√2,0],[1/√2,√(3/2)]] e L L^T=A.",
                              "finalVerifications": [
                                "A = A^T confirmada.",
                                "x^T A x > 0 para 10 vetores x aleatórios ≠0.",
                                "Todos autovalores reais e positivos.",
                                "Decomposição Cholesky existe e reconstrói A com erro <1e-10.",
                                "Minors principais todos positivos.",
                                "Sem pivoteamento necessário em Cholesky."
                              ],
                              "assessmentCriteria": [
                                "Definição precisa de SPD via forma quadrática.",
                                "Correta identificação de simetria e testes equivalentes.",
                                "Implementação numérica sem erros (autovalores/Cholesky).",
                                "Explicação clara de equivalências teóricas.",
                                "Análise de contra-exemplos.",
                                "Uso eficiente de ferramentas computacionais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Matrizes de rigidez em mecânica (formas de energia).",
                                "Otimização: Hessiana SPD em métodos de Newton.",
                                "Machine Learning: Matrizes de covariância em Gaussianas.",
                                "Estatística: Distribuições multivariadas normais.",
                                "Engenharia: Análise modal em vibrações."
                              ],
                              "realWorldApplication": "Em simulações de elementos finitos (FEA), matrizes SPD surgem como matrizes de rigidez, permitindo solvers eficientes como Cholesky para equações lineares em engenharia estrutural e otimização de portfólios financeiros via modelos quadráticos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.2",
                            "name": "Analisar raio espectral em métodos iterativos",
                            "description": "Calcular o raio espectral ρ para Jacobi em SPD: ρ(B) < 1 se ω=1 e propriedades espectrais; usar teoremas de Young para SOR (Golub & Van Loan, Seção 10.2).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Propriedades de Matrizes Simétricas Positivamente Definidas (SPD) e Splitting de Jacobi",
                                  "subSteps": [
                                    "Defina matriz SPD: simétrica com autovalores positivos.",
                                    "Explique o splitting de Jacobi: A = D - (L + U), onde D é diagonal.",
                                    "Descreva a iteração de Jacobi: x^{k+1} = D^{-1}(b - (L + U)x^k).",
                                    "Identifique pré-condições para convergência: diagonal dominante ou propriedades espectrais.",
                                    "Lembre teorema: para SPD diagonalmente dominante, método converge."
                                  ],
                                  "verification": "Liste 5 propriedades de SPD e escreva a matriz de iteração B_J = D^{-1}(L + U).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Golub & Van Loan, Seção 10.1-10.2",
                                    "Python/MATLAB para exemplos SPD"
                                  ],
                                  "tips": "Sempre verifique simetria e positividade via autovalores antes da análise.",
                                  "learningObjective": "Compreender os fundamentos teóricos para análise espectral em Jacobi.",
                                  "commonMistakes": [
                                    "Confundir SPD com simétrica indefinida.",
                                    "Esquecer que D^{-1} requer diagonal não-nula."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e Calcular a Matriz de Iteração B para Jacobi em SPD",
                                  "subSteps": [
                                    "Escreva B_J = I - D^{-1}A para Jacobi com ω=1.",
                                    "Calcule autovalores de B_J: relacione com autovalores de A.",
                                    "Prove que para SPD, |λ(B_J)| ≤ 1 - δ para alguma δ>0 sob diagonal dominância.",
                                    "Use propriedades espectrais: ρ(B_J) = max |1 - λ_i / d_ii| onde λ_i autovalores de A.",
                                    "Verifique ρ(B_J) < 1 para SPD irreducivelmente diagonal dominante."
                                  ],
                                  "verification": "Compute B_J para uma matriz SPD 2x2 e confirme ρ(B_J) < 1.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora simbólica (SymPy)",
                                    "Golub & Van Loan, Seção 10.2"
                                  ],
                                  "tips": "Normalize A para facilitar cálculos de autovalores.",
                                  "learningObjective": "Derivar explicitamente B_J e suas propriedades espectrais em SPD.",
                                  "commonMistakes": [
                                    "Erro no sinal de B_J (deve ser D^{-1}(L+U), não negativo).",
                                    "Ignorar normalização diagonal."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Condições de Convergência via Raio Espectral ρ(B) < 1",
                                  "subSteps": [
                                    "Estabeleça critério: método converge se ρ(B) < 1.",
                                    "Para Jacobi em SPD: prove ρ(B_J) < 1 se A é diagonal dominante estritamente.",
                                    "Discuta propriedades espectrais: autovalores de B_J dentro do círculo unitário.",
                                    "Analise casos onde ω=1 garante convergência em SPD consistentes.",
                                    "Compare com teorema de Gershgorin para bounds em ρ."
                                  ],
                                  "verification": "Demonstre analiticamente ρ(B_J) < 1 para exemplo diagonal dominante SPD.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis para provas",
                                    "Referência: Golub & Van Loan Thm 10.2.1"
                                  ],
                                  "tips": "Use desigualdades de autovalores para bounds rápidos.",
                                  "learningObjective": "Aplicar teoremas espectrais para verificar convergência de Jacobi.",
                                  "commonMistakes": [
                                    "Assumir convergência sem diagonal dominância.",
                                    "Confundir ρ com norma."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estender Análise para SOR Usando Teoremas de Young",
                                  "subSteps": [
                                    "Introduza SOR: B_{SOR}(ω) = (D - ωL)^{-1} [(1-ω)D + ωU].",
                                    "Aplique Teorema de Young: para |ω-1| pequeno, ρ <1 em SPD.",
                                    "Calcule ρ otimal: ω_opt = 2 / (1 + sqrt(1 - ρ(B_J)^2)).",
                                    "Prove convergência para 0 < ω < 2 em matrizes consistentes SPD.",
                                    "Compare aceleração SOR vs Jacobi via raio espectral."
                                  ],
                                  "verification": "Calcule ω_opt e ρ(B_{SOR}) para exemplo de Jacobi anterior.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB eig() para SOR",
                                    "Golub & Van Loan, Seção 10.2 Thm 10.2.3"
                                  ],
                                  "tips": "Comece com ω=1 (reduz a Jacobi) e incremente gradualmente.",
                                  "learningObjective": "Usar teoremas de Young para otimizar SOR em SPD.",
                                  "commonMistakes": [
                                    "Escolher ω >2 levando a divergência.",
                                    "Esquecer inversão de (D - ωL)."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar Numericamente e Sintetizar Análise",
                                  "subSteps": [
                                    "Implemente Jacobi e SOR em código para A SPD.",
                                    "Compute autovalores de B_J e B_{SOR} numericamente.",
                                    "Confirme ρ <1 e compare taxas de convergência.",
                                    "Analise sensibilidade a ω e propriedades de A.",
                                    "Documente conclusões com gráficos de erro."
                                  ],
                                  "verification": "Gere plot de ||e^k|| mostrando convergência com ρ calculado.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python (NumPy, SciPy)",
                                    "Exemplo matriz SPD 5x5"
                                  ],
                                  "tips": "Use np.linalg.eig para precisão em autovalores.",
                                  "learningObjective": "Validar teoria via computação numérica.",
                                  "commonMistakes": [
                                    "Erro numérico em autovalores mal-condicionados.",
                                    "Não inicializar x^0 adequadamente."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[4, -1, 0], [-1, 4, -1], [0, -1, 4]] (SPD, diagonal dominante). Para Jacobi (ω=1), B_J tem ρ≈0.25<1. Para SOR com ω=1.2, ρ≈0.1, acelerando convergência em Ax=b com b=[1,2,1]^T.",
                              "finalVerifications": [
                                "Calculou corretamente B_J e confirmou ρ(B_J)<1 para SPD dada.",
                                "Aplicou teorema de Young para SOR e encontrou ω_opt.",
                                "Verificou numericamente com código que ρ<1 implica convergência.",
                                "Identificou condições suficientes (diagonal dominância).",
                                "Comparou ρ_Jacobi vs ρ_SOR.",
                                "Documentou propriedades espectrais chave."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de B e cálculo de ρ (90% correto).",
                                "Correta aplicação de teoremas (Young, Gershgorin).",
                                "Validação numérica com erro <1e-6.",
                                "Explicação clara de condições de convergência.",
                                "Análise comparativa SOR vs Jacobi.",
                                "Uso adequado de referências (Golub & Van Loan)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Solução de EDP elípticas (Poisson) com SPD de Laplace.",
                                "Computação: Implementação eficiente em solvers lineares (SciPy).",
                                "Estatística: Inversão de matrizes de covariância SPD.",
                                "Otimização: Gradiente conjugado acelerado por SOR."
                              ],
                              "realWorldApplication": "Em simulações de engenharia (análise finita de elementos para estruturas), onde sistemas SPD grandes surgem de discretizações; análise de ρ garante eficiência iterativa em supercomputadores para problemas de milhões de variáveis."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.2.3",
                            "name": "Verificar convergência via condições suficientes",
                            "description": "Aplicar teoremas: Gauss-Seidel converge para SPD simétricas; testar numericamente com matrizes tridiagonais e analisar sensibilidade (Meyer, Cap. 8).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar teorema de convergência de Gauss-Seidel para matrizes SPD",
                                  "subSteps": [
                                    "Ler e resumir o teorema de Meyer (Cap. 8) sobre convergência de Gauss-Seidel para matrizes simétricas positivamente definidas (SPD).",
                                    "Entender que para A SPD, o método de Gauss-Seidel converge monotonicamente para a solução exata.",
                                    "Derivar ou recordar a prova básica: usar norma energética e propriedades de SPD.",
                                    "Comparar com Jacobi: Gauss-Seidel converge duas vezes mais rápido para SPD.",
                                    "Anotar condições suficientes: A simétrica e positivamente definida (autovalores positivos)."
                                  ],
                                  "verification": "Escrever um resumo de 1 página explicando o teorema e suas condições, com referências ao livro.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro Meyer, Capítulo 8",
                                    "Papel e caneta ou editor de texto",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Foque nas propriedades espectrais de SPD; visualize autovalores positivos.",
                                  "learningObjective": "Compreender teoricamente por que Gauss-Seidel converge para SPD.",
                                  "commonMistakes": [
                                    "Confundir SPD com diagonal dominante",
                                    "Ignorar simetria obrigatória"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar se uma matriz é simétrica positivamente definida (SPD)",
                                  "subSteps": [
                                    "Gerar uma matriz tridiagonal simétrica: a_{i,i-1}=a_{i+1,i}=1, a_{i,i}=2 para i=1..n.",
                                    "Confirmar simetria: A = A^T.",
                                    "Verificar definitividade positiva: calcular todos autovalores >0 ou forma quadrática x^T A x >0 para x≠0.",
                                    "Usar teste de Cholesky: fatorar A = LL^T sem pivoteamento.",
                                    "Testar com matrizes de tamanho pequeno (n=5,10) para validar."
                                  ],
                                  "verification": "Executar Cholesky e mostrar que todos diagonais de L são reais e positivos; listar autovalores.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy (numpy.linalg.eig, scipy.linalg.cholesky)",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Matrizes tridiagonais Toeplitz com diagonais 1,2,1 são SPD; use np.linalg.eigh para simétricas.",
                                  "learningObjective": "Dominar testes práticos para propriedades SPD.",
                                  "commonMistakes": [
                                    "Usar eigvals em vez de eigh para simétricas",
                                    "Esquecer normalizar vetor teste para forma quadrática"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e testar numericamente Gauss-Seidel em matriz tridiagonal SPD",
                                  "subSteps": [
                                    "Implementar Gauss-Seidel iterativo: x^{(k+1)}_i = (b_i - sum_{j<i} a_{ij} x^{(k+1)}_j - sum_{j>i} a_{ij} x^{(k)}_j)/a_{ii}.",
                                    "Escolher b para solução exata conhecida, e.g., x*=ones(n,1), b=A x*.",
                                    "Executar até ||x^{(k+1)} - x^{(k)}|| < 1e-6; registrar número de iterações e resíduos.",
                                    "Plotar convergência: log(resíduo) vs iterações.",
                                    "Comparar com solução exata via decomposição LU ou direta."
                                  ],
                                  "verification": "Número de iterações <100 para n=100; erro final <1e-10.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python: NumPy para arrays, Matplotlib para plots",
                                    "Código template de Gauss-Seidel"
                                  ],
                                  "tips": "Use vetor inicial x0=zeros; monitore norma euclidiana do erro.",
                                  "learningObjective": "Implementar e observar convergência prática em SPD.",
                                  "commonMistakes": [
                                    "Atualização errada da ordem forward/backward",
                                    "Não dividir por a_ii (diagonal dominante aqui)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar sensibilidade da convergência a perturbações",
                                  "subSteps": [
                                    "Perturbar A: adicionar ruído gaussiano pequeno (1e-6) aos off-diagonais.",
                                    "Verificar se ainda SPD (autovalores mínimos >0).",
                                    "Executar Gauss-Seidel na A perturbada; comparar iterações e taxa de convergência.",
                                    "Analisar raio espectral de matriz de iteração de Gauss-Seidel.",
                                    "Testar com n crescente (50,100,200) para ver dependência em tamanho.",
                                    "Concluir sobre robustez sob condições suficientes."
                                  ],
                                  "verification": "Gráficos de iterações vs nível de perturbação; tabela de autovalores min.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Mesmo ambiente Python",
                                    "Funções de perturbação: np.random.normal"
                                  ],
                                  "tips": "Raio espectral ρ(B_GS) <1 garante convergência; estime via power iteration.",
                                  "learningObjective": "Avaliar sensibilidade numérica das condições suficientes.",
                                  "commonMistakes": [
                                    "Perturbação quebra SPD sem checagem",
                                    "Ignorar conditioning number de A"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva Ax=b com n=50, A tridiagonal SPD (1,2,1), x*=ones(50,1), b=A x*. Implemente Gauss-Seidel: converge em ~20 iterações. Perturbe off-diagonais por 1e-5: ainda converge, mas +5 iterações; plote resíduos.",
                              "finalVerifications": [
                                "Teorema corretamente resumido com condições SPD.",
                                "Matriz tridiagonal confirmada SPD via Cholesky/autovalores.",
                                "Gauss-Seidel implementado converge numericamente (<50 iterações para n=100).",
                                "Análise de sensibilidade mostra robustez para perturbações pequenas.",
                                "Plots e tabelas documentam todos testes.",
                                "Comparação com solução exata: erro <1e-8."
                              ],
                              "assessmentCriteria": [
                                "Precisão teórica: teorema e condições explicados corretamente (30%).",
                                "Implementação numérica: código funcional e convergência observada (25%).",
                                "Verificações SPD: testes múltiplos válidos (20%).",
                                "Análise sensibilidade: perturbações quantificadas e plots claros (15%).",
                                "Documentação: relatórios com gráficos/tabelas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Solução de EDOs elípticas discretizadas (Laplaciano tridiagonal SPD).",
                                "Engenharia: Otimização quadrática em controle (min x^T A x - b^T x).",
                                "Computação: Algoritmos paralelos para iterações em grafos.",
                                "Estatística: Covariância SPD em modelos multivariados."
                              ],
                              "realWorldApplication": "Em simulações de fluxo de calor (equações de Poisson discretizadas geram A SPD tridiagonal), Gauss-Seidel resolve sistemas grandes eficientemente em softwares como COMSOL ou FEniCS, verificando convergência rápida sem pré-condicionadores."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.2.1",
                              "10.1.6.4.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.5",
                    "name": "Comparação entre Métodos Jacobi e Gauss-Seidel",
                    "description": "Diferenças na taxa de convergência e vantagens de Gauss-Seidel sobre Jacobi em certos casos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.5.1",
                        "name": "Método de Jacobi",
                        "description": "Método iterativo clássico para resolução de sistemas lineares Ax = b, onde as iterações utilizam valores anteriores para todas as variáveis em cada passo.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.1.1",
                            "name": "Descrever o algoritmo do método de Jacobi",
                            "description": "Explicar passo a passo o processo iterativo do método de Jacobi, incluindo a decomposição da matriz A em D (diagonal) + L + U e a fórmula de iteração x^{(k+1)} = D^{-1}(b - (L+U)x^{(k)}).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Verificar pré-condições e preparar o sistema",
                                  "subSteps": [
                                    "Identificar o sistema linear Ax = b, onde A é uma matriz quadrada n x n.",
                                    "Verificar se A é diagonalmente dominante ou simétrica positiva definida para garantir convergência.",
                                    "Inicializar um vetor de aproximação inicial x^{(0)} (geralmente vetor nulo).",
                                    "Definir tolerância ε (ex: 10^{-6}) e número máximo de iterações K_max.",
                                    "Definir critério de parada: ||x^{(k+1)} - x^{(k)}|| < ε."
                                  ],
                                  "verification": "Liste as condições verificadas e mostre x^{(0)} e parâmetros definidos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matriz A e vetor b de exemplo",
                                    "Calculadora ou software como MATLAB/Python"
                                  ],
                                  "tips": "Sempre priorize sistemas diagonalmente dominantes para testes iniciais.",
                                  "learningObjective": "Compreender as condições necessárias para a aplicação do método de Jacobi.",
                                  "commonMistakes": [
                                    "Ignorar verificação de convergência",
                                    "Escolher x^{(0)} inadequado",
                                    "Não definir tolerância"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Decompor a matriz A em componentes D, L e U",
                                  "subSteps": [
                                    "Extrair a matriz diagonal D de A (elementos da diagonal principal).",
                                    "Formar L como a matriz triangular inferior estrita (abaixo da diagonal, com sinal negativo).",
                                    "Formar U como a matriz triangular superior estrita (acima da diagonal).",
                                    "Verificar que A = D + L + U.",
                                    "Confirmar que D é invertível (diagonal não nula)."
                                  ],
                                  "verification": "Escreva explicitamente D, L e U para uma matriz de exemplo e some para obter A.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis ou editor de equações (LaTeX/Word)",
                                    "Exemplo de matriz 3x3"
                                  ],
                                  "tips": "Use notação clara: D_{ii} = a_{ii}, L_{ij} = -a_{ij} para i>j.",
                                  "learningObjective": "Dominar a decomposição matricial específica do método de Jacobi.",
                                  "commonMistakes": [
                                    "Confundir sinais em L e U",
                                    "Incluir diagonal em L ou U",
                                    "Erros de transcrição de elementos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a equação de iteração",
                                  "subSteps": [
                                    "Partir de Ax = b e isolar Dx = b - (L + U)x.",
                                    "Derivar x^{(k+1)} = D^{-1} (b - (L + U) x^{(k)}).",
                                    "Computar D^{-1} como inversa diagonal (dividir cada componente por d_{ii}).",
                                    "Escrever a iteração componente a componente: x_i^{(k+1)} = (1/d_{ii}) [b_i - sum_{j≠i} a_{ij} x_j^{(k)} ].",
                                    "Preparar para implementação iterativa."
                                  ],
                                  "verification": "Derive a fórmula passo a passo e aplique a uma iteração manual.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de derivação",
                                    "Software simbólico como SymPy"
                                  ],
                                  "tips": "Lembre-se: Jacobi usa apenas valores da iteração anterior em todas as componentes.",
                                  "learningObjective": "Derivar e entender a fórmula iterativa do método.",
                                  "commonMistakes": [
                                    "Usar x^{(k+1)} no cálculo de outras componentes (isso é Gauss-Seidel)",
                                    "Esquecer o inverso de D",
                                    "Erros algébricos na derivação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Descrever o algoritmo completo e critérios de parada",
                                  "subSteps": [
                                    "Iniciar com k=0 e x^{(0)}.",
                                    "Loop: Calcular x^{(k+1)} usando a fórmula até ||x^{(k+1)} - x^{(k)}|| < ε ou k > K_max.",
                                    "Atualizar k = k+1 e repetir.",
                                    "Ao final, retornar x^{(k+1)} como solução aproximada.",
                                    "Opcional: Calcular resíduo ||Ax - b|| para validação."
                                  ],
                                  "verification": "Escreva pseudocódigo completo do algoritmo e simule 2 iterações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigo template",
                                    "Python ou pseudolinguagem"
                                  ],
                                  "tips": "Use norma infinito ou euclidiana para o critério de parada.",
                                  "learningObjective": "Articular o algoritmo iterativo de forma clara e programável.",
                                  "commonMistakes": [
                                    "Parada prematura sem critério",
                                    "Confundir com Gauss-Seidel no loop",
                                    "Não reportar número de iterações"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o sistema Ax = b com A = [[10, 2, 0], [-1, 8, -1], [0, 3, 10]] e b = [6, 25, -11]. x^{(0)} = [0,0,0]. Decomposição: D = diag(10,8,10), L = [[0,0,0],[-1,0,0],[0,0,0]], U=[[0,2,0],[0,0,-1],[0,3,0]]. Primeira iteração: x1 = [0.6, 3.125, -1.1]. Continue até convergência.",
                              "finalVerifications": [
                                "Decomposição correta de A em D + L + U.",
                                "Fórmula de iteração x^{(k+1)} = D^{-1}(b - (L+U)x^{(k)}) escrita precisamente.",
                                "Pseudocódigo do loop iterativo completo.",
                                "Exemplo numérico com pelo menos 2 iterações resolvidas manualmente.",
                                "Critérios de convergência e parada explicitados.",
                                "Comparação qualitativa com Gauss-Seidel (Jacobi é mais simples mas converge mais devagar)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na decomposição e fórmula (sem erros algébricos).",
                                "Clareza e estrutura na descrição passo a passo.",
                                "Uso correto de notação matemática (superscripts para iterações, ||.|| para normas).",
                                "Inclusão de verificações de pré-condições e convergência.",
                                "Capacidade de aplicar em exemplo concreto.",
                                "Diferenciação clara de Jacobi vs. outros métodos iterativos."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python com NumPy para automação de iterações.",
                                "Física: Resolução de equações de malha em simulações de calor ou eletricidade.",
                                "Engenharia: Análise de estruturas em engenharia civil (sistemas esparsos).",
                                "Computação Científica: Pré-condicionadores em métodos mais avançados como GMRES."
                              ],
                              "realWorldApplication": "O método de Jacobi é aplicado em softwares de simulação numérica para resolver grandes sistemas lineares esparsos, como em modelagem climática, processamento de imagens (filtro de suavização) e otimização financeira (equilíbrios de mercado)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.2",
                            "name": "Implementar o método de Jacobi computacionalmente",
                            "description": "Codificar em pseudocódigo ou linguagem de programação o método de Jacobi para um sistema Ax = b, incluindo critério de parada por norma do resíduo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar teoria e formular o método de Jacobi",
                                  "subSteps": [
                                    "Estude a formulação do método de Jacobi: para Ax = b, decomponha A = D + (L + U), onde D é diagonal.",
                                    "Derive a iteração: x^{(k+1)} = D^{-1} (b - (L + U) x^{(k)}).",
                                    "Defina o critério de parada: ||r^{(k)}|| = ||Ax^{(k)} - b|| < ε, onde ε é tolerância (ex: 1e-6).",
                                    "Escolha uma inicialização x^{(0)} (ex: vetor zero).",
                                    "Discuta condições de convergência (matriz estritamente diagonal dominante)."
                                  ],
                                  "verification": "Escreva pseudocódigo da iteração e critério de parada em um documento ou notebook.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Livro de Álgebra Linear Numérica (ex: Burden & Faires)",
                                    "Notebook Jupyter ou papel para anotações"
                                  ],
                                  "tips": "Use notação matricial clara para evitar confusão entre componentes.",
                                  "learningObjective": "Compreender matematicamente o método de Jacobi e seu critério de parada.",
                                  "commonMistakes": [
                                    "Confundir Jacobi com Gauss-Seidel (Jacobi usa x^{(k)} para todos os updates)",
                                    "Ignorar inverso de D (simples divisão diagonal)",
                                    "Escolher ε muito pequeno sem limite de iterações"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar ambiente de programação e dados de entrada",
                                  "subSteps": [
                                    "Instale bibliotecas: NumPy para arrays e operações matriciais.",
                                    "Defina função para ler ou criar matriz A (nxn), vetor b (nx1) e x0 inicial.",
                                    "Implemente verificação básica: dimensões compatíveis e A diagonal dominante.",
                                    "Crie exemplo teste: A = [[4, -1, 0], [-1, 4, -1], [0, -1, 4]], b = [1, 2, 3].",
                                    "Defina parâmetros: tol = 1e-6, max_iter = 1000."
                                  ],
                                  "verification": "Execute código para imprimir A, b, x0 e confirme shapes corretos sem erros.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Python 3+",
                                    "NumPy (pip install numpy)",
                                    "Jupyter Notebook ou IDE como VS Code"
                                  ],
                                  "tips": "Use np.array para eficiência; teste com matriz pequena primeiro.",
                                  "learningObjective": "Preparar dados numéricos estáveis para iteração.",
                                  "commonMistakes": [
                                    "Usar listas Python em vez de NumPy (lento e propenso a erros)",
                                    "Não checar se A é quadrada",
                                    "Inicializar x0 com valores ruins que divergem"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o loop iterativo principal do Jacobi",
                                  "subSteps": [
                                    "Extraia diagonal D de A usando np.diag(np.diag(A)).",
                                    "Compute R = A - D (parte off-diagonal).",
                                    "No loop: x_new = np.linalg.inv(D) @ (b - R @ x_old).",
                                    "Atualize x_old = x_new.",
                                    "Conte iterações e evite exceder max_iter."
                                  ],
                                  "verification": "Rode 10 iterações manualmente e imprima x em cada passo; confira convergência manual.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Código do Step 2",
                                    "Documentação NumPy para @ e linalg.inv"
                                  ],
                                  "tips": "Para eficiência, inv(D) uma vez fora do loop: D_inv = np.diag(1/np.diag(A)).",
                                  "learningObjective": "Codificar corretamente a atualização paralela do Jacobi.",
                                  "commonMistakes": [
                                    "Atualizar componentes sequencialmente (isso é Gauss-Seidel)",
                                    "Inverter toda A em vez de só D",
                                    "Esquecer reshape para vetores coluna"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar critério de parada por norma do resíduo",
                                  "subSteps": [
                                    "No loop, após update: res = np.linalg.norm(A @ x_new - b).",
                                    "Se res < tol, break.",
                                    "Adicione log: imprima iteração, ||x_new - x_old|| e res.",
                                    "Retorne x_final, iterações usadas e resíduo final.",
                                    "Trate caso de não convergência (raise warning)."
                                  ],
                                  "verification": "Teste com exemplo: solução exata x = [1, 1.5, 2]; confira res < tol em <50 iters.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Código anterior",
                                    "np.linalg.norm docs"
                                  ],
                                  "tips": "Use norma 2 (default) ou inf para resíduo; monitore ||delta_x|| também.",
                                  "learningObjective": "Implementar parada robusta baseada em erro verdadeiro.",
                                  "commonMistakes": [
                                    "Usar ||x_new - x_old|| como critério principal (pode estagnar)",
                                    "Calcular res com x_old em vez de x_new",
                                    "tol muito rígido sem max_iter"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, validar e analisar a implementação",
                                  "subSteps": [
                                    "Teste com múltiplos sistemas: convergente e divergente.",
                                    "Compare com solução exata (np.linalg.solve(A,b)).",
                                    "Plote erro vs iterações usando Matplotlib.",
                                    "Meça tempo de execução com %timeit.",
                                    "Documente função completa com docstring."
                                  ],
                                  "verification": "Erro relativo |x_num - x_exato| / |x_exato| < 1e-5; plots mostram convergência.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Matplotlib (pip install matplotlib)",
                                    "Sistemas teste variados"
                                  ],
                                  "tips": "Salve código em função jacobi(A, b, tol=1e-6, max_iter=1000).",
                                  "learningObjective": "Validar implementação e analisar performance.",
                                  "commonMistakes": [
                                    "Não testar divergência",
                                    "Ignorar conditioning de A",
                                    "Plots sem labels/legend"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva Ax = b com A = np.array([[10., -1., 0., 0.], [-1., 11., -1., 0.], [0., -1., 10., -1.], [0., 0., -1., 8.]]), b = [6., 25., -11., 15.]. Solução exata ≈ [1, 2, 3, 4]. Rode Jacobi: converge em ~20 iters com tol=1e-6.",
                              "finalVerifications": [
                                "Código roda sem erros para matrizes 3x3 a 100x100 diagonal dominante.",
                                "Resíduo final < tol para exemplos convergentes.",
                                "Detecta e avisa não-convergência em max_iter.",
                                "Solução coincide com np.linalg.solve dentro de 1e-5 relativo.",
                                "Tempo escalável: <1s para n=100.",
                                "Docstring e comentários explicam cada seção."
                              ],
                              "assessmentCriteria": [
                                "Correção da iteração Jacobi (20%)",
                                "Implementação precisa do resíduo e parada (25%)",
                                "Eficiência: inv(D) fora do loop, NumPy vetorial (20%)",
                                "Testes abrangentes e validação (20%)",
                                "Código limpo, comentado e modular (10%)",
                                "Análise de convergência via plots/logs (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de NumPy para computação científica.",
                                "Análise Numérica: Estudo de erros e estabilidade.",
                                "Física: Solução de EDP em malhas (ex: Poisson).",
                                "Engenharia: Modelagem de circuitos elétricos.",
                                "Data Science: Pré-processamento em ML iterativo."
                              ],
                              "realWorldApplication": "Em simulações de difusão térmica (equações de Poisson), otimização em finanças (sistemas lineares grandes), e processamento de imagens (filtro iterativo), onde métodos diretos como LU são caros para matrizes esparsas grandes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.3",
                            "name": "Identificar condições de convergência do Jacobi",
                            "description": "Determinar a condição espectral de convergência baseada no raio espectral da matriz de iteração G_J = -D^{-1}(L+U) < 1, e discutir matrizes estritamente diagonalmente dominantes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a decomposição matricial e o método de Jacobi",
                                  "subSteps": [
                                    "Lembre-se da decomposição de uma matriz A em A = D + L + U, onde D é diagonal, L é triangular inferior estrita e U é triangular superior estrita.",
                                    "Entenda o iterador do método de Jacobi: x^{(k+1)} = D^{-1} (b - (L + U) x^{(k)}).",
                                    "Identifique o papel de cada componente na iteração.",
                                    "Esboce um exemplo simples de sistema Ax = b para visualizar.",
                                    "Verifique a invertibilidade de D (diagonal não nula)."
                                  ],
                                  "verification": "Escreva a decomposição A = D + L + U para uma matriz 3x3 de exemplo e formule o iterador Jacobi.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Livro de Álgebra Linear Computacional (capítulo de métodos iterativos)",
                                    "Papel e lápis ou software como MATLAB/Octave para matrizes"
                                  ],
                                  "tips": "Sempre normalize as equações para destacar o termo diagonal dominante.",
                                  "learningObjective": "Compreender a base teórica da decomposição e iteração Jacobi.",
                                  "commonMistakes": [
                                    "Confundir L e U (L abaixo da diagonal, U acima)",
                                    "Esquecer que D é diagonal e invertível"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a matriz de iteração G_J",
                                  "subSteps": [
                                    "Reescreva o iterador como x^{(k+1)} = G_J x^{(k)} + D^{-1} b, identificando G_J = -D^{-1}(L + U).",
                                    "Compute D^{-1} explicitamente para uma matriz diagonal.",
                                    "Multiplique D^{-1} por -(L + U) passo a passo.",
                                    "Verifique com uma matriz 2x2: calcule G_J manualmente.",
                                    "Discuta propriedades de G_J (não simétrica em geral)."
                                  ],
                                  "verification": "Derive G_J para uma matriz A de exemplo e confirme que satisfaz a forma do iterador.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Calculadora matricial ou Python com NumPy",
                                    "Exemplos de matrizes de sistemas lineares"
                                  ],
                                  "tips": "Use notação fracionária para elementos de D^{-1} para clareza.",
                                  "learningObjective": "Dominar a construção explícita da matriz de iteração Jacobi.",
                                  "commonMistakes": [
                                    "Sinal errado em G_J (deve ser negativo)",
                                    "Erro na multiplicação matricial D^{-1}(L+U)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a condição espectral de convergência",
                                  "subSteps": [
                                    "Defina o raio espectral ρ(G) como o máximo módulo dos autovalores de G.",
                                    "Estabeleça o teorema: o método converge se e somente se ρ(G_J) < 1.",
                                    "Compute autovalores de G_J para matrizes pequenas usando fórmula quadrática ou software.",
                                    "Interprete: se ρ(G_J) ≥ 1, a iteração diverge.",
                                    "Compare com norma: ||G_J|| < 1 implica convergência, mas é suficiente não necessária.",
                                    "Grafique a convergência para diferentes ρ."
                                  ],
                                  "verification": "Para uma G_J de exemplo, calcule ρ(G_J) e prediga convergência (ρ < 1).",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Software como MATLAB (eig função)",
                                    "Tabela de autovalores para prática"
                                  ],
                                  "tips": "Use potência método para estimar ρ se dimensão alta.",
                                  "learningObjective": "Aplicar critério espectral para prever convergência.",
                                  "commonMistakes": [
                                    "Confundir raio espectral com autovalor dominante real",
                                    "Ignorar autovalores complexos (módulo importa)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar matrizes estritamente diagonalmente dominantes",
                                  "subSteps": [
                                    "Defina dominância diagonal estrita: |a_ii| > sum_{j≠i} |a_ij| para todo i.",
                                    "Prove que para matrizes estritamente diagonalmente dominantes, ρ(G_J) < 1.",
                                    "Forneça contraexemplo onde não dominante mas converge.",
                                    "Teste em exemplos: crie matriz dominante e não dominante.",
                                    "Discuta implicações para escolha de pivot em pré-condicionamento.",
                                    "Conecte com teorema de Gershgorin para bound de autovalores."
                                  ],
                                  "verification": "Verifique dominância em uma matriz, compute ρ(G_J) e confirme teorema.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Exemplos de matrizes de Poisson ou tridiagonais",
                                    "Teorema de Gershgorin handout"
                                  ],
                                  "tips": "Some colunas de off-diagonais para checar dominância rapidamente.",
                                  "learningObjective": "Reconhecer e provar critérios práticos de convergência via dominância.",
                                  "commonMistakes": [
                                    "Usar dominância fraca (≥) que não garante ρ<1",
                                    "Confundir linha vs. coluna dominância"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o sistema Ax = b com A = [[4, -1, 0], [-1, 4, -1], [0, -1, 4]], b = [1, 2, 3]. Decomponha A = D + L + U, compute G_J = -D^{-1}(L+U) = [[0, 0.25, 0], [0.25, 0, 0.25], [0, 0.25, 0]]. Autovalores de G_J: approx. 0.5, -0.5, 0; ρ=0.5 <1, converge. A é diagonalmente dominante.",
                              "finalVerifications": [
                                "Deriva corretamente G_J para qualquer A.",
                                "Calcula ρ(G_J) e interpreta convergência.",
                                "Identifica matrizes diagonalmente dominantes.",
                                "Prova ou explica por que dominância implica ρ<1.",
                                "Aplica a um exemplo numérico completo.",
                                "Discute limitações (ex: não dominante mas converge)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de G_J (100% correto).",
                                "Cálculo exato de raio espectral (erro <1%).",
                                "Explicação clara do teorema espectral.",
                                "Verificação correta de dominância diagonal.",
                                "Uso de exemplos relevantes sem erros.",
                                "Conexão lógica entre teoria e prática."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar Jacobi em Python/NumPy e testar convergência.",
                                "Física: Sistemas lineares em malhas finitas para equações de Poisson.",
                                "Engenharia: Resolução de circuitos elétricos lineares.",
                                "Estatística: Iterações em modelos de regressão regularizada."
                              ],
                              "realWorldApplication": "Em simulações numéricas de engenharia (ex: fluxo de calor em malhas), o método Jacobi é usado para resolver grandes sistemas esparsos; verificar ρ(G_J)<1 garante eficiência computacional em supercomputadores para previsão climática ou design estrutural."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.2",
                        "name": "Método de Gauss-Seidel",
                        "description": "Método iterativo que utiliza os valores mais recentes das variáveis à medida que são computados, acelerando a convergência em comparação ao Jacobi.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.2.1",
                            "name": "Descrever o algoritmo do método de Gauss-Seidel",
                            "description": "Explicar o processo iterativo onde x^{(k+1)}_i depende de x^{(k+1)}_1 até x^{(k+1)}_{i-1} e x^{(k)}_i até x^{(k)}_n, com matriz de iteração G_{GS} = -(D+L)^{-1}U.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a decomposição da matriz A e pré-requisitos",
                                  "subSteps": [
                                    "Identifique o sistema linear Ax = b, onde A é n x n diagonal-dominante.",
                                    "Decompose A em D (diagonal), L (triangular inferior estrita) e U (triangular superior estrita).",
                                    "Verifique se A é diagonalmente dominante para garantir convergência potencial.",
                                    "Escreva as equações: (D + L) x^{(k+1)} = b - U x^{(k)}.",
                                    "Entenda que isso leva à matriz de iteração G_{GS} = -(D + L)^{-1} U."
                                  ],
                                  "verification": "Decomponha corretamente uma matriz exemplo em D, L, U e escreva a forma matricial do método.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Exemplo de matriz 3x3 diagonal-dominante",
                                    "Calculadora para verificação"
                                  ],
                                  "tips": "Sempre verifique diagonal-dominância: |a_{ii}| >= sum_{j≠i} |a_{ij}| para todos i.",
                                  "learningObjective": "Ao final deste passo, você será capaz de decompor A e formular a equação matricial do Gauss-Seidel.",
                                  "commonMistakes": [
                                    "Confundir L (inferior) com U (superior)",
                                    "Esquecer que L é estrita (sem diagonal)",
                                    "Não verificar diagonal-dominância"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar parâmetros e vetor inicial",
                                  "subSteps": [
                                    "Escolha um vetor inicial x^{(0)}, tipicamente o vetor zero.",
                                    "Defina tolerância ε (ex: 10^{-6}) e número máximo de iterações K_max (ex: 1000).",
                                    "Calcule o resíduo inicial r^{(0)} = b - A x^{(0)}.",
                                    "Registre k = 0.",
                                    "Prepare estrutura para armazenar iterações (opcional para tracking)."
                                  ],
                                  "verification": "Escreva x^{(0)}, ε e K_max para um sistema dado e calcule r^{(0)} corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Sistema linear exemplo",
                                    "Planilha ou software para tracking (opcional)"
                                  ],
                                  "tips": "Use x^{(0)} = 0 para simplicidade em testes iniciais.",
                                  "learningObjective": "Ao final, você saberá configurar todos os parâmetros iniciais necessários para o algoritmo.",
                                  "commonMistakes": [
                                    "Escolher x^{(0)} ruim sem justificativa",
                                    "Definir ε muito grande ou pequeno",
                                    "Esquecer de computar resíduo inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever o loop iterativo componente por componente",
                                  "subSteps": [
                                    "Para k = 0, 1, 2, ..., enquanto ||r^{(k)}|| > ε e k < K_max:",
                                    "Para i = 1 até n: x_i^{(k+1)} = [b_i - sum_{j=1}^{i-1} a_{ij} x_j^{(k+1)} - sum_{j=i+1}^n a_{ij} x_j^{(k)} ] / a_{ii}.",
                                    "Atualize valores imediatamente (forward substitution implícita).",
                                    "Compute r^{(k+1)} = b - A x^{(k+1)} após o loop interno.",
                                    "Increment k = k + 1."
                                  ],
                                  "verification": "Aplique o loop manualmente para as primeiras 2 iterações de um sistema 3x3 e verifique x^{(1)} e x^{(2)}.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Matriz A, b exemplo",
                                    "Tabela para rastrear iterações"
                                  ],
                                  "tips": "Atualize x_i assim que calculado; isso diferencia do Jacobi.",
                                  "learningObjective": "Você será capaz de descrever e simular o processo iterativo sequencial do Gauss-Seidel.",
                                  "commonMistakes": [
                                    "Usar x^{(k)} para todos os termos (erro Jacobi)",
                                    "Índices errados nos somatórios",
                                    "Não atualizar imediatamente os valores anteriores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir critérios de parada e análise final",
                                  "subSteps": [
                                    "Pare quando ||x^{(k+1)} - x^{(k)}|| < ε ou ||r^{(k+1)}|| < ε.",
                                    "Ou quando k >= K_max.",
                                    "Retorne x^{(k+1)} como aproximação da solução.",
                                    "Opcionalmente, compute erro relativo ||x^{(k+1)} - x|| / ||x|| se x exato conhecido.",
                                    "Discuta G_{GS} = -(D+L)^{-1} U e raio espectral ρ(G_{GS}) < 1 para convergência."
                                  ],
                                  "verification": "Escreva pseudocódigo completo do algoritmo incluindo parada e verifique com exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pseudocódigo template",
                                    "Exemplo resolvido numericamente"
                                  ],
                                  "tips": "Use norma infinito ou 2 para resíduos; infinito é comum em prática.",
                                  "learningObjective": "Ao final, você entenderá como finalizar o algoritmo e analisar convergência.",
                                  "commonMistakes": [
                                    "Parada prematura sem verificar múltiplas normas",
                                    "Confundir G_{GS} com G_J",
                                    "Ignorar máximo de iterações"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o sistema: 10x + y - z = 10, x + 12y + 2z = 22, 2x + 3y + 20z = 35. Inicialize x^{(0)} = [0,0,0]^T, ε=10^{-4}. Na 1ª iteração: x1=1, x2≈1.75, x3≈1.7. Continue até convergência, mostrando dependência imediata nos updates.",
                              "finalVerifications": [
                                "Escreva pseudocódigo completo do Gauss-Seidel.",
                                "Explique a diferença na atualização vs. Jacobi.",
                                "Decomponha A em D,L,U para um exemplo 3x3.",
                                "Simule 2 iterações manualmente.",
                                "Defina corretamente G_{GS} e condição de convergência.",
                                "Identifique quando o método converge mais rápido que Jacobi."
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula componente-wise com dependências corretas.",
                                "Correta descrição da inicialização e parâmetros.",
                                "Inclusão de critérios de parada múltiplos.",
                                "Explicação clara da matriz de iteração G_{GS}.",
                                "Uso apropriado de normas para resíduos.",
                                "Identificação de pré-condições como diagonal-dominância."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python com NumPy para automação.",
                                "Física: Resolver equações de equilíbrio em redes elétricas ou mecânicas.",
                                "Engenharia: Simulações em CFD (dinâmica de fluidos computacional).",
                                "Ciência de Dados: Otimização iterativa em machine learning.",
                                "Estatística: Resolução de mínimos quadrados lineares aproximados."
                              ],
                              "realWorldApplication": "O método Gauss-Seidel é amplamente usado em engenharia para resolver grandes sistemas lineares esparsos em simulações de fluxo de fluidos, análise de tensões em estruturas civis, processamento de imagens (filtro gaussiano iterativo) e modelagem climática, onde eficiência computacional é crítica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.2",
                            "name": "Implementar o método de Gauss-Seidel computacionalmente",
                            "description": "Codificar o método de Gauss-Seidel, destacando a atualização sequencial das componentes do vetor solução e comparação com Jacobi no mesmo código.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de programação e definir o sistema linear de teste",
                                  "subSteps": [
                                    "Instale as bibliotecas necessárias: NumPy para manipulação de matrizes e vetores.",
                                    "Defina a matriz A diagonal dominante, por exemplo: A = np.array([[4,1,1],[1,4,1],[1,1,4]]).",
                                    "Defina o vetor b correspondente: b = np.array([7,7,7]).",
                                    "Inicialize o vetor solução inicial x0 = np.zeros(3).",
                                    "Defina parâmetros comuns: tolerância tol=1e-6 e máximo de iterações max_iter=100."
                                  ],
                                  "verification": "Execute o código de setup e confirme que A, b e x0 são impressos corretamente sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "NumPy",
                                    "Jupyter Notebook ou IDE como VS Code"
                                  ],
                                  "tips": "Use um sistema diagonal dominante para garantir convergência rápida e facilitar testes.",
                                  "learningObjective": "Preparar dados de entrada padronizados para métodos iterativos.",
                                  "commonMistakes": [
                                    "Esquecer de importar numpy as np.",
                                    "Definir A não diagonal dominante, causando divergência.",
                                    "Usar listas Python em vez de arrays NumPy."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o método Jacobi para comparação",
                                  "subSteps": [
                                    "Crie uma função def jacobi(A, b, x0, tol, max_iter): que retorna x_final, num_iter.",
                                    "Calcule a matriz de iteração: D = np.diag(np.diag(A)), R = A - D.",
                                    "No loop while: compute res = b - np.dot(A, x), if np.linalg.norm(res) < tol: break.",
                                    "Atualize x_new = np.linalg.solve(D, res).",
                                    "Atualize x = x_new e incremente contador de iterações."
                                  ],
                                  "verification": "Teste a função com os dados do Step 1 e verifique se converge em poucas iterações (ex: <20) com x próximo de [1,1,1].",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "NumPy (np.linalg)",
                                    "Código do Step 1"
                                  ],
                                  "tips": "Imprima o erro residual a cada iteração para monitorar convergência.",
                                  "learningObjective": "Codificar Jacobi com atualização simultânea de todas as componentes.",
                                  "commonMistakes": [
                                    "Atualizar x in-place em vez de criar x_new.",
                                    "Não usar np.linalg.norm para erro.",
                                    "Exceder max_iter sem break."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o método Gauss-Seidel destacando atualização sequencial",
                                  "subSteps": [
                                    "Crie def gauss_seidel(A, b, x0, tol, max_iter): similar à Jacobi.",
                                    "No loop: para cada i in range(len(b)): x[i] = (b[i] - sum(A[i,j]*x[j] for j!=i)) / A[i,i].",
                                    "Use valores atualizados de x[0] a x[i-1] e antigos x[i+1] a x[n-1].",
                                    "Após cada iteração completa, compute res = np.linalg.norm(b - np.dot(A, x)).",
                                    "Break se res < tol ou max_iter atingido."
                                  ],
                                  "verification": "Execute e confirme que usa valores mais recentes sequencialmente (imprima x após cada componente).",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "NumPy",
                                    "Código dos Steps 1-2"
                                  ],
                                  "tips": "Implemente o update em um loop for explícito para visualizar a sequência.",
                                  "learningObjective": "Destacar diferença chave: atualização sequencial vs. simultânea.",
                                  "commonMistakes": [
                                    "Usar cópia de x em vez de update in-place.",
                                    "Calcular soma errada (incluir j==i).",
                                    "Não verificar diagonal não-zero."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar, comparar e analisar resultados",
                                  "subSteps": [
                                    "Chame jacobi(A, b, x0, tol, max_iter) e capture iters_j, x_j, erro_j.",
                                    "Chame gauss_seidel(A, b, x0, tol, max_iter) e capture iters_gs, x_gs, erro_gs.",
                                    "Imprima comparação: iterações, erro final, norma ||x_gs - x_j||.",
                                    "Plote (opcional com matplotlib) erro vs. iteração para ambos.",
                                    "Comente no código as vantagens observadas do Gauss-Seidel."
                                  ],
                                  "verification": "Confirme que Gauss-Seidel converge em menos iterações (ex: metade de Jacobi).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "NumPy",
                                    "Matplotlib (opcional)",
                                    "Código completo"
                                  ],
                                  "tips": "Salve histórico de erros em listas para plotar.",
                                  "learningObjective": "Comparar empiricamente eficiência e precisão.",
                                  "commonMistakes": [
                                    "Mesma semente x0 não usada.",
                                    "Ignorar print de resultados para debug.",
                                    "Concluir sem quantificar diferenças."
                                  ]
                                }
                              ],
                              "practicalExample": "Para o sistema A x = b com A = [[4,1,1],[1,4,1],[1,1,4]], b=[7,7,7], x0=[0,0,0]: Jacobi converge em ~15 iterações, Gauss-Seidel em ~9, com x_final ≈ [1,1,1] para ambos, mas GS mais rápido devido a updates sequenciais.",
                              "finalVerifications": [
                                "Código executa sem erros e converge para ambos métodos.",
                                "Gauss-Seidel usa valores atualizados sequencialmente (visível em prints intermediários).",
                                "Número de iterações de GS é menor que Jacobi no mesmo sistema.",
                                "Erro residual final < tol para ambos.",
                                "Solução final próxima da exata (np.linalg.solve(A,b)).",
                                "Comentários no código explicam diferenças chave."
                              ],
                              "assessmentCriteria": [
                                "Correção da implementação: updates sequenciais em GS vs. simultâneos em Jacobi (50%).",
                                "Eficiência: convergência demonstrada e quantificada (20%).",
                                "Clareza: código comentado, prints de debug e análise (15%).",
                                "Robustez: tratamento de tol, max_iter e diagonal dominante (10%).",
                                "Comparação visual (plot) opcional mas bonus (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Estruturas de loops, funções e vetores NumPy.",
                                "Física: Solução de equações em circuitos elétricos e redes.",
                                "Engenharia: Pré-condicionadores em solvers de elementos finitos.",
                                "Ciência de Dados: Otimização iterativa em machine learning."
                              ],
                              "realWorldApplication": "Implementado em solvers numéricos como SciPy para simulações em engenharia (análise estrutural, dinâmica de fluidos) e modelagem financeira (equilíbrios de mercado), onde sistemas grandes demandam métodos iterativos eficientes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.3",
                            "name": "Analisar condições de convergência do Gauss-Seidel",
                            "description": "Discutir que converge para as mesmas matrizes que Jacobi, mas com raio espectral geralmente menor, citando teoremas de convergência para matrizes simétricas positivas definidas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar condições de convergência do método de Jacobi",
                                  "subSteps": [
                                    "Lembre-se da decomposição A = D - L - U para matrizes com diagonal dominante.",
                                    "Calcule a matriz de iteração de Jacobi G_J = D^{-1}(L + U).",
                                    "Discuta a condição ||G_J|| < 1 para convergência, preferencialmente usando norma espectral ρ(G_J) < 1.",
                                    "Identifique classes de matrizes que satisfazem isso, como estritamente diagonalmente dominantes.",
                                    "Pratique com um exemplo 2x2 para visualizar."
                                  ],
                                  "verification": "Construa G_J para uma matriz dada e compute seu raio espectral; confirme ρ < 1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear Numérica (ex: Golub-Van Loan)",
                                    "Python com NumPy e SciPy para autovalores"
                                  ],
                                  "tips": "Sempre normalize a matriz para verificar dominância diagonal antes.",
                                  "learningObjective": "Compreender a base para comparação com Gauss-Seidel.",
                                  "commonMistakes": [
                                    "Confundir normas (use sempre ρ para precisão)",
                                    "Esquecer de inverter D corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a matriz de iteração do Gauss-Seidel",
                                  "subSteps": [
                                    "Decomponha A = (D - L) - U, onde D - L é triangular inferior.",
                                    "Defina a matriz de iteração G_GS = (D - L)^{-1} U.",
                                    "Explique a diferença na atualização: usa valores mais recentes em GS vs. antigos em Jacobi.",
                                    "Compute G_GS manualmente para uma matriz 3x3 simples.",
                                    "Verifique que G_GS^2 = G_J para matrizes simétricas."
                                  ],
                                  "verification": "Derive G_GS para uma matriz exemplo e confirme a relação quadrática com G_J.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel e lápis para derivação",
                                    "MATLAB ou Octave para inversão matricial"
                                  ],
                                  "tips": "Resolva sistemas triangulares sequencialmente para entender (D-L)^{-1}.",
                                  "learningObjective": "Dominar a formulação matemática específica do GS.",
                                  "commonMistakes": [
                                    "Ignorar a triangularidade ao inverter D-L",
                                    "Confundir L e U na decomposição"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar e comparar condições de convergência",
                                  "subSteps": [
                                    "Estabeleça que GS converge iff Jacobi converge (mesmo conjunto de matrizes).",
                                    "Mostre que ρ(G_GS) ≤ ρ(G_J), com igualdade só em casos triviais.",
                                    "Discuta aceleração: GS tipicamente requer menos iterações devido a raio menor.",
                                    "Calcule ρ para exemplos onde Jacobi converge lentamente mas GS rápido.",
                                    "Explore propriedades: se Jacobi converge, GS também, mas vice-versa não."
                                  ],
                                  "verification": "Para uma matriz diagonal dominante, compute ambos raios e compare numericamente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Software numérico (Python/NumPy para eigvals)",
                                    "Exemplos de matrizes de benchmark"
                                  ],
                                  "tips": "Use power iteration para estimar ρ se autovalores exatos difíceis.",
                                  "learningObjective": "Comparar quantitativamente os métodos.",
                                  "commonMistakes": [
                                    "Assumir GS sempre converge mais rápido sem prova",
                                    "Esquecer casos onde ρ(G_GS) = ρ(G_J)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Citar teoremas para matrizes simétricas positivas definidas (SPD)",
                                  "subSteps": [
                                    "Enuncie teorema: Para A SPD, ambos métodos convergem monotonicamente.",
                                    "Prove que para SPD, ρ(G_GS) < ρ(G_J) < 1.",
                                    "Discuta Young’s theorem ou Ostrowski-Reich para aceleração em SPD.",
                                    "Aplique a uma matriz SPD exemplo (ex: laplaciano discreto).",
                                    "Conclua implicações para aplicações reais."
                                  ],
                                  "verification": "Verifique convergência monotônica em iterações para matriz SPD.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Referência: 'Matrix Computations' de Golub",
                                    "Choleski para confirmar SPD"
                                  ],
                                  "tips": "Teste SPD com autovalores todos positivos.",
                                  "learningObjective": "Aplicar teoremas avançados a casos especiais.",
                                  "commonMistakes": [
                                    "Confundir SPD com simétrica indefinida",
                                    "Omitir monotonicidade na prova"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar com exemplo prático e síntese",
                                  "subSteps": [
                                    "Escolha sistema Ax=b com A diagonal dominante e SPD.",
                                    "Implemente ambos métodos e conte iterações até erro < 10^{-6}.",
                                    "Compare raios e plote resíduo vs. iterações.",
                                    "Discuta quando usar GS sobre Jacobi.",
                                    "Sintetize: GS para mesmas matrizes, mas mais eficiente."
                                  ],
                                  "verification": "Relatório com tabelas de iterações e ρ calculados.",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "Python script com NumPy/SciPy",
                                    "Gráficos com Matplotlib"
                                  ],
                                  "tips": "Use tolerância relativa no resíduo ||Ax^k - b|| / ||b||.",
                                  "learningObjective": "Integrar teoria com prática computacional.",
                                  "commonMistakes": [
                                    "Inicializar x^0 = 0 sem justificação",
                                    "Parar iterações prematuramente"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[4, -1, 0], [-1, 4, -1], [0, -1, 4]] (SPD, laplaciano), b = [1,2,1]. Compute G_J e G_GS, ρ(G_J)≈0.25, ρ(G_GS)≈0.0625. GS converge em ~20 iterações vs. ~80 para Jacobi.",
                              "finalVerifications": [
                                "Explicar verbalmente por que GS tem ρ menor.",
                                "Citar teorema de convergência para SPD.",
                                "Implementar GS em código e rodar exemplo.",
                                "Comparar ρ para matriz não simétrica.",
                                "Identificar matriz onde ambos falham."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de G_GS (100%)",
                                "Correta comparação de raios espectrais",
                                "Uso correto de teoremas para SPD",
                                "Análise numérica com exemplos concretos",
                                "Clareza na discussão de limitações",
                                "Profundidade nas verificações finais"
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em Python/MATLAB.",
                                "Física Computacional: Solvers para EDOs/PDEs em simulações.",
                                "Engenharia: Análise estrutural com sistemas lineares grandes.",
                                "Estatística: Regressão linear iterativa em big data."
                              ],
                              "realWorldApplication": "Em simulações de fluxo de fluidos (CFD), GS resolve sistemas esparsos de Poisson mais eficientemente que Jacobi, reduzindo tempo computacional em grids finitos para previsão meteorológica ou design aerodinâmico."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.3",
                        "name": "Comparação entre Jacobi e Gauss-Seidel",
                        "description": "Análise das diferenças na taxa de convergência e vantagens do Gauss-Seidel, como convergência mais rápida sem custo adicional de armazenamento.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.3.1",
                            "name": "Comparar taxas de convergência",
                            "description": "Explicar que ||G_{GS}|| < ||G_J|| em norma espectral para muitos casos, levando a menos iterações, com exemplos numéricos ilustrativos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as matrizes de iteração para Jacobi e Gauss-Seidel",
                                  "subSteps": [
                                    "Lembre-se da decomposição A = D - L - U para matrizes com diagonal dominante.",
                                    "Defina G_J = D^{-1}(L + U) para o método de Jacobi.",
                                    "Defina G_GS = (D - L)^{-1} U para Gauss-Seidel.",
                                    "Escreva as condições de convergência: ρ(G) < 1 para ambos.",
                                    "Discuta propriedades: GS usa informações atualizadas, potencialmente mais rápido."
                                  ],
                                  "verification": "Escreva explicitamente G_J e G_GS para um sistema Ax = b genérico e verifique ρ(G) < 1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel",
                                    "Livro de Álgebra Linear Numérica",
                                    "Calculadora"
                                  ],
                                  "tips": "Comece com matrizes simétricas positivas definidas para simplicidade.",
                                  "learningObjective": "Compreender a estrutura das matrizes de iteração e sua relação com a matriz A.",
                                  "commonMistakes": [
                                    "Confundir L e U (L é estritamente triangular inferior)",
                                    "Esquecer o sinal negativo na decomposição A = D - L - U"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a norma espectral e seu impacto na convergência",
                                  "subSteps": [
                                    "Defina a norma espectral ρ(G) como o maior valor absoluto dos autovalores de G.",
                                    "Explique que a taxa de convergência é dada por |e_{k+1}| ≈ ρ(G) |e_k|, onde e é o erro.",
                                    "Compare: menor ρ implica menos iterações para precisão ε.",
                                    "Discuta que para matrizes irreduzíveis com diagonal dominante, ρ(G_GS) ≤ ρ(G_J).",
                                    "Prove ou lembre que ||G_GS|| ≤ ||G_J|| em norma espectral para certos casos."
                                  ],
                                  "verification": "Calcule os autovalores de uma matriz G simples e identifique ρ(G).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software Python com NumPy e SciPy",
                                    "Matriz de exemplo 2x2"
                                  ],
                                  "tips": "Use eigvals no NumPy para visualizar autovalores.",
                                  "learningObjective": "Dominar o papel da norma espectral na velocidade de convergência iterativa.",
                                  "commonMistakes": [
                                    "Confundir norma espectral com norma 2 euclidiana",
                                    "Ignorar que ρ é o raio espectral, não norma de Frobenius"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e comparar numericamente as normas para um exemplo",
                                  "subSteps": [
                                    "Escolha um sistema 3x3 diagonal dominante, ex: A = [[4,-1,0],[-1,4,-1],[0,-1,4]], b=[1,2,3].",
                                    "Calcule D, L, U e forme G_J e G_GS.",
                                    "Compute autovalores e ρ(G_J), ρ(G_GS) usando software.",
                                    "Compare valores: verifique ρ(G_GS) < ρ(G_J).",
                                    "Estime número de iterações: n ≈ log(ε)/log(ρ)."
                                  ],
                                  "verification": "Mostre que ρ(G_GS) < ρ(G_J) e calcule n_J > n_GS para ε=10^{-6}.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python/Jupyter Notebook",
                                    "Bibliotecas NumPy, SciPy"
                                  ],
                                  "tips": "Use np.linalg.eigvals para rapidez; plote autovalores no plano complexo.",
                                  "learningObjective": "Aplicar cálculo de normas espectrais em exemplos concretos.",
                                  "commonMistakes": [
                                    "Erro na inversão de (D-L) para GS",
                                    "Sistema não diagonal dominante levando a divergência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar iterações e validar a comparação experimentalmente",
                                  "subSteps": [
                                    "Implemente códigos iterativos para Jacobi e Gauss-Seidel no mesmo sistema.",
                                    "Execute até ||x_{k+1} - x_k|| < 10^{-6} e conte iterações.",
                                    "Registre resíduos e plote convergência (log do erro vs. iterações).",
                                    "Compare: GS requer menos iterações.",
                                    "Teste em outro sistema para generalizar."
                                  ],
                                  "verification": "Gere gráfico mostrando curvas de erro com GS mais íngreme (convergência mais rápida).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Jupyter Notebook",
                                    "Matplotlib para plots"
                                  ],
                                  "tips": "Use tolerância relativa no resíduo para precisão.",
                                  "learningObjective": "Validar teoricamente a superioridade de GS via simulação numérica.",
                                  "commonMistakes": [
                                    "Inicializar x0=0 sem verificar solução exata",
                                    "Parar iterações prematuramente sem critério claro"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Generalizar e discutir casos excepcionais",
                                  "subSteps": [
                                    "Discuta teorema: para A simétrica positiva definida, ρ(G_GS) = [ρ(G_J)]^2 < ρ(G_J).",
                                    "Mencione casos onde Jacobi é melhor (raro, ex: matrizes com autovalores específicos).",
                                    "Explore impacto em sistemas maiores (n=100).",
                                    "Conclua: GS geralmente 2x mais rápido.",
                                    "Registre limitações: paralelização favorece Jacobi."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que ||G_GS|| < ||G_J|| em norma espectral.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula",
                                    "Referências bibliográficas"
                                  ],
                                  "tips": "Leia Young (1954) para provas clássicas.",
                                  "learningObjective": "Generalizar a comparação para cenários reais e exceções.",
                                  "commonMistakes": [
                                    "Generalizar sem mencionar condições (diagonal dominante)",
                                    "Ignorar custo computacional por iteração (GS sequencial)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[10, -1, 0], [-1, 10, -1], [0, -1, 10]], b = [9, 8, 9]^T. ρ(G_J) ≈ 0.316, ρ(G_GS) ≈ 0.1. Jacobi: ~25 iterações; GS: ~13 para ε=1e-6. Plote erros mostrando GS convergindo duas vezes mais rápido.",
                              "finalVerifications": [
                                "Calcular corretamente G_J e G_GS para sistema dado.",
                                "Identificar ρ(G) via autovalores e comparar.",
                                "Executar simulação numérica confirmando menos iterações em GS.",
                                "Explicar teoricamente por que ρ(G_GS) < ρ(G_J).",
                                "Discutir aplicação em sistema maior.",
                                "Listar 2 exceções onde Jacobi pode ser preferível."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de matrizes de iteração (100% correto).",
                                "Correta identificação de normas espectrais e comparação quantitativa.",
                                "Qualidade do código/simulação: convergência plotada e iterações contadas.",
                                "Profundidade teórica: citação de teoremas ou provas simples.",
                                "Generalização: discussão de casos reais e limitações.",
                                "Clareza na comunicação: gráficos legíveis e explicações concisas."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Implementação em Python/NumPy.",
                                "Análise Numérica: Teoria de erros e estabilidade.",
                                "Física Computacional: Solução de EDP em malhas finitas.",
                                "Engenharia: Simulações de estruturas e fluidos."
                              ],
                              "realWorldApplication": "Na resolução numérica de equações de Poisson em simulações de fluxo de calor ou eletromagnetismo, onde GS reduz tempo computacional em 50% para malhas 2D/3D, acelerando iterações em supercomputadores."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.3.2",
                            "name": "Identificar vantagens do Gauss-Seidel sobre Jacobi",
                            "description": "Destacar que Gauss-Seidel converge duas vezes mais rápido asymptoticamente para matrizes simétricas positivas definidas, sem necessidade de vetor auxiliar extra.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições e Implementações dos Métodos Jacobi e Gauss-Seidel",
                                  "subSteps": [
                                    "Decompor a matriz A em A = D + L + U, onde D é diagonal, L estrita inferior e U estrita superior.",
                                    "Escrever a fórmula iterativa do método de Jacobi: x^{(k+1)} = D^{-1} (b - (L + U) x^{(k)}).",
                                    "Escrever a fórmula iterativa do método de Gauss-Seidel: x^{(k+1)} = (D + L)^{-1} (b - U x^{(k)}), usando atualizações imediatas.",
                                    "Implementar pseudocódigo simples para ambos, destacando uso de vetor auxiliar no Jacobi.",
                                    "Testar com uma matriz 2x2 simétrica positiva definida (SPD) manualmente por 2 iterações."
                                  ],
                                  "verification": "Capacidade de derivar e escrever corretamente as fórmulas iterativas e pseudocódigos sem consulta.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha com matriz exemplo SPD 3x3",
                                    "Calculadora ou software como MATLAB/Octave",
                                    "Notas sobre decomposição A=D+L+U"
                                  ],
                                  "tips": "Visualize as atualizações: Jacobi usa x velho em todos, Gauss-Seidel usa novos valores assim que computados para acelerar.",
                                  "learningObjective": "Compreender as diferenças fundamentais nas fórmulas e na atualização de variáveis.",
                                  "commonMistakes": [
                                    "Confundir L e U na decomposição",
                                    "Esquecer que Gauss-Seidel resolve (D+L) a cada iteração",
                                    "Não notar vetor auxiliar extra no Jacobi"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Condições de Convergência Comum",
                                  "subSteps": [
                                    "Recordar critério de convergência: ρ(M) < 1, onde M é a matriz de iteração (M_J = -D^{-1}(L+U) para Jacobi).",
                                    "Verificar que ambos convergem para matrizes estritamente diagonalmente dominantes ou SPD irreduzíveis.",
                                    "Discutir que para SPD, ambos convergem monotonicamente.",
                                    "Calcular ρ(M) para uma matriz exemplo diagonal dominante.",
                                    "Comparar graficamente os espectros das matrizes de iteração."
                                  ],
                                  "verification": "Computar ρ(M_J) e ρ(M_GS) para matriz exemplo e confirmar ρ < 1 para ambos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Matriz exemplo SPD 4x4",
                                    "Software para autovalores (Python NumPy ou MATLAB)",
                                    "Gráficos de convergência pré-computados"
                                  ],
                                  "tips": "Use norma espectral ρ = max |λ|; foque em propriedades de SPD para garantir convergência.",
                                  "learningObjective": "Identificar condições compartilhadas de convergência e preparar para comparação de taxas.",
                                  "commonMistakes": [
                                    "Confundir ρ com norma de Frobenius",
                                    "Ignorar irreduzibilidade para SPD",
                                    "Assumir convergência sem verificar diagonal dominância"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Taxas de Convergência Assintóticas",
                                  "subSteps": [
                                    "Estudar taxa de convergência assintótica: erro ~ ρ^k.",
                                    "Aprender teorema chave: para A SPD consistente, ρ(M_GS) = [ρ(M_J)]^2, implicando convergência ~2x mais rápida para GS.",
                                    "Derivar ou memorizar prova qualitativa: GS usa informações mais atualizadas.",
                                    "Plotar curvas de erro ||e^k|| vs k para ambos métodos em exemplo numérico.",
                                    "Quantificar: número de iterações GS ≈ log(ε)/log(ρ_J^2) = (1/2) log(ε)/log(ρ_J)."
                                  ],
                                  "verification": "Explicar verbalmente por que GS converge duas vezes mais rápido e citar o teorema para SPD.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Artigo ou livro sobre métodos iterativos (ex: Saad 'Iterative Methods')",
                                    "Código Python para plotar erros",
                                    "Matriz SPD grande (10x10)"
                                  ],
                                  "tips": "Lembre: para ρ_J próximo de 1 (problema mal-condicionado), ganho quadrático é enorme (k_GS ≈ k_J / 2).",
                                  "learningObjective": "Dominar a vantagem assintótica de convergência do Gauss-Seidel em matrizes SPD.",
                                  "commonMistakes": [
                                    "Aplicar teorema sem SPD",
                                    "Confundir taxa linear com quadrática",
                                    "Ignorar 'assintótica' (inicial pode variar)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Destacar Vantagens Computacionais e Implementação Eficiente",
                                  "subSteps": [
                                    "Comparar custo por iteração: Jacobi requer 2 vetores (x_old, x_new), GS atualiza in-place (apenas 1 vetor).",
                                    "Calcular flops: GS ~ n^2/2 vs Jacobi ~ n^2 por iteração.",
                                    "Implementar ambos em código e medir tempo/memória para sistema 100x100.",
                                    "Discutir paralelização: Jacobi mais paralelo, mas GS sequencial mais rápido em série.",
                                    "Resumir vantagens: convergência 2x mais rápida + menos memória."
                                  ],
                                  "verification": "Implementar GS in-place e Jacobi com auxiliar, rodar e comparar iterações/tempo.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Sistema Ax=b com A SPD 50x50",
                                    "Profiler de tempo (timeit)"
                                  ],
                                  "tips": "Use arrays mutáveis em Python para GS; evite cópias desnecessárias.",
                                  "learningObjective": "Reconhecer eficiência de memória e custo do Gauss-Seidel sobre Jacobi.",
                                  "commonMistakes": [
                                    "Usar 2 vetores em GS desnecessariamente",
                                    "Ignorar overhead de memória em problemas grandes",
                                    "Confundir flops com tempo real"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva Ax = b onde A = [[4, -1, 0], [-1, 4, -1], [0, -1, 4]] (SPD), b = [1, 2, 1]^T, x0=[0,0,0]. Jacobi leva ~15 iterações para erro <1e-6; GS ~8 iterações, sem vetor extra, demonstrando convergência ~2x mais rápida.",
                              "finalVerifications": [
                                "Citar corretamente ρ(M_GS) = [ρ(M_J)]^2 para SPD.",
                                "Explicar ausência de vetor auxiliar no GS.",
                                "Comparar número de iterações em exemplo numérico.",
                                "Identificar cenários onde vantagem é máxima (ρ_J próximo de 1).",
                                "Discutir limitações (não paraleloizável facilmente).",
                                "Implementar GS in-place corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da taxa assintótica quadrática.",
                                "Correta identificação de condições (SPD simétrica positiva definida).",
                                "Análise quantitativa via exemplo (iterações/tempo).",
                                "Compreensão de trade-offs computacionais (memória vs paralelismo).",
                                "Clareza na explicação verbal das vantagens.",
                                "Ausência de erros comuns como confusão de fórmulas."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação eficiente em Python/NumPy para sistemas grandes.",
                                "Física Computacional: Solvers em simulações de calor/difusão (PDEs elípticas).",
                                "Otimização: Relação com métodos multiplicativos em programação quadrática.",
                                "Engenharia: Análise de estruturas (matrizes de rigidez SPD).",
                                "Ciência de Dados: Pré-condicionadores em ML para regressão linear."
                              ],
                              "realWorldApplication": "Em simulações de Dinâmica de Fluidos Computacional (CFD), sistemas lineares massivos de equações de Navier-Stokes discretizadas são SPD; Gauss-Seidel acelera convergência em solvers multigrid, reduzindo tempo de simulação em aeronáutica e previsão climática."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.3.3",
                            "name": "Realizar experimentos comparativos",
                            "description": "Executar simulações numéricas comparando número de iterações e tempo de CPU para ambos métodos em sistemas de teste, analisando resíduos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e sistemas de teste",
                                  "subSteps": [
                                    "Instalar bibliotecas necessárias como NumPy, SciPy e Matplotlib em Python.",
                                    "Definir matrizes A simétricas positivas definidas e vetor b para 2-3 sistemas de teste de tamanhos variados (ex: n=10, 50, 100).",
                                    "Calcular a solução exata usando decomposição LU para referência futura.",
                                    "Configurar tolerância para convergência (ex: 1e-6) e limite máximo de iterações (ex: 1000)."
                                  ],
                                  "verification": "Verificar se as matrizes são SPD (autovalores positivos) e se o ambiente roda sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python 3+, NumPy, SciPy, Jupyter Notebook",
                                  "tips": "Use matrizes tridiagonais para testes iniciais, pois convergem bem com Jacobi/Gauss-Seidel.",
                                  "learningObjective": "Configurar corretamente problemas de teste para métodos iterativos.",
                                  "commonMistakes": "Escolher matrizes não SPD, levando a divergência; ignorar normalização de resíduos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar métodos Jacobi e Gauss-Seidel",
                                  "subSteps": [
                                    "Codificar o método Jacobi: decompor A = D - L - U, iterar x^{(k+1)} = D^{-1}(b + (L+U)x^{(k)}).",
                                    "Codificar Gauss-Seidel: iterar x^{(k+1)} = D^{-1}(b - (L)x^{(k+1)} - U x^{(k)}).",
                                    "Adicionar loops para contar iterações até ||r|| < tol ou max_iter.",
                                    "Implementar medição de tempo CPU com time.perf_counter().",
                                    "Calcular resíduos r = b - A x em cada iteração."
                                  ],
                                  "verification": "Testar com sistema pequeno (2x2) e comparar com solução exata.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Código Python com funções jacobi() e gauss_seidel()",
                                  "tips": "Vetorize operações com NumPy para eficiência; use np.linalg.norm para resíduos.",
                                  "learningObjective": "Implementar corretamente algoritmos iterativos com controle de convergência.",
                                  "commonMistakes": "Confundir decomposição em Jacobi vs Gauss-Seidel; não zerar x inicial adequadamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar simulações e coletar dados",
                                  "subSteps": [
                                    "Rodar Jacobi e Gauss-Seidel para cada sistema de teste, registrando: iterações, tempo CPU, resíduo final.",
                                    "Repetir 5-10 vezes por método para média e desvio padrão do tempo CPU.",
                                    "Armazenar dados em DataFrame Pandas para fácil manipulação.",
                                    "Plotar curvas de convergência: log(resíduo) vs iterações para ambos métodos."
                                  ],
                                  "verification": "Tabelas mostram iterações e tempos; gráficos indicam convergência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Pandas, Matplotlib para plots e tabelas",
                                  "tips": "Use warm_start com solução anterior para simulações repetidas.",
                                  "learningObjective": "Coletar métricas empíricas de desempenho computacional.",
                                  "commonMistakes": "Não medir tempo CPU puro (excluir I/O); ignorar variabilidade em runs múltiplos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e comparar resultados",
                                  "subSteps": [
                                    "Comparar número médio de iterações: Gauss-Seidel tipicamente < Jacobi.",
                                    "Analisar speedup em tempo CPU e relação com tamanho n.",
                                    "Examinar resíduos: verificar se < tol e comparar curvas de decaimento.",
                                    "Calcular razões de aceleração (tempo_Jacobi / tempo_GS) e discutir spectral radius.",
                                    "Gerar relatório com tabelas, gráficos e conclusões."
                                  ],
                                  "verification": "Relatório destaca Gauss-Seidel mais eficiente em testes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Pandas para análise, Matplotlib/Seaborn para visualizações",
                                  "tips": "Use log-scale em plots de resíduos para melhor visualização.",
                                  "learningObjective": "Interpretar dados experimentais para validar teoria de convergência.",
                                  "commonMistakes": "Atribuir causalidade sem múltiplos testes; ignorar efeitos de precisão numérica."
                                }
                              ],
                              "practicalExample": "Para sistema Ax=b com A = [[4,1,0],[1,3,1],[0,1,2]], b=[5,7,4], solução exata x≈[1,2,1]. Jacobi leva ~20 iterações, Gauss-Seidel ~12, com GS 1.5x mais rápido em CPU.",
                              "finalVerifications": [
                                "Número de iterações GS < Jacobi em todos testes.",
                                "Resíduos finais < 1e-6 para ambos.",
                                "Tempo CPU médio GS menor que Jacobi por fator >1.2.",
                                "Gráficos mostram convergência mais rápida em GS.",
                                "Tabelas de dados reproduzíveis e sem erros numéricos.",
                                "Conclusões alinhadas com teoria (raio espectral)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da implementação (erro <1e-8 na solução).",
                                "Coleta completa de métricas (iterações, tempo, resíduos).",
                                "Análise quantitativa clara com tabelas/gráficos.",
                                "Interpretação correta de resultados teóricos vs empíricos.",
                                "Eficiência do código (tempo total <5s por teste grande).",
                                "Relatório bem estruturado e conciso."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação numérica em Python.",
                                "Estatística: Análise de médias e desvios em experimentos.",
                                "Física: Simulações em equações diferenciais discretizadas.",
                                "Engenharia de Software: Benchmarking de algoritmos."
                              ],
                              "realWorldApplication": "Em simulações CFD ou ML (resolução de sistemas em redes neurais), onde Gauss-Seidel acelera convergência em solvers iterativos para grandes matrizes esparsas, otimizando tempo em supercomputadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "totalSkills": 291
          }
        ],
        "totalSkills": 291
      }
    ]
  }
}